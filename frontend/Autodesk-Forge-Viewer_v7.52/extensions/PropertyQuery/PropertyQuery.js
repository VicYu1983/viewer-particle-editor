/*!
 * LMV v7.52.0
 * 
 * Copyright 2021 Autodesk, Inc.
 * All rights reserved.
 * 
 * This computer source code and related instructions and comments are the
 * unpublished confidential and proprietary information of Autodesk, Inc.
 * and are protected under Federal copyright and state trade secret law.
 * They may not be disclosed to, copied or used by any third party without
 * the prior written consent of Autodesk, Inc.
 * 
 * Autodesk Forge Viewer Usage Limitations:
 * 
 * The Autodesk Forge viewer can only be used to view files generated by
 * Autodesk Forge services. The Autodesk Forge Viewer JavaScript must be
 * delivered from an Autodesk hosted URL.
 */
Autodesk.Extensions.PropertyQuery =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./extensions/PropertyQuery/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./extensions/PropertyQuery/index.js":
/*!*******************************************!*\
  !*** ./extensions/PropertyQuery/index.js ***!
  \*******************************************/
/*! exports provided: PropertyQueryExtension */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PropertyQueryExtension", function() { return PropertyQueryExtension; });
/* harmony import */ var _query__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./query */ "./extensions/PropertyQuery/query.js");
function _typeof(obj) {"@babel/helpers - typeof";if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;};}return _typeof(obj);}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}function _get(target, property, receiver) {if (typeof Reflect !== "undefined" && Reflect.get) {_get = Reflect.get;} else {_get = function _get(target, property, receiver) {var base = _superPropBase(target, property);if (!base) return;var desc = Object.getOwnPropertyDescriptor(base, property);if (desc.get) {return desc.get.call(receiver);}return desc.value;};}return _get(target, property, receiver || target);}function _superPropBase(object, property) {while (!Object.prototype.hasOwnProperty.call(object, property)) {object = _getPrototypeOf(object);if (object === null) break;}return object;}function _inherits(subClass, superClass) {if (typeof superClass !== "function" && superClass !== null) {throw new TypeError("Super expression must either be null or a function");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}function _createSuper(Derived) {var hasNativeReflectConstruct = _isNativeReflectConstruct();return function _createSuperInternal() {var Super = _getPrototypeOf(Derived),result;if (hasNativeReflectConstruct) {var NewTarget = _getPrototypeOf(this).constructor;result = Reflect.construct(Super, arguments, NewTarget);} else {result = Super.apply(this, arguments);}return _possibleConstructorReturn(this, result);};}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === "object" || typeof call === "function")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return self;}function _isNativeReflectConstruct() {if (typeof Reflect === "undefined" || !Reflect.construct) return false;if (Reflect.construct.sham) return false;if (typeof Proxy === "function") return true;try {Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));return true;} catch (e) {return false;}}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}


var av = Autodesk.Viewing;
var namespace = AutodeskNamespace('Autodesk.Viewing.Extensions.PropertyQuery');

namespace.Query = _query__WEBPACK_IMPORTED_MODULE_0__["Query"];

/**
                          * Extension description
                          *
                          * The extension id is: 'Autodesk.PropertyQuery'
                          *
                          * @example
                          *   viewer.loadExtension('Autodesk.PropertyQuery', options)
                          *
                          * @memberof Autodesk.Viewing.Extensions
                          * @alias Autodesk.Viewing.Extensions.PropertyQuery
                          * @see {@link Autodesk.Viewing.Extension} for common inherited methods.
                          * @class
                          */
var PropertyQueryExtension = /*#__PURE__*/function (_av$Extension) {_inherits(PropertyQueryExtension, _av$Extension);var _super = _createSuper(PropertyQueryExtension);
  /**
                                                                                                                                                                                * Autodesk.PropertyQueryExtension constructor
                                                                                                                                                                                * @constructor
                                                                                                                                                                                * @param {Autodesk.Viewing.Viewer3D} viewer - Viewer instance.
                                                                                                                                                                                * @param {Object} [options] Options for the PropertyQueryExtension
                                                                                                                                                                                * @param {boolean} [options.someOption=false] This is how options should be documented
                                                                                                                                                                                */
  function PropertyQueryExtension(viewer, options) {var _this;_classCallCheck(this, PropertyQueryExtension);
    _this = _super.call(this, viewer, options);
    _this.modes = [];
    _this.mode = '';
    _this.name = 'PropertyQuery';
    console.warn(
    'This extension is currently under development. It will only work with models in the dev envirnoment.');return _this;

  }

  /**
     * Called by the viewer once for the lifetime of the extension (unload() ends it)
     * Perform all initializations here.
     * The viewer sends `EXTENSION_LOADED_EVENT` after the load succeeds.
     * @returns {boolean} True if the load was successful. Optionally, the function can return a Promise to indicate success (resolve) or failure (reject).
     * @memberof Autodesk.Viewing.Extensions.PropertyQuery
     * @alias Autodesk.Viewing.Extensions.PropertyQuery#deactivate
     * @private
     */_createClass(PropertyQueryExtension, [{ key: "load", value: function load()
    {
      _get(_getPrototypeOf(PropertyQueryExtension.prototype), "load", this).call(this);
      return true;
    }

    /**
       * Override the unload method to perform some cleanup of operations that were done in load.
       * This function will be invoked when viewer.unloadExtension("Autodesk.PropertyQuery") is called.
       * @returns {boolean} True if the load was successful. Optionally, the function can return a Promise to indicate success (resolve) or failure (reject).
       * @memberof Autodesk.Viewing.Extensions.PropertyQuery
       * @alias Autodesk.Viewing.Extensions.PropertyQuery#deactivate
       * @private
       */ }, { key: "unload", value: function unload()
    {
      _get(_getPrototypeOf(PropertyQueryExtension.prototype), "unload", this).call(this);
      return true;
    }

    /**
       * Override the activate method to enable the functionality of the extension.
       * @param [mode] - An optional mode that indicates a different way the extension can function.
       * @see {@link Autodesk.Viewing.Extension#getModes }
       * @returns {boolean} True if the extension activation was successful.
       * @alias Autodesk.Viewing.Extensions.PropertyQuery#activate
       */ }, { key: "activate", value: function activate(
    mode) {
      _get(_getPrototypeOf(PropertyQueryExtension.prototype), "activate", this).call(this, mode);
      return true;
    }

    /**
       * Override the deactivate method to disable the functionality of the extension.
       * @returns {boolean} True if the extension deactivation was successful.
       * @alias Autodesk.Viewing.Extensions.PropertyQuery#deactivate
       */ }, { key: "deactivate", value: function deactivate()
    {
      _get(_getPrototypeOf(PropertyQueryExtension.prototype), "deactivate", this).call(this);
      return true;
    }

    /**
       * Returns a new Query that can be used for building and requesting the associated properties.
       * @param {Object} [filter]
       * @param {String[]} [select]
       * @param {Object} [pagination]
       * @returns {Query}
       */ }, { key: "getQuery", value: function getQuery(
    filter, select, pagination) {
      return new _query__WEBPACK_IMPORTED_MODULE_0__["Query"](filter, select, pagination);
    }

    /**
       * Returns an array of promises that resolve once properties are received from the ModelDerivative properties:query API.
       * @example
       *  const ext = viewer.getExtension("Autodesk.PropertyQuery");
       *  const propPromises = ext.getProperties(viewer.getAggregateSelection());
       *  Promise.all(propPromises).then((resp) => {
       *      // Process properties
       *  });
       *
       * @param {Object[]|Object} objectlist - An array of objects. The object will will contain a Autodesk.Viewing.Model instance the selection array of dbIds. Example: [{model: Autodesk.Viewing.Model, selection: [Number, Number, ...]}]
       * @returns {Promises[]} - Returns an empty array if objectlist parameter missing. Otherwise, returns an array of promises that resolve with the property objects.
       */ }, { key: "getProperties", value: function getProperties(
    objectlist) {var _this2 = this;
      if (!objectlist) {
        return [];
      }
      objectlist = Array.isArray(objectlist) ? objectlist : [objectlist];

      // Currently the properties:query api requires dbIds to be passed in. Otherwise, the api responds with a 400 error
      if (objectlist.length === 0) {
        return [];
      }

      var promises = [];
      objectlist.forEach(function (item) {
        var model = item.model;
        var dbIds = item.selection;
        var filter = {
          list: {
            objectid: dbIds } };



        var pagination = {
          offset: 0,
          limit: dbIds.length };


        var query = _this2.getQuery(filter, null, pagination).build();

        var resourceNodes = model.getDocumentNode().search({ type: 'resource', role: 'graphics' });
        if (!Array.isArray(resourceNodes) || resourceNodes.length === 0) {
          return [];
        }
        var guid = resourceNodes[0].guid();
        var urn = model.getData().urn;

        promises.push(
        new Promise(function (resolve, reject) {
          _this2.requestProperties(urn, guid, query, resolve, reject);
        }));

      });

      return promises;
    }

    /**
       * Sends a request to the ModelDerivative properties:query api.
       * @param {String} urn - Model Urn
       * @param {String} guid - resource guid in the model
       * @param {Object} body - Query instance
       * @param {Function} onSuccess - callback when the request succeeded
       * @param {Function} onFailure - callback when the request failed
       * @returns {null}
       */ }, { key: "requestProperties", value: function requestProperties(
    urn, guid, body, onSuccess, onFailure) {
      if (!urn || !guid) {
        return;
      }

      var loadContext = av.endpoint.initLoadContext({});
      var url = urn.indexOf('urn:') !== 0 ? 'urn:' + urn : urn;
      av.Private.ViewingService.getProperties(loadContext, url, guid, body, onSuccess, onFailure);
    } }]);return PropertyQueryExtension;}(av.Extension);

namespace.PropertyQueryExtension = PropertyQueryExtension;

av.theExtensionManager.registerExtension('Autodesk.PropertyQuery', PropertyQueryExtension);

/***/ }),

/***/ "./extensions/PropertyQuery/query.js":
/*!*******************************************!*\
  !*** ./extensions/PropertyQuery/query.js ***!
  \*******************************************/
/*! exports provided: Query */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Query", function() { return Query; });
function _toConsumableArray(arr) {return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();}function _nonIterableSpread() {throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");}function _unsupportedIterableToArray(o, minLen) {if (!o) return;if (typeof o === "string") return _arrayLikeToArray(o, minLen);var n = Object.prototype.toString.call(o).slice(8, -1);if (n === "Object" && o.constructor) n = o.constructor.name;if (n === "Map" || n === "Set") return Array.from(o);if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);}function _iterableToArray(iter) {if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter);}function _arrayWithoutHoles(arr) {if (Array.isArray(arr)) return _arrayLikeToArray(arr);}function _arrayLikeToArray(arr, len) {if (len == null || len > arr.length) len = arr.length;for (var i = 0, arr2 = new Array(len); i < len; i++) {arr2[i] = arr[i];}return arr2;}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}var Filter = /*#__PURE__*/function () {
  function Filter(filter) {_classCallCheck(this, Filter);
    this._data = {};
    if (!filter) return;
    this.setList(filter.list);
    this.setPrefix(filter.prefix);
    this.setTerm(filter.term);
    this.setText(filter.text);
  }

  /**
     * Returns the filter data object
     * @returns {object|null} data object if it is populated, null otherwise
     */_createClass(Filter, [{ key: "getData", value: function getData()
    {
      return Object.keys(this._data).length > 0 ? this._data : null;
    }

    /**
       * Clears the filter's data object
       */ }, { key: "clear", value: function clear()
    {
      this._data = {};
    }

    /**
       * Adds a new entry for an attribute into a filter's list.
       * Currently the valid attributes are externalId and objectid
       * @example
       *  filter.addList("dbIds", [33, 44]);
       *  filter.addList("externalId", ["doc_982afc8a", "doc_afd75233"]);
       * @param {String} attribute - ex: "dbIds", "externalId"
       * @param {String[]|String|Number[]|Number} entry - number(s) for objectid and string(s) for externalId
       * @returns {boolean} - true if added, false otherwise
       */ }, { key: "addList", value: function addList(
    attribute, entry) {var _this = this;
      if (!attribute || !entry) {
        return false;
      }

      attribute = attribute.toLowerCase();
      switch (attribute) {
        case 'objectid':
        case 'objectids':
        case 'dbid':
        case 'dbids':
          attribute = 'objectid';
          break;
        case 'externalid':
        case 'externalids':
          attribute = 'externalId';
          break;
        default:
          // Invalid Type, return
          return false;}


      if (!Object.prototype.hasOwnProperty.call(this._data, 'list')) {
        this._data.list = {};
      }

      if (!Object.keys(this._data.list).includes(attribute)) {
        this._data.list[attribute] = [];
      }

      entry = Array.isArray(entry) ? entry : [entry];
      entry.forEach(function (e) {
        if (!_this._data.list[attribute].includes(e)) {
          _this._data.list[attribute].push(e);
        }
      });

      return true;
    }

    /**
       * Removes a single attribute from the list.
       * @example
       *  // Remove 33 from the objectid array
       *  filter.removeList("dbId", 33);
       *
       *  // Remove all entries for "externalId"
       *  filter.removeList("externalId");
       *
       *  // Clear the entire list
       *  filter.removeList();
       * @param {String} attribute - ex: "dbId(s)", "externalId"
       * @param {String|Number} entry - number for dbId(s) and string for externalId
       * @returns {Boolean} - true if removed
       */ }, { key: "removeList", value: function removeList(
    attribute, entry) {
      if (!attribute && !entry) {
        delete this._data.list;
        return true;
      }

      attribute = attribute.toLowerCase();
      switch (attribute) {
        case 'objectid':
        case 'objectids':
        case 'dbid':
        case 'dbids':
          attribute = 'objectid';
          break;
        case 'externalid':
        case 'externalids':
          attribute = 'externalId';
          break;
        default:
          // Invalid Type, return
          return false;}


      if (Object.prototype.hasOwnProperty.call(this._data.list, attribute)) {
        if (!entry) {
          delete this._data.list[attribute];
          return true;
        }
        var existingIndex = this._data.list[attribute].indexOf(entry);
        if (existingIndex > -1) {
          this._data.list[attribute].splice(existingIndex, 1);
          return true;
        }
      }

      return false;
    }

    /**
       * This parameter should contain a list of exact values for a specific object field.
       * The query results returns objects that must contain the specified field and the values of the field should match one of the defined values.
       * @example
       * {
       *  "externalId": [ "doc_982afc8a", "doc_afd75233" ],
       *  // "dbIds": [33, 53],
       * }
       * @param {Object} newList - list object. see example above
       * @returns {Boolean} - true if the new list object was set, false otherwise.
       */ }, { key: "setList", value: function setList(
    newList) {var _this2 = this;
      if (!newList) return false;
      // Remove the existing list entries
      this.removeList();
      var keys = Object.keys(newList);
      keys.forEach(function (key) {
        _this2.addList(key, newList[key]);
      });
      return true;
    }

    /**
       * Adds a prefix to the filter. This query clause returns objects that must contain a specific attribute whose values should contain a specific prefix (case insensitive).
       * @example
       *  filter.addPrefix('name', 'Basic Wall [');
       * @param {String} attribute - currently only "name" is supported
       * @param {String} entry - Partial string to search for in the properties
       * @returns {Boolean} - true if the prefix was added
       */ }, { key: "addPrefix", value: function addPrefix(
    attribute, entry) {
      if (!Object.prototype.hasOwnProperty.call(this._data, 'prefix')) {
        this._data.prefix = {};
      }

      // Currently the property:query api only supports the name attribute.
      this._data.prefix[attribute] = entry;
      return true;
    }

    /**
       * Removes an existing prefix.
       * @example
       *  // Removes a single prefix
       *  filter.removePrefix('name');
       *
       *  // Removes all prefixes
       *  filter.removePrefix();
       * @param {String} attribute - currently only "name" is supported
       * @returns {Boolean} - true if the prefix was removed
       */ }, { key: "removePrefix", value: function removePrefix(
    attribute) {
      if (!attribute) {
        delete this._data.prefix;
      } else if (Object.prototype.hasOwnProperty.call(this._data.prefix, attribute)) {
        delete this._data.prefix[attribute];
      } else {
        return false;
      }
      return true;
    }

    /**
       * Sets the prefix data. This method will override the existing prefix filter.
       * @example
       * {
       *  "name": "Basic Wall ["
       * }
       * @param {Object} newPrefix - see example above
       * @returns {Boolean} - true if prefix filter was set, false otherwise
       */ }, { key: "setPrefix", value: function setPrefix(
    newPrefix) {
      if (!newPrefix) return false;
      this.removePrefix();
      for (var attribute in newPrefix) {
        this.addPrefix(attribute, newPrefix[attribute]);
      }

      return true;
    }

    /**
       * Adds a term to the filter. This query clause returns objects that contain a specific object field and the values of the field should match an exact value (case insensitive)
       * @example
       *  filter.addTerm('name', 'Rectangular');
       * @param {String} attribute - currently only "name" is supported
       * @param {String} entry - String to search for in the properties
       * @returns {Boolean} - true if the term was added
       */ }, { key: "addTerm", value: function addTerm(
    attribute, entry) {
      if (!Object.prototype.hasOwnProperty.call(this._data, 'term')) {
        this._data.term = {};
      }

      // Currently the property:query api only supports the name attribute.
      this._data.term[attribute] = entry;
      return true;
    }

    /**
       * Removes an existing term.
       * @example
       *  // Removes a single term
       *  filter.removeTerm('name');
       *
       *  // Removes all terms
       *  filter.removeTerm();
       * @param {String} attribute - currently only "name" is supported
       * @returns {Boolean} - true if the term was removed
       */ }, { key: "removeTerm", value: function removeTerm(
    attribute) {
      if (!attribute) {
        delete this._data.term;
      } else if (Object.prototype.hasOwnProperty.call(this._data.term, attribute)) {
        delete this._data.term[attribute];
      } else {
        return false;
      }
      return true;
    }

    /**
       * Sets the term data. This method will override the existing term filter.
       * @example
       * {
       *  "name": "Rectangular"
       * }
       * @param {Object} newTerm - see example above
       * @returns {Boolean} - true if term filter was set, false otherwise
       */ }, { key: "setTerm", value: function setTerm(
    newTerm) {
      if (!newTerm) return false;
      this.removeTerm();
      for (var attribute in newTerm) {
        this.addTerm(attribute, newTerm[attribute]);
      }

      return true;
    }

    /**
       * Adds a text to the filter. This query clause contains multiple terms for a specific object field. The query result returns objects that should contain the specified field and values of the field should contain one or more terms defined (case insensitive). Each term need be separated by the ASCII whitespace character and a maximum of 50 terms is allowed in one query.
       * @example
       *  filter.addText('properties.Material', 'Aluminum Steel');
       * @param {String} attribute - example: properties.Material
       * @param {String} entry - String to search for in the properties
       * @returns {Boolean} - true if the text was added
       */ }, { key: "addText", value: function addText(
    attribute, entry) {
      if (!Object.prototype.hasOwnProperty.call(this._data, 'text')) {
        this._data.text = {};
      }

      // Currently the property:query api only supports the name attribute.
      this._data.text[attribute] = entry;
      return true;
    }

    /**
       * Removes an existing text.
       * @example
       *  // Removes a single text
       *  filter.removeTerm('properties.Material');
       *
       *  // Removes all texts
       *  filter.removeTerm();
       * @param {String} attribute - currently only "name" is supported
       * @returns {Boolean} - true if the term was removed
       */ }, { key: "removeText", value: function removeText(
    attribute) {
      if (!attribute) {
        delete this._data.text;
      } else if (Object.prototype.hasOwnProperty.call(this._data.text, attribute)) {
        delete this._data.text[attribute];
      } else {
        return false;
      }
      return true;
    }

    /**
       * Sets the text data. This method will override the existing text filter.
       * @example
       * {
       *  "properties.Material": "Aluminum Steel"
       * }
       * @param {Object} newText - see example above
       * @returns {Boolean} - true if added, false otherwise
       */ }, { key: "setText", value: function setText(
    newText) {
      if (!newText) return false;
      this.removeText();
      for (var attribute in newText) {
        this.addText(attribute, newText[attribute]);
      }
      return true;
    } }]);return Filter;}();var


Fields = /*#__PURE__*/function () {
  function Fields(fields) {_classCallCheck(this, Fields);
    this._data = [];
    if (!fields) return;
    this.include(fields);
  }

  /**
     * Returns the fields data array
     * @returns {array|null} data array if it is populated, null otherwise
     */_createClass(Fields, [{ key: "getData", value: function getData()
    {
      return Object.keys(this._data).length > 0 ? this._data : null;
    }

    /**
       * The attribute(s) define a set of object fields which will be searched.
       * @example
       *  fields.include(["objectid", "name", "properties.Energy*", "properties.Version", "properties.*.Version", "properties.Dimensions"]);
       * @param {String|String[]} attribute - valid attributes: 'objectid', 'name', 'externalId', 'properties'
       * @returns {Boolean} - true if added, false otherwise
       */ }, { key: "include", value: function include(
    attribute) {var _this3 = this;
      if (!attribute) return false;
      var validFields = ['objectid', 'name', 'externalId', 'properties'];
      var included = false;

      attribute = Array.isArray(attribute) ? attribute : [attribute];
      attribute.forEach(function (attr) {
        var tokenizedField = attr.split('.');
        // We might want to process the input.
        if (!_this3._data.includes(attr) && validFields.includes(tokenizedField[0])) {
          _this3._data.push(attr);
          included = true;
        }
      });

      return included;
    }

    /**
       * Removes the existing attribute from the fields array.
       * @example
       *  // Removed two attributes from the fields array
       *  fields.exclude(['objectid', 'properties']);
       *
       *  // Clear the fields array
       *  fields.exclude();
       *
       * @param {String[]|String} attribute - valid attributes: 'objectid', 'name', 'externalId', 'properties'
       * @returns {Boolean} - true if removed, false otherwise
       */ }, { key: "exclude", value: function exclude(
    attribute) {
      if (!attribute) {
        this._data = [];
        return true;
      }

      var excluded = false;
      attribute = Array.isArray(attribute) ? attribute : [attribute];

      var fields = _toConsumableArray(this._data);
      attribute.forEach(function (attr) {
        var attrIndex = fields.indexOf(attr);
        if (attrIndex > -1) {
          fields.splice(attrIndex, 1);
          excluded = true;
        }
      });

      this._data = fields;

      return excluded;
    } }]);return Fields;}();var


Pagination = /*#__PURE__*/function () {
  function Pagination(pagination) {_classCallCheck(this, Pagination);
    this._data = {};
    if (!pagination) return;
    this.setOffset(pagination.offset);
    this.setLimit(pagination.limit);
  }

  /**
     * Returns the pagination data object
     * @returns {object|null} data object if it is populated, null otherwise
     */_createClass(Pagination, [{ key: "getData", value: function getData()
    {
      return Object.keys(this._data).length > 0 ? this._data : null;
    }

    /**
       * Clears the pagination data object.
       */ }, { key: "clear", value: function clear()
    {
      this._data = {};
    }

    /**
       * Sets the pagination offset. 
       * @example
       *  pagination.setOffset(2);
       * @param {Number} offset - The offset from the start of the collection to the first entry in the page. 0 based.
       * @returns {Boolean} - true if offset added, false otherwise
       */ }, { key: "setOffset", value: function setOffset(
    offset) {
      if (offset == null) return false;
      this._data.offset = offset;
      return true;
    }

    /**
       * Sets the pagination limit. 
       * @example
       *  pagination.setLimit(30);
       * @param {Number} limit - Sets the maximum number of objects that MAY be returned. A query MAY return fewer than the value of limit due to filtering. Value should be between 1 to 1000.
       * @returns {Boolean} - true if limit added, false otherwise
       */ }, { key: "setLimit", value: function setLimit(
    limit) {
      if (limit == null) return false;
      this._data.limit = limit;
      return true;
    } }]);return Pagination;}();


var Query = /*#__PURE__*/function () {
  function Query(filter, fields, pagination) {_classCallCheck(this, Query);
    this.filter = new Filter(filter);
    this.fields = new Fields(fields);
    this.pagination = new Pagination(pagination);
  }

  /**
     * Adds a filter type.
     * @example
     *  // Add a list
     *  query.add('list', 'dbIds', [33, 44]);
     * 
     *  // Add a prefix
     *  query.add('prefix', 'name', 'Basic Wall [');
     * 
     *  // Add a term
     *  query.add('term', 'name', 'Rectangular');
     * 
     *  // Add a text
     *  query.add('text', 'properties.Material', 'Aluminum Steel');
     * @param {String} type - The type of filter.
     * @param {String} attribute - The attribute that is valid with the type.
     * @param {String[]|String|Number[]|Number} entry - the entry to add for the specific type filter attribute.
     * @returns {boolean} - true if added, false otherwise
     */_createClass(Query, [{ key: "add", value: function add(
    type, attribute, entry) {
      switch (type) {
        case 'list':
          return this.filter.addList(attribute, entry);
        case 'prefix':
          return this.filter.addPrefix(attribute, entry);
        case 'term':
          return this.filter.addTerm(attribute, entry);
        case 'text':
          return this.filter.addText(attribute, entry);
        default:
          return false;}

    }

    /**
       * Removes a filter type.
       * @example
       *  // Remove a list dbId entry
       *  query.remove('list', 'dbIds', [33]);
       * 
       *  // Remove all dbIds
       *  query.remove('list', 'dbIds');
       * 
       *  // Remove the whole list
       *  query.remove('list');
       * 
       *  // Remove a prefix
       *  query.remove('prefix', 'name');
       * 
       *  // Remove a term
       *  query.remove('term', 'name');
       * 
       *  // Remove a text
       *  query.remove('text', 'properties.Material');
       * 
       *  // To clear the whole filter
       *  query.remove();
       * 
       * @param {String} [type] - The type of filter.
       * @param {String} [attribute] - The attribute that is valid with the type.
       * @param {String[]|String|Number[]|Number} [entry] - the entry to remove for the specific type filter attribute.
       * @returns {boolean} - true if removed, false otherwise
       */ }, { key: "remove", value: function remove(
    type, attribute, entry) {
      // If no parameters are passed in, clear the whole filter.
      if (!type && !attribute && !entry) {
        this.filter.clear();
      }

      switch (type) {
        case 'list':
          return this.filter.removeList(attribute, entry);
        case 'prefix':
          return this.filter.removePrefix(attribute);
        case 'term':
          return this.filter.removeTerm(attribute);
        case 'text':
          return this.filter.removeText(attribute);
        default:
          return false;}

    }

    /** The attribute(s) define a set of object fields which will be searched.
       * @example
       *  query.include(["objectid", "name", "properties.Energy*", "properties.Version", "properties.*.Version", "properties.Dimensions"]);
       * @param {String|String[]} attribute - valid attributes: 'objectid', 'name', 'externalId', 'properties'
       * @returns {Boolean} - true if included, false otherwise
       */ }, { key: "include", value: function include(
    attribute) {
      return this.fields.include(attribute);
    }

    /**
       * Removes the existing attribute from the fields array.
       * @example
       *  // Remove two attributes from the fields array
       *  query.exclude(['objectid', 'properties']);
       *
       *  // Clear the fields array
       *  query.exclude();
       *
       * @param {String[]|String} attribute - valid attributes: 'objectid', 'name', 'externalId', 'properties'
       * @returns {Boolean} - true if removed, false otherwise
       */ }, { key: "exclude", value: function exclude(
    attribute) {
      return this.fields.exclude(attribute);
    }

    /**
       * Set the offset and limit to paginate the poperties.
       * If both parameters are missing the pagination object is cleared.
       * @param {Number|null} offset - The offset from the start of the collection to the first entry in the page. 0 based.
       * @param {Number|null} limit - Sets the maximum number of objects that MAY be returned. A query MAY return fewer than the value of limit due to filtering. Value should be between 1 to 1000.
       * @returns {Boolean} - true if cleared or set.
       */ }, { key: "paginate", value: function paginate(
    offset, limit) {
      if (offset == null && limit == null) {
        this.pagination.clear();
        return true;
      }
      this.pagination.setLimit(limit);
      this.pagination.setOffset(offset);
      return true;
    }

    /**
       * Builds the query object.
       * @returns {Object} - the query object that can be passed to the ModelDerivative properties:query api
       */ }, { key: "build", value: function build()
    {
      var query = {};
      var filter = this.filter.getData();
      var fields = this.fields.getData();
      var pagination = this.pagination.getData();

      if (filter) {
        query.filter = filter;
      }

      if (fields) {
        query.select = fields;
      }

      if (pagination) {
        query.pagination = pagination;
      }

      return query;
    } }]);return Query;}();

/***/ })

/******/ });
//# sourceMappingURL=PropertyQuery.js.map