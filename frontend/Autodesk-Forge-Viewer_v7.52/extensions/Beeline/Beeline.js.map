{"version":3,"file":"Beeline/Beeline.js","sources":["webpack://Autodesk.Extensions.[name]/webpack/bootstrap","webpack://Autodesk.Extensions.[name]/./extensions/Beeline/Beeline.js","webpack://Autodesk.Extensions.[name]/./extensions/Beeline/BeelineTool.js"],"sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./extensions/Beeline/Beeline.js\");\n","import { BeelineTool } from './BeelineTool';\n\n'use strict';\n\nexport function BeelineExtension(viewer, options) {\n  Autodesk.Viewing.Extension.call(this, viewer, options);\n  this.name = \"beeline\";\n}\n\nBeelineExtension.prototype = Object.create(Autodesk.Viewing.Extension.prototype);\nBeelineExtension.prototype.constructor = BeelineExtension;\n\nvar proto = BeelineExtension.prototype;\n\nproto.load = function () {\n  var self = this;\n  var viewer = this.viewer;\n  var AVU = Autodesk.Viewing.UI;\n\n  // Register tool\n  this.tool = new BeelineTool(viewer.impl, viewer);\n  viewer.toolController.registerTool(this.tool);\n\n  // Add hotkey\n  var previousTool;\n  function onPress() {\n    previousTool = viewer.getActiveNavigationTool();\n    viewer.setActiveNavigationTool(self.tool.getName());\n    return true;\n  }\n  function onRelease() {\n    viewer.setActiveNavigationTool(previousTool ? previousTool : viewer.defaultNavigationToolName);\n    return true;\n  }\n  this.HOTKEYS_ID = \"Autodesk.Beeline.Hotkeys\";\n  var hotkeys = [\n  {\n    keycodes: [\n    Autodesk.Viewing.KeyCode.CONTROL,\n    Autodesk.Viewing.KeyCode.ALT],\n\n    onPress: onPress,\n    onRelease: onRelease }];\n\n\n  viewer.getHotkeyManager().pushHotkeys(this.HOTKEYS_ID, hotkeys);\n\n  // Register listeners\n  this.onToolChanged = function (e) {\n    if (e.toolName.indexOf('beeline') === -1) {\n      return;\n    }\n\n    if (self.beelineButton) {\n      var state = e.active ? AVU.Button.State.ACTIVE : AVU.Button.State.INACTIVE;\n      self.beelineButton.setState(state);\n    }\n  };\n\n  viewer.addEventListener(Autodesk.Viewing.TOOL_CHANGE_EVENT, this.onToolChanged);\n\n  return true;\n};\n\nproto.onToolbarCreated = function (toolbar)\n{\n  var self = this;\n  var viewer = this.viewer;\n\n  var AVU = Autodesk.Viewing.UI;\n  var navTools = toolbar.getControl(Autodesk.Viewing.TOOLBAR.NAVTOOLSID);\n\n  var beelineButtonId = \"toolbar-beelineTool\";\n\n  /*var options = {\n                                                   defaultTooltipValue: \"Walk to (double-click to Walk through)\"\n                                               };*/\n  var beelineButton = new AVU.Button(beelineButtonId);\n  beelineButton.setToolTip('Walk to');\n  beelineButton.setIcon(\"adsk-icon-walk\");\n  beelineButton.onClick = function () {\n    if (self.activeStatus) {\n      self.deactivate();\n    } else {\n      self.activate();\n    }\n  };\n  this.beelineButton = beelineButton;\n\n  var cameraSubmenuTool = navTools.getControl('toolbar-cameraSubmenuTool');\n  if (cameraSubmenuTool) {\n    navTools.addControl(this.beelineButton, { index: navTools.indexOf(cameraSubmenuTool.getId()) });\n  } else {\n    navTools.addControl(this.beelineButton);\n  }\n\n  // Add beeline settings to the viewer's setting panel.\n  var that = this;\n  var addViewerUIOptions = function addViewerUIOptions() {\n    viewer.removeEventListener(Autodesk.Viewing.SETTINGS_PANEL_CREATED_EVENT, addViewerUIOptions);\n\n    var navTab = Autodesk.Viewing.Extensions.ViewerSettingTab.Navigation;\n    var viewerOptions = viewer.getSettingsPanel(true);\n\n    viewerOptions.addLabel(navTab, \"Look Direction\");\n\n    that.viewerOption_LookHorId = viewerOptions.addCheckbox(navTab, \"Reverse horizontal look direction\", \"Toggles direction of left and right camera movement\", false, function (checked) {\n      viewer.setReverseHorizontalLookDirection(checked);\n    }, \"reverseHorizontalLookDirection\");\n\n    that.viewerOption_LookVertId = viewerOptions.addCheckbox(navTab, \"Reverse vertical look direction\", \"Toggles direction of up and down camera movement\", false, function (checked) {\n      viewer.setReverseVerticalLookDirection(checked);\n    }, \"reverseVerticalLookDirection\");\n\n  };\n\n  if (this.viewer.getSettingsPanel(false)) {\n    addViewerUIOptions();\n  } else {\n    this.viewer.addEventListener(Autodesk.Viewing.SETTINGS_PANEL_CREATED_EVENT, addViewerUIOptions);\n  }\n};\n\nproto.unload = function () {\n  var viewer = this.viewer;\n\n  // Remove listeners\n  viewer.removeEventListener(Autodesk.Viewing.TOOL_CHANGE_EVENT, this.onToolChanged);\n  this.onToolChanged = undefined;\n\n  // Remove hotkey\n  viewer.getHotkeyManager().popHotkeys(this.HOTKEYS_ID);\n\n  // Remove the UI\n  if (this.beelineButton) {\n    this.beelineButton.removeFromParent();\n    this.beelineButton = null;\n  }\n\n  // Remove the options from the Viewer SettingsPanel.\n  if (viewer.getSettingsPanel) {\n    viewer.getSettingsPanel(false).removeCheckbox(this.viewerOption_LookHorId);\n    viewer.getSettingsPanel(false).removeCheckbox(this.viewerOption_LookVertId);\n  }\n\n  //Uh, why does the viewer need to keep track of this in addition to the tool stack?\n  if (viewer.getActiveNavigationTool() == this.tool.getName())\n  viewer.setActiveNavigationTool();\n\n  // Deregister tool\n  viewer.toolController.deregisterTool(this.tool);\n  this.tool = null;\n\n  return true;\n};\n\nproto.activate = function () {\n  if (!this.activeStatus) {\n    this.viewer.setActiveNavigationTool(this.tool.getName());\n    this.activeStatus = true;\n  }\n  return true;\n};\n\nproto.deactivate = function () {\n  if (this.activeStatus) {\n    this.viewer.setActiveNavigationTool();\n    this.activeStatus = false;\n  }\n  return true;\n};\n\nAutodesk.Viewing.theExtensionManager.registerExtension('Autodesk.Beeline', BeelineExtension);","\nvar avp = Autodesk.Viewing.Private;\n\n// /** @constructor */\n//\n// TODO: Pass in the api instead of the impl, don't use the impl object.\n//\nexport function BeelineTool(viewerImpl, viewerApi)\n{\n  var MODE = {\n    GO_TO: 0,\n    PASS_THROUGH: 1,\n    DEFAULT: 0 };\n\n\n  // Constants\n  var kDefaultFlightDuration = 1000; // milliseconds\n  var kLookSensitivity = 0.8;\n  var kMaxFocalLength = 28;\n  var kDampingFactor = 0.7;\n\n  // States\n  var kStartState = 0;\n  var kFlightState = 1;\n\n  var self = this;\n  var _viewerapi = viewerApi;\n  var _container = viewerApi.container;\n  var _autocam = viewerApi.autocam;\n  var _navapi = viewerApi.navigation;\n  var _viewerUtilities = viewerApi.utilities;\n  var _names = [\"beeline\"];\n\n  var _state = kStartState;\n  var _isDragging = false;\n  var _mouseButtons = 0;\n  var _flightStartTime = null;\n  var _flightDuration = null;\n  var _intersectPointNear = new THREE.Vector3();\n  var _intersectPointFar = new THREE.Vector3();\n  var _flightStartPosition = new THREE.Vector3();\n  var _flightEndPosition = new THREE.Vector3();\n  var _haltAnimation = false;\n  var _mouseXY = new THREE.Vector3();\n  var _previousXY = new THREE.Vector3();\n\n  var _expectedCameraState = null;\n  var _touchType = null;\n\n  function screenModeChanged()\n  {\n    self.revertToStartState();\n  }\n\n  // Utility methods\n  function getCameraState(camera) {\n    var state = {};\n\n    state.target = camera.target.clone();\n    state.worldup = camera.worldup.clone();\n\n    state.position = camera.position.clone();\n    state.up = camera.up.clone();\n\n    var props = ['isPerspective', 'fov', 'zoom', 'aspect', 'left', 'right', 'top', 'bottom'];\n    for (var i = 0; i < props.length; i++) {\n      state[props[i]] = camera[props[i]];\n    }\n\n    return state;\n  }\n\n  function compareCameraToState(camera, state) {\n    var result = camera.target.equals(state.target) &&\n    camera.position.equals(state.position) &&\n    camera.worldup.equals(state.worldup) &&\n    camera.up.equals(state.up);\n\n    if (!result) {\n      return false;\n    }\n\n    var props = ['isPerspective', 'fov', 'zoom', 'aspect', 'left', 'right', 'top', 'bottom'];\n    for (var i = 0; i < props.length; i++) {\n      if (camera[props[i]] !== state[props[i]]) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  function getIntersectionPoints(normalizedScreenPosition) {\n    var viewportVec = new THREE.Vector3(normalizedScreenPosition.x, normalizedScreenPosition.y, 1.0);\n    var result = viewerImpl.hitTestViewport(viewportVec.clone(), false);\n\n    if (!result || !result.intersectPoint) {\n      return [];\n    }\n\n    var caster = new THREE.Raycaster();\n    var vector = viewportVec.clone();\n    var camera = viewerImpl.camera;\n    var end = new THREE.Vector3(vector.x, vector.y, 1.0);\n\n    vector.z = -1.0;\n    vector = vector.unproject(camera);\n    end = end.unproject(camera);\n    end.sub(vector).normalize();\n    caster.set(_navapi.isPerspective ? camera.position : vector, end);\n\n    var intersects = [];\n\n    // Get intersection points\n    var frags = result.fragId instanceof Array ? result.fragId : [result.fragId];\n    for (var i = 0; i < frags.length; i++) {\n      var mesh = viewerImpl.getRenderProxy(viewerApi.model, frags[i]);\n\n      avp.VBIntersector.meshRayCast(mesh, caster, intersects);\n    }\n\n    intersects.sort(function (a, b) {return a.distance - b.distance;});\n\n    return intersects;\n  }\n\n  function prepareCamera() {\n    if (!_navapi.isPerspective) {\n      _navapi.toPerspective();\n      _viewerUtilities.activatePivot(false);\n    }\n    if (_navapi.getFocalLength() > kMaxFocalLength) {\n      _navapi.setFocalLength(kMaxFocalLength, true);\n    }\n  }\n\n  // Tool methdos\n  this.getNames = function ()\n  {\n    return _names;\n  };\n\n  this.getName = function ()\n  {\n    return _names[0];\n  };\n\n  this.activate = function ()\n  {\n    _mouseButtons = 0;\n    viewerApi.addEventListener(Autodesk.Viewing.FULLSCREEN_MODE_EVENT, screenModeChanged);\n    _autocam.userLookSpeed = kLookSensitivity;\n    this.showHUDMessage(true);\n  };\n\n  this.deactivate = function ()\n  {\n    viewerApi.removeEventListener(Autodesk.Viewing.FULLSCREEN_MODE_EVENT, screenModeChanged);\n    this.revertToStartState();\n    this.showHUDMessage(false);\n  };\n\n  this.getCursor = function ()\n  {\n    if (_isDragging) {\n      return \"url(data:image/x-icon;base64,iVBORw0KGgoAAAANSUhEUgAAABwAAAAcCAQAAADYBBcfAAAACXBIWXMAABYlAAAWJQFJUiTwAAADGGlDQ1BQaG90b3Nob3AgSUNDIHByb2ZpbGUAAHjaY2BgnuDo4uTKJMDAUFBUUuQe5BgZERmlwH6egY2BmYGBgYGBITG5uMAxIMCHgYGBIS8/L5UBFTAyMHy7xsDIwMDAcFnX0cXJlYE0wJpcUFTCwMBwgIGBwSgltTiZgYHhCwMDQ3p5SUEJAwNjDAMDg0hSdkEJAwNjAQMDg0h2SJAzAwNjCwMDE09JakUJAwMDg3N+QWVRZnpGiYKhpaWlgmNKflKqQnBlcUlqbrGCZ15yflFBflFiSWoKAwMD1A4GBgYGXpf8EgX3xMw8BSMDVQYqg4jIKAUICxE+CDEESC4tKoMHJQODAIMCgwGDA0MAQyJDPcMChqMMbxjFGV0YSxlXMN5jEmMKYprAdIFZmDmSeSHzGxZLlg6WW6x6rK2s99gs2aaxfWMPZ9/NocTRxfGFM5HzApcj1xZuTe4FPFI8U3mFeCfxCfNN45fhXyygI7BD0FXwilCq0A/hXhEVkb2i4aJfxCaJG4lfkaiQlJM8JpUvLS19QqZMVl32llyfvIv8H4WtioVKekpvldeqFKiaqP5UO6jepRGqqaT5QeuA9iSdVF0rPUG9V/pHDBYY1hrFGNuayJsym740u2C+02KJ5QSrOutcmzjbQDtXe2sHY0cdJzVnJRcFV3k3BXdlD3VPXS8Tbxsfd99gvwT//ID6wIlBS4N3hVwMfRnOFCEXaRUVEV0RMzN2T9yDBLZE3aSw5IaUNak30zkyLDIzs+ZmX8xlz7PPryjYVPiuWLskq3RV2ZsK/cqSql01jLVedVPrHzbqNdU0n22VaytsP9op3VXUfbpXta+x/+5Em0mzJ/+dGj/t8AyNmf2zvs9JmHt6vvmCpYtEFrcu+bYsc/m9lSGrTq9xWbtvveWGbZtMNm/ZarJt+w6rnft3u+45uy9s/4ODOYd+Hmk/Jn58xUnrU+fOJJ/9dX7SRe1LR68kXv13fc5Nm1t379TfU75/4mHeY7En+59lvhB5efB1/lv5dxc+NH0y/fzq64Lv4T8Ffp360/rP8f9/AA0ADzT6lvFdAAAAIGNIUk0AAHolAACAgwAA+f8AAIDpAAB1MAAA6mAAADqYAAAXb5JfxUYAAAEtSURBVHja7JQxTkJBFEXPQ/xQEDG0ljRYSU1iLN2AtSWlC7Gw04QtGF2ApQVLIDY2hlgIDagJwWCOhf74JXxRYumbaib3ZO7c9zIhq1WBfzAfjJViDWPdYBq/w0pKITjhd7eGJwQkDu2I8rOFHYcmkqgDz4wfoeGZA01BHXtsbSla89ixZsH3an2LtpRUOQde28xFm17PgyPvVK1bl5yYEOtuq3rnyMQCXNJgiiTchuHCnhrGbYBMaXAJULGqlJz54O43bcFdH5xZUqpWJJWW7duza/tDmTWJbbv27Fs2PS2m1iZRNeGcI/aAEevOgCKnbAI7DNjjhUmk1ouf7xgHbLgF3MSzT7wCaxxSiW3hnsf4OngLotj3ILO74CoWTWzOIGcTXab4/6z+CnwbAGjXSZC++vLvAAAAAElFTkSuQmCC), auto\";\n    } else if (_mouseButtons <= 1) {\n      return \"url(data:image/x-icon;base64,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), auto\";\n    }\n\n    return null;\n  };\n\n  this.update = function () {\n    var camera = _navapi.getCamera();\n    _isDragging = false;\n\n    var moved = false;\n    if (_mouseButtons === 1) {\n      var deltaXY = _mouseXY.clone().sub(_previousXY);\n      if (deltaXY.x !== 0 || deltaXY.y !== 0) {\n        _isDragging = true;\n        _previousXY.x += deltaXY.x * kDampingFactor;\n        _previousXY.y += deltaXY.y * kDampingFactor;\n\n        var worldDotCamera = _navapi.getWorldUpVector().dot(_navapi.getCameraUpVector());\n        var horDirection = viewerApi.prefs.reverseHorizontalLookDirection ? -1 : 1;\n        var vertDirection = viewerApi.prefs.reverseVerticalLookDirection ? -1 : 1;\n\n        deltaXY.x *= worldDotCamera < 0 ? -horDirection : horDirection;\n        deltaXY.y *= vertDirection;\n\n        // Make sure we're synced with the camera\n        _autocam.sync(_navapi.getCamera());\n        _autocam.look(deltaXY);\n        moved = true;\n\n        _expectedCameraState = getCameraState(camera);\n      }\n    }\n    return moved;\n  };\n\n  // Beeline methods\n  this.revertToStartState = function ()\n  {\n    _viewerUtilities.pivotActive(false);\n    _state = kStartState;\n    _haltAnimation = true;\n  };\n\n  this.attemptFlight = function (normalizedScreenPosition, mode)\n  {\n    if (!_navapi.isActionEnabled('walk')) {\n      return;\n    }\n\n    var intersectionPoints = getIntersectionPoints(normalizedScreenPosition);\n\n    if (intersectionPoints.length > 0) {\n      _intersectPointNear = intersectionPoints[0].point;\n      _intersectPointFar = intersectionPoints[intersectionPoints.length - 1].point;\n      self.fly(kDefaultFlightDuration, mode);\n    }\n  };\n\n  this.fly = function (duration, mode)\n  {\n    // Pivot needs to be set before altering focal length to make it less jarring for the user. Changing the focal\n    // length alters the camera's position and we need the camera's position to calculate the far pivot. Instead,\n    // use approximation of where the far pivot will be (i.e. _intersectPointFar).\n    _viewerUtilities.setPivotPoint(mode === MODE.GO_TO ? _intersectPointNear : _intersectPointFar, true, true);\n    prepareCamera();\n\n    _flightStartPosition = _navapi.getPosition();\n    _flightDuration = duration;\n    switch (mode) {\n      case MODE.GO_TO:\n        // Fly 80% of the way there\n        _flightEndPosition = _flightStartPosition.clone().lerp(_intersectPointNear, 0.8);\n        break;\n\n      case MODE.PASS_THROUGH:\n        // Fly 2 near planes past the object.\n        var near = _autocam.camera.near * 2;\n        var distance = _intersectPointFar.clone().sub(_flightStartPosition).length();\n        var nearRatio = near / distance;\n\n        _viewerUtilities.setPivotPoint(_flightStartPosition.clone().lerp(_intersectPointFar, 1 + 10 * nearRatio), true, true);\n        _flightEndPosition = _flightStartPosition.clone().lerp(_intersectPointFar, 1 + nearRatio);\n        break;\n\n      default:\n        return;}\n\n\n    _state = kFlightState;\n\n    _haltAnimation = false;\n    _flightStartTime = null;\n\n    requestAnimationFrame(self.step);\n  };\n\n  // Animating the camera\n  this.step = function (timestamp)\n  {\n    var camera = _navapi.getCamera();\n\n    if (_haltAnimation) {\n      return;\n    }\n\n    if (_flightStartTime === null) {\n      _expectedCameraState = getCameraState(camera);\n\n      _flightStartTime = timestamp;\n    } else if (!compareCameraToState(camera, _expectedCameraState)) {\n      self.revertToStartState();\n      return;\n    }\n\n    var flightTime = timestamp - _flightStartTime;\n    var t = flightTime < _flightDuration ? flightTime / _flightDuration : 1;\n\n    var newPosition = _flightStartPosition.clone().lerp(_flightEndPosition, t);\n\n    // Keep target the same distance as the pivot\n    var viewVec = _navapi.getEyeVector();\n    viewVec.multiplyScalar(_navapi.getPivotPoint().sub(_navapi.getPosition()).length() / viewVec.length());\n\n    _navapi.setView(newPosition, viewVec.add(newPosition));\n\n    _expectedCameraState = getCameraState(camera);\n\n    _viewerUtilities.activatePivot(false);\n\n    if (flightTime < _flightDuration) {\n      requestAnimationFrame(self.step);\n    } else {\n      self.revertToStartState();\n    }\n  };\n\n  // ------------------------\n  // Event handler callbacks:\n  // These can use \"this\".\n\n  this.handleGesture = function (event)\n  {\n    Autodesk.Viewing.Private.HudMessage.dismiss();\n\n    switch (event.type) {\n\n      case \"dragstart\":\n        _touchType = \"drag\";\n        // Single touch, fake the mouse for now...\n        return this.handleButtonDown(event, 0);\n\n      case \"dragmove\":\n        return _touchType === \"drag\" ? this.handleMouseMove(event) : false;\n\n      case \"dragend\":\n        if (_touchType === \"drag\")\n        {\n          this.handleButtonUp(event, 0);\n          _touchType = null;\n          return true;\n        }\n        return false;}\n\n    return false;\n  };\n\n\n  this.handleButtonDown = function (event, button)\n  {\n    Autodesk.Viewing.Private.HudMessage.dismiss();\n\n    _mouseButtons += 1 << button;\n\n    if (button === 0) {\n      _previousXY.x = _mouseXY.x = event.canvasX;\n      _previousXY.y = _mouseXY.y = event.canvasY;\n      return true;\n    }\n    return false;\n  };\n\n  this.handleButtonUp = function (event, button)\n  {\n    _mouseButtons -= 1 << button;\n\n    if (button === 0) {\n      return true;\n    }\n    return false;\n  };\n\n  this.handleSingleClick = function (event, button)\n  {\n    Autodesk.Viewing.Private.HudMessage.dismiss();\n\n    // Anything besides LMB should revert viewer to initial state\n    if (button === 0) {\n      var normalizedScreenLocation = {\n        x: event.normalizedX,\n        y: event.normalizedY };\n\n\n      switch (_state) {\n        case kStartState:\n          self.attemptFlight(normalizedScreenLocation, MODE.GO_TO);\n          break;\n\n        case kFlightState:\n          self.revertToStartState();\n          break;\n\n        default:\n          break;}\n\n    } else {\n      this.revertToStartState();\n      return false;\n    }\n\n    return true;\n  };\n\n  this.handleSingleTap = function (event)\n  {\n    return this.handleSingleClick(event, 0);\n  };\n\n  this.handleDoubleTap = function (event)\n  {\n    if (event.pointers && event.pointers.length === 1) {\n      self.attemptFlight({ x: event.normalizedX, y: event.normalizedY }, MODE.PASS_THROUGH);\n      return true;\n    }\n    return false;\n  };\n\n  this.handleDoubleClick = function (event, button)\n  {\n    if (button === 0) {\n      self.attemptFlight({ x: event.normalizedX, y: event.normalizedY }, MODE.PASS_THROUGH);\n      return true;\n    }\n\n    return false;\n  };\n\n  this.handleMouseMove = function (event)\n  {\n    _mouseXY.x = event.canvasX;\n    _mouseXY.y = event.canvasY;\n\n    if (_mouseButtons === 1) {\n      prepareCamera();\n      return true;\n    }\n\n    return false;\n  };\n\n  this.handleBlur = function ()\n  {\n    // Reset things when we lose focus...\n    this.revertToStartState();\n    return false;\n  };\n\n  this.showOrthoWarningMessage = function ()\n  {\n    var messageSpecs = {\n      \"msgTitleKey\": \"Orthographic View Set\",\n      \"messageKey\": \"The view is set to Orthographic Beeline\",\n      \"messageDefaultValue\": \"The view is set to Orthographic. Using this tool will switch to Perspective.\" };\n\n    var closeCallback = function closeCallback() {}; // dummy callback function so that the 'X' is shown\n    Autodesk.Viewing.Private.HudMessage.displayMessage(_container, messageSpecs, closeCallback);\n  };\n\n  this.showFocalWarningMessage = function ()\n  {\n    var messageSpecs = {\n      \"msgTitleKey\": \"Long Focal Length View Set\",\n      \"messageKey\": \"The view is set to a long focal length\",\n      \"messageDefaultValue\": \"This view has a long focal length. Using this tool will set a short focal length.\" };\n\n    var closeCallback = function closeCallback() {}; // dummy callback function so that the 'X' is shown\n    Autodesk.Viewing.Private.HudMessage.displayMessage(_container, messageSpecs, closeCallback);\n  };\n\n  this.watchCamera = function ()\n  {\n    // If camera changed to ORTHO and we are still in Beeline mode\n    // put up the warning message that the system will switch to perspective.\n    // Similarly, warn for long focal length.\n    if (_viewerapi.toolController.getActiveToolName() === _names[0] ||\n    _viewerapi.toolController.getActiveToolName() === _names[1]) {\n      var camera = _navapi.getCamera();\n      var isOrtho = camera && !camera.isPerspective;\n      var hasLongFocalLength = _navapi.getFocalLength() > kMaxFocalLength;\n\n      if (isOrtho)\n      self.showOrthoWarningMessage();else\n      if (hasLongFocalLength)\n      self.showFocalWarningMessage();else\n\n      Autodesk.Viewing.Private.HudMessage.dismiss();\n    }\n  };\n\n  this.showHUDMessage = function (state)\n  {\n    var camera = _navapi.getCamera();\n    var isOrtho = camera && !camera.isPerspective;\n    var hasLongFocalLength = _navapi.getFocalLength() > kMaxFocalLength;\n\n    if (state && isOrtho) {\n      self.showOrthoWarningMessage();\n    } else if (state && hasLongFocalLength) {\n      self.showFocalWarningMessage();\n    } else {\n      Autodesk.Viewing.Private.HudMessage.dismiss();\n    }\n\n    if (state) {\n      _viewerapi.addEventListener(Autodesk.Viewing.CAMERA_CHANGE_EVENT, self.watchCamera);\n    } else {\n      _viewerapi.removeEventListener(Autodesk.Viewing.CAMERA_CHANGE_EVENT, self.watchCamera);\n    }\n  };\n\n}"],"mappings":";;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AClFA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC5KA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;A","sourceRoot":""}