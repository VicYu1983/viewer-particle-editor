{"version":3,"file":"CrossFadeEffects/CrossFadeEffects.js","sources":["webpack://Autodesk.Extensions.[name]/webpack/bootstrap","webpack://Autodesk.Extensions.[name]/./extensions/CrossFadeEffects/CrossFadeEffects.js","webpack://Autodesk.Extensions.[name]/./extensions/CrossFadeEffects/TargetCrossFade.js"],"sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./extensions/CrossFadeEffects/CrossFadeEffects.js\");\n","function _typeof(obj) {\"@babel/helpers - typeof\";if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;};}return _typeof(obj);}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError(\"Cannot call a class as a function\");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}function _inherits(subClass, superClass) {if (typeof superClass !== \"function\" && superClass !== null) {throw new TypeError(\"Super expression must either be null or a function\");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}function _createSuper(Derived) {var hasNativeReflectConstruct = _isNativeReflectConstruct();return function _createSuperInternal() {var Super = _getPrototypeOf(Derived),result;if (hasNativeReflectConstruct) {var NewTarget = _getPrototypeOf(this).constructor;result = Reflect.construct(Super, arguments, NewTarget);} else {result = Super.apply(this, arguments);}return _possibleConstructorReturn(this, result);};}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");}return self;}function _isNativeReflectConstruct() {if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;if (Reflect.construct.sham) return false;if (typeof Proxy === \"function\") return true;try {Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));return true;} catch (e) {return false;}}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}\n\nvar myExtensionName = 'Autodesk.CrossFadeEffects';\n\nvar av = Autodesk.Viewing;\nvar avp = av.Private;\n\nimport { TargetCrossFade } from './TargetCrossFade';\n\n/** CrossFadeEffects extension provides API for implementing smooth fading effects in LMV, e.g.\n                                                      *  - CrossFading between models or model configurations (e.g. color theming, hiding objects etc.)\n                                                      *  - Image-based \"ghosting\" effect, i.e. showing a semitransparent snapshot of a model on top of another one.\n                                                      * \n                                                      * The extension id is: `Autodesk.CrossFadeEffects`\n                                                      * \n                                                      * Note:\n                                                      *  - Note that CrossFadeEffects require 2 extra RenderTargets. So, they should only be used for optional effects that can be skipped on weak devices.\n                                                      *  - CrossFade effects can only be used for one purpose at a time. When using them for a new feature, you have to make sure\n                                                      *    that they don't conflict with existing features.\n                                                      *\n                                                      * @example\n                                                      *   viewer.loadExtension('Autodesk.CrossFadeEffects')\n                                                      *\n                                                      * @memberof Autodesk.Viewing.Extensions\n                                                      * @see {@link Autodesk.Viewing.Extension} for common inherited methods.\n                                                      * @alias Autodesk.Viewing.Extensions.CrossFadeEffects\n                                                      * @class\n                                                      */var\nCrossFadeEffects = /*#__PURE__*/function (_av$Extension) {_inherits(CrossFadeEffects, _av$Extension);var _super = _createSuper(CrossFadeEffects);\n  function CrossFadeEffects(viewer, options) {var _this;_classCallCheck(this, CrossFadeEffects);\n\n    _this = _super.call(this, viewer, options);\n    _this.crossFade = null;\n\n    // Used to handle conflicts if this extension is used for different purposes\n    _this.clientId = null;\n    _this.onClientChanged = null;return _this;\n  }\n\n  /**\n     * Enables cross frade effects.\n     * \n     * @alias Autodesk.Viewing.Extensions.CrossFadeEffects#load\n     */_createClass(CrossFadeEffects, [{ key: \"load\", value: function load()\n    {\n      this.setCrossFadeEnabled(true);\n      return true;\n    }\n\n    /**\n       * Disables cross frade effects.\n       * \n       * @alias Autodesk.Viewing.Extensions.CrossFadeEffects#unload\n       */ }, { key: \"unload\", value: function unload()\n    {\n      this.setCrossFadeEnabled(false);\n    }\n\n    /**\n       * Fading targets may be used by different clients for different purposes. That's okay as long\n       * as it does not happen concurrently.\n       *\n       * In case of conflicts, the last caller takes precedence.\n       *\n       * If you start an effect using this extension, always call this function to notify client\n       * code that was using it before. Vice versa, provide an onClientChanged() callback to handle the case\n       * that someone else overtakes.\n       *\n       * Example: If start a fading effect while the ghost floors of the LevelsExtension are fading\n       * out, the LevelsExtension will be notified to skip the fade-out anim to avoid conflicts.\n       *\n       * @param {string} clientId - Some identifier unique for the code component using the effect, e.g. the name of an extension.\n       * @param {Function} [onClientChanged] - Will be called if another client called acquireControl.\n       * @alias Autodesk.Viewing.Extensions.CrossFadeEffects#acquireControl\n       */ }, { key: \"acquireControl\", value: function acquireControl(\n    clientId, onClientChanged) {\n      this.clientId = clientId;\n      this.onClientChanged && this.onClientChanged(); // let previous client code now that we took control\n      this.onClientChanged = onClientChanged; // call onClientChanged if someone else overtakes later\n    }\n\n    /**\n       * Only allowed if modelCrossFade is enabled. Determines to which target a RenderModel will be rendered.\n       *\n       *  @param {number} modelId - The model id\n       *  @param {undefined|0|1} targetIndex - index of the crossFade target or undefined (default) to use default color buffer\n       *\n       * @alias Autodesk.Viewing.Extensions.CrossFadeEffects#setModelTargetIndex\n       */ }, { key: \"setModelTargetIndex\", value: function setModelTargetIndex(\n    modelId, targetIndex) {\n      this.crossFade.setModelTargetIndex(modelId, targetIndex);\n      this.viewer.impl.invalidate(true);\n    }\n\n    /**\n       * Only allowed if modelCrossFade is enabled. Determines to which target a RenderModel will be rendered.\n       *\n       * @param {undefined|0|1} index - index of the crossFade target or undefined (default) to use default color buffer\n       * @alias Autodesk.Viewing.Extensions.CrossFadeEffects#setModelTargetIndexForAll\n       */ }, { key: \"setModelTargetIndexForAll\", value: function setModelTargetIndexForAll(\n    index) {\n      var models = this.viewer.getVisibleModels();\n      for (var i = 0; i < models.length; i++) {\n        var model = models[i];\n        this.setModelTargetIndex(model.id, index);\n      }\n    }\n\n    /**\n       * Only allowed if modelCrossFade is enabled. Assigns a blending opacity to a cross-fading\n       * extra target.\n       *\n       *  @param {number} targetIndex - must be >0\n       *  @param {number} opacity     - in [0,1]\n       *\n       * @alias Autodesk.Viewing.Extensions.CrossFadeEffects#setCrossFadeOpacity\n       */ }, { key: \"setCrossFadeOpacity\", value: function setCrossFadeOpacity(\n    targetIndex, opacity) {\n      this.crossFade.setCrossFadeOpacity(targetIndex, opacity);\n      this.viewer.impl.invalidate(true);\n    }\n\n    /*\n       * @param {number} targetIndex - must be >0\n       * @returns {number} opacity\n       *\n       * @alias Autodesk.Viewing.Extensions.CrossFadeEffects#getCrossFadeOpacity\n       */ }, { key: \"getCrossFadeOpacity\", value: function getCrossFadeOpacity(\n    targetIndex) {\n      return this.crossFade.getCrossFadeOpacity(targetIndex);\n    }\n\n    /**\n       * Enable/Disable model cross-fading. Must be enabled in order to render models to different render targets\n       * for cross-fading effects (see below). If no cross-fading effects are used, it should be disabled to save\n       * GPU memory and performance.\n       *\n       * @param {boolean} enable - Whether to enable(true) or disable(false) cross fade effects.\n       *\n       * @alias Autodesk.Viewing.Extensions.CrossFadeEffects#setCrossFadeEnabled\n       */ }, { key: \"setCrossFadeEnabled\", value: function setCrossFadeEnabled(\n    enable) {\n      if (enable === Boolean(this.crossFade)) {\n        return;\n      }\n\n      var renderer = this.viewer.impl.renderer();\n      if (enable) {\n        var blendPass = renderer.getBlendPass();\n        this.crossFade = new TargetCrossFade(blendPass);\n        renderer.setCrossFade(this.crossFade);\n      } else {\n        this.crossFade.dtor();\n        renderer.setCrossFade(null);\n      }\n\n      // If targets have been created already, call resize to make sure that\n      //   1. crossFade targets are created and have correct size/format\n      //   2. colorTarget/idTarget are reallocated with correct format\n      //      Note that toggling crossFade affects color/id target format as well, because\n      //      RGB and RGBA targets cannot be used at once when using MRT.\n      var colorTarget = renderer.getColorTarget();\n      if (colorTarget) {\n        var pixelRatio = this.viewer.impl.glrenderer().getPixelRatio(); //setSize expects the size without pixelRatio\n        renderer.setSize(colorTarget.width / pixelRatio, colorTarget.height / pixelRatio);\n      }\n    }\n\n    /*\n       * Renders a frame into a fading target, so that we can use it for a static-image fade.\n       * The target will be protected from cleaning, so that it will overdraw the main scene.\n       * To go back to normal rendering, call releaseFadingImage(fadeTargetIndex) afterwards.\n       *  @param {0|1} fadeTargetIndex\n       *  @param {number} [frameBudget] - time budget in ms that can be used for rendering this image.\n       *                                  Only relevant if progressive rendering is on.\n       *                                  Default value is the current this.targetFrameBudget setting.\n       *\n       * @alias Autodesk.Viewing.Extensions.CrossFadeEffects#renderFadingImage\n       */ }, { key: \"renderFadingImage\", value: function renderFadingImage(\n    fadeTargetIndex, frameBudget) {\n      // Make sure last frame was rendered to main target.\n      // This is needed in case there were changes made (like cutplanes applied), before the viewer was able to render them.\n      var timestamp = performance.now();\n      this.viewer.impl.tick(timestamp);\n\n      // make RenderContext render into fadeTarget\n      var renderer = this.viewer.impl.renderer();\n      this.crossFade.beginRenderToFadeTarget(fadeTargetIndex, renderer);\n\n      // start new frame\n      this.viewer.impl.invalidate(true, true, true);\n\n      // temporarily overload rendering budget (if wanted)\n      var originalFrameBudget = this.viewer.impl.targetFrameBudget;\n      if (frameBudget) {\n        this.viewer.impl.targetFrameBudget = frameBudget;\n      }\n\n      timestamp = performance.now();\n      this.viewer.impl.tick(timestamp);\n\n      // recover original frame budget\n      this.targetFrameBudget = originalFrameBudget;\n\n      // make RenderContext render to the main scene canvas again\n      this.crossFade.endRenderFadeTarget(renderer);\n    }\n\n    /* Must be called when a baked fading image (see renderFadingImage) is not needed anymore. */ }, { key: \"releaseFadingImage\", value: function releaseFadingImage(\n    fadeTargetIndex) {\n      this.setClearEnabled(fadeTargetIndex, true);\n    } }, { key: \"setClearEnabled\", value: function setClearEnabled(\n\n    targetIndex, enabled) {\n      this.crossFade.setClearEnabled(targetIndex, enabled);\n    }\n\n    /**\n       * Runs a fading-animation on a cross-fading target.\n       *\n       *  @param {number}        targetIndex        - see setModelTargetIndex()\n       *  @param {number}        startOpacity       - in [0,1]\n       *  @param {number}        endOpacity         - in [0,1]\n       *  @param {number}       [duration=5]        - in seconds\n       *  @param {Function}     [onFinished]        - optional callback triggered when animation is finished\n       *  @returns {object}     AnimControl instance\n       *\n       * @alias Autodesk.Viewing.Extensions.CrossFadeEffects#fadeTarget\n       */ }, { key: \"fadeTarget\", value: function fadeTarget(\n    targetIndex, startOpacity, endOpacity, duration, onFinished) {var _this2 = this;\n\n      var setTargetOpacity = function setTargetOpacity(val) {\n        _this2.setCrossFadeOpacity(targetIndex, val);\n      };\n      return avp.fadeValue(startOpacity, endOpacity, duration, setTargetOpacity, onFinished);\n    }\n\n    // Performs an image cross-fade between fade-target 0 and 1, assuming that the main scene is not visible.\n  }, { key: \"fadeImage\", value: function fadeImage(startVal, endVal, duration, onFinished) {var _this3 = this;\n\n      // Temporarily hide all models during the image fade. They would be overdrawn anyway, so rendering them would just waste time.\n      var mq = this.viewer.impl.modelQueue();\n      var models = mq.getModels().slice(); // We have to copy - otherwise the array would be empty after hiding the models\n      for (var i = 0; i < models.length; i++) {\n        var model = models[i];\n        mq.hideModel(model.id);\n      }\n\n      var onFadeDone = function onFadeDone() {\n\n        // Set fading mode back to the default (independent decal of both targets)\n        _this3.crossFade.setFadeMode(TargetCrossFade.FadeMode.CROSSFADE);\n\n        // Reactivate all temporarily hidden models\n        for (var _i = 0; _i < models.length; _i++) {\n          var _model = models[_i];\n          mq.showModel(_model.id);\n        }\n\n        if (onFinished) {\n          onFinished();\n        }\n      };\n\n      // fade between both targets\n      var setTargetOpacity = function setTargetOpacity(val) {\n\n        // Fade opacity of cross-fade target 1\n        _this3.setCrossFadeOpacity(0, 1.0 - val);\n        _this3.setCrossFadeOpacity(1, val);\n\n        // Viewer3DImpl skips the present step if scene is empty. Therefore, we enforce\n        // present from outside when cross-fading images.\n        var renderer = _this3.viewer.impl.renderer();\n        renderer.presentBuffer();\n      };\n\n      // For static image fading, we use the cross-fade mode. This ensures that identical pixels between both\n      // images do not vary during transition.\n      this.crossFade.setFadeMode(TargetCrossFade.FadeMode.CROSSFADE);\n\n      return avp.fadeValue(startVal, endVal, duration, setTargetOpacity, onFadeDone);\n    }\n\n    /**\n       * Runs a static image fade between the current view and a modified view.\n       * (e.g. with changed model/fragment visiblity, ghosting etc.)\n       * The modified view is specified via function applyState.\n       *\n       *  @param {Function} applyState - applied after rendering the fading start image.\n       *  @param {number} duration - in seconds\n       *\n       * @alias Autodesk.Viewing.Extensions.CrossFadeEffects#fadeToViewerState\n       */ }, { key: \"fadeToViewerState\", value: function fadeToViewerState(\n    applyState, duration) {var _this4 = this;\n\n      // time-limit in ms that we allow for rendering static images\n      var renderBudget = 300;\n\n      // Render \"before\" state into target 0\n      this.renderFadingImage(0, renderBudget);\n\n      // apply viewer state modification\n      applyState();\n\n      // render image that we fade to\n      this.renderFadingImage(1, renderBudget);\n\n      // remember if SAO was enabled before image fade, because we temporarily disable it, because\n      // AO is already baked into the images that we fade.\n      var rc = this.viewer.impl.renderer();\n      var aoEnabled = rc.getAOEnabled();\n\n      var onFadeDone = function onFadeDone() {\n        // unlock targets again, so that we see the main color target again (instead of the static images)\n        _this4.releaseFadingImage(0);\n        _this4.releaseFadingImage(1);\n\n        // recover original AO-enabled state\n        rc.setAOEnabled(aoEnabled);\n      };\n\n      // disable SAO during fading\n      rc.setAOEnabled(false);\n\n      // run image fading\n      this.fadeImage(0.0, 1.0, duration, onFadeDone);\n    } }]);return CrossFadeEffects;}(av.Extension);\n\n\n// Register the extension with the extension manager.\nexport { CrossFadeEffects as default };Autodesk.Viewing.theExtensionManager.registerExtension(myExtensionName, CrossFadeEffects);","\n// Controls the way in which fading targets are applied in the blend shader\nexport var FadeMode = {\n  // Just blend each target independently on top of main color target (default)\n  DECAL: 0,\n\n  // Crossfades between target 0 and 1 using crossFadeOpacity1 as mix param.\n  // crossFadeOpacity0 is not used in this mode. Advantage is that colors keep\n  // more consistent when fading between two images.\n  CROSSFADE: 1 };\n\n\n\n/**\n                   * @class TargetCrossFade is used by RenderContext to implement optional cross-fading\n                   * between different render targets. By default (no cross-fading), all scenes are rendered\n                   * to the default color buffer by RenderContext. When using targetCrossFade, a scene may\n                   * be rendered to a separate target, which is blended with the default color target in the blend pass.\n                   *  @param {LmvShaderPass} blendPass      - see RenderContext\n                   */\nexport function TargetCrossFade(blendPass) {\n\n  // {THREE.WebGLRenderTarget} of type RGBA with own depth buffer. Selected scenes are rendered into this target\n  // and overlayed on top of the main scene.\n  var _fadeTargets = [];\n  var _numFadeTargets = 2;\n  var _enableClear = [true, true]; // Clear may be disabled when fading to static images\n\n  var _blendPass = blendPass;\n\n  var _clearColor = new THREE.Color();\n\n  // {number[]} Indexed by modelId. Defines the index of the Render target to which a RenderModel is rendered.\n  //           0/undefined: default color buffer, 1:\n  var _modelId2TargetIndex = [];\n\n  var _fadeMode = FadeMode.DECAL;\n\n  // see setSaoHeuristicEnabled() comment\n  var _enableSaoHeuristic = true;\n\n  this.setModelTargetIndex = function (modelId, targetIndex) {\n    _modelId2TargetIndex[modelId] = targetIndex;\n  };\n\n  // By default (true), we exclude models from depth buffer rendering (used for SAO) if they have reduced opacity.\n  // Disabling it makes sure that models are always rendered to the depth target - no matter which opacity they have.\n  this.setSaoHeuristicEnabled = function (enabled) {\n    _enableSaoHeuristic = enabled;\n  };\n\n  //which model is used for AO (i.e. which one is more opaque)\n  this.getRenderSao = function (scene) {\n\n    if (!_enableSaoHeuristic) {\n      // Never suppress depth-writing - independent of target opacity.\n      return true;\n    }\n\n    var index = scene.modelId && _modelId2TargetIndex[scene.modelId];\n\n    if (index === undefined)\n    return true;\n\n    var idx = index;\n    var maxOpacity = this.getCrossFadeOpacity(index);\n\n    var numTargets = 2;\n    for (var i = 0; i < numTargets; i++) {\n      var op = this.getCrossFadeOpacity(i);\n      if (op > maxOpacity) {\n        idx = i;\n        maxOpacity = op;\n      }\n    }\n\n    return idx == index;\n  };\n\n  this.setCrossFadeOpacity = function (targetIndex, opacity) {\n    var uniformName = 'crossFadeOpacity' + targetIndex;\n    _blendPass.uniforms[uniformName].value = opacity;\n  };\n\n  this.getCrossFadeOpacity = function (targetIndex) {\n    var uniformName = 'crossFadeOpacity' + targetIndex;\n    return _blendPass.uniforms[uniformName].value;\n  };\n\n  // Activate target-blending for blendPass and assigns current _blendTarget as source\n  this.updateBlendPass = function (numFadeTargets) {\n\n    if (numFadeTargets === undefined) {\n      numFadeTargets = _fadeTargets.length;\n    }\n\n    // Update NUM_CROSSFADE_TARGETS shader-define if necessary\n    var macroName = 'NUM_CROSSFADE_TARGETS';\n    var oldMacroVal = _blendPass.material.defines[macroName];\n    var newMacroVal = numFadeTargets ? numFadeTargets : undefined;\n    if (oldMacroVal !== newMacroVal) {\n\n      if (numFadeTargets) {\n        _blendPass.material.defines[macroName] = newMacroVal;\n      } else {\n        // remove define from blend pass. Note that setting to 'undefined' would not work here,\n        // because the macro would still exist and would have the text value 'undefined'\n        delete _blendPass.material.defines[macroName];\n      }\n      _blendPass.material.needsUpdate = true;\n    }\n\n    for (var i = 0; i < numFadeTargets; i++) {\n      var uniformName = 'tCrossFadeTex' + i;\n      _blendPass.uniforms[uniformName].value = _fadeTargets[i];\n    }\n\n    // Update fade-mode macro\n    var modeMacroName = 'TARGET_FADE_MODE';\n    var prevMode = _blendPass.material.defines[modeMacroName];\n    if (prevMode !== _fadeMode) {\n      _blendPass.material.defines[modeMacroName] = _fadeMode;\n      _blendPass.material.needsUpdate = true;\n    }\n  };\n\n  /* @param {number} mode - See FadeMode enum above. */\n  this.setFadeMode = function (mode) {\n    if (mode !== FadeMode.DECAL && mode !== FadeMode.CROSSFADE) {\n      // A wrong value causes a shader compile error - so it's better to check here.\n      console.error(\"Unexpected fade mode enum\");\n      return;\n    }\n    _fadeMode = mode;\n    this.updateBlendPass();\n  };\n\n  /** Clear with opacity 0.0 */\n  this.clearTarget = function (renderer) {\n    // clear RGBA blend target with black + opacity 0.0 and default clearDepth\n    // Note that the blend target needs an own z-buffer.\n    renderer.setClearColor(_clearColor, 0.0);\n\n    for (var i = 0; i < _fadeTargets.length; i++) {\n      if (_enableClear[i]) {\n        renderer.clearTarget(_fadeTargets[i], true, true);\n      }\n    }\n  };\n\n  // Clear can be temporarily disabled when using targets for static image fading.\n  this.setClearEnabled = function (targetIndex, enabled) {\n    _enableClear[targetIndex] = enabled;\n  };\n\n  this.disposeTargets = function () {\n    for (var i = 0; i < _fadeTargets.length; i++) {\n      var target = _fadeTargets[i];\n      if (target) {\n        target.dispose();\n      }\n      _fadeTargets[i] = null;\n    }\n  };\n\n  this.dtor = function () {\n    this.disposeTargets();\n    this.updateBlendPass();\n\n    this.setCrossFadeOpacity(0, 0);\n    this.setCrossFadeOpacity(1, 0);\n  };\n\n  /* Determines to which color target a scene will be rendered.\n      *  @param {THREE.Scene|RenderBatch} scene         - scene to be rendered\n      *  @param {THREE.WebGLRenderTarget} defaultTarget - color target that RenderContext would use by default\n      */\n  this.chooseColorTarget = function (scene, defaultTarget) {\n\n    // Check if scene is associated with a render model that is assigned to a cross-fade target\n    var index = scene.modelId && _modelId2TargetIndex[scene.modelId];\n\n    // use default target if nothing else is assigned\n    if (index === undefined) {\n      return defaultTarget;\n    }\n\n    // use cross-fade target\n    return _fadeTargets[index];\n  };\n\n  /* Called by RenderContext if target sizes or formats may change. Makes sure that\n      * the blendTarget exists and has matching size.\n      *  @param {number} width          - render target width\n      *  @param {number} height         - ...\n      *  @param {bool}   [useHdrTarget] - if true, we use a float-type target\n      *  @param {bool}   [force]        - force reallocate, even if width/height keep the same\n      */\n  this.updateTargets = function (width, height, force, useHdrTarget) {\n\n    for (var i = 0; i < _numFadeTargets; i++) {\n\n      var target = _fadeTargets[i];\n\n      // skip if no update is needed\n      if (!force && target && target.width === width && target.height === height) {\n        continue;\n      }\n\n      // dispose any old target\n      if (target) {\n        target.dispose();\n      }\n\n      target = new THREE.WebGLRenderTarget(width, height,\n      { minFilter: THREE.LinearFilter,\n        magFilter: THREE.LinearFilter,\n        format: THREE.RGBAFormat,\n        type: useHdrTarget ? THREE.FloatType : THREE.UnsignedByteType,\n        //anisotropy: Math.min(this.getMaxAnisotropy(), 4),\n        stencilBuffer: false });\n\n      // three.js has a flaw in its constructor: the generateMipmaps value is always initialized to true\n      target.generateMipmaps = false;\n\n      _fadeTargets[i] = target;\n    }\n  };\n\n  /**\n      * Starts offscreen rendering into one of the cross-fade targets.\n      * Frames rendered between beginRenderFadeImage(i) and endRenderFadeImage() are rendered into a fading target\n      * instead of the canvas. In this way, static images can be pre-rendered and faded.\n      *  @param {number}        fadeTargetIndex - must be 0 or 1.\n      *  @param {RenderContext} renderContext\n      */\n  this.beginRenderToFadeTarget = function (fadeTargetIndex, renderContext) {\n\n    // Make sure that blend pass does not use the fadingTargets for reading while we are writing to one of them\n    this.updateBlendPass(0);\n\n    // make presentBuffer calls write into _offscreenTarget\n    var target = _fadeTargets[fadeTargetIndex];\n    renderContext.setOffscreenTarget(target);\n\n    // protect fade-target from clear, so that the image will not be overwritten in subsequent frames\n    this.setClearEnabled(fadeTargetIndex, false);\n  };\n\n  /**\n      * Finish offscreen rendering into fading target. The rendered result is now overlayed on top of\n      * the normal rendering result.\n      *\n      * @param {RenderContext} renderContext\n      */\n  this.endRenderFadeTarget = function (renderContext) {\n\n    // render to canvas again\n    renderContext.setOffscreenTarget(null);\n\n    // make blend pass use fade targets again\n    this.updateBlendPass();\n  };\n}\n\n// expose enum\nTargetCrossFade.FadeMode = FadeMode;"],"mappings":";;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AClFA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC3UA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;A","sourceRoot":""}