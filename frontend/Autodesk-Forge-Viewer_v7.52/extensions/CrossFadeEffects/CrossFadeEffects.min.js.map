{"version":3,"sources":["webpack://Autodesk.Extensions.[name]/webpack/bootstrap","webpack://Autodesk.Extensions.[name]/./extensions/CrossFadeEffects/TargetCrossFade.js","webpack://Autodesk.Extensions.[name]/./extensions/CrossFadeEffects/CrossFadeEffects.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","FadeMode","DECAL","CROSSFADE","TargetCrossFade","blendPass","_fadeTargets","_enableClear","_blendPass","_clearColor","THREE","Color","_modelId2TargetIndex","_fadeMode","_enableSaoHeuristic","this","setModelTargetIndex","modelId","targetIndex","setSaoHeuristicEnabled","enabled","getRenderSao","scene","index","undefined","idx","maxOpacity","getCrossFadeOpacity","op","setCrossFadeOpacity","opacity","uniformName","uniforms","updateBlendPass","numFadeTargets","length","macroName","newMacroVal","material","defines","needsUpdate","setFadeMode","console","error","clearTarget","renderer","setClearColor","setClearEnabled","disposeTargets","target","dispose","dtor","chooseColorTarget","defaultTarget","updateTargets","width","height","force","useHdrTarget","WebGLRenderTarget","minFilter","LinearFilter","magFilter","format","RGBAFormat","type","FloatType","UnsignedByteType","stencilBuffer","generateMipmaps","beginRenderToFadeTarget","fadeTargetIndex","renderContext","setOffscreenTarget","endRenderFadeTarget","av","Autodesk","Viewing","avp","Private","CrossFadeEffects","viewer","options","crossFade","clientId","onClientChanged","setCrossFadeEnabled","impl","invalidate","models","getVisibleModels","model","id","enable","Boolean","getBlendPass","setCrossFade","colorTarget","getColorTarget","pixelRatio","glrenderer","getPixelRatio","setSize","frameBudget","timestamp","performance","now","tick","originalFrameBudget","targetFrameBudget","startOpacity","endOpacity","duration","onFinished","fadeValue","val","startVal","endVal","mq","modelQueue","getModels","slice","hideModel","presentBuffer","showModel","applyState","renderFadingImage","rc","aoEnabled","getAOEnabled","setAOEnabled","fadeImage","releaseFadingImage","Extension","theExtensionManager","registerExtension"],"mappings":"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","file":"CrossFadeEffects/CrossFadeEffects.min.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 874);\n","\n// Controls the way in which fading targets are applied in the blend shader\nexport const FadeMode = {\n    // Just blend each target independently on top of main color target (default)\n    DECAL: 0,\n\n    // Crossfades between target 0 and 1 using crossFadeOpacity1 as mix param.\n    // crossFadeOpacity0 is not used in this mode. Advantage is that colors keep\n    // more consistent when fading between two images.\n    CROSSFADE: 1\n};\n\n\n/**\n * @class TargetCrossFade is used by RenderContext to implement optional cross-fading\n * between different render targets. By default (no cross-fading), all scenes are rendered\n * to the default color buffer by RenderContext. When using targetCrossFade, a scene may\n * be rendered to a separate target, which is blended with the default color target in the blend pass.\n *  @param {LmvShaderPass} blendPass      - see RenderContext\n */\nexport function TargetCrossFade(blendPass) {\n\n    // {THREE.WebGLRenderTarget} of type RGBA with own depth buffer. Selected scenes are rendered into this target\n    // and overlayed on top of the main scene.\n    var _fadeTargets    = [];\n    var _numFadeTargets = 2;\n    var _enableClear    = [true, true]; // Clear may be disabled when fading to static images\n\n    var _blendPass = blendPass;\n\n    var _clearColor = new THREE.Color();\n\n    // {number[]} Indexed by modelId. Defines the index of the Render target to which a RenderModel is rendered.\n    //           0/undefined: default color buffer, 1:\n    var _modelId2TargetIndex = [];\n\n    var _fadeMode = FadeMode.DECAL;\n\n    // see setSaoHeuristicEnabled() comment\n    var _enableSaoHeuristic = true;\n\n    this.setModelTargetIndex = function(modelId, targetIndex) {\n        _modelId2TargetIndex[modelId] = targetIndex;\n    };\n\n    // By default (true), we exclude models from depth buffer rendering (used for SAO) if they have reduced opacity.\n    // Disabling it makes sure that models are always rendered to the depth target - no matter which opacity they have.\n    this.setSaoHeuristicEnabled = function(enabled) {\n        _enableSaoHeuristic = enabled;\n    };\n\n    //which model is used for AO (i.e. which one is more opaque)\n    this.getRenderSao = function(scene) {\n\n        if (!_enableSaoHeuristic) {\n            // Never suppress depth-writing - independent of target opacity.\n            return true;\n        }\n\n        var index = scene.modelId && _modelId2TargetIndex[scene.modelId];\n\n        if (index === undefined)\n            return true;\n\n        var idx = index;\n        var maxOpacity = this.getCrossFadeOpacity(index);\n\n        var numTargets = 2;\n        for (var i=0; i<numTargets; i++) {\n            var op = this.getCrossFadeOpacity(i);\n            if (op > maxOpacity) {\n                idx = i;\n                maxOpacity = op;\n            }\n        }\n\n        return idx == index;\n    };\n\n    this.setCrossFadeOpacity = function(targetIndex, opacity) {\n        var uniformName = 'crossFadeOpacity' + targetIndex;\n        _blendPass.uniforms[uniformName].value = opacity;\n    };\n\n    this.getCrossFadeOpacity = function(targetIndex) {\n        var uniformName = 'crossFadeOpacity' + targetIndex;\n        return _blendPass.uniforms[uniformName].value;\n    };\n\n    // Activate target-blending for blendPass and assigns current _blendTarget as source\n    this.updateBlendPass = function(numFadeTargets) {\n\n        if (numFadeTargets === undefined) {\n            numFadeTargets = _fadeTargets.length;\n        }\n\n        // Update NUM_CROSSFADE_TARGETS shader-define if necessary\n        var macroName   = 'NUM_CROSSFADE_TARGETS';\n        var oldMacroVal = _blendPass.material.defines[macroName];\n        var newMacroVal = (numFadeTargets ? numFadeTargets : undefined);\n        if (oldMacroVal !== newMacroVal) {\n\n            if (numFadeTargets) {\n                _blendPass.material.defines[macroName] = newMacroVal;\n            } else {\n                // remove define from blend pass. Note that setting to 'undefined' would not work here,\n                // because the macro would still exist and would have the text value 'undefined'\n                delete _blendPass.material.defines[macroName];\n            }\n            _blendPass.material.needsUpdate = true;\n        }\n\n        for (var i=0; i<numFadeTargets; i++) {\n            var uniformName = 'tCrossFadeTex' + i;\n            _blendPass.uniforms[uniformName].value = _fadeTargets[i];\n        }\n\n        // Update fade-mode macro\n        var modeMacroName = 'TARGET_FADE_MODE';\n        var prevMode = _blendPass.material.defines[modeMacroName];\n        if (prevMode !== _fadeMode) {\n            _blendPass.material.defines[modeMacroName] = _fadeMode;\n            _blendPass.material.needsUpdate = true;\n        }\n    };\n\n    /* @param {number} mode - See FadeMode enum above. */\n    this.setFadeMode = function(mode) {\n        if (mode !== FadeMode.DECAL && mode !== FadeMode.CROSSFADE) {\n            // A wrong value causes a shader compile error - so it's better to check here.\n            console.error(\"Unexpected fade mode enum\");\n            return;\n        }\n        _fadeMode = mode;\n        this.updateBlendPass();\n    };\n\n    /** Clear with opacity 0.0 */\n    this.clearTarget = function(renderer) {\n        // clear RGBA blend target with black + opacity 0.0 and default clearDepth\n        // Note that the blend target needs an own z-buffer.\n        renderer.setClearColor(_clearColor, 0.0);\n\n        for (var i=0; i<_fadeTargets.length; i++) {\n            if (_enableClear[i]) {\n                renderer.clearTarget(_fadeTargets[i], true, true);\n            }\n        }\n    };\n\n    // Clear can be temporarily disabled when using targets for static image fading.\n    this.setClearEnabled = function(targetIndex, enabled) {\n        _enableClear[targetIndex] = enabled;\n    };\n\n    this.disposeTargets = function() {\n        for (var i=0; i<_fadeTargets.length; i++) {\n            var target = _fadeTargets[i];\n            if (target) {\n                target.dispose();\n            }\n            _fadeTargets[i] = null;\n        }\n    };\n\n    this.dtor = function() {\n        this.disposeTargets();\n        this.updateBlendPass();\n\n        this.setCrossFadeOpacity(0, 0);\n        this.setCrossFadeOpacity(1, 0);\n    };\n\n    /* Determines to which color target a scene will be rendered.\n     *  @param {THREE.Scene|RenderBatch} scene         - scene to be rendered\n     *  @param {THREE.WebGLRenderTarget} defaultTarget - color target that RenderContext would use by default\n     */\n    this.chooseColorTarget = function(scene, defaultTarget) {\n\n        // Check if scene is associated with a render model that is assigned to a cross-fade target\n        var index = scene.modelId && _modelId2TargetIndex[scene.modelId];\n\n        // use default target if nothing else is assigned\n        if (index === undefined) {\n            return defaultTarget;\n        }\n\n        // use cross-fade target\n        return _fadeTargets[index];\n    };\n\n    /* Called by RenderContext if target sizes or formats may change. Makes sure that\n     * the blendTarget exists and has matching size.\n     *  @param {number} width          - render target width\n     *  @param {number} height         - ...\n     *  @param {bool}   [useHdrTarget] - if true, we use a float-type target\n     *  @param {bool}   [force]        - force reallocate, even if width/height keep the same\n     */\n    this.updateTargets = function(width, height, force, useHdrTarget) {\n\n        for (var i=0; i<_numFadeTargets; i++) {\n\n            var target = _fadeTargets[i];\n\n            // skip if no update is needed\n            if (!force && target && target.width === width && target.height === height) {\n                continue;\n            }\n\n            // dispose any old target\n            if (target) {\n                target.dispose();\n            }\n\n            target = new THREE.WebGLRenderTarget(width, height,\n                {   minFilter: THREE.LinearFilter,\n                    magFilter: THREE.LinearFilter,\n                    format: THREE.RGBAFormat,\n                    type: useHdrTarget ? THREE.FloatType : THREE.UnsignedByteType,\n                    //anisotropy: Math.min(this.getMaxAnisotropy(), 4),\n                    stencilBuffer: false\n                });\n            // three.js has a flaw in its constructor: the generateMipmaps value is always initialized to true\n            target.generateMipmaps = false;\n\n            _fadeTargets[i] = target;\n        }\n    };\n\n    /**\n     * Starts offscreen rendering into one of the cross-fade targets.\n     * Frames rendered between beginRenderFadeImage(i) and endRenderFadeImage() are rendered into a fading target\n     * instead of the canvas. In this way, static images can be pre-rendered and faded.\n     *  @param {number}        fadeTargetIndex - must be 0 or 1.\n     *  @param {RenderContext} renderContext\n     */\n    this.beginRenderToFadeTarget = function(fadeTargetIndex, renderContext) {\n\n        // Make sure that blend pass does not use the fadingTargets for reading while we are writing to one of them\n        this.updateBlendPass(0);\n\n        // make presentBuffer calls write into _offscreenTarget\n        var target = _fadeTargets[fadeTargetIndex];\n        renderContext.setOffscreenTarget(target);\n\n        // protect fade-target from clear, so that the image will not be overwritten in subsequent frames\n        this.setClearEnabled(fadeTargetIndex, false);\n    };\n\n    /**\n     * Finish offscreen rendering into fading target. The rendered result is now overlayed on top of\n     * the normal rendering result.\n     *\n     * @param {RenderContext} renderContext\n     */\n    this.endRenderFadeTarget = function(renderContext) {\n\n        // render to canvas again\n        renderContext.setOffscreenTarget(null);\n\n        // make blend pass use fade targets again\n        this.updateBlendPass();\n    };\n}\n\n// expose enum\nTargetCrossFade.FadeMode = FadeMode;\n\n","\n\nconst myExtensionName = 'Autodesk.CrossFadeEffects';\n\nconst av = Autodesk.Viewing;\nconst avp = av.Private;\n\nimport { TargetCrossFade } from './TargetCrossFade';\n\n/** CrossFadeEffects extension provides API for implementing smooth fading effects in LMV, e.g.\n *  - CrossFading between models or model configurations (e.g. color theming, hiding objects etc.)\n *  - Image-based \"ghosting\" effect, i.e. showing a semitransparent snapshot of a model on top of another one.\n * \n * The extension id is: `Autodesk.CrossFadeEffects`\n * \n * Note:\n *  - Note that CrossFadeEffects require 2 extra RenderTargets. So, they should only be used for optional effects that can be skipped on weak devices.\n *  - CrossFade effects can only be used for one purpose at a time. When using them for a new feature, you have to make sure\n *    that they don't conflict with existing features.\n *\n * @example\n *   viewer.loadExtension('Autodesk.CrossFadeEffects')\n *\n * @memberof Autodesk.Viewing.Extensions\n * @see {@link Autodesk.Viewing.Extension} for common inherited methods.\n * @alias Autodesk.Viewing.Extensions.CrossFadeEffects\n * @class\n */\nexport default class CrossFadeEffects extends av.Extension {\n    constructor(viewer, options) {\n\n        super(viewer, options);\n        this.crossFade = null;\n\n        // Used to handle conflicts if this extension is used for different purposes\n        this.clientId = null;\n        this.onClientChanged = null; \n    }\n\n    /**\n     * Enables cross frade effects.\n     * \n     * @alias Autodesk.Viewing.Extensions.CrossFadeEffects#load\n     */\n    load() {\n        this.setCrossFadeEnabled(true);\n        return true;\n    }\n\n    /**\n     * Disables cross frade effects.\n     * \n     * @alias Autodesk.Viewing.Extensions.CrossFadeEffects#unload\n     */\n    unload() {\n        this.setCrossFadeEnabled(false);\n    }\n\n    /**\n     * Fading targets may be used by different clients for different purposes. That's okay as long\n     * as it does not happen concurrently.\n     *\n     * In case of conflicts, the last caller takes precedence.\n     *\n     * If you start an effect using this extension, always call this function to notify client\n     * code that was using it before. Vice versa, provide an onClientChanged() callback to handle the case\n     * that someone else overtakes.\n     *\n     * Example: If start a fading effect while the ghost floors of the LevelsExtension are fading\n     * out, the LevelsExtension will be notified to skip the fade-out anim to avoid conflicts.\n     *\n     * @param {string} clientId - Some identifier unique for the code component using the effect, e.g. the name of an extension.\n     * @param {Function} [onClientChanged] - Will be called if another client called acquireControl.\n     * @alias Autodesk.Viewing.Extensions.CrossFadeEffects#acquireControl\n     */\n    acquireControl(clientId, onClientChanged) {\n        this.clientId = clientId;\n        this.onClientChanged && this.onClientChanged(); // let previous client code now that we took control\n        this.onClientChanged = onClientChanged;         // call onClientChanged if someone else overtakes later\n    }\n\n    /**\n     * Only allowed if modelCrossFade is enabled. Determines to which target a RenderModel will be rendered.\n     *\n     *  @param {number} modelId - The model id\n     *  @param {undefined|0|1} targetIndex - index of the crossFade target or undefined (default) to use default color buffer\n     *\n     * @alias Autodesk.Viewing.Extensions.CrossFadeEffects#setModelTargetIndex\n     */\n    setModelTargetIndex(modelId, targetIndex) {\n        this.crossFade.setModelTargetIndex(modelId, targetIndex);\n        this.viewer.impl.invalidate(true);\n    }\n\n    /**\n     * Only allowed if modelCrossFade is enabled. Determines to which target a RenderModel will be rendered.\n     *\n     * @param {undefined|0|1} index - index of the crossFade target or undefined (default) to use default color buffer\n     * @alias Autodesk.Viewing.Extensions.CrossFadeEffects#setModelTargetIndexForAll\n     */\n    setModelTargetIndexForAll(index) {\n        const models = this.viewer.getVisibleModels();\n        for (let i=0; i<models.length; i++) {\n            const model = models[i];\n            this.setModelTargetIndex(model.id, index);\n        }\n    }\n\n    /**\n     * Only allowed if modelCrossFade is enabled. Assigns a blending opacity to a cross-fading\n     * extra target.\n     *\n     *  @param {number} targetIndex - must be >0\n     *  @param {number} opacity     - in [0,1]\n     *\n     * @alias Autodesk.Viewing.Extensions.CrossFadeEffects#setCrossFadeOpacity\n     */\n    setCrossFadeOpacity(targetIndex, opacity) {\n        this.crossFade.setCrossFadeOpacity(targetIndex, opacity);\n        this.viewer.impl.invalidate(true);\n    }\n\n    /*\n     * @param {number} targetIndex - must be >0\n     * @returns {number} opacity\n     *\n     * @alias Autodesk.Viewing.Extensions.CrossFadeEffects#getCrossFadeOpacity\n     */\n    getCrossFadeOpacity(targetIndex) {\n        return this.crossFade.getCrossFadeOpacity(targetIndex);\n    }\n\n    /**\n     * Enable/Disable model cross-fading. Must be enabled in order to render models to different render targets\n     * for cross-fading effects (see below). If no cross-fading effects are used, it should be disabled to save\n     * GPU memory and performance.\n     *\n     * @param {boolean} enable - Whether to enable(true) or disable(false) cross fade effects.\n     *\n     * @alias Autodesk.Viewing.Extensions.CrossFadeEffects#setCrossFadeEnabled\n     */\n    setCrossFadeEnabled(enable) {\n        if (enable === Boolean(this.crossFade)) {\n            return;\n        }\n\n        let renderer = this.viewer.impl.renderer();\n        if (enable) {\n            let blendPass = renderer.getBlendPass();\n            this.crossFade = new TargetCrossFade(blendPass);\n            renderer.setCrossFade(this.crossFade);\n        } else {\n            this.crossFade.dtor();\n            renderer.setCrossFade(null);\n        }\n\n        // If targets have been created already, call resize to make sure that\n        //   1. crossFade targets are created and have correct size/format\n        //   2. colorTarget/idTarget are reallocated with correct format\n        //      Note that toggling crossFade affects color/id target format as well, because\n        //      RGB and RGBA targets cannot be used at once when using MRT.\n        let colorTarget = renderer.getColorTarget();\n        if (colorTarget) {\n            const pixelRatio = this.viewer.impl.glrenderer().getPixelRatio(); //setSize expects the size without pixelRatio\n            renderer.setSize(colorTarget.width / pixelRatio, colorTarget.height / pixelRatio);\n        }\n    }\n\n    /*\n     * Renders a frame into a fading target, so that we can use it for a static-image fade.\n     * The target will be protected from cleaning, so that it will overdraw the main scene.\n     * To go back to normal rendering, call releaseFadingImage(fadeTargetIndex) afterwards.\n     *  @param {0|1} fadeTargetIndex\n     *  @param {number} [frameBudget] - time budget in ms that can be used for rendering this image.\n     *                                  Only relevant if progressive rendering is on.\n     *                                  Default value is the current this.targetFrameBudget setting.\n     *\n     * @alias Autodesk.Viewing.Extensions.CrossFadeEffects#renderFadingImage\n     */\n    renderFadingImage(fadeTargetIndex, frameBudget) {\n        // Make sure last frame was rendered to main target.\n        // This is needed in case there were changes made (like cutplanes applied), before the viewer was able to render them.\n        let timestamp = performance.now();\n        this.viewer.impl.tick(timestamp);\n\n        // make RenderContext render into fadeTarget\n        let renderer = this.viewer.impl.renderer();\n        this.crossFade.beginRenderToFadeTarget(fadeTargetIndex, renderer);\n\n        // start new frame\n        this.viewer.impl.invalidate(true, true, true);\n\n        // temporarily overload rendering budget (if wanted)\n        let originalFrameBudget = this.viewer.impl.targetFrameBudget;\n        if (frameBudget) {\n            this.viewer.impl.targetFrameBudget = frameBudget;\n        }\n\n        timestamp = performance.now();\n        this.viewer.impl.tick(timestamp);\n\n        // recover original frame budget\n        this.targetFrameBudget = originalFrameBudget;\n\n        // make RenderContext render to the main scene canvas again\n        this.crossFade.endRenderFadeTarget(renderer);\n    }\n\n    /* Must be called when a baked fading image (see renderFadingImage) is not needed anymore. */\n    releaseFadingImage(fadeTargetIndex) {\n        this.setClearEnabled(fadeTargetIndex, true);\n    }\n\n    setClearEnabled(targetIndex, enabled) {\n        this.crossFade.setClearEnabled(targetIndex, enabled);\n    }\n\n    /**\n     * Runs a fading-animation on a cross-fading target.\n     *\n     *  @param {number}        targetIndex        - see setModelTargetIndex()\n     *  @param {number}        startOpacity       - in [0,1]\n     *  @param {number}        endOpacity         - in [0,1]\n     *  @param {number}       [duration=5]        - in seconds\n     *  @param {Function}     [onFinished]        - optional callback triggered when animation is finished\n     *  @returns {object}     AnimControl instance\n     *\n     * @alias Autodesk.Viewing.Extensions.CrossFadeEffects#fadeTarget\n     */\n    fadeTarget(targetIndex, startOpacity, endOpacity, duration, onFinished) {\n\n        let setTargetOpacity = (val) => {\n            this.setCrossFadeOpacity(targetIndex, val);\n        };\n        return avp.fadeValue(startOpacity, endOpacity, duration, setTargetOpacity, onFinished);\n    }\n\n    // Performs an image cross-fade between fade-target 0 and 1, assuming that the main scene is not visible.\n    fadeImage(startVal, endVal, duration, onFinished) {\n\n        // Temporarily hide all models during the image fade. They would be overdrawn anyway, so rendering them would just waste time.\n        let mq = this.viewer.impl.modelQueue();\n        let models = mq.getModels().slice(); // We have to copy - otherwise the array would be empty after hiding the models\n        for (let i=0; i<models.length; i++) {\n            let model = models[i];\n            mq.hideModel(model.id);\n        }\n\n        let onFadeDone = () => {\n\n            // Set fading mode back to the default (independent decal of both targets)\n            this.crossFade.setFadeMode(TargetCrossFade.FadeMode.CROSSFADE);\n\n            // Reactivate all temporarily hidden models\n            for (let i=0; i<models.length; i++) {\n                let model = models[i];\n                mq.showModel(model.id);\n            }\n\n            if (onFinished) {\n                onFinished();\n            }\n        };\n\n        // fade between both targets\n        let setTargetOpacity = (val) => {\n\n            // Fade opacity of cross-fade target 1\n            this.setCrossFadeOpacity(0, 1.0 - val);\n            this.setCrossFadeOpacity(1, val);\n\n            // Viewer3DImpl skips the present step if scene is empty. Therefore, we enforce\n            // present from outside when cross-fading images.\n            let renderer = this.viewer.impl.renderer();\n            renderer.presentBuffer();\n        };\n\n        // For static image fading, we use the cross-fade mode. This ensures that identical pixels between both\n        // images do not vary during transition.\n        this.crossFade.setFadeMode(TargetCrossFade.FadeMode.CROSSFADE);\n\n        return avp.fadeValue(startVal, endVal, duration, setTargetOpacity, onFadeDone);\n    }\n\n    /**\n     * Runs a static image fade between the current view and a modified view.\n     * (e.g. with changed model/fragment visiblity, ghosting etc.)\n     * The modified view is specified via function applyState.\n     *\n     *  @param {Function} applyState - applied after rendering the fading start image.\n     *  @param {number} duration - in seconds\n     *\n     * @alias Autodesk.Viewing.Extensions.CrossFadeEffects#fadeToViewerState\n     */\n    fadeToViewerState(applyState, duration) {\n\n        // time-limit in ms that we allow for rendering static images\n        var renderBudget = 300;\n\n        // Render \"before\" state into target 0\n        this.renderFadingImage(0, renderBudget);\n\n        // apply viewer state modification\n        applyState();\n\n        // render image that we fade to\n        this.renderFadingImage(1, renderBudget);\n\n        // remember if SAO was enabled before image fade, because we temporarily disable it, because\n        // AO is already baked into the images that we fade.\n        var rc = this.viewer.impl.renderer();\n        var aoEnabled = rc.getAOEnabled();\n\n        let onFadeDone = () => {\n            // unlock targets again, so that we see the main color target again (instead of the static images)\n            this.releaseFadingImage(0);\n            this.releaseFadingImage(1);\n\n            // recover original AO-enabled state\n            rc.setAOEnabled(aoEnabled);\n        };\n\n        // disable SAO during fading\n        rc.setAOEnabled(false);\n\n        // run image fading\n        this.fadeImage(0.0, 1.0, duration, onFadeDone);\n    }\n}\n\n// Register the extension with the extension manager.\nAutodesk.Viewing.theExtensionManager.registerExtension(myExtensionName, CrossFadeEffects);\n"],"sourceRoot":""}