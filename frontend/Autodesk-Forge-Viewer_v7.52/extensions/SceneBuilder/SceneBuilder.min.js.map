{"version":3,"sources":["webpack://Autodesk.Extensions.[name]/webpack/bootstrap","webpack://Autodesk.Extensions.[name]/./node_modules/bintrees/lib/treebase.js","webpack://Autodesk.Extensions.[name]/./node_modules/bintrees/index.js","webpack://Autodesk.Extensions.[name]/./node_modules/bintrees/lib/rbtree.js","webpack://Autodesk.Extensions.[name]/./node_modules/bintrees/lib/bintree.js","webpack://Autodesk.Extensions.[name]/./extensions/SceneBuilder/reusableIds.js","webpack://Autodesk.Extensions.[name]/./extensions/SceneBuilder/modelBuilder.js","webpack://Autodesk.Extensions.[name]/./extensions/SceneBuilder/locales.js","webpack://Autodesk.Extensions.[name]/./extensions/SceneBuilder/sceneBuilder.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","TreeBase","Iterator","tree","this","_tree","_ancestors","_cursor","clear","_root","size","find","data","res","_comparator","get_child","findIter","iter","iterator","push","lowerBound","item","cur","cmp","length","upperBound","next","min","left","max","right","each","cb","it","reach","prev","root","_minNode","save","pop","_maxNode","start","RBTree","BinTree","Node","red","comparator","is_red","node","single_rotate","dir","set_child","double_rotate","val","insert","ret","head","undefined","last","gp","ggp","dir2","remove","found","sr","sibling","gpc","tmpRange","ReusableIds","lowId","highId","reserve","_lowId","_highId","_availableIds","a","b","range","id","ranges","upper","lower","av","Autodesk","Viewing","avp","Private","tmpMatrix","THREE","Matrix4","tmpBox","Box3","tmpMin","Vector3","tmpMax","missingGeometry","svfid","boundingBox","meshInfo","geometry","material","matrix","isLine","isWideLine","isPoint","clearFlags","MeshFlags","MESH_ISLINE","MESH_ISWIDELINE","MESH_ISPOINT","REMOVED_EVENT","type","SceneBuilderNodeAccess","rootId","nodeIndices","dbIdToIndex","_nodeCount","_maxIndex","_nodeFlags","_indexToFragId","_rootName","i18n","translate","nodeId","dbId","index","flags","includeCount","postProcess","sprintf","dst","setEmpty","frags","Array","isArray","callback","dbids","keys","child","parseInt","fragId","reserveId","indexOf","splice","releaseId","EmptyModelLoader","viewer","viewer3DImpl","url","options","onDone","onWorkerStart","initialSize","conserveMemory","svf","bbox","set","globalOffset","fragments","fragId2dbId","transforms","Float32Array","boxes","is2d","loadOptions","isSceneBuilder","loadDone","instanceTree","InstanceTree","metadata","model","Model","modelNameOverride","modelId","getModelId","nodeAccess","urn","btoa","initialize","loader","getFragmentList","isFixedSize","api","dispatchEvent","MODEL_ROOT_LOADED_EVENT","onLoadComplete","getFragmentId","fragment","Mesh","changeFragmentGeometry","modelBuilder","transform","fragList","getGeometryId","BufferGeometry","getGeometry","_getGeometry","mtl","getMaterial","_getMaterial","mesh","getVizmesh","vizflags","isLines","isWideLines","isPoints","dstMatrix","copy","elements","identity","convertMatrix","fromArray","addFragment","setFragment","useThreeMesh","sceneUpdated","calculateBBox","makeEmpty","VertexEnumerator","enumMeshVertices","pos","expandByPoint","addMaterial","matman","hash","MeshPhongMaterial","ShaderMaterial","isPrismMaterial","addMaterialNonHDR","changeDbId","newDbId","oldDbId","removeFragment","ModelBuilder","geomList","getGeometryList","geomIds","fragmentIds","Math","getData","setFragmentList","createWireframe","numFragments","geomId","attributes","indexlines","attrIndexLines","BufferAttribute","bytesPerItem","iblines","Uint32Array","setAttribute","iblinesbuffer","indices","Uint16Array","position","iba","addGeometry","packNormals","oldGeomIds","newGeomId","update","geomids","meshes","vizmeshes","search","isIdReserved","existingGeom","result","_validateGeometry","oldGeom","removeGeometry","frag2geom","_updateGeometry","delMap","delIds","materialManagerName","_getMaterialHash","_materials","_materialsNonHDR","packedNormals","needsUpdate","materials","mtls","oldMat","Material","existingMaterial","_validateMaterials","matId","materialmap","materialIdMap","hashes","findFrags","matIds","fragCount","frag2MatId","materialids","idMap","setMaterial","_getDefaultMaterial","fragToMtlId","mtlName","findMaterial","skipGeom","skipTransform","matrixWorld","objectsMoved","skipRepaint","fragIds","_validateFragment","getOriginalWorldMatrix","_defaultMaterial","defaultMaterial","clone","array","normal","itemSize","cvt","src","srcOff","srcStride","dstOff","dstStride","atan2","INV_PI","PI","pnx","pny","vcount","floor","normalize","vbstride","vb","itemOffset","from","to","j","length1","length2","buffer","vbNeedsUpdate","BufferGeometryUtils","findBufferAttribute","isPattern","divisor","offset","numInstances","attr","sceneBuilder","Promise","resolve","reject","assign","fileLoader","x","y","z","loadModel","error","locales","en","cs","de","es","fr","ja","ko","pl","ru","tr","nl","sv","da","no","SceneBuilder","_loaded","extendLocalization","addNewModel","Error","Extension","theExtensionManager","registerExtension"],"mappings":"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","file":"SceneBuilder/SceneBuilder.min.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 857);\n","\nfunction TreeBase() {}\n\n// removes all nodes from the tree\nTreeBase.prototype.clear = function() {\n    this._root = null;\n    this.size = 0;\n};\n\n// returns node data if found, null otherwise\nTreeBase.prototype.find = function(data) {\n    var res = this._root;\n\n    while(res !== null) {\n        var c = this._comparator(data, res.data);\n        if(c === 0) {\n            return res.data;\n        }\n        else {\n            res = res.get_child(c > 0);\n        }\n    }\n\n    return null;\n};\n\n// returns iterator to node if found, null otherwise\nTreeBase.prototype.findIter = function(data) {\n    var res = this._root;\n    var iter = this.iterator();\n\n    while(res !== null) {\n        var c = this._comparator(data, res.data);\n        if(c === 0) {\n            iter._cursor = res;\n            return iter;\n        }\n        else {\n            iter._ancestors.push(res);\n            res = res.get_child(c > 0);\n        }\n    }\n\n    return null;\n};\n\n// Returns an iterator to the tree node at or immediately after the item\nTreeBase.prototype.lowerBound = function(item) {\n    var cur = this._root;\n    var iter = this.iterator();\n    var cmp = this._comparator;\n\n    while(cur !== null) {\n        var c = cmp(item, cur.data);\n        if(c === 0) {\n            iter._cursor = cur;\n            return iter;\n        }\n        iter._ancestors.push(cur);\n        cur = cur.get_child(c > 0);\n    }\n\n    for(var i=iter._ancestors.length - 1; i >= 0; --i) {\n        cur = iter._ancestors[i];\n        if(cmp(item, cur.data) < 0) {\n            iter._cursor = cur;\n            iter._ancestors.length = i;\n            return iter;\n        }\n    }\n\n    iter._ancestors.length = 0;\n    return iter;\n};\n\n// Returns an iterator to the tree node immediately after the item\nTreeBase.prototype.upperBound = function(item) {\n    var iter = this.lowerBound(item);\n    var cmp = this._comparator;\n\n    while(iter.data() !== null && cmp(iter.data(), item) === 0) {\n        iter.next();\n    }\n\n    return iter;\n};\n\n// returns null if tree is empty\nTreeBase.prototype.min = function() {\n    var res = this._root;\n    if(res === null) {\n        return null;\n    }\n\n    while(res.left !== null) {\n        res = res.left;\n    }\n\n    return res.data;\n};\n\n// returns null if tree is empty\nTreeBase.prototype.max = function() {\n    var res = this._root;\n    if(res === null) {\n        return null;\n    }\n\n    while(res.right !== null) {\n        res = res.right;\n    }\n\n    return res.data;\n};\n\n// returns a null iterator\n// call next() or prev() to point to an element\nTreeBase.prototype.iterator = function() {\n    return new Iterator(this);\n};\n\n// calls cb on each node's data, in order\nTreeBase.prototype.each = function(cb) {\n    var it=this.iterator(), data;\n    while((data = it.next()) !== null) {\n        if(cb(data) === false) {\n            return;\n        }\n    }\n};\n\n// calls cb on each node's data, in reverse order\nTreeBase.prototype.reach = function(cb) {\n    var it=this.iterator(), data;\n    while((data = it.prev()) !== null) {\n        if(cb(data) === false) {\n            return;\n        }\n    }\n};\n\n\nfunction Iterator(tree) {\n    this._tree = tree;\n    this._ancestors = [];\n    this._cursor = null;\n}\n\nIterator.prototype.data = function() {\n    return this._cursor !== null ? this._cursor.data : null;\n};\n\n// if null-iterator, returns first node\n// otherwise, returns next node\nIterator.prototype.next = function() {\n    if(this._cursor === null) {\n        var root = this._tree._root;\n        if(root !== null) {\n            this._minNode(root);\n        }\n    }\n    else {\n        if(this._cursor.right === null) {\n            // no greater node in subtree, go up to parent\n            // if coming from a right child, continue up the stack\n            var save;\n            do {\n                save = this._cursor;\n                if(this._ancestors.length) {\n                    this._cursor = this._ancestors.pop();\n                }\n                else {\n                    this._cursor = null;\n                    break;\n                }\n            } while(this._cursor.right === save);\n        }\n        else {\n            // get the next node from the subtree\n            this._ancestors.push(this._cursor);\n            this._minNode(this._cursor.right);\n        }\n    }\n    return this._cursor !== null ? this._cursor.data : null;\n};\n\n// if null-iterator, returns last node\n// otherwise, returns previous node\nIterator.prototype.prev = function() {\n    if(this._cursor === null) {\n        var root = this._tree._root;\n        if(root !== null) {\n            this._maxNode(root);\n        }\n    }\n    else {\n        if(this._cursor.left === null) {\n            var save;\n            do {\n                save = this._cursor;\n                if(this._ancestors.length) {\n                    this._cursor = this._ancestors.pop();\n                }\n                else {\n                    this._cursor = null;\n                    break;\n                }\n            } while(this._cursor.left === save);\n        }\n        else {\n            this._ancestors.push(this._cursor);\n            this._maxNode(this._cursor.left);\n        }\n    }\n    return this._cursor !== null ? this._cursor.data : null;\n};\n\nIterator.prototype._minNode = function(start) {\n    while(start.left !== null) {\n        this._ancestors.push(start);\n        start = start.left;\n    }\n    this._cursor = start;\n};\n\nIterator.prototype._maxNode = function(start) {\n    while(start.right !== null) {\n        this._ancestors.push(start);\n        start = start.right;\n    }\n    this._cursor = start;\n};\n\nmodule.exports = TreeBase;\n\n","module.exports = {\n    RBTree: require('./lib/rbtree'),\n    BinTree: require('./lib/bintree')\n};\n","\nvar TreeBase = require('./treebase');\n\nfunction Node(data) {\n    this.data = data;\n    this.left = null;\n    this.right = null;\n    this.red = true;\n}\n\nNode.prototype.get_child = function(dir) {\n    return dir ? this.right : this.left;\n};\n\nNode.prototype.set_child = function(dir, val) {\n    if(dir) {\n        this.right = val;\n    }\n    else {\n        this.left = val;\n    }\n};\n\nfunction RBTree(comparator) {\n    this._root = null;\n    this._comparator = comparator;\n    this.size = 0;\n}\n\nRBTree.prototype = new TreeBase();\n\n// returns true if inserted, false if duplicate\nRBTree.prototype.insert = function(data) {\n    var ret = false;\n\n    if(this._root === null) {\n        // empty tree\n        this._root = new Node(data);\n        ret = true;\n        this.size++;\n    }\n    else {\n        var head = new Node(undefined); // fake tree root\n\n        var dir = 0;\n        var last = 0;\n\n        // setup\n        var gp = null; // grandparent\n        var ggp = head; // grand-grand-parent\n        var p = null; // parent\n        var node = this._root;\n        ggp.right = this._root;\n\n        // search down\n        while(true) {\n            if(node === null) {\n                // insert new node at the bottom\n                node = new Node(data);\n                p.set_child(dir, node);\n                ret = true;\n                this.size++;\n            }\n            else if(is_red(node.left) && is_red(node.right)) {\n                // color flip\n                node.red = true;\n                node.left.red = false;\n                node.right.red = false;\n            }\n\n            // fix red violation\n            if(is_red(node) && is_red(p)) {\n                var dir2 = ggp.right === gp;\n\n                if(node === p.get_child(last)) {\n                    ggp.set_child(dir2, single_rotate(gp, !last));\n                }\n                else {\n                    ggp.set_child(dir2, double_rotate(gp, !last));\n                }\n            }\n\n            var cmp = this._comparator(node.data, data);\n\n            // stop if found\n            if(cmp === 0) {\n                break;\n            }\n\n            last = dir;\n            dir = cmp < 0;\n\n            // update helpers\n            if(gp !== null) {\n                ggp = gp;\n            }\n            gp = p;\n            p = node;\n            node = node.get_child(dir);\n        }\n\n        // update root\n        this._root = head.right;\n    }\n\n    // make root black\n    this._root.red = false;\n\n    return ret;\n};\n\n// returns true if removed, false if not found\nRBTree.prototype.remove = function(data) {\n    if(this._root === null) {\n        return false;\n    }\n\n    var head = new Node(undefined); // fake tree root\n    var node = head;\n    node.right = this._root;\n    var p = null; // parent\n    var gp = null; // grand parent\n    var found = null; // found item\n    var dir = 1;\n\n    while(node.get_child(dir) !== null) {\n        var last = dir;\n\n        // update helpers\n        gp = p;\n        p = node;\n        node = node.get_child(dir);\n\n        var cmp = this._comparator(data, node.data);\n\n        dir = cmp > 0;\n\n        // save found node\n        if(cmp === 0) {\n            found = node;\n        }\n\n        // push the red node down\n        if(!is_red(node) && !is_red(node.get_child(dir))) {\n            if(is_red(node.get_child(!dir))) {\n                var sr = single_rotate(node, dir);\n                p.set_child(last, sr);\n                p = sr;\n            }\n            else if(!is_red(node.get_child(!dir))) {\n                var sibling = p.get_child(!last);\n                if(sibling !== null) {\n                    if(!is_red(sibling.get_child(!last)) && !is_red(sibling.get_child(last))) {\n                        // color flip\n                        p.red = false;\n                        sibling.red = true;\n                        node.red = true;\n                    }\n                    else {\n                        var dir2 = gp.right === p;\n\n                        if(is_red(sibling.get_child(last))) {\n                            gp.set_child(dir2, double_rotate(p, last));\n                        }\n                        else if(is_red(sibling.get_child(!last))) {\n                            gp.set_child(dir2, single_rotate(p, last));\n                        }\n\n                        // ensure correct coloring\n                        var gpc = gp.get_child(dir2);\n                        gpc.red = true;\n                        node.red = true;\n                        gpc.left.red = false;\n                        gpc.right.red = false;\n                    }\n                }\n            }\n        }\n    }\n\n    // replace and remove if found\n    if(found !== null) {\n        found.data = node.data;\n        p.set_child(p.right === node, node.get_child(node.left === null));\n        this.size--;\n    }\n\n    // update root and make it black\n    this._root = head.right;\n    if(this._root !== null) {\n        this._root.red = false;\n    }\n\n    return found !== null;\n};\n\nfunction is_red(node) {\n    return node !== null && node.red;\n}\n\nfunction single_rotate(root, dir) {\n    var save = root.get_child(!dir);\n\n    root.set_child(!dir, save.get_child(dir));\n    save.set_child(dir, root);\n\n    root.red = true;\n    save.red = false;\n\n    return save;\n}\n\nfunction double_rotate(root, dir) {\n    root.set_child(!dir, single_rotate(root.get_child(!dir), !dir));\n    return single_rotate(root, dir);\n}\n\nmodule.exports = RBTree;\n","\nvar TreeBase = require('./treebase');\n\nfunction Node(data) {\n    this.data = data;\n    this.left = null;\n    this.right = null;\n}\n\nNode.prototype.get_child = function(dir) {\n    return dir ? this.right : this.left;\n};\n\nNode.prototype.set_child = function(dir, val) {\n    if(dir) {\n        this.right = val;\n    }\n    else {\n        this.left = val;\n    }\n};\n\nfunction BinTree(comparator) {\n    this._root = null;\n    this._comparator = comparator;\n    this.size = 0;\n}\n\nBinTree.prototype = new TreeBase();\n\n// returns true if inserted, false if duplicate\nBinTree.prototype.insert = function(data) {\n    if(this._root === null) {\n        // empty tree\n        this._root = new Node(data);\n        this.size++;\n        return true;\n    }\n\n    var dir = 0;\n\n    // setup\n    var p = null; // parent\n    var node = this._root;\n\n    // search down\n    while(true) {\n        if(node === null) {\n            // insert new node at the bottom\n            node = new Node(data);\n            p.set_child(dir, node);\n            ret = true;\n            this.size++;\n            return true;\n        }\n\n        // stop if found\n        if(this._comparator(node.data, data) === 0) {\n            return false;\n        }\n\n        dir = this._comparator(node.data, data) < 0;\n\n        // update helpers\n        p = node;\n        node = node.get_child(dir);\n    }\n};\n\n// returns true if removed, false if not found\nBinTree.prototype.remove = function(data) {\n    if(this._root === null) {\n        return false;\n    }\n\n    var head = new Node(undefined); // fake tree root\n    var node = head;\n    node.right = this._root;\n    var p = null; // parent\n    var found = null; // found item\n    var dir = 1;\n\n    while(node.get_child(dir) !== null) {\n        p = node;\n        node = node.get_child(dir);\n        var cmp = this._comparator(data, node.data);\n        dir = cmp > 0;\n\n        if(cmp === 0) {\n            found = node;\n        }\n    }\n\n    if(found !== null) {\n        found.data = node.data;\n        p.set_child(p.right === node, node.get_child(node.left === null));\n\n        this._root = head.right;\n        this.size--;\n        return true;\n    }\n    else {\n        return false;\n    }\n};\n\nmodule.exports = BinTree;\n\n","import { RBTree } from 'bintrees';\n\nconst tmpRange = [0, 1];\n\n/**\n * Table to manage ids that can be  reserved and released and keep the\n * id values as compact as possible.\n */\nexport class ReusableIds {\n  /**\n   * Construct the id table\n   */\n  constructor(lowId, highId, reserve) {\n    this._lowId = lowId === undefined ? 0 : (lowId | 0);\n    this._highId = highId === undefined ? 4 * 1024 * 1024 * 1024 - 1 : (highId | 0);\n    this._availableIds = new RBTree(function(a, b) { return a[0] - b[0]; });\n    this._availableIds.insert([this._lowId + (reserve | 0), this._highId]);\n  }\n\n  /**\n   * Get next id\n   * @return {number|undefined} The next id or undefined if there aren't any more ids.\n   */\n  reserveId() {\n    const range = this._availableIds.min();\n    if (range === null)\n      return undefined;\n    const id = range[0];\n    if (id >= range[1]) {\n      // Remove the empty range.\n      this._availableIds.remove(range);\n    } else {\n      // Updating the key of the RBTree without removing and inserting it\n      // is probably not correct, but the ranges are all disjoint and so it should be OK\n      ++range[0];\n    }\n    return id;\n  }\n\n  /**\n   * Make an id available again\n   * @param {number} id The id\n   * @return {Boolean} True if the id can be released.\n   */\n  releaseId(id) {\n    if (id < this._lowId || id > this._highId)\n      return false;\n\n    tmpRange[0] = id;   // Only the first\n    let ranges = this._availableIds.lowerBound(tmpRange);\n    const upper = ranges.data();\n    if (upper !== null) {\n      // Make sure the id isn't already in a range\n      if (upper[0] <= id && upper[1] >= id) {\n        return false;\n      }\n\n      ranges.prev();\n      const lower = ranges.data();\n      if (id + 1 === upper[0]) {\n        if (lower === null || id - 1 > lower[1]) {\n          // Extend the upper range to include id\n          // Updating the key of the RBTree without removing and inserting it\n          // is probably not correct, but the ranges are all disjoint and so it should be OK\n          upper[0] = id;\n        } else {\n          // Combine upper and lower ranges\n          this._availableIds.remove(upper);\n          this._availableIds.remove(lower);\n          upper[0] = lower[0];\n          this._availableIds.insert(upper);\n        }\n      } else if (lower === null || id - 1 > lower[1]) {\n        // Add a new single id range\n        this._availableIds.insert([id, id]);\n      } else {\n        // Extend the lower range\n        // Updating the key of the RBTree without removing and inserting it\n        // is probably not correct, but the ranges are all disjoint and so it should be OK\n        lower[1] = id;\n      }\n    }\n\n    return true;\n  }\n\n  isIdReserved(id) {\n    if (id < this._lowId || id > this._highId)\n      return false;\n\n    tmpRange[0] = id;   // Only the first\n    const upper = this._availableIds.upperBound(tmpRange).prev();\n    return !upper || id < upper[0] || id > upper[1];\n  }\n}\n","import { ReusableIds } from \"./reusableIds\";\n\nconst av = Autodesk.Viewing;\nconst avp = av.Private;\nconst tmpMatrix = new THREE.Matrix4();\nconst tmpBox = new THREE.Box3();\nconst tmpMin = new THREE.Vector3();\nconst tmpMax = new THREE.Vector3();\nconst missingGeometry = { svfid: 0, boundingBox: new THREE.Box3() };\nconst meshInfo = {\n    geometry: null,\n    material: undefined,\n    matrix: tmpMatrix,\n    isLine: false,\n    isWideLine: false,\n    isPoint: false\n};\nconst isLines = avp.MeshFlags.MESH_ISLINE;\nconst isWideLines = avp.MeshFlags.MESH_ISWIDELINE;\nconst isPoints = avp.MeshFlags.MESH_ISPOINT;\nconst clearFlags = ~(isLines | isWideLines | isPoints);\nconst defaultMtlName = \"__defaultMaterial__\";\nconst REMOVED_EVENT = { type: \"removed\" };\n\nconst ROOT_NODE_ID = -1e9;   // Large negative number for root node id\nconst START_FRAG_ID = -100;  // Place where fragments without dbids are put\n\n// See InstanceTreeAccess in src/wgs/scene/InstanceTreeStorage.js\nclass SceneBuilderNodeAccess {\n    constructor() {\n        this.rootId = ROOT_NODE_ID;\n        this.nodeIndices = new ReusableIds(1);\n        this.dbIdToIndex = { [ROOT_NODE_ID]: 0};\n        this._nodeCount = 1;\n        this._maxIndex = 0;\n        this._nodeFlags = [0];\n        this._indexToFragId = [];\n        this._rootName = av.i18n.translate(\"Root\");\n    }\n\n    getIndex(id) {\n        return this.dbIdToIndex[id];\n    }\n\n    getNumNodes() {\n        // Use _maxIndex + 1 instead of _nodeCount. The ModelBrowserPanel get indices from the\n        // instance tree and assumes that they are < getNumNodes(). This guarantees that\n        // is true. _maxIndex + 1 will be >= _nodeCount and <= the fragment count.\n        return this._maxIndex + 1;\n    }\n\n    getParentId(nodeId) {\n        return nodeId === this.rootId ? undefined : this.rootId;\n    }\n\n    getNodeFlags(dbId) {\n        const index = this.dbIdToIndex[dbId];\n        return index >= 0 ? this._nodeFlags[index] : undefined;\n    }\n\n    setNodeFlags(dbId, flags) {\n        const index = this.dbIdToIndex[dbId];\n        if (index !== undefined)\n            this._nodeFlags[index] = flags;\n    }\n\n    name(nodeId, includeCount) {\n        return nodeId === this.rootId ?\n            ((includeCount && this._nodeCount > 1) ? `${this._rootName}(${this._nodeCount - 1})` : this._rootName) :\n            av.i18n.translate(\"Object %(nodeId)d\", {\n                postProcess: 'sprintf', sprintf: {\n                    nodeId:     nodeId,\n                }\n            });\n    }\n\n    getNodeBox(dbId, dst) {\n        dst.setEmpty();\n    }\n\n    getNumChildren(nodeId) {\n        return nodeId == this.rootId ? this._nodeCount - 1 : 0;\n    }\n\n    getNumFragments(nodeId) {\n        if (nodeId === this.rootId)\n            return 0;\n        const index = this.dbIdToIndex[nodeId];\n        if (index === undefined)\n            return 0;\n        const frags = this._indexToFragId[index];\n        return Array.isArray(frags) ? frags.length : 1;\n    }\n\n    enumNodeFragments(node, callback) {\n        if (node === this.rootId)\n            return;\n        const index = this.dbIdToIndex[node];\n        if (index === undefined)\n            return;\n        const frags = this._indexToFragId[index];\n        if (Array.isArray(frags)) {\n            for (let i = 0; i < frags.length; ++i)\n                callback(frags[i], node, index);\n        } else\n            callback(frags, node, index);\n    }\n\n    enumNodeChildren(dbId, callback) {\n        if (dbId !== this.rootId)\n            return;\n        const dbids = Object.keys(this.dbIdToIndex);\n        for (let i = 0; i < dbids.length; ++i) {\n            const child = parseInt(dbids[i]);\n            if (child !== this.rootId) {\n                callback(child, dbId, 0);\n            }\n        }\n    }\n\n    addFragment(nodeId, fragId) {\n        let index = this.dbIdToIndex[nodeId];\n        if (index === undefined) {\n            index = this.nodeIndices.reserveId();\n            this.dbIdToIndex[nodeId] = index;\n            this._nodeFlags[index] = 0;\n            ++this._nodeCount;\n            if (index > this._maxIndex)\n                this._maxIndex = index;\n        }\n        const frags = this._indexToFragId[index];\n        if (frags === undefined)\n            this._indexToFragId[index] = fragId;\n        else if (Array.isArray(frags))\n            frags.push(fragId);\n        else\n            this._indexToFragId[index] = [frags, fragId];\n    }\n\n    removeFragment(nodeId, fragId) {\n        let index = this.dbIdToIndex[nodeId];\n        if (index !== undefined) {\n            const frags = this._indexToFragId[index];\n            if (Array.isArray(frags)) {\n                const i = frags.indexOf(fragId);\n                if (i >= 0 && frags.length === 2)\n                    this._indexToFragId[index] = frags[1 - i];\n                else\n                    frags.splice(i, 1);\n            } else {\n                this.nodeIndices.releaseId();\n                delete this.dbIdToIndex[nodeId];\n                delete this._indexToFragId[index];\n                --this._nodeCount;\n            }\n        }\n    }\n}\n\nclass EmptyModelLoader {\n    constructor(viewer) {\n        this.viewer3DImpl = viewer;\n    }\n\n    loadFile(url, options, onDone, onWorkerStart) {\n        onWorkerStart && onWorkerStart();\n        //Make the initial blank model\n        const initialSize = options.conserveMemory ? 1 : 0;\n        let svf = {\n            bbox : new THREE.Box3().set(options.globalOffset, options.globalOffset),\n            fragments: {\n                length: initialSize,\n                fragId2dbId: [0],\n                transforms: initialSize ? new Float32Array(initialSize * 12) : null,\n                boxes: initialSize ? new Float32Array(initialSize * 6) : null\n            },\n            is2d: false,\n            loadOptions: options || {},\n            isSceneBuilder: true,\n            loadDone: true, // True as model is empty\n            instanceTree: new avp.InstanceTree(new SceneBuilderNodeAccess(), 0, 1),\n            metadata: {}\n        };\n        let model = new av.Model(svf);\n\n        let name;\n        if (options && options.modelNameOverride) {\n            name = options.modelNameOverride;\n            // Undefine this in the options so the model browser panel will use\n            // the same name we copy to the instance tree. The instance tree will\n            // append the object count to the model name, but not if the name\n            // is take directly from the options.\n            options.modelNameOverride = undefined;\n        } else {\n            name = av.i18n.translate('Scene Builder %(modelId)d', {\n                postProcess: 'sprintf', sprintf: {\n                    modelId:    model.getModelId()\n                }\n            });\n        }\n\n        svf.instanceTree.nodeAccess._rootName = name;\n        svf.urn = btoa(name);\n        this.svf = svf;\n\n        model.initialize();\n        model.loader = this;\n        this.model = model;\n        model.getFragmentList().isFixedSize = false;\n        onDone(null, model);\n        this.viewer3DImpl.api.dispatchEvent({type:av.MODEL_ROOT_LOADED_EVENT, svf:svf, model:model});\n        this.viewer3DImpl.onLoadComplete(model);\n    }\n\n    dtor() {\n    }\n\n    is3d() {\n        return true;\n    }\n}\n\n/**\n * @param transform\n * @param dstMatrix\n * @private\n */\nfunction convertMatrix(transform, dstMatrix) {\n    if (!transform) {\n        dstMatrix.identity();\n    } else if (transform instanceof THREE.Matrix4) {\n        dstMatrix.copy(transform);\n    } else {\n        const dst = dstMatrix.elements;\n        dst[0] = transform[0];\n        dst[1] = transform[1];\n        dst[2] = transform[2];\n        dst[3] = 0;\n        dst[4] = transform[3];\n        dst[5] = transform[4];\n        dst[6] = transform[5];\n        dst[7] = 0;\n        dst[8] = transform[6];\n        dst[9] = transform[7];\n        dst[10] = transform[8];\n        dst[11] = 0;\n        dst[12] = transform[9];\n        dst[13] = transform[10];\n        dst[14] = transform[11];\n        dst[15] = 1;\n    }\n\n    return dstMatrix;\n}\n\n/**\n * Get the fragment id for a fragment\n *\n * @param {number|THREE.Mesh} fragment The mesh or the fragment id for a fragment.\n * @returns {number} The id of the fragment\n * @private\n */\nfunction getFragmentId(fragment) {\n    return (fragment instanceof THREE.Mesh) ? fragment.fragId : fragment;\n}\n\n/**\n * @param modelBuilder\n * @param fragment\n * @param geometry\n * @param material\n * @param transform\n * @param bbox\n * @private\n */\nfunction changeFragmentGeometry(modelBuilder, fragment, geometry, material, transform, bbox) {\n    // get the fragment id\n    const fragId = getFragmentId(fragment);\n\n    const model = modelBuilder.model;\n    const fragList = modelBuilder.fragList;\n\n    // Get the geometry\n    missingGeometry.geometry = (geometry === undefined ? modelBuilder.fragList.getGeometryId(fragId) :\n        (geometry instanceof THREE.BufferGeometry ? geometry.svfid : geometry)) || 0;\n    geometry = geometry === undefined ? modelBuilder.fragList.getGeometry(fragId) : modelBuilder._getGeometry(geometry);\n\n    // Get the material\n    const mtl = material === undefined ? modelBuilder.fragList.getMaterial(fragId) : modelBuilder._getMaterial(material);\n\n    let mesh = !modelBuilder.conserveMemory && model.getFragmentList().getVizmesh(fragId);\n    if (mesh) {\n        mesh.dispatchEvent(REMOVED_EVENT);\n    } else\n        mesh = meshInfo;\n\n    // Get the material\n    mesh.material = mtl;\n    // Clear the vizflags, that may be left over.\n    if (fragId < fragList.vizflags.length)\n        fragList.vizflags[fragId] &= ~clearFlags;\n    // We need to mark whether the fragment is a line, wideline, or points\n    // If we don't have geometry, assume false, which will get fixed when\n    // the geometry is available.\n    mesh.geometry = geometry;\n    if (geometry) {\n        mesh.isLine = geometry.isLines;\n        mesh.isWideLine = geometry.isWideLines;\n        mesh.isPoint = geometry.isPoints;\n    } else {\n        mesh.geometry = missingGeometry;\n        mesh.isLine = false;\n        mesh.isWideLine = false;\n        mesh.isPoint = false;\n    }\n    // Get the transform\n    mesh.matrix = convertMatrix(transform, mesh === meshInfo ? tmpMatrix : mesh.matrix);\n    // Get the bounding box, if it is provided by the caller. Use meshInfo because\n    // bbox doesn't work when conserveMemory is false.\n    meshInfo.bbox = bbox && (bbox instanceof THREE.Box3 ? bbox :\n        tmpBox.set(tmpMin.fromArray(bbox, 0), tmpMax.fromArray(bbox, 3)));\n    fragList.fragments.fragId2dbId[fragId] = START_FRAG_ID - fragId;\n    modelBuilder.instanceTree.nodeAccess.addFragment(START_FRAG_ID - fragId, fragId);\n    model.setFragment(fragId, mesh, mesh !== meshInfo);\n    if (fragList.useThreeMesh && !geometry)\n        fragList.getVizmesh(fragId).geometry = null;\n\n    modelBuilder.sceneUpdated(true);\n    return true;\n}\n\n/**\n * @param geometry\n * @param dst\n * @private\n */\nfunction calculateBBox(geometry, dst) {\n    dst.makeEmpty();\n    avp.VertexEnumerator.enumMeshVertices(geometry, function(pos) {\n        dst.expandByPoint(pos);\n    });\n    return dst;\n}\n\n/**\n * @param matman\n * @param hash\n * @param material\n * @private\n */\nfunction addMaterial(matman, hash, material) {\n    if (material instanceof THREE.MeshPhongMaterial ||\n        (material instanceof THREE.ShaderMaterial && material.isPrismMaterial)) {\n        matman.addMaterial(hash, material, true);\n    } else\n        matman.addMaterialNonHDR(hash, material);\n}\n\n/**\n * @param newDbId\n * @param fragId\n * @param fragId2dbId\n * @param instanceTree\n * @private\n */\nfunction changeDbId(newDbId, fragId, fragId2dbId, instanceTree) {\n    const oldDbId = fragId2dbId[fragId] | 0;\n    newDbId = newDbId || START_FRAG_ID - fragId;\n    fragId2dbId[fragId] = newDbId;\n    if (newDbId === oldDbId)\n        return;\n\n    instanceTree.nodeAccess.removeFragment(oldDbId, fragId);\n    instanceTree.nodeAccess.addFragment(newDbId, fragId);\n}\n\n/**\n * Class that implements the API for building models dynamically.\n * An instance of this class can be obtained after the Promise returned by {@link Autodesk.Viewing.Extensions.SceneBuilder#addNewModel}\n * is resolved.\n * \n * @memberof Autodesk.Viewing.Extensions\n * @alias Autodesk.Viewing.Extensions.ModelBuilder\n * \n * @property {Autodesk.Viewing.Model} model The model instance being manipulated.\n */\nclass ModelBuilder {\n    \n    /**\n     * The constructor is invoked automatically by {@link Autodesk.Viewing.Extensions.SceneBuilder}.\n     * \n     * @class\n     * @param {Autodesk.Viewing.Model} model The model this build works on\n     * @param {object} [options] Options for the ModelBuilder\n     * @param {boolean} [options.conserveMemory=false] Set to true to turn on memory conservation mode.\n     *  In this mode [addMesh()]{@link Autodesk.Viewing.Extensions.ModelBuilder#addMesh} is not available because \n     *  a single mesh is shared among all of the fragments in the model.\n     */\n    constructor(model, options) {\n        this.model = model;\n        this.geomList = model.getGeometryList();\n        this.fragList = model.getFragmentList();\n        // Initialize the ids we use for geometry and fragments.\n        this.geomIds = new ReusableIds(1);\n        this.fragmentIds = new ReusableIds(Math.max(model.getData().fragments.length, 1));\n        this.conserveMemory = !!(options && options.conserveMemory);\n        this.instanceTree = model.getData().instanceTree;\n        this.instanceTree.setFragmentList(this.fragList);\n        this.createWireframe = !!(options && options.createWireframe);\n    }\n\n    /**\n     * @returns {boolean} true when the model being manipulated is using the memory-optimized code path.\n     * @alias Autodesk.Viewing.Extensions.ModelBuilder#isConservingMemory\n     */\n    isConservingMemory() {\n        return this.conserveMemory;\n    }\n\n    /**\n     * Add geometry to the model.\n     * \n     * @param {THREE.BufferGeometry} geometry The geometry to add. This can be null or\n     *  undefined to allocate a geometry id without geometry.\n     * @param {number} [numFragments] The number of fragments you expect this geometry\n     *  to be used in. Default is 1. This is used to prioritize placing geometry on the\n     *  GPU. Geometry used by more fragments gets a higher priority.\n     * @returns {number} The id of the added geometry, or 0 if there was an error.\n     * \n     * @alias Autodesk.Viewing.Extensions.ModelBuilder#addGeometry\n     */\n    addGeometry(geometry, numFragments) {\n        // Must have geometry and it must not be in a model\n        if (geometry && geometry.svfid !== undefined)\n            return 0;\n\n        // Get the new geometry id\n        const geomId = this.geomIds.reserveId();\n        if (geomId === undefined)\n            return 0;   // 4 billion fragments? not likely\n\n        if (geometry) {\n            if (this.createWireframe) {\n                avp.createWireframe(geometry);\n\n                if (!geometry.attributes.indexlines) {\n                    // add attribute for edge rendering\n                    const attrIndexLines = new THREE.BufferAttribute(undefined, 1);\n                    attrIndexLines.bytesPerItem = geometry.iblines instanceof Uint32Array ? 4 : 2;\n                    geometry.setAttribute( 'indexlines', attrIndexLines);\n                    geometry.iblinesbuffer = undefined;\n                }\n\n                // Add index for the renderer to draw the lines\n                if (!geometry.attributes.index) {\n                    const indices = new Uint16Array(geometry.attributes.position.length / 3);\n                    for (let i = 0; i < indices.length; ++i) {\n                        indices[i] = i;\n                    }\n                    const iba = new THREE.BufferAttribute(indices, 1);\n                    iba.bytesPerItem = 2;\n                    geometry.setAttribute('index', iba);\n                }\n            }\n            // Sort of ugly - the geometry list will set geometry.boundingBox to null,\n            // but if we aren't conserving memory we need to keep the bounding box.\n            var bbox = geometry.boundingBox = geometry.boundingBox ||\n                calculateBBox(geometry, this.conserveMemory ? tmpBox : new THREE.Box3());\n            this.geomList.addGeometry(this.packNormals(geometry), numFragments, geomId);\n            if (!this.conserveMemory)\n                geometry.boundingBox = bbox;\n        }\n\n        return geomId;\n    }\n\n    /**\n     * Update fragments to use a new geometry id.\n     *\n     * @param {object.<number,boolean>} oldGeomIds Existing geometry ids\n     * @param {number} newGeomId New geometry id\n     * @private\n     */\n    _updateGeometry(oldGeomIds, newGeomId) {\n        const fragList = this.fragList;\n        let update = false;\n        if (this.conserveMemory) {\n            const geomids = fragList.geomids;\n            for (let i = 0; i < geomids.length; ++i) {\n                if (oldGeomIds[geomids[i]]) {\n                    this.changeFragmentGeometry(i, newGeomId);\n                    update = true;\n                }\n            }\n        } else {\n            const meshes = fragList.vizmeshes;\n            for (let i = 0; i < meshes.length; ++i) {\n                const mesh = meshes[i];\n                if (mesh && mesh.geometry && oldGeomIds[mesh.geometry.svfid]) {\n                    this.changeFragmentGeometry(i, newGeomId);\n                    update = true;\n                }\n            }\n        }\n\n        if (update)\n            this.sceneUpdated(true);\n    }\n\n    /**\n     * Validate geometry from caller\n     *\n     * @param {number|THREE.BufferGeometry|Array<number|THREE.BufferGeometry>} geometry The geometry or ids of the geometry\n     *  to validate.\n     * @returns {object.<string, boolean>} A map from id to true for the validated geometry. Null is returned if any\n     *  of the geometry is invalid.\n     * @private\n     */\n    _validateGeometry(geometry) {\n        if (!Array.isArray(geometry))\n            geometry = [geometry];\n\n        const search = {};\n        const geomList = this.geomList;\n        for (let i = 0; i < geometry.length; ++i) {\n            // Make sure geometry is valid\n            let id = geometry[i];\n            if (id instanceof THREE.BufferGeometry) {\n                // The geometry is a BufferGeometry make sure it is right\n                if (geomList.getGeometry(id.svfid) != id)\n                    return null;\n                id = id.svfid;\n            }\n            if (!this.geomIds.isIdReserved(id))\n                return null;\n            search[id] = true;\n        }\n\n        return search;\n    }\n\n    /**\n     * Change geometry in a model.\n     *\n     * @param {number|THREE.BufferGeometry} existingGeom The geometry or the id of the geometry to change\n     * @param {THREE.BufferGeometry} geometry Geometry that replaces the existing geometry\n     * @param {number} [numFragments] The number of fragments using this geometry.\n     *  If not given, then we will count the number in the model. This is used to\n     *  prioritize placing geometry on the GPU. Geometry used by more fragments\n     *  gets a higher priority.\n     * @returns {boolean} True if the existing geometry is valid and the geometry was changed.\n     * @alias Autodesk.Viewing.Extensions.ModelBuilder#changeGeometry\n     */\n    changeGeometry(existingGeom, geometry, numFragments) {\n        const result = this._validateGeometry(existingGeom);\n        if (!result)\n            return false;\n        const geomId = parseInt(Object.keys(result)[0]);\n        const geomList = this.geomList;\n        // Make sure existing geomId and the new geometry are valid\n        if (!geometry || (geometry && geometry.svfid !== undefined))\n            return false;\n\n        // remove the geometry\n        let oldGeom = geomList.getGeometry(geomId);\n        geomList.removeGeometry(geomId);\n\n        // Count the number of fragment using geomId\n        if (numFragments === undefined) {\n            numFragments = 0;\n            const fragList = this.fragList;\n            if (fragList.useThreeMesh) {\n                // Using THREE.Mesh directly, need to look there for the geometry\n                if (oldGeom) {\n                    const meshes = fragList.vizmeshes;\n                    for (let i = 0; i < meshes.length; ++i) {\n                        if (meshes[i] && meshes[i].geometry === oldGeom)\n                            ++numFragments;\n                    }\n                }\n            } else {\n                // Using geomIds, so look and fragment to geomId map\n                const frag2geom = fragList.geomids;\n                for (let i = 0; i < frag2geom.length; ++i) {\n                    if (frag2geom[i] === geomId)\n                        ++numFragments;\n                }\n            }\n            numFragments = numFragments || 1;\n        }\n\n\n        // Sort of ugly - the geometry list will set geometry.boundingBox to null,\n        // but if we aren't conserving memory we need to keep the bounding box.\n        var bbox = geometry.boundingBox = geometry.boundingBox ||\n            calculateBBox(geometry, this.conserveMemory ? tmpBox : new THREE.Box3());\n        geomList.addGeometry(this.packNormals(geometry), numFragments, geomId);\n        if (!this.conserveMemory)\n            geometry.boundingBox = bbox;\n\n        this._updateGeometry(result, geomId);\n        // clear old geomId\n        if (oldGeom)\n            oldGeom.svfid = undefined;\n        return true;\n    }\n\n    /**\n     * Find fragments using a specific geometry.\n     *\n     * @param {number|THREE.BufferGeometry|Array<number|THREE.BufferGeometry>} geometry The geometry\n     *  or id(s) of the geometry to use in the search\n     * @returns {number[]} An array with the fragment ids for all fragments that were using\n     *  the geometry. Null is returned if any geometry is invalid.\n     * @alias Autodesk.Viewing.Extensions.ModelBuilder#findGeometryFragments\n     */\n    findGeometryFragments(geometry) {\n        const search = this._validateGeometry(geometry);\n\n        const frags = [];\n        const fragList = this.fragList;\n        if (fragList.useThreeMesh) {\n            // Using THREE.Mesh for the fragments, look there for the objects\n            const meshes = fragList.vizmeshes;\n            for (let i = 0; i < meshes.length; ++i) {\n                const id = meshes[i] && meshes[i].geometry && meshes[i].geometry.svfid;\n                if (search[id])\n                    frags.push(i);\n            }\n        } else {\n            // Using geom ids for the fragments, look and the fragment to geom id map\n            const geomids = fragList.geomids;\n            for (let i = 0; i < geomids.length; ++i) {\n                if (search[geomids[i]])\n                    frags.push(i);\n            }\n        }\n\n        return frags;\n    }\n\n    /**\n     * Remove geometry from the model.\n     * The caller should dispose the geometry if needed.\n     *\n     * @param {number|THREE.BufferGeometry|Array<number|THREE.BufferGeometry>} geometry The geometry or id(s) of the geometry to remomve\n     * @returns {boolean} True if all of the ids are valid and the geometry is removed.\n     * @alias Autodesk.Viewing.Extensions.ModelBuilder#removeGeometry\n     */\n    removeGeometry(geometry) {\n\n        const delMap = this._validateGeometry(geometry);\n        if (!delMap)\n            return false;\n        const geomList = this.geomList;\n\n        this._updateGeometry(delMap, 0);\n\n        const delIds = Object.keys(delMap);\n        for (let i = 0; i < delIds.length; ++i) {\n            const geomId = parseInt(delIds[i]);\n            const geometry = geomList.getGeometry(geomId);\n            if (geometry)\n                geometry.svfid = undefined;\n            geomList.removeGeometry(geomId);\n            this.geomIds.releaseId(geomId);\n        }\n\n        return true;\n    }\n\n    /**\n     * Add a material that can be used by a mesh in the model.\n     *\n     * @param {string} name The name used for the material. This name must not be\n     *  used for an existing material in the model.\n     * @param {THREE.Material} material The material to add. This material must not\n     *  be used in the model.\n     * @returns {boolean} True if the material was added.\n     * @alias Autodesk.Viewing.Extensions.ModelBuilder#addMaterial\n     */\n    addMaterial(name, material) {\n        if (!material || material.materialManagerName)\n            return false;\n        name = name || \"!!mtl-\" + material.id;\n        const matman = this.model.loader.viewer3DImpl.matman();\n        const hash = matman._getMaterialHash(this.model, name);\n        // Name must not be used and material must be valid.\n        if (name === defaultMtlName || matman._materials[hash] || matman._materialsNonHDR[hash])\n            return false;\n        if (!material.packedNormals) {\n            material.packedNormals = true;\n            material.needsUpdate = true;\n        }\n\n        addMaterial(matman, hash, material);\n\n        material.materialManagerName = name;\n\n        return true;\n    }\n\n    /**\n     * Validate materials from caller\n     *\n     * @param {number|THREE.Material|Array<number|THREE.Material>} materials The materials or namess of the materials\n     *  to validate.\n     * @returns {string[]} An array of the hashes of the validated materials. Null is returned if any\n     *  of the materials are invalid.\n     * @private\n     */\n    _validateMaterials(materials) {\n        if (!Array.isArray(materials))\n            materials = [materials];\n\n        const matman = this.model.loader.viewer3DImpl.matman();\n        const mtls = [];\n        for (let i = 0; i < materials.length; ++i) {\n            let name = materials[i];\n            let oldMat;\n            let hash;\n            if (name instanceof THREE.Material) {\n                oldMat = name;\n                name = name.materialManagerName;\n                hash = matman._getMaterialHash(this.model, name);\n                // Name must be the right material\n                if (oldMat !== (matman._materials[hash] || matman._materialsNonHDR[hash]))\n                    return null;\n            } else {\n                hash = matman._getMaterialHash(this.model, name);\n                // Name must be used\n                const oldMat = matman._materials[hash] || matman._materialsNonHDR[hash];\n                if (!oldMat)\n                    return null;\n            }\n\n            mtls.push(hash);\n        }\n\n        return mtls;\n    }\n\n    /**\n     * Replaces an existing material with another one.\n     *\n     * @param {string|THREE.Material} existingMaterial The material or name of the material to change. The material\n     *  must be in the model.\n     * @param {THREE.Material} material The material to replace the existing material. This material\n     *  must not be used in the model.\n     * @returns {boolean} True if the material is valid and the material was changed.\n     * @alias Autodesk.Viewing.Extensions.ModelBuilder#changeMaterial\n     */\n    changeMaterial(existingMaterial, material) {\n        if (!material || material.materialManagerName)\n            return false;\n        const mtls = this._validateMaterials(existingMaterial);\n        if (!mtls)\n            return false;\n\n        const matman = this.model.loader.viewer3DImpl.matman();\n        const hash = mtls[0];\n        const oldMat = matman._materials[hash] || matman._materialsNonHDR[hash];\n        const name = oldMat.materialManagerName;\n        if (!material.packedNormals) {\n            material.packedNormals = true;\n            material.needsUpdate = true;\n        }\n\n        addMaterial(matman, hash, material);\n        oldMat.materialManagerName = undefined;\n        material.materialManagerName = name;\n\n        const fragList = this.fragList;\n        if (fragList.useThreeMesh) {\n            // Using meshes, need to replace the material in each mesh\n            const meshes = fragList.vizmeshes;\n            for (let i = 0; i < meshes.length; ++i) {\n                if (meshes[i] && meshes[i].material === oldMat)\n                    meshes[i].material = material;\n            }\n        } else {\n            // This is easier, because we just need to update the material\n            // at the right id\n            const matId = fragList.materialmap[oldMat.id];\n            if (matId !== undefined) {\n                fragList.materialmap[material.id] = matId;\n                fragList.materialIdMap[matId] = material;\n            }\n        }\n\n        return true;\n    }\n\n    /**\n     * Find a material\n     *\n     * @param {string} name The name of the material\n     */\n    findMaterial(name) {\n        const matman = this.model.loader.viewer3DImpl.matman();\n        const hash = matman._getMaterialHash(this.model, name);\n        return matman._materials[hash] || matman._materialsNonHDR[hash];\n    }\n\n    /**\n     * Return the fragments that are using materials.\n     *\n     * @param {string|THREE.Material|Array<string|THREE.Material>} materials The materials or names of the materials to use in the search.\n     * @returns {number[]} An array with the fragment ids for all\n     *  fragments that were using the materials. Null is returned\n     *  if any material name is invalid or all of the materials were not removed.\n     * @alias Autodesk.Viewing.Extensions.ModelBuilder#findMaterialFragments\n     */\n    findMaterialFragments(materials) {\n        const hashes = this._validateMaterials(materials);\n        if (!hashes)\n            return null;\n\n        const matman = this.model.loader.viewer3DImpl.matman();\n        const fragList = this.fragList;\n        const useThreeMesh = fragList.useThreeMesh;\n        let findFrags = false;\n        const matIds = {};\n        for (let i = 0; i < hashes.length; ++i) {\n            const oldMat = matman._materials[hashes[i]] || matman._materialsNonHDR[hashes[i]];\n            const matId = useThreeMesh ? oldMat.id : fragList.materialmap[oldMat.id];\n            if (matId !== undefined) {\n                matIds[matId] = true;\n                findFrags = true;\n            }\n        }\n\n        const frags = [];\n        if (findFrags) {\n            if (useThreeMesh) {\n                // Nees to seach the meshes for the material\n                const meshes = fragList.vizmeshes;\n                const fragCount = meshes.length;\n                for (let i = 0; i < fragCount; ++i) {\n                    const id = meshes[i] && meshes[i].material && meshes[i].material.id;\n                    if (matIds[id])\n                        frags.push(i);\n                }\n            } else {\n                // Need to search to the frag id to material id map\n                const frag2MatId = fragList.materialids;\n                const fragCount = frag2MatId.length;\n                for (let i = 0; i < fragCount; ++i) {\n                    if (matIds[frag2MatId[i]])\n                        frags.push(i);\n                }\n            }\n        }\n\n        return frags;\n    }\n\n    /**\n     * Remove a material from the model.\n     * The caller should dispose the material if needed.\n     *\n     * @param {string|THREE.Material|Array<string|THREE.Material>} materials The materials or names of the materials to remove. All of the\n     *  names must be used for materials in the model.\n     * @returns {boolean} True if all of the names are valid and all of the materials are removed.\n     * @alias Autodesk.Viewing.Extensions.ModelBuilder#removeMaterial\n     */\n    removeMaterial(materials) {\n        const hashes = this._validateMaterials(materials);\n        if (!hashes)\n            return false;\n\n        const matman = this.model.loader.viewer3DImpl.matman();\n        const fragList = this.fragList;\n        const useThreeMesh = fragList.useThreeMesh;\n        const idMap = {};\n        let findFrags = false;\n\n        for (let i = 0; i < hashes.length; ++i) {\n            const oldMat = matman._materials[hashes[i]] || matman._materialsNonHDR[hashes[i]];\n            delete matman._materials[hashes[i]];\n            delete matman._materialsNonHDR[hashes[i]];\n\n            if (useThreeMesh) {\n                idMap[oldMat.id] = true;\n                findFrags = true;\n            } else {\n                const matId = fragList.materialmap[oldMat.id];\n                if (matId !== undefined) {\n                    delete fragList.materialmap[oldMat.id];\n                    delete fragList.materialIdMap[matId];\n                    idMap[matId] = true;\n                    findFrags = true;\n                }\n            }\n        }\n\n        // Map all fragments using this material to the default.\n        if (findFrags) {\n            if (useThreeMesh) {\n                // Using THREE.Mesh for the fragments, search the mesh list\n                const meshes = fragList.vizmeshes;\n                for (let i = 0; i < meshes.length; ++i) {\n                    const id = meshes[i] && meshes[i].material && meshes[i].material.id;\n                    if (idMap[id]) {\n                        fragList.setMaterial(i, this._getDefaultMaterial());\n                    }\n                }\n            } else {\n                // Use the frag to material id map to find materials to change\n                const fragToMtlId = fragList.materialids;\n                for (let i = 0; i < fragToMtlId.length; ++i) {\n                    if (idMap[fragToMtlId[i]]) {\n                        fragList.setMaterial(i, this._getDefaultMaterial());\n                    }\n                }\n            }\n        }\n\n        return true;\n    }\n\n    /**\n     * Add a fragment to the model using a mesh.\n     * Meshes can only be added to the model when {@link Autodesk.Viewing.Extensions.ModelBuilder#isConservingMemory} is false. \n     * Note the following restrictions:\n     * - A mesh cannot be used multiple times.\n     * - The geometry for a mesh cannot be used in different models.\n     * - The material for a mesh cannot be used in different models.\n     *\n     * @param {THREE.Mesh} mesh The mesh to be added.\n     * @param {boolean} [mesh.isLine=false] Optional bool to mark line geometry\n     * @param {boolean} [mesh.isWideLine=false] Optional bool to mark wide line geometry\n     * @param {boolean} [mesh.isPoint=false] Optional bool to mark point geometry\n     * @param {number} [mesh.fragId] The fragment id for the mesh. This must not be defined\n     *  when addMesh() is called and the Viewer sets this property to the new fragment id.\n     * @param {number} [mesh.modeId] The id of the model. This must not be defined when\n     *  addMesh() is called and the Viewer will set this to the id of the model for this ModelBuilder.\n     * @param {number} [mesh.dbId] An optional object id for the mesh. Meshes with the same object id\n     *  are selected as a unit. Internal tables are maintained to link fragments and dbIds. If a mesh is\n     *  in the scene you shouldn't change this value direcly. Call\n     *  {@link Autodesk.Viewing.Extensions.ModelBuilder#changeFragmentsDbId} to change it to insure\n     *  the tables are updated.\n     * @returns {boolean} True if the mesh was added.\n     * @alias Autodesk.Viewing.Extensions.ModelBuilder#addMesh\n     */\n    addMesh(mesh) {\n        if (!mesh || this.conserveMemory || mesh.modelId !== undefined || mesh.fragId !== undefined)\n            return false;\n        if (!mesh.geometry || !mesh.material)\n            return false;\n\n        // Add the geometry, if it wasn't already added\n        const svfid = mesh.geometry.svfid;\n        if (svfid) {\n            if (this.geomList.getGeometry(svfid) !== mesh.geometry)\n                return false;\n        } else if (!this.addGeometry(mesh.geometry))\n            return false;\n\n        // Add the material, if it wasn't already added\n        const mtlName = mesh.material.materialManagerName;\n        if (mtlName) {\n            if (this.findMaterial(mtlName) !== mesh.material)\n                return false;\n        } else if (!this.addMaterial(undefined, mesh.material)) {\n            svfid && this.removeGeometry(svfid);\n            return false;\n        }\n\n        const fragId = this.fragmentIds.reserveId();\n        mesh.dbId = mesh.dbId || START_FRAG_ID - fragId;\n        this.model.setFragment(fragId, mesh, true);\n        const fragments = this.fragList.fragments;\n        fragments.fragId2dbId[fragId] = mesh.dbId;\n        this.instanceTree.nodeAccess.addFragment(mesh.dbId, fragId);\n        this.sceneUpdated(true);\n        return true;\n    }\n\n    /**\n     * Remove a mesh from the model.\n     * Meshes can only be removed from the model when {@link Autodesk.Viewing.Extensions.ModelBuilder#isConservingMemory} is false.\n     *\n     * @param {THREE.Mesh|THREE.Mesh[]} meshes The meshes to be removed.\n     * @returns {boolean} True if the mesh was removed.\n     * @alias Autodesk.Viewing.Extensions.ModelBuilder#removeMesh\n     */\n    removeMesh(meshes) {\n        if (this.conserveMemory)\n            return false;\n\n        return this.removeFragment(meshes);\n    }\n\n    /**\n     * Use this method to inform the Viewer when you directly update a mesh you added\n     * to the model. If you change a mesh directly without calling this method,\n     * it may not display properly. You don't need to call this if you use the\n     * ModelBuilder API to update a mesh.\n     *\n     * @param {THREE.Mesh|THREE.Mesh[]} meshes The meshes that were changed.\n     * @param {boolean} [skipGeom=false] Set to true if the geometry in the meshes wasn't updated\n     * @param {boolean} [skipTransform=false] Set to true if the tranforms in the meshes weren't update\n     * @returns {boolean} True if the viewer was updated\n     * @alias Autodesk.Viewing.Extensions.ModelBuilder#updateMesh\n     */\n    updateMesh(meshes, skipGeom, skipTransform) {\n        // Did anything important change\n        if (skipGeom && skipTransform)\n            return true;    // No, return success\n\n        if (!Array.isArray(meshes))\n            meshes = [meshes];\n\n        let i = 0;\n        let mesh;\n        // Skip falsey meshes\n        while (!(mesh = meshes[i])) {\n            // No meshes in the input, return success;\n            if (++i >= meshes.length)\n                return true;\n        }\n\n        do {\n            if (mesh) {\n                if (!skipGeom) {\n                    this.packNormals(mesh.geometry);\n                    mesh.dispatchEvent(REMOVED_EVENT);\n                }\n                if (!skipTransform) {\n                    mesh.matrixWorld.copy(mesh.matrix);\n                }\n            }\n            mesh = meshes[++i];\n        } while (i < meshes.length);\n\n        this.sceneUpdated(!(skipGeom && skipTransform));\n        return true;\n    }\n\n    /**\n     * Signal viewer that scene was modified.\n     *\n     * @param {boolean} [objectsMoved=false] True if transforms or geometry was changed\n     * @param {boolean} [skipRepaint=false] True to skip repainting because of this change\n     * @alias Autodesk.Viewing.Extensions.ModelBuilder#sceneUpdated\n     */\n    sceneUpdated(objectsMoved, skipRepaint) {\n        this.model.loader.viewer3DImpl.sceneUpdated(objectsMoved, skipRepaint);\n    }\n\n    /**\n     * Validate the parameters for a fragment\n     *\n     * @param {number|THREE.Mesh} fragment The mesh or fragment id whose geometry is to be set.\n     * @param {number|THREE.BufferGeometry} geometry - The geometry or the id of the geometry for the fragment.\n     *  Use a falsey value if the geometry for the fragment isn't ready. If the geometry hasn't been added\n     *  to the model, this method will add it. Geometry must not be used in a different model.\n     * @param {string|THREE.material} material The material or the name of the material for the fragment.\n     *  A material name must be used by a material in the model, but a material will be added to the model\n     *  if it hasn't been.\n     * @returns {boolean} True if all parameters are valid\n     * @private\n     */\n    _validateFragment(fragment, geometry, material) {\n        if (fragment instanceof THREE.Mesh) {\n            if (!this.fragList.useThreeMesh || this.fragList.getVizmesh(fragment.fragId) !== fragment)\n                return false;\n        } else if (!this.fragmentIds.isIdReserved(fragment))\n            return false;\n\n        if (geometry) {\n            if (geometry instanceof THREE.BufferGeometry) {\n                if (geometry.svfid && this.geomList.getGeometry(geometry.svfid) !== geometry)\n                    return false;\n            } else if (!this.geomIds.isIdReserved(geometry))\n                return false;\n        }\n\n        if (material) {\n            if (material instanceof THREE.Material) {\n                if (material.materialManagerName &&\n                    this.findMaterial(material.materialManagerName) !== material) {\n                    return false;\n                }\n            } else if (!this.findMaterial(material))\n                return false;\n        }\n\n        return true;\n    }\n\n    /**\n     * Get the geometry id for some geometry\n     *\n     * @param {number|THREE.BufferGeometry} geometry The geometry or the geometry id. If this is geometry\n     *  it will be added to the model if it hasn't been.\n     * @returns {number|null} The id of the geometry, or null if the geometry is in a different model\n     * @private\n     */\n    _getGeometry(geometry) {\n        return (geometry instanceof THREE.BufferGeometry) ?\n            ((geometry.svfid || this.addGeometry(geometry)), geometry) :\n            this.geomList.getGeometry(geometry);\n    }\n\n    /**\n     * Get the material name for a material\n     *\n     * @param {number|THREE.Material} material The material or the material name. If this is a material\n     *  it will be added to the model if it hasn't been.\n     * @returns {string|null} The name of the material, or null if the material is in a different model\n     * @private\n     */\n    _getMaterial(material) {\n        if (material instanceof THREE.Material) {\n            if (material.materialManagerName) {\n                return material;\n            }\n            this.addMaterial(undefined, material);\n            return material;\n        }\n\n        return this.findMaterial(material);\n    }\n\n    /**\n     * Add a fragment to a model.\n     * A fragment is the combination of a geometry, a material, and a transform.\n     * \n     * @param {number|THREE.BufferGeometry} geometry - The geometry or the id of the geometry for the fragment.\n     *  Use a falsey value if the geometry for the fragment isn't ready. If the geometry hasn't been added\n     *  to the model, this method will add it. Geometry must not be used in a different model.\n     * @param {string|THREE.material} material The material or the name of the material instance for the fragment.\n     *  A material name must be used by a material in the model, but a material will be added to the model\n     *  if it hasn't already.\n     * @param {THREE.Matrix|number[]} [transform] The transform for the fragment. Default\n     *  is the identity transform. If an array is used it is a 4x3 matrix in column major order.\n     * @param {THREE.Box3|number[]} [bbox] Bounding box for the fragment. Default is\n     *  calculated from the geometry bounding box and the transform. \n     *  When {@link Autodesk.Viewing.Extensions.ModelBuilder#isConservingMemory} is true\n     *  then this argument is ignored and the default is used. If an array is used\n     *  it contains the minimum x, y, z followed by the maximum x, y, z.\n     * @returns {number} The fragment id added or 0 if there was an error.\n     * \n     * @alias Autodesk.Viewing.Extensions.ModelBuilder#addFragment\n     */\n    addFragment(geometry, material, transform, bbox) {\n        const fragIds = this.fragmentIds;\n        const fragId = fragIds.reserveId();\n        if (fragId === undefined || !this._validateFragment(fragId, geometry, material))\n            return 0;\n        if (changeFragmentGeometry(this, fragId, geometry, material, transform, bbox))\n            return fragId;\n        fragIds.releaseId(fragId);\n        return 0;\n    }\n\n    /**\n     * Change the geometry and transform for a fragment.\n     * \n     * @param {number|THREE.Mesh} fragment The mesh or fragment id whose geometry is to be set.\n     * @param {number|THREE.BufferGeometry} geometry - The geometry or the id of the geometry for the fragment.\n     *  Use a falsey value if the geometry for the fragment isn't ready. If the geometry hasn't been added\n     *  to the model, this method will add it. Geometry must not be used in a different model.\n     * @param {THREE.Matrix|number[]} [transform] The transform for the fragment. If not\n     *  present the transform isn't changed. If an array is used it is a 4x3 matrix in column major order.\n     * @param {THREE.Box3|number[]} [bbox] Bounding box for the fragment. Default is\n     *  calculated from the geometry bounding box and the transform. \n     *  When {@link Autodesk.Viewing.Extensions.ModelBuilder#isConservingMemory} is true\n     *  then this argument is ignored and the default is used. If an array is used\n     *  it contains the minimum x, y, z followed by the maximum x, y, z.\n     * @returns {boolean} True if the geometry id is valid and the fragment is changed.\n     * \n     * @alias Autodesk.Viewing.Extensions.ModelBuilder#changeFragmentGeometry\n     */\n    changeFragmentGeometry(fragment, geometry, transform, bbox) {\n        if (!this._validateFragment(fragment, geometry))\n            return false;\n        const fragId = getFragmentId(fragment);\n        transform = transform || (this.fragList.getOriginalWorldMatrix(fragId, tmpMatrix), tmpMatrix);\n        if (!changeFragmentGeometry(this, fragment, geometry, undefined, transform, bbox))\n            return false;\n        return true;\n    }\n\n    /**\n     * Get the default material\n     *\n     * @returns {THREE.Material} The default material\n     * @private\n     */\n    _getDefaultMaterial() {\n        // If already have default material, then use it\n        if (this._defaultMaterial)\n            return this._defaultMaterial;\n\n        // Clone the matman default.\n        const matman = this.model.loader.viewer3DImpl.matman();\n        const mtl = matman.defaultMaterial.clone();\n\n        // Make sure packed normals is true.\n        mtl.packedNormals = true;\n        mtl.needsUpdate = true;\n\n        // Add it to the material manager\n        matman.addMaterial(matman._getMaterialHash(this.model, defaultMtlName), mtl);\n        this._defaultMaterial = mtl;\n        mtl.materialManagerName = defaultMtlName;\n        return mtl;\n    }\n\n    /**\n     * Change the material for a fragment.\n     *\n     * @param {number|THREE.Mesh} fragment The mesh or fragment id whose material is to be set.\n     * @param {string|THREE.material} material The material or the name of the material for the fragment.\n     *  A material name must be used by a material in the model, but a material will be added to the model\n     *  if it hasn't been.\n     * @returns {boolean} True if the material id is valid and the fragment is changed.\n     * @alias Autodesk.Viewing.Extensions.ModelBuilder#changeFragmentMaterial\n     */\n    changeFragmentMaterial(fragment, material) {\n        if (!this._validateFragment(fragment, undefined, material))\n            return false;\n\n        // get the Material and set it for the fragment\n        const mtl = this._getMaterial(material) || this._getDefaultMaterial();\n        this.fragList.setMaterial(getFragmentId(fragment), mtl);\n        this.sceneUpdated(false);\n        return true;\n    }\n\n    /**\n     * Change the transform for a fragment.\n     *\n     * @param {number|THREE.Mesh} fragment The mesh or fragment id whose material is to be set.\n     * @param {THREE.Matrix|number[]} transform The transform for the fragment.\n     *  If an array is used it is a 4x3 matrix in column major order.\n     * @param {THREE.Box3|number[]} [bbox] [bbox] Bounding box for the fragment. Default is\n     *  calculated from the geometry bounding box and the transform. \n     *  When {@link Autodesk.Viewing.Extensions.ModelBuilder#isConservingMemory} is true\n     *  then this argument is ignored and the default is used. If an array is used\n     *  it contains the minimum x, y, z followed by the maximum x, y, z.\n     * @returns {boolean} True if the fragId is valid and the transform was changed.\n     * @alias Autodesk.Viewing.Extensions.ModelBuilder#changeFragmentTransform\n     */\n    changeFragmentTransform(fragment, transform, bbox) {\n        if (! transform || !this._validateFragment(fragment))\n            return false;\n\n        // Need to replace the geometry with the same id to change\n        // the transform.\n        const id = getFragmentId(fragment);\n        if (!this.changeFragmentGeometry(id, this.fragList.getGeometryId(id),\n            transform, bbox)) {\n            return false;\n        }\n        this.sceneUpdated(true);\n        return true;\n    }\n\n    /**\n     * Change the dbId of one or more fragments\n     *\n     * @param {number|THREE.Mesh|Array<number|THREE.Mesh>} fragments The meshes or ids of the fragments to be changed\n     * @param {number} dbId The new dbId of the fragments. A 0 dbId will prevent an object from being selected.\n     *  All fragments with the same dbId are selected as a single object. Changing the dbids on fragments will\n     *  not change the display of objects that are already selected.\n     * @returns {boolean} True if all of the fragment ids were valid and all of the\n     *  fragments were changed.\n     * @alias Autodesk.Viewing.Extensions.ModelBuilder#changeFragmentsDbId\n     */\n    changeFragmentsDbId(fragments, dbId) {\n        if (!Array.isArray(fragments))\n            fragments = [fragments];\n\n        dbId = dbId | 0;    // Force dbId to integer\n        for (let i = 0; i < fragments.length; ++i) {\n            // Make sure the fragId is valid;\n            if (!this._validateFragment(fragments[i]))\n                return false;\n        }\n\n        const frags = this.fragList.fragments;\n        const instanceTree = this.instanceTree;\n        const fragId2dbId = frags.fragId2dbId;\n        if (this.conserveMemory) {\n            for (let i = 0; i < fragments.length; ++i) {\n                const id = getFragmentId(fragments[i]);\n                changeDbId(dbId, id, fragId2dbId, instanceTree);\n            }\n        } else {\n            const array = this.fragList.vizmeshes;\n            for (let i = 0; i < fragments.length; ++i) {\n                const id = getFragmentId(fragments[i]);\n                changeDbId(dbId, id, fragId2dbId, instanceTree);\n                array[id].dbId = dbId;\n            }\n        }\n\n        return true;\n    }\n\n    /**\n     * Remove fragments from the model\n     *\n     * @param {number|THREE.Mesh|Array<number|THREE.Mesh>} fragments The meshes or ids of the fragments to be removed\n     * @returns {boolean} True if all of the fragment ids were valid and all of the\n     *  fragments were removed.\n     * @alias Autodesk.Viewing.Extensions.ModelBuilder#removeFragment\n     */\n    removeFragment(fragments) {\n        if (!Array.isArray(fragments))\n            fragments = [fragments];\n\n        for (let i = 0; i < fragments.length; ++i) {\n            // Make sure the fragId is valid;\n            if (!this._validateFragment(fragments[i]))\n                return false;\n        }\n\n        const frags = this.fragList.fragments;\n        const instanceTree = this.instanceTree;\n        const array = this.conserveMemory ? this.fragList.geomids : this.fragList.vizmeshes;\n        const clear = this.conserveMemory ? 0 : null;\n        for (let i = 0; i < fragments.length; ++i) {\n            const id = getFragmentId(fragments[i]);\n            this.fragmentIds.releaseId(id);\n            instanceTree.nodeAccess.removeFragment(frags.fragId2dbId[id], id);\n            frags.fragId2dbId[id] = 0;\n            if (!this.conserveMemory && array[id]) {\n                array[id].dispatchEvent(REMOVED_EVENT);\n                array[id].fragId = array[id].modelId = undefined;\n            }\n            array[id] = clear;\n        }\n        this.sceneUpdated(true);\n\n        return true;\n    }\n\n    /**\n     * Pack normals for geometry.\n     * Utility method automatically used when {@link Autodesk.Viewing.Extensions.ModelBuilder#isConservingMemory} is true.\n     * \n     * @param {THREE.BufferGeometry} geometry \n     * @returns {THREE.BufferGeometry} The geometry argument is returned\n     * \n     * @alias Autodesk.Viewing.Extensions.ModelBuilder#packNormals\n     */\n    packNormals(geometry) {\n        const attributes = geometry.attributes;\n        const normal = attributes.normal;\n        // If no normals or normals are already packed, then skip this\n        if (!normal || normal.itemSize !== 3)\n            return geometry;\n\n        /**\n         * @param src\n         * @param srcOff\n         * @param srcStride\n         * @param dst\n         * @param dstOff\n         * @param dstStride\n         * @private\n         */\n        function cvt(src, srcOff, srcStride, dst, dstOff, dstStride) {\n            const atan2 = Math.atan2;\n            const INV_PI = 1 / Math.PI;\n            for ( ; srcOff < src.length; srcOff += srcStride, dstOff += dstStride) {\n                var pnx = (atan2(src[srcOff + 1], src[srcOff]) * INV_PI + 1.0) * 0.5;\n                var pny = (src[srcOff + 2] + 1.0) * 0.5;\n\n                dst[dstOff] = (pnx * 65535)|0;\n                dst[dstOff + 1] = (pny * 65535)|0;\n            }\n        }\n\n        if (normal.array) {\n            // The normals are not interleaved\n            const vcount = Math.floor(normal.length / normal.itemSize);\n            const dst = new Uint16Array(vcount * 2);\n            cvt(normal.array, 0, 3, dst, 0, 2);\n            normal.itemSize = 2;\n            normal.array = dst;\n            normal.normalize = true;\n            normal.needsUpdate = true;\n            normal.bytesPerItem = 2;\n        } else {\n            // The normals are part of an interleaved buffer\n            // First copy all of the data that isn't normal to the new buffer\n            const vbstride = geometry.vbstride;\n            const vb = geometry.vb;\n            const vcount = Math.floor(vb.length / vbstride);\n\n            // ALlocate the new buffer. The normals shrink from 3 floats to\n            // 2 UInt16s which is 1 float. So reduce the vbstride by 2\n            const dst = new Float32Array((vbstride - 2) * vcount);\n            const srcOff = normal.itemOffset;\n\n            if (srcOff <= 0 || srcOff + 3 >= vbstride) {\n                // Normals are at start or end of interleaved buffer\n                let from = srcOff <= 0 ? 3 : 0;\n                let to = srcOff <= 0 ? 1 : 0;\n                const length = vbstride - 3;\n                for (let i = 0; i < vcount; ++i, from += 3, to += 1) {\n                    for (let j = 0; j < length; ++j) {\n                        dst[to++] = vb[from++];\n                    }\n                }\n            } else {\n                // Normals are in the middle of interleaved buffer\n                // Normals are at start or end of interleaved buffer\n                let from = 0;\n                let to = 0;\n                const length1 = srcOff;\n                const length2 = vbstride - srcOff - 3;\n                for (let i = 0; i < vcount; ++i) {\n                    for (let j = 0; j < length1; ++j) {\n                        dst[to++] = vb[from++];\n                    }\n                    from += 3;\n                    to += 1;\n                    for (let j = 0; j < length2; ++j) {\n                        dst[to++] = vb[from++];\n                    }\n                }\n            }\n\n            // Pack the normals, Recast the interleaved buffer as 16 bit ints\n            cvt(vb, srcOff, vbstride, new Uint16Array(dst.buffer), srcOff * 2, (vbstride - 2) * 2);\n            geometry.vbstride -= 2;\n            geometry.vb = dst;\n            geometry.vbNeedsUpdate = true;\n            // For interleaved case, the attributes are cached and shared, so we need\n            // to find the attribute with the proper description.\n            attributes.normal = avp.BufferGeometryUtils.findBufferAttribute('normal', {\n                array: null,\n                bytesPerItem: 2,\n                itemSize: 2,\n                normalize: true,\n                isPattern: normal.isPattern,\n                divisor: normal.divisor,\n                offset: normal.itemOffset\n            }, geometry.numInstances);\n\n            // Adjust all of the offsets for the packed buffers\n            const keys = Object.keys(attributes);\n            for (let i = 0; i < keys.length; ++i) {\n                const attr = attributes[keys[i]];\n                if (!attr.array && attr.itemOffset > srcOff) {\n                    // For interleaved case, the attributes are cached and shared, so we need\n                    // to find the attribute with the proper description.\n                    attributes[keys[i]] = avp.BufferGeometryUtils.findBufferAttribute(keys[i], {\n                        array: null,\n                        bytesPerItem: attr.bytesPerItem,\n                        itemSize: attr.itemSize,\n                        normalize: attr.normalize,\n                        isPattern: attr.isPattern,\n                        divisor: attr.divisor,\n                        offset: attr.itemOffset - 2\n                    }, geometry.numInstances);\n                }\n            }\n        }\n\n        return geometry;\n    }\n\n    /**\n     * Add a new model to the viewer\n     *\n     * @param {Autodesk.Extensions.SceneBuilder.SceneBuilder} sceneBuilder The SceneBuilder asking for the model\n     * @param {any} options Options for adding the model.\n     * @param {boolean} [options.conserveMemory] Set to true to turn on memory conservation mode.\n     *  In this mode [addMesh()]{@link Extensions.SceneBuilder.ModelBuilder#addMesh} is not available because a single mesh is shared among\n     *  all of the fragments in the model.\n     * @param {boolean} [options.createWireframe] Set to true to turn on edge generation for geometry.\n     * @returns {Promise<Autodesk.Extensions.SceneBuilder.ModelBuilder>} A promise that resolves to the ModelBuilder for the new model.\n     * @private\n     */\n    static addNewModel(sceneBuilder, options) {\n        return new Promise(function(resolve, reject) {\n            //Set up overrides for Fluent\n            var loadOptions = Object.assign({}, options);\n            loadOptions.fileLoader = EmptyModelLoader;\n            loadOptions.globalOffset = loadOptions.globalOffset || {x: 0, y: 0, z: 0}; //Make camera operations more sane by not having to offset everything\n\n            sceneBuilder.viewer.loadModel(\"Dummy\", loadOptions, function(model) {\n                resolve(new ModelBuilder(model, loadOptions));\n            }, function(error) {\n                reject(error);\n            });\n        });\n    }\n}\n\nexport { ModelBuilder };\n","/**\n * Include each locale json file and return it in an object\n * that can be consumed by i18n\n */\n\nimport json_en from '../../res/locales/en/nobundle-scene-builder.loc.json';\nimport json_en_GB from '../../res/locales/en-GB/nobundle-scene-builder.loc.json';\nimport json_cs from '../../res/locales/cs/nobundle-scene-builder.loc.json';\nimport json_de from '../../res/locales/de/nobundle-scene-builder.loc.json';\nimport json_es from '../../res/locales/es/nobundle-scene-builder.loc.json';\nimport json_fr from '../../res/locales/fr/nobundle-scene-builder.loc.json';\nimport json_fr_CA from '../../res/locales/fr-CA/nobundle-scene-builder.loc.json';\nimport json_it from '../../res/locales/it/nobundle-scene-builder.loc.json';\nimport json_ja from '../../res/locales/ja/nobundle-scene-builder.loc.json';\nimport json_ko from '../../res/locales/ko/nobundle-scene-builder.loc.json';\nimport json_pl from '../../res/locales/pl/nobundle-scene-builder.loc.json';\nimport json_pt_BR from '../../res/locales/pt-BR/nobundle-scene-builder.loc.json';\nimport json_ru from '../../res/locales/ru/nobundle-scene-builder.loc.json';\nimport json_tr from '../../res/locales/tr/nobundle-scene-builder.loc.json';\nimport json_zh_HANS from '../../res/locales/zh-HANS/nobundle-scene-builder.loc.json';\nimport json_zh_HANT from '../../res/locales/zh-HANT/nobundle-scene-builder.loc.json';\nimport json_zh_HK from '../../res/locales/zh-HK/nobundle-scene-builder.loc.json';\nimport json_nl from '../../res/locales/nl/nobundle-scene-builder.loc.json';\nimport json_sv from '../../res/locales/sv/nobundle-scene-builder.loc.json';\nimport json_da from '../../res/locales/da/nobundle-scene-builder.loc.json';\nimport json_no from '../../res/locales/no/nobundle-scene-builder.loc.json';\n\nexport const locales = {\n    en: json_en,\n    \"en-GB\": json_en_GB,\n    cs: json_cs,\n    de: json_de,\n    es: json_es,\n    fr: json_fr,\n    \"fr-CA\": json_fr_CA,\n    it: json_it,\n    ja: json_ja,\n    ko: json_ko,\n    pl: json_pl,\n    \"pt-BR\": json_pt_BR,\n    ru: json_ru,\n    tr: json_tr,\n    \"zh-HANS\": json_zh_HANS,\n    \"zh-HANT\": json_zh_HANT,\n    \"zh-HK\": json_zh_HK,\n    nl: json_nl,\n    sv: json_sv,\n    da: json_da,\n    no: json_no,\n};","import { ModelBuilder } from './modelBuilder';\nimport { locales } from './locales';\n\nconst av = Autodesk.Viewing;\nconst SCENE_BUILD_EXTENSION_ID = \"Autodesk.Viewing.SceneBuilder\";\n\n/**\n * Scene Builder extension provides an API for building scenes without\n * loading them from a URL.\n * \n * The extension id is: `Autodesk.Viewing.SceneBuilder`\n * \n * @example\n *  viewer.loadExtension('Autodesk.Viewing.SceneBuilder');\n * \n * @memberof Autodesk.Viewing.Extensions\n * @alias Autodesk.Viewing.Extensions.SceneBuilder\n */\nclass SceneBuilder extends av.Extension {\n    \n    /**\n     * @class\n     * @param {Autodesk.Viewing.Viewer3D} viewer The viewer instance loading the extension\n     * @param {object} [options] Default options used when calling addNewModel\n     * @param {boolean} [options.conserveMemory=false] Set to true to turn on memory conservation mode.\n     *  In this mode [addMesh()]{@link Autodesk.Viewing.Extensions.SceneBuilder#addMesh} is not available because a single mesh is shared among\n     *  all of the fragments in the model.\n     */\n    constructor(viewer, options) {\n        super(viewer, options);\n        this._loaded = false;\n        this.extendLocalization(locales);\n    }\n\n    /**\n     * Extension interface method - loads the extension\n     *\n     * @alias Autodesk.Viewing.Extensions.SceneBuilder#load\n     * @returns {boolean}\n     */\n    load() {\n        this._loaded = true;\n        return true;\n    }\n\n    /**\n     * Extension interface method - unloads the extension\n     * Method {@link Autodesk.Viewing.Extensions.SceneBuilder#addNewModel} will fail if the extension is unloaded.\n     *\n     * @alias Autodesk.Viewing.Extensions.SceneBuilder#unload\n     */\n    unload() {\n        this._loaded = false;\n        return true;\n    }\n\n     /**\n      * Add a new empty model into the scene. The model can be manipulated only by its associated\n      * ModelBuilder instance.\n      *\n      * @param {object} [options] Options combined with the options used  when the\n      *  extension is loaded with loadExtension(). The combined options are\n      *  put in the loadOptions property in the object returned by model.getData().\n      * @param {boolean} [options.conserveMemory=false] Set to true to turn on memory conservation mode.\n      *  In this mode [addMesh()]{@link Autodesk.Viewing.Extensions.SceneBuilder#addMesh} is not available because a single mesh is shared among\n      *  all of the fragments in the model.\n      * @param {boolean} [options.createWireframe] Set to true to turn on edge generation for geometry. \n      * @returns {Promise.<Autodesk.Viewing.Extensions.ModelBuilder>} A Promise that resolves with a ModelBuilder instance for the new model.\n      *\n      * @alias Autodesk.Viewing.Extensions.SceneBuilder#addNewModel\n      */\n    addNewModel(options) {\n        if (!this._loaded) {\n            return Promise.reject(new Error(\"SceneBuilder extension not loaded\"));\n        }\n\n        return ModelBuilder.addNewModel(this, Object.assign({}, this.options, options));\n    }\n}\n\nav.theExtensionManager.registerExtension(SCENE_BUILD_EXTENSION_ID, SceneBuilder);\n"],"sourceRoot":""}