{"version":3,"file":"SceneBuilder/SceneBuilder.js","sources":["webpack://Autodesk.Extensions.[name]/webpack/bootstrap","webpack://Autodesk.Extensions.[name]/./extensions/SceneBuilder/locales.js","webpack://Autodesk.Extensions.[name]/./extensions/SceneBuilder/modelBuilder.js","webpack://Autodesk.Extensions.[name]/./extensions/SceneBuilder/reusableIds.js","webpack://Autodesk.Extensions.[name]/./extensions/SceneBuilder/sceneBuilder.js","webpack://Autodesk.Extensions.[name]/./node_modules/bintrees/index.js","webpack://Autodesk.Extensions.[name]/./node_modules/bintrees/lib/bintree.js","webpack://Autodesk.Extensions.[name]/./node_modules/bintrees/lib/rbtree.js","webpack://Autodesk.Extensions.[name]/./node_modules/bintrees/lib/treebase.js"],"sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./extensions/SceneBuilder/sceneBuilder.js\");\n","/**\n * Include each locale json file and return it in an object\n * that can be consumed by i18n\n */\n\nimport json_en from '../../res/locales/en/nobundle-scene-builder.loc.json';\nimport json_en_GB from '../../res/locales/en-GB/nobundle-scene-builder.loc.json';\nimport json_cs from '../../res/locales/cs/nobundle-scene-builder.loc.json';\nimport json_de from '../../res/locales/de/nobundle-scene-builder.loc.json';\nimport json_es from '../../res/locales/es/nobundle-scene-builder.loc.json';\nimport json_fr from '../../res/locales/fr/nobundle-scene-builder.loc.json';\nimport json_fr_CA from '../../res/locales/fr-CA/nobundle-scene-builder.loc.json';\nimport json_it from '../../res/locales/it/nobundle-scene-builder.loc.json';\nimport json_ja from '../../res/locales/ja/nobundle-scene-builder.loc.json';\nimport json_ko from '../../res/locales/ko/nobundle-scene-builder.loc.json';\nimport json_pl from '../../res/locales/pl/nobundle-scene-builder.loc.json';\nimport json_pt_BR from '../../res/locales/pt-BR/nobundle-scene-builder.loc.json';\nimport json_ru from '../../res/locales/ru/nobundle-scene-builder.loc.json';\nimport json_tr from '../../res/locales/tr/nobundle-scene-builder.loc.json';\nimport json_zh_HANS from '../../res/locales/zh-HANS/nobundle-scene-builder.loc.json';\nimport json_zh_HANT from '../../res/locales/zh-HANT/nobundle-scene-builder.loc.json';\nimport json_zh_HK from '../../res/locales/zh-HK/nobundle-scene-builder.loc.json';\nimport json_nl from '../../res/locales/nl/nobundle-scene-builder.loc.json';\nimport json_sv from '../../res/locales/sv/nobundle-scene-builder.loc.json';\nimport json_da from '../../res/locales/da/nobundle-scene-builder.loc.json';\nimport json_no from '../../res/locales/no/nobundle-scene-builder.loc.json';\n\nexport var locales = {\n  en: json_en,\n  \"en-GB\": json_en_GB,\n  cs: json_cs,\n  de: json_de,\n  es: json_es,\n  fr: json_fr,\n  \"fr-CA\": json_fr_CA,\n  it: json_it,\n  ja: json_ja,\n  ko: json_ko,\n  pl: json_pl,\n  \"pt-BR\": json_pt_BR,\n  ru: json_ru,\n  tr: json_tr,\n  \"zh-HANS\": json_zh_HANS,\n  \"zh-HANT\": json_zh_HANT,\n  \"zh-HK\": json_zh_HK,\n  nl: json_nl,\n  sv: json_sv,\n  da: json_da,\n  no: json_no };","function _defineProperty(obj, key, value) {if (key in obj) {Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true });} else {obj[key] = value;}return obj;}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError(\"Cannot call a class as a function\");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}import { ReusableIds } from \"./reusableIds\";\n\nvar av = Autodesk.Viewing;\nvar avp = av.Private;\nvar tmpMatrix = new THREE.Matrix4();\nvar tmpBox = new THREE.Box3();\nvar tmpMin = new THREE.Vector3();\nvar tmpMax = new THREE.Vector3();\nvar missingGeometry = { svfid: 0, boundingBox: new THREE.Box3() };\nvar meshInfo = {\n  geometry: null,\n  material: undefined,\n  matrix: tmpMatrix,\n  isLine: false,\n  isWideLine: false,\n  isPoint: false };\n\nvar isLines = avp.MeshFlags.MESH_ISLINE;\nvar isWideLines = avp.MeshFlags.MESH_ISWIDELINE;\nvar isPoints = avp.MeshFlags.MESH_ISPOINT;\nvar clearFlags = ~(isLines | isWideLines | isPoints);\nvar defaultMtlName = \"__defaultMaterial__\";\nvar REMOVED_EVENT = { type: \"removed\" };\n\nvar ROOT_NODE_ID = -1e9; // Large negative number for root node id\nvar START_FRAG_ID = -100; // Place where fragments without dbids are put\n\n// See InstanceTreeAccess in src/wgs/scene/InstanceTreeStorage.js\nvar SceneBuilderNodeAccess = /*#__PURE__*/function () {\n  function SceneBuilderNodeAccess() {_classCallCheck(this, SceneBuilderNodeAccess);\n    this.rootId = ROOT_NODE_ID;\n    this.nodeIndices = new ReusableIds(1);\n    this.dbIdToIndex = _defineProperty({}, ROOT_NODE_ID, 0);\n    this._nodeCount = 1;\n    this._maxIndex = 0;\n    this._nodeFlags = [0];\n    this._indexToFragId = [];\n    this._rootName = av.i18n.translate(\"Root\");\n  }_createClass(SceneBuilderNodeAccess, [{ key: \"getIndex\", value: function getIndex(\n\n    id) {\n      return this.dbIdToIndex[id];\n    } }, { key: \"getNumNodes\", value: function getNumNodes()\n\n    {\n      // Use _maxIndex + 1 instead of _nodeCount. The ModelBrowserPanel get indices from the\n      // instance tree and assumes that they are < getNumNodes(). This guarantees that\n      // is true. _maxIndex + 1 will be >= _nodeCount and <= the fragment count.\n      return this._maxIndex + 1;\n    } }, { key: \"getParentId\", value: function getParentId(\n\n    nodeId) {\n      return nodeId === this.rootId ? undefined : this.rootId;\n    } }, { key: \"getNodeFlags\", value: function getNodeFlags(\n\n    dbId) {\n      var index = this.dbIdToIndex[dbId];\n      return index >= 0 ? this._nodeFlags[index] : undefined;\n    } }, { key: \"setNodeFlags\", value: function setNodeFlags(\n\n    dbId, flags) {\n      var index = this.dbIdToIndex[dbId];\n      if (index !== undefined)\n      this._nodeFlags[index] = flags;\n    } }, { key: \"name\", value: function name(\n\n    nodeId, includeCount) {\n      return nodeId === this.rootId ?\n      includeCount && this._nodeCount > 1 ? \"\".concat(this._rootName, \"(\").concat(this._nodeCount - 1, \")\") : this._rootName :\n      av.i18n.translate(\"Object %(nodeId)d\", {\n        postProcess: 'sprintf', sprintf: {\n          nodeId: nodeId } });\n\n\n    } }, { key: \"getNodeBox\", value: function getNodeBox(\n\n    dbId, dst) {\n      dst.setEmpty();\n    } }, { key: \"getNumChildren\", value: function getNumChildren(\n\n    nodeId) {\n      return nodeId == this.rootId ? this._nodeCount - 1 : 0;\n    } }, { key: \"getNumFragments\", value: function getNumFragments(\n\n    nodeId) {\n      if (nodeId === this.rootId)\n      return 0;\n      var index = this.dbIdToIndex[nodeId];\n      if (index === undefined)\n      return 0;\n      var frags = this._indexToFragId[index];\n      return Array.isArray(frags) ? frags.length : 1;\n    } }, { key: \"enumNodeFragments\", value: function enumNodeFragments(\n\n    node, callback) {\n      if (node === this.rootId)\n      return;\n      var index = this.dbIdToIndex[node];\n      if (index === undefined)\n      return;\n      var frags = this._indexToFragId[index];\n      if (Array.isArray(frags)) {\n        for (var i = 0; i < frags.length; ++i) {\n          callback(frags[i], node, index);}\n      } else\n      callback(frags, node, index);\n    } }, { key: \"enumNodeChildren\", value: function enumNodeChildren(\n\n    dbId, callback) {\n      if (dbId !== this.rootId)\n      return;\n      var dbids = Object.keys(this.dbIdToIndex);\n      for (var i = 0; i < dbids.length; ++i) {\n        var child = parseInt(dbids[i]);\n        if (child !== this.rootId) {\n          callback(child, dbId, 0);\n        }\n      }\n    } }, { key: \"addFragment\", value: function addFragment(\n\n    nodeId, fragId) {\n      var index = this.dbIdToIndex[nodeId];\n      if (index === undefined) {\n        index = this.nodeIndices.reserveId();\n        this.dbIdToIndex[nodeId] = index;\n        this._nodeFlags[index] = 0;\n        ++this._nodeCount;\n        if (index > this._maxIndex)\n        this._maxIndex = index;\n      }\n      var frags = this._indexToFragId[index];\n      if (frags === undefined)\n      this._indexToFragId[index] = fragId;else\n      if (Array.isArray(frags))\n      frags.push(fragId);else\n\n      this._indexToFragId[index] = [frags, fragId];\n    } }, { key: \"removeFragment\", value: function removeFragment(\n\n    nodeId, fragId) {\n      var index = this.dbIdToIndex[nodeId];\n      if (index !== undefined) {\n        var frags = this._indexToFragId[index];\n        if (Array.isArray(frags)) {\n          var i = frags.indexOf(fragId);\n          if (i >= 0 && frags.length === 2)\n          this._indexToFragId[index] = frags[1 - i];else\n\n          frags.splice(i, 1);\n        } else {\n          this.nodeIndices.releaseId();\n          delete this.dbIdToIndex[nodeId];\n          delete this._indexToFragId[index];\n          --this._nodeCount;\n        }\n      }\n    } }]);return SceneBuilderNodeAccess;}();var\n\n\nEmptyModelLoader = /*#__PURE__*/function () {\n  function EmptyModelLoader(viewer) {_classCallCheck(this, EmptyModelLoader);\n    this.viewer3DImpl = viewer;\n  }_createClass(EmptyModelLoader, [{ key: \"loadFile\", value: function loadFile(\n\n    url, options, onDone, onWorkerStart) {\n      onWorkerStart && onWorkerStart();\n      //Make the initial blank model\n      var initialSize = options.conserveMemory ? 1 : 0;\n      var svf = {\n        bbox: new THREE.Box3().set(options.globalOffset, options.globalOffset),\n        fragments: {\n          length: initialSize,\n          fragId2dbId: [0],\n          transforms: initialSize ? new Float32Array(initialSize * 12) : null,\n          boxes: initialSize ? new Float32Array(initialSize * 6) : null },\n\n        is2d: false,\n        loadOptions: options || {},\n        isSceneBuilder: true,\n        loadDone: true, // True as model is empty\n        instanceTree: new avp.InstanceTree(new SceneBuilderNodeAccess(), 0, 1),\n        metadata: {} };\n\n      var model = new av.Model(svf);\n\n      var name;\n      if (options && options.modelNameOverride) {\n        name = options.modelNameOverride;\n        // Undefine this in the options so the model browser panel will use\n        // the same name we copy to the instance tree. The instance tree will\n        // append the object count to the model name, but not if the name\n        // is take directly from the options.\n        options.modelNameOverride = undefined;\n      } else {\n        name = av.i18n.translate('Scene Builder %(modelId)d', {\n          postProcess: 'sprintf', sprintf: {\n            modelId: model.getModelId() } });\n\n\n      }\n\n      svf.instanceTree.nodeAccess._rootName = name;\n      svf.urn = btoa(name);\n      this.svf = svf;\n\n      model.initialize();\n      model.loader = this;\n      this.model = model;\n      model.getFragmentList().isFixedSize = false;\n      onDone(null, model);\n      this.viewer3DImpl.api.dispatchEvent({ type: av.MODEL_ROOT_LOADED_EVENT, svf: svf, model: model });\n      this.viewer3DImpl.onLoadComplete(model);\n    } }, { key: \"dtor\", value: function dtor()\n\n    {\n    } }, { key: \"is3d\", value: function is3d()\n\n    {\n      return true;\n    } }]);return EmptyModelLoader;}();\n\n\n/**\n                                        * @param transform\n                                        * @param dstMatrix\n                                        * @private\n                                        */\nfunction convertMatrix(transform, dstMatrix) {\n  if (!transform) {\n    dstMatrix.identity();\n  } else if (transform instanceof THREE.Matrix4) {\n    dstMatrix.copy(transform);\n  } else {\n    var dst = dstMatrix.elements;\n    dst[0] = transform[0];\n    dst[1] = transform[1];\n    dst[2] = transform[2];\n    dst[3] = 0;\n    dst[4] = transform[3];\n    dst[5] = transform[4];\n    dst[6] = transform[5];\n    dst[7] = 0;\n    dst[8] = transform[6];\n    dst[9] = transform[7];\n    dst[10] = transform[8];\n    dst[11] = 0;\n    dst[12] = transform[9];\n    dst[13] = transform[10];\n    dst[14] = transform[11];\n    dst[15] = 1;\n  }\n\n  return dstMatrix;\n}\n\n/**\n   * Get the fragment id for a fragment\n   *\n   * @param {number|THREE.Mesh} fragment The mesh or the fragment id for a fragment.\n   * @returns {number} The id of the fragment\n   * @private\n   */\nfunction getFragmentId(fragment) {\n  return fragment instanceof THREE.Mesh ? fragment.fragId : fragment;\n}\n\n/**\n   * @param modelBuilder\n   * @param fragment\n   * @param geometry\n   * @param material\n   * @param transform\n   * @param bbox\n   * @private\n   */\nfunction _changeFragmentGeometry(modelBuilder, fragment, geometry, material, transform, bbox) {\n  // get the fragment id\n  var fragId = getFragmentId(fragment);\n\n  var model = modelBuilder.model;\n  var fragList = modelBuilder.fragList;\n\n  // Get the geometry\n  missingGeometry.geometry = (geometry === undefined ? modelBuilder.fragList.getGeometryId(fragId) :\n  geometry instanceof THREE.BufferGeometry ? geometry.svfid : geometry) || 0;\n  geometry = geometry === undefined ? modelBuilder.fragList.getGeometry(fragId) : modelBuilder._getGeometry(geometry);\n\n  // Get the material\n  var mtl = material === undefined ? modelBuilder.fragList.getMaterial(fragId) : modelBuilder._getMaterial(material);\n\n  var mesh = !modelBuilder.conserveMemory && model.getFragmentList().getVizmesh(fragId);\n  if (mesh) {\n    mesh.dispatchEvent(REMOVED_EVENT);\n  } else\n  mesh = meshInfo;\n\n  // Get the material\n  mesh.material = mtl;\n  // Clear the vizflags, that may be left over.\n  if (fragId < fragList.vizflags.length)\n  fragList.vizflags[fragId] &= ~clearFlags;\n  // We need to mark whether the fragment is a line, wideline, or points\n  // If we don't have geometry, assume false, which will get fixed when\n  // the geometry is available.\n  mesh.geometry = geometry;\n  if (geometry) {\n    mesh.isLine = geometry.isLines;\n    mesh.isWideLine = geometry.isWideLines;\n    mesh.isPoint = geometry.isPoints;\n  } else {\n    mesh.geometry = missingGeometry;\n    mesh.isLine = false;\n    mesh.isWideLine = false;\n    mesh.isPoint = false;\n  }\n  // Get the transform\n  mesh.matrix = convertMatrix(transform, mesh === meshInfo ? tmpMatrix : mesh.matrix);\n  // Get the bounding box, if it is provided by the caller. Use meshInfo because\n  // bbox doesn't work when conserveMemory is false.\n  meshInfo.bbox = bbox && (bbox instanceof THREE.Box3 ? bbox :\n  tmpBox.set(tmpMin.fromArray(bbox, 0), tmpMax.fromArray(bbox, 3)));\n  fragList.fragments.fragId2dbId[fragId] = START_FRAG_ID - fragId;\n  modelBuilder.instanceTree.nodeAccess.addFragment(START_FRAG_ID - fragId, fragId);\n  model.setFragment(fragId, mesh, mesh !== meshInfo);\n  if (fragList.useThreeMesh && !geometry)\n  fragList.getVizmesh(fragId).geometry = null;\n\n  modelBuilder.sceneUpdated(true);\n  return true;\n}\n\n/**\n   * @param geometry\n   * @param dst\n   * @private\n   */\nfunction calculateBBox(geometry, dst) {\n  dst.makeEmpty();\n  avp.VertexEnumerator.enumMeshVertices(geometry, function (pos) {\n    dst.expandByPoint(pos);\n  });\n  return dst;\n}\n\n/**\n   * @param matman\n   * @param hash\n   * @param material\n   * @private\n   */\nfunction _addMaterial(matman, hash, material) {\n  if (material instanceof THREE.MeshPhongMaterial ||\n  material instanceof THREE.ShaderMaterial && material.isPrismMaterial) {\n    matman.addMaterial(hash, material, true);\n  } else\n  matman.addMaterialNonHDR(hash, material);\n}\n\n/**\n   * @param newDbId\n   * @param fragId\n   * @param fragId2dbId\n   * @param instanceTree\n   * @private\n   */\nfunction changeDbId(newDbId, fragId, fragId2dbId, instanceTree) {\n  var oldDbId = fragId2dbId[fragId] | 0;\n  newDbId = newDbId || START_FRAG_ID - fragId;\n  fragId2dbId[fragId] = newDbId;\n  if (newDbId === oldDbId)\n  return;\n\n  instanceTree.nodeAccess.removeFragment(oldDbId, fragId);\n  instanceTree.nodeAccess.addFragment(newDbId, fragId);\n}\n\n/**\n   * Class that implements the API for building models dynamically.\n   * An instance of this class can be obtained after the Promise returned by {@link Autodesk.Viewing.Extensions.SceneBuilder#addNewModel}\n   * is resolved.\n   * \n   * @memberof Autodesk.Viewing.Extensions\n   * @alias Autodesk.Viewing.Extensions.ModelBuilder\n   * \n   * @property {Autodesk.Viewing.Model} model The model instance being manipulated.\n   */var\nModelBuilder = /*#__PURE__*/function () {\n\n  /**\n                                          * The constructor is invoked automatically by {@link Autodesk.Viewing.Extensions.SceneBuilder}.\n                                          * \n                                          * @class\n                                          * @param {Autodesk.Viewing.Model} model The model this build works on\n                                          * @param {object} [options] Options for the ModelBuilder\n                                          * @param {boolean} [options.conserveMemory=false] Set to true to turn on memory conservation mode.\n                                          *  In this mode [addMesh()]{@link Autodesk.Viewing.Extensions.ModelBuilder#addMesh} is not available because \n                                          *  a single mesh is shared among all of the fragments in the model.\n                                          */\n  function ModelBuilder(model, options) {_classCallCheck(this, ModelBuilder);\n    this.model = model;\n    this.geomList = model.getGeometryList();\n    this.fragList = model.getFragmentList();\n    // Initialize the ids we use for geometry and fragments.\n    this.geomIds = new ReusableIds(1);\n    this.fragmentIds = new ReusableIds(Math.max(model.getData().fragments.length, 1));\n    this.conserveMemory = !!(options && options.conserveMemory);\n    this.instanceTree = model.getData().instanceTree;\n    this.instanceTree.setFragmentList(this.fragList);\n    this.createWireframe = !!(options && options.createWireframe);\n  }\n\n  /**\n     * @returns {boolean} true when the model being manipulated is using the memory-optimized code path.\n     * @alias Autodesk.Viewing.Extensions.ModelBuilder#isConservingMemory\n     */_createClass(ModelBuilder, [{ key: \"isConservingMemory\", value: function isConservingMemory()\n    {\n      return this.conserveMemory;\n    }\n\n    /**\n       * Add geometry to the model.\n       * \n       * @param {THREE.BufferGeometry} geometry The geometry to add. This can be null or\n       *  undefined to allocate a geometry id without geometry.\n       * @param {number} [numFragments] The number of fragments you expect this geometry\n       *  to be used in. Default is 1. This is used to prioritize placing geometry on the\n       *  GPU. Geometry used by more fragments gets a higher priority.\n       * @returns {number} The id of the added geometry, or 0 if there was an error.\n       * \n       * @alias Autodesk.Viewing.Extensions.ModelBuilder#addGeometry\n       */ }, { key: \"addGeometry\", value: function addGeometry(\n    geometry, numFragments) {\n      // Must have geometry and it must not be in a model\n      if (geometry && geometry.svfid !== undefined)\n      return 0;\n\n      // Get the new geometry id\n      var geomId = this.geomIds.reserveId();\n      if (geomId === undefined)\n      return 0; // 4 billion fragments? not likely\n\n      if (geometry) {\n        if (this.createWireframe) {\n          avp.createWireframe(geometry);\n\n          if (!geometry.attributes.indexlines) {\n            // add attribute for edge rendering\n            var attrIndexLines = new THREE.BufferAttribute(undefined, 1);\n            attrIndexLines.bytesPerItem = geometry.iblines instanceof Uint32Array ? 4 : 2;\n            geometry.setAttribute('indexlines', attrIndexLines);\n            geometry.iblinesbuffer = undefined;\n          }\n\n          // Add index for the renderer to draw the lines\n          if (!geometry.attributes.index) {\n            var indices = new Uint16Array(geometry.attributes.position.length / 3);\n            for (var i = 0; i < indices.length; ++i) {\n              indices[i] = i;\n            }\n            var iba = new THREE.BufferAttribute(indices, 1);\n            iba.bytesPerItem = 2;\n            geometry.setAttribute('index', iba);\n          }\n        }\n        // Sort of ugly - the geometry list will set geometry.boundingBox to null,\n        // but if we aren't conserving memory we need to keep the bounding box.\n        var bbox = geometry.boundingBox = geometry.boundingBox ||\n        calculateBBox(geometry, this.conserveMemory ? tmpBox : new THREE.Box3());\n        this.geomList.addGeometry(this.packNormals(geometry), numFragments, geomId);\n        if (!this.conserveMemory)\n        geometry.boundingBox = bbox;\n      }\n\n      return geomId;\n    }\n\n    /**\n       * Update fragments to use a new geometry id.\n       *\n       * @param {object.<number,boolean>} oldGeomIds Existing geometry ids\n       * @param {number} newGeomId New geometry id\n       * @private\n       */ }, { key: \"_updateGeometry\", value: function _updateGeometry(\n    oldGeomIds, newGeomId) {\n      var fragList = this.fragList;\n      var update = false;\n      if (this.conserveMemory) {\n        var geomids = fragList.geomids;\n        for (var i = 0; i < geomids.length; ++i) {\n          if (oldGeomIds[geomids[i]]) {\n            this.changeFragmentGeometry(i, newGeomId);\n            update = true;\n          }\n        }\n      } else {\n        var meshes = fragList.vizmeshes;\n        for (var _i = 0; _i < meshes.length; ++_i) {\n          var mesh = meshes[_i];\n          if (mesh && mesh.geometry && oldGeomIds[mesh.geometry.svfid]) {\n            this.changeFragmentGeometry(_i, newGeomId);\n            update = true;\n          }\n        }\n      }\n\n      if (update)\n      this.sceneUpdated(true);\n    }\n\n    /**\n       * Validate geometry from caller\n       *\n       * @param {number|THREE.BufferGeometry|Array<number|THREE.BufferGeometry>} geometry The geometry or ids of the geometry\n       *  to validate.\n       * @returns {object.<string, boolean>} A map from id to true for the validated geometry. Null is returned if any\n       *  of the geometry is invalid.\n       * @private\n       */ }, { key: \"_validateGeometry\", value: function _validateGeometry(\n    geometry) {\n      if (!Array.isArray(geometry))\n      geometry = [geometry];\n\n      var search = {};\n      var geomList = this.geomList;\n      for (var i = 0; i < geometry.length; ++i) {\n        // Make sure geometry is valid\n        var id = geometry[i];\n        if (id instanceof THREE.BufferGeometry) {\n          // The geometry is a BufferGeometry make sure it is right\n          if (geomList.getGeometry(id.svfid) != id)\n          return null;\n          id = id.svfid;\n        }\n        if (!this.geomIds.isIdReserved(id))\n        return null;\n        search[id] = true;\n      }\n\n      return search;\n    }\n\n    /**\n       * Change geometry in a model.\n       *\n       * @param {number|THREE.BufferGeometry} existingGeom The geometry or the id of the geometry to change\n       * @param {THREE.BufferGeometry} geometry Geometry that replaces the existing geometry\n       * @param {number} [numFragments] The number of fragments using this geometry.\n       *  If not given, then we will count the number in the model. This is used to\n       *  prioritize placing geometry on the GPU. Geometry used by more fragments\n       *  gets a higher priority.\n       * @returns {boolean} True if the existing geometry is valid and the geometry was changed.\n       * @alias Autodesk.Viewing.Extensions.ModelBuilder#changeGeometry\n       */ }, { key: \"changeGeometry\", value: function changeGeometry(\n    existingGeom, geometry, numFragments) {\n      var result = this._validateGeometry(existingGeom);\n      if (!result)\n      return false;\n      var geomId = parseInt(Object.keys(result)[0]);\n      var geomList = this.geomList;\n      // Make sure existing geomId and the new geometry are valid\n      if (!geometry || geometry && geometry.svfid !== undefined)\n      return false;\n\n      // remove the geometry\n      var oldGeom = geomList.getGeometry(geomId);\n      geomList.removeGeometry(geomId);\n\n      // Count the number of fragment using geomId\n      if (numFragments === undefined) {\n        numFragments = 0;\n        var fragList = this.fragList;\n        if (fragList.useThreeMesh) {\n          // Using THREE.Mesh directly, need to look there for the geometry\n          if (oldGeom) {\n            var meshes = fragList.vizmeshes;\n            for (var i = 0; i < meshes.length; ++i) {\n              if (meshes[i] && meshes[i].geometry === oldGeom)\n              ++numFragments;\n            }\n          }\n        } else {\n          // Using geomIds, so look and fragment to geomId map\n          var frag2geom = fragList.geomids;\n          for (var _i2 = 0; _i2 < frag2geom.length; ++_i2) {\n            if (frag2geom[_i2] === geomId)\n            ++numFragments;\n          }\n        }\n        numFragments = numFragments || 1;\n      }\n\n\n      // Sort of ugly - the geometry list will set geometry.boundingBox to null,\n      // but if we aren't conserving memory we need to keep the bounding box.\n      var bbox = geometry.boundingBox = geometry.boundingBox ||\n      calculateBBox(geometry, this.conserveMemory ? tmpBox : new THREE.Box3());\n      geomList.addGeometry(this.packNormals(geometry), numFragments, geomId);\n      if (!this.conserveMemory)\n      geometry.boundingBox = bbox;\n\n      this._updateGeometry(result, geomId);\n      // clear old geomId\n      if (oldGeom)\n      oldGeom.svfid = undefined;\n      return true;\n    }\n\n    /**\n       * Find fragments using a specific geometry.\n       *\n       * @param {number|THREE.BufferGeometry|Array<number|THREE.BufferGeometry>} geometry The geometry\n       *  or id(s) of the geometry to use in the search\n       * @returns {number[]} An array with the fragment ids for all fragments that were using\n       *  the geometry. Null is returned if any geometry is invalid.\n       * @alias Autodesk.Viewing.Extensions.ModelBuilder#findGeometryFragments\n       */ }, { key: \"findGeometryFragments\", value: function findGeometryFragments(\n    geometry) {\n      var search = this._validateGeometry(geometry);\n\n      var frags = [];\n      var fragList = this.fragList;\n      if (fragList.useThreeMesh) {\n        // Using THREE.Mesh for the fragments, look there for the objects\n        var meshes = fragList.vizmeshes;\n        for (var i = 0; i < meshes.length; ++i) {\n          var id = meshes[i] && meshes[i].geometry && meshes[i].geometry.svfid;\n          if (search[id])\n          frags.push(i);\n        }\n      } else {\n        // Using geom ids for the fragments, look and the fragment to geom id map\n        var geomids = fragList.geomids;\n        for (var _i3 = 0; _i3 < geomids.length; ++_i3) {\n          if (search[geomids[_i3]])\n          frags.push(_i3);\n        }\n      }\n\n      return frags;\n    }\n\n    /**\n       * Remove geometry from the model.\n       * The caller should dispose the geometry if needed.\n       *\n       * @param {number|THREE.BufferGeometry|Array<number|THREE.BufferGeometry>} geometry The geometry or id(s) of the geometry to remomve\n       * @returns {boolean} True if all of the ids are valid and the geometry is removed.\n       * @alias Autodesk.Viewing.Extensions.ModelBuilder#removeGeometry\n       */ }, { key: \"removeGeometry\", value: function removeGeometry(\n    geometry) {\n\n      var delMap = this._validateGeometry(geometry);\n      if (!delMap)\n      return false;\n      var geomList = this.geomList;\n\n      this._updateGeometry(delMap, 0);\n\n      var delIds = Object.keys(delMap);\n      for (var i = 0; i < delIds.length; ++i) {\n        var geomId = parseInt(delIds[i]);\n        var _geometry = geomList.getGeometry(geomId);\n        if (_geometry)\n        _geometry.svfid = undefined;\n        geomList.removeGeometry(geomId);\n        this.geomIds.releaseId(geomId);\n      }\n\n      return true;\n    }\n\n    /**\n       * Add a material that can be used by a mesh in the model.\n       *\n       * @param {string} name The name used for the material. This name must not be\n       *  used for an existing material in the model.\n       * @param {THREE.Material} material The material to add. This material must not\n       *  be used in the model.\n       * @returns {boolean} True if the material was added.\n       * @alias Autodesk.Viewing.Extensions.ModelBuilder#addMaterial\n       */ }, { key: \"addMaterial\", value: function addMaterial(\n    name, material) {\n      if (!material || material.materialManagerName)\n      return false;\n      name = name || \"!!mtl-\" + material.id;\n      var matman = this.model.loader.viewer3DImpl.matman();\n      var hash = matman._getMaterialHash(this.model, name);\n      // Name must not be used and material must be valid.\n      if (name === defaultMtlName || matman._materials[hash] || matman._materialsNonHDR[hash])\n      return false;\n      if (!material.packedNormals) {\n        material.packedNormals = true;\n        material.needsUpdate = true;\n      }\n\n      _addMaterial(matman, hash, material);\n\n      material.materialManagerName = name;\n\n      return true;\n    }\n\n    /**\n       * Validate materials from caller\n       *\n       * @param {number|THREE.Material|Array<number|THREE.Material>} materials The materials or namess of the materials\n       *  to validate.\n       * @returns {string[]} An array of the hashes of the validated materials. Null is returned if any\n       *  of the materials are invalid.\n       * @private\n       */ }, { key: \"_validateMaterials\", value: function _validateMaterials(\n    materials) {\n      if (!Array.isArray(materials))\n      materials = [materials];\n\n      var matman = this.model.loader.viewer3DImpl.matman();\n      var mtls = [];\n      for (var i = 0; i < materials.length; ++i) {\n        var name = materials[i];\n        var oldMat = void 0;\n        var hash = void 0;\n        if (name instanceof THREE.Material) {\n          oldMat = name;\n          name = name.materialManagerName;\n          hash = matman._getMaterialHash(this.model, name);\n          // Name must be the right material\n          if (oldMat !== (matman._materials[hash] || matman._materialsNonHDR[hash]))\n          return null;\n        } else {\n          hash = matman._getMaterialHash(this.model, name);\n          // Name must be used\n          var _oldMat = matman._materials[hash] || matman._materialsNonHDR[hash];\n          if (!_oldMat)\n          return null;\n        }\n\n        mtls.push(hash);\n      }\n\n      return mtls;\n    }\n\n    /**\n       * Replaces an existing material with another one.\n       *\n       * @param {string|THREE.Material} existingMaterial The material or name of the material to change. The material\n       *  must be in the model.\n       * @param {THREE.Material} material The material to replace the existing material. This material\n       *  must not be used in the model.\n       * @returns {boolean} True if the material is valid and the material was changed.\n       * @alias Autodesk.Viewing.Extensions.ModelBuilder#changeMaterial\n       */ }, { key: \"changeMaterial\", value: function changeMaterial(\n    existingMaterial, material) {\n      if (!material || material.materialManagerName)\n      return false;\n      var mtls = this._validateMaterials(existingMaterial);\n      if (!mtls)\n      return false;\n\n      var matman = this.model.loader.viewer3DImpl.matman();\n      var hash = mtls[0];\n      var oldMat = matman._materials[hash] || matman._materialsNonHDR[hash];\n      var name = oldMat.materialManagerName;\n      if (!material.packedNormals) {\n        material.packedNormals = true;\n        material.needsUpdate = true;\n      }\n\n      _addMaterial(matman, hash, material);\n      oldMat.materialManagerName = undefined;\n      material.materialManagerName = name;\n\n      var fragList = this.fragList;\n      if (fragList.useThreeMesh) {\n        // Using meshes, need to replace the material in each mesh\n        var meshes = fragList.vizmeshes;\n        for (var i = 0; i < meshes.length; ++i) {\n          if (meshes[i] && meshes[i].material === oldMat)\n          meshes[i].material = material;\n        }\n      } else {\n        // This is easier, because we just need to update the material\n        // at the right id\n        var matId = fragList.materialmap[oldMat.id];\n        if (matId !== undefined) {\n          fragList.materialmap[material.id] = matId;\n          fragList.materialIdMap[matId] = material;\n        }\n      }\n\n      return true;\n    }\n\n    /**\n       * Find a material\n       *\n       * @param {string} name The name of the material\n       */ }, { key: \"findMaterial\", value: function findMaterial(\n    name) {\n      var matman = this.model.loader.viewer3DImpl.matman();\n      var hash = matman._getMaterialHash(this.model, name);\n      return matman._materials[hash] || matman._materialsNonHDR[hash];\n    }\n\n    /**\n       * Return the fragments that are using materials.\n       *\n       * @param {string|THREE.Material|Array<string|THREE.Material>} materials The materials or names of the materials to use in the search.\n       * @returns {number[]} An array with the fragment ids for all\n       *  fragments that were using the materials. Null is returned\n       *  if any material name is invalid or all of the materials were not removed.\n       * @alias Autodesk.Viewing.Extensions.ModelBuilder#findMaterialFragments\n       */ }, { key: \"findMaterialFragments\", value: function findMaterialFragments(\n    materials) {\n      var hashes = this._validateMaterials(materials);\n      if (!hashes)\n      return null;\n\n      var matman = this.model.loader.viewer3DImpl.matman();\n      var fragList = this.fragList;\n      var useThreeMesh = fragList.useThreeMesh;\n      var findFrags = false;\n      var matIds = {};\n      for (var i = 0; i < hashes.length; ++i) {\n        var oldMat = matman._materials[hashes[i]] || matman._materialsNonHDR[hashes[i]];\n        var matId = useThreeMesh ? oldMat.id : fragList.materialmap[oldMat.id];\n        if (matId !== undefined) {\n          matIds[matId] = true;\n          findFrags = true;\n        }\n      }\n\n      var frags = [];\n      if (findFrags) {\n        if (useThreeMesh) {\n          // Nees to seach the meshes for the material\n          var meshes = fragList.vizmeshes;\n          var fragCount = meshes.length;\n          for (var _i4 = 0; _i4 < fragCount; ++_i4) {\n            var id = meshes[_i4] && meshes[_i4].material && meshes[_i4].material.id;\n            if (matIds[id])\n            frags.push(_i4);\n          }\n        } else {\n          // Need to search to the frag id to material id map\n          var frag2MatId = fragList.materialids;\n          var _fragCount = frag2MatId.length;\n          for (var _i5 = 0; _i5 < _fragCount; ++_i5) {\n            if (matIds[frag2MatId[_i5]])\n            frags.push(_i5);\n          }\n        }\n      }\n\n      return frags;\n    }\n\n    /**\n       * Remove a material from the model.\n       * The caller should dispose the material if needed.\n       *\n       * @param {string|THREE.Material|Array<string|THREE.Material>} materials The materials or names of the materials to remove. All of the\n       *  names must be used for materials in the model.\n       * @returns {boolean} True if all of the names are valid and all of the materials are removed.\n       * @alias Autodesk.Viewing.Extensions.ModelBuilder#removeMaterial\n       */ }, { key: \"removeMaterial\", value: function removeMaterial(\n    materials) {\n      var hashes = this._validateMaterials(materials);\n      if (!hashes)\n      return false;\n\n      var matman = this.model.loader.viewer3DImpl.matman();\n      var fragList = this.fragList;\n      var useThreeMesh = fragList.useThreeMesh;\n      var idMap = {};\n      var findFrags = false;\n\n      for (var i = 0; i < hashes.length; ++i) {\n        var oldMat = matman._materials[hashes[i]] || matman._materialsNonHDR[hashes[i]];\n        delete matman._materials[hashes[i]];\n        delete matman._materialsNonHDR[hashes[i]];\n\n        if (useThreeMesh) {\n          idMap[oldMat.id] = true;\n          findFrags = true;\n        } else {\n          var matId = fragList.materialmap[oldMat.id];\n          if (matId !== undefined) {\n            delete fragList.materialmap[oldMat.id];\n            delete fragList.materialIdMap[matId];\n            idMap[matId] = true;\n            findFrags = true;\n          }\n        }\n      }\n\n      // Map all fragments using this material to the default.\n      if (findFrags) {\n        if (useThreeMesh) {\n          // Using THREE.Mesh for the fragments, search the mesh list\n          var meshes = fragList.vizmeshes;\n          for (var _i6 = 0; _i6 < meshes.length; ++_i6) {\n            var id = meshes[_i6] && meshes[_i6].material && meshes[_i6].material.id;\n            if (idMap[id]) {\n              fragList.setMaterial(_i6, this._getDefaultMaterial());\n            }\n          }\n        } else {\n          // Use the frag to material id map to find materials to change\n          var fragToMtlId = fragList.materialids;\n          for (var _i7 = 0; _i7 < fragToMtlId.length; ++_i7) {\n            if (idMap[fragToMtlId[_i7]]) {\n              fragList.setMaterial(_i7, this._getDefaultMaterial());\n            }\n          }\n        }\n      }\n\n      return true;\n    }\n\n    /**\n       * Add a fragment to the model using a mesh.\n       * Meshes can only be added to the model when {@link Autodesk.Viewing.Extensions.ModelBuilder#isConservingMemory} is false. \n       * Note the following restrictions:\n       * - A mesh cannot be used multiple times.\n       * - The geometry for a mesh cannot be used in different models.\n       * - The material for a mesh cannot be used in different models.\n       *\n       * @param {THREE.Mesh} mesh The mesh to be added.\n       * @param {boolean} [mesh.isLine=false] Optional bool to mark line geometry\n       * @param {boolean} [mesh.isWideLine=false] Optional bool to mark wide line geometry\n       * @param {boolean} [mesh.isPoint=false] Optional bool to mark point geometry\n       * @param {number} [mesh.fragId] The fragment id for the mesh. This must not be defined\n       *  when addMesh() is called and the Viewer sets this property to the new fragment id.\n       * @param {number} [mesh.modeId] The id of the model. This must not be defined when\n       *  addMesh() is called and the Viewer will set this to the id of the model for this ModelBuilder.\n       * @param {number} [mesh.dbId] An optional object id for the mesh. Meshes with the same object id\n       *  are selected as a unit. Internal tables are maintained to link fragments and dbIds. If a mesh is\n       *  in the scene you shouldn't change this value direcly. Call\n       *  {@link Autodesk.Viewing.Extensions.ModelBuilder#changeFragmentsDbId} to change it to insure\n       *  the tables are updated.\n       * @returns {boolean} True if the mesh was added.\n       * @alias Autodesk.Viewing.Extensions.ModelBuilder#addMesh\n       */ }, { key: \"addMesh\", value: function addMesh(\n    mesh) {\n      if (!mesh || this.conserveMemory || mesh.modelId !== undefined || mesh.fragId !== undefined)\n      return false;\n      if (!mesh.geometry || !mesh.material)\n      return false;\n\n      // Add the geometry, if it wasn't already added\n      var svfid = mesh.geometry.svfid;\n      if (svfid) {\n        if (this.geomList.getGeometry(svfid) !== mesh.geometry)\n        return false;\n      } else if (!this.addGeometry(mesh.geometry))\n      return false;\n\n      // Add the material, if it wasn't already added\n      var mtlName = mesh.material.materialManagerName;\n      if (mtlName) {\n        if (this.findMaterial(mtlName) !== mesh.material)\n        return false;\n      } else if (!this.addMaterial(undefined, mesh.material)) {\n        svfid && this.removeGeometry(svfid);\n        return false;\n      }\n\n      var fragId = this.fragmentIds.reserveId();\n      mesh.dbId = mesh.dbId || START_FRAG_ID - fragId;\n      this.model.setFragment(fragId, mesh, true);\n      var fragments = this.fragList.fragments;\n      fragments.fragId2dbId[fragId] = mesh.dbId;\n      this.instanceTree.nodeAccess.addFragment(mesh.dbId, fragId);\n      this.sceneUpdated(true);\n      return true;\n    }\n\n    /**\n       * Remove a mesh from the model.\n       * Meshes can only be removed from the model when {@link Autodesk.Viewing.Extensions.ModelBuilder#isConservingMemory} is false.\n       *\n       * @param {THREE.Mesh|THREE.Mesh[]} meshes The meshes to be removed.\n       * @returns {boolean} True if the mesh was removed.\n       * @alias Autodesk.Viewing.Extensions.ModelBuilder#removeMesh\n       */ }, { key: \"removeMesh\", value: function removeMesh(\n    meshes) {\n      if (this.conserveMemory)\n      return false;\n\n      return this.removeFragment(meshes);\n    }\n\n    /**\n       * Use this method to inform the Viewer when you directly update a mesh you added\n       * to the model. If you change a mesh directly without calling this method,\n       * it may not display properly. You don't need to call this if you use the\n       * ModelBuilder API to update a mesh.\n       *\n       * @param {THREE.Mesh|THREE.Mesh[]} meshes The meshes that were changed.\n       * @param {boolean} [skipGeom=false] Set to true if the geometry in the meshes wasn't updated\n       * @param {boolean} [skipTransform=false] Set to true if the tranforms in the meshes weren't update\n       * @returns {boolean} True if the viewer was updated\n       * @alias Autodesk.Viewing.Extensions.ModelBuilder#updateMesh\n       */ }, { key: \"updateMesh\", value: function updateMesh(\n    meshes, skipGeom, skipTransform) {\n      // Did anything important change\n      if (skipGeom && skipTransform)\n      return true; // No, return success\n\n      if (!Array.isArray(meshes))\n      meshes = [meshes];\n\n      var i = 0;\n      var mesh;\n      // Skip falsey meshes\n      while (!(mesh = meshes[i])) {\n        // No meshes in the input, return success;\n        if (++i >= meshes.length)\n        return true;\n      }\n\n      do {\n        if (mesh) {\n          if (!skipGeom) {\n            this.packNormals(mesh.geometry);\n            mesh.dispatchEvent(REMOVED_EVENT);\n          }\n          if (!skipTransform) {\n            mesh.matrixWorld.copy(mesh.matrix);\n          }\n        }\n        mesh = meshes[++i];\n      } while (i < meshes.length);\n\n      this.sceneUpdated(!(skipGeom && skipTransform));\n      return true;\n    }\n\n    /**\n       * Signal viewer that scene was modified.\n       *\n       * @param {boolean} [objectsMoved=false] True if transforms or geometry was changed\n       * @param {boolean} [skipRepaint=false] True to skip repainting because of this change\n       * @alias Autodesk.Viewing.Extensions.ModelBuilder#sceneUpdated\n       */ }, { key: \"sceneUpdated\", value: function sceneUpdated(\n    objectsMoved, skipRepaint) {\n      this.model.loader.viewer3DImpl.sceneUpdated(objectsMoved, skipRepaint);\n    }\n\n    /**\n       * Validate the parameters for a fragment\n       *\n       * @param {number|THREE.Mesh} fragment The mesh or fragment id whose geometry is to be set.\n       * @param {number|THREE.BufferGeometry} geometry - The geometry or the id of the geometry for the fragment.\n       *  Use a falsey value if the geometry for the fragment isn't ready. If the geometry hasn't been added\n       *  to the model, this method will add it. Geometry must not be used in a different model.\n       * @param {string|THREE.material} material The material or the name of the material for the fragment.\n       *  A material name must be used by a material in the model, but a material will be added to the model\n       *  if it hasn't been.\n       * @returns {boolean} True if all parameters are valid\n       * @private\n       */ }, { key: \"_validateFragment\", value: function _validateFragment(\n    fragment, geometry, material) {\n      if (fragment instanceof THREE.Mesh) {\n        if (!this.fragList.useThreeMesh || this.fragList.getVizmesh(fragment.fragId) !== fragment)\n        return false;\n      } else if (!this.fragmentIds.isIdReserved(fragment))\n      return false;\n\n      if (geometry) {\n        if (geometry instanceof THREE.BufferGeometry) {\n          if (geometry.svfid && this.geomList.getGeometry(geometry.svfid) !== geometry)\n          return false;\n        } else if (!this.geomIds.isIdReserved(geometry))\n        return false;\n      }\n\n      if (material) {\n        if (material instanceof THREE.Material) {\n          if (material.materialManagerName &&\n          this.findMaterial(material.materialManagerName) !== material) {\n            return false;\n          }\n        } else if (!this.findMaterial(material))\n        return false;\n      }\n\n      return true;\n    }\n\n    /**\n       * Get the geometry id for some geometry\n       *\n       * @param {number|THREE.BufferGeometry} geometry The geometry or the geometry id. If this is geometry\n       *  it will be added to the model if it hasn't been.\n       * @returns {number|null} The id of the geometry, or null if the geometry is in a different model\n       * @private\n       */ }, { key: \"_getGeometry\", value: function _getGeometry(\n    geometry) {\n      return geometry instanceof THREE.BufferGeometry ? (\n      geometry.svfid || this.addGeometry(geometry), geometry) :\n      this.geomList.getGeometry(geometry);\n    }\n\n    /**\n       * Get the material name for a material\n       *\n       * @param {number|THREE.Material} material The material or the material name. If this is a material\n       *  it will be added to the model if it hasn't been.\n       * @returns {string|null} The name of the material, or null if the material is in a different model\n       * @private\n       */ }, { key: \"_getMaterial\", value: function _getMaterial(\n    material) {\n      if (material instanceof THREE.Material) {\n        if (material.materialManagerName) {\n          return material;\n        }\n        this.addMaterial(undefined, material);\n        return material;\n      }\n\n      return this.findMaterial(material);\n    }\n\n    /**\n       * Add a fragment to a model.\n       * A fragment is the combination of a geometry, a material, and a transform.\n       * \n       * @param {number|THREE.BufferGeometry} geometry - The geometry or the id of the geometry for the fragment.\n       *  Use a falsey value if the geometry for the fragment isn't ready. If the geometry hasn't been added\n       *  to the model, this method will add it. Geometry must not be used in a different model.\n       * @param {string|THREE.material} material The material or the name of the material instance for the fragment.\n       *  A material name must be used by a material in the model, but a material will be added to the model\n       *  if it hasn't already.\n       * @param {THREE.Matrix|number[]} [transform] The transform for the fragment. Default\n       *  is the identity transform. If an array is used it is a 4x3 matrix in column major order.\n       * @param {THREE.Box3|number[]} [bbox] Bounding box for the fragment. Default is\n       *  calculated from the geometry bounding box and the transform. \n       *  When {@link Autodesk.Viewing.Extensions.ModelBuilder#isConservingMemory} is true\n       *  then this argument is ignored and the default is used. If an array is used\n       *  it contains the minimum x, y, z followed by the maximum x, y, z.\n       * @returns {number} The fragment id added or 0 if there was an error.\n       * \n       * @alias Autodesk.Viewing.Extensions.ModelBuilder#addFragment\n       */ }, { key: \"addFragment\", value: function addFragment(\n    geometry, material, transform, bbox) {\n      var fragIds = this.fragmentIds;\n      var fragId = fragIds.reserveId();\n      if (fragId === undefined || !this._validateFragment(fragId, geometry, material))\n      return 0;\n      if (_changeFragmentGeometry(this, fragId, geometry, material, transform, bbox))\n      return fragId;\n      fragIds.releaseId(fragId);\n      return 0;\n    }\n\n    /**\n       * Change the geometry and transform for a fragment.\n       * \n       * @param {number|THREE.Mesh} fragment The mesh or fragment id whose geometry is to be set.\n       * @param {number|THREE.BufferGeometry} geometry - The geometry or the id of the geometry for the fragment.\n       *  Use a falsey value if the geometry for the fragment isn't ready. If the geometry hasn't been added\n       *  to the model, this method will add it. Geometry must not be used in a different model.\n       * @param {THREE.Matrix|number[]} [transform] The transform for the fragment. If not\n       *  present the transform isn't changed. If an array is used it is a 4x3 matrix in column major order.\n       * @param {THREE.Box3|number[]} [bbox] Bounding box for the fragment. Default is\n       *  calculated from the geometry bounding box and the transform. \n       *  When {@link Autodesk.Viewing.Extensions.ModelBuilder#isConservingMemory} is true\n       *  then this argument is ignored and the default is used. If an array is used\n       *  it contains the minimum x, y, z followed by the maximum x, y, z.\n       * @returns {boolean} True if the geometry id is valid and the fragment is changed.\n       * \n       * @alias Autodesk.Viewing.Extensions.ModelBuilder#changeFragmentGeometry\n       */ }, { key: \"changeFragmentGeometry\", value: function changeFragmentGeometry(\n    fragment, geometry, transform, bbox) {\n      if (!this._validateFragment(fragment, geometry))\n      return false;\n      var fragId = getFragmentId(fragment);\n      transform = transform || (this.fragList.getOriginalWorldMatrix(fragId, tmpMatrix), tmpMatrix);\n      if (!_changeFragmentGeometry(this, fragment, geometry, undefined, transform, bbox))\n      return false;\n      return true;\n    }\n\n    /**\n       * Get the default material\n       *\n       * @returns {THREE.Material} The default material\n       * @private\n       */ }, { key: \"_getDefaultMaterial\", value: function _getDefaultMaterial()\n    {\n      // If already have default material, then use it\n      if (this._defaultMaterial)\n      return this._defaultMaterial;\n\n      // Clone the matman default.\n      var matman = this.model.loader.viewer3DImpl.matman();\n      var mtl = matman.defaultMaterial.clone();\n\n      // Make sure packed normals is true.\n      mtl.packedNormals = true;\n      mtl.needsUpdate = true;\n\n      // Add it to the material manager\n      matman.addMaterial(matman._getMaterialHash(this.model, defaultMtlName), mtl);\n      this._defaultMaterial = mtl;\n      mtl.materialManagerName = defaultMtlName;\n      return mtl;\n    }\n\n    /**\n       * Change the material for a fragment.\n       *\n       * @param {number|THREE.Mesh} fragment The mesh or fragment id whose material is to be set.\n       * @param {string|THREE.material} material The material or the name of the material for the fragment.\n       *  A material name must be used by a material in the model, but a material will be added to the model\n       *  if it hasn't been.\n       * @returns {boolean} True if the material id is valid and the fragment is changed.\n       * @alias Autodesk.Viewing.Extensions.ModelBuilder#changeFragmentMaterial\n       */ }, { key: \"changeFragmentMaterial\", value: function changeFragmentMaterial(\n    fragment, material) {\n      if (!this._validateFragment(fragment, undefined, material))\n      return false;\n\n      // get the Material and set it for the fragment\n      var mtl = this._getMaterial(material) || this._getDefaultMaterial();\n      this.fragList.setMaterial(getFragmentId(fragment), mtl);\n      this.sceneUpdated(false);\n      return true;\n    }\n\n    /**\n       * Change the transform for a fragment.\n       *\n       * @param {number|THREE.Mesh} fragment The mesh or fragment id whose material is to be set.\n       * @param {THREE.Matrix|number[]} transform The transform for the fragment.\n       *  If an array is used it is a 4x3 matrix in column major order.\n       * @param {THREE.Box3|number[]} [bbox] [bbox] Bounding box for the fragment. Default is\n       *  calculated from the geometry bounding box and the transform. \n       *  When {@link Autodesk.Viewing.Extensions.ModelBuilder#isConservingMemory} is true\n       *  then this argument is ignored and the default is used. If an array is used\n       *  it contains the minimum x, y, z followed by the maximum x, y, z.\n       * @returns {boolean} True if the fragId is valid and the transform was changed.\n       * @alias Autodesk.Viewing.Extensions.ModelBuilder#changeFragmentTransform\n       */ }, { key: \"changeFragmentTransform\", value: function changeFragmentTransform(\n    fragment, transform, bbox) {\n      if (!transform || !this._validateFragment(fragment))\n      return false;\n\n      // Need to replace the geometry with the same id to change\n      // the transform.\n      var id = getFragmentId(fragment);\n      if (!this.changeFragmentGeometry(id, this.fragList.getGeometryId(id),\n      transform, bbox)) {\n        return false;\n      }\n      this.sceneUpdated(true);\n      return true;\n    }\n\n    /**\n       * Change the dbId of one or more fragments\n       *\n       * @param {number|THREE.Mesh|Array<number|THREE.Mesh>} fragments The meshes or ids of the fragments to be changed\n       * @param {number} dbId The new dbId of the fragments. A 0 dbId will prevent an object from being selected.\n       *  All fragments with the same dbId are selected as a single object. Changing the dbids on fragments will\n       *  not change the display of objects that are already selected.\n       * @returns {boolean} True if all of the fragment ids were valid and all of the\n       *  fragments were changed.\n       * @alias Autodesk.Viewing.Extensions.ModelBuilder#changeFragmentsDbId\n       */ }, { key: \"changeFragmentsDbId\", value: function changeFragmentsDbId(\n    fragments, dbId) {\n      if (!Array.isArray(fragments))\n      fragments = [fragments];\n\n      dbId = dbId | 0; // Force dbId to integer\n      for (var i = 0; i < fragments.length; ++i) {\n        // Make sure the fragId is valid;\n        if (!this._validateFragment(fragments[i]))\n        return false;\n      }\n\n      var frags = this.fragList.fragments;\n      var instanceTree = this.instanceTree;\n      var fragId2dbId = frags.fragId2dbId;\n      if (this.conserveMemory) {\n        for (var _i8 = 0; _i8 < fragments.length; ++_i8) {\n          var id = getFragmentId(fragments[_i8]);\n          changeDbId(dbId, id, fragId2dbId, instanceTree);\n        }\n      } else {\n        var array = this.fragList.vizmeshes;\n        for (var _i9 = 0; _i9 < fragments.length; ++_i9) {\n          var _id = getFragmentId(fragments[_i9]);\n          changeDbId(dbId, _id, fragId2dbId, instanceTree);\n          array[_id].dbId = dbId;\n        }\n      }\n\n      return true;\n    }\n\n    /**\n       * Remove fragments from the model\n       *\n       * @param {number|THREE.Mesh|Array<number|THREE.Mesh>} fragments The meshes or ids of the fragments to be removed\n       * @returns {boolean} True if all of the fragment ids were valid and all of the\n       *  fragments were removed.\n       * @alias Autodesk.Viewing.Extensions.ModelBuilder#removeFragment\n       */ }, { key: \"removeFragment\", value: function removeFragment(\n    fragments) {\n      if (!Array.isArray(fragments))\n      fragments = [fragments];\n\n      for (var i = 0; i < fragments.length; ++i) {\n        // Make sure the fragId is valid;\n        if (!this._validateFragment(fragments[i]))\n        return false;\n      }\n\n      var frags = this.fragList.fragments;\n      var instanceTree = this.instanceTree;\n      var array = this.conserveMemory ? this.fragList.geomids : this.fragList.vizmeshes;\n      var clear = this.conserveMemory ? 0 : null;\n      for (var _i10 = 0; _i10 < fragments.length; ++_i10) {\n        var id = getFragmentId(fragments[_i10]);\n        this.fragmentIds.releaseId(id);\n        instanceTree.nodeAccess.removeFragment(frags.fragId2dbId[id], id);\n        frags.fragId2dbId[id] = 0;\n        if (!this.conserveMemory && array[id]) {\n          array[id].dispatchEvent(REMOVED_EVENT);\n          array[id].fragId = array[id].modelId = undefined;\n        }\n        array[id] = clear;\n      }\n      this.sceneUpdated(true);\n\n      return true;\n    }\n\n    /**\n       * Pack normals for geometry.\n       * Utility method automatically used when {@link Autodesk.Viewing.Extensions.ModelBuilder#isConservingMemory} is true.\n       * \n       * @param {THREE.BufferGeometry} geometry \n       * @returns {THREE.BufferGeometry} The geometry argument is returned\n       * \n       * @alias Autodesk.Viewing.Extensions.ModelBuilder#packNormals\n       */ }, { key: \"packNormals\", value: function packNormals(\n    geometry) {\n      var attributes = geometry.attributes;\n      var normal = attributes.normal;\n      // If no normals or normals are already packed, then skip this\n      if (!normal || normal.itemSize !== 3)\n      return geometry;\n\n      /**\n                        * @param src\n                        * @param srcOff\n                        * @param srcStride\n                        * @param dst\n                        * @param dstOff\n                        * @param dstStride\n                        * @private\n                        */\n      function cvt(src, srcOff, srcStride, dst, dstOff, dstStride) {\n        var atan2 = Math.atan2;\n        var INV_PI = 1 / Math.PI;\n        for (; srcOff < src.length; srcOff += srcStride, dstOff += dstStride) {\n          var pnx = (atan2(src[srcOff + 1], src[srcOff]) * INV_PI + 1.0) * 0.5;\n          var pny = (src[srcOff + 2] + 1.0) * 0.5;\n\n          dst[dstOff] = pnx * 65535 | 0;\n          dst[dstOff + 1] = pny * 65535 | 0;\n        }\n      }\n\n      if (normal.array) {\n        // The normals are not interleaved\n        var vcount = Math.floor(normal.length / normal.itemSize);\n        var dst = new Uint16Array(vcount * 2);\n        cvt(normal.array, 0, 3, dst, 0, 2);\n        normal.itemSize = 2;\n        normal.array = dst;\n        normal.normalize = true;\n        normal.needsUpdate = true;\n        normal.bytesPerItem = 2;\n      } else {\n        // The normals are part of an interleaved buffer\n        // First copy all of the data that isn't normal to the new buffer\n        var vbstride = geometry.vbstride;\n        var vb = geometry.vb;\n        var _vcount = Math.floor(vb.length / vbstride);\n\n        // ALlocate the new buffer. The normals shrink from 3 floats to\n        // 2 UInt16s which is 1 float. So reduce the vbstride by 2\n        var _dst = new Float32Array((vbstride - 2) * _vcount);\n        var srcOff = normal.itemOffset;\n\n        if (srcOff <= 0 || srcOff + 3 >= vbstride) {\n          // Normals are at start or end of interleaved buffer\n          var from = srcOff <= 0 ? 3 : 0;\n          var to = srcOff <= 0 ? 1 : 0;\n          var length = vbstride - 3;\n          for (var i = 0; i < _vcount; ++i, from += 3, to += 1) {\n            for (var j = 0; j < length; ++j) {\n              _dst[to++] = vb[from++];\n            }\n          }\n        } else {\n          // Normals are in the middle of interleaved buffer\n          // Normals are at start or end of interleaved buffer\n          var _from = 0;\n          var _to = 0;\n          var length1 = srcOff;\n          var length2 = vbstride - srcOff - 3;\n          for (var _i11 = 0; _i11 < _vcount; ++_i11) {\n            for (var _j = 0; _j < length1; ++_j) {\n              _dst[_to++] = vb[_from++];\n            }\n            _from += 3;\n            _to += 1;\n            for (var _j2 = 0; _j2 < length2; ++_j2) {\n              _dst[_to++] = vb[_from++];\n            }\n          }\n        }\n\n        // Pack the normals, Recast the interleaved buffer as 16 bit ints\n        cvt(vb, srcOff, vbstride, new Uint16Array(_dst.buffer), srcOff * 2, (vbstride - 2) * 2);\n        geometry.vbstride -= 2;\n        geometry.vb = _dst;\n        geometry.vbNeedsUpdate = true;\n        // For interleaved case, the attributes are cached and shared, so we need\n        // to find the attribute with the proper description.\n        attributes.normal = avp.BufferGeometryUtils.findBufferAttribute('normal', {\n          array: null,\n          bytesPerItem: 2,\n          itemSize: 2,\n          normalize: true,\n          isPattern: normal.isPattern,\n          divisor: normal.divisor,\n          offset: normal.itemOffset },\n        geometry.numInstances);\n\n        // Adjust all of the offsets for the packed buffers\n        var keys = Object.keys(attributes);\n        for (var _i12 = 0; _i12 < keys.length; ++_i12) {\n          var attr = attributes[keys[_i12]];\n          if (!attr.array && attr.itemOffset > srcOff) {\n            // For interleaved case, the attributes are cached and shared, so we need\n            // to find the attribute with the proper description.\n            attributes[keys[_i12]] = avp.BufferGeometryUtils.findBufferAttribute(keys[_i12], {\n              array: null,\n              bytesPerItem: attr.bytesPerItem,\n              itemSize: attr.itemSize,\n              normalize: attr.normalize,\n              isPattern: attr.isPattern,\n              divisor: attr.divisor,\n              offset: attr.itemOffset - 2 },\n            geometry.numInstances);\n          }\n        }\n      }\n\n      return geometry;\n    }\n\n    /**\n       * Add a new model to the viewer\n       *\n       * @param {Autodesk.Extensions.SceneBuilder.SceneBuilder} sceneBuilder The SceneBuilder asking for the model\n       * @param {any} options Options for adding the model.\n       * @param {boolean} [options.conserveMemory] Set to true to turn on memory conservation mode.\n       *  In this mode [addMesh()]{@link Extensions.SceneBuilder.ModelBuilder#addMesh} is not available because a single mesh is shared among\n       *  all of the fragments in the model.\n       * @param {boolean} [options.createWireframe] Set to true to turn on edge generation for geometry.\n       * @returns {Promise<Autodesk.Extensions.SceneBuilder.ModelBuilder>} A promise that resolves to the ModelBuilder for the new model.\n       * @private\n       */ }], [{ key: \"addNewModel\", value: function addNewModel(\n    sceneBuilder, options) {\n      return new Promise(function (resolve, reject) {\n        //Set up overrides for Fluent\n        var loadOptions = Object.assign({}, options);\n        loadOptions.fileLoader = EmptyModelLoader;\n        loadOptions.globalOffset = loadOptions.globalOffset || { x: 0, y: 0, z: 0 }; //Make camera operations more sane by not having to offset everything\n\n        sceneBuilder.viewer.loadModel(\"Dummy\", loadOptions, function (model) {\n          resolve(new ModelBuilder(model, loadOptions));\n        }, function (error) {\n          reject(error);\n        });\n      });\n    } }]);return ModelBuilder;}();\n\n\nexport { ModelBuilder };","function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError(\"Cannot call a class as a function\");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}import { RBTree } from 'bintrees';\n\nvar tmpRange = [0, 1];\n\n/**\n                        * Table to manage ids that can be  reserved and released and keep the\n                        * id values as compact as possible.\n                        */\nexport var ReusableIds = /*#__PURE__*/function () {\n  /**\n                                                    * Construct the id table\n                                                    */\n  function ReusableIds(lowId, highId, reserve) {_classCallCheck(this, ReusableIds);\n    this._lowId = lowId === undefined ? 0 : lowId | 0;\n    this._highId = highId === undefined ? 4 * 1024 * 1024 * 1024 - 1 : highId | 0;\n    this._availableIds = new RBTree(function (a, b) {return a[0] - b[0];});\n    this._availableIds.insert([this._lowId + (reserve | 0), this._highId]);\n  }\n\n  /**\n     * Get next id\n     * @return {number|undefined} The next id or undefined if there aren't any more ids.\n     */_createClass(ReusableIds, [{ key: \"reserveId\", value: function reserveId()\n    {\n      var range = this._availableIds.min();\n      if (range === null)\n      return undefined;\n      var id = range[0];\n      if (id >= range[1]) {\n        // Remove the empty range.\n        this._availableIds.remove(range);\n      } else {\n        // Updating the key of the RBTree without removing and inserting it\n        // is probably not correct, but the ranges are all disjoint and so it should be OK\n        ++range[0];\n      }\n      return id;\n    }\n\n    /**\n       * Make an id available again\n       * @param {number} id The id\n       * @return {Boolean} True if the id can be released.\n       */ }, { key: \"releaseId\", value: function releaseId(\n    id) {\n      if (id < this._lowId || id > this._highId)\n      return false;\n\n      tmpRange[0] = id; // Only the first\n      var ranges = this._availableIds.lowerBound(tmpRange);\n      var upper = ranges.data();\n      if (upper !== null) {\n        // Make sure the id isn't already in a range\n        if (upper[0] <= id && upper[1] >= id) {\n          return false;\n        }\n\n        ranges.prev();\n        var lower = ranges.data();\n        if (id + 1 === upper[0]) {\n          if (lower === null || id - 1 > lower[1]) {\n            // Extend the upper range to include id\n            // Updating the key of the RBTree without removing and inserting it\n            // is probably not correct, but the ranges are all disjoint and so it should be OK\n            upper[0] = id;\n          } else {\n            // Combine upper and lower ranges\n            this._availableIds.remove(upper);\n            this._availableIds.remove(lower);\n            upper[0] = lower[0];\n            this._availableIds.insert(upper);\n          }\n        } else if (lower === null || id - 1 > lower[1]) {\n          // Add a new single id range\n          this._availableIds.insert([id, id]);\n        } else {\n          // Extend the lower range\n          // Updating the key of the RBTree without removing and inserting it\n          // is probably not correct, but the ranges are all disjoint and so it should be OK\n          lower[1] = id;\n        }\n      }\n\n      return true;\n    } }, { key: \"isIdReserved\", value: function isIdReserved(\n\n    id) {\n      if (id < this._lowId || id > this._highId)\n      return false;\n\n      tmpRange[0] = id; // Only the first\n      var upper = this._availableIds.upperBound(tmpRange).prev();\n      return !upper || id < upper[0] || id > upper[1];\n    } }]);return ReusableIds;}();","function _typeof(obj) {\"@babel/helpers - typeof\";if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;};}return _typeof(obj);}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError(\"Cannot call a class as a function\");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}function _inherits(subClass, superClass) {if (typeof superClass !== \"function\" && superClass !== null) {throw new TypeError(\"Super expression must either be null or a function\");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}function _createSuper(Derived) {var hasNativeReflectConstruct = _isNativeReflectConstruct();return function _createSuperInternal() {var Super = _getPrototypeOf(Derived),result;if (hasNativeReflectConstruct) {var NewTarget = _getPrototypeOf(this).constructor;result = Reflect.construct(Super, arguments, NewTarget);} else {result = Super.apply(this, arguments);}return _possibleConstructorReturn(this, result);};}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");}return self;}function _isNativeReflectConstruct() {if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;if (Reflect.construct.sham) return false;if (typeof Proxy === \"function\") return true;try {Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));return true;} catch (e) {return false;}}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}import { ModelBuilder } from './modelBuilder';\nimport { locales } from './locales';\n\nvar av = Autodesk.Viewing;\nvar SCENE_BUILD_EXTENSION_ID = \"Autodesk.Viewing.SceneBuilder\";\n\n/**\n                                                                 * Scene Builder extension provides an API for building scenes without\n                                                                 * loading them from a URL.\n                                                                 * \n                                                                 * The extension id is: `Autodesk.Viewing.SceneBuilder`\n                                                                 * \n                                                                 * @example\n                                                                 *  viewer.loadExtension('Autodesk.Viewing.SceneBuilder');\n                                                                 * \n                                                                 * @memberof Autodesk.Viewing.Extensions\n                                                                 * @alias Autodesk.Viewing.Extensions.SceneBuilder\n                                                                 */var\nSceneBuilder = /*#__PURE__*/function (_av$Extension) {_inherits(SceneBuilder, _av$Extension);var _super = _createSuper(SceneBuilder);\n\n  /**\n                                                                                                                                       * @class\n                                                                                                                                       * @param {Autodesk.Viewing.Viewer3D} viewer The viewer instance loading the extension\n                                                                                                                                       * @param {object} [options] Default options used when calling addNewModel\n                                                                                                                                       * @param {boolean} [options.conserveMemory=false] Set to true to turn on memory conservation mode.\n                                                                                                                                       *  In this mode [addMesh()]{@link Autodesk.Viewing.Extensions.SceneBuilder#addMesh} is not available because a single mesh is shared among\n                                                                                                                                       *  all of the fragments in the model.\n                                                                                                                                       */\n  function SceneBuilder(viewer, options) {var _this;_classCallCheck(this, SceneBuilder);\n    _this = _super.call(this, viewer, options);\n    _this._loaded = false;\n    _this.extendLocalization(locales);return _this;\n  }\n\n  /**\n     * Extension interface method - loads the extension\n     *\n     * @alias Autodesk.Viewing.Extensions.SceneBuilder#load\n     * @returns {boolean}\n     */_createClass(SceneBuilder, [{ key: \"load\", value: function load()\n    {\n      this._loaded = true;\n      return true;\n    }\n\n    /**\n       * Extension interface method - unloads the extension\n       * Method {@link Autodesk.Viewing.Extensions.SceneBuilder#addNewModel} will fail if the extension is unloaded.\n       *\n       * @alias Autodesk.Viewing.Extensions.SceneBuilder#unload\n       */ }, { key: \"unload\", value: function unload()\n    {\n      this._loaded = false;\n      return true;\n    }\n\n    /**\n       * Add a new empty model into the scene. The model can be manipulated only by its associated\n       * ModelBuilder instance.\n       *\n       * @param {object} [options] Options combined with the options used  when the\n       *  extension is loaded with loadExtension(). The combined options are\n       *  put in the loadOptions property in the object returned by model.getData().\n       * @param {boolean} [options.conserveMemory=false] Set to true to turn on memory conservation mode.\n       *  In this mode [addMesh()]{@link Autodesk.Viewing.Extensions.SceneBuilder#addMesh} is not available because a single mesh is shared among\n       *  all of the fragments in the model.\n       * @param {boolean} [options.createWireframe] Set to true to turn on edge generation for geometry. \n       * @returns {Promise.<Autodesk.Viewing.Extensions.ModelBuilder>} A Promise that resolves with a ModelBuilder instance for the new model.\n       *\n       * @alias Autodesk.Viewing.Extensions.SceneBuilder#addNewModel\n       */ }, { key: \"addNewModel\", value: function addNewModel(\n    options) {\n      if (!this._loaded) {\n        return Promise.reject(new Error(\"SceneBuilder extension not loaded\"));\n      }\n\n      return ModelBuilder.addNewModel(this, Object.assign({}, this.options, options));\n    } }]);return SceneBuilder;}(av.Extension);\n\n\nav.theExtensionManager.registerExtension(SCENE_BUILD_EXTENSION_ID, SceneBuilder);","module.exports = {\n    RBTree: require('./lib/rbtree'),\n    BinTree: require('./lib/bintree')\n};\n","\nvar TreeBase = require('./treebase');\n\nfunction Node(data) {\n    this.data = data;\n    this.left = null;\n    this.right = null;\n}\n\nNode.prototype.get_child = function(dir) {\n    return dir ? this.right : this.left;\n};\n\nNode.prototype.set_child = function(dir, val) {\n    if(dir) {\n        this.right = val;\n    }\n    else {\n        this.left = val;\n    }\n};\n\nfunction BinTree(comparator) {\n    this._root = null;\n    this._comparator = comparator;\n    this.size = 0;\n}\n\nBinTree.prototype = new TreeBase();\n\n// returns true if inserted, false if duplicate\nBinTree.prototype.insert = function(data) {\n    if(this._root === null) {\n        // empty tree\n        this._root = new Node(data);\n        this.size++;\n        return true;\n    }\n\n    var dir = 0;\n\n    // setup\n    var p = null; // parent\n    var node = this._root;\n\n    // search down\n    while(true) {\n        if(node === null) {\n            // insert new node at the bottom\n            node = new Node(data);\n            p.set_child(dir, node);\n            ret = true;\n            this.size++;\n            return true;\n        }\n\n        // stop if found\n        if(this._comparator(node.data, data) === 0) {\n            return false;\n        }\n\n        dir = this._comparator(node.data, data) < 0;\n\n        // update helpers\n        p = node;\n        node = node.get_child(dir);\n    }\n};\n\n// returns true if removed, false if not found\nBinTree.prototype.remove = function(data) {\n    if(this._root === null) {\n        return false;\n    }\n\n    var head = new Node(undefined); // fake tree root\n    var node = head;\n    node.right = this._root;\n    var p = null; // parent\n    var found = null; // found item\n    var dir = 1;\n\n    while(node.get_child(dir) !== null) {\n        p = node;\n        node = node.get_child(dir);\n        var cmp = this._comparator(data, node.data);\n        dir = cmp > 0;\n\n        if(cmp === 0) {\n            found = node;\n        }\n    }\n\n    if(found !== null) {\n        found.data = node.data;\n        p.set_child(p.right === node, node.get_child(node.left === null));\n\n        this._root = head.right;\n        this.size--;\n        return true;\n    }\n    else {\n        return false;\n    }\n};\n\nmodule.exports = BinTree;\n\n","\nvar TreeBase = require('./treebase');\n\nfunction Node(data) {\n    this.data = data;\n    this.left = null;\n    this.right = null;\n    this.red = true;\n}\n\nNode.prototype.get_child = function(dir) {\n    return dir ? this.right : this.left;\n};\n\nNode.prototype.set_child = function(dir, val) {\n    if(dir) {\n        this.right = val;\n    }\n    else {\n        this.left = val;\n    }\n};\n\nfunction RBTree(comparator) {\n    this._root = null;\n    this._comparator = comparator;\n    this.size = 0;\n}\n\nRBTree.prototype = new TreeBase();\n\n// returns true if inserted, false if duplicate\nRBTree.prototype.insert = function(data) {\n    var ret = false;\n\n    if(this._root === null) {\n        // empty tree\n        this._root = new Node(data);\n        ret = true;\n        this.size++;\n    }\n    else {\n        var head = new Node(undefined); // fake tree root\n\n        var dir = 0;\n        var last = 0;\n\n        // setup\n        var gp = null; // grandparent\n        var ggp = head; // grand-grand-parent\n        var p = null; // parent\n        var node = this._root;\n        ggp.right = this._root;\n\n        // search down\n        while(true) {\n            if(node === null) {\n                // insert new node at the bottom\n                node = new Node(data);\n                p.set_child(dir, node);\n                ret = true;\n                this.size++;\n            }\n            else if(is_red(node.left) && is_red(node.right)) {\n                // color flip\n                node.red = true;\n                node.left.red = false;\n                node.right.red = false;\n            }\n\n            // fix red violation\n            if(is_red(node) && is_red(p)) {\n                var dir2 = ggp.right === gp;\n\n                if(node === p.get_child(last)) {\n                    ggp.set_child(dir2, single_rotate(gp, !last));\n                }\n                else {\n                    ggp.set_child(dir2, double_rotate(gp, !last));\n                }\n            }\n\n            var cmp = this._comparator(node.data, data);\n\n            // stop if found\n            if(cmp === 0) {\n                break;\n            }\n\n            last = dir;\n            dir = cmp < 0;\n\n            // update helpers\n            if(gp !== null) {\n                ggp = gp;\n            }\n            gp = p;\n            p = node;\n            node = node.get_child(dir);\n        }\n\n        // update root\n        this._root = head.right;\n    }\n\n    // make root black\n    this._root.red = false;\n\n    return ret;\n};\n\n// returns true if removed, false if not found\nRBTree.prototype.remove = function(data) {\n    if(this._root === null) {\n        return false;\n    }\n\n    var head = new Node(undefined); // fake tree root\n    var node = head;\n    node.right = this._root;\n    var p = null; // parent\n    var gp = null; // grand parent\n    var found = null; // found item\n    var dir = 1;\n\n    while(node.get_child(dir) !== null) {\n        var last = dir;\n\n        // update helpers\n        gp = p;\n        p = node;\n        node = node.get_child(dir);\n\n        var cmp = this._comparator(data, node.data);\n\n        dir = cmp > 0;\n\n        // save found node\n        if(cmp === 0) {\n            found = node;\n        }\n\n        // push the red node down\n        if(!is_red(node) && !is_red(node.get_child(dir))) {\n            if(is_red(node.get_child(!dir))) {\n                var sr = single_rotate(node, dir);\n                p.set_child(last, sr);\n                p = sr;\n            }\n            else if(!is_red(node.get_child(!dir))) {\n                var sibling = p.get_child(!last);\n                if(sibling !== null) {\n                    if(!is_red(sibling.get_child(!last)) && !is_red(sibling.get_child(last))) {\n                        // color flip\n                        p.red = false;\n                        sibling.red = true;\n                        node.red = true;\n                    }\n                    else {\n                        var dir2 = gp.right === p;\n\n                        if(is_red(sibling.get_child(last))) {\n                            gp.set_child(dir2, double_rotate(p, last));\n                        }\n                        else if(is_red(sibling.get_child(!last))) {\n                            gp.set_child(dir2, single_rotate(p, last));\n                        }\n\n                        // ensure correct coloring\n                        var gpc = gp.get_child(dir2);\n                        gpc.red = true;\n                        node.red = true;\n                        gpc.left.red = false;\n                        gpc.right.red = false;\n                    }\n                }\n            }\n        }\n    }\n\n    // replace and remove if found\n    if(found !== null) {\n        found.data = node.data;\n        p.set_child(p.right === node, node.get_child(node.left === null));\n        this.size--;\n    }\n\n    // update root and make it black\n    this._root = head.right;\n    if(this._root !== null) {\n        this._root.red = false;\n    }\n\n    return found !== null;\n};\n\nfunction is_red(node) {\n    return node !== null && node.red;\n}\n\nfunction single_rotate(root, dir) {\n    var save = root.get_child(!dir);\n\n    root.set_child(!dir, save.get_child(dir));\n    save.set_child(dir, root);\n\n    root.red = true;\n    save.red = false;\n\n    return save;\n}\n\nfunction double_rotate(root, dir) {\n    root.set_child(!dir, single_rotate(root.get_child(!dir), !dir));\n    return single_rotate(root, dir);\n}\n\nmodule.exports = RBTree;\n","\nfunction TreeBase() {}\n\n// removes all nodes from the tree\nTreeBase.prototype.clear = function() {\n    this._root = null;\n    this.size = 0;\n};\n\n// returns node data if found, null otherwise\nTreeBase.prototype.find = function(data) {\n    var res = this._root;\n\n    while(res !== null) {\n        var c = this._comparator(data, res.data);\n        if(c === 0) {\n            return res.data;\n        }\n        else {\n            res = res.get_child(c > 0);\n        }\n    }\n\n    return null;\n};\n\n// returns iterator to node if found, null otherwise\nTreeBase.prototype.findIter = function(data) {\n    var res = this._root;\n    var iter = this.iterator();\n\n    while(res !== null) {\n        var c = this._comparator(data, res.data);\n        if(c === 0) {\n            iter._cursor = res;\n            return iter;\n        }\n        else {\n            iter._ancestors.push(res);\n            res = res.get_child(c > 0);\n        }\n    }\n\n    return null;\n};\n\n// Returns an iterator to the tree node at or immediately after the item\nTreeBase.prototype.lowerBound = function(item) {\n    var cur = this._root;\n    var iter = this.iterator();\n    var cmp = this._comparator;\n\n    while(cur !== null) {\n        var c = cmp(item, cur.data);\n        if(c === 0) {\n            iter._cursor = cur;\n            return iter;\n        }\n        iter._ancestors.push(cur);\n        cur = cur.get_child(c > 0);\n    }\n\n    for(var i=iter._ancestors.length - 1; i >= 0; --i) {\n        cur = iter._ancestors[i];\n        if(cmp(item, cur.data) < 0) {\n            iter._cursor = cur;\n            iter._ancestors.length = i;\n            return iter;\n        }\n    }\n\n    iter._ancestors.length = 0;\n    return iter;\n};\n\n// Returns an iterator to the tree node immediately after the item\nTreeBase.prototype.upperBound = function(item) {\n    var iter = this.lowerBound(item);\n    var cmp = this._comparator;\n\n    while(iter.data() !== null && cmp(iter.data(), item) === 0) {\n        iter.next();\n    }\n\n    return iter;\n};\n\n// returns null if tree is empty\nTreeBase.prototype.min = function() {\n    var res = this._root;\n    if(res === null) {\n        return null;\n    }\n\n    while(res.left !== null) {\n        res = res.left;\n    }\n\n    return res.data;\n};\n\n// returns null if tree is empty\nTreeBase.prototype.max = function() {\n    var res = this._root;\n    if(res === null) {\n        return null;\n    }\n\n    while(res.right !== null) {\n        res = res.right;\n    }\n\n    return res.data;\n};\n\n// returns a null iterator\n// call next() or prev() to point to an element\nTreeBase.prototype.iterator = function() {\n    return new Iterator(this);\n};\n\n// calls cb on each node's data, in order\nTreeBase.prototype.each = function(cb) {\n    var it=this.iterator(), data;\n    while((data = it.next()) !== null) {\n        if(cb(data) === false) {\n            return;\n        }\n    }\n};\n\n// calls cb on each node's data, in reverse order\nTreeBase.prototype.reach = function(cb) {\n    var it=this.iterator(), data;\n    while((data = it.prev()) !== null) {\n        if(cb(data) === false) {\n            return;\n        }\n    }\n};\n\n\nfunction Iterator(tree) {\n    this._tree = tree;\n    this._ancestors = [];\n    this._cursor = null;\n}\n\nIterator.prototype.data = function() {\n    return this._cursor !== null ? this._cursor.data : null;\n};\n\n// if null-iterator, returns first node\n// otherwise, returns next node\nIterator.prototype.next = function() {\n    if(this._cursor === null) {\n        var root = this._tree._root;\n        if(root !== null) {\n            this._minNode(root);\n        }\n    }\n    else {\n        if(this._cursor.right === null) {\n            // no greater node in subtree, go up to parent\n            // if coming from a right child, continue up the stack\n            var save;\n            do {\n                save = this._cursor;\n                if(this._ancestors.length) {\n                    this._cursor = this._ancestors.pop();\n                }\n                else {\n                    this._cursor = null;\n                    break;\n                }\n            } while(this._cursor.right === save);\n        }\n        else {\n            // get the next node from the subtree\n            this._ancestors.push(this._cursor);\n            this._minNode(this._cursor.right);\n        }\n    }\n    return this._cursor !== null ? this._cursor.data : null;\n};\n\n// if null-iterator, returns last node\n// otherwise, returns previous node\nIterator.prototype.prev = function() {\n    if(this._cursor === null) {\n        var root = this._tree._root;\n        if(root !== null) {\n            this._maxNode(root);\n        }\n    }\n    else {\n        if(this._cursor.left === null) {\n            var save;\n            do {\n                save = this._cursor;\n                if(this._ancestors.length) {\n                    this._cursor = this._ancestors.pop();\n                }\n                else {\n                    this._cursor = null;\n                    break;\n                }\n            } while(this._cursor.left === save);\n        }\n        else {\n            this._ancestors.push(this._cursor);\n            this._maxNode(this._cursor.left);\n        }\n    }\n    return this._cursor !== null ? this._cursor.data : null;\n};\n\nIterator.prototype._minNode = function(start) {\n    while(start.left !== null) {\n        this._ancestors.push(start);\n        start = start.left;\n    }\n    this._cursor = start;\n};\n\nIterator.prototype._maxNode = function(start) {\n    while(start.right !== null) {\n        this._ancestors.push(start);\n        start = start.right;\n    }\n    this._cursor = start;\n};\n\nmodule.exports = TreeBase;\n\n"],"mappings":";;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AClFA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AChDA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACz9CA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC7FA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AChFA;AACA;AACA;AACA;;;;;;;;;;;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC3GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACzNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;A","sourceRoot":""}