{"version":3,"sources":["webpack://Autodesk.Extensions.[name]/webpack/bootstrap","webpack://Autodesk.Extensions.[name]/./extensions/Snapping/index.js","webpack://Autodesk.Extensions.[name]/./extensions/Snapping/Snapper.js","webpack://Autodesk.Extensions.[name]/./extensions/Snapping/SnapMath.js","webpack://Autodesk.Extensions.[name]/./extensions/Snapping/SnapperIndicator.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","av","Autodesk","Viewing","namespace","AutodeskNamespace","_export","prop","require","SnappingExtension","viewer","options","this","loadExtension","Extension","theExtensionManager","registerExtension","MeasureCommon","EPSILON","SnapType","SnapResult","VertexBufferReader","Private","isEqualWithPrecision","a","b","Math","abs","isEqualVectorsWithPrecision","v1","v2","x","y","z","distancePointToLine","point","lineStart","lineEnd","equals","distanceTo","distance","param","X0","THREE","Vector3","X1","subVectors","dot","cross","sqrt","SnapCandidateType","Unknown","Line","CircularArc","EllipticalArc","SnapCandidate","viewportId","type","radius","radiusX","radiusY","center","startAngle","endAngle","p1","p2","clone","start","end","CirularArc","other","optionalTarget","isLine","intersectLines","Snapper","_snapResult","_viewer","setGlobalManager","globalManager","_names","_options","markupMode","toolName","_active","_distanceToEdge","Number","MAX_VALUE","_distanceToVertex","_isDragging","_isPressing","_isSnapped","_forcedVpId","_snapToPixel","_snapFilter","indicator","SnapperIndicator","renderSnappedGeometry","renderSnappedTopology","detectRadiusInPixels","isMobileDevice","isActive","getNames","getName","getPriority","activate","deactivate","destroy","copyResults","destiny","copyTo","getEdge","geomEdge","getVertex","geomVertex","getGeometry","getGeometryType","geomType","getIntersectPoint","intersectPoint","getSnapResult","isSnapped","clearSnapped","clear","setViewportId","vpId","setSnapToPixel","enable","getSnapToPixel","setSnapToArc","snapToArc","getSnapToArc","setArc","isArc","getArc","setSnapFilter","filter","snapping3D","result","snapNode","dbId","modelId","model","id","fragIds","face","fragId","undefined","length","hasTopology","snapping3DwithTopology","snapping3DtoMesh","getData","instanceTree","enumNodeFragments","push","geomFace","fi","mesh","impl","getRenderProxy","geometry","topoIndex","getTopoIndex","topology","getTopology","facesTopology","faces","edgesTopology","edges","faceSnappingWithTopology","normalMatrix","Matrix3","getNormalMatrix","matrixWorld","faceNormal","normal","applyMatrix3","normalize","edgeSnappingWithTopology","vertexSnappingWithTopology","setDetectRadius","forceSnapVertices","SNAP_VERTEX","forceSnapEdges","edgeIsCircle","circularArcCenter","circularArcRadius","vertices","SNAP_CIRCULARARC","edgeIsCurved","SNAP_CURVEDEDGE","SNAP_EDGE","faceIsCurved","SNAP_CURVEDFACE","SNAP_FACE","isWideLine","extractLineGeometry","applyMatrix","vertexSnapping","Face3","faceSnapping","edgeSnapping","vA","vB","vC","geom","Geometry","attributes","index","positions","vb","position","array","stride","vbstride","indexList","faceId","j","set","vIndex","indices","ib","offsets","count","oi","Triangle","va","getTrianglesOnSameFace","isIncludeFace","vertexIndices","slice","vc","intersectFace","vCount","k","trianglesSharedEdge","ci","splice","a1","a2","a3","b1","b2","b3","c1","c2","c3","minDistTopoIndex","edgeGeom","minDist","applyMatrix4","dist","edge","lineGeom","isEdge_12","isEdge_13","isEdge_23","minDistIndex","getConnectedLineSegmentsOnSameLine","edgeVertices","V0","V1","dist1","dist2","add","divideScalar","V2","fN1","vA1","fN2","vA2","angleVector2","vector","atan","PI","GeometryCallback","snapper","aDetectRadius","circularArc","ellipticalArc","ellipticalArcCenter","matrix","Matrix4","vpIdLine","vpIdCircular","vpIdElliptical","detectRadius","snapCandidates","onLineSegment","x1","y1","x2","y2","fromLine","onCircularArc","cx","cy","Vector2","sub","pointOnArc","nearestPointOnCircularArc","fromCircularArc","arc","angle","CircleGeometry","makeTranslation","snapPoint","onEllipticalArc","major","minor","tilt","major1","minor1","major2","minor2","equation1","equation2","rx","ry","numPoints","Extensions","CompGeom","getEllipseArcPoint","createEllipticalArcGeometry","pop","nearestPoint","nearestVertexInVertexToEdge","makeEllipticalArc","setMatrix","snapping2D","hitResult","is3d","tr","scale","is2d","getModelToViewerTransform","getMaxScaleOnAxis","getInverseModelToViewerTransform","supportsGeomSnapping","getFragmentList","gc","enumSegments","minx","miny","maxx","maxy","Array","isArray","vbr","enumGeomsForObject","reverseMapDbIdFor2D","finishSnapping2D","RASTER_PIXEL","results","Set","forEach","res","snapping2DOverlay","meshes","enumGeoms","intersectSnap","candidates","snapRadius","sort","ca","cb","first","second","getIntersection","findIntersectionSnap","viewportIndex2d","SNAP_INTERSECTION","lineStripToPieces","mid","addVectors","md","sd","ed","SNAP_CIRCLE_CENTER","snappingRasterPixel","snapMidpoint","isMidpoint","midpoint","SNAP_MIDPOINT","setPerpendicular","isPerpendicular","navapi","navigation","camera","getCamera","getPosition","isPerspective","getEyeVector","fov","getVerticalFov","worldHeight","tan","degToRad","viewport","getScreenViewport","devicePixelRatio","getWindow","height","handleButtonDown","handleButtonUp","handleMouseMove","event","onMouseMove","canvasX","canvasY","handleSingleTap","handlePressHold","handleGesture","onMouseDown","mousePosition","snappingHitTest","vpVec","clientToViewport","intersectGroundViewport","isLeaflet","GlobalManagerMixin","outPoint","dir","copy","atan2","angleInsideArc","multiplyScalar","pStart","getEllipsePoint","pEnd","startIsCloser","distanceToSquared","p3","p4","checkInsideSegment","epsilon","denom","ua","ub","isEqualVectors","GEOMETRIES_OVERLAY","INDICATOR_OVERLAY","_point","overlayType","previewsIntersectPoint","createOverlayScene","geometryMaterial","MeshPhongMaterial","color","ambient","opacity","transparent","depthTest","depthWrite","side","DoubleSide","indicatorMaterial","MeshBasicMaterial","constructor","proto","render","snapResult","clearOverlay","isEmpty","renderGeometry","renderIndicator","removeOverlay","overlayName","removeOverlayScene","clearOverlays","addOverlay","drawFace","material","snapperPlane","Mesh","cylinderMesh","pointX","pointY","width","direction","orientation","lookAt","Object3D","up","multiply","cylinder","CylinderGeometry","drawPoint","drawLine","renderVertexIndicator","pos","getSnapResultPosition","setScale","rightVec","getCameraRightVector","upVec","getCameraUpVector","renderMidpointIndicator","renderEdgeIndicator","renderCircleIndicator","drawCircle","renderPerpendicular","renderPixelIndicator","isPdf","setEdgeScale","SphereGeometry","pointMesh","setPointScale","torus","TorusGeometry","torusMesh","setCircleScale","updatePointScale","overlay","overlayScenes","scene","children","updateEdgeScale","onCameraChange","dispose"],"mappings":"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","file":"Snapping/Snapping.min.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 562);\n","\nvar av = Autodesk.Viewing;\n\n/**\n * @namespace Autodesk.Viewing.Extensions.Snapping\n */\nvar namespace = AutodeskNamespace('Autodesk.Viewing.Extensions.Snapping');\n\n/**\n * @param m\n * @param ns\n * @private\n */\nfunction _export(m, ns) {\n    for (var prop in m) {\n        if (Object.prototype.hasOwnProperty.call(m, prop)) {\n            //Export directly into the module (e.g. for node.js use, where LMV is used via require instead from global namespace)\n            module.exports[prop] = m[prop];\n\n            //Export into the desired viewer namespace\n            ns[prop] = m[prop];\n        }\n    }\n}\n\n_export(require(\"./SnapMath.js\"), namespace);\n_export(require(\"./Snapper.js\"), namespace);\n_export(require(\"./SnapperIndicator.js\"), namespace);\n\n\n/**\n * Utility extension that provides access to the {@link Autodesk.Viewing.Extensions.Snapping.Snapper} tool.\n * \n * The extension id is: `Autodesk.Snapping`\n * \n * @example\n *   viewer.loadExtension('Autodesk.Snapping')\n *  \n * @memberof Autodesk.Viewing.Extensions\n * @alias Autodesk.Viewing.Extensions.SnappingExtension\n * @see {@link Autodesk.Viewing.Extension} for common inherited methods.\n * @class\n */\nclass SnappingExtension extends av.Extension {\n\n    /**\n     * @param {Viewer3D} viewer - Viewer instance\n     * @param {object} options - Configurations for the extension\n     * @alias Autodesk.Viewing.Extensions.SnappingExtension\n     * @class\n     */\n    constructor(viewer, options) {\n        super(viewer, options);\n    }\n\n    /**\n     * Load the extension.\n     *\n     * @returns {Promise} that resolves when dependent extension finishes loading.\n     * \n     * @alias Autodesk.Viewing.Extensions.SnappingExtension#load\n     */\n    load() { \n        // Load the required dependency (and return the pending load as the load completion Promise)\n        return this.viewer.loadExtension('Autodesk.CompGeom');\n    }\n\n    /**\n     * Unloads the extension.\n     * It does not unload dependent extensions.\n     *\n     * @returns {boolean} Always returns true\n     * \n     * @alias Autodesk.Viewing.Extensions.SnappingExtension#unload\n     */\n    unload() { return true; }\n\n\n    /**\n     * Unused method.\n     *\n     * @returns {boolean} Always returns true\n     * \n     * @alias Autodesk.Viewing.Extensions.SnappingExtension#activate\n     */\n    activate() { return true; }\n\n    /**\n     * Unused method.\n     *\n     * @returns {boolean} Always returns false\n     * \n     * @alias Autodesk.Viewing.Extensions.SnappingExtension#deactivate\n     */\n    deactivate() { return false; }\n}\n\n// The ExtensionManager requires an extension to be registered.\nav.theExtensionManager.registerExtension('Autodesk.Snapping', SnappingExtension);\n\n","\nimport { SnapperIndicator } from \"./SnapperIndicator.js\";\nimport { nearestPointOnCircularArc, intersectLines } from \"./SnapMath.js\";\n\nconst MeasureCommon = Autodesk.Viewing.MeasureCommon;\nconst EPSILON = MeasureCommon.EPSILON;\nconst SnapType = MeasureCommon.SnapType;\nconst SnapResult = MeasureCommon.SnapResult;\n\nvar SNAP_PRECISION = 0.001;\n\nconst av = Autodesk.Viewing;\nconst avp = av.Private;\nconst VertexBufferReader = avp.VertexBufferReader;\n\n/**\n * @param {number} a - First value to compare\n * @param {number} b - Second value to compare\n * @private\n */\nfunction isEqualWithPrecision(a, b) {\n    return Math.abs(a - b) <= SNAP_PRECISION;\n}\n\n/**\n * Are the vectors equal within SNAP_PRECISION?\n * @param {THREE.Vector3} v1 - vector\n * @param {THREE.Vector3} v2 - vector\n * @returns {boolean} - true when they are equal\n * @private\n */\nfunction isEqualVectorsWithPrecision(v1, v2) {\n    return Math.abs(v1.x - v2.x) <= SNAP_PRECISION\n        && Math.abs(v1.y - v2.y) <= SNAP_PRECISION\n        && Math.abs(v1.z - v2.z) <= SNAP_PRECISION;\n}\n\n/**\n * Are the vectors inverse of each other within SNAP_PRECISION?\n * @param {THREE.Vector3} v1 - vector\n * @param {THREE.Vector3} v2 - vector\n * @returns {boolean} - true when they are inverse of each other\n * @private\n */\nfunction isInverseVectorsWithPrecision(v1, v2) {\n    return Math.abs(v1.x + v2.x) <= SNAP_PRECISION\n        && Math.abs(v1.y + v2.y) <= SNAP_PRECISION\n        && Math.abs(v1.z + v2.z) <= SNAP_PRECISION;\n}\n\n/**\n * @param {THREE.Vector3} point - Point \n * @param {THREE.Vector3} lineStart - Start of the line\n * @param {THREE.Vector3} lineEnd - End of the line\n * @returns {number} - distance from point to the line\n * @private\n */\nfunction distancePointToLine(point, lineStart, lineEnd) {\n\n    if (lineStart.equals(lineEnd)) { // Degenerate line\n        return point.distanceTo(lineStart);\n    }\n\n    var X0 = new THREE.Vector3();\n    var X1 = new THREE.Vector3();\n    var distance;\n    var param;\n\n    X0.subVectors(lineStart, point);\n    X1.subVectors(lineEnd, lineStart);\n    param = X0.dot(X1);\n    X0.subVectors(lineEnd, lineStart);\n    param = -param / X0.dot(X0);\n\n    if (param < 0) {\n        distance = point.distanceTo(lineStart);\n    } else if (param > 1) {\n        distance = point.distanceTo(lineEnd);\n    } else {\n        X0.subVectors(point, lineStart);\n        X1.subVectors(point, lineEnd);\n        X0.cross(X1);\n        X1.subVectors(lineEnd, lineStart);\n\n        distance = Math.sqrt(X0.dot(X0)) / Math.sqrt(X1.dot(X1));\n    }\n\n    return distance;\n}\n\nconst SnapCandidateType = {\n    Unknown:       0,\n    Line:          1,\n    CircularArc:   2,\n    EllipticalArc: 3\n};\n\n// A SnapCandidate references a single segment (line or arc) that we could snap to.\nclass SnapCandidate {\n    constructor(viewportId) {\n\n        this.type = SnapCandidateType.Unknown;\n        this.viewportId = viewportId;\n\n        // 2d distance between original (unsnapped) position and the geometry of this candidate.\n        this.distance = 0;\n\n        // {Vector2} Start/Endpoint - only for line segments\n        this.lineStart = null;\n        this.lineEnd   = null;\n\n        // Fixed radius - only for CircularArcs\n        this.radius = 0;\n        \n        // Separate radii - only for ellipse arcs\n        this.radiusX = 0; // = major radius - by convention\n        this.radiusY = 0;\n        \n        // Center point as Vector2 (for arcs)\n        this.center = null;\n\n        // Start/end angle for arcs: Ccw angle in radians. Angle 0 corresponds to direction x+.\n        this.startAngle = 0;\n        this.endAngle   = 0; \n    }\n\n    fromLine(p1, p2) {\n        this.type = SnapCandidateType.Line;\n        this.lineStart = p1.clone();\n        this.lineEnd   = p2.clone();\n        return this;\n    }\n\n    fromCircularArc(center, radius, start, end) {\n        this.type   = SnapCandidateType.CircularArc;\n        this.center = center.clone();\n        this.radius = radius;\n        this.start  = start;\n        this.end    = end;\n        return this;\n    }\n\n    fromEllipticalArc(center, radiusX, radiusY, start, end) {\n        this.type = SnapCandidateType.EllipticalArc;\n        this.center = center.clone();\n        this.radiusX = radiusX;\n        this.radiusY = radiusY;\n        this.start = start;\n        this.end = end;\n        return this;\n    }\n\n    isLine()          { return this.type === SnapCandidateType.Line; }\n    isCircularArc()   { return this.type === SnapCandidateType.CirularArc; }\n    isEllipticalArc() { return this.type === SnapCandidateType.EllipticalArc; }\n\n    // Checks if the snapGeometry of this candidate intersects with another one.\n    //  @param {SnapCandidate} other\n    //  @param {Vector2} [optionalTarget]\n    //  @returns {THREE.Vector2|null} Returns intersection point if there is one.\n    getIntersection(other, optionalTarget) {\n\n        if (this.isLine() && other.isLine()) {\n            // Note: We do the intersections on the whole line - not just the intersections.\n            // Reason is:\n            //  a) Otherwise, it would not snap if you are slightly outline of one line segment\n            //  b) By definition, we get only very close segment candidates anyway\n            return intersectLines(this.lineStart, this.lineEnd, other.lineStart, other.lineEnd, false, optionalTarget);\n        }\n        \n        // TODO: Currently, we only support snapping to line-line intersections\n    }\n}\n\n// Checks if we can snap to an intersection of two close segments (each can be a line or arcs).\n//  @param {SnapCandidate[]} candidates     - Snap candidate geometries collected in GeometryCallback. Assumed to be within snapRadius.\n//  @param {TREE.Vector3}    intersectPoint - Unsnapped original position\n//  @param {number}          snapRadius\n//  @returns {Object|null} If an intersection snap is found, the result contains:\n//                    {\n//                        viewportId  // number\n//                        snapPoint   // (THREE.Vector3)\n//                    }\nconst findIntersectionSnap = (candidates, intersectPoint, snapRadius) => {\n\n    // Sort snapping candidates by increasing distance\n    // Strictly speaking, we just need the best two ones. But the number of candidates within the snapping\n    // distance is generally small anyway - and working with a sorted array is more flexible to incrementally\n    // make the snapping smarter later.\n    const byDistance = (ca, cb) => ca.distance - cb.distance;\n    candidates.sort(byDistance);\n    \n    // Stop here if we don't have enough candidates for an intersection\n    if (candidates.length < 2) {\n        return null;\n    }\n\n    // Init result object\n    const result = {\n        // Just use the one of the first candidate. There is no unique viewportId when using an intersection.\n        viewportId: candidates[0].viewportId,\n\n        // Snapping happens in 2d - so we set z in advance and just keep the original value.\n        // Note: Snapper generally needs some revision if we use it for planes that are not perpendicular to the viewing direction.\n        snapPoint:  new THREE.Vector3(0, 0, intersectPoint.z)\n    };\n    \n    // Check for any candidate that intersects with the closest one we found\n    const first = candidates[0];\n    for (let i=1; i<candidates.length; i++) {\n        const second = candidates[i];\n\n        // Do intersection test. If found, write it to result.snapPoint\n        const found = first.getIntersection(second, result.snapPoint);\n        if (!found) {\n            continue;\n        }\n\n        // We found an intersection. Although we assume all candidates to be within\n        // snap radius already, the intersection may still be somewhere else.\n        // => Check if intersection is still within the snapRadius.\n        const dist = THREE.Vector2.prototype.distanceTo.call(result.snapPoint, intersectPoint);\n        if (dist < snapRadius) {\n            // We found a valid intersection snap\n            return result;\n        }\n    }\n    return null;\n};\n\n\n/**\n * A tool that lets users attach pointer events to vertices and edges. It supports 2D and 3D models.\n *\n * @param {Viewer3D} viewer - Viewer instance\n * @param {object} options - Configurations for the extension\n * @memberof Autodesk.Viewing.Extensions.Snapping\n * @alias Autodesk.Viewing.Extensions.Snapping.Snapper\n * @class\n */\nexport function Snapper(viewer, options) {\n\n    var _snapResult = new SnapResult();\n\n    var _viewer = viewer;\n    this.setGlobalManager(viewer.globalManager);\n\n    var _options = options || {};\n    var _names;\n\n    if (_options.markupMode) {\n        _names = [\"snapper-markup\"];\n    } else if (_options.toolName) {\n        // Allow tools to use their own snapper\n        _names = [_options.toolName];\n    } else {\n        _names = [\"snapper\"];\n    }\n\n    var _priority = 60;\n\n    var _active = false;\n\n    var _distanceToEdge = Number.MAX_VALUE;\n    var _distanceToVertex = null;\n\n    var _isDragging = false;\n    var _isPressing = false;\n    var _isSnapped = false;\n\n    var _forcedVpId = null; // the viewport index of the first selection for 2D\n\n    var _snapToPixel = false;\n\n    var _snapFilter = null; // Optional snapping filter, based on snapResult. (snapResult) => boolean.\n\n    this.indicator = new SnapperIndicator(viewer, this);\n\n    this.markupMode = _options.markupMode;\n    this.renderSnappedGeometry = _options.renderSnappedGeometry;\n    this.renderSnappedTopology = _options.renderSnappedTopology;\n\n    //Notice: The pixelSize should correspond to the amount of pixels per line in idAtPixels, the shape of\n    //detection area is square in idAtPixels, but circle in snapper, should make their areas match roughly.\n    this.detectRadiusInPixels = av.isMobileDevice() ? 50 : 10;\n\n    /**\n     * @returns {boolean} true when the tool is active\n     *\n     * @alias Autodesk.Viewing.Extensions.Snapping.Snapper#isActive\n     */\n    this.isActive = function() {\n        return _active;\n    };\n\n    this.getNames = function() {\n        return _names;\n    };\n\n    this.getName = function() {\n        return _names[0];\n    };\n\n    this.getPriority = function() {\n        return _priority;\n    };\n\n    /**\n     * Starts intercepting pointer events.\n     * Invoked automatically by the {@link ToolController}.\n     *\n     * @alias Autodesk.Viewing.Extensions.Snapping.Snapper#activate\n     */\n    this.activate = function() {\n        _active = true;\n\n        if (!this.indicator) {\n            this.indicator = new SnapperIndicator(viewer, this);\n        }\n    };\n\n\n    /**\n     * Stops intercepting pointer events.\n     * Invoked automatically by the {@link ToolController}.\n     *\n     * @alias Autodesk.Viewing.Extensions.Snapping.Snapper#deactivate\n     */\n    this.deactivate = function() {\n        _active = false;\n\n        if (this.indicator) {\n            this.indicator.destroy();\n            this.indicator = null;    \n        }        \n    };\n\n    this.copyResults = function(destiny) {\n        _snapResult.copyTo(destiny);\n    };\n\n    this.getEdge = function() {\n        return _snapResult.geomEdge;\n    };\n\n    this.getVertex = function() {\n        return _snapResult.geomVertex;\n    };\n\n    this.getGeometry = function() {\n        return _snapResult.getGeometry();\n    };\n\n    this.getGeometryType = function() {\n        return _snapResult.geomType;\n    };\n\n    this.getIntersectPoint = function() {\n        return _snapResult.intersectPoint;\n    };\n\n\n    /**\n     * @returns {SnapResult} The snapping status of the last pointer event performed.\n     *\n     * @alias Autodesk.Viewing.Extensions.Snapping.Snapper#getSnapResult\n     */\n    this.getSnapResult = function() {\n        return _snapResult;\n    };\n\n    /**\n     * Checks whether the tool's last update resulted on a snap.\n     *\n     * @returns {boolean} true when the last pointer event got snapped.\n     *\n     * @alias Autodesk.Viewing.Extensions.Snapping.Snapper#isSnapped\n     */\n    this.isSnapped = function() {\n        return _isSnapped;\n    };\n\n    this.clearSnapped = function() {\n        _snapResult.clear();\n        _isSnapped = false;\n    };\n\n    this.setViewportId = function(vpId) {\n        _forcedVpId = vpId;\n    };\n\n    this.setSnapToPixel = function(enable) {\n        _snapToPixel = enable;\n    };\n\n    this.getSnapToPixel = function() {\n        return _snapToPixel;\n    };\n\n    this.setSnapToArc = function(enable) {\n        _snapResult.snapToArc = enable;\n    };\n\n    this.getSnapToArc = function() {\n        return _snapResult.snapToArc;\n    };\n    \n    this.setArc = function(isArc) {\n        _snapResult.isArc = isArc;\n    };\n\n    this.getArc = function() {\n        return _snapResult.isArc;\n    };\n\n    this.setSnapFilter = function (filter) {\n        _snapFilter = filter;\n    };\n\n    /**\n     * 3D Snapping\n     *\n     * @param result -Result of Hit Test.\n     */\n    this.snapping3D = function(result) {\n\n        _snapResult.snapNode = result.dbId;\n        _snapResult.intersectPoint = result.intersectPoint;\n        _snapResult.modelId = result.model ? result.model.id : null;\n\n        // Avoid crash if the hit test does not belong to a model. This may happen, if a 3D overlay was hit (see Viewer3DImpl.rayIntersect).\n        if (!result.model) {\n            return;\n        }\n\n        var face = result.face;\n        var fragIds;\n\n        if (!result.fragId || result.fragId.length === undefined) {\n            fragIds = [result.fragId];\n        } else {\n            fragIds = result.fragId;\n        }\n\n        // This is for Fusion model with topology data\n        _snapResult.hasTopology = result.model.hasTopology();\n        if (_snapResult.hasTopology) {\n            this.snapping3DwithTopology(face, fragIds, result.model);\n        } else {\n           this.snapping3DtoMesh(face, fragIds, result.model);\n        }\n    };\n\n    /**\n     * Snapping order is: 1st vertices, 2nd edges, 3rd and final faces.\n     *\n     * @param face\n     * @param fragIds\n     * @param model\n     * @private\n     */\n    this.snapping3DwithTopology = function(face, fragIds, model) {\n\n        // Because edge topology data may be in other fragments with same dbId, need to iterate all of them.\n        if (_snapResult.snapNode) {\n            fragIds = [];\n\n            model.getData().instanceTree.enumNodeFragments(_snapResult.snapNode, function(fragId) {\n                fragIds.push(fragId);\n            }, true);\n        }\n\n        _snapResult.geomFace = _snapResult.geomEdge = _snapResult.geomVertex = null;\n        _distanceToEdge = Number.MAX_VALUE;\n\n        for (var fi = 0; fi < fragIds.length; ++fi) {\n\n            var fragId = fragIds[fi];\n            var mesh = _viewer.impl.getRenderProxy(model, fragId);\n            var geometry = mesh.geometry;\n\n            var topoIndex = model.getTopoIndex(fragId);\n            var topology = model.getTopology(topoIndex);\n            var facesTopology = topology.faces;\n            var edgesTopology = topology.edges;\n\n            if (!_snapResult.geomFace) {\n                _snapResult.geomFace = this.faceSnappingWithTopology(face, geometry, facesTopology, mesh);\n\n                if (_snapResult.geomFace) {\n                    _snapResult.geomFace.fragId = fragId;\n                }\n\n                var normalMatrix = new THREE.Matrix3().getNormalMatrix(mesh.matrixWorld);\n                _snapResult.faceNormal = face.normal.applyMatrix3(normalMatrix).normalize();\n            }\n\n            // Need to iterate all frags with same dbId, because when meshes are attached with each other, \n            // edge-topology data will only be on one mesh.\n            this.edgeSnappingWithTopology(_snapResult.intersectPoint, geometry, edgesTopology, mesh);\n\n        }\n\n        _snapResult.geomVertex = this.vertexSnappingWithTopology(_snapResult.geomEdge, _snapResult.intersectPoint);\n\n        if (_snapResult.geomFace) {\n\n            // Determine which one should be drawn: face , edge or vertex\n            _snapResult.radius = this.setDetectRadius(_snapResult.intersectPoint);\n\n            if ((_options.forceSnapVertices || _distanceToVertex < _snapResult.radius) && _snapResult.geomVertex) {\n                _snapResult.geomType = SnapType.SNAP_VERTEX;\n            }\n            else if ((_options.forceSnapEdges || _distanceToEdge < _snapResult.radius) && _snapResult.geomEdge) {\n\n                var center = this.edgeIsCircle(_snapResult.geomEdge);\n                if (center) {\n                    _snapResult.circularArcCenter = center;\n                    _snapResult.circularArcRadius = center.distanceTo(_snapResult.geomEdge.vertices[0]);\n                    _snapResult.geomEdge.center = _snapResult.circularArcCenter;\n                    _snapResult.geomEdge.radius = _snapResult.circularArcRadius;\n                    _snapResult.geomType = SnapType.SNAP_CIRCULARARC;\n                }\n                else if (this.edgeIsCurved(_snapResult.geomEdge)) {\n                    _snapResult.geomType = SnapType.SNAP_CURVEDEDGE;\n                }\n                else {\n                    _snapResult.geomType = SnapType.SNAP_EDGE;\n                }\n\n            }\n            else {\n\n                if (this.faceIsCurved(_snapResult.geomFace)) {\n                    _snapResult.geomType = SnapType.SNAP_CURVEDFACE;\n                }\n                else {\n                    _snapResult.geomType = SnapType.SNAP_FACE;\n                }\n\n            }\n            \n            _isSnapped = true;\n        }\n    };\n\n    this.snapping3DtoMesh = function(face, fragIds, model) {\n         for (var fi = 0; fi < fragIds.length; ++fi) {\n\n            var fragId = fragIds[fi];\n            var mesh = _viewer.impl.getRenderProxy(model, fragId);\n            var geometry = mesh.geometry;\n\n            // Handle 3D line geometry\n            const isLine = mesh.isLine || mesh.isWideLine;\n            if (isLine && face) {\n\n                // For line meshes, face is a line {a, b} instead of a Face3 instance (see lineRayCast(..) in VBIntersector.js,\n                // where a, b are vertex indices into the line mesh vertex array.\n                //\n                // Note: Unlike edge intersection for faces, we just use the line segment itself and don't search for topology\n                //       of connected line segments to identify polylines as one item. If we need this, we have to add the corresponding code first.\n                _snapResult.geomEdge = this.extractLineGeometry(face, geometry);\n                _snapResult.geomEdge.applyMatrix(mesh.matrixWorld);\n\n                _snapResult.geomVertex = this.vertexSnapping(_snapResult.geomEdge, _snapResult.intersectPoint);\n\n                _snapResult.radius = this.setDetectRadius(_snapResult.intersectPoint);\n\n                // Determine which one should be drawn: edge or vertex\n                if ((_options.forceSnapVertices || (_distanceToVertex < _snapResult.radius))) {\n                    _snapResult.geomType = SnapType.SNAP_VERTEX;\n                }\n                else {\n                    // Note: Since we got the edge as hit result, we can already assume the intersection to be close to the line.\n                    _snapResult.geomType = SnapType.SNAP_EDGE;\n                }\n\n                _isSnapped = true;\n                break;\n            }\n\n            // Note that face may also be a line {a, b} (see lineRayCast(..) in VBIntersector.js\n            if (face instanceof THREE.Face3) {\n                _snapResult.geomFace = this.faceSnapping(face, geometry);\n            }\n\n            if (!_snapResult.geomFace)\n                continue;\n\n            _snapResult.geomFace.applyMatrix(mesh.matrixWorld);\n            _snapResult.geomEdge = this.edgeSnapping(_snapResult.geomFace, _snapResult.intersectPoint);\n            _snapResult.geomVertex = this.vertexSnapping(_snapResult.geomEdge, _snapResult.intersectPoint);\n\n            var normalMatrix = new THREE.Matrix3().getNormalMatrix(mesh.matrixWorld);\n            _snapResult.faceNormal = face.normal.applyMatrix3(normalMatrix).normalize();\n\n            _snapResult.radius = this.setDetectRadius(_snapResult.intersectPoint);\n\n            // Determine which one should be drawn: face, edge or vertex\n            if ((_options.forceSnapVertices || (_distanceToVertex < _snapResult.radius))) {\n                _snapResult.geomType = SnapType.SNAP_VERTEX;\n            }\n            else if (_options.forceSnapEdges || (_distanceToEdge < _snapResult.radius)) {\n                _snapResult.geomType = SnapType.SNAP_EDGE;\n            }\n            else {\n                _snapResult.geomType = SnapType.SNAP_FACE;\n            }\n\n            _isSnapped = true;\n            break;\n        }\n    };\n\n    this.faceSnappingWithTopology = function(face, geometry, facesTopology, mesh) {\n\n        var vA = new THREE.Vector3();\n        var vB = new THREE.Vector3();\n        var vC = new THREE.Vector3();\n\n        var geom = new THREE.Geometry();\n\n        var attributes = geometry.attributes;\n\n        if (attributes.index !== undefined) {\n\n            var positions = geometry.vb ? geometry.vb : attributes.position.array;\n            var stride = geometry.vb ? geometry.vbstride : 3;\n\n            // Find the index of face topology list which includes the intersect face(triangle)\n            for (var i = 0; i < facesTopology.length; i++) {\n\n                var indexList = facesTopology[i].indexList;\n                var faceId = facesTopology[i].id;\n                let j = 0;\n                for (; j < indexList.length; j += 3) {\n\n                    if (face.a === indexList[j]) {\n                        if ((face.b === indexList[j + 1] && face.c === indexList[j + 2]) || (face.b === indexList[j + 2] && face.c === indexList[j + 1])) {\n                            break;\n                        }\n                    }\n                    else if (face.a === indexList[j + 1]) {\n                        if ((face.b === indexList[j] && face.c === indexList[j + 2]) || (face.b === indexList[j + 2] && face.c === indexList[j])) {\n                            break;\n                        }\n                    }\n                    else if (face.a === indexList[j + 2]) {\n                        if ((face.b === indexList[j] && face.c === indexList[j + 1]) || (face.b === indexList[j + 1] && face.c === indexList[j])) {\n                            break;\n                        }\n                    }\n                }\n\n                if (j < indexList.length) {\n                    break;\n                }\n            }\n\n            if (i < facesTopology.length) {\n\n                for (let j = 0; j < indexList.length; j += 3) {\n                    vA.set(\n                        positions[ indexList[j] * stride ],\n                        positions[ indexList[j] * stride + 1 ],\n                        positions[ indexList[j] * stride + 2 ]\n                    );\n                    vB.set(\n                        positions[ indexList[j + 1] * stride ],\n                        positions[ indexList[j + 1] * stride + 1 ],\n                        positions[ indexList[j + 1] * stride + 2 ]\n                    );\n                    vC.set(\n                        positions[ indexList[j + 2] * stride ],\n                        positions[ indexList[j + 2] * stride + 1 ],\n                        positions[ indexList[j + 2] * stride + 2 ]\n                    );\n\n                    var vIndex = geom.vertices.length;\n\n                    geom.vertices.push(vA.clone());\n                    geom.vertices.push(vB.clone());\n                    geom.vertices.push(vC.clone());\n\n                    geom.faces.push(new THREE.Face3(vIndex, vIndex + 1, vIndex + 2));\n                }\n            }\n        }\n\n        //console.log(face);\n\n        if (geom.vertices.length > 0) {\n\n            geom.faceId = faceId;\n            geom.applyMatrix(mesh.matrixWorld);\n            return geom;\n        }\n        else {\n\n            return null;\n        }\n\n    };\n\n    /**\n     * Find the closest face next to the cast ray\n     *\n     * @param {THREE.Face3} face - the intersect triangle of Hit Test.\n     * @param geometry - the geometry of mesh\n     *\n     * @private\n     */\n    this.faceSnapping = function(face, geometry) {\n\n        var vA = new THREE.Vector3();\n        var vB = new THREE.Vector3();\n        var vC = new THREE.Vector3();\n\n        var geom = new THREE.Geometry();  //Geometry which includes all the triangles on the same plane.\n\n\n\n        var attributes = geometry.attributes;\n\n        var indices = attributes.index && (attributes.index.array || geometry.ib);\n        var positions = geometry.vb ? geometry.vb : attributes.position.array;\n        var stride = geometry.vb ? geometry.vbstride : 3;\n        var offsets = geometry.offsets;\n\n        if ( !offsets || offsets.length === 0) {\n\n            offsets = [{start: 0, count: indices ? indices.length : positions.length, index: 0}];\n\n        }\n\n        for (var oi = 0; oi < offsets.length; ++oi) {\n\n            var start = offsets[oi].start;\n            var count = offsets[oi].count;\n            var index = offsets[oi].index;\n\n            for (var i = start; i < start + count; i += 3) {\n\n                var a = index + (indices ? indices[i] : i);\n                var b = index + (indices ? indices[i + 1] : i + 1);\n                var c = index + (indices ? indices[i + 2] : i + 2);\n\n                vA.set(\n                    positions[a * stride],\n                    positions[a * stride + 1],\n                    positions[a * stride + 2]\n                );\n                vB.set(\n                    positions[b * stride],\n                    positions[b * stride + 1],\n                    positions[b * stride + 2]\n                );\n                vC.set(\n                    positions[c * stride],\n                    positions[c * stride + 1],\n                    positions[c * stride + 2]\n                );\n\n                var faceNormal = THREE.Triangle.normal(vA, vB, vC);\n\n                var va = new THREE.Vector3();\n                va.set(\n                    positions[ face.a * stride ],\n                    positions[ face.a * stride + 1 ],\n                    positions[ face.a * stride + 2 ]\n                );\n\n                if (isEqualVectorsWithPrecision(faceNormal, face.normal) && isEqualWithPrecision(faceNormal.dot(vA), face.normal.dot(va)))\n                {\n\n                    var vIndex = geom.vertices.length;\n\n                    geom.vertices.push(vA.clone());\n                    geom.vertices.push(vB.clone());\n                    geom.vertices.push(vC.clone());\n\n                    geom.faces.push(new THREE.Face3(vIndex, vIndex + 1, vIndex + 2));\n\n                }\n            }\n        }\n\n        if (geom.vertices.length > 0) {\n\n            return this.getTrianglesOnSameFace(geom, face, positions, stride);\n        }\n        else {\n\n            return null;\n        }\n    };\n\n    /**\n     * Find triangles on the same face with the triangle intersected with the cast ray\n     *\n     * @param geom -Geometry which includes all the triangles on the same plane.\n     * @param face -Triangle which intersects with the cast ray.\n     * @param positions -Positions of all vertices.\n     * @param stride -Stride for the interleaved buffer.\n     *\n     * @private\n     */\n    this.getTrianglesOnSameFace = function(geom, face, positions, stride) {\n\n        var isIncludeFace = false; // Check if the intersect face is in the mesh\n        var vertexIndices = geom.vertices.slice();\n\n        var va = new THREE.Vector3();\n        va.set(\n            positions[ face.a * stride ],\n            positions[ face.a * stride + 1 ],\n            positions[ face.a * stride + 2 ]\n        );\n        var vb = new THREE.Vector3();\n        vb.set(\n            positions[ face.b * stride ],\n            positions[ face.b * stride + 1 ],\n            positions[ face.b * stride + 2 ]\n        );\n        var vc = new THREE.Vector3();\n        vc.set(\n            positions[ face.c * stride ],\n            positions[ face.c * stride + 1 ],\n            positions[ face.c * stride + 2 ]\n        );\n        var intersectFace = new THREE.Geometry();\n        intersectFace.vertices.push(va);\n        intersectFace.vertices.push(vb);\n        intersectFace.vertices.push(vc);\n        intersectFace.faces.push(new THREE.Face3(0, 1, 2));\n\n        var vCount = [];\n\n        do {\n\n            vCount = [];\n\n            for (var j = 0; j < vertexIndices.length; j += 3) {\n\n                // The triangle which is intersected with the ray\n                if (vertexIndices[j].equals(va) && vertexIndices[j + 1].equals(vb) && vertexIndices[j + 2].equals(vc)) {\n\n                    isIncludeFace = true;\n                    vCount.push(j);\n                    continue;\n                }\n\n                for (var k = 0; k < intersectFace.vertices.length; k += 3) {\n\n                    // The triangles which are on the same face with the intersected triangle\n                    if (this.trianglesSharedEdge(vertexIndices[j], vertexIndices[j + 1], vertexIndices[j + 2],\n                            intersectFace.vertices[k], intersectFace.vertices[k + 1], intersectFace.vertices[k + 2])) {\n\n                        var vIndex = intersectFace.vertices.length;\n                        intersectFace.vertices.push(vertexIndices[j].clone());\n                        intersectFace.vertices.push(vertexIndices[j + 1].clone());\n                        intersectFace.vertices.push(vertexIndices[j + 2].clone());\n                        intersectFace.faces.push(new THREE.Face3(vIndex, vIndex + 1, vIndex + 2));\n\n                        vCount.push(j);\n                        break;\n                    }\n                }\n            }\n\n            for (var ci = vCount.length - 1; ci >= 0; --ci) {\n\n                vertexIndices.splice(vCount[ci], 3);\n\n            }\n\n        } while (vCount.length > 0);\n\n        if (isIncludeFace) {\n            return intersectFace;\n        }\n        else {\n            return null;\n        }\n\n    };\n\n    /**\n     * Check if the two triangle share edge, the inputs are their vertices\n     *\n     * @param a1\n     * @param a2\n     * @param a3\n     * @param b1\n     * @param b2\n     * @param b3\n     * @private\n     */\n    this.trianglesSharedEdge = function(a1, a2, a3, b1, b2, b3) {\n\n        var c1 = false;\n        var c2 = false;\n        var c3 = false;\n\n        if (a1.equals(b1) || a1.equals(b2) || a1.equals(b3)) {\n            c1 = true;\n        }\n        if (a2.equals(b1) || a2.equals(b2) || a2.equals(b3)) {\n            c2 = true;\n        }\n        if (a3.equals(b1) || a3.equals(b2) || a3.equals(b3)) {\n            c3 = true;\n        }\n\n        if (c1 & c2 || c1 & c3 || c2 & c3) {\n            return true;\n        }\n\n        return false;\n    };\n\n    this.edgeSnappingWithTopology = function(intersectPoint, geometry, edgesTopology, mesh) {\n\n        var edgeGeom = new THREE.Geometry();\n        var minDistTopoIndex;\n        var minDist = Number.MAX_VALUE;\n\n        var vA = new THREE.Vector3();\n        var vB = new THREE.Vector3();\n\n        var attributes = geometry.attributes;\n\n        if (attributes.index !== undefined && edgesTopology != undefined) {\n\n            var positions = geometry.vb ? geometry.vb : attributes.position.array;\n            var stride = geometry.vb ? geometry.vbstride : 3;\n\n            // Find the index of edge topology list which includes the nearest edge segment to the intersect point\n            for (var i = 0; i < edgesTopology.length; i++) {\n\n                var indexList = edgesTopology[i].indexList;\n                // In edges topology index list the type is LineStrip\n                for (var j = 0; j < indexList.length - 1; j++) {\n                    vA.set(\n                        positions[ indexList[j] * stride ],\n                        positions[ indexList[j] * stride + 1 ],\n                        positions[ indexList[j] * stride + 2 ]\n                    );\n                    vB.set(\n                        positions[ indexList[j + 1] * stride ],\n                        positions[ indexList[j + 1] * stride + 1 ],\n                        positions[ indexList[j + 1] * stride + 2 ]\n                    );\n\n                    vA.applyMatrix4(mesh.matrixWorld);\n                    vB.applyMatrix4(mesh.matrixWorld);\n\n                    var dist = distancePointToLine(intersectPoint, vA, vB);\n                    if (dist < minDist) {\n                        minDist = dist;\n                        minDistTopoIndex = i;\n                    }\n                }\n            }\n\n            if (minDistTopoIndex) {\n                indexList = edgesTopology[minDistTopoIndex].indexList;\n                for (var k = 0; k < indexList.length - 1; k++) {\n                    edgeGeom.vertices.push(new THREE.Vector3(positions[indexList[k] * stride], positions[indexList[k] * stride + 1], positions[indexList[k] * stride + 2]));\n                    // To make the line's type to LinePieces which is used by drawLine function\n                    edgeGeom.vertices.push(new THREE.Vector3(positions[indexList[k + 1] * stride], positions[indexList[k + 1] * stride + 1], positions[indexList[k + 1] * stride + 2]));\n                }\n            }\n        }\n\n        if (_distanceToEdge >= minDist && edgeGeom.vertices.length > 0) {\n\n            _distanceToEdge = minDist;\n            edgeGeom.applyMatrix(mesh.matrixWorld);\n            _snapResult.geomEdge = edgeGeom;\n        }\n    };\n\n    /**\n     * Get Edge geometry for the case that the hittest result contained a 3D lines. For this case, we have no Face3, so\n     * that faceSnapping and edgeSnapping don't work.\n     * \n     *  @param {Object}         edge     - {a, b} with vertex indices a,b of lineStart/lineEnd vertex\n     *  @param {GeometryBuffer} geometry\n     *  @returns {EdgeGeometry} Geometry with simple line\n     */\n    this.extractLineGeometry = function(edge, geometry) {\n\n        const va = new THREE.Vector3();\n        const vb = new THREE.Vector3();\n\n        const attributes = geometry.attributes;\n        const positions = geometry.vb ? geometry.vb : attributes.position.array;\n        const stride    = geometry.vb ? geometry.vbstride : 3;\n\n        va.set(\n            positions[edge.a * stride],\n            positions[edge.a * stride + 1],\n            positions[edge.a * stride + 2]\n        );\n        vb.set(\n            positions[edge.b * stride],\n            positions[edge.b * stride + 1],\n            positions[edge.b * stride + 2]\n        );\n        \n        const edgeGeom = new THREE.Geometry();\n        edgeGeom.vertices.push(va, vb);\n        return edgeGeom;\n    };\n\n    /**\n     * Find the closest edge next to the intersect point\n     *\n     * @param face -Face which is found by faceSnapping.\n     * @param intersectPoint -IntersectPoint between cast ray and face.\n     *\n     * @private\n     */\n    this.edgeSnapping = function(face, intersectPoint) {\n\n        var lineGeom = new THREE.Geometry();\n        var isEdge_12 = true;\n        var isEdge_13 = true;\n        var isEdge_23 = true;\n\n        for (var i = 0; i < face.vertices.length; i += 3) {\n\n            for (var j = 0; j < face.vertices.length; j += 3) {\n\n                if ( i !== j ) {\n                    // Check edge 12\n                    if ((face.vertices[i].equals(face.vertices[j]) || face.vertices[i].equals(face.vertices[j + 1])\n                        || face.vertices[i].equals(face.vertices[j + 2]))\n                        && (face.vertices[i + 1].equals(face.vertices[j]) || face.vertices[i + 1].equals(face.vertices[j + 1])\n                        || face.vertices[i + 1].equals(face.vertices[j + 2]))) {\n\n                        isEdge_12 = false;\n\n                    }\n                    // Check edge 13\n                    if ((face.vertices[i].equals(face.vertices[j]) || face.vertices[i].equals(face.vertices[j + 1])\n                        || face.vertices[i].equals(face.vertices[j + 2]))\n                        && (face.vertices[i + 2].equals(face.vertices[j]) || face.vertices[i + 2].equals(face.vertices[j + 1])\n                        || face.vertices[i + 2].equals(face.vertices[j + 2]))) {\n\n                        isEdge_13 = false;\n\n                    }\n                    // Check edge 23\n                    if ((face.vertices[i + 1].equals(face.vertices[j]) || face.vertices[i + 1].equals(face.vertices[j + 1])\n                        || face.vertices[i + 1].equals(face.vertices[j + 2]))\n                        && (face.vertices[i + 2].equals(face.vertices[j]) || face.vertices[i + 2].equals(face.vertices[j + 1])\n                        || face.vertices[i + 2].equals(face.vertices[j + 2]))) {\n\n                        isEdge_23 = false;\n\n                    }\n                }\n            }\n\n            if (isEdge_12) {\n\n                lineGeom.vertices.push(face.vertices[i].clone());\n                lineGeom.vertices.push(face.vertices[i + 1].clone());\n\n            }\n            if (isEdge_13) {\n\n                lineGeom.vertices.push(face.vertices[i].clone());\n                lineGeom.vertices.push(face.vertices[i + 2].clone());\n\n            }\n            if (isEdge_23) {\n\n                lineGeom.vertices.push(face.vertices[i + 1].clone());\n                lineGeom.vertices.push(face.vertices[i + 2].clone());\n\n            }\n\n            isEdge_12 = true;\n            isEdge_13 = true;\n            isEdge_23 = true;\n\n        }\n\n        //return lineGeom;\n\n        var edgeGeom = new THREE.Geometry();\n        var minDistIndex;\n        var minDist = Number.MAX_VALUE;\n\n        for (var k = 0; k < lineGeom.vertices.length; k += 2) {\n\n            var dist = distancePointToLine(intersectPoint, lineGeom.vertices[k], lineGeom.vertices[k + 1]);\n\n            if (dist < minDist) {\n                minDist = dist;\n                minDistIndex = k;\n            }\n\n        }\n\n        edgeGeom.vertices.push(lineGeom.vertices[ minDistIndex ].clone());\n        edgeGeom.vertices.push(lineGeom.vertices[ minDistIndex + 1 ].clone());\n\n        edgeGeom.vertices = this.getConnectedLineSegmentsOnSameLine(lineGeom, edgeGeom.vertices);\n\n        _distanceToEdge = minDist;\n\n        return edgeGeom;\n\n    };\n\n    this.getConnectedLineSegmentsOnSameLine = function(lineGeom, edgeVertices) {\n\n        var vertices = lineGeom.vertices.slice();\n        var va = edgeVertices[0];\n        var vb = edgeVertices[1];\n\n        var vCount = [];\n\n        do {\n\n            vCount = [];\n\n            for (var j = 0; j < vertices.length; j += 2) {\n\n                // The line which has min distance to intersection point\n                if (vertices[j].equals(va) && vertices[j + 1].equals(vb)) {\n\n                    continue;\n                }\n\n                for (var k = 0; k < edgeVertices.length; k += 2) {\n\n                    // The line segments which are connected on the same line\n                    if (vertices[j].equals(edgeVertices[k]) || vertices[j + 1].equals(edgeVertices[k]) ||\n                        vertices[j].equals(edgeVertices[k + 1]) || vertices[j + 1].equals(edgeVertices[k + 1])) {\n\n                        var V0 = new THREE.Vector3();\n                        var V1 = new THREE.Vector3();\n\n                        V0.subVectors(edgeVertices[k],  edgeVertices[k + 1]);\n                        V0.normalize();\n                        V1.subVectors(vertices[j],vertices[j + 1]);\n                        V1.normalize();\n\n                        //if (V0.equals(V1) || V0.equals(V1.negate())) {\n                        if (isEqualVectorsWithPrecision(V0, V1) || isInverseVectorsWithPrecision(V0, V1))\n                        {\n\n                            vCount.push(j);\n                            break;\n\n                        }\n                    }\n                }\n            }\n\n            for (var ci = vCount.length - 1; ci >= 0; --ci) {\n\n                edgeVertices.push(vertices[ vCount[ci] ]);\n                edgeVertices.push(vertices[ vCount[ci] + 1 ]);\n                vertices.splice(vCount[ci], 2);\n\n            }\n\n        } while (vCount.length > 0);\n\n        return edgeVertices;\n\n    };\n\n    this.vertexSnappingWithTopology = function(edge, intersectPoint) {\n\n        var minDist = Number.MAX_VALUE;\n        var point = new THREE.Vector3();\n\n        if (edge && edge.vertices.length > 1) {\n            var dist1 = intersectPoint.distanceTo(edge.vertices[0]);\n            var dist2 = intersectPoint.distanceTo(edge.vertices[edge.vertices.length - 1]);\n\n            if (dist1 <= dist2) {\n                minDist = dist1;\n                point = edge.vertices[0].clone();\n            }\n            else {\n                minDist = dist2;\n                point = edge.vertices[edge.vertices.length - 1].clone();\n            }\n        }\n\n        _distanceToVertex = minDist;\n\n        return point;\n    };\n\n    /**\n     * Find the closest vertex next to the intersect point\n     *\n     * @param edge -Edge which is found by edgeSnapping.\n     * @param intersectPoint -IntersectPoint between cast ray and face.\n     *\n     * @private\n     */\n    this.vertexSnapping = function(edge, intersectPoint) {\n\n        var minDist = Number.MAX_VALUE;\n        var point = new THREE.Vector3();\n\n        for (var i = 0; i < edge.vertices.length; ++i) {\n\n            var dist = intersectPoint.distanceTo(edge.vertices[i]);\n\n            if (dist < minDist - SNAP_PRECISION) {\n\n                minDist = dist;\n                point = edge.vertices[i].clone();\n\n            }\n        }\n\n        _distanceToVertex = minDist;\n\n        return point;\n    };\n\n    // This is only a workaround to detect if an edge is circle\n    this.edgeIsCircle = function(edge) {\n\n        var vertices = edge.vertices;\n\n        // Exclude squares and regular polygons\n        if (vertices.length < 8) {\n            return false;\n        }\n\n        if (vertices[0].equals(vertices[vertices.length - 1])) {\n\n            var center = new THREE.Vector3(0, 0, 0);\n            for (let i = 0; i < vertices.length; i += 2) {\n                center.add(vertices[i]);\n            }\n            center.divideScalar(vertices.length / 2.0);\n\n            var radius = center.distanceTo(vertices[0]);\n            for (let i = 0; i < vertices.length; i += 2) {\n                if (Math.abs(center.distanceTo(vertices[i]) - radius) <= SNAP_PRECISION) {\n                    continue;\n                }\n                else {\n                    return false;\n                }\n            }\n            return center;\n        }\n        else {\n            return false;\n        }\n    };\n\n    this.edgeIsCurved = function (edge) {\n\n        var vertices = edge.vertices;\n\n        if (vertices.length <= 2) {\n            return false;\n        }\n        else if (vertices[0].equals(vertices[vertices.length - 1])) {\n            return true;\n        }\n        else {\n            var V1 = new THREE.Vector3();\n            V1.subVectors(vertices[0], vertices[1]);\n\n            var V2 = new THREE.Vector3();\n            for (var i = 2; i < vertices.length; i += 2) {\n                V2.subVectors(vertices[i], vertices[i + 1]);\n                if (!isEqualVectorsWithPrecision(V1, V2)) {\n                    return true;\n                }\n            }\n\n            return false;\n        }\n    };\n\n    this.faceIsCurved = function (face) {\n\n        var vertices = face.vertices;\n        var faces = face.faces;\n\n        if (faces.length <= 1) {\n            return false;\n        }\n        else {\n            var fN1 = THREE.Triangle.normal(vertices[faces[0].a], vertices[faces[0].b], vertices[faces[0].c]);\n            var vA1 = vertices[faces[0].a];\n\n            for (var i = 1; i < faces.length; i++) {\n                var fN2 = THREE.Triangle.normal(vertices[faces[i].a], vertices[faces[i].b], vertices[faces[i].c]);\n                var vA2 = vertices[faces[i].a];\n\n                if (!isEqualVectorsWithPrecision(fN1, fN2) || !isEqualWithPrecision(fN1.dot(vA1), fN2.dot(vA2))) {\n                    return true;\n                }\n            }\n\n            return false;\n        }\n    };\n\n    this.angleVector2 = function(vector) {\n\n        if (vector.x > 0 && vector.y >= 0) {\n            return Math.atan(vector.y / vector.x);\n        }\n        else if (vector.x >= 0 && vector.y < 0) {\n            return Math.atan(vector.y / vector.x) + Math.PI * 2;\n        }\n        else if (vector.x < 0 && vector.y <= 0) {\n            return Math.atan(vector.y / vector.x) + Math.PI;\n        }\n        else if (vector.x <= 0 && vector.y > 0) {\n            return Math.atan(vector.y / vector.x) + Math.PI;\n        }\n        else{ // x = 0, y = 0\n            return null;\n        }\n    };\n\n    // Creates a THREE.Geometry that represents an approximation of a given elliptical arc in {z=0} plane.\n    // Points are obtained by by uniform sampling of a given elliptical arc.\n    //  @param {number} numPoints - The length number of points that the output geometry will contain. segments in which we subdivide the arc. Resulting point count is numSegments+1.\n    // See getEllipseArcPoint() for param details.\n    const createEllipticalArcGeometry = (cx, cy, rx, ry, startAngle, endAngle, numPoints) => {\n        const geometry = new THREE.Geometry();\n        for (let i=0; i<numPoints; i++) {\n            const p = new THREE.Vector3(0,0,0);\n            const t = i/(numPoints-1);\n            Autodesk.Extensions.CompGeom.getEllipseArcPoint(t, cx, cy, rx, ry, startAngle, endAngle, 0.0, p);\n            geometry.vertices.push(p);\n        }\n        return geometry;\n    };\n\n    /**\n     * @param {Viewer3D} viewer - Viewer instance\n     * @param snapper\n     * @param aDetectRadius\n     * @private\n     */\n    function GeometryCallback(viewer, snapper, aDetectRadius) {\n        this.viewer = viewer;\n        this.snapper = snapper;\n\n        this.lineGeom = new THREE.Geometry();\n        this.circularArc = null;\n        this.circularArcCenter;\n        this.circularArcRadius;\n        this.ellipticalArc = null;\n        this.ellipticalArcCenter;\n\n        this.minDist = Number.MAX_VALUE;\n\n        this.matrix = new THREE.Matrix4();\n\n        this.vpIdLine = null;\n        this.vpIdCircular = null;\n        this.vpIdElliptical = null;\n\n        this.detectRadius = aDetectRadius;\n\n        // Collects candidate segments that we can snap to.\n        // This is used to allow snapping to segment intersections.\n        this.snapCandidates = []; // {SnappingCandidate[]}\n    }\n\n    GeometryCallback.prototype.onLineSegment = function(x1, y1, x2, y2, vpId) {\n        var intersectPoint = this.snapper.getIntersectPoint();\n        var vertices = this.lineGeom.vertices;\n        var v1 = new THREE.Vector3(x1, y1, intersectPoint.z);\n        var v2 = new THREE.Vector3(x2, y2, intersectPoint.z);\n\n        // LMV-5515: Apply the supplied matrix to the line vector's\n        if (this.matrix) {\n            v1.applyMatrix4(this.matrix);\n            v2.applyMatrix4(this.matrix);\n        }\n\n        // Skip segments outside detectRadius\n        var dist = distancePointToLine(intersectPoint, v1, v2);\n        if (dist > this.detectRadius) {\n            return;\n        }\n\n        // Collect snap candidate\n        this.snapCandidates.push(new SnapCandidate(vpId, dist).fromLine(v1, v2));\n\n        // Track minDist and lineGeometry for best hit so far\n        if (dist < this.minDist) {\n\n            vertices.splice(0, 2, v1, v2);\n            this.minDist = dist;\n\n            this.vpIdLine = vpId;\n        }\n    };\n\n    GeometryCallback.prototype.onCircularArc = function(cx, cy, start, end, radius, vpId) {\n        var intersectPoint = this.snapper.getIntersectPoint();\n        var point = new THREE.Vector2(intersectPoint.x, intersectPoint.y);\n\n        var center = new THREE.Vector2(cx, cy);\n        point.sub(center);\n\n        // Compute closest point on arc\n        const pointOnArc = nearestPointOnCircularArc(intersectPoint, center, radius, start, end);\n        const dist       = pointOnArc.distanceTo(intersectPoint); // 2D distance\n\n        // Collect snap candidate\n        this.snapCandidates.push(new SnapCandidate(vpId, dist).fromCircularArc(center, radius, start, end));\n\n        // Skip arcs outside detectRadius\n        if (dist > this.detectRadius) {\n            return;\n        }\n\n        // TODO: get rid of the CircleGeometry stuff below, because we computed the snapPoint above already.\n        //       But this needs some refactoring, because the Geometry is passed around outside of snapper.\n\n        var angle = this.snapper.angleVector2(point);\n\n        let arc;\n        if (end > start && angle >= start && angle <= end) {\n            arc = new THREE.CircleGeometry(radius, 100, start, end - start);\n        }\n        else if (end < start && (angle >= start || angle <= end)) {\n            arc = new THREE.CircleGeometry(radius, 100, start, Math.PI * 2 - start + end);\n        }\n        else {\n            return;\n        }\n        arc.vertices.splice(0, 1);\n        arc.applyMatrix(new THREE.Matrix4().makeTranslation(cx, cy, intersectPoint.z));\n        this.circularArc = arc;\n        this.circularArcCenter = new THREE.Vector3(cx, cy, intersectPoint.z);\n        this.circularArcRadius = radius;\n\n        this.snapPoint = new THREE.Vector3(pointOnArc.x, pointOnArc.y, intersectPoint.z);\n\n        this.vpIdCircular = vpId;\n    };\n\n    GeometryCallback.prototype.onEllipticalArc = function(cx, cy, start, end, major, minor, tilt, vpId) {\n        var intersectPoint = this.snapper.getIntersectPoint();\n        var point = new THREE.Vector2(intersectPoint.x, intersectPoint.y);\n\n        var major1 = major - this.detectRadius;\n        var minor1 = minor - this.detectRadius;\n        var major2 = major + this.detectRadius;\n        var minor2 = minor + this.detectRadius;\n\n        var equation1 = (point.x - cx) * (point.x - cx) / (major1 * major1) + (point.y - cy) * (point.y - cy) / (minor1 * minor1);\n        var equation2 = (point.x - cx) * (point.x - cx) / (major2 * major2) + (point.y - cy) * (point.y - cy) / (minor2 * minor2);\n\n        var center = new THREE.Vector2(cx, cy);\n        point.sub(center);\n        point.x *= minor;\n        point.y *= major;\n        var angle = this.snapper.angleVector2(point);\n\n        if (end > Math.PI * 2) {\n            end = Math.PI * 2;\n        }\n\n        if (equation1 >= 1 && equation2 <= 1) {\n\n            if ((end > start && angle >= start && angle <= end) || (end < start && (angle >= start || angle <= end))){\n                var arc = createEllipticalArcGeometry(cx, cy, major, minor, start, end, 50);\n                if (!isEqualWithPrecision(end - start, Math.PI * 2))\n                {\n                    arc.vertices.pop();\n                }\n                arc.applyMatrix(new THREE.Matrix4().makeTranslation(0, 0, intersectPoint.z));\n\n                // Compute distance between geometry and snapped point. \n                // We use the same way here as in getSnapResultPosition(). This will be replaced later by a more accurate solution.\n                const nearestPoint = MeasureCommon.nearestVertexInVertexToEdge(intersectPoint, arc);\n                const dist = THREE.Vector2.prototype.distanceTo.call(nearestPoint, intersectPoint); // only in x/y\n\n                // Collect snap candidate\n                const center = new THREE.Vector2(cx, cy);\n                this.snapCandidates.push(new SnapCandidate(vpId, dist).makeEllipticalArc(center, major, minor, start, end));\n\n                // Todo: Unlike for line-segments, arcs are currently collected by \"last one wins\" rule by the code for single-snapping. \n                //       We should consider the distance here as well.\n                this.ellipticalArc = arc;\n                this.ellipticalArcCenter = new THREE.Vector3(cx, cy, intersectPoint.z);\n\n                this.vpIdElliptical = vpId;\n            }\n        }\n    };\n\n    /**\n     * This method sets the matrix to identity if matrix is not supplied;\n     *\n     * @param {THREE.Matrix4} matrix - Matrix to set\n     */\n    GeometryCallback.prototype.setMatrix = function (matrix) {\n        this.matrix = matrix || new THREE.Matrix4();\n    };\n\n    /**\n     * Snap to a 2D model.\n     * \n     * @param {object}      hitResult - a result of a ray intersection.\n     * @param {object}      [options] - Options object.\n     * @param {Function}    [options.enumSegments] - Enumerates all segments within a given bbox in model-space.\n     *\n     */\n    this.snapping2D = function (hitResult, options = {}) {\n\n        if (!hitResult) {\n            return;\n        }\n\n        // hitResult is a result of a ray intersection. it may contain the following:\n        let {\n            dbId,\n            fragId,\n            intersectPoint,\n            model = _viewer.model\n        } = hitResult;\n\n        if (model.is3d()) {\n            return;\n        }\n        _snapResult.modelId = hitResult.model ? hitResult.model.id : null;\n        _snapResult.hasTopology = false;\n        _snapResult.intersectPoint = intersectPoint;\n        \n        let tr, scale = 1;\n\n        // The model that we are trying to snap is 2D, but the viewer is 3D. It means that we are in hypermodeling scenario!\n        // For that, we'll need to apply the inversed transform of the 2D model to the intersect point first, in order to get it in local model coords.\n        if (!_viewer.impl.is2d) {\n            tr = model.getModelToViewerTransform();\n            // If there's a transform, move point to original location in sheet (will be restored at the end)\n            if (tr) {\n                scale = tr.getMaxScaleOnAxis();\n                _snapResult.intersectPoint = intersectPoint.clone();\n                _snapResult.intersectPoint.applyMatrix4(model.getInverseModelToViewerTransform());\n            }\n        }\n\n        // Determine which one should be drawn: line, circular arc or elliptical arc\n        // Use the un-transformed point, but scale down the radius because we are comparing with the unscaled geometry\n        _snapResult.radius = this.setDetectRadius(intersectPoint) / scale;\n\n        // Geometry snapping is only possible if a fragment list is available to obtain geometry per fragment.\n        var supportsGeomSnapping = (model.getFragmentList()!=null);\n        if (!supportsGeomSnapping) {\n\n            // If no snapping is available, just accept the hitpoint as a vertex hit. This allows to measure\n            // distances between arbitrary points in rasters.\n            _isSnapped = true;\n            _snapResult.geomType = SnapType.SNAP_VERTEX;\n            _snapResult.geomVertex = intersectPoint; // Use the un-transformed point\n            tr &&_snapResult.intersectPoint.applyMatrix4(tr); // Restore to original location\n            return;\n        }\n\n\n        var gc = new GeometryCallback(_viewer, this, _snapResult.radius);\n\n        // Performs 2D snapping to segments based on an enumSegments() callback, which enumerates all segments\n        // within in a given bbox in model-space.\n        if (options.enumSegments) {\n            // enum all segments within the snapRadius around intersectPoint\n            const minx = _snapResult.intersectPoint.x - _snapResult.radius;\n            const miny = _snapResult.intersectPoint.y - _snapResult.radius;\n            const maxx = _snapResult.intersectPoint.x + _snapResult.radius;\n            const maxy = _snapResult.intersectPoint.y + _snapResult.radius;\n\n            options.enumSegments(minx, miny, maxx, maxy, gc);\n        } else {\n            // Regular snapping - snap to the 2D model's geometry.\n            var fragIds = fragId;\n\n            if (typeof fragIds === \"undefined\") {\n                // LMV-6082 Do not return out if the snap to pixel flag (free measure) is enabled.\n                if (!_snapToPixel) {\n                    return;\n                }\n                fragIds = [];\n            } else if (!Array.isArray(fragIds)) {\n                fragIds = [fragIds];\n            }\n\n            for (var fi = 0; fi < fragIds.length; ++fi) {\n                var mesh = _viewer.impl.getRenderProxy(model, fragIds[fi]);\n\n                if (mesh && mesh.geometry) {\n                    gc.setMatrix(mesh.matrix);\n                    var vbr = new VertexBufferReader(mesh.geometry);\n                    vbr.enumGeomsForObject(model.reverseMapDbIdFor2D(dbId), gc);\n                    // Set the matrix back to identity after processing a mesh\n                    gc.setMatrix();\n                }\n            }\n        }\n\n        // _snapResult.intersectPoint contains the possibly transformed point\n        this.finishSnapping2D(gc, _snapResult.intersectPoint);\n\n        // Snap the unsnapped point only if the snapping fails\n        if(!_isSnapped && _snapToPixel) {\n            _isSnapped = true;\n            _snapResult.geomType = SnapType.RASTER_PIXEL;\n            _snapResult.geomVertex = _snapResult.intersectPoint;\n        }\n\n        // Now apply the transform matrix on the results, so we'll get the results in their final transformed position.\n        if (tr) {\n            let results = [_snapResult.snapPoint, _snapResult.geomVertex, _snapResult.intersectPoint, _snapResult.circularArcCenter,\n                _snapResult.geomEdge?.vertices[0], _snapResult.geomEdge?.vertices[1]];\n            // Remove undefined and possibly shared vectors\n            results = [...new Set(results.filter(n => n))];\n            results.forEach(res => res.applyMatrix4(tr));\n            if (_snapResult.circularArcRadius) {\n                _snapResult.circularArcRadius *= scale;\n            }\n            _snapResult.radius *= scale;\n        }\n    };\n\n    // By default, snapper only considers model geometry that is written to ID buffer.\n    // This function performs the 2D snapping on a set of given 2D meshes instead. It works similar to snapping2D() but \n    // enumerates the given meshes instead of getting them from the fragment list.\n    //\n    //  @param {THREE.Vector3}                 intersectPoint - click position in world-coords\n    //  @param {function(dbId, layerId, vpId)} filter - Defines subset of primitives to be considered.\n    //  @param {THREE.Mesh[]}                  meshes - The triangulated 2D shapes to be checked for snapping\n    //  @param {number}                        [detectRadius] - Same coordinate system as the given geometry. Required if geometry is not in world-coords.\n\n    this.snapping2DOverlay = function(intersectPoint, meshes, filter, detectRadius) {\n        _snapResult.hasTopology = false;\n        _snapResult.intersectPoint = intersectPoint;\n        _snapResult.radius = detectRadius || this.setDetectRadius(intersectPoint);\n        \n        var gc = new GeometryCallback(_viewer, this, _snapResult.radius);\n             \n        for (var i=0; i<meshes.length; i++) {\n            var mesh = meshes[i];\n            var vbr = new VertexBufferReader(mesh.geometry);\n            vbr.enumGeoms(filter, gc);\n        }\n         \n        this.finishSnapping2D(gc, intersectPoint);\n    };\n\n    // Finish 2D snapping operation - assuming that all candidate geometry for snapping has been processed by the geometryCallback gc already.\n    this.finishSnapping2D = function(gc, intersectPoint) {\n\n        // When restricting to a single viewport, exclude candidates of all other viewports\n        if (_forcedVpId !== null) {\n            const isSameViewport = c => (c.viewportId === _forcedVpId);\n            gc.snapCandidates = gc.snapCandidates.filter(isSameViewport);\n        }\n\n        // Check if we can snap to an intersection of two close segments\n        const intersectSnap = findIntersectionSnap(gc.snapCandidates, intersectPoint, gc.detectRadius);\n        if (intersectSnap) {\n            _snapResult.viewportIndex2d = intersectSnap.viewportId;\n            _snapResult.snapPoint = intersectSnap.snapPoint;\n            _snapResult.geomType = SnapType.SNAP_INTERSECTION;\n            _snapResult.geomVertex = intersectSnap.snapPoint;\n            _isSnapped = true;\n            return;\n        }\n\n        if (gc.circularArc) {\n\n            _snapResult.viewportIndex2d = gc.vpIdCircular;\n\n            _snapResult.snapPoint = gc.snapPoint;\n\n            // Only snap the geometries which belong to the same viewport as the first selection\n            if (_forcedVpId !== null && _forcedVpId !== _snapResult.viewportIndex2d)\n                return;\n\n            if (intersectPoint.distanceTo(gc.circularArc.vertices[0]) < _snapResult.radius) {\n\n                _snapResult.geomVertex = gc.circularArc.vertices[0];\n                _snapResult.geomType = SnapType.SNAP_VERTEX;\n            }\n            else if (intersectPoint.distanceTo(gc.circularArc.vertices[gc.circularArc.vertices.length - 1]) < _snapResult.radius) {\n\n                _snapResult.geomVertex = gc.circularArc.vertices[gc.circularArc.vertices.length - 1];\n                _snapResult.geomType = SnapType.SNAP_VERTEX;\n            }\n            else {\n\n                this.lineStripToPieces(gc.circularArc);\n                _snapResult.geomEdge = gc.circularArc;\n                _snapResult.circularArcCenter = gc.circularArcCenter;\n                _snapResult.circularArcRadius = gc.circularArcRadius;\n                _snapResult.geomType = SnapType.SNAP_CIRCULARARC;\n            }\n\n            _isSnapped = true;\n\n\n        }\n        else if (gc.ellipticalArc) {\n\n            _snapResult.viewportIndex2d = gc.vpIdElliptical;\n\n            // Only snap the geometries which belong to the same viewport as the first selection\n            if (_forcedVpId !== null && _forcedVpId !== _snapResult.viewportIndex2d)\n                return;\n\n            if (intersectPoint.distanceTo(gc.ellipticalArc.vertices[0]) < _snapResult.radius) {\n\n                _snapResult.geomVertex = gc.ellipticalArc.vertices[0];\n                _snapResult.geomType = SnapType.SNAP_VERTEX;\n            }\n            else if (intersectPoint.distanceTo(gc.ellipticalArc.vertices[gc.ellipticalArc.vertices.length - 1]) < _snapResult.radius) {\n\n                _snapResult.geomVertex = gc.ellipticalArc.vertices[gc.ellipticalArc.vertices.length - 1];\n                _snapResult.geomType = SnapType.SNAP_VERTEX;\n            }\n            else {\n\n                this.lineStripToPieces(gc.ellipticalArc);\n                _snapResult.geomEdge = gc.ellipticalArc;\n                // Before we have measure design for elliptical arc, measure the center for now\n                _snapResult.circularArcCenter = gc.ellipticalArcCenter;\n                _snapResult.circularArcRadius = null;\n                _snapResult.geomType = SnapType.SNAP_CIRCULARARC;\n            }\n\n            _isSnapped = true;\n\n        }\n        else if (gc.lineGeom.vertices.length) {\n\n            _snapResult.viewportIndex2d = gc.vpIdLine;\n\n            // Only snap the geometries which belong to the same viewport as the first selection\n            if (_forcedVpId !== null && _forcedVpId !== _snapResult.viewportIndex2d)\n                return;\n\n            // Always expose edge segment - no matter whether we snap to the edge or one of its vertices.\n            // This allows us to combine it with other snap constraints later - as done by Edit2D.\n            _snapResult.geomEdge = gc.lineGeom;\n\n            if (this.markupMode) {  // Markup mode\n                var start = gc.lineGeom.vertices[0];\n                var end = gc.lineGeom.vertices[1];\n                var mid = new THREE.Vector3();\n                mid.addVectors(start, end);\n                mid.divideScalar(2);\n                var md = intersectPoint.distanceTo(mid);\n                var sd = intersectPoint.distanceTo(start);\n                var ed = intersectPoint.distanceTo(end);\n\n                // Store it for snapping to parallel/perpendicular of underlying vectors\n                _snapResult.geomEdge = gc.lineGeom;\n\n                if (md < _snapResult.radius) {\n                    _snapResult.geomVertex = mid;\n                    _snapResult.geomType = SnapType.SNAP_VERTEX;\n                }\n                else if (sd < _snapResult.radius) {\n                    _snapResult.geomVertex = start;\n                    _snapResult.geomType = SnapType.SNAP_VERTEX;\n                }\n                else if (ed < _snapResult.radius) {\n                    _snapResult.geomVertex = end;\n                    _snapResult.geomType = SnapType.SNAP_VERTEX;\n                }\n                else {\n                    _snapResult.geomType = SnapType.SNAP_EDGE;\n                }\n\n                // Circle center\n                if (gc.lineGeom.vertices[0].distanceTo(gc.lineGeom.vertices[1]) < EPSILON) {\n                    _snapResult.geomType = SnapType.SNAP_CIRCLE_CENTER;\n                }\n            }\n            else {  // Measure mode\n                if (intersectPoint.distanceTo(gc.lineGeom.vertices[0]) < _snapResult.radius) {\n\n                    if (gc.lineGeom.vertices[0].distanceTo(gc.lineGeom.vertices[1]) < EPSILON) {\n                        _snapResult.geomType = SnapType.SNAP_CIRCLE_CENTER;\n                    } else {\n                        _snapResult.geomType = SnapType.SNAP_VERTEX;\n                    }\n\n                    _snapResult.geomVertex = gc.lineGeom.vertices[0];\n                }\n                else if ((_options.forceSnapVertices || (intersectPoint.distanceTo(gc.lineGeom.vertices[1]) < _snapResult.radius))) {\n\n                    _snapResult.geomVertex = gc.lineGeom.vertices[1];\n                    _snapResult.geomType = SnapType.SNAP_VERTEX;\n                }\n                else {\n                    _snapResult.geomType = SnapType.SNAP_EDGE;\n                }\n            }\n\n            _isSnapped = true;\n        }\n    };\n\n    this.snappingRasterPixel = function(result) {\n        if (!result) {\n            return;\n        }\n        \n        var intersectPoint = result.intersectPoint;\n        _snapResult.intersectPoint = intersectPoint;\n        _snapResult.hasTopology = false;\n\n        // Determine which one should be drawn: line, circular arc or elliptical arc\n        _snapResult.radius = this.setDetectRadius(intersectPoint);\n        _snapResult.geomType = SnapType.RASTER_PIXEL;\n        _snapResult.geomVertex = intersectPoint;\n        _isSnapped = true;\n    };\n\n    this.snapMidpoint = function() {\n        _snapResult.isMidpoint = false;\n\n        // Snap midpoint for edge\n        if (_isSnapped) {\n            if (_snapResult.geomType === SnapType.SNAP_EDGE) {\n                var edge = _snapResult.geomEdge;\n                var p1 = edge.vertices[0];\n                var p2 = edge.vertices[1];\n\n                var midpoint = new THREE.Vector3((p1.x + p2.x) / 2, (p1.y + p2.y) / 2, (p1.z + p2.z) / 2);\n\n                if (_snapResult.intersectPoint.distanceTo(midpoint) < 2 * _snapResult.radius) {\n                    _snapResult.geomVertex = midpoint;\n                    _snapResult.geomType = SnapType.SNAP_MIDPOINT;\n                }\n            }\n        }\n    };\n\n    this.setPerpendicular = function(isPerpendicular) {\n        _snapResult.isPerpendicular = isPerpendicular;\n    };\n\n    this.lineStripToPieces = function(geom) {\n\n        var vertices = geom.vertices;\n        for (var i = vertices.length - 2; i > 0; i--) {\n            vertices.splice(i, 0, vertices[i]);\n        }\n    };\n\n    this.setDetectRadius = function(point) {\n\n        var navapi = _viewer.navigation;\n        var camera = navapi.getCamera();\n        var position = navapi.getPosition();\n\n        var p = point.clone();\n\n        var distance = camera.isPerspective ? p.sub(position).length()\n            : navapi.getEyeVector().length();\n\n        var fov = navapi.getVerticalFov();\n        var worldHeight = 2.0 * distance * Math.tan(THREE.Math.degToRad(fov * 0.5));\n\n        var viewport = navapi.getScreenViewport();\n        var _window = this.getWindow();\n        var devicePixelRatio = _window.devicePixelRatio || 1;\n        var radius = this.detectRadiusInPixels * worldHeight / (viewport.height * devicePixelRatio);\n\n        return radius;\n    };\n\n    this.handleButtonDown = function () {\n        _isDragging = true;\n        return false;\n    };\n\n    this.handleButtonUp = function () {\n        _isDragging = false;\n        return false;\n    };\n\n    this.handleMouseMove = function (event) {\n\n        if (_isDragging)\n            return false;\n\n        this.onMouseMove({ \n            x: event.canvasX, \n            y: event.canvasY \n        });\n\n        return false;\n    };\n\n    this.handleSingleTap = function(event) {\n\n        return this.handleMouseMove(event);\n    };\n\n    this.handlePressHold = function (event) {\n        \n        if (av.isMobileDevice()) {\n            switch( event.type )\n            {\n                case \"press\":\n                    _isPressing = true;\n                    this.onMouseMove({x: event.canvasX, y: event.canvasY});\n                    break;\n\n                case \"pressup\":\n                    this.onMouseMove({x: event.canvasX, y: event.canvasY});\n                    _isPressing = false;\n                    break;\n            }\n        }\n        return false;\n\n    };\n\n    this.handleGesture = function( event )\n    {   \n        if (av.isMobileDevice()) {\n            if (_isPressing) {\n                switch( event.type )\n                {\n                    case \"dragstart\":\n                        this.onMouseMove({x: event.canvasX, y: event.canvasY});\n                        break;\n\n                    case \"dragmove\":\n                        this.onMouseMove({x: event.canvasX, y: event.canvasY});\n                        break;\n\n                    case \"dragend\":\n                        this.onMouseMove({x: event.canvasX, y: event.canvasY});\n                        _isPressing = false;\n                        break;\n\n                    case \"pinchstart\":\n                        \n                        break;\n\n                    case \"pinchmove\":\n                        break;\n\n                    case \"pinchend\":\n                        break;\n                }\n            }\n        }\n\n        return false;\n    };\n\n    /**\n     * Handler to mouse move events, used to snap in markup edit mode.\n     *\n     * @param mousePosition\n     * @private\n     */\n    this.onMouseDown = function(mousePosition) {\n        return this.onMouseMove(mousePosition);\n    };\n\n    /**\n     * Handler to mouse move events, used to snap in markup edit mode.\n     *\n     * @param mousePosition\n     * @private\n     */\n    this.onMouseMove = function(mousePosition) {\n\n        this.clearSnapped();\n\n        var result = _viewer.impl.snappingHitTest(mousePosition.x, mousePosition.y, false);\n\n        if (!result && _snapToPixel) {\n            var vpVec = _viewer.impl.clientToViewport(mousePosition.x, mousePosition.y);\n            let point = _viewer.impl.intersectGroundViewport(vpVec);\n            result = { intersectPoint : point };\n        }\n\n        if (!result || !result.intersectPoint) \n            return false;\n\n        const isLeaflet = result.model?.isLeaflet() || (_viewer.impl.is2d && _viewer.model?.isLeaflet());\n        // 3D Snapping\n        if (result.face) {\n            this.snapping3D(result);\n        }\n        // 2D Snapping\n        else if ((result.dbId || result.dbId === 0) && !isLeaflet) {\n            this.snapping2D(result);\n        }\n        // Pixel Snapping\n        else {\n            const isPixelSnap = _snapToPixel || isLeaflet;\n            if (isPixelSnap) {\n                this.snappingRasterPixel(result);\n            }\n        }\n\n        this.snapMidpoint();\n\n        if (_snapFilter && !_snapFilter(_snapResult)) {\n            this.clearSnapped();\n            return false;\n        }\n\n        return true;\n    };\n}\n\nav.GlobalManagerMixin.call(Snapper.prototype);\n","\n// Collection of static math functions used for snapping implementation\n\n// Find closest point to p on a circular arc. \n//  @param {Vector2} center\n//  @param {number} radius\n//  @param {number} startAngle, endAngle - ccw angles in radians. 0 means direction x+\n//  @param {Vector2} [outPoint]\n//  @param {Vector2}\nexport const nearestPointOnCircularArc = (p, center, radius, startAngle, endAngle, outPoint) => {\n\n    outPoint = outPoint || new THREE.Vector2();\n\n    // get normalized direction from circle center to p.\n    // dir = (p-center).normalized()\n    const dir = outPoint.copy(p).sub(center).normalize();\n\n    // If the point is within the arc, we are done\n    const angle = Math.atan2(dir.y, dir.x);\n    const insideArc = Autodesk.Extensions.CompGeom.angleInsideArc(angle, startAngle, endAngle);\n    if (insideArc) {\n        // The ray from center towards p intersects the circle arc.\n        // So, we obtain the closest point by projecting p onto the circle.\n        //\n        // Since dir is the normalized direction from center to p, we obtain the circle projection by:\n        //  onCircleArc = center + dir * radius\n        return dir.multiplyScalar(radius).add(center);\n    }\n\n    // The closest point on the circle is not on the arc.\n    // Then the closest point must be one of the arc ends. Note that this conclusion\n    // can only be made for circles, but not for ellipses with different radii.\n    const pStart = Autodesk.Extensions.CompGeom.getEllipsePoint(startAngle, center.x, center.y, radius, radius);\n    const pEnd   = Autodesk.Extensions.CompGeom.getEllipsePoint(endAngle, center.x, center.y, radius, radius);\n\n    const d2Start = pStart.distanceToSquared(p);\n    const d2End   = pEnd.distanceToSquared(p);\n    const startIsCloser = d2Start <= d2End;\n\n    outPoint.copy(startIsCloser ? pStart : pEnd);\n    return outPoint;\n};\n\n// Compute intersection of two line segments\n// based on http://www.paulbourke.net/geometry/pointlineplane/\n//  @param {Vector2} p1, p2               - First line segment\n//  @param {Vector2} p3, p4               - Second line segment\n//  @param {bool}    [checkInsideSegment] - If true, we reject line intersections outside the segment ranges\n//  @param {Vector2} [outPoint]           - Optional target vector\n//  @param {number}  [epsilon]            - Nearly-zero threshold used to determine \"nearly-parallel\" resp. \"nearly-zero-length line\"\n//  @param {Vector2|null}\nexport const intersectLines = (p1, p2, p3, p4, checkInsideSegment, outPoint, epsilon = 0.00001) => {\n    \n    const denom = (p4.y - p3.y) * (p2.x - p1.x) - (p4.x - p3.x) * (p2.y - p1.y);\n    \n    // Reject if lines are parallel or one of them has zero-length\n    if (Math.abs(denom) < epsilon) {\n        return null;\n    }\n\n    // ua denotes where to find the intersection point p along segment (p1, p2):\n    //   For ua = 0, we have p = p1\n    //   For ua = 1, we have p = p2\n    let ua = (p4.x - p3.x) * (p1.y - p3.y) - (p4.y - p3.y) * (p1.x - p3.x);\n    ua /= denom;\n    \n    // Apply segment check\n    if (checkInsideSegment) {\n\n        // ub denotes where to find the intersection point p along segment (p3, p4)\n        let ub = (p2.x - p1.x) * (p1.y - p3.y) - (p2.y - p1.y) * (p1.x - p3.x);\n        ub /= denom;\n\n        // Intersection is within the segments if ua and ub are both in [0,1]\n        if (ua < 0.0 || ua > 1.0 || \n            ub < 0.0 || ub > 1.0) {\n            return null;\n        }\n    }\n    \n    outPoint = outPoint || new THREE.Vector2();\n    \n    outPoint.x = p1.x + ua * (p2.x - p1.x);\n    outPoint.y = p1.y + ua * (p2.y - p1.y);\n    return outPoint;\n};\n\n\n\n","const MeasureCommon = Autodesk.Viewing.MeasureCommon;\nconst isEqualVectors = MeasureCommon.isEqualVectors;\nconst EPSILON = MeasureCommon.EPSILON;\nconst SnapType = MeasureCommon.SnapType;\n\n    var NO_OVERLAY = 0;\n    var FACE_OVERLAY = 1;\n    var EDGE_OVERLAY = 2;\n    var POINT_OVERLAY = 3;\n    \n    var GEOMETRIES_OVERLAY = 'MeasureTool-snapper-geometries';\n    var INDICATOR_OVERLAY = 'MeasureTool-snapper-indicator';\n\n    var _geometryLineWidth = 0.3;\n    var _indicatorLineWidth = 0.2;\n    var _indicatorSize = 1.2;\n    var _point = null;\n\n    var _indicatorColor = 0xff7700;\n    var _geometryColor = 0x00CC00;\n\n    // /** @constructor */\n    export function SnapperIndicator( viewer, snapper )\n    {\n        this.viewer = viewer;\n        this.snapper = snapper;\n        this.overlayType = NO_OVERLAY;\n        this.previewsIntersectPoint = null;\n\n        this.viewer.impl.createOverlayScene(GEOMETRIES_OVERLAY);\n        this.viewer.impl.createOverlayScene(INDICATOR_OVERLAY);\n\n        this.geometryMaterial = new THREE.MeshPhongMaterial({\n            color: _geometryColor,\n            ambient: _geometryColor,\n            opacity: 0.5,\n            transparent: true,\n            depthTest: false,\n            depthWrite: false,\n            side: THREE.DoubleSide\n        });\n\n        this.indicatorMaterial = new THREE.MeshBasicMaterial({\n            color: _indicatorColor,\n            ambient: _indicatorColor,\n            opacity: 1,\n            transparent: false,\n            depthTest: false,\n            depthWrite: false,\n            side: THREE.DoubleSide\n        });\n    }\n\n    SnapperIndicator.prototype.constructor = SnapperIndicator;\n    var proto = SnapperIndicator.prototype;\n\n\n    proto.render = function() {\n\n        var snapResult = this.snapper.getSnapResult();\n\n        if (!isEqualVectors(this.previewsIntersectPoint, snapResult.intersectPoint, EPSILON)) {\n            this.clearOverlay(GEOMETRIES_OVERLAY);\n        }\n        \n        this.clearOverlay(INDICATOR_OVERLAY);\n\n        if (snapResult.isEmpty())\n            return;\n\n        if (this.snapper.renderSnappedGeometry ||\n            (snapResult.hasTopology && this.snapper.renderSnappedTopology)) {\n            this.renderGeometry(snapResult);\n        }\n        this.renderIndicator(snapResult);\n\n        this.previewsIntersectPoint = snapResult.intersectPoint.clone();\n    };\n\n    proto.removeOverlay = function(overlayName) {\n        \n        this.viewer.impl.clearOverlay(overlayName);\n        this.viewer.impl.removeOverlayScene(overlayName);\n\n    };\n\n    proto.clearOverlay = function(overlayName) {\n        \n        this.removeOverlay(overlayName);\n        this.viewer.impl.createOverlayScene(overlayName);\n\n    };\n\n    proto.clearOverlays = function() {\n        \n        this.removeOverlay(GEOMETRIES_OVERLAY);\n        this.viewer.impl.createOverlayScene(GEOMETRIES_OVERLAY);\n\n        this.removeOverlay(INDICATOR_OVERLAY);\n        this.viewer.impl.createOverlayScene(INDICATOR_OVERLAY);\n\n        this.previewsIntersectPoint = null;\n\n    };\n\n    proto.addOverlay = function(overlayName, mesh) {\n\n        this.viewer.impl.addOverlay(overlayName, mesh);\n\n    };\n\n    /**\n     * Draw the planar face\n     * @param geom -Geometry which needs to be draw.\n     * @param mesh -Mesh which is loaded.\n     */\n    proto.drawFace = function(geom, material, overlayName) {\n\n        var snapperPlane = new THREE.Mesh(geom, material, true);\n\n        if (overlayName === GEOMETRIES_OVERLAY) {\n            this.overlayType = FACE_OVERLAY;\n        }\n\n        this.addOverlay(overlayName, snapperPlane);\n\n    };\n\n    proto.cylinderMesh = function(pointX, pointY, material, width) {\n\n        var direction = new THREE.Vector3().subVectors(pointY, pointX);\n        var orientation = new THREE.Matrix4();\n        orientation.lookAt(pointX, pointY, new THREE.Object3D().up);\n        orientation.multiply(new THREE.Matrix4().set(1, 0, 0, 0,\n            0, 0, 1, 0,\n            0, -direction.length(), 0, 0,\n            0, 0, 0, 1));\n\n        width = width || 0.5;\n        var cylinder = new THREE.CylinderGeometry(width, width, 1.0, 8, 1, true);\n        var edge = new THREE.Mesh(cylinder, material);\n        cylinder = null;\n\n        edge.applyMatrix(orientation);\n        edge.position.x = (pointY.x + pointX.x) / 2;\n        edge.position.y = (pointY.y + pointX.y) / 2;\n        edge.position.z = (pointY.z + pointX.z) / 2;\n        return edge;\n\n    };\n\n    proto.renderGeometry = function(snapResult) {\n\n        if (isEqualVectors(this.previewsIntersectPoint, snapResult.intersectPoint, EPSILON)){\n            return;\n        }\n\n        switch (snapResult.geomType) {\n            case SnapType.SNAP_VERTEX:\n                 SnapType.RASTER_PIXEL;\n                this.drawPoint(snapResult.geomVertex, this.geometryMaterial, GEOMETRIES_OVERLAY);\n                break;\n\n            case SnapType.SNAP_EDGE:\n            case SnapType.SNAP_CURVEDEDGE:\n            case SnapType.SNAP_CIRCULARARC:\n            case SnapType.SNAP_MIDPOINT:\n                this.drawLine(snapResult.geomEdge, this.geometryMaterial, _geometryLineWidth, GEOMETRIES_OVERLAY);\n                break;\n\n            case SnapType.SNAP_FACE:\n            case SnapType.SNAP_CURVEDFACE:\n                this.drawFace(snapResult.geomFace, this.geometryMaterial, GEOMETRIES_OVERLAY);\n                break;\n        }\n    };\n\n    /**\n     * Renders a square around the given snap result.\n     * Is used when youre snapping on a vertex, intersection, circular\n     * arc on a F2D sheet, and the curved face.\n     * @param {Autodesk.Viewing.MeasureCommon.SnapResult} snapResult\n     */\n    proto.renderVertexIndicator = function(snapResult) {\n\n        var pos = MeasureCommon.getSnapResultPosition(snapResult, this.viewer);\n        var scale = this.setScale(pos);\n        var length = _indicatorSize * scale;\n\n        var rightVec = this.viewer.navigation.getCameraRightVector().multiplyScalar(length);\n        var upVec = this.viewer.navigation.getCameraUpVector().multiplyScalar(length);\n\n        var geom = new THREE.Geometry();\n        var p = new THREE.Vector3();\n\n        // Upper line\n        p.addVectors(pos, rightVec);\n        p.addVectors(p, upVec);\n        geom.vertices[0] = p.clone();\n        p.subVectors(pos, rightVec);\n        p.addVectors(p, upVec);\n        geom.vertices[1] = p.clone();\n        this.drawLine(geom, this.indicatorMaterial, _indicatorLineWidth, INDICATOR_OVERLAY);\n\n        // Bottom line\n        p.addVectors(pos, rightVec);\n        p.subVectors(p, upVec);\n        geom.vertices[0] = p.clone();\n        p.subVectors(pos, rightVec);\n        p.subVectors(p, upVec);\n        geom.vertices[1] = p.clone();\n        this.drawLine(geom, this.indicatorMaterial, _indicatorLineWidth, INDICATOR_OVERLAY);\n\n        // Left line\n        p.subVectors(pos, rightVec);\n        p.subVectors(p, upVec);\n        geom.vertices[0] = p.clone();\n        p.subVectors(pos, rightVec);\n        p.addVectors(p, upVec);\n        geom.vertices[1] = p.clone();\n        this.drawLine(geom, this.indicatorMaterial, _indicatorLineWidth, INDICATOR_OVERLAY);\n\n        // Right line\n        p.addVectors(pos, rightVec);\n        p.subVectors(p, upVec);\n        geom.vertices[0] = p.clone();\n        p.addVectors(pos, rightVec);\n        p.addVectors(p, upVec);\n        geom.vertices[1] = p.clone();\n        this.drawLine(geom, this.indicatorMaterial, _indicatorLineWidth, INDICATOR_OVERLAY);\n\n    };\n\n    /**\n     * Renders a triangle around the given snap result\n     * on a midpoint\n     * @param {Autodesk.Viewing.MeasureCommon.SnapResult} snapResult\n     */\n    proto.renderMidpointIndicator = function(snapResult) {\n\n        var pos = snapResult.geomVertex;\n        var scale = this.setScale(pos);\n        var length = _indicatorSize * scale;\n\n        var rightVec = this.viewer.navigation.getCameraRightVector().multiplyScalar(length);\n        var upVec = this.viewer.navigation.getCameraUpVector().multiplyScalar(length);\n\n        var geom = new THREE.Geometry();\n        var p = new THREE.Vector3();\n\n        // Bottom line\n        p.addVectors(pos, rightVec);\n        p.subVectors(p, upVec);\n        geom.vertices[0] = p.clone();\n        p.subVectors(pos, rightVec);\n        p.subVectors(p, upVec);\n        geom.vertices[1] = p.clone();\n        this.drawLine(geom, this.indicatorMaterial, _indicatorLineWidth, INDICATOR_OVERLAY);\n\n        // Left line\n        p.subVectors(pos, rightVec);\n        p.subVectors(p, upVec);\n        geom.vertices[0] = p.clone();\n        p.addVectors(pos, upVec);\n        geom.vertices[1] = p.clone();\n        this.drawLine(geom, this.indicatorMaterial, _indicatorLineWidth, INDICATOR_OVERLAY);\n\n        // Right line\n        p.addVectors(pos, rightVec);\n        p.subVectors(p, upVec);\n        geom.vertices[0] = p.clone();\n        p.addVectors(pos, upVec);\n        geom.vertices[1] = p.clone();\n        this.drawLine(geom, this.indicatorMaterial, _indicatorLineWidth, INDICATOR_OVERLAY);\n\n    };\n\n    /**\n     * Renders an upside-down Y around the given snap result\n     * on an edge or a curved edge..\n     * @param {Autodesk.Viewing.MeasureCommon.SnapResult} snapResult\n     */\n    proto.renderEdgeIndicator = function(snapResult) {\n\n        var pos = MeasureCommon.getSnapResultPosition(snapResult, this.viewer);\n        var scale = this.setScale(pos);\n        var length = _indicatorSize * scale;\n\n        var rightVec = this.viewer.navigation.getCameraRightVector().multiplyScalar(length);\n        var upVec = this.viewer.navigation.getCameraUpVector().multiplyScalar(length);\n\n        var geom = new THREE.Geometry();\n        var p = new THREE.Vector3();\n\n        // Bottom line\n        p.addVectors(pos, rightVec);\n        p.subVectors(p, upVec);\n        geom.vertices[0] = p.clone();\n        geom.vertices[1] = pos.clone();\n        this.drawLine(geom, this.indicatorMaterial, _indicatorLineWidth, INDICATOR_OVERLAY);\n\n        // Left line\n        p.subVectors(pos, rightVec);\n        p.subVectors(p, upVec);\n        geom.vertices[0] = p.clone();\n        geom.vertices[1] = pos.clone();\n        this.drawLine(geom, this.indicatorMaterial, _indicatorLineWidth, INDICATOR_OVERLAY);\n\n        // Right line\n        p.addVectors(pos, upVec);\n        geom.vertices[0] = p.clone();\n        geom.vertices[1] = pos.clone();\n        this.drawLine(geom, this.indicatorMaterial, _indicatorLineWidth, INDICATOR_OVERLAY);\n\n    };\n\n    /**\n     * Renders an circle on a center of a circle\n     * and circular arc for other than F2D sheets.\n     * @param {Autodesk.Viewing.MeasureCommon.SnapResult} snapResult\n     */\n    proto.renderCircleIndicator = function(snapResult){\n\n        var pos = MeasureCommon.getSnapResultPosition(snapResult, this.viewer);\n        this.drawCircle(pos, this.indicatorMaterial, INDICATOR_OVERLAY);\n\n    };\n\n    /**\n     * Renders an right-angle ( |_ ) indicator around the given snap result\n     * when the result is perpendicular.\n     * @param {Autodesk.Viewing.MeasureCommon.SnapResult} snapResult\n     */\n    proto.renderPerpendicular = function(snapResult) {\n\n        var pos = MeasureCommon.getSnapResultPosition(snapResult, this.viewer);\n        var scale = this.setScale(pos);\n        var length = _indicatorSize * scale;\n\n        var rightVec = this.viewer.navigation.getCameraRightVector().multiplyScalar(length);\n        var upVec = this.viewer.navigation.getCameraUpVector().multiplyScalar(length);\n\n        var geom = new THREE.Geometry();\n        var p = new THREE.Vector3();\n\n        // Upper line\n        geom.vertices[0] = pos.clone();\n        p.subVectors(pos, rightVec);\n        geom.vertices[1] = p.clone();\n        this.drawLine(geom, this.indicatorMaterial, _indicatorLineWidth, INDICATOR_OVERLAY);\n\n        // Bottom line\n        p.addVectors(pos, rightVec);\n        p.subVectors(p, upVec);\n        geom.vertices[0] = p.clone();\n        p.subVectors(pos, rightVec);\n        p.subVectors(p, upVec);\n        geom.vertices[1] = p.clone();\n        this.drawLine(geom, this.indicatorMaterial, _indicatorLineWidth, INDICATOR_OVERLAY);\n\n        // Left line\n        p.subVectors(pos, rightVec);\n        p.subVectors(p, upVec);\n        geom.vertices[0] = p.clone();\n        p.subVectors(pos, rightVec);\n        p.addVectors(p, upVec);\n        geom.vertices[1] = p.clone();\n        this.drawLine(geom, this.indicatorMaterial, _indicatorLineWidth, INDICATOR_OVERLAY);\n\n        // Right line\n        geom.vertices[0] = pos.clone();\n        p.subVectors(pos, upVec);\n        geom.vertices[1] = p.clone();\n        this.drawLine(geom, this.indicatorMaterial, _indicatorLineWidth, INDICATOR_OVERLAY);\n\n    };\n\n    /**\n     * Renders an X around the given snap result.\n     * Usually shown when using \"Free Measure\" mode is enabled.\n     * @param {Autodesk.Viewing.MeasureCommon.SnapResult} snapResult\n     */\n    proto.renderPixelIndicator = function(snapResult) {\n\n        var pos = MeasureCommon.getSnapResultPosition(snapResult, this.viewer);\n        var scale = this.setScale(pos);\n        var length = _indicatorSize * scale;\n\n        var rightVec = this.viewer.navigation.getCameraRightVector().multiplyScalar(length);\n        var upVec = this.viewer.navigation.getCameraUpVector().multiplyScalar(length);\n\n        var geom = new THREE.Geometry();\n        var p = new THREE.Vector3();\n\n        // Top-left line\n        p.subVectors(pos, rightVec);\n        p.addVectors(p,upVec);\n        geom.vertices[0] = p.clone();\n        geom.vertices[1] = pos.clone();\n        this.drawLine(geom, this.indicatorMaterial, _indicatorLineWidth, INDICATOR_OVERLAY);\n\n        // Top-right line\n        p.addVectors(pos, rightVec);\n        p.addVectors(p,upVec);\n        geom.vertices[0] = p.clone();\n        geom.vertices[1] = pos.clone();\n        this.drawLine(geom, this.indicatorMaterial, _indicatorLineWidth, INDICATOR_OVERLAY);\n\n        // Bottom-right line\n        p.addVectors(pos, rightVec);\n        p.subVectors(p, upVec);\n        geom.vertices[0] = p.clone();\n        geom.vertices[1] = pos.clone();\n        this.drawLine(geom, this.indicatorMaterial, _indicatorLineWidth, INDICATOR_OVERLAY);\n        \n        // Bottom-left line\n        p.subVectors(pos, rightVec);\n        p.subVectors(p, upVec);\n        geom.vertices[0] = p.clone();\n        geom.vertices[1] = pos.clone();\n        this.drawLine(geom, this.indicatorMaterial, _indicatorLineWidth, INDICATOR_OVERLAY);\n\n\n    };\n\n    proto.renderIndicator = function(snapResult) {\n\n        if (snapResult.isPerpendicular) {\n            this.renderPerpendicular(snapResult);\n            return;\n        }\n\n        if(snapResult.snapToArc) {\n            if(snapResult.isArc && snapResult.geomType === SnapType.SNAP_CIRCULARARC && this.viewer.model.is2d() && !this.viewer.model.isPdf()) {\n                this.renderVertexIndicator(snapResult);\n            }\n            return;\n        }\n        \n\n        switch (snapResult.geomType) {\n            case SnapType.SNAP_VERTEX:            \n            case SnapType.SNAP_INTERSECTION:\n                this.renderVertexIndicator(snapResult);\n                break;\n    \n            case SnapType.SNAP_MIDPOINT:\n                this.renderMidpointIndicator(snapResult);\n                break;\n\n            case SnapType.SNAP_CIRCLE_CENTER:\n                this.renderCircleIndicator(snapResult);\n                break;\n\n            case SnapType.SNAP_EDGE:\n            case SnapType.SNAP_CURVEDEDGE:\n                this.renderEdgeIndicator(snapResult);\n                break;\n\n            case SnapType.SNAP_CIRCULARARC:\n                if (this.viewer.model.is2d()) {\n                    this.renderVertexIndicator(snapResult);\n                } else {\n                    this.renderCircleIndicator(snapResult);\n                }\n                break;\n\n            case SnapType.SNAP_FACE:\n            case SnapType.SNAP_CURVEDFACE:\n                this.renderVertexIndicator(snapResult);\n                break;\n\n            case SnapType.RASTER_PIXEL:\n                this.renderPixelIndicator(snapResult);\n                break;\n        }\n    };\n\n    proto.drawLine = function(geom, material, width, overlayName) {\n\n        // Line Pieces\n        if (overlayName === GEOMETRIES_OVERLAY) {\n            this.overlayType = EDGE_OVERLAY;    \n        }\n        \n        for (var i = 0; i < geom.vertices.length; i += 2) {\n            var cylinder = this.cylinderMesh(geom.vertices[i], geom.vertices[i + 1], material, width);\n            this.setEdgeScale(cylinder);\n            this.addOverlay(overlayName, cylinder);\n        }\n    };\n\n    proto.drawPoint = function(point, material, overlayName) {\n        \n        // Because every point is snappable in PDFs, don't display the green dot for PDFs.\n        if (this.viewer.model.isLeaflet()) {\n            return;\n        }\n\n        if (!_point)\n            _point = new THREE.SphereGeometry(1.0);\n\n        var pointMesh = new THREE.Mesh(_point, material);\n        pointMesh.position.set(point.x, point.y, point.z);\n\n        this.setPointScale(pointMesh);\n\n        if (overlayName === GEOMETRIES_OVERLAY) {\n            this.overlayType = POINT_OVERLAY;\n        }\n\n        this.addOverlay(overlayName, pointMesh);\n\n    };\n\n    proto.drawCircle = function(point, material, overlayName) {\n\n        var torus = new THREE.TorusGeometry(_indicatorSize, _indicatorLineWidth, 2, 20);\n        var torusMesh = new THREE.Mesh(torus, material);\n        torusMesh.lookAt(this.viewer.navigation.getEyeVector().normalize());\n        torus = null;\n\n        torusMesh.position.set(point.x, point.y, point.z);\n\n        this.setCircleScale(torusMesh);\n\n        this.addOverlay(overlayName, torusMesh);\n\n    };\n\n    proto.setScale = function (point) {\n\n        var pixelSize = 5;\n\n        var navapi = this.viewer.navigation;\n        var camera = navapi.getCamera();\n        var position = navapi.getPosition();\n\n        var p = point.clone();\n\n        var distance = camera.isPerspective ? p.sub(position).length()\n            : navapi.getEyeVector().length();\n\n        var fov = navapi.getVerticalFov();\n        var worldHeight = 2.0 * distance * Math.tan(THREE.Math.degToRad(fov * 0.5));\n\n        var viewport = navapi.getScreenViewport();\n        var scale = pixelSize * worldHeight / viewport.height;\n\n        return scale;\n\n    };\n\n    proto.setPointScale = function (pointMesh) {\n\n        var scale = this.setScale(pointMesh.position);\n        pointMesh.scale.x = scale;\n        pointMesh.scale.y = scale;\n        pointMesh.scale.z = scale;\n\n    };\n\n    proto.setCircleScale = function (torusMesh) {\n\n        var scale = this.setScale(torusMesh.position);\n        torusMesh.scale.x = scale;\n        torusMesh.scale.y = scale;\n    };\n\n    proto.setEdgeScale = function (cylinderMesh) {\n\n        var scale = this.setScale(cylinderMesh.position);\n        cylinderMesh.scale.x = scale;\n        cylinderMesh.scale.z = scale;\n    };\n\n    proto.updatePointScale = function(overlayName) {\n\n        if (this.overlayType != POINT_OVERLAY)\n            return;\n\n        var overlay = this.viewer.impl.overlayScenes[overlayName];\n        if (overlay) {\n            var scene = overlay.scene;\n\n            for (var i = 0; i < scene.children.length; i++) {\n                var pointMesh = scene.children[i];\n                if (pointMesh) {\n\n                    this.setPointScale(pointMesh);\n                }\n            }\n        }\n    };\n\n    proto.updateEdgeScale = function(overlayName) {\n\n        if (this.overlayType != EDGE_OVERLAY)\n            return;\n\n        var overlay = this.viewer.impl.overlayScenes[overlayName];\n        if (overlay) {\n            var scene = overlay.scene;\n\n            for (var i = 0; i < scene.children.length; i++) {\n                var cylinderMesh = scene.children[i];\n                if (cylinderMesh) {\n\n                    this.setEdgeScale(cylinderMesh);\n                }\n            }\n        }\n    };\n\n    proto.onCameraChange = function () {\n\n        this.updatePointScale(GEOMETRIES_OVERLAY);\n        this.updateEdgeScale(GEOMETRIES_OVERLAY);\n\n        // if (!this.snapper.markupMode) {\n            this.render();\n        // }\n    };\n\n    proto.destroy = function() {\n\n        this.removeOverlay(GEOMETRIES_OVERLAY);\n        this.removeOverlay(INDICATOR_OVERLAY);\n\n        if (_point) {\n            _point.dispose();\n            _point = null;\n        }\n    };"],"sourceRoot":""}