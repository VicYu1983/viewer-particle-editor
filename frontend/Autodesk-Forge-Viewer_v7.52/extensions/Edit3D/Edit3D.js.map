{"version":3,"file":"Edit3D/Edit3D.js","sources":["webpack://Autodesk.Extensions.[name]/webpack/bootstrap","webpack://Autodesk.Extensions.[name]/./extensions/Edit3D/CoordPicker.js","webpack://Autodesk.Extensions.[name]/./extensions/Edit3D/Edit3D.js","webpack://Autodesk.Extensions.[name]/./extensions/Edit3D/Gizmo3D.js","webpack://Autodesk.Extensions.[name]/./extensions/Edit3D/Label3D.js","webpack://Autodesk.Extensions.[name]/./extensions/Edit3D/NPointPicker.js","webpack://Autodesk.Extensions.[name]/./extensions/Edit3D/PointMarker.js","webpack://Autodesk.Extensions.[name]/./extensions/Edit3D/TwoPointPicker.js"],"sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./extensions/Edit3D/Edit3D.js\");\n","function ownKeys(object, enumerableOnly) {var keys = Object.keys(object);if (Object.getOwnPropertySymbols) {var symbols = Object.getOwnPropertySymbols(object);if (enumerableOnly) symbols = symbols.filter(function (sym) {return Object.getOwnPropertyDescriptor(object, sym).enumerable;});keys.push.apply(keys, symbols);}return keys;}function _objectSpread(target) {for (var i = 1; i < arguments.length; i++) {var source = arguments[i] != null ? arguments[i] : {};if (i % 2) {ownKeys(Object(source), true).forEach(function (key) {_defineProperty(target, key, source[key]);});} else if (Object.getOwnPropertyDescriptors) {Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));} else {ownKeys(Object(source)).forEach(function (key) {Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));});}}return target;}function _defineProperty(obj, key, value) {if (key in obj) {Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true });} else {obj[key] = value;}return obj;}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError(\"Cannot call a class as a function\");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}var ToolName = 'ModelAlignment.CoordPicker';\n\nvar Events = {\n  POINT_CLICKED: 'pointClicked',\n  POINT_HOVERED: 'pointHovered', // point param may be undefined if no object was hit at the current mouse position \n  ESCAPE: 'escape' };var\n\n\nCoordPicker = /*#__PURE__*/function () {\n\n  function CoordPicker(viewer, snapper) {_classCallCheck(this, CoordPicker);\n    this.viewer = viewer;\n    this.snapper = snapper;\n\n    // Bind function so that we can use it for event listeners\n    this.onCameraChanged = this.onCameraChanged.bind(this);\n\n    Autodesk.Viewing.EventDispatcher.prototype.apply(this);\n\n    // Optional: If a plane is set, we select points on this plane instead of the model \n    this.selectionPlane = null;\n\n    this.enableSnapper = true;\n    this.snapperActive = false;\n    this.isDragging = false;\n\n    this.keyMap = {\n      SnapKey: Autodesk.Viewing.KeyCode.SHIFT // Holding this key suppresses snapping\n    };\n\n    // Track last mouse position in canvas coords. Note that derived classes must call\n    // the base class mouse handlers to keep this value valid.\n    this.canvasPos = new THREE.Vector2();\n\n    this.tmpPoint = new THREE.Vector3();\n    this.tmpMatrix3 = new THREE.Matrix3();\n\n    // Last successful hit under mouse.\n    this.lastHit = null;\n    this.consumeClickEvents = true;\n\n    this.snapFilter = null; // Optional snapping filter, based on snapResult. (snapResult) => boolean.\n\n    // Set default cursor.\n    this.setCursor();\n  }\n\n  // @param {THREE.Plane} [plane] - If a plane is set, we are selecting points on that plane instead of the model. \n  _createClass(CoordPicker, [{ key: \"setSelectionPlane\", value: function setSelectionPlane(plane) {\n      this.selectionPlane = plane;\n    } }, { key: \"getName\", value: function getName()\n\n    {\n      return ToolName;\n    } }, { key: \"getNames\", value: function getNames()\n\n    {\n      return [ToolName];\n    } }, { key: \"setCursor\", value: function setCursor(\n\n    cursor) {\n      this.cursor = cursor ? cursor : 'crosshair';\n    } }, { key: \"getCursor\", value: function getCursor()\n\n    {\n      return this.isDragging ? 'grabbing' : this.active && this.lastHit ? this.cursor : null;\n    } }, { key: \"snapperOn\", value: function snapperOn()\n\n    {\n      if (!this.snapperActive) {\n        this.viewer.toolController.activateTool(this.snapper.getName());\n        this.snapperActive = true;\n      }\n    } }, { key: \"snapperOff\", value: function snapperOff()\n\n    {\n      if (this.snapperActive) {\n        this.viewer.toolController.deactivateTool(this.snapper.getName());\n        this.snapperActive = false;\n      }\n    } }, { key: \"setSnapperEnabled\", value: function setSnapperEnabled(\n\n    enabled) {\n      this.enableSnapper = enabled;\n      if (enabled) {\n        this.snapperOn();\n      } else {\n        this.snapperOff();\n      }\n    } }, { key: \"setSnapFilter\", value: function setSnapFilter(\n\n    snapFilter) {\n      this.snapFilter = snapFilter;\n      this.snapper.setSnapFilter(snapFilter);\n    } }, { key: \"activate\", value: function activate()\n\n    {\n      this.active = true;\n\n      if (this.enableSnapper) {\n        this.snapperOn();\n      }\n\n      this.viewer.addEventListener(Autodesk.Viewing.CAMERA_CHANGE_EVENT, this.onCameraChanged);\n      this.viewer.impl.pauseHighlight(true);\n    } }, { key: \"deactivate\", value: function deactivate()\n\n    {\n      this.active = false;\n      this.isDragging = false;\n      this.lastHit = null;\n\n      this.snapperOff();\n\n      this.viewer.removeEventListener(Autodesk.Viewing.CAMERA_CHANGE_EVENT, this.onCameraChanged);\n      this.viewer.impl.pauseHighlight(false);\n    } }, { key: \"register\", value: function register()\n\n    {}\n\n    // Remember last mouse position\n  }, { key: \"trackMousePos\", value: function trackMousePos(e) {\n      this.canvasPos.set(e.canvasX, e.canvasY);\n    } }, { key: \"handleMouseMove\", value: function handleMouseMove(\n\n    event) {\n      this.trackMousePos(event);\n\n      // Make sure that snapping result is up-to-date\n      this.snapper.onMouseMove({ x: event.canvasX, y: event.canvasY });\n\n      if (this.snapper.indicator) {\n        this.snapper.indicator.render();\n      }\n\n      // Note that we always fire, even if hit is undefined. This is needed to clear indicators and edit \n      // values if the mouse is not on an object anymore.\n      var result = this.getHitResultUnderMouse(event);\n      this.fireEvent(_objectSpread({ type: Events.POINT_HOVERED }, result));\n\n      return this.isDragging;\n    }\n\n    // Returns hitPoint under mouse or null if no object under mouse.\n  }, { key: \"getHitResultUnderMouse\", value: function getHitResultUnderMouse(event) {\n\n      var point = null;\n      var normal = null;\n      var modelId = null;\n      var dbId = null;\n\n      if (this.snapperActive && this.snapper.isSnapped()) {\n        // Get snapped position.\n        var hitResult = this.snapper.getSnapResult();\n        point = Autodesk.Viewing.MeasureCommon.getSnapResultPosition(hitResult, this.viewer);\n        normal = hitResult === null || hitResult === void 0 ? void 0 : hitResult.faceNormal;\n        modelId = hitResult === null || hitResult === void 0 ? void 0 : hitResult.modelId;\n        dbId = hitResult === null || hitResult === void 0 ? void 0 : hitResult.snapNode;\n      } else {var _hitResult$face, _hitResult$model;\n        // When snapper is not active, or no point resulted, perform a simple hit test.\n        var _hitResult = this.viewer.impl.hitTest(event.canvasX, event.canvasY);\n        point = _hitResult === null || _hitResult === void 0 ? void 0 : _hitResult.point;\n\n        // Extract normal\n        if (_hitResult === null || _hitResult === void 0 ? void 0 : (_hitResult$face = _hitResult.face) === null || _hitResult$face === void 0 ? void 0 : _hitResult$face.normal) {\n          var mesh = this.viewer.impl.getRenderProxy(_hitResult.model, _hitResult.fragId);\n          var normalMatrix = this.tmpMatrix3.getNormalMatrix(mesh.matrixWorld);\n          normal = _hitResult.face.normal.clone().applyMatrix3(normalMatrix).normalize();\n        }\n\n        modelId = _hitResult === null || _hitResult === void 0 ? void 0 : (_hitResult$model = _hitResult.model) === null || _hitResult$model === void 0 ? void 0 : _hitResult$model.id;\n        dbId = _hitResult === null || _hitResult === void 0 ? void 0 : _hitResult.dbId;\n      }\n\n      if (this.snapFilter && !this.snapFilter({ modelId: modelId })) {\n        point = null;\n        normal = null;\n        modelId = null;\n        dbId = null;\n      }\n\n      // If selection plane is set, project the hit point on the plane.\n      if (point && this.selectionPlane) {\n        point = this.selectionPlane.projectPoint(point, this.tmpPoint);\n      }\n\n      var result = { point: point, normal: normal, modelId: modelId, dbId: dbId };\n\n      // Update lastHit only if we have an actual hit.\n      this.lastHit = point ? result : null;\n\n      return result;\n    } }, { key: \"setConsumeClickEvents\", value: function setConsumeClickEvents(\n\n    consumeClickEvents) {\n      this.consumeClickEvents = consumeClickEvents;\n    } }, { key: \"handleSingleClick\", value: function handleSingleClick(\n\n    event, button) {\n      this.trackMousePos(event);\n\n      // Only respond to left button\n      if (button !== 0) {\n        return false;\n      }\n\n      var result = this.getHitResultUnderMouse(event);\n\n      this.fireEvent(_objectSpread({ type: Events.POINT_CLICKED }, result));\n\n      return this.consumeClickEvents;\n    } }, { key: \"handleDoubleClick\", value: function handleDoubleClick(\n\n    event) {\n      this.trackMousePos(event);\n    } }, { key: \"handleButtonDown\", value: function handleButtonDown(\n\n    event) {\n      this.trackMousePos(event);\n\n      // In case of start dragging, make sure to turn on the snapper first.\n      if (this.isDragging) {\n        this.snapperOn();\n      }\n\n      return this.handleMouseMove(event);\n    } }, { key: \"handleButtonUp\", value: function handleButtonUp(\n\n    event) {\n      this.trackMousePos(event);\n      return this.isDragging;\n    }\n\n    // Simulate mouse move instantly when snapper is being toggled.\n  }, { key: \"onSnappingToggled\", value: function onSnappingToggled() {\n      this.handleMouseMove({\n        canvasX: this.canvasPos.x,\n        canvasY: this.canvasPos.y });\n\n    } }, { key: \"handleKeyDown\", value: function handleKeyDown(\n\n    event, keyCode) {\n      switch (keyCode) {\n        case Autodesk.Viewing.KeyCode.BACKSPACE:\n        case Autodesk.Viewing.KeyCode.DELETE:\n        case Autodesk.Viewing.KeyCode.ESCAPE:\n          this.fireEvent({ type: Events.ESCAPE });\n          return true;\n        case this.keyMap.SnapKey:\n          if (this.snapperActive) {\n            this.snapperOff();\n            this.onSnappingToggled();\n            return true;\n          }\n          return false;\n        default:\n          break;}\n\n\n      return false;\n    } }, { key: \"handleKeyUp\", value: function handleKeyUp(\n\n\n    event, keyCode) {\n      switch (keyCode) {\n        case this.keyMap.SnapKey:\n          if (!this.snapperActive && this.enableSnapper) {\n            this.snapperOn();\n            this.onSnappingToggled();\n            return true;\n          }\n          return false;\n        default:\n          break;}\n\n\n      return false;\n    } }, { key: \"onCameraChanged\", value: function onCameraChanged()\n\n    {\n      if (this.snapper.indicator) {\n        this.snapper.indicator.render();\n      }\n    } }, { key: \"setDragging\", value: function setDragging(\n\n    isDragging) {\n      this.isDragging = isDragging;\n    } }, { key: \"getDragging\", value: function getDragging()\n\n    {\n      return this.isDragging;\n    } }]);return CoordPicker;}();export { CoordPicker as default };\n\n\nCoordPicker.Events = Events;\nCoordPicker.Name = ToolName;","function _typeof(obj) {\"@babel/helpers - typeof\";if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;};}return _typeof(obj);}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError(\"Cannot call a class as a function\");}}function _inherits(subClass, superClass) {if (typeof superClass !== \"function\" && superClass !== null) {throw new TypeError(\"Super expression must either be null or a function\");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}function _createSuper(Derived) {var hasNativeReflectConstruct = _isNativeReflectConstruct();return function _createSuperInternal() {var Super = _getPrototypeOf(Derived),result;if (hasNativeReflectConstruct) {var NewTarget = _getPrototypeOf(this).constructor;result = Reflect.construct(Super, arguments, NewTarget);} else {result = Super.apply(this, arguments);}return _possibleConstructorReturn(this, result);};}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");}return self;}function _isNativeReflectConstruct() {if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;if (Reflect.construct.sham) return false;if (typeof Proxy === \"function\") return true;try {Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));return true;} catch (e) {return false;}}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}\nvar av = Autodesk.Viewing;\nvar namespace = AutodeskNamespace('Autodesk.Edit3D');\nvar myExtensionName = 'Autodesk.Edit3D';\n\nimport Gizmo3D from './Gizmo3D.js';\nimport Label3D from './Label3D.js';\nimport PointMarker from './PointMarker.js';\nimport CoordPicker from './CoordPicker.js';\nimport TwoPointPicker from './TwoPointPicker.js';\nimport NPointPicker from \"./NPointPicker.js\";\n\n/** \n                                               * Edit3D extension is a collection of general-purpose helper classes to faciliate \n                                               * implementation of 3D EditTools.\n                                               * Loading the extension does not add UI or changes behavior in the viewer. Its purpose is only\n                                               * to provide a basis for other extensions and client applications.\n                                               * \n                                               * The extension id is: `Autodesk.Edit3D`\n                                               * \n                                               * @example\n                                               *   viewer.loadExtension('Autodesk.Edit3D')\n                                               *\n                                               * @memberof Autodesk.Viewing.Extensions\n                                               * @see {@link Autodesk.Viewing.Extension} for common inherited methods.\n                                               * @alias Autodesk.Viewing.Extensions.Edit3DExtension\n                                               * @class\n                                               */var\nEdit3DExtension = /*#__PURE__*/function (_av$Extension) {_inherits(Edit3DExtension, _av$Extension);var _super = _createSuper(Edit3DExtension);\n  function Edit3DExtension(viewer, options) {_classCallCheck(this, Edit3DExtension);return _super.call(this,\n    viewer, options);\n  }return Edit3DExtension;}(av.Extension);export { Edit3DExtension as default };\n\n\nnamespace.Gizmo3D = Gizmo3D;\nnamespace.Label3D = Label3D;\nnamespace.PointMarker = PointMarker;\nnamespace.CoordPicker = CoordPicker;\nnamespace.TwoPointPicker = TwoPointPicker;\nnamespace.NPointPicker = NPointPicker;\n\n// Register the extension with the extension manager.\nav.theExtensionManager.registerExtension(myExtensionName, Edit3DExtension);","function _typeof(obj) {\"@babel/helpers - typeof\";if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;};}return _typeof(obj);}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError(\"Cannot call a class as a function\");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}\nvar nextId = 1;\n\n// Helper class for displaying a 3D shape that is scaled to keep approximately constant screen-size.\n// Example:\n//   const gizmo = new Gizmo3D(viewer).makeCube();\n//   gizmo.setPosition(10, 10, 10);\n//   gizmo.setVisible(true);\nvar Gizmo3D = /*#__PURE__*/function () {\n\n  // @param {Viewer3d} viewer\n  // @param {number}   [pixelSize]   - Size of the gizmo in pixels\n  // @param {Vector3}  [pos]         - Initial position. Default (0,0,0)\n  // @param {string}   [overlayName] - Name of an (existing) viewer overlay used to display the gizmo. If not specified, the Gizmo creates its own.\n  function Gizmo3D(viewer) {var pixelSize = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 30;var pos = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;var overlayName = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;_classCallCheck(this, Gizmo3D);\n\n    this.viewer = viewer;\n\n    // The shape is auto-scaled in a way that the projected screen-size of the unitBox diagonal\n    // keeps equal to this value. \n    this.pixelSize = pixelSize;\n\n    // Container for the gizmo shape. Matrix of this scene is controlled by the gizmo\n    this.scene = new THREE.Scene();\n\n    // Shape or scene to be displayed. BBox should be the unit box [-0.5, 0.5]^2, so that\n    // uto-scaling works properly.\n    this.shape = null;\n\n    // Connect event listener\n    this.onCameraChange = this.onCameraChange.bind(this);\n    this.viewer.addEventListener(Autodesk.Viewing.CAMERA_CHANGE_EVENT, this.onCameraChange);\n\n    // Make sure that matrix is recomputed after position/scale changes.\n    this.scene.matrixAutoUpdate = true;\n\n    // Overlay name that we use to display the gizmo\n    this.overlayName = overlayName;\n\n    // create own overlay if none specified\n    this.overlayOwned = !overlayName;\n    if (this.overlayOwned) {\n      this.overlayName = \"Gizmo3D_Overlay_\".concat(this.id);\n      this.viewer.impl.createOverlayScene(this.overlayName);\n    }\n\n    this.visible = false;\n\n    this.id = nextId++;\n\n    if (pos) {\n      this.setPosition(pos);\n    }\n  }_createClass(Gizmo3D, [{ key: \"setPosition\", value: function setPosition(\n\n    x, y, z) {\n\n      // Suppoer call with single Vec3 param\n      if (_typeof(x) === 'object') {\n        this.scene.position.copy(x);\n      } else {\n        this.scene.position.set(x, y, z);\n      }\n      this.scene.matrixWorldNeedsUpdate;\n\n      this.update();\n\n      return this;\n    } }, { key: \"dtor\", value: function dtor()\n\n    {\n      this.viewer.removeEventListener(Autodesk.Viewing.CAMERA_CHANGE_EVENT, this.onCameraChange);\n\n      if (this.overlayOwned) {\n        this.viewer.impl.removeOverlayScene(this.overlayName);\n      }\n    } }, { key: \"clearShape\", value: function clearShape()\n\n    {\n      if (this.shape) {\n        this.scene.remove(this.shape);\n        this.shape = null;\n      }\n    }\n\n    // Set a gizmo shape to display. Must be scaled to unitBox.\n  }, { key: \"setShape\", value: function setShape(shape) {\n      this.clearShape();\n      this.shape = shape;\n      this.scene.add(shape);\n      return this;\n    }\n\n    // Set shape to sphere\n  }, { key: \"makeSphere\", value: function makeSphere() {var color = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0xff0000;\n\n      // create sphere mesh, centered at (0,0,0) \n      var radius = 0.5;\n      var widthSegments = 22;\n      var heightSegments = 16;\n      var geometry = new THREE.SphereGeometry(radius, widthSegments, heightSegments);\n      var material = new THREE.MeshPhongMaterial({ color: color });\n      var shape = new THREE.Mesh(geometry, material);\n\n      return this.setShape(shape);\n    } }, { key: \"makeCube\", value: function makeCube()\n\n    {var color = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0xff0000;\n\n      // create box mesh of edgeLength 1, centered at (0,0,0)\n      var geometry = new THREE.BoxGeometry(1, 1, 1);\n      var material = new THREE.MeshPhongMaterial({ color: color });\n      var shape = new THREE.Mesh(geometry, material);\n      return this.setShape(shape);\n    } }, { key: \"setVisible\", value: function setVisible(\n\n    visible) {\n      if (this.visible == visible) {\n        return;\n      }\n\n      if (visible) {\n        this.viewer.impl.addOverlay(this.overlayName, this.scene);\n      } else {\n        this.viewer.impl.removeOverlay(this.overlayName, this.scene);\n      }\n\n      this.visible = visible;\n\n      // trigger overlay update\n      this.viewer.impl.invalidate(false, false, true);\n\n      return this;\n    } }, { key: \"update\", value: function update()\n\n    {\n      // compute screenSize that we get with scaling 1.0\n      var dist = this.viewer.impl.camera.position.distanceTo(this.scene.position);\n      var worldToPixelScale = this.viewer.impl.camera.pixelsPerUnitAtDistance(dist);\n\n      // compute and apply scale in world-space\n      var scale = this.pixelSize / worldToPixelScale;\n      this.scene.scale.set(scale, scale, scale);\n\n      // make sure that scale changes takes effect \n      this.scene.matrixWorldNeedsUpdate = true;\n\n      this.viewer.impl.invalidate(false, false, true);\n    }\n\n    // On camera changes, update scaling to keep constant pixel-size\n  }, { key: \"onCameraChange\", value: function onCameraChange() {\n      this.update();\n    } }]);return Gizmo3D;}();export { Gizmo3D as default };","function _typeof(obj) {\"@babel/helpers - typeof\";if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;};}return _typeof(obj);}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError(\"Cannot call a class as a function\");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}function _inherits(subClass, superClass) {if (typeof superClass !== \"function\" && superClass !== null) {throw new TypeError(\"Super expression must either be null or a function\");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}function _createSuper(Derived) {var hasNativeReflectConstruct = _isNativeReflectConstruct();return function _createSuperInternal() {var Super = _getPrototypeOf(Derived),result;if (hasNativeReflectConstruct) {var NewTarget = _getPrototypeOf(this).constructor;result = Reflect.construct(Super, arguments, NewTarget);} else {result = Super.apply(this, arguments);}return _possibleConstructorReturn(this, result);};}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");}return self;}function _isNativeReflectConstruct() {if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;if (Reflect.construct.sham) return false;if (typeof Proxy === \"function\") return true;try {Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));return true;} catch (e) {return false;}}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}\nvar av = Autodesk.Viewing;\nvar avp = Autodesk.Viewing.Private;\n\n// Given two points p1, p2 in worldSpace, this function computes\n// the pixel distance of their screen projections.\nvar getPixelDistance = function getPixelDistance(viewer, p1, p2) {\n\n  var p1Screen = viewer.impl.worldToClient(p1);\n  var p2Screen = viewer.impl.worldToClient(p2);\n\n  var dx = p2Screen.x - p1Screen.x;\n  var dy = p2Screen.y - p1Screen.y;\n  return Math.sqrt(dx * dx + dy * dy);\n};\n\nvar Events = {\n  DRAG_START: \"dragStart\",\n  DRAG_END: \"dragEnd\" };\n\n\n// A Label3D is an html div whose position is synchronized with a fixed world-space position in LMV.\nvar Label3D = /*#__PURE__*/function (_Autodesk$Viewing$Eve) {_inherits(Label3D, _Autodesk$Viewing$Eve);var _super = _createSuper(Label3D);\n\n  // @param {Viewer3D}      viewer\n  // @param {THREE.Vector3} [pos3D] - By default (0,0,0). Can be set later by changing this.pos3D.\n  // @param {string}        [text]  - If undefined, label will be empty/invisible by default and you have to configure this.container yourself.\n  function Label3D(viewer) {var _this;var pos3D = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new THREE.Vector3();var text = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '<Empty>';_classCallCheck(this, Label3D);\n    _this = _super.call(this);\n    _this.viewer = viewer;\n    _this.pos3D = pos3D;\n    _this.pos2D = new THREE.Vector3(); // updated automatically. z is the depth value\n    _this.draggable = false;\n\n    _this.setGlobalManager(viewer.globalManager);\n\n    // keep position in-sync with camera changes\n    _this.cameraChangeCb = _this.update.bind(_assertThisInitialized(_this));\n    _this.viewer.addEventListener(av.CAMERA_CHANGE_EVENT, _this.cameraChangeCb);\n    _this.viewer.addEventListener(av.VIEWER_RESIZE_EVENT, _this.cameraChangeCb);\n\n    // Create container\n    var document = viewer.canvasWrap.ownerDocument; // (might be != global document in popout scenarios)\n    _this.container = document.createElement('div');\n\n    // Note: It's essential that we add it to viewer.canvasWrap instead of viewer.container:\n    //       ToolController listens to events on canvasWrap. Therefore, if we would add\n    //       it to viewer.container, all mouse events captured would never reach the ToolController\n    //       no matter whether the gizmo handles them or not.\n    viewer.canvasWrap.appendChild(_this.container);\n\n    // For fadeIn/Out effects\n    var setOpacity = function setOpacity(t) {\n      _this.container.style.opacity = t;\n    };\n    _this.opacityParam = new avp.AnimatedParam(0.0, setOpacity, 0.5);\n\n    // Initial fade-in\n    _this.opacityParam.fadeTo(1.0);\n\n    // We control position via transform. So, left/top usually keep (0,0)\n    _this.container.style.left = '0px';\n    _this.container.style.top = '0px';\n    _this.container.style.position = 'absolute';\n    _this.container.style.pointerEvents = 'none';\n\n    // Only used for text labels\n    _this.textDiv = null;\n    if (text) {\n      _this.setText(text);\n    }\n\n    // Level-of-detail (optional)\n    _this.worldBox = null;\n    _this.minPixels = 0;\n\n    // Update position and fade-in\n    _this.setVisible(true);\n\n    _this.onMouseDown = _this.onMouseDown.bind(_assertThisInitialized(_this));return _this;\n  }\n\n  // Decides if the label should be shown or hidden.\n  // We hide the label the projected box diagonal falls below this.minPixels.\n  _createClass(Label3D, [{ key: \"shouldBeHidden\", value: function shouldBeHidden() {\n      if (!this.worldBox) {\n        return false;\n      }\n\n      var boxSizeScreen = getPixelDistance(this.viewer, this.worldBox.min, this.worldBox.max);\n      return boxSizeScreen < this.minPixels;\n    }\n\n    // Optional: WorldBox of the annotated object. Used for level-of-detail: We only show the label\n    //           if the projected screen-size of the box is >= a given minimum pixel size.\n    // @param {Box3}   worldBox\n    // @param {number} minPixels\n  }, { key: \"setWorldBox\", value: function setWorldBox(box, minPixels) {\n      this.worldBox = box;\n      this.minPixels = minPixels;\n      this.update(); // hide this label immediately if projected world-box is very small\n    }\n\n    // Configure this label to display text\n  }, { key: \"initTextLabel\", value: function initTextLabel() {\n\n      // Create textDiv child div\n      var document = this.viewer.container.ownerDocument;\n      this.textDiv = document.createElement('div');\n      this.container.appendChild(this.textDiv);\n\n      // Use measure-tool styles by default\n      this.container.classList.add('measure-length');\n      this.container.classList.add('visible');\n      this.textDiv.classList.add('measure-length-text');\n    } }, { key: \"setText\", value: function setText(\n\n    text) {\n      if (!this.textDiv) {\n        this.initTextLabel();\n      }\n      this.textDiv.textContent = Autodesk.Viewing.i18n.translate(text);\n    } }, { key: \"dtor\", value: function dtor()\n\n    {\n      this.container.remove();\n      this.viewer.removeEventListener(av.CAMERA_CHANGE_EVENT, this.cameraChangeCb);\n      this.viewer.removeEventListener(av.VIEWER_RESIZE_EVENT, this.cameraChangeCb);\n    }\n\n    // To change the position, just modify this.pos3D directly and call update().\n  }, { key: \"update\", value: function update() {var _this2 = this;\n      // Get canvas position corresponding to this.pos3D\n      var _this$viewer$impl$wor = this.viewer.impl.worldToClient(this.pos3D),x = _this$viewer$impl$wor.x,y = _this$viewer$impl$wor.y;\n\n      // Transform the div, so that its center is anchored in (x,y)\n      this.container.style.transform = \"translate(calc(\".concat(x, \"px - 50%), calc(\").concat(y, \"px - 50%))\");\n\n      // Hide label if the annotated object is small on screen\n      var hidden = !this.visible || this.shouldBeHidden();\n\n      // If the label should be visible, immediately restore the container visibility, so the fade-in will be displayed.\n      if (!hidden) {\n        this.changeContainerVisibility(!hidden);\n      }\n\n      // this.opacityParam.skipAnim();\n      this.opacityParam.fadeTo(hidden ? 0.0 : 1.0, function () {\n        // If the label should be hidden, change container visibility only after the fade-out animation finished.\n        // This is needed in order that the element won't be touchable while hidden.\n        _this2.changeContainerVisibility(!hidden);\n      });\n    }\n\n    // Necessary in addition to the opacity change, in order to remove from the DOM rendering.\n  }, { key: \"changeContainerVisibility\", value: function changeContainerVisibility(show) {\n      if (!show && !this.styleHidden) {\n        this.styleHidden = true;\n        this.container.style.display = 'none';\n      } else if (show && this.styleHidden) {\n        this.styleHidden = false;\n        this.container.style.display = 'block';\n      }\n    } }, { key: \"setPosition\", value: function setPosition(\n\n    pos) {\n      this.pos3D.copy(pos);\n      this.update();\n    } }, { key: \"setVisible\", value: function setVisible(\n\n    visible) {\n      this.visible = visible;\n      this.update();\n    }\n\n    // Fade out and dispose label when done\n  }, { key: \"dispose\", value: function dispose() {var _this3 = this;\n      this.setVisible(false);\n\n      // Make sure that we clean up when fading is done.\n      window.setTimeout(function () {return _this3.dtor();}, 1000 * this.opacityParam.animTime);\n    }\n\n    // @param {number} offset - Optional: Vertical offset in screen-pixels. Positive values shift down.\n  }, { key: \"setVerticalOffset\", value: function setVerticalOffset(offset) {\n      this.container.style.top = offset + 'px';\n    } }, { key: \"onMouseDown\", value: function onMouseDown(\n\n    event) {var _this4 = this;\n      this.container.style.cursor = \"grabbing\";\n\n      this.viewer.toolController.__clientToCanvasCoords(event);\n\n      this.fireEvent({ type: Events.DRAG_START, event: event });\n\n      var handleMouseUp = function handleMouseUp(e) {\n        _this4.onMouseUp(e);\n        _this4.removeDocumentEventListener(\"mouseup\", handleMouseUp);\n      };\n\n      this.addDocumentEventListener(\"mouseup\", handleMouseUp);\n    } }, { key: \"onMouseUp\", value: function onMouseUp(\n\n    event) {\n      this.container.style.cursor = \"grab\";\n\n      this.viewer.toolController.__clientToCanvasCoords(event);\n\n      this.fireEvent({ type: Events.DRAG_END, event: event });\n    } }, { key: \"setDraggable\", value: function setDraggable(\n\n    draggable) {\n      if (draggable && !this.draggable) {\n        this.container.addEventListener(\"mousedown\", this.onMouseDown);\n        this.container.style.cursor = \"grab\";\n        this.container.style.pointerEvents = 'auto';\n      } else if (!draggable && this.draggable) {\n        this.container.removeEventListener(\"mousedown\", this.onMouseDown);\n        this.container.style.cursor = \"\";\n        this.container.style.pointerEvents = 'none';\n      }\n\n      this.draggable = draggable;\n    } }]);return Label3D;}(Autodesk.Viewing.EventDispatcher);export { Label3D as default };\n\n\nav.GlobalManagerMixin.call(Label3D.prototype);\n\nLabel3D.Events = Events;","function _defineProperty(obj, key, value) {if (key in obj) {Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true });} else {obj[key] = value;}return obj;}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError(\"Cannot call a class as a function\");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}import CoordPicker from \"./CoordPicker.js\";\nimport PointMarker from \"./PointMarker.js\";\n\n// Controls the user interaction workflow for picking N points\n\nvar Events = {\n  POINT_SELECTED: \"pointSelected\",\n  POINT_HOVERED: \"pointHovered\",\n  POINT_SELECTION_STARTED: \"pointSelectionStarted\",\n  CLEAR: \"clear\" };\n\n\nvar Colors = {\n  Blue: \"rgb(6, 150, 215)\", // adskBlue500\n  Red: \"rgb(236, 74, 65)\", // red500\n  Black: \"rgb(0,0,0)\",\n  White: \"rgb(255,255,255)\" };\n\n\nvar ConnectorTypes = {\n  Line: \"line\",\n  Arrow: \"arrow\" };\n\n\n// N point picker - allows picking N points.\n//  @param {Viewer3D}      viewer\n//  @param {CoordPicker}   coordPicker\n//  @param {ScreenOverlay} screenOverlay\n//  @param {number}        N - number of points to select\n//  @param {Object}        [options]\n//  @param {Boolean}          [options.draggable] -      Whether points are draggable or not\n//  @param {String[]}      [options.colors] -         Array of colors\n//  @param {String[]}      [options.labels] -         Array of labels\n//  @param {String[]}      [options.icons] -          Array of icons\n//  @param {Object[]}      [options.connections] -    Array of point connections metadata.\n//  @param {Object[]}      [options.stops] -          Array of point indexes that the tool shouldn't automatically continue positioning new points after them.\nvar NPointPicker = /*#__PURE__*/function () {\n  function NPointPicker(viewer, coordPicker, screenOverlay, N) {var _this = this;var options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};_classCallCheck(this, NPointPicker);\n    this.viewer = viewer;\n    this.options = options;\n    this.coordPicker = coordPicker;\n    this.N = N;\n\n    Autodesk.Viewing.EventDispatcher.prototype.apply(this);\n\n    // Current active point - the one that is currently being picked or hovered.\n    this.selectingIndex = -1;\n\n    // Last valid point that was selected. Drag an exising previous point won't change this value.\n    this.lastSelectedPoint = -1;\n\n    this.coordPicker.addEventListener(\n    CoordPicker.Events.POINT_CLICKED,\n    function (event) {return _this.onPointClicked(event);});\n\n    this.coordPicker.addEventListener(\n    CoordPicker.Events.POINT_HOVERED,\n    function (event) {return _this.onPointHovered(event);});\n\n    this.coordPicker.addEventListener(CoordPicker.Events.ESCAPE, function () {\n      // Reset point only when dragging.\n      if (_this.coordPicker.isDragging) {\n        _this.cancelPointSelection();\n      }\n    });\n\n    this.points = [];\n    this.pointValid = [];\n    this.markers = [];\n    this.showMarkers = this.options.showMarkers || new Array(this.N).fill(true); // If showMarkers array is not supplied, default to true.\n    var _loop = function _loop(\n    i) {\n      _this.points.push(new THREE.Vector3());\n      _this.pointValid.push(false);\n      var color = options.colors ? options.colors[i] : Colors.Blue;\n      var label = options.labels ? options.labels[i] : undefined;\n      var icon = options.icons ? options.icons[i] : undefined;\n      var marker = new PointMarker(_this.viewer, undefined, label, icon);\n      _this.markers.push(marker);\n\n      if (_this.options.draggable) {\n        marker.addEventListener(PointMarker.Events.DRAG_START, function () {return (\n            _this.startSelectPoint(i, true));});\n\n        marker.addEventListener(PointMarker.Events.DRAG_END, function (event) {return (\n            _this.onDragEnded(event));});\n\n      }\n\n      // Hide the markers until we have valid from/to point\n      marker.setVisible(false);\n      marker.setColor(color);\n\n      // Custom label style\n      if (options.labelStyles && options.labelStyles[i]) {\n        Object.keys(options.labelStyles[i]).forEach(function (key) {\n          marker.label.container.style[key] = options.labelStyles[i][key];\n        });\n      }};for (var i = 0; i < this.N; i++) {_loop(i);\n    }\n\n    // {Autodesk.Edit2D.ScreenOverlay}\n    this.screenOverlay = screenOverlay;\n\n    var connectionsData = this.options.connections || [];\n    this.connectors = [];var _loop2 = function _loop2(\n\n    _i) {\n      var connectionData = connectionsData[_i];\n\n      // Configure style of line/arrow connection\n      var lineStyle = new Autodesk.Edit2D.Style({\n        lineStyle: 10,\n        lineWidth: 1.5,\n        lineColor: connectionData.color || Colors.Blue });\n\n\n      var gizmo = void 0;\n      var attachableObject = void 0;\n      var setFrom = void 0;\n      var setTo = void 0;\n\n      if (connectionData.type === ConnectorTypes.Line) {\n        // Dashed line connecting from/to point\n        gizmo = new Autodesk.Edit2D.ScreenOverlay.Line3DGizmo();\n        gizmo.line2D.style.copy(lineStyle);\n\n        // Define attachable object for the label\n        attachableObject = gizmo.line2D;\n\n        // Define position setters\n        setFrom = gizmo.a.copy.bind(gizmo.a);\n        setTo = gizmo.b.copy.bind(gizmo.b);\n      } else if (connectionData.type === ConnectorTypes.Arrow) {\n        // Dashed arrow connecting from/to point\n        gizmo = new Autodesk.Edit2D.ScreenOverlay.Arrow3DGizmo();\n        gizmo.arrow.line.style.copy(lineStyle);\n        gizmo.arrow.head.style.fillColor = lineStyle.lineColor;\n        gizmo.arrow.setHeadLength(18); // in pixels, because layer is screen-aligned\n        gizmo.arrow.setHeadAngle(40); // in degrees\n\n        // Define attachable object for the label\n        attachableObject = gizmo.arrow.line;\n\n        // Define position setters\n        setFrom = gizmo.setFrom.bind(gizmo);\n        setTo = gizmo.setTo.bind(gizmo);\n      } else {\n        console.warn(\"Invalid connector type.\");\n        return \"continue\";\n      }\n\n      var label = void 0;\n\n      if (connectionData.getEdgeLabelText) {\n        label = new Autodesk.Edit2D.EdgeLabel(screenOverlay.layer);\n        label.attachToEdge(attachableObject, 0, 0);\n\n        // Custom label style\n        if (connectionData.labelStyle) {\n          Object.keys(connectionData.labelStyle).forEach(function (key) {\n            label.container.style[key] = connectionData.labelStyle[key];\n          });\n        }\n      }\n\n      _this.connectors.push({\n        fromIndex: connectionData.fromIndex,\n        toIndex: connectionData.toIndex,\n        getEdgeLabelText: connectionData.getEdgeLabelText,\n        gizmo: gizmo,\n        label: label,\n        setFrom: setFrom,\n        setTo: setTo });};for (var _i = 0; _i < connectionsData.length; _i++) {var _ret = _loop2(_i);if (_ret === \"continue\") continue;\n\n    }\n\n    this.visible = true;\n\n    this.stops = this.options.stops || [];\n\n    this.onModelTransformChanged = this.onModelTransformChanged.bind(this);\n\n    this.modelsToPointsMap = {}; // { modelId: [indexes] }\n  }_createClass(NPointPicker, [{ key: \"dtor\", value: function dtor()\n\n    {\n      this.viewer.removeEventListener(Autodesk.Viewing.MODEL_TRANSFORM_CHANGED_EVENT, this.onModelTransformChanged);\n    } }, { key: \"startSelectPoint\", value: function startSelectPoint(\n\n    index, enableDrag) {\n      // Backup current point's position in case the drag won't be valid. In this case, we'll restore the current point.\n      this.pointBackup = this.pointValid[index] ?\n      this.points[index].clone() :\n      null;\n\n      // Start coord picker\n      if (!this.viewer.toolController.isToolActivated(this.coordPicker.getName())) {\n        this.viewer.toolController.activateTool(this.coordPicker.getName());\n      }\n\n      this.selectingIndex = index;\n\n      if (this.options.draggable) {\n        this.coordPicker.setDragging(enableDrag);\n        this.setMarkersDraggable(false);\n      }\n\n      this.fireEvent({\n        type: Events.POINT_SELECTION_STARTED,\n        index: this.selectingIndex });\n\n    } }, { key: \"onDragEnded\", value: function onDragEnded(_ref)\n\n    {var event = _ref.event;\n      if (!this.coordPicker.getDragging()) {\n        return;\n      }\n\n      this.coordPicker.handleSingleClick(event, 0);\n      this.coordPicker.setDragging(false);\n    } }, { key: \"startSelect\", value: function startSelect()\n\n    {\n      this.isActive = true;\n      this.continuePointSelectionIfNeeded();\n    }\n\n    // @param {Vector3} [from] - Use null/undefined for clearing the fromPoint.\n  }, { key: \"setPoint\", value: function setPoint(index, point) {\n      this.pointValid[index] = !!point;\n\n      if (this.pointValid[index]) {\n        this.points[index].copy(point);\n\n        // update point marker\n        this.markers[index].setPosition(point);\n      }\n\n      this.updateGizmos();\n    } }, { key: \"updateGizmoVisibility\", value: function updateGizmoVisibility(\n\n    gizmo, visible, skipFade) {\n      if (visible || skipFade) {\n        // Show/Hide immediately.\n        this.screenOverlay.setGizmoVisible(gizmo, visible);\n      } else {\n        // By default, hiding is done as smooth fadeout.\n        this.screenOverlay.fadeOutGizmo(gizmo);\n      }\n    }\n\n    // Show dashed line or arrow if from/to are both valid\n  }, { key: \"updateGizmos\", value: function updateGizmos(skipFade) {\n      for (var i = 0; i < this.N; i++) {\n        var visible = this.showMarkers[i] && this.visible && this.pointValid[i];\n        this.markers[i].setVisible(visible);\n      }\n\n      for (var _i2 = 0; _i2 < this.connectors.length; _i2++) {\n        var connector = this.connectors[_i2];\n        // Decide whether to show the connection between both points\n        var showGizmo =\n        this.visible &&\n        this.pointValid[connector.fromIndex] &&\n        this.pointValid[connector.toIndex];\n\n        this.updateGizmoVisibility(connector.gizmo, showGizmo, skipFade);\n\n        if (showGizmo) {\n          connector.setFrom(this.points[connector.fromIndex]);\n          connector.setTo(this.points[connector.toIndex]);\n        }\n\n        if (connector.label) {\n          connector.label.setOpacity(showGizmo ? 1 : 0, true);\n\n          // Update distance value only if label is visible.\n          if (showGizmo) {\n            var text = connector.getEdgeLabelText(_i2);\n            connector.label.setText(text);\n          }\n        }\n      }\n\n      // ensure refresh if only position has changed\n      this.screenOverlay.update();\n    } }, { key: \"clearPoint\", value: function clearPoint(\n\n    index) {\n      this.pointValid[index] = false;\n      this.markers[index].setVisible(false);\n\n      this.updateGizmos();\n    } }, { key: \"clear\", value: function clear()\n\n    {\n      this.cancelPointSelection();\n\n      for (var i = 0; i < this.N; i++) {\n        this.pointValid[i] = false;\n        this.markers[i].setVisible(false);\n      }\n\n      this.selectingIndex = -1;\n      this.lastSelectedPoint = -1;\n\n      this.updateGizmos();\n\n      this.isActive = false;\n\n      this.fireEvent({ type: Events.CLEAR });\n    } }, { key: \"onPointHovered\", value: function onPointHovered(\n\n    event) {\n      if (this.selectingIndex === -1) {\n        return;\n      }\n\n      this.setPoint(this.selectingIndex, event.point);\n      this.fireEvent({\n        type: Events.POINT_HOVERED,\n        point: event.point,\n        index: this.selectingIndex });\n\n    } }, { key: \"onPointClicked\", value: function onPointClicked(_ref2)\n\n    {var point = _ref2.point;var pickAnother = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      if (this.selectingIndex === -1) {\n        return;\n      }\n\n      // In case not point was selected, try restoring point backup.\n      point = point || this.pointBackup;\n\n      // Clear point backup\n      this.pointBackup = null;\n\n      // TODO: Avoid this hack. For this, the OrbitDollyPanTool should stop locking the ToolController and\n      //       properly handle the case to be disabled within an interaction - without global blocking the ToolController.\n      this.viewer.toolController.setIsLocked(false);\n      this.viewer.toolController.deactivateTool(this.coordPicker.getName());\n\n      if (point) {\n        // Set pivot to selected point, so that we can orbit around it\n        this.viewer.impl.camera.pivot.copy(point);\n        this.viewer.impl.camera.dirty = true;\n      }\n\n      this.setPoint(this.selectingIndex, point);\n\n      this.setMarkersDraggable(true);\n\n      var index = this.selectingIndex;\n\n      this.selectingIndex = -1;\n\n      if (point) {\n        this.lastSelectedPoint = Math.max(index, this.lastSelectedPoint);\n        this.fireEvent({ type: Events.POINT_SELECTED, point: point, index: index });\n      }\n\n      // Start picking another point if:\n      // - pickAnother flag is set\n      // - We just selected a point, and it's not a stop point index.\n      if (pickAnother && !(point && this.stops.includes(this.lastSelectedPoint))) {\n        this.continuePointSelectionIfNeeded();\n      }\n    } }, { key: \"setMarkersDraggable\", value: function setMarkersDraggable(\n\n    enable) {\n      if (!this.options.draggable) {\n        return;\n      }\n\n      for (var i = 0; i < this.N; i++) {\n        var draggable =\n        enable && this.visible && this.pointValid[i] && this.showMarkers[i];\n        this.markers[i].setDraggable(draggable);\n      }\n    } }, { key: \"cancelPointSelection\", value: function cancelPointSelection()\n\n    {\n      this.onPointClicked({}, false);\n    } }, { key: \"continuePointSelectionIfNeeded\", value: function continuePointSelectionIfNeeded()\n\n    {\n      if (!this.isPickerActive()) {\n        return;\n      }\n\n      // Make sure the tool is visible.\n      this.setVisible(true);\n\n      for (var i = 0; i < this.N; i++) {\n        if (!this.pointValid[i]) {\n          this.startSelectPoint(i, false);\n          break;\n        }\n      }\n    }\n\n    // Note: By default, setVisible(false) triggers a smooth fadeout. Use skipFade=true if you want to ensure that everything is instantly hidden.\n  }, { key: \"setVisible\", value: function setVisible(visible, skipFade) {\n      if (visible !== this.visible) {\n        this.visible = visible;\n        this.updateGizmos(skipFade);\n      }\n    }\n\n    // Shortcut for readability: Hide immediately without any fade-out.\n  }, { key: \"forceHide\", value: function forceHide() {\n      this.setVisible(false, true);\n    } }, { key: \"areAllPointsSet\", value: function areAllPointsSet()\n\n    {\n      if (this.selectingIndex !== -1) {\n        return false;\n      }\n\n      for (var i = 0; i < this.N; i++) {\n        if (!this.pointValid[i]) {\n          return false;\n        }\n      }\n\n      return true;\n    } }, { key: \"isPickerActive\", value: function isPickerActive()\n\n    {\n      return this.isActive;\n    } }, { key: \"attachPointsToModel\", value: function attachPointsToModel(\n\n    model, points) {\n      this.setModelsToPointsMap(Object.assign({}, this.modelsToPointsMap, _defineProperty({}, model.id, points)));\n    }\n\n    // ModelsToPointsMap is used to define a connection between points and specific models.\n    // It is currently being used in order to update the points according to model transform changes.\n    // Could be also used in the future for limiting the snapper to snap only on the attached model.\n  }, { key: \"setModelsToPointsMap\", value: function setModelsToPointsMap(map) {var _this2 = this;\n      this.modelsToPointsMap = map;\n\n      var ids = Object.keys(this.modelsToPointsMap);\n\n      if (ids.length > 0) {\n        ids.forEach(function (id) {var _model$getModelTransf;\n          var model = _this2.viewer.impl.findModel(Number(id), true);\n\n          // Used in order to calculate the initial transform diff later.\n          var matrix = (_model$getModelTransf = model.getModelTransform()) === null || _model$getModelTransf === void 0 ? void 0 : _model$getModelTransf.clone();\n          _this2.modelsToPointsMap[id].matrix = matrix || new Autodesk.Viewing.Private.LmvMatrix4(true);\n        });\n\n        if (!this.viewer.hasEventListener(Autodesk.Viewing.MODEL_TRANSFORM_CHANGED_EVENT, this.onModelTransformChanged)) {\n          this.viewer.addEventListener(Autodesk.Viewing.MODEL_TRANSFORM_CHANGED_EVENT, this.onModelTransformChanged);\n        }\n\n      } else {\n        // Remove event if there is no mapping.\n        this.viewer.removeEventListener(Autodesk.Viewing.MODEL_TRANSFORM_CHANGED_EVENT, this.onModelTransformChanged);\n      }\n    }\n\n    // Update points that are attached to a specific model, in case it moved.\n  }, { key: \"onModelTransformChanged\", value: function onModelTransformChanged(_ref3) {var model = _ref3.model,matrix = _ref3.matrix;\n      // No map;\n      if (!this.modelsToPointsMap) {\n        return;\n      }\n\n      var pointIndexes = this.modelsToPointsMap[model.id];\n\n      // Model not in map - nothing to update.\n      if (!pointIndexes) {\n        return;\n      }\n\n      // Calculate diff matrix.\n      var previousMatrix = this.modelsToPointsMap[model.id].matrix;\n      var diffMatrix = previousMatrix.getInverse(previousMatrix);\n      diffMatrix.multiplyMatrices(matrix, diffMatrix);\n\n      // Update for next time.\n      this.modelsToPointsMap[model.id].matrix = matrix.clone();\n\n      for (var i = 0; i < this.N; i++) {\n        if (pointIndexes.includes(i) && this.pointValid[i]) {\n\n          var point = this.points[i];\n          point.applyMatrix4(diffMatrix);\n          this.setPoint(i, point);\n        }\n      }\n    } }]);return NPointPicker;}();export { NPointPicker as default };\n\n\nNPointPicker.Events = Events;\nNPointPicker.Colors = Colors;\nNPointPicker.ConnectorTypes = ConnectorTypes;","function _typeof(obj) {\"@babel/helpers - typeof\";if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;};}return _typeof(obj);}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError(\"Cannot call a class as a function\");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}function _get(target, property, receiver) {if (typeof Reflect !== \"undefined\" && Reflect.get) {_get = Reflect.get;} else {_get = function _get(target, property, receiver) {var base = _superPropBase(target, property);if (!base) return;var desc = Object.getOwnPropertyDescriptor(base, property);if (desc.get) {return desc.get.call(receiver);}return desc.value;};}return _get(target, property, receiver || target);}function _superPropBase(object, property) {while (!Object.prototype.hasOwnProperty.call(object, property)) {object = _getPrototypeOf(object);if (object === null) break;}return object;}function _inherits(subClass, superClass) {if (typeof superClass !== \"function\" && superClass !== null) {throw new TypeError(\"Super expression must either be null or a function\");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}function _createSuper(Derived) {var hasNativeReflectConstruct = _isNativeReflectConstruct();return function _createSuperInternal() {var Super = _getPrototypeOf(Derived),result;if (hasNativeReflectConstruct) {var NewTarget = _getPrototypeOf(this).constructor;result = Reflect.construct(Super, arguments, NewTarget);} else {result = Super.apply(this, arguments);}return _possibleConstructorReturn(this, result);};}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");}return self;}function _isNativeReflectConstruct() {if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;if (Reflect.construct.sham) return false;if (typeof Proxy === \"function\") return true;try {Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));return true;} catch (e) {return false;}}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}\nimport Label3D from './Label3D.js';\n\nvar createIcon = function createIcon(icon) {\n  return [\n  '<svg width=\"50\" height=\"50\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\">',\n  '<g stroke-width=\"2\" stroke=\"currentColor\" fill=\"none\">',\n  icon,\n  '</g>',\n  '</svg>'].\n  join('');\n};\n\nvar Icons = {\n  Cross: '<path d=\"M0 25 L50 25 M25 0 L25 50\"/>',\n  Circle: '<circle r=\"5\" cx=\"25\" cy=\"27.5\" fill=\"currentColor\" stroke-width=\"0\" />',\n  Empty: '' };var\n\n\nPointMarker = /*#__PURE__*/function (_Label3D) {_inherits(PointMarker, _Label3D);var _super = _createSuper(PointMarker);\n\n  function PointMarker(viewer, pos3D, labelText) {var _this;var icon = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : Icons.Cross;_classCallCheck(this, PointMarker);\n    _this = _super.call(this, viewer, pos3D, null);\n\n    _this.container.innerHTML = createIcon(icon);\n\n    // Create another label for the text\n    if (labelText) {\n      _this.label = new Label3D(viewer, pos3D, labelText);\n\n      // Center text above the actual position\n      _this.label.setVerticalOffset(-45);\n    }\n\n    // Set label visible by default. If text is empty, it is hidden anyway. \n    _this.labelVisible = true;return _this;\n  }\n\n  // @param {string} Color string in css style (e.g. 'rgb(255, 255, 255)');\n  _createClass(PointMarker, [{ key: \"setColor\", value: function setColor(color) {\n      this.container.style.color = color;\n    } }, { key: \"setPosition\", value: function setPosition(\n\n    pos) {\n      _get(_getPrototypeOf(PointMarker.prototype), \"setPosition\", this).call(this, pos);\n      this.label && this.label.setPosition(pos);\n    } }, { key: \"setVisible\", value: function setVisible(\n\n    visible) {\n      _get(_getPrototypeOf(PointMarker.prototype), \"setVisible\", this).call(this, visible);\n      this.label && this.label.setVisible(this.labelVisible && visible);\n    } }, { key: \"setLabelVisible\", value: function setLabelVisible(\n\n    visible) {\n      this.label && this.label.setVisible(this.visible && visible);\n    } }]);return PointMarker;}(Label3D);export { PointMarker as default };\n;\n\nPointMarker.Events = Label3D.Events;\nPointMarker.Icons = Icons;","function _typeof(obj) {\"@babel/helpers - typeof\";if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;};}return _typeof(obj);}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError(\"Cannot call a class as a function\");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}function _inherits(subClass, superClass) {if (typeof superClass !== \"function\" && superClass !== null) {throw new TypeError(\"Super expression must either be null or a function\");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}function _createSuper(Derived) {var hasNativeReflectConstruct = _isNativeReflectConstruct();return function _createSuperInternal() {var Super = _getPrototypeOf(Derived),result;if (hasNativeReflectConstruct) {var NewTarget = _getPrototypeOf(this).constructor;result = Reflect.construct(Super, arguments, NewTarget);} else {result = Super.apply(this, arguments);}return _possibleConstructorReturn(this, result);};}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");}return self;}function _isNativeReflectConstruct() {if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;if (Reflect.construct.sham) return false;if (typeof Proxy === \"function\") return true;try {Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));return true;} catch (e) {return false;}}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}import NPointPicker from './NPointPicker.js';\n\n// Controls the user interaction workflow for aligning a model based on two selected points\n\n// Extend NPointPicker events.\nvar Events = Object.assign({}, NPointPicker.Events, {\n  FROM_POINT_SELECTED: 'fromPointSelected',\n  TO_POINT_SELECTED: 'toPointSelected',\n  FROM_POINT_HOVERED: 'fromPointHovered',\n  TO_POINT_HOVERED: 'toPointHovered' });\n\n\n// Implements the interaction to select two points: A 'fromPoint' and a 'toPoint'.\nvar TwoPointPicker = /*#__PURE__*/function (_NPointPicker) {_inherits(TwoPointPicker, _NPointPicker);var _super = _createSuper(TwoPointPicker);\n\n  function TwoPointPicker(viewer, coordPicker, screenOverlay, options) {var _this;_classCallCheck(this, TwoPointPicker);\n    _this = _super.call(this, viewer, coordPicker, screenOverlay, 2, options);\n\n    _this.addEventListener(NPointPicker.Events.POINT_SELECTED, function (_ref) {var point = _ref.point,index = _ref.index;\n      if (index === 0) {\n        _this.fireEvent({ type: Events.FROM_POINT_SELECTED, point: point });\n      } else {\n        _this.fireEvent({ type: Events.TO_POINT_SELECTED, point: point });\n      }\n    });\n\n    _this.addEventListener(NPointPicker.Events.POINT_HOVERED, function (_ref2) {var point = _ref2.point,index = _ref2.index;\n      if (index === 0) {\n        _this.fireEvent({ type: Events.FROM_POINT_HOVERED, point: point });\n      } else {\n        _this.fireEvent({ type: Events.TO_POINT_HOVERED, point: point });\n      }\n    });return _this;\n  }_createClass(TwoPointPicker, [{ key: \"setOffset\", value: function setOffset(\n\n    offset) {\n      this.offset.copy(offset);\n    } }, { key: \"startSelectFrom\", value: function startSelectFrom()\n\n    {\n      this.startSelectPoint(0);\n    } }, { key: \"startSelectTo\", value: function startSelectTo()\n\n    {\n      this.startSelectPoint(1);\n    } }]);return TwoPointPicker;}(NPointPicker);export { TwoPointPicker as default };\n\n\nTwoPointPicker.Events = Events;"],"mappings":";;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AClFA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACvSA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC1CA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACzJA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACpOA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACnfA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC3DA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;A","sourceRoot":""}