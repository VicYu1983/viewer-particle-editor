{"version":3,"sources":["webpack://Autodesk.Extensions.[name]/webpack/bootstrap","webpack://Autodesk.Extensions.[name]/./extensions/Edit3D/Gizmo3D.js","webpack://Autodesk.Extensions.[name]/./extensions/Edit3D/Label3D.js","webpack://Autodesk.Extensions.[name]/./extensions/Edit3D/PointMarker.js","webpack://Autodesk.Extensions.[name]/./extensions/Edit3D/CoordPicker.js","webpack://Autodesk.Extensions.[name]/./extensions/Edit3D/NPointPicker.js","webpack://Autodesk.Extensions.[name]/./extensions/Edit3D/TwoPointPicker.js","webpack://Autodesk.Extensions.[name]/./extensions/Edit3D/Edit3D.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","nextId","Gizmo3D","viewer","pixelSize","pos","overlayName","this","scene","THREE","Scene","shape","onCameraChange","addEventListener","Autodesk","Viewing","CAMERA_CHANGE_EVENT","matrixAutoUpdate","overlayOwned","id","impl","createOverlayScene","visible","setPosition","x","y","z","position","copy","set","matrixWorldNeedsUpdate","update","removeEventListener","removeOverlayScene","remove","clearShape","add","color","radius","widthSegments","heightSegments","geometry","SphereGeometry","material","MeshPhongMaterial","Mesh","setShape","BoxGeometry","addOverlay","removeOverlay","invalidate","dist","camera","distanceTo","worldToPixelScale","pixelsPerUnitAtDistance","scale","av","avp","Private","Events","DRAG_START","DRAG_END","Label3D","EventDispatcher","pos3D","Vector3","text","pos2D","draggable","setGlobalManager","globalManager","cameraChangeCb","VIEWER_RESIZE_EVENT","document","canvasWrap","ownerDocument","container","createElement","appendChild","setOpacity","style","opacity","opacityParam","AnimatedParam","fadeTo","left","top","pointerEvents","textDiv","setText","worldBox","minPixels","setVisible","onMouseDown","p1","min","p2","max","p1Screen","worldToClient","p2Screen","dx","dy","Math","sqrt","box","classList","initTextLabel","textContent","i18n","translate","transform","hidden","shouldBeHidden","changeContainerVisibility","show","styleHidden","display","window","setTimeout","dtor","animTime","offset","event","cursor","toolController","__clientToCanvasCoords","fireEvent","type","addDocumentEventListener","handleMouseUp","e","onMouseUp","removeDocumentEventListener","GlobalManagerMixin","createIcon","icon","join","Icons","Cross","Circle","Empty","PointMarker","labelText","innerHTML","label","setVerticalOffset","labelVisible","ToolName","POINT_CLICKED","POINT_HOVERED","ESCAPE","CoordPicker","snapper","onCameraChanged","apply","selectionPlane","enableSnapper","snapperActive","isDragging","keyMap","SnapKey","KeyCode","SHIFT","canvasPos","Vector2","tmpPoint","tmpMatrix3","Matrix3","lastHit","consumeClickEvents","snapFilter","setCursor","plane","active","activateTool","getName","deactivateTool","enabled","snapperOn","snapperOff","setSnapFilter","pauseHighlight","canvasX","canvasY","trackMousePos","onMouseMove","indicator","render","result","getHitResultUnderMouse","point","normal","modelId","dbId","isSnapped","hitResult","getSnapResult","MeasureCommon","getSnapResultPosition","faceNormal","snapNode","hitTest","face","mesh","getRenderProxy","model","fragId","normalMatrix","getNormalMatrix","matrixWorld","clone","applyMatrix3","normalize","projectPoint","button","handleMouseMove","keyCode","BACKSPACE","DELETE","onSnappingToggled","Name","POINT_SELECTED","POINT_SELECTION_STARTED","CLEAR","Colors","Blue","Red","Black","White","ConnectorTypes","Line","Arrow","NPointPicker","coordPicker","screenOverlay","N","options","selectingIndex","lastSelectedPoint","onPointClicked","onPointHovered","cancelPointSelection","points","pointValid","markers","showMarkers","Array","fill","push","colors","labels","undefined","icons","marker","startSelectPoint","onDragEnded","setColor","labelStyles","keys","forEach","connectionsData","connections","connectors","connectionData","lineStyle","Edit2D","Style","lineWidth","lineColor","gizmo","attachableObject","setFrom","setTo","ScreenOverlay","Line3DGizmo","line2D","a","b","console","warn","Arrow3DGizmo","arrow","line","head","fillColor","setHeadLength","setHeadAngle","getEdgeLabelText","EdgeLabel","layer","attachToEdge","labelStyle","fromIndex","toIndex","length","stops","onModelTransformChanged","modelsToPointsMap","MODEL_TRANSFORM_CHANGED_EVENT","index","enableDrag","pointBackup","isToolActivated","setDragging","setMarkersDraggable","getDragging","handleSingleClick","isActive","continuePointSelectionIfNeeded","updateGizmos","skipFade","setGizmoVisible","fadeOutGizmo","connector","showGizmo","updateGizmoVisibility","setPoint","pickAnother","setIsLocked","pivot","dirty","includes","enable","setDraggable","isPickerActive","setModelsToPointsMap","assign","map","ids","matrix","findModel","Number","getModelTransform","LmvMatrix4","hasEventListener","pointIndexes","previousMatrix","diffMatrix","getInverse","multiplyMatrices","applyMatrix4","FROM_POINT_SELECTED","TO_POINT_SELECTED","FROM_POINT_HOVERED","TO_POINT_HOVERED","TwoPointPicker","namespace","AutodeskNamespace","Edit3DExtension","Extension","theExtensionManager","registerExtension"],"mappings":"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","file":"Edit3D/Edit3D.min.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 842);\n","\nlet nextId = 1;\n\n// Helper class for displaying a 3D shape that is scaled to keep approximately constant screen-size.\n// Example:\n//   const gizmo = new Gizmo3D(viewer).makeCube();\n//   gizmo.setPosition(10, 10, 10);\n//   gizmo.setVisible(true);\nexport default class Gizmo3D {\n\n    // @param {Viewer3d} viewer\n    // @param {number}   [pixelSize]   - Size of the gizmo in pixels\n    // @param {Vector3}  [pos]         - Initial position. Default (0,0,0)\n    // @param {string}   [overlayName] - Name of an (existing) viewer overlay used to display the gizmo. If not specified, the Gizmo creates its own.\n    constructor(viewer, pixelSize = 30, pos = null, overlayName = null) {\n\n        this.viewer = viewer;\n\n        // The shape is auto-scaled in a way that the projected screen-size of the unitBox diagonal\n        // keeps equal to this value. \n        this.pixelSize = pixelSize;\n\n        // Container for the gizmo shape. Matrix of this scene is controlled by the gizmo\n        this.scene = new THREE.Scene();\n\n        // Shape or scene to be displayed. BBox should be the unit box [-0.5, 0.5]^2, so that\n        // uto-scaling works properly.\n        this.shape = null;\n\n        // Connect event listener\n        this.onCameraChange = this.onCameraChange.bind(this);\n        this.viewer.addEventListener(Autodesk.Viewing.CAMERA_CHANGE_EVENT, this.onCameraChange);\n\n        // Make sure that matrix is recomputed after position/scale changes.\n        this.scene.matrixAutoUpdate = true;\n\n        // Overlay name that we use to display the gizmo\n        this.overlayName = overlayName;\n\n        // create own overlay if none specified\n        this.overlayOwned = !overlayName;\n        if (this.overlayOwned) {\n            this.overlayName = `Gizmo3D_Overlay_${this.id}`;\n            this.viewer.impl.createOverlayScene(this.overlayName);\n        }\n\n        this.visible = false;\n\n        this.id = nextId++;\n\n        if (pos) {\n            this.setPosition(pos);\n        }\n    }\n\n    setPosition(x, y, z) {\n    \n        // Suppoer call with single Vec3 param\n        if ((typeof x) === 'object') {\n            this.scene.position.copy(x);\n        } else {\n            this.scene.position.set(x, y, z);\n        }\n        this.scene.matrixWorldNeedsUpdate;\n\n        this.update();\n\n        return this;\n    }\n\n    dtor() {\n        this.viewer.removeEventListener(Autodesk.Viewing.CAMERA_CHANGE_EVENT, this.onCameraChange);\n\n        if (this.overlayOwned) {\n            this.viewer.impl.removeOverlayScene(this.overlayName);\n        }\n    }\n\n    clearShape() {\n        if (this.shape) {\n            this.scene.remove(this.shape);\n            this.shape = null;\n        }\n    }\n\n    // Set a gizmo shape to display. Must be scaled to unitBox.\n    setShape(shape) {\n        this.clearShape();\n        this.shape = shape;\n        this.scene.add(shape);\n        return this;\n    }\n\n    // Set shape to sphere\n    makeSphere(color = 0xff0000) {\n\n        // create sphere mesh, centered at (0,0,0) \n        const radius = 0.5;\n        const widthSegments  = 22;\n        const heightSegments = 16; \n        const geometry = new THREE.SphereGeometry(radius, widthSegments, heightSegments);\n        const material = new THREE.MeshPhongMaterial( { color } );\n        const shape = new THREE.Mesh(geometry, material);\n\n        return this.setShape(shape);\n    }\n\n    makeCube(color = 0xff0000) {\n\n        // create box mesh of edgeLength 1, centered at (0,0,0)\n        const geometry = new THREE.BoxGeometry(1, 1, 1);\n        const material = new THREE.MeshPhongMaterial( { color } );\n        const shape = new THREE.Mesh(geometry, material);\n        return this.setShape(shape);\n    }\n\n    setVisible(visible) {\n        if (this.visible == visible) {\n            return;\n        }\n\n        if (visible) {\n            this.viewer.impl.addOverlay(this.overlayName, this.scene);\n        } else {\n            this.viewer.impl.removeOverlay(this.overlayName, this.scene);\n        }\n\n        this.visible = visible;\n\n        // trigger overlay update\n        this.viewer.impl.invalidate(false, false, true);\n\n        return this;\n    }\n\n    update() {\n        // compute screenSize that we get with scaling 1.0\n        const dist = this.viewer.impl.camera.position.distanceTo(this.scene.position);\n        const worldToPixelScale = this.viewer.impl.camera.pixelsPerUnitAtDistance(dist);\n\n        // compute and apply scale in world-space\n        const scale = this.pixelSize / worldToPixelScale;\n        this.scene.scale.set(scale, scale, scale);\n\n        // make sure that scale changes takes effect \n        this.scene.matrixWorldNeedsUpdate = true;\n\n        this.viewer.impl.invalidate(false, false, true);\n    }\n\n    // On camera changes, update scaling to keep constant pixel-size\n    onCameraChange() {\n        this.update();\n    }\n}\n","\nconst av = Autodesk.Viewing;\nconst avp = Autodesk.Viewing.Private;\n\n// Given two points p1, p2 in worldSpace, this function computes\n// the pixel distance of their screen projections.\nconst getPixelDistance = (viewer, p1, p2) => {\n\n    const p1Screen = viewer.impl.worldToClient(p1);\n    const p2Screen = viewer.impl.worldToClient(p2);\n\n    const dx = p2Screen.x - p1Screen.x;\n    const dy = p2Screen.y - p1Screen.y;\n    return Math.sqrt(dx * dx + dy * dy);\n}\n\nconst Events = {\n    DRAG_START: \"dragStart\",\n    DRAG_END: \"dragEnd\",\n};\n\n// A Label3D is an html div whose position is synchronized with a fixed world-space position in LMV.\nexport default class Label3D extends Autodesk.Viewing.EventDispatcher {\n\n    // @param {Viewer3D}      viewer\n    // @param {THREE.Vector3} [pos3D] - By default (0,0,0). Can be set later by changing this.pos3D.\n    // @param {string}        [text]  - If undefined, label will be empty/invisible by default and you have to configure this.container yourself.\n    constructor(viewer, pos3D = new THREE.Vector3(), text = '<Empty>') {\n        super();\n        this.viewer = viewer;\n        this.pos3D = pos3D;\n        this.pos2D = new THREE.Vector3(); // updated automatically. z is the depth value\n        this.draggable = false;\n\n        this.setGlobalManager(viewer.globalManager);\n\n        // keep position in-sync with camera changes\n        this.cameraChangeCb = this.update.bind(this);\n        this.viewer.addEventListener(av.CAMERA_CHANGE_EVENT, this.cameraChangeCb);\n        this.viewer.addEventListener(av.VIEWER_RESIZE_EVENT, this.cameraChangeCb);\n\n        // Create container\n        const document = viewer.canvasWrap.ownerDocument; // (might be != global document in popout scenarios)\n        this.container = document.createElement('div');\n\n        // Note: It's essential that we add it to viewer.canvasWrap instead of viewer.container:\n        //       ToolController listens to events on canvasWrap. Therefore, if we would add\n        //       it to viewer.container, all mouse events captured would never reach the ToolController\n        //       no matter whether the gizmo handles them or not.\n        viewer.canvasWrap.appendChild(this.container);\n\n        // For fadeIn/Out effects\n        const setOpacity = t => {\n            this.container.style.opacity = t;\n        };\n        this.opacityParam = new avp.AnimatedParam(0.0, setOpacity, 0.5);\n\n        // Initial fade-in\n        this.opacityParam.fadeTo(1.0);\n\n        // We control position via transform. So, left/top usually keep (0,0)\n        this.container.style.left = '0px';\n        this.container.style.top = '0px';\n        this.container.style.position = 'absolute';\n        this.container.style.pointerEvents = 'none';\n\n        // Only used for text labels\n        this.textDiv = null;\n        if (text) {\n            this.setText(text);\n        }\n\n        // Level-of-detail (optional)\n        this.worldBox = null;\n        this.minPixels = 0;\n\n        // Update position and fade-in\n        this.setVisible(true);\n\n        this.onMouseDown = this.onMouseDown.bind(this);\n    }\n\n    // Decides if the label should be shown or hidden.\n    // We hide the label the projected box diagonal falls below this.minPixels.\n    shouldBeHidden() {\n        if (!this.worldBox) {\n            return false;\n        }\n\n        const boxSizeScreen = getPixelDistance(this.viewer, this.worldBox.min, this.worldBox.max);\n        return boxSizeScreen < this.minPixels;\n    }\n\n    // Optional: WorldBox of the annotated object. Used for level-of-detail: We only show the label\n    //           if the projected screen-size of the box is >= a given minimum pixel size.\n    // @param {Box3}   worldBox\n    // @param {number} minPixels\n    setWorldBox(box, minPixels) {\n        this.worldBox  = box;\n        this.minPixels = minPixels;\n        this.update(); // hide this label immediately if projected world-box is very small\n    }\n\n    // Configure this label to display text\n    initTextLabel() {\n\n        // Create textDiv child div\n        const document = this.viewer.container.ownerDocument;\n        this.textDiv = document.createElement('div');\n        this.container.appendChild(this.textDiv);\n\n        // Use measure-tool styles by default\n        this.container.classList.add('measure-length');\n        this.container.classList.add('visible');\n        this.textDiv.classList.add('measure-length-text');\n    }\n\n    setText(text) {\n        if (!this.textDiv) {\n            this.initTextLabel();\n        }\n        this.textDiv.textContent = Autodesk.Viewing.i18n.translate(text);\n    }\n\n    dtor() {\n        this.container.remove();\n        this.viewer.removeEventListener(av.CAMERA_CHANGE_EVENT, this.cameraChangeCb);\n        this.viewer.removeEventListener(av.VIEWER_RESIZE_EVENT, this.cameraChangeCb);\n    }\n\n    // To change the position, just modify this.pos3D directly and call update().\n    update() {\n        // Get canvas position corresponding to this.pos3D\n        const {x, y} = this.viewer.impl.worldToClient(this.pos3D);\n\n        // Transform the div, so that its center is anchored in (x,y)\n        this.container.style.transform = `translate(calc(${x}px - 50%), calc(${y}px - 50%))`;\n\n        // Hide label if the annotated object is small on screen\n        const hidden = !this.visible || this.shouldBeHidden();\n\n        // If the label should be visible, immediately restore the container visibility, so the fade-in will be displayed.\n        if (!hidden) {\n            this.changeContainerVisibility(!hidden);\n        }\n\n        // this.opacityParam.skipAnim();\n        this.opacityParam.fadeTo(hidden ? 0.0 : 1.0, () => {\n            // If the label should be hidden, change container visibility only after the fade-out animation finished.\n            // This is needed in order that the element won't be touchable while hidden.\n            this.changeContainerVisibility(!hidden);\n        });\n    }\n\n    // Necessary in addition to the opacity change, in order to remove from the DOM rendering.\n    changeContainerVisibility(show) {\n        if (!show && !this.styleHidden) {\n            this.styleHidden = true;\n            this.container.style.display = 'none';\n        } else if (show && this.styleHidden) {\n            this.styleHidden = false;\n            this.container.style.display = 'block';\n        }\n    }\n\n    setPosition(pos) {\n        this.pos3D.copy(pos);\n        this.update();\n    }\n\n    setVisible(visible) {\n        this.visible = visible;\n        this.update();\n    }\n\n    // Fade out and dispose label when done\n    dispose() {\n        this.setVisible(false);\n\n        // Make sure that we clean up when fading is done.\n        window.setTimeout(()=>this.dtor(), 1000 * this.opacityParam.animTime);\n    }\n\n    // @param {number} offset - Optional: Vertical offset in screen-pixels. Positive values shift down.\n    setVerticalOffset(offset) {\n        this.container.style.top = offset + 'px';\n    }\n\n    onMouseDown(event) {\n        this.container.style.cursor = \"grabbing\";\n\n        this.viewer.toolController.__clientToCanvasCoords(event);\n\n        this.fireEvent({ type: Events.DRAG_START, event });\n\n        const handleMouseUp = (e) => {\n            this.onMouseUp(e);\n            this.removeDocumentEventListener(\"mouseup\", handleMouseUp);\n        };\n\n        this.addDocumentEventListener(\"mouseup\", handleMouseUp);\n    }\n\n    onMouseUp(event) {\n        this.container.style.cursor = \"grab\";\n\n        this.viewer.toolController.__clientToCanvasCoords(event);\n\n        this.fireEvent({ type: Events.DRAG_END, event });\n    }\n\n    setDraggable(draggable) {\n        if (draggable && !this.draggable) {\n            this.container.addEventListener(\"mousedown\", this.onMouseDown);\n            this.container.style.cursor = \"grab\";\n            this.container.style.pointerEvents = 'auto';\n        } else if (!draggable && this.draggable) {\n            this.container.removeEventListener(\"mousedown\", this.onMouseDown);\n            this.container.style.cursor = \"\";\n            this.container.style.pointerEvents = 'none';\n        }\n\n        this.draggable = draggable;\n    }\n}\n\nav.GlobalManagerMixin.call(Label3D.prototype);\n\nLabel3D.Events = Events;\n","\nimport Label3D from './Label3D.js'; \n\nconst createIcon = (icon) => {\n    return [\n        '<svg width=\"50\" height=\"50\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\">',\n            '<g stroke-width=\"2\" stroke=\"currentColor\" fill=\"none\">',\n                icon,\n            '</g>',\n        '</svg>'\n    ].join('');\n};\n\nconst Icons = {\n    Cross: '<path d=\"M0 25 L50 25 M25 0 L25 50\"/>',\n    Circle: '<circle r=\"5\" cx=\"25\" cy=\"27.5\" fill=\"currentColor\" stroke-width=\"0\" />',\n    Empty: ''\n};\n\nexport default class PointMarker extends Label3D {\n\n    constructor(viewer, pos3D, labelText, icon = Icons.Cross) {\n        super(viewer, pos3D, null);\n\n        this.container.innerHTML = createIcon(icon);\n    \n        // Create another label for the text\n        if (labelText) {\n            this.label = new Label3D(viewer, pos3D, labelText);\n\n            // Center text above the actual position\n            this.label.setVerticalOffset(-45); \n        }\n\n        // Set label visible by default. If text is empty, it is hidden anyway. \n        this.labelVisible = true;\n    }\n\n    // @param {string} Color string in css style (e.g. 'rgb(255, 255, 255)');\n    setColor(color) {\n        this.container.style.color = color;\n    }\n\n    setPosition(pos) {\n        super.setPosition(pos);\n        this.label && this.label.setPosition(pos);\n    }\n\n    setVisible(visible) {\n        super.setVisible(visible);\n        this.label && this.label.setVisible(this.labelVisible && visible);\n    }\n\n    setLabelVisible(visible) {\n        this.label && this.label.setVisible(this.visible && visible);\n    }\n};\n\nPointMarker.Events = Label3D.Events;\nPointMarker.Icons = Icons;","const ToolName = 'ModelAlignment.CoordPicker';\n\nconst Events = {\n    POINT_CLICKED: 'pointClicked',\n    POINT_HOVERED: 'pointHovered', // point param may be undefined if no object was hit at the current mouse position \n    ESCAPE: 'escape'\n};\n\nexport default class CoordPicker {\n\n    constructor(viewer, snapper) {\n        this.viewer = viewer;\n        this.snapper = snapper;\n\n        // Bind function so that we can use it for event listeners\n        this.onCameraChanged = this.onCameraChanged.bind(this);\n\n        Autodesk.Viewing.EventDispatcher.prototype.apply(this);\n\n        // Optional: If a plane is set, we select points on this plane instead of the model \n        this.selectionPlane = null;\n\n        this.enableSnapper = true;\n        this.snapperActive = false;\n        this.isDragging = false;\n\n        this.keyMap = {\n            SnapKey: Autodesk.Viewing.KeyCode.SHIFT, // Holding this key suppresses snapping\n        };\n\n        // Track last mouse position in canvas coords. Note that derived classes must call\n        // the base class mouse handlers to keep this value valid.\n        this.canvasPos = new THREE.Vector2();\n\n        this.tmpPoint = new THREE.Vector3();\n        this.tmpMatrix3 = new THREE.Matrix3();\n\n        // Last successful hit under mouse.\n        this.lastHit = null;\n        this.consumeClickEvents = true;\n\n        this.snapFilter = null; // Optional snapping filter, based on snapResult. (snapResult) => boolean.\n\n        // Set default cursor.\n        this.setCursor();\n    }\n\n    // @param {THREE.Plane} [plane] - If a plane is set, we are selecting points on that plane instead of the model. \n    setSelectionPlane(plane) {\n        this.selectionPlane = plane;\n    }\n\n    getName() {\n        return ToolName;\n    }\n\n    getNames() {\n        return [ToolName];\n    }\n\n    setCursor(cursor) {\n        this.cursor = cursor ? cursor : 'crosshair';\n    }\n\n    getCursor() {\n        return this.isDragging ? 'grabbing' : (this.active && this.lastHit ? this.cursor : null);\n    }\n\n    snapperOn() {\n        if (!this.snapperActive) {\n            this.viewer.toolController.activateTool(this.snapper.getName());\n            this.snapperActive = true;\n        }\n    }\n\n    snapperOff() {\n        if (this.snapperActive) {\n            this.viewer.toolController.deactivateTool(this.snapper.getName());\n            this.snapperActive = false;\n        }\n    }\n    \n    setSnapperEnabled(enabled) {\n        this.enableSnapper = enabled;\n        if (enabled) {\n            this.snapperOn();\n        } else {\n            this.snapperOff();\n        }\n    }\n\n    setSnapFilter(snapFilter) {\n        this.snapFilter = snapFilter;\n        this.snapper.setSnapFilter(snapFilter);\n    }\n\n    activate() {\n        this.active = true;\n\n        if (this.enableSnapper) {\n            this.snapperOn();\n        }\n\n        this.viewer.addEventListener(Autodesk.Viewing.CAMERA_CHANGE_EVENT, this.onCameraChanged);\n        this.viewer.impl.pauseHighlight(true);\n    }\n\n    deactivate() {\n        this.active = false;\n        this.isDragging = false;\n        this.lastHit = null;\n\n        this.snapperOff();\n\n        this.viewer.removeEventListener(Autodesk.Viewing.CAMERA_CHANGE_EVENT, this.onCameraChanged);\n        this.viewer.impl.pauseHighlight(false);\n    }\n\n    register() { }\n    \n    // Remember last mouse position\n    trackMousePos(e) {\n        this.canvasPos.set(e.canvasX, e.canvasY);\n    }\n\n    handleMouseMove(event) {\n        this.trackMousePos(event);\n\n        // Make sure that snapping result is up-to-date\n        this.snapper.onMouseMove({ x: event.canvasX, y: event.canvasY });\n\n        if (this.snapper.indicator) {\n            this.snapper.indicator.render();\n        }\n\n        // Note that we always fire, even if hit is undefined. This is needed to clear indicators and edit \n        // values if the mouse is not on an object anymore.\n        const result = this.getHitResultUnderMouse(event);\n        this.fireEvent({ type: Events.POINT_HOVERED, ...result });\n\n        return this.isDragging;\n    }\n\n    // Returns hitPoint under mouse or null if no object under mouse.\n    getHitResultUnderMouse(event) {\n\n        let point = null;\n        let normal = null;\n        let modelId = null;\n        let dbId = null;\n\n        if (this.snapperActive && this.snapper.isSnapped()) {\n            // Get snapped position.\n            const hitResult = this.snapper.getSnapResult();\n            point = Autodesk.Viewing.MeasureCommon.getSnapResultPosition(hitResult, this.viewer);\n            normal = hitResult?.faceNormal;\n            modelId = hitResult?.modelId;\n            dbId = hitResult?.snapNode;\n        } else {\n            // When snapper is not active, or no point resulted, perform a simple hit test.\n            const hitResult = this.viewer.impl.hitTest(event.canvasX, event.canvasY);\n            point = hitResult?.point;\n\n            // Extract normal\n            if (hitResult?.face?.normal) {\n                const mesh = this.viewer.impl.getRenderProxy(hitResult.model, hitResult.fragId);\n                const normalMatrix = this.tmpMatrix3.getNormalMatrix(mesh.matrixWorld);\n                normal = hitResult.face.normal.clone().applyMatrix3(normalMatrix).normalize();\n            }\n\n            modelId = hitResult?.model?.id;\n            dbId = hitResult?.dbId;\n        }\n\n        if (this.snapFilter && !this.snapFilter({ modelId })) {\n            point = null;\n            normal = null;\n            modelId = null;\n            dbId = null;\n        }\n\n        // If selection plane is set, project the hit point on the plane.\n        if (point && this.selectionPlane) {\n            point = this.selectionPlane.projectPoint(point, this.tmpPoint);\n        }\n\n        const result = { point, normal, modelId, dbId };\n\n        // Update lastHit only if we have an actual hit.\n        this.lastHit = point ? result : null;\n\n        return result;\n    }\n\n    setConsumeClickEvents(consumeClickEvents) {\n        this.consumeClickEvents = consumeClickEvents;\n    }\n\n    handleSingleClick(event, button) {\n        this.trackMousePos(event);\n\n        // Only respond to left button\n        if (button !== 0) {\n            return false;\n        }\n\n        const result = this.getHitResultUnderMouse(event);\n        \n        this.fireEvent({ type: Events.POINT_CLICKED, ...result });\n\n        return this.consumeClickEvents;\n    }\n\n    handleDoubleClick(event) {\n        this.trackMousePos(event);\n    }\n\n    handleButtonDown(event) {\n        this.trackMousePos(event);\n\n        // In case of start dragging, make sure to turn on the snapper first.\n        if (this.isDragging) {\n            this.snapperOn();\n        }\n\n        return this.handleMouseMove(event);\n    }\n\n    handleButtonUp(event) {\n        this.trackMousePos(event);\n        return this.isDragging;\n    }\n\n    // Simulate mouse move instantly when snapper is being toggled.\n    onSnappingToggled() {\n        this.handleMouseMove({\n          canvasX: this.canvasPos.x,\n          canvasY: this.canvasPos.y,\n        });\n    }\n\n    handleKeyDown(event, keyCode) {\n        switch (keyCode) {\n            case Autodesk.Viewing.KeyCode.BACKSPACE:\n            case Autodesk.Viewing.KeyCode.DELETE:\n            case Autodesk.Viewing.KeyCode.ESCAPE:\n                this.fireEvent({ type: Events.ESCAPE });\n                return true;\n            case this.keyMap.SnapKey:\n                if (this.snapperActive) {\n                    this.snapperOff();\n                    this.onSnappingToggled();\n                    return true;\n                }\n                return false;\n            default:\n                break;\n        }\n\n        return false;\n    }\n\n\n    handleKeyUp(event, keyCode) {\n        switch (keyCode) {\n            case this.keyMap.SnapKey:\n                if (!this.snapperActive && this.enableSnapper) {\n                    this.snapperOn();\n                    this.onSnappingToggled();\n                  return true;\n                }\n                return false;\n            default:\n                break;\n        }\n\n        return false;\n    }\n\n    onCameraChanged() {\n        if (this.snapper.indicator) {\n            this.snapper.indicator.render();\n        }\n    }\n\n    setDragging(isDragging) {\n        this.isDragging = isDragging;\n    }\n\n    getDragging() {\n        return this.isDragging;\n    }\n}\n\nCoordPicker.Events = Events;\nCoordPicker.Name = ToolName;\n","import CoordPicker from \"./CoordPicker.js\";\nimport PointMarker from \"./PointMarker.js\";\n\n// Controls the user interaction workflow for picking N points\n\nconst Events = {\n    POINT_SELECTED: \"pointSelected\",\n    POINT_HOVERED: \"pointHovered\",\n    POINT_SELECTION_STARTED: \"pointSelectionStarted\",\n    CLEAR: \"clear\",\n};\n\nconst Colors = {\n    Blue: \"rgb(6, 150, 215)\", // adskBlue500\n    Red: \"rgb(236, 74, 65)\", // red500\n    Black: \"rgb(0,0,0)\",\n    White: \"rgb(255,255,255)\",\n};\n\nconst ConnectorTypes = {\n    Line: \"line\",\n    Arrow: \"arrow\",\n};\n\n// N point picker - allows picking N points.\n//  @param {Viewer3D}      viewer\n//  @param {CoordPicker}   coordPicker\n//  @param {ScreenOverlay} screenOverlay\n//  @param {number}        N - number of points to select\n//  @param {Object}        [options]\n//  @param {Boolean}          [options.draggable] -      Whether points are draggable or not\n//  @param {String[]}      [options.colors] -         Array of colors\n//  @param {String[]}      [options.labels] -         Array of labels\n//  @param {String[]}      [options.icons] -          Array of icons\n//  @param {Object[]}      [options.connections] -    Array of point connections metadata.\n//  @param {Object[]}      [options.stops] -          Array of point indexes that the tool shouldn't automatically continue positioning new points after them.\nexport default class NPointPicker {\n    constructor(viewer, coordPicker, screenOverlay, N, options = {}) {\n        this.viewer = viewer;\n        this.options = options;\n        this.coordPicker = coordPicker;\n        this.N = N;\n\n        Autodesk.Viewing.EventDispatcher.prototype.apply(this);\n\n        // Current active point - the one that is currently being picked or hovered.\n        this.selectingIndex = -1;\n        \n        // Last valid point that was selected. Drag an exising previous point won't change this value.\n        this.lastSelectedPoint = -1;\n\n        this.coordPicker.addEventListener(\n            CoordPicker.Events.POINT_CLICKED,\n            (event) => this.onPointClicked(event)\n        );\n        this.coordPicker.addEventListener(\n            CoordPicker.Events.POINT_HOVERED,\n            (event) => this.onPointHovered(event)\n        );\n        this.coordPicker.addEventListener(CoordPicker.Events.ESCAPE, () => {\n            // Reset point only when dragging.\n            if (this.coordPicker.isDragging) {\n                this.cancelPointSelection();\n            }\n        });\n\n        this.points = [];\n        this.pointValid = [];\n        this.markers = [];\n        this.showMarkers = this.options.showMarkers || new Array(this.N).fill(true); // If showMarkers array is not supplied, default to true.\n\n        for (let i = 0; i < this.N; i++) {\n            this.points.push(new THREE.Vector3());\n            this.pointValid.push(false);\n            const color = options.colors ? options.colors[i] : Colors.Blue;\n            const label = options.labels ? options.labels[i] : undefined;\n            const icon = options.icons ? options.icons[i] : undefined;\n            const marker = new PointMarker(this.viewer, undefined, label, icon);\n            this.markers.push(marker);\n\n            if (this.options.draggable) {\n                marker.addEventListener(PointMarker.Events.DRAG_START, () =>\n                    this.startSelectPoint(i, true)\n                );\n                marker.addEventListener(PointMarker.Events.DRAG_END, (event) =>\n                    this.onDragEnded(event)\n                );\n            }\n\n            // Hide the markers until we have valid from/to point\n            marker.setVisible(false);\n            marker.setColor(color);\n\n            // Custom label style\n            if (options.labelStyles && options.labelStyles[i]) {\n                Object.keys(options.labelStyles[i]).forEach((key) => {\n                    marker.label.container.style[key] = options.labelStyles[i][key];\n                });\n            }\n        }\n\n        // {Autodesk.Edit2D.ScreenOverlay}\n        this.screenOverlay = screenOverlay;\n\n        const connectionsData = this.options.connections || [];\n        this.connectors = [];\n\n        for (let i = 0; i < connectionsData.length; i++) {\n            const connectionData = connectionsData[i];\n\n            // Configure style of line/arrow connection\n            const lineStyle = new Autodesk.Edit2D.Style({\n                lineStyle: 10,\n                lineWidth: 1.5,\n                lineColor: connectionData.color || Colors.Blue,\n            });\n\n            let gizmo;\n            let attachableObject;\n            let setFrom;\n            let setTo;\n\n            if (connectionData.type === ConnectorTypes.Line) {\n                // Dashed line connecting from/to point\n                gizmo = new Autodesk.Edit2D.ScreenOverlay.Line3DGizmo();\n                gizmo.line2D.style.copy(lineStyle);\n\n                // Define attachable object for the label\n                attachableObject = gizmo.line2D;\n\n                // Define position setters\n                setFrom = gizmo.a.copy.bind(gizmo.a);\n                setTo = gizmo.b.copy.bind(gizmo.b);\n            } else if (connectionData.type === ConnectorTypes.Arrow) {\n                // Dashed arrow connecting from/to point\n                gizmo = new Autodesk.Edit2D.ScreenOverlay.Arrow3DGizmo();\n                gizmo.arrow.line.style.copy(lineStyle);\n                gizmo.arrow.head.style.fillColor = lineStyle.lineColor;\n                gizmo.arrow.setHeadLength(18); // in pixels, because layer is screen-aligned\n                gizmo.arrow.setHeadAngle(40); // in degrees\n\n                // Define attachable object for the label\n                attachableObject = gizmo.arrow.line;\n\n                // Define position setters\n                setFrom = gizmo.setFrom.bind(gizmo);\n                setTo = gizmo.setTo.bind(gizmo);\n            } else {\n                console.warn(\"Invalid connector type.\");\n                continue;\n            }\n\n            let label;\n\n            if (connectionData.getEdgeLabelText) {\n                label = new Autodesk.Edit2D.EdgeLabel(screenOverlay.layer);\n                label.attachToEdge(attachableObject, 0, 0);\n\n                // Custom label style\n                if (connectionData.labelStyle) {\n                    Object.keys(connectionData.labelStyle).forEach((key) => {\n                        label.container.style[key] = connectionData.labelStyle[key];\n                    });\n                }\n            }\n\n            this.connectors.push({\n                fromIndex: connectionData.fromIndex,\n                toIndex: connectionData.toIndex,\n                getEdgeLabelText: connectionData.getEdgeLabelText,\n                gizmo,\n                label,\n                setFrom,\n                setTo,\n            });\n        }\n\n        this.visible = true;\n\n        this.stops = this.options.stops || [];\n\n        this.onModelTransformChanged = this.onModelTransformChanged.bind(this);\n\n        this.modelsToPointsMap = {}; // { modelId: [indexes] }\n    }\n\n    dtor() { \n        this.viewer.removeEventListener(Autodesk.Viewing.MODEL_TRANSFORM_CHANGED_EVENT, this.onModelTransformChanged);\n    }\n\n    startSelectPoint(index, enableDrag) {\n        // Backup current point's position in case the drag won't be valid. In this case, we'll restore the current point.\n        this.pointBackup = this.pointValid[index]\n            ? this.points[index].clone()\n            : null;\n\n        // Start coord picker\n        if (!this.viewer.toolController.isToolActivated(this.coordPicker.getName())) {\n            this.viewer.toolController.activateTool(this.coordPicker.getName());\n        }\n\n        this.selectingIndex = index;\n\n        if (this.options.draggable) {\n            this.coordPicker.setDragging(enableDrag);\n            this.setMarkersDraggable(false);\n        }\n\n        this.fireEvent({\n            type: Events.POINT_SELECTION_STARTED,\n            index: this.selectingIndex,\n        });\n    }\n\n    onDragEnded({ event }) {\n        if (!this.coordPicker.getDragging()) {\n            return;\n        }\n\n        this.coordPicker.handleSingleClick(event, 0);\n        this.coordPicker.setDragging(false);\n    }\n\n    startSelect() {\n        this.isActive = true;\n        this.continuePointSelectionIfNeeded();\n    }\n\n    // @param {Vector3} [from] - Use null/undefined for clearing the fromPoint.\n    setPoint(index, point) {\n        this.pointValid[index] = !!point;\n\n        if (this.pointValid[index]) {\n            this.points[index].copy(point);\n\n            // update point marker\n            this.markers[index].setPosition(point);\n        }\n\n        this.updateGizmos();\n    }\n\n    updateGizmoVisibility(gizmo, visible, skipFade) {\n        if (visible || skipFade) {\n            // Show/Hide immediately.\n            this.screenOverlay.setGizmoVisible(gizmo, visible);\n        } else {\n            // By default, hiding is done as smooth fadeout.\n            this.screenOverlay.fadeOutGizmo(gizmo);\n        }\n    }\n\n    // Show dashed line or arrow if from/to are both valid\n    updateGizmos(skipFade) {\n        for (let i = 0; i < this.N; i++) {\n            const visible = this.showMarkers[i] && this.visible && this.pointValid[i];\n            this.markers[i].setVisible(visible);\n        }\n\n        for (let i = 0; i < this.connectors.length; i++) {\n            const connector = this.connectors[i];\n            // Decide whether to show the connection between both points\n            const showGizmo =\n                this.visible &&\n                this.pointValid[connector.fromIndex] &&\n                this.pointValid[connector.toIndex];\n\n            this.updateGizmoVisibility(connector.gizmo, showGizmo, skipFade);\n\n            if (showGizmo) {\n                connector.setFrom(this.points[connector.fromIndex]);\n                connector.setTo(this.points[connector.toIndex]);\n            }\n\n            if (connector.label) {\n                connector.label.setOpacity(showGizmo ? 1 : 0, true);\n\n                // Update distance value only if label is visible.\n                if (showGizmo) {\n                    const text = connector.getEdgeLabelText(i);\n                    connector.label.setText(text);\n                }\n            }\n        }\n\n        // ensure refresh if only position has changed\n        this.screenOverlay.update();\n    }\n\n    clearPoint(index) {\n        this.pointValid[index] = false;\n        this.markers[index].setVisible(false);\n\n        this.updateGizmos();\n    }\n\n    clear() {\n        this.cancelPointSelection();\n\n        for (let i = 0; i < this.N; i++) {\n            this.pointValid[i] = false;\n            this.markers[i].setVisible(false);\n        }\n\n        this.selectingIndex = -1;\n        this.lastSelectedPoint = -1;\n\n        this.updateGizmos();\n\n        this.isActive = false;\n\n        this.fireEvent({ type: Events.CLEAR });\n    }\n\n    onPointHovered(event) {\n        if (this.selectingIndex === -1) {\n            return;\n        }\n\n        this.setPoint(this.selectingIndex, event.point);\n        this.fireEvent({\n            type: Events.POINT_HOVERED,\n            point: event.point,\n            index: this.selectingIndex,\n        });\n    }\n\n    onPointClicked({ point }, pickAnother = true) {\n        if (this.selectingIndex === -1) {\n            return;\n        }\n\n        // In case not point was selected, try restoring point backup.\n        point = point || this.pointBackup;\n\n        // Clear point backup\n        this.pointBackup = null;\n\n        // TODO: Avoid this hack. For this, the OrbitDollyPanTool should stop locking the ToolController and\n        //       properly handle the case to be disabled within an interaction - without global blocking the ToolController.\n        this.viewer.toolController.setIsLocked(false);\n        this.viewer.toolController.deactivateTool(this.coordPicker.getName());\n\n        if (point) {\n            // Set pivot to selected point, so that we can orbit around it\n            this.viewer.impl.camera.pivot.copy(point);\n            this.viewer.impl.camera.dirty = true;\n        }\n\n        this.setPoint(this.selectingIndex, point);\n\n        this.setMarkersDraggable(true);\n\n        const index = this.selectingIndex;\n\n        this.selectingIndex = -1;\n\n        if (point) {\n            this.lastSelectedPoint = Math.max(index, this.lastSelectedPoint);\n            this.fireEvent({ type: Events.POINT_SELECTED, point, index });\n        }\n\n        // Start picking another point if:\n        // - pickAnother flag is set\n        // - We just selected a point, and it's not a stop point index.\n        if (pickAnother && !(point && this.stops.includes(this.lastSelectedPoint))) {\n            this.continuePointSelectionIfNeeded();\n        }\n    }\n\n    setMarkersDraggable(enable) {\n        if (!this.options.draggable) {\n            return;\n        }\n\n        for (let i = 0; i < this.N; i++) {\n            const draggable =\n                enable && this.visible && this.pointValid[i] && this.showMarkers[i];\n            this.markers[i].setDraggable(draggable);\n        }\n    }\n\n    cancelPointSelection() {\n        this.onPointClicked({}, false);\n    }\n\n    continuePointSelectionIfNeeded() {\n        if (!this.isPickerActive()) {\n            return;\n        }\n\n        // Make sure the tool is visible.\n        this.setVisible(true);\n\n        for (let i = 0; i < this.N; i++) {\n            if (!this.pointValid[i]) {\n                this.startSelectPoint(i, false); \n                break;\n            }\n        }\n    }\n\n    // Note: By default, setVisible(false) triggers a smooth fadeout. Use skipFade=true if you want to ensure that everything is instantly hidden.\n    setVisible(visible, skipFade) {\n        if (visible !== this.visible) {\n            this.visible = visible;\n            this.updateGizmos(skipFade);\n        }\n    }\n\n    // Shortcut for readability: Hide immediately without any fade-out.\n    forceHide() {\n        this.setVisible(false, true);\n    }\n\n    areAllPointsSet() {\n        if (this.selectingIndex !== -1) {\n            return false;\n        }\n\n        for (let i = 0; i < this.N; i++) {\n            if (!this.pointValid[i]) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    isPickerActive() {\n        return this.isActive;\n    }\n\n    attachPointsToModel(model, points) {\n        this.setModelsToPointsMap(Object.assign({}, this.modelsToPointsMap, { [model.id]: points }));\n    }\n    \n    // ModelsToPointsMap is used to define a connection between points and specific models.\n    // It is currently being used in order to update the points according to model transform changes.\n    // Could be also used in the future for limiting the snapper to snap only on the attached model.\n    setModelsToPointsMap(map) {\n        this.modelsToPointsMap = map;\n\n        const ids = Object.keys(this.modelsToPointsMap);\n\n        if (ids.length > 0) {\n            ids.forEach(id => {\n                const model = this.viewer.impl.findModel(Number(id), true);\n\n                // Used in order to calculate the initial transform diff later.\n                const matrix = model.getModelTransform()?.clone();\n                this.modelsToPointsMap[id].matrix = matrix || new Autodesk.Viewing.Private.LmvMatrix4(true);\n            });\n\n            if (!this.viewer.hasEventListener(Autodesk.Viewing.MODEL_TRANSFORM_CHANGED_EVENT, this.onModelTransformChanged)) {\n                this.viewer.addEventListener(Autodesk.Viewing.MODEL_TRANSFORM_CHANGED_EVENT, this.onModelTransformChanged);\n            }\n\n        } else {\n            // Remove event if there is no mapping.\n            this.viewer.removeEventListener(Autodesk.Viewing.MODEL_TRANSFORM_CHANGED_EVENT, this.onModelTransformChanged);\n        }\n    }\n\n    // Update points that are attached to a specific model, in case it moved.\n    onModelTransformChanged({ model, matrix }) {\n        // No map;\n        if (!this.modelsToPointsMap) {\n            return;\n        }\n\n        const pointIndexes = this.modelsToPointsMap[model.id];\n\n        // Model not in map - nothing to update.\n        if (!pointIndexes) {\n            return;\n        }\n\n        // Calculate diff matrix.\n        const previousMatrix = this.modelsToPointsMap[model.id].matrix;\n        const diffMatrix = previousMatrix.getInverse(previousMatrix);\n        diffMatrix.multiplyMatrices(matrix, diffMatrix);\n\n        // Update for next time.\n        this.modelsToPointsMap[model.id].matrix = matrix.clone();\n\n        for (let i = 0; i < this.N; i++) {\n            if (pointIndexes.includes(i) && this.pointValid[i]) {\n\n                const point = this.points[i];\n                point.applyMatrix4(diffMatrix);\n                this.setPoint(i, point);\n            }\n        }\n    }\n}\n\nNPointPicker.Events = Events;\nNPointPicker.Colors = Colors;\nNPointPicker.ConnectorTypes = ConnectorTypes;\n","import NPointPicker from './NPointPicker.js';\n\n// Controls the user interaction workflow for aligning a model based on two selected points\n\n// Extend NPointPicker events.\nconst Events = Object.assign({}, NPointPicker.Events, {\n    FROM_POINT_SELECTED: 'fromPointSelected',\n    TO_POINT_SELECTED: 'toPointSelected',\n    FROM_POINT_HOVERED: 'fromPointHovered',\n    TO_POINT_HOVERED: 'toPointHovered'\n});\n\n// Implements the interaction to select two points: A 'fromPoint' and a 'toPoint'.\nexport default class TwoPointPicker extends NPointPicker {\n\n    constructor(viewer, coordPicker, screenOverlay, options) {\n        super(viewer, coordPicker, screenOverlay, 2, options);\n\n        this.addEventListener(NPointPicker.Events.POINT_SELECTED, ({ point, index }) => {\n            if (index === 0) {\n                this.fireEvent({ type: Events.FROM_POINT_SELECTED, point });\n            } else {\n                this.fireEvent({ type: Events.TO_POINT_SELECTED, point });\n            }\n        });\n\n        this.addEventListener(NPointPicker.Events.POINT_HOVERED, ({ point, index }) => {\n            if (index === 0) {\n                this.fireEvent({ type: Events.FROM_POINT_HOVERED, point });\n            } else {\n                this.fireEvent({ type: Events.TO_POINT_HOVERED, point });\n            }\n        });\n    }\n\n    setOffset(offset) {\n        this.offset.copy(offset);\n    }\n\n    startSelectFrom() {\n        this.startSelectPoint(0);\n    }\n\n    startSelectTo() {\n        this.startSelectPoint(1);\n    }\n}\n\nTwoPointPicker.Events = Events;\n","\nconst av = Autodesk.Viewing;\nconst namespace = AutodeskNamespace('Autodesk.Edit3D');\nconst myExtensionName = 'Autodesk.Edit3D';\n\nimport Gizmo3D from './Gizmo3D.js';\nimport Label3D from './Label3D.js';\nimport PointMarker from './PointMarker.js';\nimport CoordPicker from './CoordPicker.js';\nimport TwoPointPicker from './TwoPointPicker.js';\nimport NPointPicker from \"./NPointPicker.js\";\n\n/** \n * Edit3D extension is a collection of general-purpose helper classes to faciliate \n * implementation of 3D EditTools.\n * Loading the extension does not add UI or changes behavior in the viewer. Its purpose is only\n * to provide a basis for other extensions and client applications.\n * \n * The extension id is: `Autodesk.Edit3D`\n * \n * @example\n *   viewer.loadExtension('Autodesk.Edit3D')\n *\n * @memberof Autodesk.Viewing.Extensions\n * @see {@link Autodesk.Viewing.Extension} for common inherited methods.\n * @alias Autodesk.Viewing.Extensions.Edit3DExtension\n * @class\n */\nexport default class Edit3DExtension extends av.Extension {\n    constructor(viewer, options) {\n        super(viewer, options);\n    }\n}\n\nnamespace.Gizmo3D = Gizmo3D;\nnamespace.Label3D = Label3D;\nnamespace.PointMarker = PointMarker;\nnamespace.CoordPicker = CoordPicker;\nnamespace.TwoPointPicker = TwoPointPicker;\nnamespace.NPointPicker = NPointPicker;\n\n// Register the extension with the extension manager.\nav.theExtensionManager.registerExtension(myExtensionName, Edit3DExtension);\n\n"],"sourceRoot":""}