{"version":3,"file":"VisualClusters/VisualClusters.js","sources":["webpack://Autodesk.Extensions.[name]/webpack/bootstrap","webpack://Autodesk.Extensions.[name]/./extensions/VisualClusters/AnimController.js","webpack://Autodesk.Extensions.[name]/./extensions/VisualClusters/AnimState.js","webpack://Autodesk.Extensions.[name]/./extensions/VisualClusters/Cluster.js","webpack://Autodesk.Extensions.[name]/./extensions/VisualClusters/ClusterGizmo.js","webpack://Autodesk.Extensions.[name]/./extensions/VisualClusters/ClusterLayout.js","webpack://Autodesk.Extensions.[name]/./extensions/VisualClusters/RotationAlignment.js","webpack://Autodesk.Extensions.[name]/./extensions/VisualClusters/RowLayoutBuilder.js","webpack://Autodesk.Extensions.[name]/./extensions/VisualClusters/ShapeBoxes.js","webpack://Autodesk.Extensions.[name]/./extensions/VisualClusters/VisualClusters.js"],"sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./extensions/VisualClusters/VisualClusters.js\");\n","function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError(\"Cannot call a class as a function\");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;} //\n// Controls animations between different animation states.\n//\n\nimport { SceneAnimState } from './AnimState.js';\n\n\n// An AnimController contains multiple scene animation states and can smoothly interpolate between those. Each state defines the positions for several objects.\n//\n// Example: Transition from \"original shape positions\" to \"shapes are grouped by categories\".\nvar AnimController = /*#__PURE__*/function () {\n\n  function AnimController(viewer) {_classCallCheck(this, AnimController);\n\n    // Describes animation state at the current time.\n    this.currentState = new SceneAnimState();\n\n    // Different states that we can interpolate between - indexed by stateName.\n    this.states = {}; // string => SceneAnimState\n\n    // Animation state at the point when the last animation had started\n    this.startState = new SceneAnimState();\n\n    // {Viewer3D}\n    this.viewer = viewer;\n\n    // Used to interrupt running in-progress animations\n    this.animControl = null;\n  }\n\n  // Start animation to a target state.\n  //\n  // @param {string} [stateName] - A previously registered stateName or null. Null returns to original shape positions.\n  //\n  // @returns {AnimControl} Control in-progress animation..\n  //                          control.stop(): to interrupt it.\n  //                          control.isRunning(): to check whether it is in progress.\n  _createClass(AnimController, [{ key: \"animateTo\", value: function animateTo() {var _this = this;var stateName = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;var animTime = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2.0;\n\n      // Make sure that we don't run any previous animation concurrently\n      this.stopAnim();\n\n      var endState = this.states[stateName];\n\n      var onTimer = function onTimer(t) {\n\n        // Ensure that motion speed is changed smoothly\n        t = Autodesk.Viewing.Private.smootherStep(t);\n\n        _this.currentState.lerp(_this.startState, endState, t);\n        _this.currentState.apply(_this.viewer);\n      };\n\n      // Freeze current SceneAnimState and keep it as start for interpolation\n      this.startState.copyFrom(this.currentState);\n\n      return Autodesk.Viewing.Private.fadeValue(0, 1, animTime, onTimer, function () {return _this.onAnimEnded();});\n    }\n\n    // Immediately stop current animation at its current state. No-op if no animation is running\n  }, { key: \"stopAnim\", value: function stopAnim() {\n      if (this.animControl && this.animControl.isRunning) {\n        this.animControl.stop();\n        this.animControl = null;\n      }\n    }\n\n    // Register new SceneState that we can animate to\n  }, { key: \"registerState\", value: function registerState(stateName, sceneState) {\n      this.states[stateName] = sceneState;\n\n      // Make sure that currentState addresses all objects that are modified by the new SceneAnimState.\n      this.currentState.createObjectAnimStates(sceneState);\n    }\n\n    // Immediately apply a given animation state\n  }, { key: \"setState\", value: function setState(stateName) {\n      var state = this.states[stateName];\n      if (state) {\n        this.currentState.copyFrom(state);\n      } else {\n        // Recover shape transforms\n        this.currentState.resetTransforms();\n      }\n      this.currentState.apply(this.viewer);\n    } }, { key: \"onAnimEnded\", value: function onAnimEnded()\n\n    {\n      //this should trigger ANIM_ENDED event\n      this.viewer.dispatchEvent({ type: Autodesk.Viewing.ANIM_ENDED });\n    }\n\n    // Ensures that no animation is active and all anim transform is being cleared for all fragments that we modified before.\n  }, { key: \"reset\", value: function reset() {\n      this.stopAnim();\n      this.currentState.resetTransforms();\n      this.currentState.apply(this.viewer);\n\n      // Drop all states to free some memory\n      this.currentState = new SceneAnimState();\n      this.states = {};\n      this.startState = new SceneAnimState();\n    } }]);return AnimController;}();export { AnimController as default };\n;","function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError(\"Cannot call a class as a function\");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;} // Contains classes to control the animation state of animation for objects of one or more models.\n\nvar tmpMatrix = new THREE.Matrix4();\nvar tmpVec1 = new THREE.Vector3();\n\n// Get translation offset that is needed to make the given\n// point center of the rotation.\n//  @param {Quaternion} rotation\n//  @param {Vector3}    center\n//  @param {Vecotr3}    [optionalTarget]\n//  @returns {THREE.Vector3}\nvar getRotationOffset = function getRotationOffset(rotation, center, optionalTarget) {\n\n  var result = optionalTarget || new THREE.Vector3();\n\n  // get rotation as matrix\n  var rotMatrix = tmpMatrix.makeRotationFromQuaternion(rotation);\n\n  // Compute where center would be moved when just applying rotation alone\n  var p = center.clone().applyMatrix4(rotMatrix);\n\n  // Return correction offset to bring center back at its original position\n  return result.copy(center).sub(p);\n};\n\n// Describes an animation transform to be applied to single object. \n// Note that placement is relative to original position, i.e., identity means shape appears at original position.\nexport var ObjectAnimState = /*#__PURE__*/function () {\n\n  function ObjectAnimState(dbId) {_classCallCheck(this, ObjectAnimState);\n\n    // id of the object being animated\n    this.dbId = dbId;\n\n    // translation\n    this.move = new THREE.Vector3(0, 0, 0);\n\n    // scale\n    this.scale = new THREE.Vector3(1, 1, 1);\n\n    // rotation (as Quaternion)\n    //\n    // Note: Note that fragment animTransforms always rotate around the world origin, \n    //       because the original matrix is applied first.\n    this.rot = new THREE.Quaternion();\n\n    // By default, fragment rotations in LMV rotate around the world-origin.\n    this.rotCenter = new THREE.Vector3(0, 0, 0);\n  }_createClass(ObjectAnimState, [{ key: \"apply\", value: function apply(\n\n    model) {var _this = this;\n\n      var fragList = model.getFragmentList();\n      var it = model.getInstanceTree();\n\n      // Apply additional correction offset when rotating around a center != origin.\n      // Note that rotations set by updateAnimTransform always rotate around world origin.\n      var move = getRotationOffset(this.rot, this.rotCenter, tmpVec1).add(this.move);\n\n      // Update fragment animation transforms\n      it.enumNodeFragments(this.dbId, function (fragId) {\n        fragList.updateAnimTransform(fragId, _this.scale, _this.rot, move);\n      });\n    }\n\n    // Set this placement by interpolating between a start and end placement\n    //  @param {ItemPlacement} start, end - If null, we assume identity transform.\n    //  @param {number}        t          - interpolation param in [0,1]\n  }, { key: \"lerp\", value: function lerp(start, end, t) {\n\n      // use identiy transform if start or end is missing\n      start = start || ObjectAnimState.Identity;\n      end = end || ObjectAnimState.Identity;\n\n      // Interpolate move/scale/rotation\n      this.move.lerpVectors(start.move, end.move, t);\n      this.scale.lerpVectors(start.scale, end.scale, t);\n      this.rotCenter.lerpVectors(start.rotCenter, end.rotCenter, t);\n      THREE.Quaternion.slerp(start.rot, end.rot, this.rot, t);\n    } }, { key: \"copyFrom\", value: function copyFrom(\n\n    src) {\n      this.dbId = src.dbId;\n      this.move.copy(src.move);\n      this.scale.copy(src.scale);\n      this.rot.copy(src.rot);\n      this.rotCenter.copy(src.rotCenter);\n    } }, { key: \"resetTransform\", value: function resetTransform()\n\n    {\n      this.move.set(0, 0, 0);\n      this.scale.set(1, 1, 1);\n      this.rot.set(0, 0, 0, 1); // = identity Quaternion\n      this.rotCenter.set(0, 0, 0);\n    }\n\n    // Set rotation center. \n    // @param {Vector3} center\n    // @param {bool}    ajdustMove - If true, the move vector is changed so that the effect of the AnimState keeps the same.\n  }, { key: \"setRotationCenter\", value: function setRotationCenter(newCenter, adjustMove) {\n\n      // Adjust translation offset to keep position\n      if (adjustMove) {\n\n        // Compute the shift that the shape position would do without move adjustment.\n        // This could be optimized by avoiding double-computation of the rotation matrix.\n        var oldOffset = getRotationOffset(this.rot, this.rotCenter);\n        var newOffset = getRotationOffset(this.rot, newCenter);\n\n        // Modify translation to eliminate the position shift\n        this.move.add(oldOffset).sub(newOffset);\n      }\n\n      // Change rotationCenter\n      this.rotCenter.copy(newCenter);\n    } }]);return ObjectAnimState;}();\n\n\n// Represents the original state of an object when no anim transform is applied.\nObjectAnimState.Identity = new ObjectAnimState(-1);\n\n// Describes animation transforms for a set of objects within the same RenderModel\nexport var ModelAnimState = /*#__PURE__*/function () {\n\n  function ModelAnimState(model) {_classCallCheck(this, ModelAnimState);\n\n    this.model = model;\n\n    // Indexed by dbId.\n    this.animStates = []; // ObjectAnimState[]\n  }_createClass(ModelAnimState, [{ key: \"apply\", value: function apply()\n\n    {\n      for (var dbId in this.animStates) {\n        this.animStates[dbId].apply(this.model);\n      }\n\n      // Make sure that hierarchical bboxes are updated\n      this.model.visibleBoundsDirty = true;\n    }\n\n    // Finds or creates an animState for the given dbId.\n    //  @param {number}          dbId\n    //  @param {ObjectAnimState} animState\n  }, { key: \"setAnimState\", value: function setAnimState(dbId, animState) {\n      this.animStates[dbId] = animState;\n    } }, { key: \"getAnimState\", value: function getAnimState(\n\n    dbId) {var createIfMissing = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n      var animState = this.animStates[dbId];\n\n      // Create new one if needed\n      if (!animState && createIfMissing) {\n        animState = new ObjectAnimState(dbId);\n        this.setAnimState(dbId, animState);\n      }\n\n      return animState;\n    }\n\n    // Adds new ObjectAnimStates for all dbIds in srcState.\n    //\n    // This is important if you use this to interpolate between other ModelStates and want to make sure that this ModelState\n    // affects all dbIds that are affected either by startState or endState.\n    //\n    // @param {ModelAnimState} srcState\n  }, { key: \"createObjctAnimStates\", value: function createObjctAnimStates(srcState) {\n      for (var key in srcState.animStates) {\n\n        // Note that key is the dbId as string. \n        // => Use the integer variant from srcState instead.\n        var dbId = srcState.animStates[key].dbId;\n\n        // Make sure that we have an ObjectAnimState for this dbId\n        this.getAnimState(dbId, true);\n      }\n    }\n\n    // Prepares this ModelState to interpolate between two others:\n    // For this, we make sure that this ModelState affects all dbIds that are modified by either start or end.\n  }, { key: \"prepareLerp\", value: function prepareLerp(start, end) {\n      this.createObjectAnimStates(start);\n      this.createObjectAnimStates(end);\n    }\n\n    // Updates all ObjectAnimStates by interpolating between a start and end anim state.\n    //\n    // Note: This only affects the existing ObjectAnimStates within this ModelAnimState.\n    //       It does NOT create new AnimStates. See prepareLerp()\n    // \n    //  @param {ModelAnimState} start, end - may be null (= original state)\n    //  @param {number}         t          - interpolation param in [0,1]\n  }, { key: \"lerp\", value: function lerp(start, end, t) {\n      for (var dbId in this.animStates) {\n        var objStart = start && start.animStates[dbId];\n        var objEnd = end && end.animStates[dbId];\n        this.animStates[dbId].lerp(objStart, objEnd, t);\n      }\n    } }, { key: \"copyFrom\", value: function copyFrom(\n\n    src) {\n\n      this.model = src.model;\n\n      // Make sure that we set the same ObjectAnimStates as src.\n      // Avoid re-allocations if possible.\n      for (var dbId in src.animStates) {\n        // get or create state\n        var srcObj = src.animStates[dbId];\n        var dstObj = this.getAnimState(dbId, true);\n        dstObj.copyFrom(srcObj);\n      }\n\n      // Clean all object animStates that src doesn't have\n      for (var _dbId in this.animStates) {\n        if (!src.animStates[_dbId]) {\n          delete this.animStates[_dbId];\n        }\n      }\n    }\n\n    // Reset anim transforms for all fragments that were modified by this state\n  }, { key: \"resetTransforms\", value: function resetTransforms() {\n      for (var dbId in this.animStates) {\n        this.animStates[dbId].resetTransform();\n      }\n    } }]);return ModelAnimState;}();\n\n\n// Describes animations for several objects within a scene composed from multiple models.\nexport var SceneAnimState = /*#__PURE__*/function () {\n\n  function SceneAnimState(models) {var _this2 = this;_classCallCheck(this, SceneAnimState);\n\n    // ModelAnimState[] - indexed by modelId\n    this.animStates = [];\n\n    // Create a model placement for each model, indexed by modelId\n    models && models.forEach(function (m) {return _this2.animStates[m.id] = new ModelAnimState(m);});\n  }_createClass(SceneAnimState, [{ key: \"apply\", value: function apply(\n\n    viewer) {\n      // Apply all model anim states\n      for (var modelId in this.animStates) {\n        this.animStates[modelId].apply();\n      }\n\n      // Force re-render\n      viewer.impl.invalidate(true, true, true);\n    }\n\n    // Set animation state for a single object\n    // Note that modelId must be the id of one of the models used for construction\n  }, { key: \"setAnimState\", value: function setAnimState(modelId, dbId, animState) {\n      this.animStates[modelId].setAnimState(dbId, animState);\n    }\n\n    // Adds new ObjectAnimStates for all dbIds in srcState.\n    // see ModelAnimState.createObjectAnimStates for details.\n    //\n    // @param {ModelAnimState} srcState\n  }, { key: \"createObjectAnimStates\", value: function createObjectAnimStates(srcState) {\n      for (var modelId in srcState.animStates) {\n        // get src ModelAnimState\n        var src = srcState.animStates[modelId];\n\n        // Get or create target ModelState for this model\n        var dst = this.animStates[modelId];\n        if (!dst) {\n          dst = new ModelAnimState(src.model);\n          this.animStates[modelId] = dst;\n        }\n\n        // Make sure that this ModelState operates on the same dbIds as src\n        dst.createObjctAnimStates(src);\n      }\n    }\n\n    // Prepares this SceneAnimState to interpolate between two others:\n    // For this, we make sure that this SceneAnimState affects all dbIds that are modified by either start or end.\n    //  @param {SceneAnimState} start, end\n  }, { key: \"prepareLerp\", value: function prepareLerp(start, end) {\n      this.createObjctAnimStates(start);\n      this.createObjctAnimStates(end);\n    }\n\n    // Set this placement by interpolating between a start and end placement\n    // Note:\n    //  - All placements must refer to the same list of models\n    //  - For each model, all placements must enlist the same dbIds\n    // \n    //  @param {ScenePlacement} start, end\n    //  @param {number}         t          - interpolation param in [0,1]\n  }, { key: \"lerp\", value: function lerp(start, end, t) {\n      for (var modelId in this.animStates) {\n        var modelStart = start && start.animStates[modelId];\n        var modelEnd = end && end.animStates[modelId];\n        this.animStates[modelId].lerp(modelStart, modelEnd, t);\n      }\n    }\n\n    // Makes this SceneState equal to the src state.\n  }, { key: \"copyFrom\", value: function copyFrom(srcState) {\n\n      for (var modelId in srcState.animStates) {\n        var src = srcState.animStates[modelId];\n        var dst = this.animStates[modelId];\n\n        // In case we don't have a ModelState for this model, create one\n        if (!dst) {\n          dst = new ModelAnimState(src.model);\n          this.animStates[modelId] = dst;\n        }\n\n        dst.copyFrom(src);\n      }\n\n      // Erase any modelState that src doesn't have\n      for (var _modelId in this.animStates) {\n        if (!srcState.animStates[_modelId]) {\n          delete this.animStates[_modelId];\n        }\n      }\n    }\n\n    // Reset anim transforms for all fragments that were modified by this state\n  }, { key: \"resetTransforms\", value: function resetTransforms() {\n      for (var modelId in this.animStates) {\n        this.animStates[modelId].resetTransforms();\n      }\n    } }]);return SceneAnimState;}();","function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {try {var info = gen[key](arg);var value = info.value;} catch (error) {reject(error);return;}if (info.done) {resolve(value);} else {Promise.resolve(value).then(_next, _throw);}}function _asyncToGenerator(fn) {return function () {var self = this,args = arguments;return new Promise(function (resolve, reject) {var gen = fn.apply(self, args);function _next(value) {asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);}function _throw(err) {asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);}_next(undefined);});};}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError(\"Cannot call a class as a function\");}}\n// A ShapeID references a single object within a multi-models scene. \nvar createShapeId = function createShapeId(modelId, dbId) {\n  return {\n    modelId: modelId,\n    dbId: dbId };\n\n};\n\n// A Cluster is a group of objects that is supposed to be positions close to each other.\nvar Cluster =\n\nfunction Cluster(name) {_classCallCheck(this, Cluster);\n\n  // string\n  this.name = name;\n\n  // ShapeID[]\n  this.shapeIds = [];\n};\n\n\n// Checks if all fragments of a given dbId are hidden. If so, we exclude it from layout algorithm, because it would just produce empty space.\nvar hasVisibleFragments = function hasVisibleFragments(model, dbId) {\n\n  var it = model.getInstanceTree();\n  var fragList = model.getFragmentList();\n  var visFlags = model.myData.fragments.visibilityFlags;\n\n  // Update fragment animation transforms\n  var allHidden = true;\n  it.enumNodeFragments(dbId, function (fragId) {\n\n    // For OTG models, the visFlags tell us which fragments have been skipped by OtgLoader. This applies for Revit Room geometry.\n    // For Svf, these flags may not exist, because they are deleted after loading. However, SvfLoader then sets the corresponding fragments to invisible.\n    var skipped = visFlags && visFlags[fragId] === Autodesk.Viewing.Private.MeshFlags.MESH_NOTLOADED;\n    var hidden = !fragList.isFragVisible(fragId);\n\n    if (!skipped && !hidden) {\n      // We found a visible fragment\n      allHidden = false;\n\n      // No need to continue traversal\n      return true;\n    }\n  });\n  return !allHidden;\n};\n\n// Remove duplicates from array\n//  @param {[]} a\n//  @returns {[]} Deduplicated copy.\nvar uniq = function uniq(a) {\n  return Array.from(new Set(a));\n};\n\n// Creates a set of clusters based on the values of a certain propertyDB attribute.\n// Note that you have to wait for an async propDB call to finish.\n//\n// By default, we only categorize leaf objects. This requires that all leaf objects contain the attribute to search for.\n// The searchParents option enables to allow parent nodes as well:\n//      i.e. we search all levels of the model tree and consider inner nodes as a single object if they contain\n//           the search attribute.\n//\n//  @param {Model[]}   models\n//  @param {string}    attribName\n//  @param {boolean}   searchParents\n//  @returns {Promise} When done, it resolves to a {Cluster[]}, where each element is...\n//                       - named by an attribute value \n//                       - containing all ShapeIds that match that value\nvar buildClustersFromAttribute = /*#__PURE__*/function () {var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(models) {var attribName,searchAncestors,clustersByName,promises,_loop,i,clusters,_args = arguments;return regeneratorRuntime.wrap(function _callee$(_context) {while (1) {switch (_context.prev = _context.next) {case 0:attribName = _args.length > 1 && _args[1] !== undefined ? _args[1] : 'Category';searchAncestors = _args.length > 2 && _args[2] !== undefined ? _args[2] : false;\n\n            // Collects result\n            clustersByName = {};\n\n            // For each model, we run an async propDB worker query\n            promises = [];_loop = function _loop(\n\n            i) {\n\n              var model = models[i];\n              var tree = model.getData().instanceTree;\n              var dbIds = void 0;\n\n              if (searchAncestors) {\n                // Use all the dbIds in the model\n                var ids = Object.keys(tree.nodeAccess.dbIdToIndex);\n                dbIds = ids.map(function (item) {return parseInt(item, 10);});\n              } else {\n                // get all dbIds with visual representation\n                dbIds = model.myData.fragments.fragId2dbId;\n\n                // Exclude all dbIds that only contain hidden fragments (like room geometries)\n                dbIds = dbIds.filter(function (dbId) {return hasVisibleFragments(model, dbId);});\n\n                // Remove duplicates. Note that this is necessary, because dbIds with multiple fragments will\n                // occur several times in fragId2dbId.\n                dbIds = uniq(dbIds);\n              }\n\n              var options = {\n                ignoreHidden: false,\n                propFilter: [attribName] };\n\n\n              promises.push(new Promise(function (resolve, reject) {\n\n                // Process dbIds. result is an array of item,\n                // each containing the props for a single dbId\n                var onDone = function onDone(result) {var _loop2 = function _loop2(\n                  _i) {\n\n                    // item contains props of a single db object\n                    var item = result[_i];\n\n                    // get category of this db item  \n                    var category = item.properties[0].displayValue;\n\n                    // get or create cluster for this category\n                    var cluster = clustersByName[category];\n                    if (!cluster) {\n                      cluster = new Cluster(category);\n                      clustersByName[category] = cluster;\n                    }\n\n                    if (searchAncestors) {\n                      // Append IDs of visible children\n                      tree.enumNodeChildren(item.dbId, function (child) {\n                        if (hasVisibleFragments(model, child)) {\n                          cluster.shapeIds.push(createShapeId(model.id, child));\n                        }\n                      }, true);\n                    } else {\n                      // Append current dbId to this cluster\n                      cluster.shapeIds.push(createShapeId(model.id, item.dbId));\n                    }};for (var _i = 0; _i < result.length; _i++) {_loop2(_i);\n                  }\n                  resolve();\n                };\n\n                model.getBulkProperties2(dbIds, options, onDone);\n              }));};for (i = 0; i < models.length; i++) {_loop(i);\n            }_context.next = 8;return (\n\n              Promise.all(promises));case 8:\n\n            // Flatten to an array\n            clusters = Object.values(clustersByName);return _context.abrupt(\"return\",\n\n            clusters);case 10:case \"end\":return _context.stop();}}}, _callee);}));return function buildClustersFromAttribute(_x) {return _ref.apply(this, arguments);};}();\n\n\nexport {\nbuildClustersFromAttribute,\nCluster,\ncreateShapeId,\nhasVisibleFragments };","function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError(\"Cannot call a class as a function\");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}\n// Disable packed normals for now, because it sometimes causes wrong values in the normal-depth-buffer (not clear why).\n// The number of cluster boxes is small anyway, so using unpacked is okay here.\nvar UsePackedNormals = false;\n\nvar avp = Autodesk.Viewing.Private;\n\n// Creates a quad with xy in [-0.5, 0.5] and z=0. Normal is +z\nvar createUnitQuadGeom = function createUnitQuadGeom() {\n\n  var l = -0.5;\n  var h = +0.5;\n\n  // vertex positions (3-floats per vertex)\n  var positions = Float32Array.from([\n  l, l, 0,\n  l, h, 0,\n  h, l, 0,\n  h, h, 0]);\n\n\n  // index buffer for triangles\n  var indices = Uint16Array.from([0, 3, 1, 0, 2, 3]);\n\n  // index buffer for edges\n  var iblines = Uint16Array.from([0, 1, 1, 3, 3, 2, 2, 0]);\n\n  // create interleaved vertex buffer\n  var vertexCount = 4;\n  var vbstride = UsePackedNormals ? 4 : 6; // float32 values per vertex\n  var vb = new Float32Array(vertexCount * vbstride);\n\n  // write positions to interleaved buffer\n  for (var i = 0; i < vertexCount; i++) {\n    var srcOffset = 3 * i;\n    var dstOffset = vbstride * i;\n    vb[dstOffset] = positions[srcOffset];\n    vb[dstOffset + 1] = positions[srcOffset + 1];\n    vb[dstOffset + 2] = positions[srcOffset + 2];\n  }\n\n  if (UsePackedNormals) {\n    // encode (0,0,1) as packed Uint16 normal\n    var toUint16 = 0xFFFF; // for upscaling from [0,1]-floats to Uint16-scale\n    var nx = 0.5 * toUint16;\n    var ny = 1.0 * toUint16;\n\n    // The first 3 floats per vertex are used by positions. \n    // Counting in Uint16 values, this makes 6.\n    var normalOffset = 6;\n\n    // write normals to interleaved buffer\n    var vbUint16 = new Uint16Array(vb.buffer);\n    var vbUint16Stride = vbstride * 2; // 2 Uint16 per float32\n    for (var _i = 0; _i < vertexCount; _i++) {\n      var _dstOffset = vbUint16Stride * _i + normalOffset;\n      vbUint16[_dstOffset] = nx;\n      vbUint16[_dstOffset + 1] = ny;\n    }\n  } else {\n    var _normalOffset = 3;\n\n    // write normals to interleaved buffer\n    for (var _i2 = 0; _i2 < vertexCount; _i2++) {\n      var _dstOffset2 = vbstride * _i2 + _normalOffset;\n      vb[_dstOffset2] = 0;\n      vb[_dstOffset2 + 1] = 0;\n      vb[_dstOffset2 + 2] = 1;\n    }\n  }\n\n  // create result geometry\n  var geom = new THREE.BufferGeometry();\n  geom.vbstride = vbstride;\n  geom.vb = vb;\n  geom.ib = indices;\n  geom.iblines = iblines;\n\n  // position attribute\n  var attrPos = new THREE.BufferAttribute(undefined, 3);\n  attrPos.itemOffset = 0;\n  geom.attributes.position = attrPos;\n\n  // normal attribute\n  var attrNormal = new THREE.BufferAttribute(undefined, 3);\n  attrNormal.itemOffset = 3;\n  attrNormal.bytesPerItem = UsePackedNormals ? 2 : 6;\n  attrNormal.normalize = true;\n  geom.attributes.normal = attrNormal;\n\n  // index attribute\n  var attrIndex = new THREE.BufferAttribute(undefined, 1);\n  attrIndex.bytesPerItem = 2;\n  geom.attributes.index = attrIndex;\n\n  // add attribute for edge rendering\n  var attrIndexLines = new THREE.BufferAttribute(undefined, 1);\n  attrIndexLines.bytesPerItem = 2;\n  geom.setAttribute('indexlines', attrIndexLines);\n\n  // attribute keys\n  geom.attributesKeys = Object.keys(geom.attributes);\n\n  return geom;\n};\n\n// Creates a quad mesh that corresponds to the z-Min face of the given bbox\n//  @param {Box3}            bbox\n//  @param {BufferGeometry}  unitQuadGeom\n//  @param {Material}        matman       - must be registered at materialManager and use packedNormals\nvar createGizmoMesh = function createGizmoMesh(bbox, material) {\n\n  // In theory, we could share a static one here. However, this would introduce subtle detail problems\n  // when using multiple viewer instances, because WebGLRenderer attaches gl-context-specific resources.\n  // The number of gizmo boxes is not big anyway, so what.\n  var geom = createUnitQuadGeom();\n\n  // create mesh\n  var boxMesh = new THREE.Mesh(geom, material);\n\n  // move mesh origin to center of bbox z-min face\n  bbox.getCenter(boxMesh.position);\n  bbox.size(boxMesh.scale);\n  boxMesh.position.z = bbox.min.z;\n\n  // Attach mesh bbox\n  boxMesh.boundingBox = bbox.clone();\n  boxMesh.boundingBox.max.z = bbox.min.z; // The mesh only spans the z-min surface of bbox\n\n  return boxMesh;\n};\n\n// @param {MaterialManager} matman - needed to register the material\nvar createGizmoMaterial = function createGizmoMaterial(matman) {\n\n  // create material\n  var material = new THREE.MeshPhongMaterial({\n    color: 0xffffff, // white\n    transparent: true,\n    opacity: 1,\n    side: THREE.DoubleSide,\n\n    // Disable z-buffer: It doesn't work with fading and the quads are below all the shapes anyway.\n    depthTest: false,\n    depthWrite: false });\n\n\n  // Note: This is must be set separately, because it's a custom-lmv property and not supported by the material ctor\n  material.packedNormals = UsePackedNormals;\n\n  // Register at MaterialManager\n  material.name = 'ClusterGizmoMaterial_' + material.id;\n  matman.addHDRMaterial(material.name, material);\n\n  return material;\n};\n\nvar disposeGizmoMesh = function disposeGizmoMesh(mesh, matman) {\n  mesh.geometry.dispose();\n  mesh.material.dispose();\n  matman.removeMaterial(mesh.material.name);\n};\n\n// A ClusterGizmo is a quad below an object cluster that helps to distinguish different clusters.\nexport var ClusterGizmo = /*#__PURE__*/function () {\n\n  // @param {Box3}   clusterBox - bbox of the cluster\n  // @param {string} [meshName] - Attached to the mesh to simplify debugging\n  function ClusterGizmo(viewer, clusterBox, meshName) {var _this = this;_classCallCheck(this, ClusterGizmo);\n\n    this.viewer = viewer;\n\n    // create mesh\n    var material = createGizmoMaterial(viewer.impl.matman());\n    this.mesh = createGizmoMesh(clusterBox, material);\n\n    this.mesh.name = meshName;\n\n    // add it to viewer scene\n    this.viewer.impl.scene.add(this.mesh);\n\n    // For smooth fadeIn/Out\n    var setOpacity = function setOpacity(t) {\n      // Fade-in quad\n      _this.mesh.material.opacity = t;\n\n      // Fade-in outline: Edges should have 0.5 opacity when fully faded in\n      _this.mesh.material.edgeOpacity = 0.5 * t;\n\n      _this.viewer.impl.invalidate(true, true);\n    };\n    this.opacityParam = new avp.AnimatedParam(0.0, setOpacity, 1.0);\n\n    // Initial fade-in\n    this.opacityParam.fadeTo(1);\n  }_createClass(ClusterGizmo, [{ key: \"dtor\", value: function dtor()\n\n    {\n      // remove from viewer scene\n      this.viewer.impl.scene.remove(this.mesh);\n      this.viewer.impl.invalidate(true, true);\n\n      // dispose gpu resources\n      disposeGizmoMesh(this.mesh, this.viewer.impl.matman());\n\n      this.mesh = null;\n      this.viewer = null;\n    }\n\n    // Fade out and dispose mesh when done\n  }, { key: \"dispose\", value: function dispose() {var _this2 = this;\n      this.opacityParam.fadeTo(0.0, function () {return _this2.dtor();});\n    } }]);return ClusterGizmo;}();\n\n\n// ClusterGizmoController takes care that ClusterGizmos and corresponding labels are created/disposed according to the currently shown layout.\nexport var ClusterGizmoController = /*#__PURE__*/function () {\n\n  function ClusterGizmoController(viewer) {_classCallCheck(this, ClusterGizmoController);\n\n    this.viewer = viewer;\n\n    this.gizmos = []; // ClusterGizmo[]\n    this.labels = []; // Label3D[]\n\n    // We delay fade-in, so that gizmos/labels appear shortly before the cluster animation ends\n    this.fadeInDelay = 1.8; // in seconds\n    this.timerId = null;\n  }_createClass(ClusterGizmoController, [{ key: \"createGizmos\", value: function createGizmos(\n\n    sceneLayout) {var _this3 = this;\n\n      // For each cluster...\n      var layouts = sceneLayout.clusterLayouts;var _loop = function _loop(\n      i) {\n        var layout = layouts[i];\n\n        // create quad gizmo\n        var bbox = layout.getBBox();\n        var gizmo = new ClusterGizmo(_this3.viewer, bbox, layout.cluster.name);\n        _this3.gizmos.push(gizmo);\n\n        // get label position (center of the bbox zMin-face)\n        var labelPos = bbox.getCenter();\n        labelPos.z = bbox.min.z;\n\n        // create label\n        var text = _this3.getLabelText(layout);\n        var label = new Autodesk.Edit3D.Label3D(_this3.viewer, labelPos, text);\n        _this3.labels.push(label);\n\n        // Hide label if ClusterGizmo size on screen is below MinPixels threshold.\n        //\n        // Note: We could use the screen-size of the label text. However, this looks confusing\n        //       if some cluster labels are shown and others are not (due to longer text that you don't see).\n        //       So, it looks more consistent to use a fixed minPixelSize for all clusters.\n        //       For super-long cluster names, we will introduce abbreviations instead.\n        var MinPixels = 75;\n        label.setWorldBox(gizmo.mesh.boundingBox, MinPixels);\n\n        // When clicking a label, fly to the cluster\n        var flyToCluster = function flyToCluster(e) {\n          var camera = _this3.viewer.impl.camera;\n\n          // get cluster-platform center and box size\n          var gizmoBox = gizmo.mesh.boundingBox;\n          var p = gizmoBox.getCenter();\n          var size = gizmoBox.size();\n\n          // Setup view diagonally to look at p\n          var dstView = camera.clone();\n          dstView.target.copy(p);\n\n          // get current distance from target point\n          var curDistance = camera.position.distanceTo(p);\n\n          // Place the camera on the line between target and start camera position.\n          // Choose distance close enough to the cluster to clearly focus it.\n          var dist = Math.max(size.x, size.y, size.z);\n          dist = Math.min(dist, curDistance); // if already close, never move away from target\n          var dir = camera.position.clone().sub(p).normalize();\n          dstView.position.set(\n          p.x + dir.x * dist,\n          p.y + dir.y * dist,\n          p.z + dir.z * dist);\n\n\n          // trigger animation\n          avp.flyToView(_this3.viewer, dstView, 1.5);\n\n          // Mark click as consumed, so that it doesn't trigger selection of objects behind the label.\n          e.stopPropagation();\n        };\n        label.container.style.pointerEvents = 'auto';\n        label.container.addEventListener('click', flyToCluster);};for (var i = 0; i < layouts.length; i++) {_loop(i);\n      }\n    } }, { key: \"getLabelText\", value: function getLabelText(\n\n    layout) {\n      var text = layout.cluster.name;\n\n      // Remove \"Revit \" prefix\n      // For now, we hard-wire this, but this function will be customizable by clients later.\n      var prefix = 'Revit ';\n      if (text.startsWith(prefix)) {\n        text = text.substring(prefix.length);\n      }\n\n      return text;\n    } }, { key: \"disposeGizmos\", value: function disposeGizmos()\n\n    {\n      this.gizmos.forEach(function (g) {return g.dispose();});\n      this.labels.forEach(function (l) {return l.dispose();});\n      this.gizmos.length = 0;\n      this.labels.length = 0;\n    }\n\n    // If a delayed fade-in of gizmos is pending for prior layout, cancel it\n  }, { key: \"cancelTimer\", value: function cancelTimer() {\n      if (this.timerId) {\n        window.clearTimeout(this.timerId);\n        this.timerId = null;\n      }\n    } }, { key: \"onLayoutChanged\", value: function onLayoutChanged(\n\n    sceneLayout) {var _this4 = this;\n\n      // Make sure that there is no concurrent delayed fade-in of a prior layout\n      this.cancelTimer();\n\n      // Fade-out and dispose any outdated gizmos\n      this.disposeGizmos();\n\n      // Fade-in new gizmos after some delay\n      if (sceneLayout) {\n        this.timerId = window.setTimeout(\n        function () {return _this4.createGizmos(sceneLayout);},\n        this.fadeInDelay * 1000);\n\n      }\n    }\n\n    // Dispose all resources immediately\n  }, { key: \"reset\", value: function reset() {\n      this.gizmos.forEach(function (g) {return g.dtor();});\n      this.labels.forEach(function (l) {return l.dtor();});\n      this.gizmos.length = 0;\n      this.labels.length = 0;\n    } }]);return ClusterGizmoController;}();","function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError(\"Cannot call a class as a function\");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}import { ObjectAnimState, SceneAnimState } from './AnimState.js';\nimport ShapeBoxes from './ShapeBoxes.js';\n\n\nvar tmpBox = new THREE.Box3();\n\n// Rotate an item by 90 degrees to make sure that width >= height. \n// This is done in a way that the box minPoint keeps the same.\n// \n// Note: Rotations using animTransform rotate around the world origin\n//\n// @param {THREE.Box3}      box - Original worldBox of a shape (without any animTransform applied)\n// @param {ObjectAnimState} dst - animState on which we set the rotation\nvar applyAlignmentTransform = function applyAlignmentTransform(box, dst) {\n\n  // rotate by 90 degrees\n  var angle = 90;\n  var axis = new THREE.Vector3(0, 0, 1);\n  dst.rot.setFromAxisAngle(axis, THREE.Math.degToRad(angle));\n\n  // Rotations work around the world origin.\n  // Now, we modify the move vector to make sure that the bbox keeps the same\n\n  // get rotation as matrix\n  var rotTf = new THREE.Matrix4().makeRotationFromQuaternion(dst.rot);\n\n  // get box after rotation\n  var box2 = tmpBox.copy(box).applyMatrix4(rotTf);\n\n  // modify move vector to obtain the same box minPoint as before rotation\n  // Note that box2.min is not simply the same as we would get when rotating the point box.min. \n  dst.move.sub(box2.min).add(box.min);\n};\n\n// A ClusterRowLayout defines how to line up a group of objects along one or more rows.\nvar ClusterRowLayout = /*#__PURE__*/function () {\n\n  function ClusterRowLayout(cluster) {_classCallCheck(this, ClusterRowLayout);\n\n    // MinPoint of the whole cluster.\n    this.position = new THREE.Vector3(0, 0, 0);\n\n    // {Cluster} - The cluster defining the object that this layout refers to\n    this.cluster = cluster;\n\n    // For each dbId cluster.shapeIds[i], positions[i] defines the corresponding position.\n    // Each object is anchored at the bbox minPoint.\n    this.positions = []; // Vector3[]\n\n    // If rotated[i] is true, the shape with id clusterShapeIds[i] will be rotated by 90 degree around z, \n    // so that x/y are swapped - while preserving the bbox minPoint.\n    this.rotated = []; // bool[]\n\n    // Spatial extent of this cluster.\n    this.size = new THREE.Vector3(0, 0, 0);\n  }_createClass(ClusterRowLayout, [{ key: \"getBBox\", value: function getBBox(\n\n    optionalTarget) {\n      var target = optionalTarget || new THREE.Box3();\n      target.min.copy(this.position);\n      target.max.copy(this.position).add(this.size);\n      return target;\n    }\n\n    // Modifies the given scene anim state so that all objects in the cluster are properly placed and rotated.\n    //\n    //  @param {SceneAnimState} sceneAnimState - SceneAnimState to be modified.\n    //  @param {Vector3}        offset         - Additional translation offset applied to all objects\n    //  @param {ShapeBoxes}     shapeBoxes     - access to shape bboxes\n    //  @param {RotationAlignment} [rotationAlignment] - Optional: Defines rotations that are applied per shape.\n  }, { key: \"apply\", value: function apply(sceneAnimState, offset, shapeBoxes, rotationAlignment) {\n\n      // reused tmp-vector\n      var targetPos = new THREE.Vector3();\n\n      // Reused below\n      var tmpBox = new THREE.Box3();\n      var tmpVec = new THREE.Vector3();\n\n      for (var i = 0; i < this.cluster.shapeIds.length; i++) {\n\n        // get shapeId\n        var shapeId = this.cluster.shapeIds[i];\n\n        // init itemPlacement for this shape\n        var animState = new ObjectAnimState(shapeId.dbId);\n\n        // get final position of this shape: \n        targetPos.copy(this.positions[i]) // position of the shape within the cluster\n        .add(this.position) // position of this cluster within the cluster set\n        .add(offset); // cluster set position\n\n        // get original shape minPoint\n        var originalBox = shapeBoxes.getShapeBox(shapeId, tmpBox);\n        var originalPos = originalBox.min;\n\n        // Set move-vector so that originalPos is moved to targePos\n        animState.move.subVectors(targetPos, originalPos);\n\n        if (rotationAlignment) {\n          // Apply rotation\n          rotationAlignment.getShapeRotation(shapeId, animState.rot);\n\n          // Set original shape box center as rotation anchor\n          var shapeBox = shapeBoxes.getUnrotatedShapeBox(shapeId, tmpBox);\n          var center = shapeBox.getCenter(tmpVec);\n          animState.setRotationCenter(center, true);\n        }\n\n        // If needed, apply rotation while keeping bbox.min the same.\n        // Note: When using RotationAlignments, the auto-flip is not needed anymore.\n        //       So, this code path will be removed as soon as the new variant is sufficiently tested.\n        var needsRotate = this.rotated[i];\n        if (needsRotate) {\n\n          // get shape bbox\n          originalBox = shapeBoxes.getShapeBox(shapeId, originalBox);\n\n          // apply rotation\n          applyAlignmentTransform(originalBox, animState);\n        }\n\n        // Add object anim state to scene anim state\n        sceneAnimState.setAnimState(shapeId.modelId, shapeId.dbId, animState);\n      }\n    } }]);return ClusterRowLayout;}();\n;\n\n// Defines the placement for a set of object clusters\nvar ClusterSetLayout = /*#__PURE__*/function () {\n\n  // @param {ClusterLayout}     layouts\n  // @param {RotationAlignment} [rotationAlignment] - only needed if shapes are rotated for alignment.\n  function ClusterSetLayout(layouts, rotationAlignment) {_classCallCheck(this, ClusterSetLayout);\n\n    // ClusterSet position. ClusterSets are anchored at the minPoint\n    this.position = new THREE.Vector3(0, 0, 0);\n\n    // {ClusterLayout[]}\n    this.clusterLayouts = layouts || [];\n\n    // {RotationAlignment}\n    this.rotationAlignment = rotationAlignment;\n  }\n\n  // Modifies the given scene anim state so that all objects in all cluster are properly placed and rotated.\n  //\n  //  @param {SceneAnimState} sceneAnimState - SceneAnimState to be modified.\n  //  @param {ShapeBoxes}     shapeBoxes     - access to shape bboxes\n  _createClass(ClusterSetLayout, [{ key: \"apply\", value: function apply(sceneAnimState, shapeBoxes) {var _this = this;\n      this.clusterLayouts.forEach(function (l) {return l.apply(sceneAnimState, _this.position, shapeBoxes, _this.rotationAlignment);});\n    }\n\n    // Creates a SceneAnimState that brings all shapes to their target positions\n  }, { key: \"createSceneState\", value: function createSceneState(models) {\n      var shapeBoxes = new ShapeBoxes(models, this.rotationAlignment);\n      var state = new SceneAnimState(models);\n      this.apply(state, shapeBoxes);\n      return state;\n    } }]);return ClusterSetLayout;}();\n\n\nexport {\nShapeBoxes,\nClusterRowLayout,\nClusterSetLayout };","function _createForOfIteratorHelper(o, allowArrayLike) {var it;if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {if (it) o = it;var i = 0;var F = function F() {};return { s: F, n: function n() {if (i >= o.length) return { done: true };return { done: false, value: o[i++] };}, e: function e(_e) {throw _e;}, f: F };}throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");}var normalCompletion = true,didErr = false,err;return { s: function s() {it = o[Symbol.iterator]();}, n: function n() {var step = it.next();normalCompletion = step.done;return step;}, e: function e(_e2) {didErr = true;err = _e2;}, f: function f() {try {if (!normalCompletion && it.return != null) it.return();} finally {if (didErr) throw err;}} };}function _unsupportedIterableToArray(o, minLen) {if (!o) return;if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);var n = Object.prototype.toString.call(o).slice(8, -1);if (n === \"Object\" && o.constructor) n = o.constructor.name;if (n === \"Map\" || n === \"Set\") return Array.from(o);if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);}function _arrayLikeToArray(arr, len) {if (len == null || len > arr.length) len = arr.length;for (var i = 0, arr2 = new Array(len); i < len; i++) {arr2[i] = arr[i];}return arr2;}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError(\"Cannot call a class as a function\");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;} // The purpose of this file is to compute the necessary transforms to rotate\n// all objects in a way that...\n//\n//  1. Identical objects are oriented in the same way\n//  2. Objects are horizontally aligned with the main axes x/y to reduce bbox extents.\n//  3. Up-Vector is preserved\n//\n// It also provides methods to consider these rotations during computation of\n// cluster layout and animation.\n\n// @param {Box3}   box\n// @param {number} i - in [0, 7]\nexport var getBoxCorner = function getBoxCorner(box, i) {\n  return new THREE.Vector3(\n  i & 1 ? box.min.x : box.max.x,\n  i & 2 ? box.min.y : box.max.y,\n  i & 4 ? box.min.z : box.max.z);\n\n};\n\n// Each element is a corner index. Each pair of two forms a main axis direction.\nvar BoxAxisIndices = Uint32Array.from([\n0, 1, 0, 2, 0, 4]);\n\n\n// Helper class to enumerate the main axis directions of one or more rotated bboxes.\nvar BoxAxes = /*#__PURE__*/function () {\n\n  function BoxAxes() {_classCallCheck(this, BoxAxes);\n    // Transforming vertices turned out to be the major cost factor. So we use indexing to reduce it.\n    this.vertices = [];\n\n    this.tmpPoint = new THREE.Vector3();\n  }\n\n  // @param {Box3}    box\n  // @param {Matrix4} matrix - orientation of the box\n  _createClass(BoxAxes, [{ key: \"addBox\", value: function addBox(box, matrix) {\n\n      // It's important to skip empty boxes. Otherwise, we would produce infinite \n      // extents after transforming min/max\n      if (box.isEmpty()) {\n        return;\n      }\n\n      // add 8 box corners\n      for (var i = 0; i < 8; i++) {\n        var p = getBoxCorner(box, i).applyMatrix4(matrix);\n        this.vertices.push(p);\n      }\n    }\n\n    // Sets outAxis.indexA and outAxis.indexB to vertex numbers of the given edge\n    //\n    // @param {number} axisIndex\n    // @param {Object} outAxis.indexA and outAxis.indexB will be set.\n  }, { key: \"getAxis\", value: function getAxis(axisIndex, outAxis) {\n      // Get offset where the vertices of the box start\n      var boxIndex = Math.floor(axisIndex / 3); // 3 axes per box\n      var vertexOffset = 8 * boxIndex; // 8 vertices per box\n\n      // Get index into BoxAxisIndices\n      var localIndex = 2 * axisIndex % BoxAxisIndices.length; // 2 values per axis\n\n      outAxis.indexA = vertexOffset + BoxAxisIndices[localIndex];\n      outAxis.indexB = vertexOffset + BoxAxisIndices[localIndex + 1];\n    } }, { key: \"getAxisCount\", value: function getAxisCount()\n\n    {\n      var boxCount = this.vertices.length / 8;\n      var AxesPerBox = 3;\n      return boxCount * AxesPerBox;\n    }\n\n    // Returns bounding rectangle of all boxes if we transform all points by the given matrix\n    //  @param {Box2}    outRect\n    //  @param {Matrix4} matrix\n  }, { key: \"getBoundingRect\", value: function getBoundingRect(outRect, matrix) {var _iterator = _createForOfIteratorHelper(\n      this.vertices),_step;try {for (_iterator.s(); !(_step = _iterator.n()).done;) {var v = _step.value;\n          // add transformed vertex to bbox\n          var p = this.tmpPoint.copy(v).applyMatrix4(matrix);\n          outRect.expandByPoint(p);\n        }} catch (err) {_iterator.e(err);} finally {_iterator.f();}\n    } }]);return BoxAxes;}();\n;\n\n// Find rotation around z-axis that brings the given (horizontal) direction to the x-axis\n//\n//  @param {Vector2}  dir - Does not need to be normalized\n//  @returns {number} ccw angle in radians. Rotate by this angle to bring dir to xAxis.\nexport var getAngleToXAxis = function getAngleToXAxis(dir) {\n  return -Math.atan2(dir.y, dir.x);\n};\n\n// Collects main axes of all fragment geometry boxes and projects them to world-space.\n//  @returns {BoxAxes} \nexport var collectFragBoxAxes = function collectFragBoxAxes(model, dbId) {\n\n  var boxAxes = new BoxAxes();\n\n  var geomList = model.getGeometryList();\n  var fragList = model.getFragmentList();\n\n  // Reused tmp-values\n  var geomBox = new THREE.Box3();\n  var worldMatrix = new THREE.Matrix4();\n\n  // For each fragment...\n  var it = model.getInstanceTree();\n  it.enumNodeFragments(dbId, function (fragId) {\n\n    // Set geomBox to geometry bbox in object-space (for otg, it will simply be the unit box)\n    var geomId = fragList.getGeometryId(fragId);\n    geomList.getModelBox(geomId, geomBox);\n\n    // get fragment world matrix\n    fragList.getOriginalWorldMatrix(fragId, worldMatrix);\n\n    // collect bbox with transform\n    boxAxes.addBox(geomBox, worldMatrix);\n  });\n  return boxAxes;\n};\n\n// Given vertices and axis directions of bboxes, this function finds a rotation around z so that...\n//  - area of the boundsXY is minimized\n//  - We always have xExtent <= yExtent for boundsXY\n// where boundsXY is the bounding box of the xy-projection of all boxes.\n//\n// Note: We assume here that the optimal solution will align one of the edges with the x-axis.\n//\n//  @param {BoxAxes} boxAxes\n//  @returns {Quaternion}\nexport var findAlignmentRotation = function findAlignmentRotation(boxAxes) {\n\n  // Reused in the loop below\n  var edgeDir = new THREE.Vector2();\n  var quaternion = new THREE.Quaternion();\n  var rotMatrix = new THREE.Matrix4();\n  var zAxis = new THREE.Vector3(0, 0, 1);\n  var rect = new THREE.Box2();\n\n  var minArea = Infinity;\n  var bestAngle = null;\n  var minExtent = new THREE.Vector2();\n\n  // An axis direction, given by two indices into boxAxes.vertices\n  var axis = {\n    indexA: 0,\n    indexB: 0 };\n\n  var a = null;\n  var b = null;\n\n  // For each edge...\n  var axisCount = boxAxes.getAxisCount();\n  for (var i = 0; i < axisCount; i++) {\n\n    // get edge\n    boxAxes.getAxis(i, axis);\n    a = boxAxes.vertices[axis.indexA];\n    b = boxAxes.vertices[axis.indexB];\n\n    // get edge direction\n    edgeDir.set(b.x - a.x, b.y - a.y);\n\n    // compute rotation matrix that brings that angle to x-axis (ccw radians)\n    var angleToXAxis = getAngleToXAxis(edgeDir);\n    quaternion.setFromAxisAngle(zAxis, angleToXAxis);\n    rotMatrix.makeRotationFromQuaternion(quaternion);\n\n    // compute xy-bounding rectangle that we get when using this angle\n    boxAxes.getBoundingRect(rect, rotMatrix);\n\n    // compute area\n    var dx = rect.max.x - rect.min.x;\n    var dy = rect.max.y - rect.min.y;\n    var area = dx * dy;\n\n    // If this area is better than our candidates so far, use it\n    if (area < minArea) {\n      // keep rotation that minimized area so far\n      minExtent.set(dx, dy);\n      minArea = area;\n      bestAngle = angleToXAxis;\n    }\n  }\n\n  // If needed, rotate by another 90 degree to ensure xExtent < yExtent.\n  // Note that this doesn't change the area\n  if (minExtent.x > minExtent.y) {\n    bestAngle += THREE.Math.degToRad(90.0);\n  }\n\n  // Compute final quaternion\n  quaternion.setFromAxisAngle(zAxis, bestAngle);\n  return quaternion;\n};\n\n// Computes a rotation transform for a given dbId that aligns the object horizontally, so that:\n//  - xy extent of the bbox is minimized\n//  - xExtent <= yExtent\n// @returns {Quaternion}\nexport var computeObjectAlignment = function computeObjectAlignment(model, dbId) {\n\n  // project the main axes of all fragment geometry boxes to world-space\n  var axes = collectFragBoxAxes(model, dbId); // {Vector3[]} with two vectors per edge\n\n  // find rotation that minimizes the x/y-bbox of all transformed boxes\n  return findAlignmentRotation(axes);\n};\n\nvar tmpMatrix = new THREE.Matrix4();\nvar tmpMatrix2 = new THREE.Matrix4();\n\n// Returns the bbox that we obtain when applying the given rotationMatrix\n// to the given fragment as animation transform, i.e., applied after world matrix.\nexport var getRotatedFragmentBox = function getRotatedFragmentBox(model, fragId, rotMatrix, optionalTarget) {\n\n  var result = optionalTarget || new THREE.Box3();\n\n  var fragList = model.getFragmentList();\n  var geomList = model.getGeometryList();\n\n  // Get fragment worldMatrix. Note that we don't want it to be affected by current animation state.\n  var worldMatrix = tmpMatrix;\n  fragList.getOriginalWorldMatrix(fragId, worldMatrix);\n\n  // Apply worldMatrix then rotMatrix\n  var fullMatrix = tmpMatrix2.copy(rotMatrix).multiply(worldMatrix);\n\n  // Get geometry bbox in object-space (for otg, it will simply be the unit box)\n  var geomId = fragList.getGeometryId(fragId);\n  geomList.getModelBox(geomId, result);\n\n  // Applying a matrix turns an empty box into an infinite one. So, we must skip it for empty boxes\n  if (!result.isEmpty()) {\n    // Apply combined matrix to geometry box.\n    // Note that we cannot simply rotate the fragment's worldBox here, because\n    // this would sometimes result in an unnecessary large bbox.\n    result.applyMatrix4(fullMatrix);\n  }\n\n  return result;\n};\n\n// Given a list of fragment ids and an addtional transform to be applied to each of those,\n// this function computes the resulting bbox when applying fragment worldMatrix + given transform to each\n// fragment geometry.\n//\n//  @param {Model}   model\n//  @param {dbId}    dbId\n//  @param {Matrix4} matrix\nexport var computeTransformedObjectBox = function computeTransformedObjectBox(model, dbId, matrix) {\n\n  var summedBox = new THREE.Box3();\n  var tmpBox = new THREE.Box3();\n\n  // For each fragment...\n  var it = model.getInstanceTree();\n  it.enumNodeFragments(dbId, function (fragId) {\n    // add aligned box of this fragment\n    var fragBox = getRotatedFragmentBox(model, fragId, matrix, tmpBox);\n    summedBox.union(fragBox);\n  });\n\n  return summedBox;\n};\n\n// Computes for each object an alignment rotation with the goal that...\n//  - x/y extent is minimized\n//  - z-axis is preserved\n//  - xExtent <= yExtent\nexport var RotationAlignment = /*#__PURE__*/function () {\n\n  // @param {Model[]}\n  function RotationAlignment(models) {var _this = this;_classCallCheck(this, RotationAlignment);\n\n    // Index modely by modelId\n    this.modelsById = [];\n    models.forEach(function (m) {return _this.modelsById[m.id] = m;});\n\n    // Caches of rotations and bboxes for rotated shapes\n    this.rotations = []; // {Quaternion[][]}\n    this.boxes = []; // {Box3[][]} - boxes of rotated fragments\n\n    // Reused tmp matrix\n    this.rotMatrix = new THREE.Matrix4();\n  }_createClass(RotationAlignment, [{ key: \"_addToCache\",\n\n    // Store alignment rotation and bbox for a shape in cache\n    value: function _addToCache(modelId, dbId, rotation, bbox) {\n\n      // Get or create arrays for cached rotations and boxes for this model\n      var modelRotations = this.rotations[modelId];\n      var modelBoxes = this.boxes[modelId];\n      if (!this.rotations[modelId]) {\n        // first rotation for this model => create new array\n        modelRotations = [];\n        modelBoxes = [];\n        this.rotations[modelId] = modelRotations;\n        this.boxes[modelId] = modelBoxes;\n      }\n\n      // store rotation and bbox in cache\n      modelRotations[dbId] = rotation;\n      modelBoxes[dbId] = bbox;\n    }\n\n    // Make sure that rotation and rotated box are in cache\n  }, { key: \"_computeAlignmentAndBox\", value: function _computeAlignmentAndBox(modelId, dbId) {\n\n      // Skip if already cached\n      if (this._isInCache(modelId, dbId)) {\n        return;\n      }\n\n      // compute Quaternion to align the shape\n      var model = this.modelsById[modelId];\n      var rotation = computeObjectAlignment(model, dbId);\n\n      // compute bbox that we get after rotation\n      this.rotMatrix.makeRotationFromQuaternion(rotation);\n      var box = computeTransformedObjectBox(model, dbId, this.rotMatrix);\n\n      // Store both for next time\n      this._addToCache(modelId, dbId, rotation, box);\n\n      return box;\n    }\n\n    // Check if alignment transform and bbox are already computed\n  }, { key: \"_isInCache\", value: function _isInCache(modelId, dbId) {\n      var modelBoxes = this.boxes[modelId];\n      return Boolean(modelBoxes && modelBoxes[dbId]);\n    }\n\n    // Get resulting bbox that a shape has - assuming that the alignment rotation was already applied.\n    //\n    // Note: We cannot simply transform the fragment world-box here, because this results in a larger\n    //       bbox than transforming the geometry boxes directly to the rotated world position.\n  }, { key: \"getAlignedBox\", value: function getAlignedBox(shapeId, optionalTarget) {var\n\n      modelId = shapeId.modelId,dbId = shapeId.dbId;\n\n      var result = optionalTarget || new THREE.Box3();\n\n      // Make sure that box is in cache\n      this._computeAlignmentAndBox(modelId, dbId);\n\n      // Return box from cache\n      var box = this.boxes[modelId][dbId];\n      return result.copy(box);\n    }\n\n    // Returns the alignment rotation for a shape.\n    // @param {ShapeId}      shapeId\n    // @param {Quaternion}   [optionalTarget]\n    // @returns {Quaternion}\n  }, { key: \"getShapeRotation\", value: function getShapeRotation(shapeId, optionalTarget) {var\n\n      modelId = shapeId.modelId,dbId = shapeId.dbId;\n\n      var result = optionalTarget || new THREE.Quaternion();\n\n      // Make sure that rotation is in cache\n      this._computeAlignmentAndBox(modelId, dbId);\n\n      // Return rotation from cache\n      var rotation = this.rotations[modelId][dbId];\n      return result.copy(rotation);\n    } }]);return RotationAlignment;}();\n;","//\n// An algorithm to computes the placement (ClusterSetLayout) for a set of object clusters.\n//\n\nimport { ClusterRowLayout, ClusterSetLayout } from './ClusterLayout.js';\n\n\n// Computes the x/y extent that we obtain when lining up all shapes in a single row. \n//\n//  @param {bool} autoRotate - If true, we assume that each object is rotated in a way that sizeX <= sizeY.\nvar getRowExtent = function getRowExtent(cluster, shapeBoxes, spacing, autoRotate) {\n\n  // Reused tmp vector\n  var boxDiag = new THREE.Vector3();\n\n  // Accumulated row width\n  var rowSize = new THREE.Vector2();\n\n  for (var i = 0; i < cluster.shapeIds.length; i++) {\n\n    // get shape box diagonal\n    var shapeId = cluster.shapeIds[i];\n    boxDiag = shapeBoxes.getShapeSize(shapeId, boxDiag);\n\n    // get width/height along row\n    var shapeSizeX = autoRotate ? Math.min(boxDiag.x, boxDiag.y) : boxDiag.x;\n    var shapeSizeY = autoRotate ? Math.max(boxDiag.x, boxDiag.y) : boxDiag.y;\n\n    // sum up shape with along the row\n    rowSize.x += shapeSizeX;\n\n    // Track y-extent of row (determined by largest shape along y)\n    rowSize.y = Math.max(rowSize.y, shapeSizeY);\n    rowSize.z = Math.max(rowSize.z, boxDiag.z);\n  }\n\n  // consider spacing\n  rowSize.x += (cluster.shapeIds.length - 1) * spacing;\n\n  return rowSize;\n};\n\n// Given a list of bboxes, this function creates a ClusterLayout that stacks all items vertically.\n//  @param {Cluster}    cluster\n//  @param {ShapeBoxes} shapeBoxes\n//  @param {number}     spacing\nvar createStack = function createStack(cluster, shapeBoxes, spacing) {\n\n  var shapeIds = cluster.shapeIds;\n\n  var layout = new ClusterRowLayout(cluster);\n\n  // Track position where to add next shape\n  var zOffset = 0.0;\n\n  // Reused tmp vector\n  var boxSize = new THREE.Vector3();\n\n  // Why backwards?: Shapes are ordered by increasing size. For stacking, it looks better to start with the largest.\n  for (var i = shapeIds.length - 1; i >= 0; i--) {\n    var shapeId = shapeIds[i];\n\n    // Place shape i\n    layout.positions[i] = new THREE.Vector3(0, 0, zOffset);\n\n    // Size along the row is alway min(sizeX, sizeY)\n    boxSize = shapeBoxes.getShapeSize(shapeId, boxSize);\n\n    // Track layout size\n    layout.size.x = Math.max(layout.size.x, boxSize.x);\n    layout.size.y = Math.max(layout.size.y, boxSize.y);\n    layout.size.z = zOffset + boxSize.y;\n\n    // Step up to next stack level\n    zOffset += boxSize.z + spacing;\n  }\n  return layout;\n};\n\n// Given a list of bboxes, this function creates a ClusterLayout that lines them up in one or more rows.\n//  @param {Cluster}    cluster\n//  @param {ShapeBoxes} shapeBoxes\n//  @param {number}     rowWidth\n//  @param {number}     spacing\n//  @param {number}     autoRotate - If true, each shape is aligned so that sizeX <= sizeY\nvar createRows = function createRows(cluster, shapeBoxes, rowWidth, spacing, autoRotate) {\n\n  var shapeIds = cluster.shapeIds;\n\n  var layout = new ClusterRowLayout(cluster);\n\n  // Track position where to add next shape\n  var nextPos = new THREE.Vector3(0, 0, 0);\n\n  // Reused tmp vector\n  var boxSize = new THREE.Vector3();\n\n  // Track y-extent of current row\n  var rowSizeY = 0;\n\n  for (var i = 0; i < shapeIds.length; i++) {\n    var shapeId = shapeIds[i];\n\n    // Place shape i\n    layout.positions[i] = nextPos.clone();\n\n    // Size along the row is alway min(sizeX, sizeY)\n    boxSize = shapeBoxes.getShapeSize(shapeId, boxSize);\n\n    // If wanted, we orient all shapes so that sizeX < sizeY.\n    layout.rotated[i] = autoRotate && boxSize.x > boxSize.y;\n\n    // get shapeSize in x/y - after rotating in a way that sizeX <= sizeY\n    var shapeSizeX = autoRotate ? Math.min(boxSize.x, boxSize.y) : boxSize.x;\n    var shapeSizeY = autoRotate ? Math.max(boxSize.x, boxSize.y) : boxSize.y;\n\n    // Track y-extent of current row\n    rowSizeY = Math.max(rowSizeY, shapeSizeY);\n\n    // Track overall extent of the whole layout\n    layout.size.x = Math.max(layout.size.x, nextPos.x + shapeSizeX);\n    layout.size.y = Math.max(layout.size.y, nextPos.y + shapeSizeY); // \n    layout.size.z = Math.max(layout.size.z, boxSize.z); // max over all shape heights\n\n    // Shift position along x to next new slot\n    nextPos.x += shapeSizeX + spacing;\n\n    // If width of current row reached the target row width...\n    if (nextPos.x >= rowWidth) {\n      // Start a new row\n      nextPos.x = 0;\n      nextPos.y += rowSizeY + spacing;\n      rowSizeY = 0;\n    }\n  }\n\n  return layout;\n};\n\n// Given a list of shapeIds, this function computes how these can be positioned in order to form a compact block.\n//\n//   @param {Cluster}    cluster    - Note: cluster.shapeIds within the claster will be sorted within this function.\n//   @param {ShapeBoxes} shapeBoxes - to get shape sizes per shapeId\n//   @param {bool}       autoRotate - Ensure sizeX <= sizeY for each shape by auto-rotating by 90 degree if necessary.\n//   @returns {ClusterRowLayout}\nvar createClusterRowLayout = function createClusterRowLayout(cluster, shapeBoxes, spacing, autoRotate) {var enableStacking = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;\n\n  // Sort shapes by increasing yExtent.\n  //\n  // When using autoRotate, we must consider that shapes will be xy-flipped, so that we\n  // must sort by max{xExtent, yExtent} instead.\n  //\n  // Note: The autoRotate option will eventually be removed, because the rotationAlignment can already ensure xExtent <= yExtent,\n  //       so that the layout algorithm can just assume it and always sort by y-extent only.\n  var shapeIds = cluster.shapeIds;\n  var byY = function byY(a, b) {return bySizeY(a, b, shapeBoxes);};\n  var byMaxXY = function byMaxXY(a, b) {return byMaxXYSize(a, b, shapeBoxes);};\n  var pred = autoRotate ? byMaxXY : byY;\n\n  // Sort shapeIds\n  shapeIds.sort(pred);\n\n  // Compute x/y-extent that we would get when lining up all objects in a single row\n  var singleRowSize = getRowExtent(cluster, shapeBoxes, spacing, autoRotate);\n\n  // For simplicity and performance, the code below is just a heuristic: We neglect the fact \n  // that y-extents of rows may be varying. So, depending on the variance of y-extents\n  // we may not get an actual squre. However, at least we usually avoid to odd aspect ratios.\n  // \n  // We would like to choose the number of rows in a way that the cluster gets approximately squared.\n  // Given n rows, we would approximately obtain a cluster for which...\n  //  - sizeX = singleRowSizeX / numRows\n  //  - sizeY = singleRowSizeY * numRows\n  //\n  // To get it approximately square, we choose so that \n  //    sizeX = sizeY\n  //\n  var numRows = Math.sqrt(singleRowSize.x / singleRowSize.y);\n  var rowWidth = singleRowSize.x / numRows;\n\n  var rows = createRows(cluster, shapeBoxes, rowWidth, spacing, autoRotate);\n\n  // For large flat shapes (like floors/ceilings), it may be better to just stack them on top of each other.\n  // So, we try stacking them as well.\n  if (enableStacking) {\n    var stack = createStack(cluster, shapeBoxes, spacing);\n\n    // If the stack height is smaller than the horizonal extent, we use the stack.\n    var useStack = stack.size.z < Math.max(rows.size.x, rows.size.y);\n    if (useStack) {\n      return stack;\n    }\n  }\n\n  return rows;\n};\n\n// Sort predicate to order objects by increasing y-extent\n// Input:\n//   @param {ShapeId}    a          - shapeID a\n//   @param {ShapeId}    b          - shapeID b\n//   @param {ShapeBoxes} shapeBoxes - shape sizes per shapeId\n//\n// Output: -1, if the max extent of object a is greater than of object b\n//          1, otherwise\nvar bySizeY = function bySizeY(a, b, shapeBoxes) {\n\n  // Get bbox extents\n  var diagA = shapeBoxes.getShapeSize(a);\n  var diagB = shapeBoxes.getShapeSize(b);\n\n  // If y-extent is different, use it\n  if (diagA.y != diagB.y) {\n    return diagA.y - diagB.y;\n  }\n\n  // Among shapes with equal y-extent, sort by increasing x-extent\n  if (diagA.x != diagB.x) {\n    return diagA.x - diagB.x;\n  }\n\n  return 0;\n};\n\n\n// Sort predicate to order objects by increasing maxXYExtent (=max(xExtent, yExtent)). \n// Input:\n//   @param {ShapeId}    a          - shapeID a\n//   @param {ShapeId}    b          - shapeID b\n//   @param {ShapeBoxes} shapeBoxes - shape sizes per shapeId\n//\n// Output: -1, if the max extent of object a is greater than of object b\n//          1, otherwise\nvar byMaxXYSize = function byMaxXYSize(a, b, shapeBoxes) {\n\n  // Get bbox extents\n  var diagA = shapeBoxes.getShapeSize(a);\n  var diagB = shapeBoxes.getShapeSize(b);\n\n  // Sort based on the max axis extent.\n  var sizeA = Math.max(diagA.x, diagA.y);\n  var sizeB = Math.max(diagB.x, diagB.y);\n  if (sizeA < sizeB) {\n    return -1;\n  } else\n  if (sizeA > sizeB) {\n    return 1;\n  }\n\n  // If max-entents are equal, sort by minExtent\n  var minExtA = Math.min(diagA.x, diagA.y);\n  var minExtB = Math.min(diagB.x, diagB.y);\n  if (minExtA > minExtB) {\n    return -1;\n  } else if (minExtA < minExtB) {\n    return 1;\n  }\n\n  // If min/max extents are both equal, just sort by id for consistency\n  return b - a;\n};\n\n// Given a set of individual ClusterRowLayouts, this function sets their positions, so that clusters are lined up in a grid or stack as well.\n//\n//  @param {ClusterRowLayout[]} layouts\n//  @param {number}             clusterSpacing - Minimum distance between two clusters\n//  @param {Box3}               sceneBox       - bbox of the full scene (without anim transforms)\nvar setClusterPositions = function setClusterPositions(layouts, clusterSpacing, sceneBox) {\n\n  // For placing the clusters, we use the same code that we used for arranging the shapes within\n  // the cluster. \n  //\n  // Only difference is that the shapes to be placed are actually clusters instead of shapes.\n\n  var parentCluster = {\n    // In this case, shapeIds are just indices into the layouts array\n    shapeIds: new Int32Array(layouts.length) };\n\n\n  // Enlist all cluster indices 0, 1, ..., layouts.length-1.\n  for (var i = 0; i < layouts.length; i++) {\n    parentCluster.shapeIds[i] = i;\n  }\n\n  // ShapeBoxes access when using clusters as shapes.\n  var clusterBoxes = {\n    // Return cluster size\n    getShapeSize: function getShapeSize(shapeId, target) {\n      target = target || new THREE.Vector3();\n      var layout = layouts[shapeId];\n      target.copy(layout.size);\n      return target;\n    } };\n\n\n  // We only align single shapes, but don't rotate clusters. Note that the aspect ratio \n  var autoRotate = false;\n\n  // Run layout to place the clusters\n  var enableStacking = false; // We only use stacking inside clusters. But the clusters themselves are always layouted horizontally.\n  var parentLayout = createClusterRowLayout(parentCluster, clusterBoxes, clusterSpacing, autoRotate, enableStacking);\n\n  // Parent cluster should be horizonally centered at the scene midpoint\n  var origin = sceneBox.getCenter();\n\n  origin.x -= 0.5 * parentLayout.size.x;\n\n  // Start the flea-market behind the actual building\n  origin.y = sceneBox.min.y + 1.1 * (sceneBox.max.y - sceneBox.min.y);\n\n  // Copy positions from parent clusterLayout to the individual cluster positions\n  for (var _i = 0; _i < parentCluster.shapeIds.length; _i++) {\n    // get position for next cluster\n    var clusterPos = parentLayout.positions[_i];\n\n    // Find the corresponding cluster\n    var clusterIndex = parentCluster.shapeIds[_i];\n    var layout = layouts[clusterIndex]; // Note that shapeIds is reordered during layout process. So we cannot assume shapeIds[i]==i anymore\n\n    // set cluster position\n    layout.position.copy(clusterPos).add(origin);\n  }\n};\n\nvar getDefaultOptions = function getDefaultOptions() {\n  return {\n    // minimum distance between two shapes within a group\n    spacing: 1.0,\n\n    // minimum distance between different groups\n    clusterSpacing: 10.0,\n\n    // If true, we stack clusters vertically - otherwise, we line up along x/y\n    stackClusters: true };\n\n};\n\n// Computes a ClusterSetLayout from a set of object clusters.\n//\n// @param {Cluster[]}         layouts    - Each shape group is given by an array of shapeIds\n// @param {ShapeBoxes}        shapeBoxes - Provides bboxes per shape\n// @param {RotationAlignment} [rotationAlignment] - Defines rotations per shape (optional)\n// @param {Object}            options    - configuration params (see getDefaultOptions)\n// @returns {ClusterSetLayout}\nvar createClusterSetLayout = function createClusterSetLayout(clusters, shapeBoxes, rotationAlignment) {var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : getDefaultOptions();\n\n  // When using pre-rotated shapes, the algorithm doesn't need to flipXY for items anymore.\n  var enableXYFlip = !rotationAlignment;\n\n  // Create layout for each cluster\n  var layouts = clusters.map(function (c) {return createClusterRowLayout(c, shapeBoxes, options.spacing, enableXYFlip);});\n\n  // Based on layouts and known cluster sizes, determine the placement of each cluster\n  //setClusterPositions(layouts, shapeBoxes, options.stackClusters, options.clusterSpacing);\n  setClusterPositions(layouts, options.clusterSpacing, shapeBoxes.sceneBox);\n\n  return new ClusterSetLayout(layouts, rotationAlignment);\n};\n\nexport {\ncreateClusterSetLayout };","function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError(\"Cannot call a class as a function\");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}\nimport { RotationAlignment } from './RotationAlignment.js';\n\nvar getSummedModelBox = function getSummedModelBox(models) {\n  var bbox = new THREE.Box3();\n  for (var i = 0; i < models.length; i++) {\n    var modelBox = models[i].getBoundingBox();\n    bbox.union(modelBox);\n  }\n  return bbox;\n};\n\n// Helper class to faciliate access to shape bboxes across multiple models\nvar ShapeBoxes = /*#__PURE__*/function () {\n\n  // @param {bool} [rotationAlignment] - If specified, we don't return the original fragment boxes. Instead, we return the boxes obtained\n  //                                     assuming that an alignment rotation has been applied to each shape. (see RotationAlignment.js for details)\n  function ShapeBoxes(models, rotationAlignment) {var _this = this;_classCallCheck(this, ShapeBoxes);\n\n    // Index modely by modelId\n    this.modelsById = [];\n    models.forEach(function (m) {return _this.modelsById[m.id] = m;});\n\n    // reused for bbox access\n    this.tmpFloat6 = new Float32Array(6);\n    this.tmpBox = new THREE.Box3();\n\n    // Compute summed scene box. Note that sceneBox is always the original scene bbox - not considering alignment rotations per object.\n    this.sceneBox = getSummedModelBox(models);\n\n    // {RotationAlignment}\n    this.rotationAlignment = rotationAlignment;\n  }\n\n  // Return shapeBox that we obtain when not applying any rotationAlignment.\n  // @param {ShapeId} shapeId\n  // @param {Box3}    [optionalTarget]\n  _createClass(ShapeBoxes, [{ key: \"getUnrotatedShapeBox\", value: function getUnrotatedShapeBox(shapeId, optionalTarget) {\n      var box = optionalTarget || new THREE.Box3();var\n\n      modelId = shapeId.modelId,dbId = shapeId.dbId;\n\n      // get instanceTree\n      var model = this.modelsById[modelId];\n      var it = model.getInstanceTree();\n\n      // get box as 6 floats in tmpArray\n      it.getNodeBox(dbId, this.tmpFloat6);\n\n      // convert to Box3\n      var values = this.tmpFloat6;\n      box.min.set(values[0], values[1], values[2]);\n      box.max.set(values[3], values[4], values[5]);\n\n      return box;\n    }\n\n    // @param {ShapeId} shapeId\n    // @param {Box3}    [optionalTarget]\n  }, { key: \"getShapeBox\", value: function getShapeBox(shapeId, optionalTarget) {\n\n      // If shapes are rotated, we must return the bboxes of the rotated shapes instead\n      // of the original fragment boxes.\n      // It would be nice if AlignmentRotation could simply provide only the rotations and ShapeBoxes\n      // apply them to the fragment boxes. Unfortunately, this would not work, because it would unnecessarily \n      // increase the bbox sizes. So, RotationAlignment has to provide own bboxes that are computed by transforming the geometry boxes directly.\n      if (this.rotationAlignment) {\n        return this.rotationAlignment.getAlignedBox(shapeId, optionalTarget);\n      }\n\n      // No rotation applied - just use original boxes.\n      return this.getUnrotatedShapeBox(shapeId, optionalTarget);\n    }\n\n    // get shape box diagonal from a given ShapeId\n  }, { key: \"getShapeSize\", value: function getShapeSize(shapeId, optionalTarget) {\n      var target = optionalTarget || new THREE.Vector3();\n\n      var box = this.getShapeBox(shapeId, this.tmpBox);\n\n      // For empty boxes, the diagonal contains -infinity - which isn't helpful for layouting.\n      // So, we return zero extent for this case.\n      if (box.isEmpty()) {\n        target.set(0, 0, 0);\n      } else {\n        box.size(target);\n      }\n      return target;\n    } }]);return ShapeBoxes;}();export { ShapeBoxes as default };\n;","\n'use strict';function _typeof(obj) {\"@babel/helpers - typeof\";if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;};}return _typeof(obj);}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError(\"Cannot call a class as a function\");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}function _inherits(subClass, superClass) {if (typeof superClass !== \"function\" && superClass !== null) {throw new TypeError(\"Super expression must either be null or a function\");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}function _createSuper(Derived) {var hasNativeReflectConstruct = _isNativeReflectConstruct();return function _createSuperInternal() {var Super = _getPrototypeOf(Derived),result;if (hasNativeReflectConstruct) {var NewTarget = _getPrototypeOf(this).constructor;result = Reflect.construct(Super, arguments, NewTarget);} else {result = Super.apply(this, arguments);}return _possibleConstructorReturn(this, result);};}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");}return self;}function _isNativeReflectConstruct() {if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;if (Reflect.construct.sham) return false;if (typeof Proxy === \"function\") return true;try {Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));return true;} catch (e) {return false;}}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {try {var info = gen[key](arg);var value = info.value;} catch (error) {reject(error);return;}if (info.done) {resolve(value);} else {Promise.resolve(value).then(_next, _throw);}}function _asyncToGenerator(fn) {return function () {var self = this,args = arguments;return new Promise(function (resolve, reject) {var gen = fn.apply(self, args);function _next(value) {asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);}function _throw(err) {asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);}_next(undefined);});};}\n\nimport { buildClustersFromAttribute, Cluster, createShapeId, hasVisibleFragments } from './Cluster.js';\nimport { createClusterSetLayout } from './RowLayoutBuilder.js';\nimport AnimController from './AnimController.js';\nimport ShapeBoxes from './ShapeBoxes.js';\nimport { ObjectAnimState, ModelAnimState, SceneAnimState } from './AnimState.js';\nimport { ClusterGizmoController } from './ClusterGizmo.js';\nimport { RotationAlignment, getBoxCorner, findAlignmentRotation, computeObjectAlignment } from './RotationAlignment.js';\n\nvar av = Autodesk.Viewing;\nvar avu = av.UI;\n\nvar namespace = AutodeskNamespace('Autodesk.Viewing.Extensions.VisualClusters');\n\n// Name of the animation state that organizes all objects in clusters based on Category attribute.\nvar ClusteredStateName = 'ByCategory';\n\nvar createClusterIcon = function createClusterIcon() {\n  return [\n  '<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 143 135\">',\n  '<g fill=\"currentColor\">',\n  '<polygon points=\"29.275 51 9.725 51 0 68.05 9.725 85 29.275 85 39 68.05\"/>',\n  '<polygon points=\"133.275 51 113.725 51 104 68.05 113.725 85 133.275 85 143 68.05\"/>',\n  '<polygon points=\"89.05 0 55.05 0 38 29.55 55.05 59 89.05 59 106 29.55\"/>',\n  '<polygon points=\"89.05 76 55.05 76 38 105.45 55.05 135 89.05 135 106 105.45\"/>',\n  '</g>',\n  '</svg>'].\n  join('');\n};\n\n// Create a clustering layout that forms clusters of objects based on Category attribute.\nvar createDefaultLayout = /*#__PURE__*/function () {var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(models, alignShapeRotation, attribName, searchAncestors) {var modelSupported, clusters, filter, rotationAlignment, shapeBoxes;return regeneratorRuntime.wrap(function _callee$(_context) {while (1) {switch (_context.prev = _context.next) {case 0:\n\n            // Make sure that we only work on supported models\n            modelSupported = function modelSupported(model) {return model.is3d() && Boolean(model.getInstanceTree());};\n            models = models.filter(modelSupported);\n\n            // build clusters\n            _context.next = 4;return buildClustersFromAttribute(models, attribName, searchAncestors);case 4:clusters = _context.sent;\n\n            // Exclude topography & rooms\n            filter = function filter(c) {return c.name != 'Revit Topography' && c.name != 'Revit Rooms' && c.name != 'Revit <Sketch>';};\n            clusters = clusters.filter(filter);\n\n            // Use RotationLayout to orient all shapes in a way that the projected x/y-extent is small\n            rotationAlignment = alignShapeRotation ? new RotationAlignment(models) : null;\n\n            // Create helper for bbox access\n            shapeBoxes = new ShapeBoxes(models, rotationAlignment);\n\n            // Compute layouts\n            return _context.abrupt(\"return\", createClusterSetLayout(clusters, shapeBoxes, rotationAlignment));case 10:case \"end\":return _context.stop();}}}, _callee);}));return function createDefaultLayout(_x, _x2, _x3, _x4) {return _ref.apply(this, arguments);};}();\n\n\n/**\n                                                                                                                                                                                                                                                                             * Purpose of VisualClusters extension is to group objects into clusters.\n                                                                                                                                                                                                                                                                             * \n                                                                                                                                                                                                                                                                             * This means:\n                                                                                                                                                                                                                                                                             *  1. Categories: Form categories by assigning each shape in a model (or multiple) to a unique category, e.g. based on values of a database property.\n                                                                                                                                                                                                                                                                             *  2. Layout:     Compute a \"layout\" that places all shapes in a way that shapes of the same group are located closeby.\n                                                                                                                                                                                                                                                                             *  3. Animation:  Animate between original shape positions and new positions according to cluster layout.\n                                                                                                                                                                                                                                                                             * \n                                                                                                                                                                                                                                                                             * Example: By default, the clustering extension forms clusters based on the \"Category\" Given a building model and 2 groups - windows and doors - the result is that all windows and doors are moved away from their\n                                                                                                                                                                                                                                                                             *          original positions, so that you have one cluster of windows and one cluster of doors located outside the original building.\n                                                                                                                                                                                                                                                                             * \n                                                                                                                                                                                                                                                                             * The extension id is: `Autodesk.VisualClusters`\n                                                                                                                                                                                                                                                                             * \n                                                                                                                                                                                                                                                                             * @example\n                                                                                                                                                                                                                                                                             *   viewer.loadExtension('Autodesk.VisualClusters')\n                                                                                                                                                                                                                                                                             * \n                                                                                                                                                                                                                                                                             *   If you have a 3D model with propertyDb loaded, you should now see a button in the toolbar to trigger clustering based on Category attribute.\n                                                                                                                                                                                                                                                                             *  \n                                                                                                                                                                                                                                                                             * @memberof Autodesk.Viewing.Extensions\n                                                                                                                                                                                                                                                                             * @alias Autodesk.Viewing.Extensions.VisualClusters\n                                                                                                                                                                                                                                                                             * @see {@link Autodesk.Viewing.Extension} for common inherited methods.\n                                                                                                                                                                                                                                                                             * @constructor\n                                                                                                                                                                                                                                                                            */var\nVisualClustersExtension = /*#__PURE__*/function (_av$Extension) {_inherits(VisualClustersExtension, _av$Extension);var _super = _createSuper(VisualClustersExtension);\n  function VisualClustersExtension(viewer, options) {var _this;_classCallCheck(this, VisualClustersExtension);\n    _this = _super.call(this, viewer, options);\n\n    // If true, the toggle button for the layout is pressed and all objects\n    // are arranged in clusters (or being computed or animating towards that state)\n    _this.layoutActive = false;\n\n    // Used to detect if an async layout computation is meanwhile outdated.\n    _this.layoutTimeStamp = 0;\n\n    // Controls transitions between clustered and original state\n    _this.animController = new AnimController(_this.viewer);\n\n    // Controls gizmos and labels for clusters\n    _this.gizmoController = new ClusterGizmoController(_this.viewer);\n\n    // Bind event listener callbacks\n    _this.onModelAddedCb = _this.onModelAdded.bind(_assertThisInitialized(_this));\n    _this.onModelRemovedCb = _this.onModelRemoved.bind(_assertThisInitialized(_this));\n    _this.dbLoadedCb = _this.onDbLoaded.bind(_assertThisInitialized(_this));\n    _this.onTransitionEndedCb = _this.onTransitionEnded.bind(_assertThisInitialized(_this));return _this;\n  }_createClass(VisualClustersExtension, [{ key: \"load\", value: function () {var _load = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {return regeneratorRuntime.wrap(function _callee2$(_context2) {while (1) {switch (_context2.prev = _context2.next) {case 0:_context2.next = 2;return (\n\n\n\n                  this.viewer.loadExtension('Autodesk.Edit3D'));case 2:\n\n                this.viewer.addEventListener(av.MODEL_ADDED_EVENT, this.onModelAddedCb);\n                this.viewer.addEventListener(av.MODEL_REMOVED_EVENT, this.onModelRemovedCb);\n                this.viewer.addEventListener(av.OBJECT_TREE_CREATED_EVENT, this.dbLoadedCb);\n                this.viewer.addEventListener(av.ANIM_ENDED, this.onTransitionEndedCb);return _context2.abrupt(\"return\",\n                true);case 7:case \"end\":return _context2.stop();}}}, _callee2, this);}));function load() {return _load.apply(this, arguments);}return load;}() }, { key: \"unload\", value: function unload()\n\n\n    {\n      this.viewer.removeEventListener(av.MODEL_ADDED_EVENT, this.onModelAddedCb);\n      this.viewer.removeEventListener(av.MODEL_REMOVED_EVENT, this.onModelRemovedCb);\n      this.viewer.removeEventListener(av.OBJECT_TREE_CREATED_EVENT, this.onDbLoaded);\n      this.viewer.removeEventListener(av.ANIM_ENDED, this.onTransitionEndedCb);\n\n      // Revert all anim transform changes.\n      this.animController.reset();\n\n      this._destroyUI();\n      return true;\n    }\n\n    // Reset to initial state.\n  }, { key: \"reset\", value: function reset() {\n      this.animController.reset();\n      this.gizmoController.reset();\n      this.layoutActive = false;\n      this.updateButton();\n    } }, { key: \"onModelAdded\", value: function onModelAdded()\n\n    {\n      this.updateButton();\n    } }, { key: \"onModelRemoved\", value: function onModelRemoved()\n\n    {\n      this.updateButton();\n\n      // Auto-reset: When reset all animation transforms and extension state.\n      // This avoids leaking any state information when switching between views.\n      //\n      // Note: When temporarily switching all models off in a multi-model scenario, auto-reset might\n      //       not be wanted. If we need to support that case, we need a concept to tell the extension\n      //       explicitly whether a view-switch occurred or leave the reset to the client.\n      var lastModelRemoved = !this.viewer.getVisibleModels().length;\n      if (lastModelRemoved) {\n        this.reset();\n      }\n    } }, { key: \"onDbLoaded\", value: function onDbLoaded()\n\n    {\n      this.updateButton();\n    } }, { key: \"onToolbarCreated\", value: function onToolbarCreated()\n\n    {var _this2 = this;\n      this.clusterButton = new avu.Button(\"toolbar-clusterTool\");\n      this.clusterButton.icon.innerHTML = createClusterIcon();\n\n      // add button to toolbar section 'Model Tools'\n      var toolbar = this.viewer.getToolbar && this.viewer.getToolbar();\n      if (toolbar) {\n        var modelTools = toolbar.getControl(av.TOOLBAR.MODELTOOLSID);\n\n        // Add our button to the toolbar\n        if (modelTools) {\n          modelTools.addControl(this.clusterButton);\n        }\n      }\n\n      this.clusterButton.onClick = function () {\n        _this2.setLayoutActive(!_this2.layoutActive);\n      };\n\n      this.updateButton();\n    } }, { key: \"onTransitionStarted\", value: function onTransitionStarted()\n\n    {\n      // check if animation state is available and whether there are clusters\n      // (models with clusters have an animStates array with length bigger than 0)\n      if (ClusteredStateName in this.animController.states &&\n      this.animController.states[ClusteredStateName].animStates.filter(Boolean)[0].animStates.length > 0) {\n        this.viewer.fireEvent({ type: av.TRANSITION_STARTED, sceneAnimState: this.animController.states[ClusteredStateName] });\n      } else {\n        this.viewer.fireEvent({ type: av.TRANSITION_STARTED, sceneAnimState: null });\n      }\n    } }, { key: \"onTransitionEnded\", value: function onTransitionEnded()\n\n    {\n      if (ClusteredStateName in this.animController.states &&\n      this.animController.states[ClusteredStateName].animStates.filter(Boolean)[0].animStates.length > 0) {\n        this.viewer.fireEvent({ type: av.TRANSITION_ENDED, sceneAnimState: this.animController.states[ClusteredStateName] });\n      } else {\n        this.viewer.fireEvent({ type: av.TRANSITION_ENDED, sceneAnimState: null });\n      }\n    } }, { key: \"_destroyUI\", value: function _destroyUI()\n\n    {\n      // Remove button from toolbar\n      if (this.clusterButton) {\n        var toolbar = this.viewer.getToolbar && this.viewer.getToolbar();\n        var modelTools = toolbar && toolbar.getControl(av.TOOLBAR.MODELTOOLSID);\n        if (modelTools) {\n          modelTools.removeControl(this.clusterButton);\n        }\n        this.clusterButton = null;\n      }\n    } }, { key: \"setLayoutActive\", value: function setLayoutActive(\n\n    active) {\n      if (this.layoutActive === active) {\n        return;\n      }\n\n      // Indicate that layout is activated\n      this.layoutActive = active;\n\n      this.updateButton();\n\n      // Layout disabled: Animate back to original state\n      if (!active) {\n        this.onTransitionStarted();\n        this.animController.animateTo(null);\n        this.gizmoController.onLayoutChanged(null);\n        return;\n      }\n\n      this.applyLayout();\n    } }, { key: \"applyLayout\", value: function () {var _applyLayout = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3() {var models, layoutTimeStamp, sceneLayout;return regeneratorRuntime.wrap(function _callee3$(_context3) {while (1) {switch (_context3.prev = _context3.next) {case 0:\n\n\n\n                // get currently visible/loaded models\n                models = this.viewer.getVisibleModels();\n\n                // If a layout computation is active, mark it as outdated.\n                this.layoutTimeStamp++;\n\n                // Remember timestamp so that we can check later if result is still wanted\n                layoutTimeStamp = this.layoutTimeStamp;_context3.next = 5;return (\n                  createDefaultLayout(models, true, this.options.attribName, this.options.searchAncestors));case 5:sceneLayout = _context3.sent;if (!(\n\n\n                !this.layoutActive || layoutTimeStamp !== this.layoutTimeStamp)) {_context3.next = 8;break;}return _context3.abrupt(\"return\");case 8:\n\n\n\n                this.sceneLayout = sceneLayout;\n\n                // Create animation state that represents this layout\n                this.sceneAnimState = sceneLayout.createSceneState(models);\n\n                // Make animation state available \n                this.animController.registerState(ClusteredStateName, this.sceneAnimState);\n\n                this.onTransitionStarted();\n\n                // Animate to clustered layout\n                this.animController.animateTo(ClusteredStateName);\n                this.gizmoController.onLayoutChanged(this.sceneLayout);case 14:case \"end\":return _context3.stop();}}}, _callee3, this);}));function applyLayout() {return _applyLayout.apply(this, arguments);}return applyLayout;}() }, { key: \"updateButton\", value: function updateButton()\n\n\n    {\n      if (!this.clusterButton) {\n        return;\n      }\n\n      var models = this.viewer.getVisibleModels();\n\n      // Only show button if we have >=1 3D model. Note that we cannot rely on this.viewer.impl.is2d, because it\n      // is set after addModel event is fired.\n      var showButton = models.some(function (model) {return model.is3d();});\n      this.clusterButton.setVisible(showButton);\n      if (!showButton) {\n        return;\n      }\n\n      // Disable button if some propDb is still loading or if we don't have any propDb at all.\n      var propDbLoading = function propDbLoading(model) {return model.getPropertyDb() && !model.getPropertyDb().isLoadDone();};\n      var propDbMissing = function propDbMissing(model) {return !propDbLoading(model) && !model.getInstanceTree();};\n      var waitForDb = models.some(propDbLoading);\n      var noPropDb = models.some(propDbMissing);\n      var disable = waitForDb || noPropDb;\n\n      // Choose button tooltip. If we disable, explain why.\n      var tooltip = 'Form Clusters by Category';\n      if (disable) {\n        tooltip = waitForDb ? 'Waiting for database to load' : 'Visual Clustering can only be used if a database is available';\n      }\n      this.clusterButton.setToolTip(tooltip);\n\n      // Set button state\n      if (disable) {\n        this.clusterButton.setState(avu.Button.State.DISABLED);\n      } else {\n        this.clusterButton.setState(this.layoutActive ? avu.Button.State.ACTIVE : avu.Button.State.INACTIVE);\n      }\n    } }]);return VisualClustersExtension;}(av.Extension);export { VisualClustersExtension as default };\n\n\nav.theExtensionManager.registerExtension('Autodesk.VisualClusters', VisualClustersExtension);\n\nnamespace.buildClustersFromAttribute = buildClustersFromAttribute;\nnamespace.Cluster = Cluster;\nnamespace.createShapeId = createShapeId;\nnamespace.createClusterSetLayout = createClusterSetLayout;\nnamespace.ShapeBoxes = ShapeBoxes;\nnamespace.AnimConstroller = AnimController;\nnamespace.hasVisibleFragments = hasVisibleFragments;\nnamespace.ObjectAnimState = ObjectAnimState;\nnamespace.ModelAnimState = ModelAnimState;\nnamespace.SceneAnimState = SceneAnimState;\nnamespace.getBoxCorner = getBoxCorner;\nnamespace.findAlignmentRotation = findAlignmentRotation;\nnamespace.computeObjectAlignment = computeObjectAlignment;\nnamespace.RotationAlignment = RotationAlignment;"],"mappings":";;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AClFA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACvGA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC3UA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACvJA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC7VA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACjKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACpXA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACtWA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACzFA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;A","sourceRoot":""}