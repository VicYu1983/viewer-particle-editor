{"version":3,"sources":["webpack://Autodesk.Extensions.[name]/webpack/bootstrap","webpack://Autodesk.Extensions.[name]/./extensions/VisualClusters/Cluster.js","webpack://Autodesk.Extensions.[name]/./extensions/VisualClusters/AnimState.js","webpack://Autodesk.Extensions.[name]/./extensions/VisualClusters/RotationAlignment.js","webpack://Autodesk.Extensions.[name]/./extensions/VisualClusters/ShapeBoxes.js","webpack://Autodesk.Extensions.[name]/./extensions/VisualClusters/ClusterLayout.js","webpack://Autodesk.Extensions.[name]/./extensions/VisualClusters/RowLayoutBuilder.js","webpack://Autodesk.Extensions.[name]/./extensions/VisualClusters/AnimController.js","webpack://Autodesk.Extensions.[name]/./extensions/VisualClusters/ClusterGizmo.js","webpack://Autodesk.Extensions.[name]/./extensions/VisualClusters/VisualClusters.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","createShapeId","modelId","dbId","Cluster","this","shapeIds","hasVisibleFragments","model","it","getInstanceTree","fragList","getFragmentList","visFlags","myData","fragments","visibilityFlags","allHidden","enumNodeFragments","fragId","skipped","Autodesk","Viewing","Private","MeshFlags","MESH_NOTLOADED","hidden","isFragVisible","uniq","a","Array","from","Set","buildClustersFromAttribute","models","attribName","searchAncestors","clustersByName","promises","tree","getData","instanceTree","dbIds","ids","keys","nodeAccess","dbIdToIndex","map","item","parseInt","fragId2dbId","filter","options","ignoreHidden","propFilter","push","Promise","resolve","reject","getBulkProperties2","result","category","properties","displayValue","cluster","enumNodeChildren","child","id","length","all","clusters","values","tmpMatrix","THREE","Matrix4","tmpVec1","Vector3","getRotationOffset","rotation","center","optionalTarget","rotMatrix","makeRotationFromQuaternion","clone","applyMatrix4","copy","sub","ObjectAnimState","move","scale","rot","Quaternion","rotCenter","add","updateAnimTransform","start","end","Identity","lerpVectors","slerp","src","set","newCenter","adjustMove","oldOffset","newOffset","ModelAnimState","animStates","apply","visibleBoundsDirty","animState","createIfMissing","setAnimState","srcState","getAnimState","createObjectAnimStates","objStart","objEnd","lerp","srcObj","copyFrom","resetTransform","SceneAnimState","forEach","viewer","impl","invalidate","dst","createObjctAnimStates","modelStart","modelEnd","resetTransforms","getBoxCorner","box","min","x","max","y","z","BoxAxisIndices","Uint32Array","BoxAxes","vertices","tmpPoint","matrix","isEmpty","axisIndex","outAxis","vertexOffset","Math","floor","localIndex","indexA","indexB","outRect","v","expandByPoint","findAlignmentRotation","boxAxes","dir","edgeDir","Vector2","quaternion","zAxis","rect","Box2","minArea","Infinity","bestAngle","minExtent","axis","b","axisCount","getAxisCount","getAxis","angleToXAxis","atan2","setFromAxisAngle","getBoundingRect","dx","dy","area","degToRad","computeObjectAlignment","axes","geomList","getGeometryList","geomBox","Box3","worldMatrix","geomId","getGeometryId","getModelBox","getOriginalWorldMatrix","addBox","collectFragBoxAxes","tmpMatrix2","computeTransformedObjectBox","summedBox","tmpBox","fragBox","fullMatrix","multiply","getRotatedFragmentBox","union","RotationAlignment","modelsById","rotations","boxes","bbox","modelRotations","modelBoxes","_isInCache","_addToCache","Boolean","shapeId","_computeAlignmentAndBox","ShapeBoxes","rotationAlignment","tmpFloat6","Float32Array","sceneBox","modelBox","getBoundingBox","getSummedModelBox","getNodeBox","getAlignedBox","getUnrotatedShapeBox","target","getShapeBox","size","applyAlignmentTransform","rotTf","box2","ClusterRowLayout","position","positions","rotated","sceneAnimState","offset","shapeBoxes","targetPos","tmpVec","originalBox","originalPos","subVectors","getShapeRotation","getCenter","setRotationCenter","ClusterSetLayout","layouts","clusterLayouts","state","getRowExtent","spacing","autoRotate","boxDiag","rowSize","getShapeSize","shapeSizeX","shapeSizeY","createStack","layout","zOffset","boxSize","createRows","rowWidth","nextPos","rowSizeY","createClusterRowLayout","enableStacking","byY","bySizeY","byMaxXY","byMaxXYSize","pred","sort","singleRowSize","numRows","sqrt","rows","stack","useStack","diagA","diagB","sizeA","sizeB","minExtA","minExtB","setClusterPositions","clusterSpacing","parentCluster","Int32Array","parentLayout","origin","clusterPos","clusterIndex","createClusterSetLayout","stackClusters","enableXYFlip","AnimController","currentState","states","startState","animControl","stateName","animTime","stopAnim","endState","onTimer","smootherStep","fadeValue","onAnimEnded","isRunning","stop","sceneState","dispatchEvent","type","ANIM_ENDED","avp","createGizmoMesh","material","geom","h","indices","Uint16Array","iblines","vb","vertexCount","srcOffset","dstOffset","BufferGeometry","vbstride","ib","attrPos","BufferAttribute","undefined","itemOffset","attributes","attrNormal","bytesPerItem","normalize","normal","attrIndex","index","attrIndexLines","setAttribute","attributesKeys","createUnitQuadGeom","boxMesh","Mesh","boundingBox","ClusterGizmo","clusterBox","meshName","matman","MeshPhongMaterial","color","transparent","opacity","side","DoubleSide","depthTest","depthWrite","packedNormals","addHDRMaterial","createGizmoMaterial","mesh","scene","opacityParam","AnimatedParam","edgeOpacity","fadeTo","remove","geometry","dispose","removeMaterial","dtor","ClusterGizmoController","gizmos","labels","fadeInDelay","timerId","sceneLayout","getBBox","gizmo","labelPos","text","getLabelText","label","Edit3D","Label3D","setWorldBox","container","style","pointerEvents","addEventListener","e","camera","gizmoBox","dstView","curDistance","distanceTo","dist","flyToView","stopPropagation","startsWith","substring","g","window","clearTimeout","cancelTimer","disposeGizmos","setTimeout","createGizmos","av","avu","UI","namespace","AutodeskNamespace","createDefaultLayout","alignShapeRotation","modelSupported","is3d","VisualClustersExtension","layoutActive","layoutTimeStamp","animController","gizmoController","onModelAddedCb","onModelAdded","onModelRemovedCb","onModelRemoved","dbLoadedCb","onDbLoaded","onTransitionEndedCb","onTransitionEnded","loadExtension","MODEL_ADDED_EVENT","MODEL_REMOVED_EVENT","OBJECT_TREE_CREATED_EVENT","removeEventListener","reset","_destroyUI","updateButton","getVisibleModels","clusterButton","Button","icon","innerHTML","join","toolbar","getToolbar","modelTools","getControl","TOOLBAR","MODELTOOLSID","addControl","onClick","setLayoutActive","fireEvent","TRANSITION_STARTED","TRANSITION_ENDED","removeControl","active","onTransitionStarted","animateTo","onLayoutChanged","applyLayout","createSceneState","registerState","showButton","some","setVisible","propDbLoading","getPropertyDb","isLoadDone","waitForDb","noPropDb","disable","tooltip","setToolTip","setState","State","DISABLED","ACTIVE","INACTIVE","Extension","theExtensionManager","registerExtension","AnimConstroller"],"mappings":"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","file":"VisualClusters/VisualClusters.min.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 840);\n","\n// A ShapeID references a single object within a multi-models scene. \nconst createShapeId = (modelId, dbId) => {\n    return { \n        modelId, \n        dbId \n    };\n};\n\n// A Cluster is a group of objects that is supposed to be positions close to each other.\nclass Cluster {\n\n    constructor(name) {\n\n        // string\n        this.name = name;\n\n        // ShapeID[]\n        this.shapeIds = [];\n    }\n}\n\n// Checks if all fragments of a given dbId are hidden. If so, we exclude it from layout algorithm, because it would just produce empty space.\nconst hasVisibleFragments = (model, dbId) => {\n\n    const it = model.getInstanceTree();\n    const fragList = model.getFragmentList();\n    const visFlags = model.myData.fragments.visibilityFlags;\n\n    // Update fragment animation transforms\n    let allHidden = true;\n    it.enumNodeFragments(dbId, fragId => {\n\n        // For OTG models, the visFlags tell us which fragments have been skipped by OtgLoader. This applies for Revit Room geometry.\n        // For Svf, these flags may not exist, because they are deleted after loading. However, SvfLoader then sets the corresponding fragments to invisible.\n        const skipped = visFlags && (visFlags[fragId] === Autodesk.Viewing.Private.MeshFlags.MESH_NOTLOADED);\n        const hidden = !fragList.isFragVisible(fragId);\n\n        if (!skipped && !hidden) {\n            // We found a visible fragment\n            allHidden = false;\n\n            // No need to continue traversal\n            return true;\n        }\n    })\n    return !allHidden;\n};\n\n// Remove duplicates from array\n//  @param {[]} a\n//  @returns {[]} Deduplicated copy.\nconst uniq = (a) => {\n    return Array.from(new Set(a));\n};\n\n// Creates a set of clusters based on the values of a certain propertyDB attribute.\n// Note that you have to wait for an async propDB call to finish.\n//\n// By default, we only categorize leaf objects. This requires that all leaf objects contain the attribute to search for.\n// The searchParents option enables to allow parent nodes as well:\n//      i.e. we search all levels of the model tree and consider inner nodes as a single object if they contain\n//           the search attribute.\n//\n//  @param {Model[]}   models\n//  @param {string}    attribName\n//  @param {boolean}   searchParents\n//  @returns {Promise} When done, it resolves to a {Cluster[]}, where each element is...\n//                       - named by an attribute value \n//                       - containing all ShapeIds that match that value\nconst buildClustersFromAttribute = async (models, attribName = 'Category', searchAncestors = false) => {\n\n    // Collects result\n    const clustersByName = {};\n\n    // For each model, we run an async propDB worker query\n    const promises = [];\n\n    for (let i=0; i<models.length; i++) {\n\n        let model = models[i];\n        const tree = model.getData().instanceTree;\n        let dbIds;\n\n        if (searchAncestors) {\n            // Use all the dbIds in the model\n            const ids = Object.keys(tree.nodeAccess.dbIdToIndex);\n            dbIds = ids.map(item => parseInt(item, 10));\n        } else {\n            // get all dbIds with visual representation\n            dbIds = model.myData.fragments.fragId2dbId;\n\n            // Exclude all dbIds that only contain hidden fragments (like room geometries)\n            dbIds = dbIds.filter(dbId => hasVisibleFragments(model, dbId));\n\n            // Remove duplicates. Note that this is necessary, because dbIds with multiple fragments will\n            // occur several times in fragId2dbId.\n            dbIds = uniq(dbIds);\n        }\n\n        const options = {\n            ignoreHidden: false,\n            propFilter: [attribName]\n        };\n\n        promises.push(new Promise((resolve, reject) => {\n\n            // Process dbIds. result is an array of item,\n            // each containing the props for a single dbId\n            const onDone = (result) => {\n                for (let i=0; i<result.length; i++) {\n\n                    // item contains props of a single db object\n                    const item = result[i];\n\n                    // get category of this db item  \n                    const category = item.properties[0].displayValue;\n            \n                    // get or create cluster for this category\n                    const cluster = clustersByName[category];\n                    if (!cluster) {\n                        cluster = new Cluster(category);\n                        clustersByName[category] = cluster;\n                    }\n\n                    if (searchAncestors) {\n                        // Append IDs of visible children\n                        tree.enumNodeChildren(item.dbId, child => {\n                            if (hasVisibleFragments(model, child)) {\n                                cluster.shapeIds.push(createShapeId(model.id, child));\n                            }\n                        }, true);\n                    } else {\n                        // Append current dbId to this cluster\n                        cluster.shapeIds.push(createShapeId(model.id, item.dbId));\n                    }\n                }\n                resolve();\n            };\n\n            model.getBulkProperties2(dbIds, options, onDone);\n        }));\n    }\n\n    await Promise.all(promises);\n\n    // Flatten to an array\n    let clusters = Object.values(clustersByName);\n\n    return clusters;\n};\n\nexport {\n    buildClustersFromAttribute,\n    Cluster,\n    createShapeId,\n    hasVisibleFragments\n}\n","// Contains classes to control the animation state of animation for objects of one or more models.\n\nconst tmpMatrix = new THREE.Matrix4();\nconst tmpVec1 = new THREE.Vector3();\n\n// Get translation offset that is needed to make the given\n// point center of the rotation.\n//  @param {Quaternion} rotation\n//  @param {Vector3}    center\n//  @param {Vecotr3}    [optionalTarget]\n//  @returns {THREE.Vector3}\nconst getRotationOffset = (rotation, center, optionalTarget) => {\n\n    const result = optionalTarget || new THREE.Vector3();\n    \n    // get rotation as matrix\n    let rotMatrix = tmpMatrix.makeRotationFromQuaternion(rotation);\n    \n    // Compute where center would be moved when just applying rotation alone\n    const p = center.clone().applyMatrix4(rotMatrix);\n\n    // Return correction offset to bring center back at its original position\n    return result.copy(center).sub(p);\n};\n\n// Describes an animation transform to be applied to single object. \n// Note that placement is relative to original position, i.e., identity means shape appears at original position.\nexport class ObjectAnimState {\n\n    constructor(dbId) {\n\n        // id of the object being animated\n        this.dbId = dbId;\n\n        // translation\n        this.move = new THREE.Vector3(0,0,0);\n\n        // scale\n        this.scale = new THREE.Vector3(1,1,1);\n\n        // rotation (as Quaternion)\n        //\n        // Note: Note that fragment animTransforms always rotate around the world origin, \n        //       because the original matrix is applied first.\n        this.rot = new THREE.Quaternion();\n\n        // By default, fragment rotations in LMV rotate around the world-origin.\n        this.rotCenter = new THREE.Vector3(0,0,0);\n    }\n\n    apply(model) {\n\n        const fragList = model.getFragmentList();\n        const it = model.getInstanceTree();\n\n        // Apply additional correction offset when rotating around a center != origin.\n        // Note that rotations set by updateAnimTransform always rotate around world origin.\n        const move = getRotationOffset(this.rot, this.rotCenter, tmpVec1).add(this.move);\n\n        // Update fragment animation transforms\n        it.enumNodeFragments(this.dbId, fragId => {\n            fragList.updateAnimTransform(fragId, this.scale, this.rot, move);\n        });\n    }\n\n    // Set this placement by interpolating between a start and end placement\n    //  @param {ItemPlacement} start, end - If null, we assume identity transform.\n    //  @param {number}        t          - interpolation param in [0,1]\n    lerp(start, end, t) {\n        \n        // use identiy transform if start or end is missing\n        start = start || ObjectAnimState.Identity;\n        end   = end   || ObjectAnimState.Identity;\n\n        // Interpolate move/scale/rotation\n        this.move.lerpVectors(start.move, end.move, t);\n        this.scale.lerpVectors(start.scale, end.scale, t);\n        this.rotCenter.lerpVectors(start.rotCenter, end.rotCenter, t);\n        THREE.Quaternion.slerp(start.rot, end.rot, this.rot, t);\n    }\n\n    copyFrom(src) {\n        this.dbId = src.dbId;\n        this.move.copy(src.move);\n        this.scale.copy(src.scale);\n        this.rot.copy(src.rot);\n        this.rotCenter.copy(src.rotCenter);\n    }\n\n    resetTransform() {\n        this.move.set(0,0,0);\n        this.scale.set(1,1,1);\n        this.rot.set(0,0,0,1); // = identity Quaternion\n        this.rotCenter.set(0,0,0);\n    }\n\n    // Set rotation center. \n    // @param {Vector3} center\n    // @param {bool}    ajdustMove - If true, the move vector is changed so that the effect of the AnimState keeps the same.\n    setRotationCenter(newCenter, adjustMove) {\n\n        // Adjust translation offset to keep position\n        if (adjustMove) {\n            \n            // Compute the shift that the shape position would do without move adjustment.\n            // This could be optimized by avoiding double-computation of the rotation matrix.\n            const oldOffset = getRotationOffset(this.rot, this.rotCenter);\n            const newOffset = getRotationOffset(this.rot, newCenter);\n            \n            // Modify translation to eliminate the position shift\n            this.move.add(oldOffset).sub(newOffset);\n        }\n\n        // Change rotationCenter\n        this.rotCenter.copy(newCenter);\n    }\n}\n\n// Represents the original state of an object when no anim transform is applied.\nObjectAnimState.Identity = new ObjectAnimState(-1);\n\n// Describes animation transforms for a set of objects within the same RenderModel\nexport class ModelAnimState {\n\n    constructor(model) {\n\n        this.model = model;\n\n        // Indexed by dbId.\n        this.animStates = []; // ObjectAnimState[]\n    }\n\n    apply() {\n        for (var dbId in this.animStates) {\n            this.animStates[dbId].apply(this.model);\n        }\n\n        // Make sure that hierarchical bboxes are updated\n        this.model.visibleBoundsDirty = true;\n    }\n\n    // Finds or creates an animState for the given dbId.\n    //  @param {number}          dbId\n    //  @param {ObjectAnimState} animState\n    setAnimState(dbId, animState) {\n        this.animStates[dbId] = animState;\n    }\n\n    getAnimState(dbId, createIfMissing = false) {\n\n        let animState = this.animStates[dbId];\n\n        // Create new one if needed\n        if (!animState && createIfMissing) {\n            animState = new ObjectAnimState(dbId);\n            this.setAnimState(dbId, animState);\n        }\n\n        return animState;\n    }\n\n    // Adds new ObjectAnimStates for all dbIds in srcState.\n    //\n    // This is important if you use this to interpolate between other ModelStates and want to make sure that this ModelState\n    // affects all dbIds that are affected either by startState or endState.\n    //\n    // @param {ModelAnimState} srcState\n    createObjctAnimStates(srcState) {\n        for (let key in srcState.animStates) {\n\n            // Note that key is the dbId as string. \n            // => Use the integer variant from srcState instead.\n            const dbId = srcState.animStates[key].dbId;\n\n            // Make sure that we have an ObjectAnimState for this dbId\n            this.getAnimState(dbId, true);\n        }\n    }\n\n    // Prepares this ModelState to interpolate between two others:\n    // For this, we make sure that this ModelState affects all dbIds that are modified by either start or end.\n    prepareLerp(start, end) {\n        this.createObjectAnimStates(start);\n        this.createObjectAnimStates(end);\n    }\n\n    // Updates all ObjectAnimStates by interpolating between a start and end anim state.\n    //\n    // Note: This only affects the existing ObjectAnimStates within this ModelAnimState.\n    //       It does NOT create new AnimStates. See prepareLerp()\n    // \n    //  @param {ModelAnimState} start, end - may be null (= original state)\n    //  @param {number}         t          - interpolation param in [0,1]\n    lerp(start, end, t) {\n        for (let dbId in this.animStates) {\n            const objStart = start && start.animStates[dbId];\n            const objEnd   = end   && end.animStates[dbId];\n            this.animStates[dbId].lerp(objStart, objEnd, t);\n        }\n    }\n\n    copyFrom(src) {\n\n        this.model = src.model;\n\n        // Make sure that we set the same ObjectAnimStates as src.\n        // Avoid re-allocations if possible.\n        for (let dbId in src.animStates) {\n            // get or create state\n            const srcObj = src.animStates[dbId];\n            const dstObj = this.getAnimState(dbId, true);\n            dstObj.copyFrom(srcObj);\n        }\n\n        // Clean all object animStates that src doesn't have\n        for (let dbId in this.animStates) {\n            if (!src.animStates[dbId]) {\n                delete this.animStates[dbId];\n            }\n        }\n    }\n\n    // Reset anim transforms for all fragments that were modified by this state\n    resetTransforms() {\n        for (let dbId in this.animStates) {\n            this.animStates[dbId].resetTransform();\n        }\n    }\n}\n\n// Describes animations for several objects within a scene composed from multiple models.\nexport class SceneAnimState {\n\n    constructor(models) {\n        \n        // ModelAnimState[] - indexed by modelId\n        this.animStates = [];\n\n        // Create a model placement for each model, indexed by modelId\n        models && models.forEach(m => this.animStates[m.id] = new ModelAnimState(m));\n    }\n\n    apply(viewer) {\n        // Apply all model anim states\n        for (let modelId in this.animStates) {\n            this.animStates[modelId].apply();\n        }\n\n        // Force re-render\n        viewer.impl.invalidate(true, true, true);\n    }\n\n    // Set animation state for a single object\n    // Note that modelId must be the id of one of the models used for construction\n    setAnimState(modelId, dbId, animState) {\n        this.animStates[modelId].setAnimState(dbId, animState);\n    }\n\n    // Adds new ObjectAnimStates for all dbIds in srcState.\n    // see ModelAnimState.createObjectAnimStates for details.\n    //\n    // @param {ModelAnimState} srcState\n    createObjectAnimStates(srcState) {\n        for (let modelId in srcState.animStates) {\n            // get src ModelAnimState\n            const src = srcState.animStates[modelId];\n\n            // Get or create target ModelState for this model\n            let dst = this.animStates[modelId];\n            if (!dst) {\n                dst = new ModelAnimState(src.model);\n                this.animStates[modelId] = dst;\n            }\n\n            // Make sure that this ModelState operates on the same dbIds as src\n            dst.createObjctAnimStates(src);\n        }\n    }\n\n    // Prepares this SceneAnimState to interpolate between two others:\n    // For this, we make sure that this SceneAnimState affects all dbIds that are modified by either start or end.\n    //  @param {SceneAnimState} start, end\n    prepareLerp(start, end) {\n        this.createObjctAnimStates(start);\n        this.createObjctAnimStates(end);\n    }\n\n    // Set this placement by interpolating between a start and end placement\n    // Note:\n    //  - All placements must refer to the same list of models\n    //  - For each model, all placements must enlist the same dbIds\n    // \n    //  @param {ScenePlacement} start, end\n    //  @param {number}         t          - interpolation param in [0,1]\n    lerp(start, end, t) {\n        for (let modelId in this.animStates) {\n            const modelStart = start && start.animStates[modelId];\n            const modelEnd   = end   && end.animStates[modelId];\n            this.animStates[modelId].lerp(modelStart, modelEnd, t);\n        }\n    }\n\n    // Makes this SceneState equal to the src state.\n    copyFrom(srcState) {\n\n        for (let modelId in srcState.animStates) {\n            const src = srcState.animStates[modelId];\n            let   dst = this.animStates[modelId];\n\n            // In case we don't have a ModelState for this model, create one\n            if (!dst) {\n                dst = new ModelAnimState(src.model);\n                this.animStates[modelId] = dst;\n            }\n\n            dst.copyFrom(src);\n        }\n\n        // Erase any modelState that src doesn't have\n        for (let modelId in this.animStates) {\n            if (!srcState.animStates[modelId]) {\n                delete this.animStates[modelId];\n            }\n        }\n    }\n\n    // Reset anim transforms for all fragments that were modified by this state\n    resetTransforms() {\n        for (let modelId in this.animStates) {\n            this.animStates[modelId].resetTransforms();\n        }\n    }\n}\n\n","// The purpose of this file is to compute the necessary transforms to rotate\n// all objects in a way that...\n//\n//  1. Identical objects are oriented in the same way\n//  2. Objects are horizontally aligned with the main axes x/y to reduce bbox extents.\n//  3. Up-Vector is preserved\n//\n// It also provides methods to consider these rotations during computation of\n// cluster layout and animation.\n\n// @param {Box3}   box\n// @param {number} i - in [0, 7]\nexport const getBoxCorner = (box, i) => {    \n    return new THREE.Vector3(\n        (i & 1) ? box.min.x : box.max.x,\n        (i & 2) ? box.min.y : box.max.y,\n        (i & 4) ? box.min.z : box.max.z\n    );\n};\n\n// Each element is a corner index. Each pair of two forms a main axis direction.\nconst BoxAxisIndices = Uint32Array.from([\n    0, 1, 0, 2, 0, 4\n]);\n\n// Helper class to enumerate the main axis directions of one or more rotated bboxes.\nclass BoxAxes {\n\n    constructor() {\n        // Transforming vertices turned out to be the major cost factor. So we use indexing to reduce it.\n        this.vertices = [];\n\n        this.tmpPoint = new THREE.Vector3();\n    }\n\n    // @param {Box3}    box\n    // @param {Matrix4} matrix - orientation of the box\n    addBox(box, matrix) {\n\n        // It's important to skip empty boxes. Otherwise, we would produce infinite \n        // extents after transforming min/max\n        if (box.isEmpty()) {\n            return;\n        }\n\n        // add 8 box corners\n        for (let i=0; i<8; i++) {\n            const p = getBoxCorner(box, i).applyMatrix4(matrix);\n            this.vertices.push(p);\n        }\n    }\n\n    // Sets outAxis.indexA and outAxis.indexB to vertex numbers of the given edge\n    //\n    // @param {number} axisIndex\n    // @param {Object} outAxis.indexA and outAxis.indexB will be set.\n    getAxis(axisIndex, outAxis) {\n        // Get offset where the vertices of the box start\n        const boxIndex = Math.floor(axisIndex / 3); // 3 axes per box\n        const vertexOffset = 8 * boxIndex;          // 8 vertices per box\n\n        // Get index into BoxAxisIndices\n        const localIndex = (2 * axisIndex) % BoxAxisIndices.length; // 2 values per axis\n\n        outAxis.indexA = vertexOffset + BoxAxisIndices[localIndex];\n        outAxis.indexB = vertexOffset + BoxAxisIndices[localIndex + 1];\n    }\n\n    getAxisCount() {\n        const boxCount = this.vertices.length / 8;\n        const AxesPerBox = 3;\n        return boxCount * AxesPerBox;\n    }\n\n    // Returns bounding rectangle of all boxes if we transform all points by the given matrix\n    //  @param {Box2}    outRect\n    //  @param {Matrix4} matrix\n    getBoundingRect(outRect, matrix) {\n        for (let v of this.vertices) {\n            // add transformed vertex to bbox\n            const p = this.tmpPoint.copy(v).applyMatrix4(matrix);\n            outRect.expandByPoint(p);\n        }\n    }\n};\n\n// Find rotation around z-axis that brings the given (horizontal) direction to the x-axis\n//\n//  @param {Vector2}  dir - Does not need to be normalized\n//  @returns {number} ccw angle in radians. Rotate by this angle to bring dir to xAxis.\nexport const getAngleToXAxis = (dir) => {\n    return -Math.atan2(dir.y, dir.x);\n};\n\n// Collects main axes of all fragment geometry boxes and projects them to world-space.\n//  @returns {BoxAxes} \nexport const collectFragBoxAxes = (model, dbId) => {\n\n    let boxAxes = new BoxAxes();\n\n    const geomList = model.getGeometryList();\n    const fragList = model.getFragmentList();\n    \n    // Reused tmp-values\n    const geomBox     = new THREE.Box3();\n    const worldMatrix = new THREE.Matrix4();\n\n    // For each fragment...\n    const it = model.getInstanceTree();\n    it.enumNodeFragments(dbId, (fragId) => {\n\n        // Set geomBox to geometry bbox in object-space (for otg, it will simply be the unit box)\n        const geomId = fragList.getGeometryId(fragId);\n        geomList.getModelBox(geomId, geomBox);\n\n        // get fragment world matrix\n        fragList.getOriginalWorldMatrix(fragId, worldMatrix);\n\n        // collect bbox with transform\n        boxAxes.addBox(geomBox, worldMatrix);\n    });\n    return boxAxes;\n};\n\n// Given vertices and axis directions of bboxes, this function finds a rotation around z so that...\n//  - area of the boundsXY is minimized\n//  - We always have xExtent <= yExtent for boundsXY\n// where boundsXY is the bounding box of the xy-projection of all boxes.\n//\n// Note: We assume here that the optimal solution will align one of the edges with the x-axis.\n//\n//  @param {BoxAxes} boxAxes\n//  @returns {Quaternion}\nexport const findAlignmentRotation = (boxAxes) => {\n\n    // Reused in the loop below\n    const edgeDir    = new THREE.Vector2();\n    const quaternion = new THREE.Quaternion();\n    const rotMatrix  = new THREE.Matrix4();\n    const zAxis      = new THREE.Vector3(0,0,1);\n    const rect       = new THREE.Box2();\n\n    let minArea        = Infinity;\n    let bestAngle      = null;\n    let minExtent      = new THREE.Vector2();\n\n    // An axis direction, given by two indices into boxAxes.vertices\n    const axis = { \n        indexA: 0, \n        indexB: 0 \n    };\n    let a = null;\n    let b = null;\n\n    // For each edge...\n    const axisCount = boxAxes.getAxisCount();\n    for (let i=0; i<axisCount; i++) {\n\n        // get edge\n        boxAxes.getAxis(i, axis);\n        a = boxAxes.vertices[axis.indexA];\n        b = boxAxes.vertices[axis.indexB];\n\n        // get edge direction\n        edgeDir.set(b.x-a.x, b.y-a.y);\n\n        // compute rotation matrix that brings that angle to x-axis (ccw radians)\n        let angleToXAxis = getAngleToXAxis(edgeDir);\n        quaternion.setFromAxisAngle(zAxis, angleToXAxis);\n        rotMatrix.makeRotationFromQuaternion(quaternion);\n\n        // compute xy-bounding rectangle that we get when using this angle\n        boxAxes.getBoundingRect(rect, rotMatrix);\n\n        // compute area\n        const dx = rect.max.x - rect.min.x;\n        const dy = rect.max.y - rect.min.y;\n        const area = dx * dy;\n\n        // If this area is better than our candidates so far, use it\n        if (area < minArea) {\n            // keep rotation that minimized area so far\n            minExtent.set(dx, dy);\n            minArea   = area;\n            bestAngle = angleToXAxis;\n        }\n    }\n\n    // If needed, rotate by another 90 degree to ensure xExtent < yExtent.\n    // Note that this doesn't change the area\n    if (minExtent.x > minExtent.y) {\n        bestAngle += THREE.Math.degToRad(90.0);\n    }\n\n    // Compute final quaternion\n    quaternion.setFromAxisAngle(zAxis, bestAngle);\n    return quaternion;\n};\n\n// Computes a rotation transform for a given dbId that aligns the object horizontally, so that:\n//  - xy extent of the bbox is minimized\n//  - xExtent <= yExtent\n// @returns {Quaternion}\nexport const computeObjectAlignment = (model, dbId) => {\n\n    // project the main axes of all fragment geometry boxes to world-space\n    const axes = collectFragBoxAxes(model, dbId); // {Vector3[]} with two vectors per edge\n\n    // find rotation that minimizes the x/y-bbox of all transformed boxes\n    return findAlignmentRotation(axes);\n};\n\nconst tmpMatrix  = new THREE.Matrix4();\nconst tmpMatrix2 = new THREE.Matrix4();\n\n// Returns the bbox that we obtain when applying the given rotationMatrix\n// to the given fragment as animation transform, i.e., applied after world matrix.\nexport const getRotatedFragmentBox = (model, fragId, rotMatrix, optionalTarget) => {\n\n    const result = optionalTarget || new THREE.Box3();\n\n    const fragList = model.getFragmentList();\n    const geomList = model.getGeometryList();\n\n    // Get fragment worldMatrix. Note that we don't want it to be affected by current animation state.\n    const worldMatrix = tmpMatrix;\n    fragList.getOriginalWorldMatrix(fragId, worldMatrix);\n\n    // Apply worldMatrix then rotMatrix\n    const fullMatrix = tmpMatrix2.copy(rotMatrix).multiply(worldMatrix);\n\n    // Get geometry bbox in object-space (for otg, it will simply be the unit box)\n    const geomId = fragList.getGeometryId(fragId);\n    geomList.getModelBox(geomId, result);\n\n    // Applying a matrix turns an empty box into an infinite one. So, we must skip it for empty boxes\n    if (!result.isEmpty()) {\n        // Apply combined matrix to geometry box.\n        // Note that we cannot simply rotate the fragment's worldBox here, because\n        // this would sometimes result in an unnecessary large bbox.\n        result.applyMatrix4(fullMatrix);\n    }\n\n    return result;\n};\n\n// Given a list of fragment ids and an addtional transform to be applied to each of those,\n// this function computes the resulting bbox when applying fragment worldMatrix + given transform to each\n// fragment geometry.\n//\n//  @param {Model}   model\n//  @param {dbId}    dbId\n//  @param {Matrix4} matrix\nexport const computeTransformedObjectBox = (model, dbId, matrix) => {\n\n    const summedBox = new THREE.Box3();\n    const tmpBox    = new THREE.Box3();\n\n    // For each fragment...\n    const it = model.getInstanceTree();\n    it.enumNodeFragments(dbId, (fragId) => {\n        // add aligned box of this fragment\n        const fragBox = getRotatedFragmentBox(model, fragId, matrix, tmpBox);\n        summedBox.union(fragBox);\n    });\n\n    return summedBox;\n};\n\n// Computes for each object an alignment rotation with the goal that...\n//  - x/y extent is minimized\n//  - z-axis is preserved\n//  - xExtent <= yExtent\nexport class RotationAlignment {\n\n    // @param {Model[]}\n    constructor(models) {\n\n        // Index modely by modelId\n        this.modelsById = [];\n        models.forEach(m => this.modelsById[m.id] = m);\n\n        // Caches of rotations and bboxes for rotated shapes\n        this.rotations = []; // {Quaternion[][]}\n        this.boxes     = []; // {Box3[][]} - boxes of rotated fragments\n\n        // Reused tmp matrix\n        this.rotMatrix = new THREE.Matrix4();\n    };\n\n    // Store alignment rotation and bbox for a shape in cache\n    _addToCache(modelId, dbId, rotation, bbox) {\n\n        // Get or create arrays for cached rotations and boxes for this model\n        let modelRotations = this.rotations[modelId];\n        let modelBoxes     = this.boxes[modelId]; \n        if (!this.rotations[modelId]) {\n            // first rotation for this model => create new array\n            modelRotations = [];\n            modelBoxes     = [];\n            this.rotations[modelId] = modelRotations;\n            this.boxes[modelId]     = modelBoxes;\n        }\n\n        // store rotation and bbox in cache\n        modelRotations[dbId] = rotation;\n        modelBoxes[dbId]     = bbox;\n    }\n\n    // Make sure that rotation and rotated box are in cache\n    _computeAlignmentAndBox(modelId, dbId) {\n\n        // Skip if already cached\n        if (this._isInCache(modelId, dbId)) {\n            return;\n        }\n\n        // compute Quaternion to align the shape\n        const model = this.modelsById[modelId];\n        const rotation = computeObjectAlignment(model, dbId);\n\n        // compute bbox that we get after rotation\n        this.rotMatrix.makeRotationFromQuaternion(rotation);\n        const box = computeTransformedObjectBox(model, dbId, this.rotMatrix);\n\n        // Store both for next time\n        this._addToCache(modelId, dbId, rotation, box);\n\n        return box;\n    }\n\n    // Check if alignment transform and bbox are already computed\n    _isInCache(modelId, dbId) {\n        const modelBoxes = this.boxes[modelId];\n        return Boolean(modelBoxes && modelBoxes[dbId]);\n    }\n\n    // Get resulting bbox that a shape has - assuming that the alignment rotation was already applied.\n    //\n    // Note: We cannot simply transform the fragment world-box here, because this results in a larger\n    //       bbox than transforming the geometry boxes directly to the rotated world position.\n    getAlignedBox(shapeId, optionalTarget) {\n\n        const { modelId, dbId } = shapeId;\n\n        const result = optionalTarget || new THREE.Box3();\n\n        // Make sure that box is in cache\n        this._computeAlignmentAndBox(modelId, dbId);\n\n        // Return box from cache\n        const box = this.boxes[modelId][dbId];\n        return result.copy(box);\n    }\n\n    // Returns the alignment rotation for a shape.\n    // @param {ShapeId}      shapeId\n    // @param {Quaternion}   [optionalTarget]\n    // @returns {Quaternion}\n    getShapeRotation(shapeId, optionalTarget) {\n\n        const { modelId, dbId } = shapeId;\n\n        const result = optionalTarget || new THREE.Quaternion();\n\n        // Make sure that rotation is in cache\n        this._computeAlignmentAndBox(modelId, dbId);\n\n        // Return rotation from cache\n        const rotation = this.rotations[modelId][dbId];\n        return result.copy(rotation);\n    }\n};\n","\nimport { RotationAlignment } from './RotationAlignment.js';\n\nconst getSummedModelBox = (models) => {\n    let bbox = new THREE.Box3();\n    for (let i=0; i<models.length; i++) {\n        const modelBox = models[i].getBoundingBox();\n        bbox.union(modelBox);\n    }\n    return bbox;\n};\n\n// Helper class to faciliate access to shape bboxes across multiple models\nexport default class ShapeBoxes {\n\n    // @param {bool} [rotationAlignment] - If specified, we don't return the original fragment boxes. Instead, we return the boxes obtained\n    //                                     assuming that an alignment rotation has been applied to each shape. (see RotationAlignment.js for details)\n    constructor(models, rotationAlignment) {\n\n        // Index modely by modelId\n        this.modelsById = [];\n        models.forEach(m => this.modelsById[m.id] = m);\n\n        // reused for bbox access\n        this.tmpFloat6 = new Float32Array(6);\n        this.tmpBox = new THREE.Box3();\n\n        // Compute summed scene box. Note that sceneBox is always the original scene bbox - not considering alignment rotations per object.\n        this.sceneBox = getSummedModelBox(models);\n\n        // {RotationAlignment}\n        this.rotationAlignment = rotationAlignment;\n    }\n\n    // Return shapeBox that we obtain when not applying any rotationAlignment.\n    // @param {ShapeId} shapeId\n    // @param {Box3}    [optionalTarget]\n    getUnrotatedShapeBox(shapeId, optionalTarget) {\n        const box = optionalTarget || new THREE.Box3();\n\n        const { modelId, dbId } = shapeId;\n\n        // get instanceTree\n        const model = this.modelsById[modelId];\n        const it    = model.getInstanceTree();\n\n        // get box as 6 floats in tmpArray\n        it.getNodeBox(dbId, this.tmpFloat6);\n\n        // convert to Box3\n        const values = this.tmpFloat6;\n        box.min.set(values[0], values[1], values[2]);\n        box.max.set(values[3], values[4], values[5]);\n\n        return box;\n    }\n\n    // @param {ShapeId} shapeId\n    // @param {Box3}    [optionalTarget]\n    getShapeBox(shapeId, optionalTarget) {\n\n        // If shapes are rotated, we must return the bboxes of the rotated shapes instead\n        // of the original fragment boxes.\n        // It would be nice if AlignmentRotation could simply provide only the rotations and ShapeBoxes\n        // apply them to the fragment boxes. Unfortunately, this would not work, because it would unnecessarily \n        // increase the bbox sizes. So, RotationAlignment has to provide own bboxes that are computed by transforming the geometry boxes directly.\n        if (this.rotationAlignment) {\n            return this.rotationAlignment.getAlignedBox(shapeId, optionalTarget);\n        } \n\n        // No rotation applied - just use original boxes.\n        return this.getUnrotatedShapeBox(shapeId, optionalTarget);\n    }\n\n    // get shape box diagonal from a given ShapeId\n    getShapeSize(shapeId, optionalTarget) {\n        const target = optionalTarget || new THREE.Vector3();\n\n        const box = this.getShapeBox(shapeId, this.tmpBox);\n\n        // For empty boxes, the diagonal contains -infinity - which isn't helpful for layouting.\n        // So, we return zero extent for this case.\n        if (box.isEmpty()) {\n            target.set(0,0,0);\n        } else {\n            box.size(target);\n        }\n        return target;\n    }\n};\n","import { ObjectAnimState, SceneAnimState } from './AnimState.js';\nimport ShapeBoxes from './ShapeBoxes.js';\n\n\nconst tmpBox = new THREE.Box3();\n\n// Rotate an item by 90 degrees to make sure that width >= height. \n// This is done in a way that the box minPoint keeps the same.\n// \n// Note: Rotations using animTransform rotate around the world origin\n//\n// @param {THREE.Box3}      box - Original worldBox of a shape (without any animTransform applied)\n// @param {ObjectAnimState} dst - animState on which we set the rotation\nconst applyAlignmentTransform = (box, dst) => {\n\n    // rotate by 90 degrees\n    let angle = 90;\n    let axis = new THREE.Vector3(0, 0, 1);\n    dst.rot.setFromAxisAngle(axis, THREE.Math.degToRad(angle));\n\n    // Rotations work around the world origin.\n    // Now, we modify the move vector to make sure that the bbox keeps the same\n\n    // get rotation as matrix\n    let rotTf = new THREE.Matrix4().makeRotationFromQuaternion(dst.rot);\n\n    // get box after rotation\n    const box2 = tmpBox.copy(box).applyMatrix4(rotTf);\n\n    // modify move vector to obtain the same box minPoint as before rotation\n    // Note that box2.min is not simply the same as we would get when rotating the point box.min. \n    dst.move.sub(box2.min).add(box.min);\n};\n\n// A ClusterRowLayout defines how to line up a group of objects along one or more rows.\nclass ClusterRowLayout {\n\n    constructor(cluster) {\n\n        // MinPoint of the whole cluster.\n        this.position = new THREE.Vector3(0,0,0);\n\n        // {Cluster} - The cluster defining the object that this layout refers to\n        this.cluster = cluster;\n\n        // For each dbId cluster.shapeIds[i], positions[i] defines the corresponding position.\n        // Each object is anchored at the bbox minPoint.\n        this.positions = []; // Vector3[]\n\n        // If rotated[i] is true, the shape with id clusterShapeIds[i] will be rotated by 90 degree around z, \n        // so that x/y are swapped - while preserving the bbox minPoint.\n        this.rotated = []; // bool[]\n\n        // Spatial extent of this cluster.\n        this.size = new THREE.Vector3(0, 0, 0);        \n    }\n\n    getBBox(optionalTarget) {\n        let target = optionalTarget || new THREE.Box3();\n        target.min.copy(this.position);\n        target.max.copy(this.position).add(this.size);\n        return target;\n    }\n\n    // Modifies the given scene anim state so that all objects in the cluster are properly placed and rotated.\n    //\n    //  @param {SceneAnimState} sceneAnimState - SceneAnimState to be modified.\n    //  @param {Vector3}        offset         - Additional translation offset applied to all objects\n    //  @param {ShapeBoxes}     shapeBoxes     - access to shape bboxes\n    //  @param {RotationAlignment} [rotationAlignment] - Optional: Defines rotations that are applied per shape.\n    apply(sceneAnimState, offset, shapeBoxes, rotationAlignment) {\n\n        // reused tmp-vector\n        const targetPos = new THREE.Vector3();\n\n        // Reused below\n        const tmpBox = new THREE.Box3();\n        const tmpVec = new THREE.Vector3();\n\n        for (let i = 0; i < this.cluster.shapeIds.length; i++) {\n\n            // get shapeId\n            let shapeId = this.cluster.shapeIds[i];\n\n            // init itemPlacement for this shape\n            const animState = new ObjectAnimState(shapeId.dbId);\n\n            // get final position of this shape: \n            targetPos.copy(this.positions[i]) // position of the shape within the cluster\n                .add(this.position)           // position of this cluster within the cluster set\n                .add(offset)                  // cluster set position\n\n            // get original shape minPoint\n            const originalBox = shapeBoxes.getShapeBox(shapeId, tmpBox);\n            const originalPos = originalBox.min;\n\n            // Set move-vector so that originalPos is moved to targePos\n            animState.move.subVectors(targetPos, originalPos);\n\n            if (rotationAlignment) {\n                // Apply rotation\n                rotationAlignment.getShapeRotation(shapeId, animState.rot);\n\n                // Set original shape box center as rotation anchor\n                const shapeBox = shapeBoxes.getUnrotatedShapeBox(shapeId, tmpBox);\n                const center   = shapeBox.getCenter(tmpVec);\n                animState.setRotationCenter(center, true);\n            }\n\n            // If needed, apply rotation while keeping bbox.min the same.\n            // Note: When using RotationAlignments, the auto-flip is not needed anymore.\n            //       So, this code path will be removed as soon as the new variant is sufficiently tested.\n            const needsRotate = this.rotated[i];\n            if (needsRotate) {\n\n                // get shape bbox\n                originalBox = shapeBoxes.getShapeBox(shapeId, originalBox);\n\n                // apply rotation\n                applyAlignmentTransform(originalBox, animState);\n            }\n\n            // Add object anim state to scene anim state\n            sceneAnimState.setAnimState(shapeId.modelId, shapeId.dbId, animState);\n        }\n    }\n};\n\n// Defines the placement for a set of object clusters\nclass ClusterSetLayout {\n\n    // @param {ClusterLayout}     layouts\n    // @param {RotationAlignment} [rotationAlignment] - only needed if shapes are rotated for alignment.\n    constructor(layouts, rotationAlignment) {\n\n        // ClusterSet position. ClusterSets are anchored at the minPoint\n        this.position = new THREE.Vector3(0,0,0);\n\n        // {ClusterLayout[]}\n        this.clusterLayouts = layouts || [];\n\n        // {RotationAlignment}\n        this.rotationAlignment = rotationAlignment;\n    }\n\n    // Modifies the given scene anim state so that all objects in all cluster are properly placed and rotated.\n    //\n    //  @param {SceneAnimState} sceneAnimState - SceneAnimState to be modified.\n    //  @param {ShapeBoxes}     shapeBoxes     - access to shape bboxes\n    apply(sceneAnimState, shapeBoxes) {\n        this.clusterLayouts.forEach(l => l.apply(sceneAnimState, this.position, shapeBoxes, this.rotationAlignment));\n    }\n\n    // Creates a SceneAnimState that brings all shapes to their target positions\n    createSceneState(models) {\n        let shapeBoxes = new ShapeBoxes(models, this.rotationAlignment);\n        let state = new SceneAnimState(models);\n        this.apply(state, shapeBoxes);\n        return state;\n    }\n}\n\nexport {\n    ShapeBoxes,\n    ClusterRowLayout,\n    ClusterSetLayout\n}\n","//\n// An algorithm to computes the placement (ClusterSetLayout) for a set of object clusters.\n//\n\nimport { ClusterRowLayout, ClusterSetLayout } from './ClusterLayout.js';\n\n\n// Computes the x/y extent that we obtain when lining up all shapes in a single row. \n//\n//  @param {bool} autoRotate - If true, we assume that each object is rotated in a way that sizeX <= sizeY.\nconst getRowExtent = (cluster, shapeBoxes, spacing, autoRotate) => {\n\n    // Reused tmp vector\n    let boxDiag = new THREE.Vector3();\n\n    // Accumulated row width\n    let rowSize = new THREE.Vector2();\n\n    for (let i = 0; i < cluster.shapeIds.length; i++) {\n\n        // get shape box diagonal\n        let shapeId = cluster.shapeIds[i];\n        boxDiag = shapeBoxes.getShapeSize(shapeId, boxDiag);\n\n        // get width/height along row\n        const shapeSizeX = autoRotate ? Math.min(boxDiag.x, boxDiag.y) : boxDiag.x;\n        const shapeSizeY = autoRotate ? Math.max(boxDiag.x, boxDiag.y) : boxDiag.y;\n\n        // sum up shape with along the row\n        rowSize.x += shapeSizeX;\n\n        // Track y-extent of row (determined by largest shape along y)\n        rowSize.y = Math.max(rowSize.y, shapeSizeY);\n        rowSize.z = Math.max(rowSize.z, boxDiag.z);\n    }\n\n    // consider spacing\n    rowSize.x += (cluster.shapeIds.length - 1) * spacing;\n\n    return rowSize;\n};\n\n// Given a list of bboxes, this function creates a ClusterLayout that stacks all items vertically.\n//  @param {Cluster}    cluster\n//  @param {ShapeBoxes} shapeBoxes\n//  @param {number}     spacing\nconst createStack = (cluster, shapeBoxes, spacing) => {\n\n    let shapeIds = cluster.shapeIds;\n\n    let layout = new ClusterRowLayout(cluster);\n\n    // Track position where to add next shape\n    let zOffset = 0.0;\n\n    // Reused tmp vector\n    let boxSize = new THREE.Vector3();\n\n    // Why backwards?: Shapes are ordered by increasing size. For stacking, it looks better to start with the largest.\n    for (let i = shapeIds.length - 1; i >= 0; i--) {\n        let shapeId = shapeIds[i];\n\n        // Place shape i\n        layout.positions[i] = new THREE.Vector3(0, 0, zOffset);\n\n        // Size along the row is alway min(sizeX, sizeY)\n        boxSize = shapeBoxes.getShapeSize(shapeId, boxSize);\n\n        // Track layout size\n        layout.size.x = Math.max(layout.size.x, boxSize.x);\n        layout.size.y = Math.max(layout.size.y, boxSize.y);\n        layout.size.z = zOffset + boxSize.y;\n\n        // Step up to next stack level\n        zOffset += boxSize.z + spacing;\n    }\n    return layout;\n};\n\n// Given a list of bboxes, this function creates a ClusterLayout that lines them up in one or more rows.\n//  @param {Cluster}    cluster\n//  @param {ShapeBoxes} shapeBoxes\n//  @param {number}     rowWidth\n//  @param {number}     spacing\n//  @param {number}     autoRotate - If true, each shape is aligned so that sizeX <= sizeY\nconst createRows = (cluster, shapeBoxes, rowWidth, spacing, autoRotate) => {\n\n    let shapeIds = cluster.shapeIds;\n\n    let layout = new ClusterRowLayout(cluster);\n\n    // Track position where to add next shape\n    let nextPos = new THREE.Vector3(0,0,0);\n\n    // Reused tmp vector\n    let boxSize = new THREE.Vector3();\n\n    // Track y-extent of current row\n    let rowSizeY = 0;\n\n    for (let i = 0; i < shapeIds.length; i++) {\n        let shapeId = shapeIds[i];\n\n        // Place shape i\n        layout.positions[i] = nextPos.clone();\n\n        // Size along the row is alway min(sizeX, sizeY)\n        boxSize = shapeBoxes.getShapeSize(shapeId, boxSize);\n\n        // If wanted, we orient all shapes so that sizeX < sizeY.\n        layout.rotated[i] = autoRotate && (boxSize.x > boxSize.y);\n\n        // get shapeSize in x/y - after rotating in a way that sizeX <= sizeY\n        const shapeSizeX = autoRotate ? Math.min(boxSize.x, boxSize.y) : boxSize.x;\n        const shapeSizeY = autoRotate ? Math.max(boxSize.x, boxSize.y) : boxSize.y;\n\n        // Track y-extent of current row\n        rowSizeY = Math.max(rowSizeY, shapeSizeY);\n\n        // Track overall extent of the whole layout\n        layout.size.x = Math.max(layout.size.x, nextPos.x + shapeSizeX);\n        layout.size.y = Math.max(layout.size.y, nextPos.y + shapeSizeY); // \n        layout.size.z = Math.max(layout.size.z, boxSize.z);              // max over all shape heights\n\n        // Shift position along x to next new slot\n        nextPos.x += shapeSizeX + spacing;\n\n        // If width of current row reached the target row width...\n        if (nextPos.x >= rowWidth) {\n            // Start a new row\n            nextPos.x  = 0;\n            nextPos.y += rowSizeY + spacing;\n            rowSizeY   = 0;\n        }\n    }\n\n    return layout;\n}\n\n// Given a list of shapeIds, this function computes how these can be positioned in order to form a compact block.\n//\n//   @param {Cluster}    cluster    - Note: cluster.shapeIds within the claster will be sorted within this function.\n//   @param {ShapeBoxes} shapeBoxes - to get shape sizes per shapeId\n//   @param {bool}       autoRotate - Ensure sizeX <= sizeY for each shape by auto-rotating by 90 degree if necessary.\n//   @returns {ClusterRowLayout}\nconst createClusterRowLayout = (cluster, shapeBoxes, spacing, autoRotate, enableStacking = true) => {\n\n    // Sort shapes by increasing yExtent.\n    //\n    // When using autoRotate, we must consider that shapes will be xy-flipped, so that we\n    // must sort by max{xExtent, yExtent} instead.\n    //\n    // Note: The autoRotate option will eventually be removed, because the rotationAlignment can already ensure xExtent <= yExtent,\n    //       so that the layout algorithm can just assume it and always sort by y-extent only.\n    let shapeIds = cluster.shapeIds;\n    const byY     = (a, b) => bySizeY(a, b, shapeBoxes);\n    const byMaxXY = (a, b) => byMaxXYSize(a, b, shapeBoxes);\n    const pred = autoRotate ? byMaxXY : byY;\n\n    // Sort shapeIds\n    shapeIds.sort(pred);\n\n    // Compute x/y-extent that we would get when lining up all objects in a single row\n    const singleRowSize = getRowExtent(cluster, shapeBoxes, spacing, autoRotate);\n\n    // For simplicity and performance, the code below is just a heuristic: We neglect the fact \n    // that y-extents of rows may be varying. So, depending on the variance of y-extents\n    // we may not get an actual squre. However, at least we usually avoid to odd aspect ratios.\n    // \n    // We would like to choose the number of rows in a way that the cluster gets approximately squared.\n    // Given n rows, we would approximately obtain a cluster for which...\n    //  - sizeX = singleRowSizeX / numRows\n    //  - sizeY = singleRowSizeY * numRows\n    //\n    // To get it approximately square, we choose so that \n    //    sizeX = sizeY\n    //\n    const numRows = Math.sqrt(singleRowSize.x / singleRowSize.y);\n    const rowWidth = singleRowSize.x / numRows;\n\n    const rows = createRows(cluster, shapeBoxes, rowWidth, spacing, autoRotate);\n\n    // For large flat shapes (like floors/ceilings), it may be better to just stack them on top of each other.\n    // So, we try stacking them as well.\n    if (enableStacking) {\n        const stack = createStack(cluster, shapeBoxes, spacing);\n\n        // If the stack height is smaller than the horizonal extent, we use the stack.\n        const useStack = (stack.size.z < Math.max(rows.size.x, rows.size.y));\n        if (useStack) {\n            return stack;\n        }\n    }\n\n    return rows;\n}\n\n// Sort predicate to order objects by increasing y-extent\n// Input:\n//   @param {ShapeId}    a          - shapeID a\n//   @param {ShapeId}    b          - shapeID b\n//   @param {ShapeBoxes} shapeBoxes - shape sizes per shapeId\n//\n// Output: -1, if the max extent of object a is greater than of object b\n//          1, otherwise\nconst bySizeY = (a, b, shapeBoxes) => {\n\n    // Get bbox extents\n    const diagA = shapeBoxes.getShapeSize(a);\n    const diagB = shapeBoxes.getShapeSize(b);\n\n    // If y-extent is different, use it\n    if (diagA.y != diagB.y) {\n        return diagA.y - diagB.y;\n    }\n\n    // Among shapes with equal y-extent, sort by increasing x-extent\n    if (diagA.x != diagB.x) {\n        return diagA.x - diagB.x;\n    }\n\n    return 0;\n};\n\n\n// Sort predicate to order objects by increasing maxXYExtent (=max(xExtent, yExtent)). \n// Input:\n//   @param {ShapeId}    a          - shapeID a\n//   @param {ShapeId}    b          - shapeID b\n//   @param {ShapeBoxes} shapeBoxes - shape sizes per shapeId\n//\n// Output: -1, if the max extent of object a is greater than of object b\n//          1, otherwise\nconst byMaxXYSize = (a, b, shapeBoxes) => {\n\n    // Get bbox extents\n    const diagA = shapeBoxes.getShapeSize(a);\n    const diagB = shapeBoxes.getShapeSize(b);\n\n    // Sort based on the max axis extent.\n    const sizeA = Math.max(diagA.x, diagA.y);\n    const sizeB = Math.max(diagB.x, diagB.y);\n    if (sizeA < sizeB) {\n        return -1;\n    } \n    else if (sizeA > sizeB) {\n        return 1;\n    } \n    \n    // If max-entents are equal, sort by minExtent\n    const minExtA = Math.min(diagA.x, diagA.y);\n    const minExtB = Math.min(diagB.x, diagB.y);\n    if (minExtA > minExtB) {\n        return -1;\n    } else if (minExtA < minExtB) {\n        return 1;\n    }\n\n    // If min/max extents are both equal, just sort by id for consistency\n    return b - a;\n};\n\n// Given a set of individual ClusterRowLayouts, this function sets their positions, so that clusters are lined up in a grid or stack as well.\n//\n//  @param {ClusterRowLayout[]} layouts\n//  @param {number}             clusterSpacing - Minimum distance between two clusters\n//  @param {Box3}               sceneBox       - bbox of the full scene (without anim transforms)\nconst setClusterPositions = (layouts, clusterSpacing, sceneBox) => {\n\n    // For placing the clusters, we use the same code that we used for arranging the shapes within\n    // the cluster. \n    //\n    // Only difference is that the shapes to be placed are actually clusters instead of shapes.\n\n    const parentCluster = {\n        // In this case, shapeIds are just indices into the layouts array\n        shapeIds: new Int32Array(layouts.length)\n    };\n\n    // Enlist all cluster indices 0, 1, ..., layouts.length-1.\n    for (let i=0; i<layouts.length; i++) {\n        parentCluster.shapeIds[i] = i;\n    }\n\n    // ShapeBoxes access when using clusters as shapes.\n    const clusterBoxes = {\n        // Return cluster size\n        getShapeSize: (shapeId, target) => {\n            target = target || new THREE.Vector3();\n            const layout = layouts[shapeId];\n            target.copy(layout.size);\n            return target;\n        }\n    };\n\n    // We only align single shapes, but don't rotate clusters. Note that the aspect ratio \n    const autoRotate = false;\n\n    // Run layout to place the clusters\n    const enableStacking = false; // We only use stacking inside clusters. But the clusters themselves are always layouted horizontally.\n    const parentLayout = createClusterRowLayout(parentCluster, clusterBoxes, clusterSpacing, autoRotate, enableStacking);\n\n    // Parent cluster should be horizonally centered at the scene midpoint\n    let origin = sceneBox.getCenter();\n\n    origin.x -= 0.5 * parentLayout.size.x;\n\n    // Start the flea-market behind the actual building\n    origin.y = sceneBox.min.y + 1.1 * (sceneBox.max.y - sceneBox.min.y);\n\n    // Copy positions from parent clusterLayout to the individual cluster positions\n    for (let i=0; i<parentCluster.shapeIds.length; i++) {\n        // get position for next cluster\n        const clusterPos = parentLayout.positions[i];\n\n        // Find the corresponding cluster\n        const clusterIndex = parentCluster.shapeIds[i];\n        const layout       = layouts[clusterIndex]; // Note that shapeIds is reordered during layout process. So we cannot assume shapeIds[i]==i anymore\n\n        // set cluster position\n        layout.position.copy(clusterPos).add(origin);\n    }\n}\n\nconst getDefaultOptions = () => {\n    return {\n        // minimum distance between two shapes within a group\n        spacing: 1.0,\n\n        // minimum distance between different groups\n        clusterSpacing: 10.0,\n\n        // If true, we stack clusters vertically - otherwise, we line up along x/y\n        stackClusters: true\n    }\n};\n\n// Computes a ClusterSetLayout from a set of object clusters.\n//\n// @param {Cluster[]}         layouts    - Each shape group is given by an array of shapeIds\n// @param {ShapeBoxes}        shapeBoxes - Provides bboxes per shape\n// @param {RotationAlignment} [rotationAlignment] - Defines rotations per shape (optional)\n// @param {Object}            options    - configuration params (see getDefaultOptions)\n// @returns {ClusterSetLayout}\nconst createClusterSetLayout = (clusters, shapeBoxes, rotationAlignment, options = getDefaultOptions()) => {\n\n    // When using pre-rotated shapes, the algorithm doesn't need to flipXY for items anymore.\n    const enableXYFlip = !rotationAlignment;\n\n    // Create layout for each cluster\n    const layouts = clusters.map(c => createClusterRowLayout(c, shapeBoxes, options.spacing, enableXYFlip));\n\n    // Based on layouts and known cluster sizes, determine the placement of each cluster\n    //setClusterPositions(layouts, shapeBoxes, options.stackClusters, options.clusterSpacing);\n    setClusterPositions(layouts, options.clusterSpacing, shapeBoxes.sceneBox);\n\n    return new ClusterSetLayout(layouts, rotationAlignment);\n};\n\nexport {\n    createClusterSetLayout\n}\n","//\n// Controls animations between different animation states.\n//\n\nimport { SceneAnimState } from './AnimState.js';\n\n\n// An AnimController contains multiple scene animation states and can smoothly interpolate between those. Each state defines the positions for several objects.\n//\n// Example: Transition from \"original shape positions\" to \"shapes are grouped by categories\".\nexport default class AnimController {\n\n    constructor(viewer) {\n\n        // Describes animation state at the current time.\n        this.currentState = new SceneAnimState();\n\n        // Different states that we can interpolate between - indexed by stateName.\n        this.states = {}; // string => SceneAnimState\n\n        // Animation state at the point when the last animation had started\n        this.startState = new SceneAnimState();\n\n        // {Viewer3D}\n        this.viewer = viewer;\n\n        // Used to interrupt running in-progress animations\n        this.animControl = null;\n    }\n\n    // Start animation to a target state.\n    //\n    // @param {string} [stateName] - A previously registered stateName or null. Null returns to original shape positions.\n    //\n    // @returns {AnimControl} Control in-progress animation..\n    //                          control.stop(): to interrupt it.\n    //                          control.isRunning(): to check whether it is in progress.\n    animateTo(stateName = null, animTime = 2.0) {\n\n        // Make sure that we don't run any previous animation concurrently\n        this.stopAnim();\n\n        const endState = this.states[stateName];\n\n        const onTimer = t => {\n\n            // Ensure that motion speed is changed smoothly\n            t = Autodesk.Viewing.Private.smootherStep(t);\n\n            this.currentState.lerp(this.startState, endState, t);\n            this.currentState.apply(this.viewer);\n        };\n\n        // Freeze current SceneAnimState and keep it as start for interpolation\n        this.startState.copyFrom(this.currentState);\n\n        return Autodesk.Viewing.Private.fadeValue(0, 1, animTime, onTimer, () => this.onAnimEnded());\n    }\n\n    // Immediately stop current animation at its current state. No-op if no animation is running\n    stopAnim() {\n        if (this.animControl && this.animControl.isRunning) {\n            this.animControl.stop();\n            this.animControl = null;\n        }\n    }\n\n    // Register new SceneState that we can animate to\n    registerState(stateName, sceneState) {\n        this.states[stateName] = sceneState;\n\n        // Make sure that currentState addresses all objects that are modified by the new SceneAnimState.\n        this.currentState.createObjectAnimStates(sceneState);\n    }\n\n    // Immediately apply a given animation state\n    setState(stateName) {\n        let state = this.states[stateName];\n        if (state) {\n            this.currentState.copyFrom(state);\n        } else {\n            // Recover shape transforms\n            this.currentState.resetTransforms();\n        }\n        this.currentState.apply(this.viewer);\n    }\n\n    onAnimEnded() {\n        //this should trigger ANIM_ENDED event\n        this.viewer.dispatchEvent({ type: Autodesk.Viewing.ANIM_ENDED });\n    }\n\n    // Ensures that no animation is active and all anim transform is being cleared for all fragments that we modified before.\n    reset() {\n        this.stopAnim();\n        this.currentState.resetTransforms();\n        this.currentState.apply(this.viewer);\n\n        // Drop all states to free some memory\n        this.currentState = new SceneAnimState();\n        this.states = {};\n        this.startState = new SceneAnimState();\n    }\n};\n","\n// Disable packed normals for now, because it sometimes causes wrong values in the normal-depth-buffer (not clear why).\n// The number of cluster boxes is small anyway, so using unpacked is okay here.\nconst UsePackedNormals = false;\n\nconst avp = Autodesk.Viewing.Private;\n\n// Creates a quad with xy in [-0.5, 0.5] and z=0. Normal is +z\nconst createUnitQuadGeom = () => {\n\n    const l = - 0.5;\n    const h = + 0.5;\n\n    // vertex positions (3-floats per vertex)\n    const positions = Float32Array.from([\n        l, l, 0,\n        l, h, 0,\n        h, l, 0,\n        h, h, 0,\n    ]);\n\n    // index buffer for triangles\n    const indices = Uint16Array.from([0, 3, 1, 0, 2, 3]);\n\n    // index buffer for edges\n    const iblines = Uint16Array.from([0, 1, 1, 3, 3, 2, 2, 0]);\n\n    // create interleaved vertex buffer\n    const vertexCount = 4;    \n    const vbstride = UsePackedNormals ? 4 : 6; // float32 values per vertex\n    const vb = new Float32Array(vertexCount * vbstride);\n\n    // write positions to interleaved buffer\n    for (let i = 0; i < vertexCount; i++) {\n        const srcOffset = 3 * i;\n        const dstOffset = vbstride * i;\n        vb[dstOffset]     = positions[srcOffset];\n        vb[dstOffset + 1] = positions[srcOffset + 1];\n        vb[dstOffset + 2] = positions[srcOffset + 2];\n    }\n\n    if (UsePackedNormals) {\n        // encode (0,0,1) as packed Uint16 normal\n        const toUint16 = 0xFFFF;   // for upscaling from [0,1]-floats to Uint16-scale\n        const nx = 0.5 * toUint16; \n        const ny = 1.0 * toUint16;\n\n        // The first 3 floats per vertex are used by positions. \n        // Counting in Uint16 values, this makes 6.\n        const normalOffset = 6;\n\n        // write normals to interleaved buffer\n        const vbUint16 = new Uint16Array(vb.buffer);\n        const vbUint16Stride = vbstride * 2; // 2 Uint16 per float32\n        for (let i = 0; i < vertexCount; i++) {\n            const dstOffset = vbUint16Stride * i + normalOffset;\n            vbUint16[dstOffset]     = nx;\n            vbUint16[dstOffset + 1] = ny;\n        }\n    } else {\n        const normalOffset = 3;\n\n        // write normals to interleaved buffer\n        for (let i = 0; i < vertexCount; i++) {\n            const dstOffset = vbstride * i + normalOffset;\n            vb[dstOffset]     = 0;\n            vb[dstOffset + 1] = 0;\n            vb[dstOffset + 2] = 1;\n        }\n    }\n\n    // create result geometry\n    const geom = new THREE.BufferGeometry();\n    geom.vbstride = vbstride;\n    geom.vb       = vb;\n    geom.ib       = indices;\n    geom.iblines  = iblines;\n\n    // position attribute\n    var attrPos = new THREE.BufferAttribute(undefined, 3);\n    attrPos.itemOffset = 0;\n    geom.attributes.position = attrPos;\n    \n    // normal attribute\n    var attrNormal = new THREE.BufferAttribute(undefined, 3);\n    attrNormal.itemOffset = 3;\n    attrNormal.bytesPerItem = UsePackedNormals ? 2 : 6;\n    attrNormal.normalize = true;\n    geom.attributes.normal = attrNormal;\n\n    // index attribute\n    var attrIndex = new THREE.BufferAttribute(undefined, 1);\n    attrIndex.bytesPerItem = 2;\n    geom.attributes.index = attrIndex;\n\n    // add attribute for edge rendering\n    var attrIndexLines = new THREE.BufferAttribute(undefined, 1);\n    attrIndexLines.bytesPerItem = 2;\n    geom.setAttribute( 'indexlines', attrIndexLines);\n\n    // attribute keys\n    geom.attributesKeys = Object.keys( geom.attributes );\n\n    return geom;\n};\n\n// Creates a quad mesh that corresponds to the z-Min face of the given bbox\n//  @param {Box3}            bbox\n//  @param {BufferGeometry}  unitQuadGeom\n//  @param {Material}        matman       - must be registered at materialManager and use packedNormals\nconst createGizmoMesh = (bbox, material) => {\n\n    // In theory, we could share a static one here. However, this would introduce subtle detail problems\n    // when using multiple viewer instances, because WebGLRenderer attaches gl-context-specific resources.\n    // The number of gizmo boxes is not big anyway, so what.\n    const geom = createUnitQuadGeom();\n\n    // create mesh\n    var boxMesh = new THREE.Mesh(geom, material);\n\n    // move mesh origin to center of bbox z-min face\n    bbox.getCenter(boxMesh.position);\n    bbox.size(boxMesh.scale);\n    boxMesh.position.z = bbox.min.z;\n\n    // Attach mesh bbox\n    boxMesh.boundingBox = bbox.clone();\n    boxMesh.boundingBox.max.z = bbox.min.z; // The mesh only spans the z-min surface of bbox\n\n    return boxMesh;\n};\n\n// @param {MaterialManager} matman - needed to register the material\nconst createGizmoMaterial = (matman) => {\n\n    // create material\n    var material = new THREE.MeshPhongMaterial({\n        color: 0xffffff, // white\n        transparent: true, \n        opacity: 1,\n        side: THREE.DoubleSide,\n\n        // Disable z-buffer: It doesn't work with fading and the quads are below all the shapes anyway.\n        depthTest: false,\n        depthWrite: false,\n    });\n\n    // Note: This is must be set separately, because it's a custom-lmv property and not supported by the material ctor\n    material.packedNormals = UsePackedNormals;\n\n    // Register at MaterialManager\n    material.name = 'ClusterGizmoMaterial_' + material.id;\n    matman.addHDRMaterial(material.name, material);\n\n    return material;\n};\n\nconst disposeGizmoMesh = (mesh, matman) => {\n    mesh.geometry.dispose();\n    mesh.material.dispose();\n    matman.removeMaterial(mesh.material.name);\n};\n\n// A ClusterGizmo is a quad below an object cluster that helps to distinguish different clusters.\nexport class ClusterGizmo {\n\n    // @param {Box3}   clusterBox - bbox of the cluster\n    // @param {string} [meshName] - Attached to the mesh to simplify debugging\n    constructor(viewer, clusterBox, meshName) {\n\n        this.viewer = viewer;\n\n        // create mesh\n        const material = createGizmoMaterial(viewer.impl.matman());\n        this.mesh = createGizmoMesh(clusterBox, material);\n\n        this.mesh.name = meshName;\n\n        // add it to viewer scene\n        this.viewer.impl.scene.add(this.mesh);\n\n        // For smooth fadeIn/Out\n        const setOpacity = t => {\n            // Fade-in quad\n             this.mesh.material.opacity = t;\n\n             // Fade-in outline: Edges should have 0.5 opacity when fully faded in\n             this.mesh.material.edgeOpacity = 0.5 * t;\n\n             this.viewer.impl.invalidate(true, true);\n        };\n        this.opacityParam = new avp.AnimatedParam(0.0, setOpacity, 1.0);\n\n        // Initial fade-in\n        this.opacityParam.fadeTo(1);\n    }\n\n    dtor() {\n        // remove from viewer scene\n        this.viewer.impl.scene.remove(this.mesh);\n        this.viewer.impl.invalidate(true, true);\n\n        // dispose gpu resources\n        disposeGizmoMesh(this.mesh, this.viewer.impl.matman());\n\n        this.mesh   = null;\n        this.viewer = null;\n    }\n\n    // Fade out and dispose mesh when done\n    dispose() {\n        this.opacityParam.fadeTo(0.0, ()=>this.dtor());\n    }\n}\n\n// ClusterGizmoController takes care that ClusterGizmos and corresponding labels are created/disposed according to the currently shown layout.\nexport class ClusterGizmoController {\n\n    constructor(viewer) {\n\n        this.viewer = viewer;\n\n        this.gizmos = []; // ClusterGizmo[]\n        this.labels = []; // Label3D[]\n\n        // We delay fade-in, so that gizmos/labels appear shortly before the cluster animation ends\n        this.fadeInDelay = 1.8; // in seconds\n        this.timerId = null;\n    }\n\n    createGizmos(sceneLayout) {\n\n        // For each cluster...\n        const layouts = sceneLayout.clusterLayouts;\n        for (let i=0; i<layouts.length; i++) {\n            const layout = layouts[i];\n\n            // create quad gizmo\n            const bbox = layout.getBBox();\n            const gizmo = new ClusterGizmo(this.viewer, bbox, layout.cluster.name);\n            this.gizmos.push(gizmo);\n\n            // get label position (center of the bbox zMin-face)\n            const labelPos = bbox.getCenter();\n            labelPos.z = bbox.min.z;\n\n            // create label\n            const text = this.getLabelText(layout);\n            const label = new Autodesk.Edit3D.Label3D(this.viewer, labelPos, text);\n            this.labels.push(label);\n\n            // Hide label if ClusterGizmo size on screen is below MinPixels threshold.\n            //\n            // Note: We could use the screen-size of the label text. However, this looks confusing\n            //       if some cluster labels are shown and others are not (due to longer text that you don't see).\n            //       So, it looks more consistent to use a fixed minPixelSize for all clusters.\n            //       For super-long cluster names, we will introduce abbreviations instead.\n            const MinPixels = 75; \n            label.setWorldBox(gizmo.mesh.boundingBox, MinPixels);\n\n            // When clicking a label, fly to the cluster\n            const flyToCluster = (e) => {\n                const camera = this.viewer.impl.camera;\n\n                // get cluster-platform center and box size\n                const gizmoBox = gizmo.mesh.boundingBox;\n                const p = gizmoBox.getCenter(); \n                const size = gizmoBox.size();\n\n                // Setup view diagonally to look at p\n                const dstView = camera.clone();\n                dstView.target.copy(p);\n\n                // get current distance from target point\n                const curDistance = camera.position.distanceTo(p)\n\n                // Place the camera on the line between target and start camera position.\n                // Choose distance close enough to the cluster to clearly focus it.\n                let dist = Math.max(size.x, size.y, size.z);\n                dist     = Math.min(dist, curDistance); // if already close, never move away from target\n                let dir  = camera.position.clone().sub(p).normalize();\n                dstView.position.set(\n                    p.x + dir.x * dist,\n                    p.y + dir.y * dist,\n                    p.z + dir.z * dist,\n                );\n\n                // trigger animation\n                avp.flyToView(this.viewer, dstView, 1.5);\n\n                // Mark click as consumed, so that it doesn't trigger selection of objects behind the label.\n                e.stopPropagation();\n            };\n            label.container.style.pointerEvents = 'auto';\n            label.container.addEventListener('click', flyToCluster);\n        }\n    }\n\n    getLabelText(layout) {\n        let text = layout.cluster.name;\n\n        // Remove \"Revit \" prefix\n        // For now, we hard-wire this, but this function will be customizable by clients later.\n        const prefix = 'Revit ';\n        if (text.startsWith(prefix)) {\n            text = text.substring(prefix.length);\n        }\n\n        return text;\n    }\n\n    disposeGizmos() {\n        this.gizmos.forEach(g => g.dispose());\n        this.labels.forEach(l => l.dispose());\n        this.gizmos.length = 0;\n        this.labels.length = 0;\n    }\n\n        // If a delayed fade-in of gizmos is pending for prior layout, cancel it\n    cancelTimer() {\n        if (this.timerId) {\n            window.clearTimeout(this.timerId);\n            this.timerId = null;\n        }\n    }\n\n    onLayoutChanged(sceneLayout) {\n\n        // Make sure that there is no concurrent delayed fade-in of a prior layout\n        this.cancelTimer();\n        \n        // Fade-out and dispose any outdated gizmos\n        this.disposeGizmos();\n    \n        // Fade-in new gizmos after some delay\n        if (sceneLayout) {\n            this.timerId = window.setTimeout(\n                ()=>this.createGizmos(sceneLayout),\n                this.fadeInDelay * 1000\n            );\n        }\n    }\n\n    // Dispose all resources immediately\n    reset() {\n        this.gizmos.forEach(g => g.dtor());\n        this.labels.forEach(l => l.dtor());\n        this.gizmos.length = 0;\n        this.labels.length = 0;\n    }\n}\n\n","\n'use strict';\n\nimport { buildClustersFromAttribute, Cluster, createShapeId, hasVisibleFragments } from './Cluster.js';\nimport { createClusterSetLayout } from './RowLayoutBuilder.js';\nimport AnimController from './AnimController.js';\nimport ShapeBoxes from './ShapeBoxes.js';\nimport { ObjectAnimState, ModelAnimState, SceneAnimState } from './AnimState.js';\nimport { ClusterGizmoController } from './ClusterGizmo.js';\nimport { RotationAlignment, getBoxCorner, findAlignmentRotation, computeObjectAlignment } from './RotationAlignment.js';\n\nconst av = Autodesk.Viewing;\nconst avu = av.UI;\n\nconst namespace = AutodeskNamespace('Autodesk.Viewing.Extensions.VisualClusters');\n\n// Name of the animation state that organizes all objects in clusters based on Category attribute.\nconst ClusteredStateName = 'ByCategory';\n\nconst createClusterIcon = () => {\n    return [\n        '<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 143 135\">',\n            '<g fill=\"currentColor\">',\n                '<polygon points=\"29.275 51 9.725 51 0 68.05 9.725 85 29.275 85 39 68.05\"/>',\n                '<polygon points=\"133.275 51 113.725 51 104 68.05 113.725 85 133.275 85 143 68.05\"/>',\n                '<polygon points=\"89.05 0 55.05 0 38 29.55 55.05 59 89.05 59 106 29.55\"/>',\n                '<polygon points=\"89.05 76 55.05 76 38 105.45 55.05 135 89.05 135 106 105.45\"/>',\n            '</g>',\n        '</svg>'\n    ].join('');\n};\n\n// Create a clustering layout that forms clusters of objects based on Category attribute.\nconst createDefaultLayout = async (models, alignShapeRotation, attribName, searchAncestors) => {\n\n    // Make sure that we only work on supported models\n    const modelSupported = model => model.is3d() && Boolean(model.getInstanceTree());\n    models = models.filter(modelSupported);\n\n    // build clusters\n    let clusters = await buildClustersFromAttribute(models, attribName, searchAncestors);\n    \n    // Exclude topography & rooms\n    const filter = c => (c.name != 'Revit Topography' && c.name != 'Revit Rooms' && c.name != 'Revit <Sketch>');\n    clusters = clusters.filter(filter);\n\n    // Use RotationLayout to orient all shapes in a way that the projected x/y-extent is small\n    const rotationAlignment = alignShapeRotation ? new RotationAlignment(models) : null;\n\n    // Create helper for bbox access\n    const shapeBoxes = new ShapeBoxes(models, rotationAlignment);\n\n    // Compute layouts\n    return createClusterSetLayout(clusters, shapeBoxes, rotationAlignment);\n};\n\n/**\n * Purpose of VisualClusters extension is to group objects into clusters.\n * \n * This means:\n *  1. Categories: Form categories by assigning each shape in a model (or multiple) to a unique category, e.g. based on values of a database property.\n *  2. Layout:     Compute a \"layout\" that places all shapes in a way that shapes of the same group are located closeby.\n *  3. Animation:  Animate between original shape positions and new positions according to cluster layout.\n * \n * Example: By default, the clustering extension forms clusters based on the \"Category\" Given a building model and 2 groups - windows and doors - the result is that all windows and doors are moved away from their\n *          original positions, so that you have one cluster of windows and one cluster of doors located outside the original building.\n * \n * The extension id is: `Autodesk.VisualClusters`\n * \n * @example\n *   viewer.loadExtension('Autodesk.VisualClusters')\n * \n *   If you have a 3D model with propertyDb loaded, you should now see a button in the toolbar to trigger clustering based on Category attribute.\n *  \n * @memberof Autodesk.Viewing.Extensions\n * @alias Autodesk.Viewing.Extensions.VisualClusters\n * @see {@link Autodesk.Viewing.Extension} for common inherited methods.\n * @constructor\n*/\nexport default class VisualClustersExtension extends av.Extension {\n    constructor(viewer, options) {\n        super(viewer, options);\n\n        // If true, the toggle button for the layout is pressed and all objects\n        // are arranged in clusters (or being computed or animating towards that state)\n        this.layoutActive = false;\n\n        // Used to detect if an async layout computation is meanwhile outdated.\n        this.layoutTimeStamp = 0;\n\n        // Controls transitions between clustered and original state\n        this.animController = new AnimController(this.viewer);\n\n        // Controls gizmos and labels for clusters\n        this.gizmoController = new ClusterGizmoController(this.viewer);\n\n        // Bind event listener callbacks\n        this.onModelAddedCb   = this.onModelAdded.bind(this);\n        this.onModelRemovedCb = this.onModelRemoved.bind(this);\n        this.dbLoadedCb       = this.onDbLoaded.bind(this);\n        this.onTransitionEndedCb   = this.onTransitionEnded.bind(this);\n    }\n\n    async load() {\n\n        await this.viewer.loadExtension('Autodesk.Edit3D');\n\n        this.viewer.addEventListener(av.MODEL_ADDED_EVENT, this.onModelAddedCb);\n        this.viewer.addEventListener(av.MODEL_REMOVED_EVENT, this.onModelRemovedCb);\n        this.viewer.addEventListener(av.OBJECT_TREE_CREATED_EVENT, this.dbLoadedCb);\n        this.viewer.addEventListener(av.ANIM_ENDED, this.onTransitionEndedCb);\n        return true; \n    }\n\n    unload() {\n        this.viewer.removeEventListener(av.MODEL_ADDED_EVENT, this.onModelAddedCb);\n        this.viewer.removeEventListener(av.MODEL_REMOVED_EVENT, this.onModelRemovedCb);\n        this.viewer.removeEventListener(av.OBJECT_TREE_CREATED_EVENT, this.onDbLoaded);\n        this.viewer.removeEventListener(av.ANIM_ENDED, this.onTransitionEndedCb);\n\n        // Revert all anim transform changes.\n        this.animController.reset();\n\n        this._destroyUI();\n        return true; \n    }\n\n    // Reset to initial state.\n    reset() {\n        this.animController.reset();\n        this.gizmoController.reset();\n        this.layoutActive = false;\n        this.updateButton();\n    }\n\n    onModelAdded() {\n        this.updateButton();\n    }\n\n    onModelRemoved() {\n        this.updateButton();\n\n        // Auto-reset: When reset all animation transforms and extension state.\n        // This avoids leaking any state information when switching between views.\n        //\n        // Note: When temporarily switching all models off in a multi-model scenario, auto-reset might\n        //       not be wanted. If we need to support that case, we need a concept to tell the extension\n        //       explicitly whether a view-switch occurred or leave the reset to the client.\n        const lastModelRemoved = !this.viewer.getVisibleModels().length;\n        if (lastModelRemoved) {\n            this.reset();\n        }\n    }\n\n    onDbLoaded() {\n        this.updateButton();\n    }\n\n    onToolbarCreated() {\n        this.clusterButton = new avu.Button(\"toolbar-clusterTool\");\n        this.clusterButton.icon.innerHTML = createClusterIcon();\n\n        // add button to toolbar section 'Model Tools'\n        let toolbar = this.viewer.getToolbar && this.viewer.getToolbar();\n        if (toolbar) {\n            let modelTools = toolbar.getControl(av.TOOLBAR.MODELTOOLSID);\n\n            // Add our button to the toolbar\n            if (modelTools) {\n                    modelTools.addControl(this.clusterButton);\n            }\n        }\n\n        this.clusterButton.onClick = () => {\n            this.setLayoutActive(!this.layoutActive);\n        };\n\n        this.updateButton();\n    }\n\n    onTransitionStarted() {\n        // check if animation state is available and whether there are clusters\n        // (models with clusters have an animStates array with length bigger than 0)\n        if (ClusteredStateName in this.animController.states &&\n            this.animController.states[ClusteredStateName].animStates.filter(Boolean)[0].animStates.length > 0) {\n            this.viewer.fireEvent({ type: av.TRANSITION_STARTED, sceneAnimState: this.animController.states[ClusteredStateName]});\n        } else {\n            this.viewer.fireEvent({ type: av.TRANSITION_STARTED, sceneAnimState: null});\n        }\n    }\n\n    onTransitionEnded() {\n        if (ClusteredStateName in this.animController.states && \n            this.animController.states[ClusteredStateName].animStates.filter(Boolean)[0].animStates.length > 0) {\n            this.viewer.fireEvent({ type: av.TRANSITION_ENDED, sceneAnimState: this.animController.states[ClusteredStateName]});\n        } else {\n            this.viewer.fireEvent({ type: av.TRANSITION_ENDED, sceneAnimState: null});\n        }\n    }\n\n    _destroyUI() {\n        // Remove button from toolbar\n        if (this.clusterButton) {\n            const toolbar = this.viewer.getToolbar && this.viewer.getToolbar();\n            const modelTools = toolbar && toolbar.getControl(av.TOOLBAR.MODELTOOLSID);\n            if (modelTools) {\n                modelTools.removeControl(this.clusterButton);\n            }\n            this.clusterButton = null;\n        }\n    }\n\n    setLayoutActive(active) {\n        if (this.layoutActive === active) {\n            return;\n        }\n\n        // Indicate that layout is activated\n        this.layoutActive = active;\n\n        this.updateButton();\n\n        // Layout disabled: Animate back to original state\n        if (!active) {\n            this.onTransitionStarted();\n            this.animController.animateTo(null);\n            this.gizmoController.onLayoutChanged(null);\n            return;\n        } \n\n        this.applyLayout();\n    }\n\n    async applyLayout() {\n\n        // get currently visible/loaded models\n        const models = this.viewer.getVisibleModels();\n\n        // If a layout computation is active, mark it as outdated.\n        this.layoutTimeStamp++;\n\n        // Remember timestamp so that we can check later if result is still wanted\n        const layoutTimeStamp = this.layoutTimeStamp;\n        const sceneLayout = await createDefaultLayout(models, true, this.options.attribName, this.options.searchAncestors);\n\n        // If this.layoutTimeStamp has changed, the result is outdated.\n        if (!this.layoutActive || layoutTimeStamp !== this.layoutTimeStamp) {\n            return;\n        }\n\n        this.sceneLayout = sceneLayout;\n\n        // Create animation state that represents this layout\n        this.sceneAnimState = sceneLayout.createSceneState(models);\n\n        // Make animation state available \n        this.animController.registerState(ClusteredStateName, this.sceneAnimState);\n\n        this.onTransitionStarted();\n\n        // Animate to clustered layout\n        this.animController.animateTo(ClusteredStateName);\n        this.gizmoController.onLayoutChanged(this.sceneLayout);\n    }\n\n    updateButton() {\n        if (!this.clusterButton) {\n            return;\n        }\n\n        const models = this.viewer.getVisibleModels();\n\n        // Only show button if we have >=1 3D model. Note that we cannot rely on this.viewer.impl.is2d, because it\n        // is set after addModel event is fired.\n        const showButton = models.some(model => model.is3d());\n        this.clusterButton.setVisible(showButton);\n        if (!showButton) {\n            return;\n        }\n\n        // Disable button if some propDb is still loading or if we don't have any propDb at all.\n        const propDbLoading = (model) => model.getPropertyDb() && !model.getPropertyDb().isLoadDone();\n        const propDbMissing = (model) => !propDbLoading(model) && !model.getInstanceTree();\n        const waitForDb = models.some(propDbLoading);\n        const noPropDb  = models.some(propDbMissing);\n        const disable   = waitForDb || noPropDb;\n\n        // Choose button tooltip. If we disable, explain why.\n        let tooltip  = 'Form Clusters by Category';\n        if (disable) {\n            tooltip = waitForDb ? 'Waiting for database to load' : 'Visual Clustering can only be used if a database is available'\n        }\n        this.clusterButton.setToolTip(tooltip);\n\n        // Set button state\n        if (disable) {\n            this.clusterButton.setState(avu.Button.State.DISABLED);\n        } else {\n            this.clusterButton.setState(this.layoutActive ? avu.Button.State.ACTIVE : avu.Button.State.INACTIVE);\n        }\n    }\n}\n\nav.theExtensionManager.registerExtension('Autodesk.VisualClusters', VisualClustersExtension);\n\nnamespace.buildClustersFromAttribute = buildClustersFromAttribute;\nnamespace.Cluster = Cluster;\nnamespace.createShapeId = createShapeId;\nnamespace.createClusterSetLayout = createClusterSetLayout;\nnamespace.ShapeBoxes = ShapeBoxes;\nnamespace.AnimConstroller = AnimController;\nnamespace.hasVisibleFragments = hasVisibleFragments;\nnamespace.ObjectAnimState = ObjectAnimState;\nnamespace.ModelAnimState = ModelAnimState;\nnamespace.SceneAnimState = SceneAnimState;\nnamespace.getBoxCorner = getBoxCorner;\nnamespace.findAlignmentRotation = findAlignmentRotation;\nnamespace.computeObjectAlignment = computeObjectAlignment;\nnamespace.RotationAlignment = RotationAlignment;\n"],"sourceRoot":""}