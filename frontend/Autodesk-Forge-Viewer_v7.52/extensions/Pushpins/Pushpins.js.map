{"version":3,"file":"Pushpins/Pushpins.js","sources":["webpack://Autodesk.Extensions.[name]/webpack/bootstrap","webpack://Autodesk.Extensions.[name]/./extensions/Pushpins/PushPinConstants.js","webpack://Autodesk.Extensions.[name]/./extensions/Pushpins/PushPinEvents.js","webpack://Autodesk.Extensions.[name]/./extensions/Pushpins/PushPinExtension.css?4b73","webpack://Autodesk.Extensions.[name]/./extensions/Pushpins/PushPinExtension.js","webpack://Autodesk.Extensions.[name]/./extensions/Pushpins/PushPinInputHandler.js","webpack://Autodesk.Extensions.[name]/./extensions/Pushpins/PushPinItem.js","webpack://Autodesk.Extensions.[name]/./extensions/Pushpins/PushPinLabel/HTMLPushPinLabel.js","webpack://Autodesk.Extensions.[name]/./extensions/Pushpins/PushPinLabel/PushPinBillboardLabel.js","webpack://Autodesk.Extensions.[name]/./extensions/Pushpins/PushPinLegacyFallback.js","webpack://Autodesk.Extensions.[name]/./extensions/Pushpins/PushPinLocales.js","webpack://Autodesk.Extensions.[name]/./extensions/Pushpins/PushPinManager.js","webpack://Autodesk.Extensions.[name]/./extensions/Pushpins/PushPinObserver.js","webpack://Autodesk.Extensions.[name]/./extensions/Pushpins/PushPinTools.js","webpack://Autodesk.Extensions.[name]/./extensions/Pushpins/PushPinUi/IssuePushPinVisButton.js","webpack://Autodesk.Extensions.[name]/./extensions/Pushpins/PushPinUi/PushPinVisButtonBase.js","webpack://Autodesk.Extensions.[name]/./extensions/Pushpins/PushPinUi/QualityIssuePushPinVisButton.js","webpack://Autodesk.Extensions.[name]/./extensions/Pushpins/PushPinUi/RfiPushPinVisButton.js","webpack://Autodesk.Extensions.[name]/./extensions/Pushpins/PushPinUtils.js","webpack://Autodesk.Extensions.[name]/./extensions/Pushpins/PushPins2D/PushPinBillboardTool2D.js","webpack://Autodesk.Extensions.[name]/./extensions/Pushpins/PushPins2D/RenderHandler2D.js","webpack://Autodesk.Extensions.[name]/./extensions/Pushpins/PushPins3D/PushPinBillboardTool3D.js","webpack://Autodesk.Extensions.[name]/./extensions/Pushpins/PushPins3D/PushPinViewerState.js","webpack://Autodesk.Extensions.[name]/./extensions/Pushpins/PushPins3D/RenderHandler3D.js","webpack://Autodesk.Extensions.[name]/./extensions/Pushpins/PushPinExtension.css","webpack://Autodesk.Extensions.[name]/./node_modules/css-loader/lib/css-base.js","webpack://Autodesk.Extensions.[name]/./node_modules/style-loader/lib/addStyles.js","webpack://Autodesk.Extensions.[name]/./node_modules/style-loader/lib/urls.js"],"sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./extensions/Pushpins/PushPinExtension.js\");\n","export var statusHexValues = {\n  /* Issues */\n\n  'issues-draft': '#819099',\n  'issues-draft-selected': '#819099',\n  'issues-draft-movable': '#819099',\n\n  'issues-open': '#ffba0c',\n  'issues-open-selected': '#ffba0c',\n  'issues-open-movable': '#ffba0c',\n\n  'issues-answered': '#087cd9',\n  'issues-answered-selected': '#087cd9',\n  'issues-answered-movable': '#087cd9',\n\n  'issues-closed': '#bcc9d1',\n  'issues-closed-selected': '#bcc9d1',\n  'issues-closed-movable': '#bcc9d1',\n\n  /* RFIs */\n\n  'rfis-draft': '#819099',\n  'rfis-draft-selected': '#819099',\n  'rfis-draft-movable': '#819099',\n\n  'rfis-submitted': '#7a77d9',\n  'rfis-submitted-selected': '#7a77d9',\n  'rfis-submitted-movable': '#7a77d9',\n\n  'rfis-open': '#ffba0c',\n  'rfis-open-selected': '#ffba0c',\n  'rfis-open-movable': '#ffba0c',\n\n  'rfis-answered': '#087cd9',\n  'rfis-answered-selected': '#087cd9',\n  'rfis-answered-movable': '#087cd9',\n\n  'rfis-rejected': '#ff495c',\n  'rfis-rejected-selected': '#ff495c',\n  'rfis-rejected-movable': '#ff495c',\n\n  'rfis-closed': '#bcc9d1',\n  'rfis-closed-selected': '#bcc9d1',\n  'rfis-closed-movable': '#bcc9d1',\n\n  'rfis-void': '#bcc9d1',\n  'rfis-void-selected': '#bcc9d1',\n  'rfis-void-movable': '#bcc9d1',\n\n\n  /* Field Issues */\n\n  'quality_issues-draft': '#819099',\n  'quality_issues-draft-selected': '#819099',\n  'quality_issues-draft-movable': '#819099',\n\n  'quality_issues-not_approved': '#ff495c',\n  'quality_issues-not_approved-selected': '#ff495c',\n  'quality_issues-not_approved-movable': '#ff495c',\n\n  'quality_issues-open': '#ffba0c',\n  'quality_issues-open-selected': '#ffba0c',\n  'quality_issues-open-movable': '#ffba0c',\n\n  'quality_issues-ready_to_inspect': '#7a77d9',\n  'quality_issues-ready_to_inspect-selected': '#7a77d9',\n  'quality_issues-ready_to_inspect-movable': '#7a77d9',\n\n  'quality_issues-void': '#bcc9d1',\n  'quality_issues-void-selected': '#bcc9d1',\n  'quality_issues-void-movable': '#bcc9d1',\n\n  'quality_issues-work_completed': '#087cd9',\n  'quality_issues-work_completed-selected': '#087cd9',\n  'quality_issues-work_completed-movable': '#087cd9',\n\n  // \"in_dispute\" pushpins are the same as \"not_approved\" ones\n  'quality_issues-in_dispute': '#ff495c',\n  'quality_issues-in_dispute-selected': '#ff495c',\n  'quality_issues-in_dispute-movable': '#ff495c',\n\n  // \"closed\" pushpins are the same as \"void\" ones\n  'quality_issues-closed': '#bcc9d1',\n  'quality_issues-closed-selected': '#bcc9d1',\n  'quality_issues-closed-movable': '#bcc9d1',\n\n  'quality_issues-answered': '#087cd9',\n  'quality_issues-answered-selected': '#087cd9',\n  'quality_issues-answered-movable': '#087cd9' };\n\n\nexport var moveableIcon = 'url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEsAAABMCAYAAAAlS0pSAAAA4UlEQVR42u3bSw7DIAwFwNz/zhXddNVuoPWHlHkHCGKUgG0p1yVyTMYrJGDFQwFbhAIGKw8KGKw8KGCLUMBg5UEdDQYrGeo4sBEUWLC0O7BgwYIFCxYsWLBgwYL1r1jRm8nGasPP3Ew2VhlY1Waqnl96ntwdKxytagjXifXzOtUTy26sr9YbMoeGaAIMywIaDm+Yc2sbKKVDcr2lKP1c6KHd0Ugb0WwxojH8M1aGBUtgwYIFCxYsgQUL1iYofkeB1Q/mcwQFqw3MzQgrHkwlOglGCJZ2B9YdwIhMgpGAJfKWJ1qioD8mrIWXAAAAAElFTkSuQmCC)';\n\nexport var cursorIcon = 'url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACIAAAAiCAYAAAA6RwvCAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAIxJREFUeNpi/P//PwMlgJGR0QBIfQCa84ASc5gYKAcTgDiBUkOo4RCqgFGHjDpk1CGjDhl1yKhDRoxDGIFYgcJqPAVK3yHXAGBbxoEF1KgBYgcKHPIHiEHmHKCgcaXASIUWWgPIIyBfjSbWUYeMOmTUIaMOGXXIqEOGVMOICs0AUMNKAGjOBUrMAQgwAFWiHzqojsmJAAAAAElFTkSuQmCC)16 16, auto';\n\nexport var markerOffsets = {\n  markerOffsetWidth: 30, // .pushpin-billboard-marker height + (border*2)\n  selectedMarkerOffsetWidth: 38 // .pushpin-billboard-marker.selected height + (border*2)\n};\n\nexport var thumbnailOriginalPixelSize = 200; // Original crop size\nexport var thumbnailSize = 800; // Output size of the thumbnail\nexport var thumbnailZoom = thumbnailSize / thumbnailOriginalPixelSize;\nexport var thumbnailMarkerRadius = 10 * thumbnailZoom;\n\n// ATTRIBUTES_VERSION is used in order to track changes of the pushpin attributes.\n// Change this number only if there is a code change that requires a distinction between pushpins created before & after that change.\n//\n// V1: Legacy pushpins\n// V2: applyOffsetToCutplanes is being applied to pushpins' cutplanes. https://git.autodesk.com/A360/firefly.js/pull/3046\nexport var ATTRIBUTES_VERSION = 2;","export var PUSHPIN_EVENTS = {\n  PUSH_PIN_EDIT_START_EVENT: 'pushpin.edit.start',\n  PUSH_PIN_EDIT_END_EVENT: 'pushpin.edit.end',\n  PUSH_PIN_PREPARING_THUMBNAIL: 'pushpin.preparing.thumbnail',\n  PUSH_PIN_CREATED_EVENT: 'pushpin.created',\n  PUSH_PIN_SELECTED_EVENT: 'pushpin.selected',\n  PUSH_PIN_REMOVED_EVENT: 'pushpin.removed',\n  PUSH_PIN_REMOVE_ALL_EVENT: 'pushpin.remove.all',\n  PUSH_PIN_MODIFY_EVENT: 'pushpin.modified', // this will be fired on push pin position changed.\n  PUSH_PIN_UPDATE_EVENT: 'pushpin.update', // this will be fired on an explicit push pin data update.\n  PUSH_PIN_VISIBILITY_EVENT: 'pushpin.visibility.changed',\n  PUSH_PIN_ITEMS_LOADED: 'pushpin.tool.items.loaded',\n\n  // Separate events to distinguish that they are triggered from client by direct API call.\n  // This is a workaround to fix some problems on mobile client.\n  // Mobile is going to rely on this event to get push pin select status.\n  PUSH_PIN_CLICKED_EVENT: 'pushpin.clicked',\n  PUSH_PIN_SELECT_NONE: 'pushpin.select.none' };","\nvar content = require(\"!!../../node_modules/css-loader/index.js!../../node_modules/sass-loader/dist/cjs.js!./PushPinExtension.css\");\n\nif(typeof content === 'string') content = [[module.id, content, '']];\n\nvar transform;\nvar insertInto;\n\n\n\nvar options = {\"hmr\":true}\n\noptions.transform = transform\noptions.insertInto = undefined;\n\nvar update = require(\"!../../node_modules/style-loader/lib/addStyles.js\")(content, options);\n\nif(content.locals) module.exports = content.locals;\n\nif(module.hot) {\n\tmodule.hot.accept(\"!!../../node_modules/css-loader/index.js!../../node_modules/sass-loader/dist/cjs.js!./PushPinExtension.css\", function() {\n\t\tvar newContent = require(\"!!../../node_modules/css-loader/index.js!../../node_modules/sass-loader/dist/cjs.js!./PushPinExtension.css\");\n\n\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\n\t\tvar locals = (function(a, b) {\n\t\t\tvar key, idx = 0;\n\n\t\t\tfor(key in a) {\n\t\t\t\tif(!b || a[key] !== b[key]) return false;\n\t\t\t\tidx++;\n\t\t\t}\n\n\t\t\tfor(key in b) idx--;\n\n\t\t\treturn idx === 0;\n\t\t}(content.locals, newContent.locals));\n\n\t\tif(!locals) throw new Error('Aborting CSS HMR due to changed css-modules locals.');\n\n\t\tupdate(newContent);\n\t});\n\n\tmodule.hot.dispose(function() { update(); });\n}","function _typeof(obj) {\"@babel/helpers - typeof\";if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;};}return _typeof(obj);}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError(\"Cannot call a class as a function\");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}function _inherits(subClass, superClass) {if (typeof superClass !== \"function\" && superClass !== null) {throw new TypeError(\"Super expression must either be null or a function\");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}function _createSuper(Derived) {var hasNativeReflectConstruct = _isNativeReflectConstruct();return function _createSuperInternal() {var Super = _getPrototypeOf(Derived),result;if (hasNativeReflectConstruct) {var NewTarget = _getPrototypeOf(this).constructor;result = Reflect.construct(Super, arguments, NewTarget);} else {result = Super.apply(this, arguments);}return _possibleConstructorReturn(this, result);};}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");}return self;}function _isNativeReflectConstruct() {if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;if (Reflect.construct.sham) return false;if (typeof Proxy === \"function\") return true;try {Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));return true;} catch (e) {return false;}}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}import { PUSHPIN_EVENTS } from './PushPinEvents';\nimport PushPinManager from './PushPinManager';\nimport PushPinTool from './PushPinTools';\nimport IssuePushPinVisButton from './PushPinUi/IssuePushPinVisButton';\nimport RfiPushPinVisButton from './PushPinUi/RfiPushPinVisButton';\nimport QualityIssuePushPinVisButton from './PushPinUi/QualityIssuePushPinVisButton';\nimport PushPinMobileObserver from './PushPinObserver';\nimport { applyLegacyFallback, legacyToLocalPushPinData as _legacyToLocalPushPinData, getLegacyPushPinData as _getLegacyPushPinData } from './PushPinLegacyFallback';\nimport { locales } from './PushPinLocales';\n\nimport CSS from './PushPinExtension.css'; // REQUIRED!!\n\nvar namespace = AutodeskNamespace('Autodesk.BIM360.Extension.PushPin');var\n\nPushPinExtension = /*#__PURE__*/function (_Autodesk$Viewing$Ext) {_inherits(PushPinExtension, _Autodesk$Viewing$Ext);var _super = _createSuper(PushPinExtension);\n  function PushPinExtension(viewer) {var _this;var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};_classCallCheck(this, PushPinExtension);\n    _this = _super.call(this, viewer, options);\n    _this.viewer = viewer;\n    _this.options = options;\n    Autodesk.Viewing.EventDispatcher.prototype.apply(_assertThisInitialized(_this));return _this;\n  }_createClass(PushPinExtension, [{ key: \"load\", value: function load()\n\n    {\n      this.extendLocalization(locales);\n\n      this.onModelAdded = this.onModelAdded.bind(this);\n      this.onModelRemoved = this.onModelRemoved.bind(this);\n      this.viewer.addEventListener(Autodesk.Viewing.MODEL_ADDED_EVENT, this.onModelAdded);\n      this.viewer.addEventListener(Autodesk.Viewing.MODEL_REMOVED_EVENT, this.onModelRemoved);\n\n      if (this.viewer.getVisibleModels().length > 0) {\n        this.onModelAdded();\n      }\n\n      return true;\n    } }, { key: \"unload\", value: function unload()\n\n    {\n      this.destroyUI();\n\n      this.destroyPushpinManager();\n\n      this.destroyTool();\n\n      this.viewer.removeEventListener(Autodesk.Viewing.MODEL_ADDED_EVENT, this.onModelAdded);\n      this.viewer.removeEventListener(Autodesk.Viewing.MODEL_REMOVED_EVENT, this.onModelRemoved);\n\n      return true;\n    } }, { key: \"onModelAdded\", value: function onModelAdded()\n\n    {var _this2 = this;\n      // Need to initialize pushpinManager & pushpinTool in these cases:\n      // - pushpinManager or tool weren't initialized yet\n      // - viewer switched mode from 2D to 3D (or 3D to 2D)\n      var reset = !this.pushPinManager || !this.tool ||\n      // For 3D is2d is undefined, so first convert to boolean\n      Boolean(this.viewer.impl.is2d) !== this.pushPinManager.is2D;\n\n      if (reset) {\n        this.initPushpinManager();\n        this.initTool();\n        this.createUI();\n\n        for (var _i = 0, _Object$values = Object.values(PUSHPIN_EVENTS); _i < _Object$values.length; _i++) {var value = _Object$values[_i];\n          // Forward the events to the pushpin manager\n          // Removing is not necessary as the pushpin manager gets recreated\n          this.pushPinManager.addEventListener(value, function (e) {return _this2.fireEvent(e);});\n        }\n        this.fireEvent({ type: Events.PUSH_PIN_MANAGER_INITIALIZED, value: this.pushPinManager });\n      }\n    } }, { key: \"onModelRemoved\", value: function onModelRemoved()\n\n    {\n      // In case that there is no model left on the viewer.\n      if (this.viewer.getVisibleModels().length === 0) {\n        this.destroyUI();\n        this.destroyPushpinManager();\n        this.destroyTool();\n\n        this.fireEvent({ type: Events.PUSH_PIN_MANAGER_DESTROYED });\n      }\n    } }, { key: \"initPushpinManager\", value: function initPushpinManager()\n\n    {\n      // Clean previous instance of pushpin manager if exists.\n      this.destroyPushpinManager();\n\n      this.pushPinManager = new PushPinManager(this.viewer, this.options);\n\n      if (Autodesk.Viewing.isMobileDevice()) {\n        this.observer = new PushPinMobileObserver(this.pushPinManager);\n      }\n    } }, { key: \"destroyPushpinManager\", value: function destroyPushpinManager()\n\n    {\n      if (this.pushPinManager) {\n        this.pushPinManager.selectNone();\n        this.pushPinManager.removeAllItems();\n        this.pushPinManager = null;\n      }\n\n      this.observer = null;\n    } }, { key: \"initTool\", value: function initTool()\n\n    {\n      // Clean previous instance of pushpin tool if exists.\n      this.destroyTool();\n\n      this.tool = new PushPinTool(this.viewer, this.pushPinManager);\n\n      this.viewer.toolController.registerTool(this.tool);\n      this.viewer.toolController.activateTool(this.tool.getName());\n    } }, { key: \"destroyTool\", value: function destroyTool()\n\n    {\n      if (this.tool) {\n        this.viewer.toolController.deregisterTool(this.tool);\n        this.tool = null;\n      }\n    }\n\n    /**\n       * Public interfaces routing to tool for clients to call\n       */ }, { key: \"startCreateItem\", value: function startCreateItem(\n    data) {\n      this.tool.startCreateItem(data);\n      this.updateButtonsStatus();\n      this.pushPinManager.fireEvent({ type: PUSHPIN_EVENTS.PUSH_PIN_EDIT_START_EVENT });\n    } }, { key: \"endCreateItem\", value: function endCreateItem()\n\n    {\n      this.tool.endCreateItem();\n      this.updateButtonsStatus();\n      this.pushPinManager.fireEvent({ type: PUSHPIN_EVENTS.PUSH_PIN_EDIT_END_EVENT });\n    } }, { key: \"showAll\", value: function showAll()\n\n    {\n      for (var type in this.pushPinManager.PushPinTypes) {\n        this.showByType(this.pushPinManager.PushPinTypes[type]);\n      }\n    } }, { key: \"hideAll\", value: function hideAll()\n\n    {\n      for (var type in this.pushPinManager.PushPinTypes) {\n        this.hideByType(this.pushPinManager.PushPinTypes[type]);\n      }\n    } }, { key: \"enableItemSelect\", value: function enableItemSelect(\n\n    enable) {\n      this.tool.enablePushPinSelect(enable);\n    } }, { key: \"updatePattern\", value: function updatePattern(\n\n    id, size, res) {\n      this.tool.renderTool.updatePattern(id, size, res);\n    }\n\n    // public interfaces routing to push pin manager for clients to call\n  }, { key: \"loadItems\", value: function loadItems(pushPinDatas) {\n      if (this.viewer.getVisibleModels().length === 0) {\n        console.warn('model need to be loaded before using loadItems API');\n        return;\n      }\n\n      if (this.viewer.model.is3d()) {\n        console.warn('loadItems is deprecated for 3D models. Use loadItemsV2 instead.');\n      }\n\n      this.tool.show(true);\n      this.pushPinManager.addItems(pushPinDatas);\n      this.pushPinManager.fireEvent({ type: PUSHPIN_EVENTS.PUSH_PIN_ITEMS_LOADED, value: null });\n    }\n\n    // @param {bool} [blockEvent=false] - By default, we fire a PUSH_PIN_ITEMS_LOADED event each time to make sure that \n    //                                    it's never missed. If you call this function several times in a loop, you can block\n    //                                    the event as long as you ensure to fire it once at the end of the loop.\n  }, { key: \"loadItemFromLocal\", value: function loadItemFromLocal(pushPinData, blockEvent) {\n      if (this.viewer.getVisibleModels().length === 0) {\n        console.warn('model need to be loaded before using loadItemFromLocal API');\n        return;\n      }\n\n      this.pushPinManager.addItems([pushPinData], true, this.viewer);\n\n      if (!blockEvent) {\n        this.pushPinManager.fireEvent({ type: PUSHPIN_EVENTS.PUSH_PIN_ITEMS_LOADED, value: null });\n      }\n    }\n\n    // New load API that encapsulates the 2D/3D loading APIs.\n  }, { key: \"loadItemsV2\", value: function loadItemsV2(pushpinsData) {var _this3 = this;\n      if (this.viewer.getVisibleModels().length === 0) {\n        console.warn('model need to be loaded before using loadItemsV2 API');\n        return;\n      }\n\n      if (!Array.isArray(pushpinsData)) {\n        pushpinsData = [pushpinsData];\n      }\n\n      // Activate tool so pushpins will be visible.\n      this.tool.show(true);\n\n      pushpinsData.forEach(function (pushpinData) {\n        if (_this3.viewer.model.is3d()) {\n          // For legacy reasons, issue positions are not directly stored in model-local coordinates. So we need some legacy conversion.\n          _this3.legacyToLocalPushPinData(pushpinData);\n\n          // Now, position and viewerState are in model-local coordinates.\n          _this3.loadItemFromLocal(pushpinData, true);\n        } else {\n          // Old code path for 2D issues.\n          _this3.pushPinManager.addItems([pushpinData]);\n        }\n      });\n\n      this.pushPinManager.fireEvent({ type: PUSHPIN_EVENTS.PUSH_PIN_ITEMS_LOADED, value: null });\n    } }, { key: \"updateItemById\", value: function updateItemById(\n\n    id, data) {\n      return this.pushPinManager.updateItemById(id, data);\n    } }, { key: \"getItemById\", value: function getItemById(\n\n    id) {\n      var item = this.pushPinManager.getItemById(id);\n\n      if (item) {\n        return item.data;\n      }\n\n      return null;\n    } }, { key: \"setDraggableById\", value: function setDraggableById(\n\n    id, isDraggable, cancelPositionChange) {var _this$pushPinManager;\n\n      // Note that this.pushPinManager may temporarily destroyed when removing the last model\n      // during a view switch. We tolerate that case in the same way as we handle a call for a non-existing issue.\n      var item = (_this$pushPinManager = this.pushPinManager) === null || _this$pushPinManager === void 0 ? void 0 : _this$pushPinManager.getItemById(id);\n\n      if (item) {\n        if (cancelPositionChange) {\n          item.setPosition(this.origItemPosition);\n        }\n\n        item.draggable = isDraggable;\n        this.pushPinManager.fireEvent({ type: PUSHPIN_EVENTS.PUSH_PIN_UPDATE_EVENT, value: item });\n        this.origItemPosition = Object.assign({}, item.data.position);\n\n        if (isDraggable) {\n          this.pushPinManager.fireEvent({ type: PUSHPIN_EVENTS.PUSH_PIN_EDIT_START_EVENT });\n        } else {\n          this.pushPinManager.fireEvent({ type: PUSHPIN_EVENTS.PUSH_PIN_EDIT_END_EVENT });\n        }\n      }\n    } }, { key: \"setVisibleById\", value: function setVisibleById(\n\n    id, isVisible) {\n      var item = this.pushPinManager.getItemById(id);\n      if (item) {\n        item.visible = isVisible;\n        this.pushPinManager.fireEvent({ type: PUSHPIN_EVENTS.PUSH_PIN_UPDATE_EVENT, value: item });\n      }\n    }\n\n    /**\n       * Select one pushpin\n       * @param id Issue id\n       * @param reTriggerEvent Allows to force a re-triggering of the selection event, even if pushpin was selected before.\n       * This makes sense if you want to make sure that the pushpin viewer state is applied anyway (zoom to pushpin).\n       */ }, { key: \"selectOne\", value: function selectOne(\n    id, reTriggerEvent) {\n      this.pushPinManager && this.pushPinManager.selectOne(id, reTriggerEvent);\n    } }, { key: \"selectNone\", value: function selectNone()\n\n    {\n      this.pushPinManager && this.pushPinManager.selectNone();\n    } }, { key: \"removeItemById\", value: function removeItemById(\n\n    id) {\n      var item = this.pushPinManager.getItemById(id);\n\n      if (!item) {\n        return;\n      }\n\n      this.pushPinManager.removeItemById(id);\n    } }, { key: \"removeItemsByType\", value: function removeItemsByType(\n\n    type) {\n      this.pushPinManager.removeItemsByType(type);\n    } }, { key: \"removeAllItems\", value: function removeAllItems()\n\n    {\n      this.pushPinManager && this.pushPinManager.removeAllItems();\n    } }, { key: \"createUI\", value: function createUI()\n\n    {\n      // UI depends on pushpinManager.\n      this.destroyUI();\n\n      this.uiButtons = [];\n\n      if (!this.options.hideIssuesButton) {\n        this.uiButtons.push(new IssuePushPinVisButton(this.viewer, this, this.options.initiallyHideIssuesPushpins));\n      }\n\n      if (!this.options.hideFieldIssuesButton) {\n        this.uiButtons.push(new QualityIssuePushPinVisButton(this.viewer, this, this.options.initiallyHideFieldIssuesPushpins));\n      }\n\n      if (!this.options.hideRfisButton) {\n        this.uiButtons.push(new RfiPushPinVisButton(this.viewer, this, this.options.initiallyHideRfisPushpins));\n      }\n\n      if (this.viewer.model) {\n        // If model is already loaded, then check.\n        this.uiButtons.forEach(function (uiButton) {\n          uiButton.addButton();\n        });\n        return;\n      }\n\n      var self = this;\n\n      function enableVisButton() {\n        if (self.viewer.model) {\n          self.uiButtons.forEach(function (uiButton) {\n            uiButton.addButton();\n          });\n        }\n        self.viewer.removeEventListener(Autodesk.Viewing.MODEL_ROOT_LOADED_EVENT, enableVisButton);\n      }\n\n      // Otherwise, watch model loaded event.\n      this.viewer.addEventListener(Autodesk.Viewing.MODEL_ROOT_LOADED_EVENT, enableVisButton);\n    } }, { key: \"destroyUI\", value: function destroyUI()\n\n    {\n      if (!this.uiButtons) {\n        return;\n      }\n\n      this.uiButtons.forEach(function (uiButton) {\n        uiButton.destroyButton();\n      });\n\n      this.uiButtons = null;\n    } }, { key: \"updateButtonsStatus\", value: function updateButtonsStatus()\n\n    {\n      this.uiButtons.forEach(function (uiButton) {\n        uiButton.updateButtonStatus();\n      });\n    } }, { key: \"hideByType\", value: function hideByType(\n\n    type) {\n      this.pushPinManager && this.pushPinManager.setVisibleByType(type, false);\n    } }, { key: \"showByType\", value: function showByType(\n\n    type) {\n      this.pushPinManager && this.pushPinManager.setVisibleByType(type, true);\n    }\n\n    // Convert legacy 3D pushPinData in-place to make sure that positions and viewerState are consistently in model-local coords.\n  }, { key: \"legacyToLocalPushPinData\", value: function legacyToLocalPushPinData(pushPinData) {\n\n      _legacyToLocalPushPinData(pushPinData, this.viewer);\n\n      // Usually, this will be a no-op. It will just detect and auto-repair some previously saved\n      // PushPins that would be broken otherwise.\n      if (this.options.useLegacyFallback) {\n        applyLegacyFallback(pushPinData, this.viewer);\n      }\n    }\n\n    // Takes a PushPinItem and returns its PushPinData - transformed in a way that it is compatible with the PushPins as stored in issues-backend. For this, pushPin position\n    // must match with viewer coordinates when using a single model with default loadOptions (default globalOffset and no transforms).\n  }, { key: \"getLegacyPushPinData\", value: function getLegacyPushPinData(pushPin) {\n      return _getLegacyPushPinData(pushPin, this.viewer);\n    }\n\n    // Makes restore viewer state immediate (without animation)\n  }, { key: \"setRestoreViewerStateImmediate\", value: function setRestoreViewerStateImmediate(restoreViewerStateImmediate) {\n      if (this.pushPinManager) {\n        this.pushPinManager.restoreViewerStateImmediate = restoreViewerStateImmediate;\n      }\n    } }]);return PushPinExtension;}(Autodesk.Viewing.Extension);export { PushPinExtension as default };\n\n\nvar Events = {\n  PUSH_PIN_MANAGER_INITIALIZED: 'pushpin.manager.initialized',\n  PUSH_PIN_MANAGER_DESTROYED: 'pushpin.manager.destroyed' };\n\n\nPushPinExtension.Events = Events;\n\nnamespace.PUSH_PIN_EXT_NAME = 'Autodesk.BIM360.Extension.PushPin';\nObject.assign(namespace, PUSHPIN_EVENTS);\nAutodesk.Viewing.theExtensionManager.registerExtension(namespace.PUSH_PIN_EXT_NAME, PushPinExtension);","function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError(\"Cannot call a class as a function\");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}var PushPinInputHandler = /*#__PURE__*/function () {\n  function PushPinInputHandler(pushpinRenderer) {_classCallCheck(this, PushPinInputHandler);\n    this.pushpin = null;\n    this.pushpinRenderer = pushpinRenderer;\n    this.mousePosition = { x: 0, y: 0 };\n\n    this.onTouchDragBinded = this.onTouchDrag.bind(this);\n    this.onMouseMoveBinded = this.onMouseMove.bind(this);\n    this.onMouseUpBinded = this.onMouseUp.bind(this);\n    this.onMouseDownBinded = this.onMouseDown.bind(this);\n    this.onHammerInputBinded = this.onHammerInput.bind(this);\n\n    this.mouseEnabled = false;\n    this.mousePrevValue = false;\n    this.lock = false;\n  }\n\n  // Convert Hammer touch-event X,Y into mouse-event X,Y.\n  _createClass(PushPinInputHandler, [{ key: \"processMouseEvent\", value: function processMouseEvent(\n\n\n\n\n\n    event) {\n      this.mousePosition.x = event.clientX;\n      this.mousePosition.y = event.clientY;\n    } }, { key: \"attachTo\", value: function attachTo(\n\n    pushpin) {\n      if (this.pushpin) {\n        this.detach();\n      }\n\n      this.pushpin = pushpin;\n\n      if (Autodesk.Viewing.isTouchDevice()) {\n        this.hammer = new Autodesk.Viewing.Hammer.Manager(pushpin, {\n          recognizers: [\n          Autodesk.Viewing.GestureRecognizers.drag],\n\n          inputClass: Autodesk.Viewing.isIE11 ? Hammer.PointerEventInput : Hammer.TouchInput });\n\n\n        this.hammer.on('dragstart dragmove dragend', this.onTouchDragBinded);\n        this.hammer.on('hammer.input', this.onHammerInputBinded);\n      }\n\n      if (!Autodesk.Viewing.isMobileDevice()) {\n        this.enableMouseButtons(true);\n      }\n    } }, { key: \"onHammerInput\", value: function onHammerInput(\n\n    event) {\n      this.setMouseDisabledWhenTouching(event);\n    } }, { key: \"setMouseDisabledWhenTouching\", value: function setMouseDisabledWhenTouching(\n\n    event) {var _this = this;\n      if (event.isFirst && !this.lock) {\n        this.enableMouseButtons(false);\n        this.lock = true;\n      } else if (event.isFinal) {\n        setTimeout(function () {\n          _this.enableMouseButtons(_this.mousePrevValue);\n          _this.lock = false;\n        }, 10);\n      }\n    } }, { key: \"enableMouseButtons\", value: function enableMouseButtons(\n\n    state) {\n      if (state && !this.mouseEnabled) {\n        this.pushpin.addEventListener('mousedown', this.onMouseDownBinded);\n        this.pushpinRenderer.viewer.container.addEventListener('mousemove', this.onMouseMoveBinded);\n        this.pushpinRenderer.viewer.container.addEventListener('mouseup', this.onMouseUpBinded);\n      } else if (!state && this.mouseEnabled) {\n        this.pushpin.removeEventListener('mousedown', this.onMouseDownBinded);\n        this.pushpinRenderer.viewer.container.removeEventListener('mousemove', this.onMouseMoveBinded);\n        this.pushpinRenderer.viewer.container.removeEventListener('mouseup', this.onMouseUpBinded);\n      }\n\n      this.mousePrevValue = this.mouseEnabled;\n      this.mouseEnabled = state;\n    } }, { key: \"detach\", value: function detach()\n\n    {\n      if (this.hammer) {\n        this.hammer.destroy();\n      }\n\n      this.pushpinRenderer.viewer.container.removeEventListener('mousemove', this.onMouseMoveBinded);\n      this.pushpinRenderer.viewer.container.removeEventListener('mouseup', this.onMouseUpBinded);\n\n      if (this.pushpin) {\n        this.pushpin.removeEventListener('mousedown', this.onMouseDownBinded);\n\n        this.pushpin = null;\n      }\n\n      this.mouseEnabled = false;\n    } }, { key: \"onMouseMove\", value: function onMouseMove(\n\n    event) {\n      this.processMouseEvent(event);\n      this.pushpinRenderer.handleMouseMove(event);\n      event.preventDefault();\n    } }, { key: \"onMouseDown\", value: function onMouseDown(\n\n    event) {\n      this.processMouseEvent(event);\n      this.pushpinRenderer.handleMouseDown(event);\n      event.preventDefault();\n    } }, { key: \"onMouseUp\", value: function onMouseUp(\n\n    event) {\n      this.processMouseEvent(event);\n      this.pushpinRenderer.handleMouseUp(event);\n      event.preventDefault();\n    } }, { key: \"onTouchDrag\", value: function onTouchDrag(\n\n    event) {\n      PushPinInputHandler.convertEventHammerToMouse(event);\n      switch (event.type) {\n        case 'dragstart':\n          this.onMouseDown(event);\n          break;\n        case 'dragmove':\n          this.onMouseMove(event);\n          break;\n        case 'dragend':\n          this.onMouseUp(event);\n          break;\n        default:\n          break;}\n\n\n      event.preventDefault();\n    } }], [{ key: \"convertEventHammerToMouse\", value: function convertEventHammerToMouse(event) {event.shiftKey = false;event.clientX = event.pointers[0].clientX;event.clientY = event.pointers[0].clientY;} }]);return PushPinInputHandler;}();export { PushPinInputHandler as default };\n\n\nvar namespace = AutodeskNamespace('Autodesk.BIM360.Extension.PushPin');\nnamespace.PushPinInputHandler = PushPinInputHandler;","function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError(\"Cannot call a class as a function\");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}var namespace = AutodeskNamespace('Autodesk.BIM360.Extension.PushPin');\n\nimport { transformViewerState } from './PushPins3D/PushPinViewerState';\nimport { ATTRIBUTES_VERSION } from './PushPinConstants';\n\nvar decodeUrn = function decodeUrn(urn) {\n  urn = urn.replace(/-/g, '+'); // Convert '-' (dash) to '+'\n  urn = urn.replace(/_/g, '/'); // Convert '_' (underscore) to '/'\n  while (urn.length % 4) {urn += '=';} // Add padding '='\n\n  try {\n    return atob(urn);\n  } catch (_unused) {\n    return null;\n  }\n};\n\n// Extract the lineageID string from a base64-encoded version urn\n// Example: dXJuOmFkc2sud2lwc3RnOmZzLmZpbGU6dmYuM3Q4QlBZQXJSSkNpZkFZUnhOSnM0QT92ZXJzaW9uPTI \n//          => (decoded) \"urn:adsk.wipstg:fs.file:vf.3t8BPYArRJCifAYRxNJs4A?version=2\"\n//          => vf.3t8BPYArRJCifAYRxNJs4A\n//\n// An edge case that is being handled here is a seedUrn that has been created on offline mode.\n// In this case, it might look like this: \"OfflineFiles/dXJuOmFkc2sud2lwZW1lYTpkbS5saW5lYWdlOjRlV01pbFl5UkV1SEIzZHQxTHBNUWc/6/dXJuOmFkc2sud2lwZW1lYTpmcy5maWxlOnZmLjRlV01pbFl5UkV1SEIzZHQxTHBNUWc_dmVyc2lvbj02/output/0/0.svf\".\nvar getLineageId = function getLineageId(encodedUrn) {\n  var parts = encodedUrn.split('/');\n\n  var decodedPart = null;\n\n  for (var i = parts.length - 1; i >= 0; i--) {\n    decodedPart = decodeUrn(parts[i]);\n\n    if (decodedPart && decodedPart.indexOf('file:') != -1) {\n      break;\n    } else {\n      decodedPart = null;\n    }\n  }\n\n  if (!decodedPart) {\n    console.error('urn is not encoded correctly.');\n    return null;\n  }\n\n  var start = decodedPart.indexOf('file:') + 'file:'.length; // skip prefix \"urn:adsk.wipstg:fs.file:\" resp. \"urn:adsk.wipprod:fs.file:\"\n  var end = decodedPart.indexOf('?');\n  return decodedPart.substring(start, end);\n};\n\n// Returns the first visible model for which the lineageID is the same as for the given seedUrn.\n// The is usually not more than 1 anyway, but not guaranteed to be. In case there are more (e.g. for diff), \n// the first matching model determines the issue position.\nexport var findMatchingModel = function findMatchingModel(viewer, seedUrn) {\n\n  var models = viewer.getVisibleModels();\n\n  // Skip in case seedUrn is missing (a possible reason is that it was created externally)\n  if (!seedUrn) {\n    // In case seedUrn is missing from the viewerState for some reason - we can still have a fallback in case there is only a single visible model.\n    // In that case, we can assume that the pushpin belongs to the main viewer's model.\n    if (models.length === 1) {\n      console.error('Issue seedUrn does not exist. Assume pushpin belongs to viewer current main model');\n      return models[0];\n    } else {\n      console.error('Issue seedUrn does not exist.');\n      return null;\n    }\n  }\n  // Extract decoded lineage urn from seedUrn\n  // We ignore the version part, so that the visible model is also found if it is another model version.\n  // Note: If the model is outside the version range of the issue, it will\n  //\t\t   not be displayed anyway, so that we don't have to check the version here again.\n  var issueLineageId = getLineageId(seedUrn);\n\n  // Find model with matching lineageId\n  for (var i = 0; i < models.length; i++) {\n\n    // get lineageId of next model\n    var model = models[i];\n    var urn = model.myData.urn;\n    var lineageId = getLineageId(urn);\n\n    // return model if matching\n    if (lineageId === issueLineageId) {\n      return model;\n    }\n  }\n\n  if (models.length === 1) {\n    //console.error('Issue seedUrn does not match with any visible model urn. Assume pushpin belongs to viewer current main model');\n    return models[0];\n  }\n\n  // We didn't find any model that matches the given issue. This should not happen, because \n  // issues are not supposed to be displayed if it doesn't belong to any visible model. \n  // TODO: Investigate whether the assumption above might be temporarily broken due to async calls. E.g., if a model\n  //       was toggled off shortly before the issue was received.\n  //console.error('Issue seedUrn does not match with any visible model urn.');\n};\n\n// Unique id for runtime-generated PushPinItems. Note that the id will be overwritten by actual GUIDs if issues are saved or loaded.\n// Note: It would be cleaner to consistently use guids in the first place. But, this requires some refactoring first to get rid\n//       of a hack in RenderHandler.createRenderItem (https://git.autodesk.com/fluent/lmv.js/blob/develop/extensions/Pushpins/PushPins3D/RenderHandler3D.js#L188),\n//       which uses the ID length to distinguish between loaded and newly created issues.\nvar _nextPushPinId = 1;var\n\nPushPinItem = /*#__PURE__*/function () {\n  function PushPinItem() {_classCallCheck(this, PushPinItem);\n    this.itemData = {\n      id: (_nextPushPinId++).toString(),\n      label: 'New',\n      status: 'issues-open',\n      position: { x: 0, y: 0, z: 0 },\n      type: 'issues',\n      objectId: null,\n      externalId: null,\n      viewerState: null,\n      objectData: null,\n      locationIds: [],\n      seedURN: null };\n\n\n    // Params affect render or interaction\n    this.selected = false;\n    this.isVisible = true;\n    this.draggable = false;\n    this.selectable = true;\n  }_createClass(PushPinItem, [{ key: \"defaultAppearance\", value: function defaultAppearance()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    {\n      var normalSize = 40;\n      var selectedSize = 60;\n\n      return {\n        normalSize: normalSize,\n        selectedSize: selectedSize,\n        draggableStatus: '-movable',\n        selectedStatus: '-selected' };\n\n    } }, { key: \"set\", value: function set(\n\n    data) {\n      this.itemData = Object.assign({}, this.itemData, data);\n      this.correctDataFormat();\n\n      return this;\n    }\n\n    // Like set, but performs a conversion of position and viewerState from model-local-coords to viewer-coords.\n    // PushPinItems store viewer coordinates, i.e., ready-to-render for the current viewer. Expected input is \n    // in model-local coordinates, i.e., excluding any load-time transforms.\n    //\n    // Note that the model of the Pushpin must be visible/loaded.\n  }, { key: \"setLocal\", value: function setLocal(data, viewer) {\n\n      this.set(data);\n\n      // Positions are specified relative to the model the issue belongs to. We have to find this model first.\n      var model = this.findModel(viewer);\n      if (!model) {\n        // If we ever see this message, we are trying to create an issue for a model that is not shown.\n        // If this actually happens, we need some additional fallback logic here, e.g.\n        // set position to undefined first and update on model-show events.\n        console.error('PushPin coordinate conversion failed: PushPin must belong to a visible model.');\n        return;\n      }\n\n      // Why creating a new vector here instead of converting in-place:\n      //  - this.itemData is only a shallow copy and we don't want to modify the src input data\n      //  - Original vectors cannot be assumed to be THREE types.\n      this.itemData.position = new THREE.Vector3().copy(this.itemData.position);\n\n      // Apply matrix that combines all transforms that have been applied to the model during loading.\n      // Note that modelTf may be undefined. This is no error, but just indicates that neither placement nor offset was applied to the model.\n      var modelTf = model.myData.placementWithOffset;\n      if (modelTf) {\n        this.itemData.position.applyMatrix4(modelTf);\n      }\n\n      // Apply this transforms to position. \n\n      // Replace viewerState by transformed copy\n      // Note that we cannot use placementWithOffset here as we did for position. To make it more confusing,\n      // there is another legacy constraint: viewerState values are currently stored in world-coords, i.e., viewer-coords with added \n      // global offset. The current globalOffset is subtracted when applying the viewerState (see PushPinViewerState.js:restoreViewState).\n      // \n      // It would be easier and more consistent to store viewerState in viewer-coords as well. But this would currently break legacy code,\n      // e.g., older issue-UI versions that don't use createItemFromLocal() are working based on the assumption that viewerStates are in world-coords.\n      var placementTf = model.myData.placementTransform;\n      this.itemData.viewerState = JSON.parse(JSON.stringify(this.itemData.viewerState));\n\n      // Transform viewer state. Note that placementTf may be undefined if the model was loaded without any placement transform.\n      // This is okay and just means that we can skip the transform step.\n      if (placementTf) {\n        transformViewerState(this.itemData.viewerState, placementTf);\n      }\n    }\n\n    // Returns a copy of the PushPin itemData where position and viewerState are provided in model-local coords.\n    // The model that the issue is assigned to must be visible.\n  }, { key: \"getLocal\", value: function getLocal(viewer) {\n\n      // Find the model for which the issue was assigned\n      var model = this.findModel(viewer);\n      if (!model) {\n        //            console.error('PushPin coordinate conversion failed: PushPin must belong to a visible model.');\n        return;\n      }\n\n      var localData = Object.assign({}, this.itemData);\n\n      // Create copies of position and viewerState, so that they can be safely transformed and passed outside.\n      localData.position = new THREE.Vector3().copy(this.itemData.position);\n      localData.viewerState = JSON.parse(JSON.stringify(this.itemData.viewerState));\n\n      // Get matrices to convert between different coordinate spaces. \n      // Note that both matrices may be undefined. This is no error and just indicates that the two coordinate\n      // spaces are the same. \n      var modelLocalToViewer = model.myData.placementWithOffset;\n      var modelLocalToWorld = model.myData.placementTransform;\n\n      // Convert position from viewer coords to model-local coords.\n      if (modelLocalToViewer) {\n        var viewerToModelLocal = new THREE.Matrix4().getInverse(modelLocalToViewer);\n        localData.position.applyMatrix4(viewerToModelLocal);\n      }\n\n      // Convert viewerState from world-coords to model-local coords.\n      if (modelLocalToWorld) {\n        // Create copy of the viewerState that is transformed from world-coords to model-local coords.\n        var worldToModelLocal = new THREE.Matrix4().getInverse(modelLocalToWorld);\n        transformViewerState(localData.viewerState, worldToModelLocal);\n      }\n\n      return localData;\n    } }, { key: \"setObjectId\", value: function setObjectId(\n\n    dbId) {\n      this.itemData.objectId = dbId;\n    } }, { key: \"setObjectData\", value: function setObjectData(\n\n    res) {\n      var model = res.model;\n      if (!model) {\n        return;\n      }\n      var data = model.getData();\n      if (!data) {\n        return;\n      }\n      var documentNode = model.getDocumentNode();\n      if (!documentNode) {\n        return;\n      }\n      var docNodeData = documentNode.data;\n      if (!docNodeData) {\n        return;\n      }\n      this.itemData.objectData = {\n        guid: docNodeData.guid,\n        urn: data.urn,\n        viewableId: docNodeData.viewableID,\n        viewName: docNodeData.name };\n\n    } }, { key: \"setExternalId\", value: function setExternalId(\n\n    externalId) {\n      this.itemData.externalId = externalId;\n    } }, { key: \"setPosition\", value: function setPosition(\n\n    newPos) {\n      this.itemData.position = Object.assign({}, newPos);\n    } }, { key: \"hasPosition\", value: function hasPosition()\n\n    {\n      return this.itemData.position.x !== null && this.itemData.position.y !== null && this.itemData.position.z !== null;\n    }\n\n    // Finds the visible model whose lineageId matches the seedUrn stored for this issue.\n    // May return undefined if the model is currently not visible.\n  }, { key: \"findModel\", value: function findModel(viewer) {\n      // if viewerState doesn't exist, the only way to not \"give up\" on the pushpin, is to check if the viewer has only a single model.\n      var visibleModels = viewer.getVisibleModels();\n      if (!this.itemData.viewerState && visibleModels.length === 1) {\n        return visibleModels[0];\n      }\n\n      var seedUrn = this.getSeedUrn();\n      return findMatchingModel(viewer, seedUrn);\n    } }, { key: \"setViewerState\", value: function setViewerState(\n\n    state) {\n      this.itemData.viewerState = Object.assign({}, state);\n\n      // Added attributesVersion to viewerState until all the BIM clients will save it in the backend.\n      this.itemData.viewerState.attributesVersion = ATTRIBUTES_VERSION;\n    } }, { key: \"setOriginalDocumentResolution\", value: function setOriginalDocumentResolution(\n\n    originalDocumentResolution) {\n      this.setViewerState({ originalDocumentResolution: originalDocumentResolution });\n    } }, { key: \"correctDataFormat\", value: function correctDataFormat()\n\n    {var _this = this;\n      var defaultStatusNames = [\n      'draft', 'draft-selected', 'draft-movable', 'open', 'open-selected',\n      'open-movable', 'answered', 'answered-selected', 'answered-movable',\n      'closed', 'closed-selected', 'closed-movable'];\n\n\n      defaultStatusNames.forEach(function (status) {\n        if (_this.itemData.status === status) {\n          _this.itemData.status = \"\".concat(_this.itemData.type || 'issues', \"-\").concat(_this.itemData.status);\n        }\n      });\n    } }, { key: \"getAttributesVersion\", value: function getAttributesVersion()\n\n    {\n      // get attributesVersion from viewerState until all the BIM clients will save it in the backend.\n      return this.itemData.attributesVersion || this.itemData.viewerState && this.itemData.viewerState.attributesVersion;\n    } }, { key: \"setLocationIds\", value: function setLocationIds(\n\n    locationIds) {\n      this.itemData.locationIds = locationIds;\n    } }, { key: \"getSeedUrn\", value: function getSeedUrn()\n\n    {var _this$itemData$viewer, _this$itemData$viewer2;\n      // TODO: Find out why for serialized issues, it is called \"seedUrn\" while for newly created PushPins it is called \"seedURN\". In LMV viewer states, it was \n      //       always \"seedURN\" since several years.\n      return this.itemData.seedURN || ((_this$itemData$viewer = this.itemData.viewerState) === null || _this$itemData$viewer === void 0 ? void 0 : _this$itemData$viewer.seedUrn) || ((_this$itemData$viewer2 = this.itemData.viewerState) === null || _this$itemData$viewer2 === void 0 ? void 0 : _this$itemData$viewer2.seedURN);\n    } }, { key: \"setSeedUrn\", value: function setSeedUrn(\n\n    seedUrn) {\n      this.itemData.seedURN = seedUrn;\n    } }, { key: \"data\", get: function get() {return this.itemData;} }, { key: \"visible\", get: function get() {return this.isVisible;}, set: function set(isVisible) {if (!this.hasPosition()) {this.isVisible = false;} else {this.isVisible = isVisible;}} }]);return PushPinItem;}();export { PushPinItem as default };\n\n\nnamespace.PushPinItem = PushPinItem;","function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError(\"Cannot call a class as a function\");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}var av = Autodesk.Viewing;\nvar _document = av.getGlobal().document;var\n\nHTMLPushPinLabel = /*#__PURE__*/function () {\n  function HTMLPushPinLabel() {_classCallCheck(this, HTMLPushPinLabel);\n    this.container = _document.createElement('div');\n    this.container.className = 'leaflet-text-label';\n    this.text = '';\n    this.dirty = false;\n  }_createClass(HTMLPushPinLabel, [{ key: \"setParent\", value: function setParent(\n\n    parent) {\n      if (this.container.parentNode) {\n        this.container.parentNode.removeChild(this.container);\n      }\n\n      if (parent) {\n        parent.appendChild(this.container);\n      }\n    } }, { key: \"set\", value: function set(\n\n    textString) {\n      if (this.text === textString) {\n        return;\n      }\n\n      this.container.innerHTML = '<span>' + textString + '</span>';\n      this.text = textString;\n\n      var textWidth = this.container.firstChild.clientWidth;\n      var bgWidth = textWidth + 20;\n\n      if (bgWidth < 60) {\n        bgWidth = 60;\n      }\n\n      this.container.style.width = bgWidth.toString() + 'px';\n\n      var top = 10;\n      var left = 0;\n\n      if (this.container.clientWidth !== 0) {\n        var containerHeight = this.container.parentNode.clientHeight;\n        top += containerHeight;\n\n        var containerWidth = this.container.parentNode.clientWidth;\n        left = (containerWidth - this.container.clientWidth) * 0.5;\n      } else {\n        // if label client width is null, need refresh label again.\n        return;\n      }\n\n      top = top.toString() + 'px';\n      left = left.toString() + 'px';\n\n      if (this.container.style.top !== top) {\n        this.container.style.top = top;\n      }\n\n      if (this.container.style.left !== left) {\n        this.container.style.left = left;\n      }\n      this.dirty = false;\n    } }]);return HTMLPushPinLabel;}();export { HTMLPushPinLabel as default };\n\n\nvar namespace = AutodeskNamespace('Autodesk.BIM360.Extension.PushPin');\n\nnamespace.HTMLPushPinLabel = HTMLPushPinLabel;","function _typeof(obj) {\"@babel/helpers - typeof\";if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;};}return _typeof(obj);}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError(\"Cannot call a class as a function\");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}function _get(target, property, receiver) {if (typeof Reflect !== \"undefined\" && Reflect.get) {_get = Reflect.get;} else {_get = function _get(target, property, receiver) {var base = _superPropBase(target, property);if (!base) return;var desc = Object.getOwnPropertyDescriptor(base, property);if (desc.get) {return desc.get.call(receiver);}return desc.value;};}return _get(target, property, receiver || target);}function _superPropBase(object, property) {while (!Object.prototype.hasOwnProperty.call(object, property)) {object = _getPrototypeOf(object);if (object === null) break;}return object;}function _inherits(subClass, superClass) {if (typeof superClass !== \"function\" && superClass !== null) {throw new TypeError(\"Super expression must either be null or a function\");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}function _createSuper(Derived) {var hasNativeReflectConstruct = _isNativeReflectConstruct();return function _createSuperInternal() {var Super = _getPrototypeOf(Derived),result;if (hasNativeReflectConstruct) {var NewTarget = _getPrototypeOf(this).constructor;result = Reflect.construct(Super, arguments, NewTarget);} else {result = Super.apply(this, arguments);}return _possibleConstructorReturn(this, result);};}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");}return self;}function _isNativeReflectConstruct() {if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;if (Reflect.construct.sham) return false;if (typeof Proxy === \"function\") return true;try {Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));return true;} catch (e) {return false;}}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}import HTMLPushPinLabel from '../PushPinLabel/HTMLPushPinLabel';var\n\nPushPinBillboardLabel = /*#__PURE__*/function (_HTMLPushPinLabel) {_inherits(PushPinBillboardLabel, _HTMLPushPinLabel);var _super = _createSuper(PushPinBillboardLabel);\n  function PushPinBillboardLabel(marker, labelText) {var _this;_classCallCheck(this, PushPinBillboardLabel);\n    _this = _super.call(this);\n\n    _this.createLabel(marker, labelText);\n    _this.visible = true;return _this;\n  }_createClass(PushPinBillboardLabel, [{ key: \"createLabel\", value: function createLabel(\n\n    marker, labelText) {\n      _get(_getPrototypeOf(PushPinBillboardLabel.prototype), \"setParent\", this).call(this, marker);\n      this.update(labelText);\n    } }, { key: \"update\", value: function update(\n\n\n\n\n\n\n\n\n\n    labelText) {\n      _get(_getPrototypeOf(PushPinBillboardLabel.prototype), \"set\", this).call(this, labelText);\n\n      this.container.style.top = PushPinBillboardLabel.TOP_PADDING;\n      this.container.style.left = this.container.style.width / 3 + 'px';\n    } }, { key: \"show\", value: function show()\n\n    {\n      this.visible = true;\n      this.container.style.display = 'block';\n    } }, { key: \"hide\", value: function hide()\n\n    {\n      this.visible = false;\n      this.container.style.display = 'none';\n    } }, { key: \"isVisible\", get: function get() {return this.visible;}, set: function set(isVisible) {this.visible = isVisible;} }]);return PushPinBillboardLabel;}(HTMLPushPinLabel);export { PushPinBillboardLabel as default };\n\n\nPushPinBillboardLabel.TOP_PADDING = '50px';\n\nvar namespace = AutodeskNamespace('Autodesk.BIM360.Extension.PushPin');\n\nnamespace.PushPinBillboardLabel = PushPinBillboardLabel;","import { transformViewerState } from './PushPins3D/PushPinViewerState';\nimport { findMatchingModel } from './PushPinItem';\n\n// Helper function used for saving viewerStates in PushPin attributes:\n// For backward compatibility, the globalOffset of the viewerState is always equal to the center of the model bbox. Here 'model'\n// is the model that the issue has been created for.\n// This corresponds to the default globalOffset when using globalOffset=undefined and applyRefPoint=false in the model options.\n//  @param {av.Model} model for which the PushPin was created\nvar getLegacyGlobalOffset = function getLegacyGlobalOffset(model) {\n  // The goal here is to reproduce the default globalOffset that LMV would choose for the case\n  // globalOffset=undefined and applyRefPoint=false.\n  //\n  // It is essential NOT to use model.getBoundingBox(): Only the box in the metadata is unaffected by\n  // any lmv load-time transforms.\n  var boxData = model && model.myData.metadata['world bounding box'];\n  var pMin = boxData.minXYZ;\n  var pMax = boxData.maxXYZ;\n  return {\n    x: 0.5 * (pMin[0] + pMax[0]),\n    y: 0.5 * (pMin[1] + pMax[1]),\n    z: 0.5 * (pMin[2] + pMax[2]) };\n\n};\n\n// For legacy reasons, location and viewerState from issue-backend are stored in viewer-coordinates assuming that a single\n// model has been loaded with default load-options in LMV, i.e.,\n//  - Global offset is at the center of the model for which the issue was created.\n//  - No refPointTransform or custom transform/scaling was applied in loadOptions\n//\n// These conditions are true in single-model viewers like BIM360Docs Viewer,\n// but not in aggregated viewers like ModelCoordination and DesignCollaboration.\n// To make it for all viewers in the same way, we convert position and viewerState\n// in model-local coords - which are independent of load-time transforms.\n// \n// @param {Object} pushPinData - pushPin data with position and viewerState. Conversion works in-place.\nexport var legacyToLocalPushPinData = function legacyToLocalPushPinData(pushPinData, viewer) {\n\n  // Get globalOffset. Note that not all pushpins contain viewerState.\n  var offset = pushPinData.viewerState && pushPinData.viewerState.globalOffset;\n\n  // Legacy-fallback: (consider removal of this section in April 2020)\n  //   Older Issues may not have stored the globalOffset attribute, so some information is lost.\n  //   For these, we have to 'recover' it using some guesswork. To avoid regression, we assume here\n  //   that the issue has been created with the same globalOffset as it is viewed. The old code had\n  //   made this assumption implicitly too - so it will keep the scenarios working that had worked before.\n  if (!offset) {\n    // Note that consistent model placement requires globalOffset to be the same for all models.\n    // So, it's okay to just use viewer.model - even for aggregated views.\n    offset = viewer.model && viewer.model.myData.globalOffset;\n  }\n\n  // Convert position to model-local coords\n  if (offset) {\n    pushPinData.position.x += offset.x;\n    pushPinData.position.y += offset.y;\n    pushPinData.position.z += offset.z;\n  }\n\n  // Note: Unlike position, the viewerState (eye, target, up etc.) is already in model-local coordinates, so we don't need to add anything here.\n};\n\n// Converts PushPinData from local coordinates to legacy format - to ensure compatibility with issues that were saved before introducing model-local coordinates.\nvar localToLegacyPushPinData = function localToLegacyPushPinData(pushPinData, model) {\n  // If there is no saved viewerState, there is nothing to convert;\n  if (!pushPinData.viewerState) {\n    return;\n  }\n\n  // For backward compatibility, the globalOffset is always at the center of the model. (see getLegacyGlobalOffset for details)\n  pushPinData.viewerState.globalOffset = getLegacyGlobalOffset(model);\n\n  // For backward compatibility, the model-local coords are not stored directly in position. Instead the convention is\n  // model-local position is obtained by 'data.position + data.viewerState.globalOffset'. Therefore, we must subtract the globalOffset\n  // before saving.\n  pushPinData.position.x -= pushPinData.viewerState.globalOffset.x;\n  pushPinData.position.y -= pushPinData.viewerState.globalOffset.y;\n  pushPinData.position.z -= pushPinData.viewerState.globalOffset.z;\n};\n\nvar getModelLocalBox = function getModelLocalBox(model) {\n  var boxData = model && model.myData.metadata['world bounding box'];\n  var box = new THREE.Box3();\n  box.min.fromArray(boxData.minXYZ);\n  box.max.fromArray(boxData.maxXYZ);\n  return box;\n};\n\n// Heuristic to detect PushPins that were written while in DesignCollaboration before the positions were fixed.\n// For these, position and camera will be far outside the actual model and need some auto-correction to keep correct.\nvar isOldDCPushPin = function isOldDCPushPin(model, data) {\n\n  // For new issues or old ones from Docs viewer, the pushpin position is given in model-local\n  // coords and is usually inside the model box.\n  // For old issues from Design Collaboration, the position will be far outside of the model-local box     \n  var localBox = getModelLocalBox(model);\n  var dist = localBox.distanceToPoint(data.position) * model.getUnitScale();\n\n  // If the point is more than 100m outside, consider it as an old design collaboration issue.\n  // A valid issue should always be within the model box. The length of 100m is just some heuristic choice\n  // to identify \"clearly far outside\".\n  if (dist < 100) {\n    return false;\n  }\n\n  // Verify that the fallback would actually provide a valid position: If the issue was actually written\n  // by design-collaboration before we fixed the positions, the position should be valid when interpreted \n  // as world coords.\n  var viewerBox = model.getBoundingBox();\n  var pWorld = new THREE.Vector3().copy(data.position);\n\n  if (data.viewerState && data.viewerState.globalOffset) {\n    pWorld.sub(data.viewerState.globalOffset);\n  }\n\n  return viewerBox.containsPoint(pWorld);\n};\n\nvar fixOldDCPushPin = function fixOldDCPushPin(model, data) {\n\n  // get matrix to convert position from world coords to model-local coords\n  var modelLocalToWorld = model.myData.placementTransform;\n  var worldToModelLocal = modelLocalToWorld && new THREE.Matrix4().getInverse(modelLocalToWorld);\n\n  // If there is a placement transform & viewerState, transform pos and viewerState from world to model-local coords.\n  // If there is no placement transform or viewerState, there is nothing todo.\n  if (modelLocalToWorld && data.viewerState) {\n    // transform pos\n    data.position = new THREE.Vector3().copy(data.position).applyMatrix4(worldToModelLocal);\n\n    // transform viewer state\n    data.viewerState = JSON.parse(JSON.stringify(data.viewerState));\n    transformViewerState(data.viewerState, worldToModelLocal);\n  }\n};\n\n// Gets the in-memory reporesentation of a PushPinItem and returns the data in a way that is compatible with the \n// issues saved to issues-backend. For 2D, it is just the original PushPinData. For 3D, we have to apply some coordinate transforms.\nexport var getLegacyPushPinData = function getLegacyPushPinData(pushPin, viewer) {\n\n  // Check whether we are editing in 2D or 3D. Actually it would be safer to check this on the pushPin, \n  // but they don't contain any information about this.\n  var is3d = viewer.model && viewer.model.is3d();\n  if (!is3d) {\n    // For 2D, we are done here (no modifications needed).\n    return pushPin.data;\n  }\n\n  // Internally, PushPinItem stores positions in viewer-coords and viewer states in world-coords.\n  // Both depend on the model-load options used in the current viewer application, i.e., would not allow issues\n  // between different viewing applications.\n  //\n  // In the PushPinAttributes, we store everything in model-local coords. These coordinates are not affected by any load-time transform.\n  // Therefore, they are always the same for different LMV clients - no matter which loadOptions they are using. Also, it\n  // ensures that the issues automatically \"follows\" the model in case the refPointTransform changed.\n  var data = pushPin.getLocal(viewer);\n\n  // When using getLocal(), position and viewerState (eye, target, ..) are consistently given in model-local coords. In a perfect world, we were done now.\n  // But, for backwards compatibility with previously existing issues, we need some legacy conversions before storing the data.\n\n  // For backward compatibility, the globalOffset is always at the center of the model. (see getLegacyGlobalOffset for details)\n  var model = pushPin.findModel(viewer);\n  if (!model) {\n    console.error('Saving issue attributes failed: Issue must be assigned to a visible model.');\n    return pushPin.data;\n  }\n\n  // Convert from model-local coords to legacy PushPins: For backward compatility, they PushPin position must match with the viewer\n  // position when viewing a single model with default loadOptions (default globalOffset, no transforms).\n  localToLegacyPushPinData(data, model);\n\n  return data;\n};\n\n//\n// The purpose of this function is to avoid regressions for issues that have been created...\n//  - using Design Collaboration\n//  - written before we made the issue positions and viewerStates compatible with BIM360Docs viewer.\n//\n// For these issues, PushPin positions and viewerState will be world-coords. In the past, they had worked - but only under\n// the assumption that an issue is viewed under exactly the same conditions (globalOffset, model placement etc.) in which it was created.\n//\n// The heuristic in this section is making sure that this case keeps working - by converting position and viewerState to model-local coordinates.\n//\n// Note: This fallback is not needed for viewers that use LMV default loadOptions like BIM360Docs viewer.\n//\n// @param {Object} data - PushPinData. Same as in PushPinExtension.createItem(..). Will be modified in-place if needed.\n// @param {Viewer3D} viewer\nexport var applyLegacyFallback = function applyLegacyFallback(data, viewer) {\n  // If there is no saved viewerState, there is nothing we can do.\n  if (!data.viewerState) {\n    return;\n  }\n\n  // find model that the pushpin belongs to\n  var model = findMatchingModel(viewer, data.viewerState.seedUrn);\n  if (!model) {\n    return;\n  }\n\n  // Apply fallback only if we know for sure that the PushPin position would be broken otherwise.\n  if (!isOldDCPushPin(model, data)) {\n    return;\n  }\n\n  // Transform position and viewerState\n  fixOldDCPushPin(model, data);\n};","/**\n * Include each locale json file and return it in an object\n * that can be consumed by i18n\n */\n\nimport json_en from '../../res/locales/en/nobundle-pushpins.loc.json';\n\nimport json_en_GB from '../../res/locales/en-GB/nobundle-pushpins.loc.json';\nimport json_cs from '../../res/locales/cs/nobundle-pushpins.loc.json';\nimport json_de from '../../res/locales/de/nobundle-pushpins.loc.json';\nimport json_es from '../../res/locales/es/nobundle-pushpins.loc.json';\nimport json_fr from '../../res/locales/fr/nobundle-pushpins.loc.json';\nimport json_fr_CA from '../../res/locales/fr-CA/nobundle-pushpins.loc.json';\nimport json_it from '../../res/locales/it/nobundle-pushpins.loc.json';\nimport json_ja from '../../res/locales/ja/nobundle-pushpins.loc.json';\nimport json_ko from '../../res/locales/ko/nobundle-pushpins.loc.json';\nimport json_pl from '../../res/locales/pl/nobundle-pushpins.loc.json';\nimport json_pt_BR from '../../res/locales/pt-BR/nobundle-pushpins.loc.json';\nimport json_ru from '../../res/locales/ru/nobundle-pushpins.loc.json';\nimport json_tr from '../../res/locales/tr/nobundle-pushpins.loc.json';\nimport json_zh_HANS from '../../res/locales/zh-HANS/nobundle-pushpins.loc.json';\nimport json_zh_HANT from '../../res/locales/zh-HANT/nobundle-pushpins.loc.json';\nimport json_zh_HK from '../../res/locales/zh-HK/nobundle-pushpins.loc.json';\nimport json_nl from '../../res/locales/nl/nobundle-pushpins.loc.json';\nimport json_sv from '../../res/locales/sv/nobundle-pushpins.loc.json';\nimport json_da from '../../res/locales/da/nobundle-pushpins.loc.json';\nimport json_no from '../../res/locales/no/nobundle-pushpins.loc.json';\n\nexport var locales = {\n  en: json_en,\n  \"en-GB\": json_en_GB,\n  cs: json_cs,\n  de: json_de,\n  es: json_es,\n  fr: json_fr,\n  \"fr-CA\": json_fr_CA,\n  it: json_it,\n  ja: json_ja,\n  ko: json_ko,\n  pl: json_pl,\n  \"pt-BR\": json_pt_BR,\n  ru: json_ru,\n  tr: json_tr,\n  \"zh-HANS\": json_zh_HANS,\n  \"zh-HANT\": json_zh_HANT,\n  \"zh-HK\": json_zh_HK,\n  nl: json_nl,\n  sv: json_sv,\n  da: json_da,\n  no: json_no };","function _typeof(obj) {\"@babel/helpers - typeof\";if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;};}return _typeof(obj);}function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {try {var info = gen[key](arg);var value = info.value;} catch (error) {reject(error);return;}if (info.done) {resolve(value);} else {Promise.resolve(value).then(_next, _throw);}}function _asyncToGenerator(fn) {return function () {var self = this,args = arguments;return new Promise(function (resolve, reject) {var gen = fn.apply(self, args);function _next(value) {asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);}function _throw(err) {asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);}_next(undefined);});};}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError(\"Cannot call a class as a function\");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}function _get(target, property, receiver) {if (typeof Reflect !== \"undefined\" && Reflect.get) {_get = Reflect.get;} else {_get = function _get(target, property, receiver) {var base = _superPropBase(target, property);if (!base) return;var desc = Object.getOwnPropertyDescriptor(base, property);if (desc.get) {return desc.get.call(receiver);}return desc.value;};}return _get(target, property, receiver || target);}function _superPropBase(object, property) {while (!Object.prototype.hasOwnProperty.call(object, property)) {object = _getPrototypeOf(object);if (object === null) break;}return object;}function _inherits(subClass, superClass) {if (typeof superClass !== \"function\" && superClass !== null) {throw new TypeError(\"Super expression must either be null or a function\");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}function _createSuper(Derived) {var hasNativeReflectConstruct = _isNativeReflectConstruct();return function _createSuperInternal() {var Super = _getPrototypeOf(Derived),result;if (hasNativeReflectConstruct) {var NewTarget = _getPrototypeOf(this).constructor;result = Reflect.construct(Super, arguments, NewTarget);} else {result = Super.apply(this, arguments);}return _possibleConstructorReturn(this, result);};}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");}return self;}function _isNativeReflectConstruct() {if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;if (Reflect.construct.sham) return false;if (typeof Proxy === \"function\") return true;try {Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));return true;} catch (e) {return false;}}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}import PushPinItem from './PushPinItem';\nimport { PUSHPIN_EVENTS } from './PushPinEvents';\nimport { convertPdfToLeaflet, applyPdfWorldScaling, clientToWorldLeaflet } from './PushPinUtils';\nimport { thumbnailSize, thumbnailOriginalPixelSize, thumbnailMarkerRadius } from './PushPinConstants';\n\nvar namespace = AutodeskNamespace('Autodesk.BIM360.Extension.PushPin');var\n\nPushPinManager = /*#__PURE__*/function (_Autodesk$Viewing$Eve) {_inherits(PushPinManager, _Autodesk$Viewing$Eve);var _super = _createSuper(PushPinManager);\n  function PushPinManager(viewer) {var _this;var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};_classCallCheck(this, PushPinManager);\n    _this = _super.call(this);\n\n    _this.viewer = viewer;\n    _this.options = options;\n\n    _this.pushPinList = [];\n    _this.selectedItem = null;\n    _this.PushPinTypes = {\n      ISSUES: 'issues',\n      RFIS: 'rfis',\n      QUALITY_ISSUES: 'quality_issues' };\n\n\n    _this.is2D = !!_this.viewer.impl.is2d;\n\n    // In case the 3d model has no thickness, consider it as a 'pseudo 2D' model.\n    // It will disable the occlusion test. And when creating new pushpins it will not interact with the objects, but with the ground. \n    if (!_this.is2D) {\n      var modelBB = _this.viewer.model.getBoundingBox();\n      var worldUp = _this.viewer.impl.worldUpName();\n      _this.isPseudo2D = modelBB.max[worldUp] - modelBB.min[worldUp] === 0;\n      _this.options.disableOcclusionTest = _this.options.disableOcclusionTest || _this.isPseudo2D;\n    }\n\n    _this.pushPinsVisibilityByType = _this.getInitialPushpinVisibilityByType();\n    _this.pushpinsByType = _this.getInitialPushpinsByType();\n    _this.create = Promise.resolve();\n\n    _this.onPushpinEditStartBinded = _this.onPushpinEditStart.bind(_assertThisInitialized(_this));\n    _this.onPushpinEditEndBinded = _this.onPushpinEditEnd.bind(_assertThisInitialized(_this));\n\n    _this.addEventListener(PUSHPIN_EVENTS.PUSH_PIN_EDIT_START_EVENT, _this.onPushpinEditStartBinded);\n    _this.addEventListener(PUSHPIN_EVENTS.PUSH_PIN_EDIT_END_EVENT, _this.onPushpinEditEndBinded);\n    _this.addEventListener(PUSHPIN_EVENTS.PUSH_PIN_REMOVED_EVENT, _this.onPushpinEditEndBinded);return _this;\n  }_createClass(PushPinManager, [{ key: \"items\", value: function items()\n\n    {\n      return this.pushPinList;\n    } }, { key: \"getInitialPushpinsByType\", value: function getInitialPushpinsByType()\n\n    {var _this2 = this;\n      var cache = {};\n\n      Object.keys(this.PushPinTypes).forEach(function (issueTypeKey) {\n        cache[_this2.PushPinTypes[issueTypeKey]] = {};\n      });\n\n      return cache;\n    } }, { key: \"getInitialPushpinVisibilityByType\", value: function getInitialPushpinVisibilityByType()\n\n    {var _this3 = this;\n      var cache = {};\n\n      Object.keys(this.PushPinTypes).forEach(function (typeKey) {\n        cache[_this3.PushPinTypes[typeKey]] = true;\n      });\n\n      return cache;\n    } }, { key: \"shouldGenerateThumbnail\", value: function shouldGenerateThumbnail(\n\n    item) {\n      return this.options.generateIssueThumbnail && (item.data.type === this.PushPinTypes.ISSUES || item.data.type === this.PushPinTypes.QUALITY_ISSUES) ||\n      this.options.generateRFIThumbnail && item.data.type === this.PushPinTypes.RFIS;\n    } }, { key: \"generateThumbnail\", value: function generateThumbnail(\n\n    item) {var _this4 = this;\n      if (!this.shouldGenerateThumbnail(item)) {\n        return Promise.resolve(null);\n      }\n\n      return new Promise(function (resolve, reject) {var _item$data$position =\n        item.data.position,x = _item$data$position.x,y = _item$data$position.y,z = _item$data$position.z; // Backup position.\n\n        if (_this4.viewer.model.isPdf(true)) {\n          convertPdfToLeaflet(_this4.viewer, item.data);\n        }\n\n        _this4.fireEvent({ type: PUSHPIN_EVENTS.PUSH_PIN_PREPARING_THUMBNAIL, value: item });\n\n        item.data.position = { x: x, y: y, z: z }; // Restore position.\n\n        var width, height, zoomRatio;\n        var pWorld;\n        var markerPos;\n        var bounds;\n\n        if (_this4.viewer.model.isLeaflet()) {\n          pWorld = applyPdfWorldScaling(_this4.viewer, item.data);\n        } else {\n          pWorld = item.data.position;\n        }\n\n        var canvasBounds = _this4.viewer.impl.getCanvasBoundingClientRect();\n        var ratio = canvasBounds.width / canvasBounds.height;\n\n        if (ratio > 1) {\n          height = Math.floor(Math.max(canvasBounds.height, thumbnailSize));\n          zoomRatio = height / canvasBounds.height;\n          width = Math.floor(canvasBounds.width * zoomRatio);\n        } else {\n          width = Math.floor(Math.max(canvasBounds.width, thumbnailSize));\n          zoomRatio = width / canvasBounds.width;\n          height = Math.floor(canvasBounds.height * zoomRatio);\n        }\n\n        var overlayRenderer = function overlayRenderer(viewer, options) {var\n          width = options.width,height = options.height,ctx = options.ctx,target = options.target,screenshotCamera = options.screenshotCamera,onRenderDone = options.onRenderDone;var _ctx$targetToCanvas =\n          ctx.targetToCanvas(target),canvas = _ctx$targetToCanvas.canvas;\n\n          // In case bounds were supplied, it means that the marker should be in the center of the screenshot.\n          if (bounds) {\n            markerPos = { x: width / 2, y: height / 2 };\n          } else {\n            // Otherwise, we are probably in a 3D scene - marker can be anywhere. In that case we should\n            // calculate the marker position on canvas according to the pushpin's world position.\n            markerPos = viewer.worldToClient(pWorld, screenshotCamera).multiplyScalar(zoomRatio);\n          }\n\n          var radius = thumbnailMarkerRadius;\n          var ctx2d = canvas.getContext(\"2d\");\n          ctx2d.fillStyle = \"#FF0000\";\n          ctx2d.beginPath();\n          ctx2d.arc(markerPos.x, height - markerPos.y, radius, 0, 2 * Math.PI);\n          ctx2d.closePath();\n          ctx2d.fill();\n\n          onRenderDone(canvas);\n        };\n\n        var getCropBounds = function getCropBounds(viewer, camera) {\n          var cropCenter = markerPos;\n\n          // Make sure crop won't exceed bounds.\n          if (cropCenter.x + thumbnailSize / 2 > width) {\n            cropCenter.x -= cropCenter.x + thumbnailSize / 2 - width;\n          }\n\n          if (cropCenter.y + thumbnailSize / 2 > height) {\n            cropCenter.y -= cropCenter.y + thumbnailSize / 2 - height;\n          }\n\n          var clientBounds = new THREE.Box3().expandByPoint(cropCenter);\n          clientBounds.expandByVector(new THREE.Vector3(thumbnailSize / 2, thumbnailSize / 2, 0));\n\n          return clientBounds;\n        };\n\n        // Zoom in with virtual camera to get the desired thumbnail size.\n        if (_this4.viewer.model.is2d()) {\n\n          var thumbnailSizeWorld;\n          var zeroWorld;\n\n          if (!_this4.viewer.model.isPageCoordinates()) {\n            thumbnailSizeWorld = clientToWorldLeaflet(_this4.viewer, thumbnailOriginalPixelSize, 0);\n            zeroWorld = clientToWorldLeaflet(_this4.viewer, 0, 0);\n          } else {\n            thumbnailSizeWorld = _this4.viewer.clientToWorld(thumbnailOriginalPixelSize, 0, undefined, true).point;\n            zeroWorld = _this4.viewer.clientToWorld(0, 0, undefined, true).point;\n          }\n\n          var size = thumbnailSizeWorld.distanceTo(zeroWorld);\n\n          bounds = new THREE.Box3().expandByPoint(pWorld);\n          bounds.expandByVector(new THREE.Vector3(size / 2, size / 2, 0));\n          bounds.min.z = 0;\n          bounds.max.z = 0;\n        }\n\n        var options = {\n          bounds: bounds,\n          getCropBounds: getCropBounds,\n          overlayRenderer: overlayRenderer };\n\n\n        Autodesk.Viewing.ScreenShot.getScreenShotWithBounds(\n        _this4.viewer,\n        width,\n        height,\n        function (blob, outputWidth, outputHeight) {\n          if (!blob) {\n            return reject('Error while preparing pushpin thumbnail.');\n          }\n\n          Autodesk.Viewing.ScreenShot.blobToImage(blob, outputWidth, outputHeight, function (img) {\n            return resolve(img);\n          });\n        },\n        options);\n\n      }).catch(function (e) {\n        // In case of an error in the screenshot creation, continue saving the pushpin with empty thumbnail.\n        console.error(e);\n        return null;\n      });\n    }\n\n    // Update locationIds array inside the item's data.\n  }, { key: \"setItemLocationIds\", value: function setItemLocationIds(item) {\n      var point;\n\n      // Locations are stored using page coordinate system.\n      // In case we are viewing a Leaflet document, the pushpin position has to be converted into the same coordinate system.\n      if (this.viewer.model.isLeaflet()) {\n        var pWorld = applyPdfWorldScaling(this.viewer, item.data);\n\n        if (this.viewer.model.isPageCoordinates()) {\n          point = pWorld;\n        } else {\n          point = Autodesk.Viewing.PDFUtils.leafletToPdfWorld(this.viewer, pWorld);\n        }\n\n      } else {\n        point = item.data.position;\n      }\n\n      // Intersect pushpin position with locations array.\n      var intersectedLocationIds = this.getLocationIdsAtPoint(point);\n      item.setLocationIds(intersectedLocationIds);\n    }\n\n    // @param {Object} data                - Data to be copied to the PushPin. By default, it must contain a pushpin position.\n    // @param {bool}   [isTriggeringEvent] - Fire PUSH_PIN_CREATED event by default\n    // @param {bool}   [createFromLocal]   - By default, data.position is assumed to be in world-coords (ready-to-render for the viewer).\n    //                                       If true, the position is provided in model-local coordinates instead.\n    // @param {Viewer3D} [viewer}          - Only needed when createFromLocal is true: In this case, we need to find the model for this PushPin to convert the position.\n  }, { key: \"createItem\", value: function createItem(data) {var _this5 = this;var isTriggeringEvent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;var createFromLocal = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;var viewer = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : undefined;\n\n      if (this.getItemById(data.id)) {\n        return null;\n      }\n\n      var newItem = new PushPinItem();\n\n      if (createFromLocal) {\n        // Set pushPinData - assuming that position and viewerState are given in model-local coords.\n        // In this case, we have to convert them to viewer-coordinates first.\n        newItem.setLocal(data, viewer);\n      } else {\n        newItem.set(data);\n      }\n\n      this.addItem(newItem);\n\n      if (isTriggeringEvent) {\n        this.create(newItem).\n        then(function () {\n          _this5.setItemLocationIds(newItem);\n          return _this5.generateThumbnail(newItem);\n        }).\n        then(function (thumbnail) {var _newItem$data$positio =\n\n          newItem.data.position,x = _newItem$data$positio.x,y = _newItem$data$positio.y,z = _newItem$data$positio.z; // Backup position.\n\n          if (_this5.viewer.model.isPdf(true)) {\n            convertPdfToLeaflet(_this5.viewer, newItem.data);\n          }\n\n          _this5.fireEvent({ type: PUSHPIN_EVENTS.PUSH_PIN_CREATED_EVENT, value: newItem, thumbnail: thumbnail });\n\n          newItem.data.position = { x: x, y: y, z: z }; // Restore position.\n        });\n      }\n\n      return newItem;\n    } }, { key: \"addItems\", value: function addItems(\n\n    dataArray, createFromLocal, viewer) {var _this6 = this;\n      dataArray.forEach(function (pushPinData) {\n        if (_this6.viewer.model.isPdf(true)) {var _applyPdfWorldScaling =\n          applyPdfWorldScaling(_this6.viewer, pushPinData),x = _applyPdfWorldScaling.x,y = _applyPdfWorldScaling.y,z = _applyPdfWorldScaling.z;\n          pushPinData.position = { x: x, y: y, z: z };\n        }\n\n        _this6.createItem(pushPinData, false, createFromLocal, viewer);\n      });\n    } }, { key: \"removeAllItems\", value: function removeAllItems()\n\n    {\n      this.selectedItem = null;\n      this.pushPinList = [];\n\n      // Update local pushpins cache\n      this.pushpinsByType = this.getInitialPushpinsByType();\n\n      this.fireEvent({ type: PUSHPIN_EVENTS.PUSH_PIN_REMOVE_ALL_EVENT });\n    } }, { key: \"addItem\", value: function addItem(\n\n    item) {\n      if (item.data && item.data.id) {\n        var idx = this.getItemIndexById(item.data.id);\n\n        if (idx > -1) {\n          return false;\n        }\n\n        var type = item.data.type;\n\n        if (type && this.pushPinsVisibilityByType) {\n          item.visible = this.pushPinsVisibilityByType[type];\n        }\n\n        type = type || this.PushPinTypes.ISSUES;\n\n        // Update local pushpins cache, handle only pushpins with supported type\n        if (this.pushpinsByType[type]) {\n          this.pushpinsByType[type][item.data.id] = item.data;\n        }\n\n        this.pushPinList.unshift(item);\n        return true;\n      }\n      return false;\n    } }, { key: \"removeItemById\", value: function removeItemById(\n\n    id) {\n      if (this.selectedItem && this.selectedItem.data.id === id) {\n        this.selectedItem = null;\n      }\n      var idx = this.getItemIndexById(id);\n\n      if (idx > -1) {\n        var item = this.pushPinList.splice(idx, 1)[0];\n\n        var type = item.data.type;\n\n        // Update local pushpins cache, handle only pushpins with supported type\n        if (type && this.pushpinsByType[type]) {\n          delete this.pushpinsByType[type][id];\n        }\n\n        this.fireEvent({ type: PUSHPIN_EVENTS.PUSH_PIN_REMOVED_EVENT, value: item });\n        return item;\n      }\n\n      return null;\n    } }, { key: \"removeItemsByType\", value: function removeItemsByType(\n\n    type) {var _this7 = this;\n      var pushPinTypeObject = this.pushpinsByType[type] || {};\n\n      Object.keys(pushPinTypeObject).forEach(function (id) {\n        _this7.removeItemById(id);\n      });\n    } }, { key: \"updateItemById\", value: function updateItemById(\n\n    id, data) {\n      // 1. validate data & create new one\n      var item = this.getItemById(id);\n      if (!item) {\n        return null;\n      }\n      var idx = this.getItemIndexById(item.data.id);\n\n      if (!data || !data.id || data.type !== item.data.type) {\n        return null;\n      }\n\n      if (this.viewer.model.isPdf(true)) {var _applyPdfWorldScaling2 =\n        applyPdfWorldScaling(this.viewer, data),x = _applyPdfWorldScaling2.x,y = _applyPdfWorldScaling2.y,z = _applyPdfWorldScaling2.z;\n        data.position = { x: x, y: y, z: z };\n      }\n\n      // 2. update data\n      item.set(data);\n\n      // 3. update local pushpins cache, handle only pushpins with supported type\n      var type = item.data.type;\n\n      if (type && this.pushpinsByType[type]) {\n        delete this.pushpinsByType[type][id];\n        this.pushpinsByType[type][item.data.id] = item.data;\n      }\n      this.pushPinList[idx] = item;\n\n      this.fireEvent({ type: PUSHPIN_EVENTS.PUSH_PIN_UPDATE_EVENT, value: item });\n\n      return item;\n    } }, { key: \"getItemById\", value: function getItemById(\n\n    id) {\n      var idx = this.getItemIndexById(id);\n      return idx > -1 ? this.pushPinList[idx] : null;\n    } }, { key: \"getItemIndexById\", value: function getItemIndexById(\n\n    id) {\n      var idx = -1;\n      this.pushPinList.every(function (item, index) {\n        if (item.data.id === id) {\n          idx = index;\n          return false;\n        }\n        return true;\n      });\n      return idx;\n    } }, { key: \"getItemCountByType\", value: function getItemCountByType(\n\n    type) {\n      var pushPinTypeObject = this.pushpinsByType[type] || {};\n\n      return Object.keys(pushPinTypeObject).length;\n    } }, { key: \"getSelectedItem\", value: function getSelectedItem()\n\n    {\n      return this.selectedItem;\n    } }, { key: \"selectOne\", value: function selectOne(\n\n    id, reTriggerEvent) {\n      var triggerSelectionEvent = Boolean(reTriggerEvent);\n      if (!this.selectedItem || this.selectedItem.data.id !== id) {\n\n        var oldOne = this.selectedItem;\n        this.selectedItem = this.getItemById(id);\n\n        if (oldOne !== this.selectedItem) {\n          oldOne && (oldOne.selected = false);\n          this.selectedItem && (this.selectedItem.selected = true);\n          triggerSelectionEvent = true;\n        }\n      }\n\n      if (triggerSelectionEvent) {\n        this.fireEvent({ type: PUSHPIN_EVENTS.PUSH_PIN_SELECTED_EVENT, value: this.selectedItem });\n      }\n\n      return this.selectedItem;\n    } }, { key: \"selectNone\", value: function selectNone()\n\n    {\n      this.selectOne(null);\n    } }, { key: \"getVisibleByType\", value: function getVisibleByType(\n\n    type) {\n      return this.pushPinsVisibilityByType[type];\n    } }, { key: \"setVisibleByType\", value: function setVisibleByType(\n\n    type, isVisible) {var _this8 = this;\n      this.pushPinsVisibilityByType[type] = isVisible;\n      var pushPinTypeObject = this.pushpinsByType[type] || {};\n\n      Object.keys(pushPinTypeObject).forEach(function (id) {\n        var item = _this8.getItemById(id);\n\n        if (item) {\n          item.visible = isVisible;\n        }\n      });\n\n      this.fireEvent({ type: PUSHPIN_EVENTS.PUSH_PIN_VISIBILITY_EVENT, value: { type: type, isVisible: isVisible } });\n    } }, { key: \"addEventListener\", value: function addEventListener(\n\n    event, func) {\n      if (!this.hasEventListener(event, func)) {\n        _get(_getPrototypeOf(PushPinManager.prototype), \"addEventListener\", this).call(this, event, func);\n      }\n    } }, { key: \"setCreateFunction\", value: function setCreateFunction(\n\n    func) {\n      this.create = func;\n    } }, { key: \"removeCreateFunction\", value: function removeCreateFunction(\n\n    func) {\n      if (func === this.create) {\n        this.create = Promise.resolve();\n      }\n    } }, { key: \"getLocationsExtension\", value: function getLocationsExtension()\n\n    {\n      return this.viewer.getExtension(\"Autodesk.AEC.LocationsExtension\");\n    } }, { key: \"getLocationsExtensionAsync\", value: function getLocationsExtensionAsync()\n\n    {\n      return this.viewer.getExtensionAsync(\"Autodesk.AEC.LocationsExtension\");\n    } }, { key: \"onPushpinEditStart\", value: function () {var _onPushpinEditStart = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {var explodeExt, model, locationsExtension;return regeneratorRuntime.wrap(function _callee$(_context) {while (1) {switch (_context.prev = _context.next) {case 0:\n\n\n                explodeExt = this.viewer.getExtension('Autodesk.Explode');\n\n                if (explodeExt) {\n                  explodeExt.setUIEnabled(false);\n                }\n\n                // In order to avoid extension loading timing issues, we use the async api here.\n                // Just make sure that the model wasn't changed by the time we got the result.\n                model = this.viewer.model;\n                this.pushpinEditStarted = true;_context.next = 6;return (\n                  this.getLocationsExtensionAsync());case 6:locationsExtension = _context.sent;\n\n                if (locationsExtension && this.viewer.model === model && this.pushpinEditStarted) {\n                  if (this.options.showLocations) {\n                    locationsExtension.showAllLocations();\n                  }\n\n                  // Update initial hover for selected pushpin (before actually moving the mouse).\n                  if (this.selectedItem) {\n                    locationsExtension.hoverLocationsByIds(this.selectedItem.data.locationIds);\n                  }\n\n                  // Stop highlight when placing pushpin on 2D locations.\n                  this.highlightPausedBackup = this.viewer.isHighlightPaused();\n                  this.viewer.impl.pauseHighlight(true);\n                }case 8:case \"end\":return _context.stop();}}}, _callee, this);}));function onPushpinEditStart() {return _onPushpinEditStart.apply(this, arguments);}return onPushpinEditStart;}() }, { key: \"onPushpinEditEnd\", value: function onPushpinEditEnd()\n\n\n    {\n      // If item is still draggable, the edit is not really done.\n      if (this.selectedItem && this.selectedItem.draggable) {\n        return;\n      }\n\n      var explodeExt = this.viewer.getExtension('Autodesk.Explode');\n\n      if (explodeExt) {\n        explodeExt.setUIEnabled(true);\n      }\n\n      var locationsExtension = this.getLocationsExtension();\n\n      if (locationsExtension) {\n        locationsExtension.hideAllLocations();\n\n        // Restore highlights.\n        this.viewer.impl.pauseHighlight(this.highlightPausedBackup);\n      }\n\n      this.pushpinEditStarted = false;\n    } }, { key: \"getLocationIdsAtPoint\", value: function getLocationIdsAtPoint(\n\n    point) {\n      var locationsExtension = this.getLocationsExtension();\n\n      if (locationsExtension) {\n        return locationsExtension.getLocationIdsAtPoint(point);\n      }\n\n      return [];\n    } }, { key: \"hoverLocations\", value: function hoverLocations(\n\n    event) {\n      var locationsExtension = this.getLocationsExtension();\n\n      if (locationsExtension) {\n        locationsExtension.onMouseMove(event);\n      }\n    } }]);return PushPinManager;}(Autodesk.Viewing.EventDispatcher);export { PushPinManager as default };\n\n\nnamespace.PushPinManager = PushPinManager;","function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError(\"Cannot call a class as a function\");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}var av = Autodesk.Viewing;\nvar _window = av.getGlobal();var\nPushPinMobileObserver = /*#__PURE__*/function () {\n  function PushPinMobileObserver(pushpinManager) {_classCallCheck(this, PushPinMobileObserver);\n    this.pushpinManager = pushpinManager;\n\n    this.addListeners();\n  }_createClass(PushPinMobileObserver, [{ key: \"addListeners\", value: function addListeners()\n\n    {\n      this.pushpinManager.addEventListener(Autodesk.BIM360.Extension.PushPin.PUSH_PIN_CREATED_EVENT, function (event) {\n        PushPinMobileObserver.postMessage('onPushPinCreated', event);\n      });\n\n      this.pushpinManager.addEventListener(Autodesk.BIM360.Extension.PushPin.PUSH_PIN_PREPARING_THUMBNAIL, function (event) {\n        PushPinMobileObserver.postMessage('onPushPinPreparingThumbnail', event);\n      });\n\n      this.pushpinManager.addEventListener(Autodesk.BIM360.Extension.PushPin.PUSH_PIN_CLICKED_EVENT, function (event) {\n        PushPinMobileObserver.postMessage('onPushPinActived', event);\n      });\n\n      this.pushpinManager.addEventListener(Autodesk.BIM360.Extension.PushPin.PUSH_PIN_MODIFY_EVENT, function (event) {\n        PushPinMobileObserver.postMessage('onPushPinMoved', event);\n      });\n\n      this.pushpinManager.addEventListener(Autodesk.BIM360.Extension.PushPin.PUSH_PIN_SELECT_NONE, function (event) {\n        PushPinMobileObserver.postMessage('onPushPinSelectNone', event);\n      });\n\n      this.pushpinManager.addEventListener(Autodesk.BIM360.Extension.PushPin.PUSH_PIN_UPDATE_EVENT, function (event) {\n        PushPinMobileObserver.postMessage('onPushPinUpdated', event);\n      });\n\n      this.pushpinManager.addEventListener(Autodesk.BIM360.Extension.PushPin.PUSH_PIN_ITEMS_LOADED, function (event) {\n        PushPinMobileObserver.postMessage('onPushPinItemsLoaded', event);\n      });\n\n      PushPinMobileObserver.postMessage('onPushPinToolLoaded', {});\n    } }], [{ key: \"postMessage\", value: function postMessage(\n\n    messageName, event) {\n      var pushPinItem = event.value;\n      var thumbnail = event.thumbnail || '';\n\n      var metadata = {};\n\n      if (pushPinItem) {\n        metadata = {\n          id: pushPinItem.data.id,\n          label: pushPinItem.data.label,\n          status: pushPinItem.data.status,\n          position: {\n            x: pushPinItem.data.position.x,\n            y: pushPinItem.data.position.y,\n            z: pushPinItem.data.position.z },\n\n          type: pushPinItem.data.type,\n          objectId: pushPinItem.data.objectId,\n          externalId: pushPinItem.data.externalId,\n          viewerState: pushPinItem.data.viewerState,\n          attributesVersion: pushPinItem.getAttributesVersion(),\n          locationIds: pushPinItem.data.locationIds || [] };\n\n      }\n\n      if (_window.webkit !== undefined) {\n        // New iOS SDK uses a standard callback method with the pattern of \"command\" and \"data\", just like MobileCallbacks.js\n        _window.webkit.messageHandlers.callbackHandler.postMessage({ command: messageName, data: { metadata: metadata, thumbnail: thumbnail } });\n      } else if (_window.JSINTERFACE) {\n        // Android\n        if (!pushPinItem) {\n          _window.JSINTERFACE[messageName]();\n        } else {\n          _window.JSINTERFACE[messageName](metadata.id, metadata.type, metadata.label, metadata.status,\n          metadata.position.x, metadata.position.y, metadata.position.z, metadata.objectId,\n          JSON.stringify(metadata.viewerState), metadata.externalId, metadata.attributesVersion, JSON.stringify(metadata.locationIds), thumbnail);\n        }\n      }\n    } }]);return PushPinMobileObserver;}();export { PushPinMobileObserver as default };","function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError(\"Cannot call a class as a function\");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}import { PUSHPIN_EVENTS } from './PushPinEvents';\nimport { clientToWorld, invertModelTransform } from \"./PushPinUtils\";\nimport { cursorIcon } from './PushPinConstants';\nimport RenderHandler2D from './PushPins2D/RenderHandler2D';\nimport RenderHandler3D from './PushPins3D/RenderHandler3D';\n\nvar av = Autodesk.Viewing;var\n\nPushPinTool = /*#__PURE__*/function () {\n  function PushPinTool(viewer, pushPinManager) {_classCallCheck(this, PushPinTool);\n    this.setGlobalManager(viewer.globalManager);\n\n    this.names = ['pushpin'];\n    this.priority = 45;\n    this.pushpinCursor = cursorIcon;\n\n    this.isActive = false;\n    this.pushPinInitData = null;\n    this.viewer = viewer;\n    this.pushPinManager = pushPinManager;\n    this.createMode = false;\n\n    // This is for test\n    this.testId = '1111122222333334444455555';\n    this.autoCreate = false;\n    // test end\n  }_createClass(PushPinTool, [{ key: \"getNames\", value: function getNames()\n\n    {\n      return this.names;\n    } }, { key: \"getName\", value: function getName()\n\n    {\n      return this.names[0];\n    } }, { key: \"getPriority\", value: function getPriority()\n\n    {\n      return this.priority;\n    } }, { key: \"setAutoCreate\", value: function setAutoCreate(\n\n    auto) {\n      this.autoCreate = auto;\n    } }, { key: \"getCursor\", value: function getCursor()\n\n    {\n      if (this.createMode) {\n        return this.pushpinCursor;\n      }\n      return this.isHover ? 'pointer' : null;\n    } }, { key: \"register\", value: function register()\n\n    {\n      // Init render tool\n      if (!this.renderTool) {\n        if (this.pushPinManager.is2D) {\n          this.renderTool = new RenderHandler2D(this.viewer, this.pushPinManager);\n        } else {\n          this.renderTool = new RenderHandler3D(this.viewer, this.pushPinManager);\n        }\n\n        this.renderTool.register();\n      }\n    } }, { key: \"deregister\", value: function deregister()\n\n    {\n      if (this.renderTool) {\n        this.renderTool.deregister();\n        this.renderTool = null;\n      }\n    } }, { key: \"activate\", value: function activate(\n\n    name, viewerApi) {\n      if (name === this.getName()) {\n        this.renderTool.activate();\n        this.isActive = true;\n      }\n    } }, { key: \"deactivate\", value: function deactivate(\n\n    name) {\n      if (name === this.getName()) {\n        this.show(false);\n        this.isActive = false;\n      }\n    } }, { key: \"update\", value: function update()\n\n    {\n      if (this.isActive) {\n        if (this.duringShowing && this.renderTool) {\n          this.renderTool.render();\n        }\n      }\n\n      // return false, because push pin render doesn't affect LMV model.\n      return false;\n    } }, { key: \"show\", value: function show(\n\n    duringShowing) {\n      this.duringShowing = duringShowing;\n    } }, { key: \"enablePushPinSelect\", value: function enablePushPinSelect(\n\n    enable) {\n      this.pushPinManager.items().forEach(function (item) {\n        item.selectable = enable;\n      });\n    }\n\n    // Each time client initiate push pin create with default info and one at a time\n  }, { key: \"startCreateItem\", value: function startCreateItem(data) {\n      if (this.isActive) {\n        var controller = this.viewer.toolController;\n        if (controller && controller.getActiveToolName() !== this.getName()) {\n          controller.deactivateTool(this.getName());\n          controller.activateTool(this.getName());\n        }\n\n        if (!this.duringShowing) {\n          this.show(true);\n        }\n\n        this.pushPinInitData = data;\n        this.createMode = true;\n        this.enablePushPinSelect(false);\n      }\n\n      this.viewer.dispatchEvent({ type: PUSHPIN_EVENTS.PUSH_PIN_SELECTED_EVENT });\n    } }, { key: \"endCreateItem\", value: function endCreateItem()\n\n    {\n      this.pushPinInitData = null;\n\n      if (this.createMode) {\n        this.createMode = false;\n        this.enablePushPinSelect(true);\n      }\n    } }, { key: \"createThreePushPin\", value: function createThreePushPin(\n\n    event) {\n      var pushPin = null;\n      var clientX = event.canvasX;\n      var clientY = event.canvasY;\n      var result;\n      if (!this.pushPinManager.isPseudo2D) {\n        result = this.viewer.impl.clientToWorld(clientX, clientY);\n      } else {\n        result = {\n          point: this.viewer.impl.intersectGround(clientX, clientY) };\n\n      }\n\n      if (result && this.pushPinInitData) {var _result$model;\n        this.pushPinInitData.position = new THREE.Vector3(result.point.x, result.point.y, result.point.z);\n        invertModelTransform(this.pushPinInitData.position, result.model);\n        this.pushPinInitData.seedURN = (_result$model = result.model) === null || _result$model === void 0 ? void 0 : _result$model.getSeedUrn();\n\n        pushPin = this.pushPinManager.createItem(this.pushPinInitData);\n        // Clear pin pin init data, as it is a one time data for creating only one push pin.\n        this.pushPinInitData = null;\n      }\n\n      return pushPin;\n    } }, { key: \"createTwoPushPin\", value: function createTwoPushPin(\n\n    event) {\n      var pushPin = null;\n      var clientX = event.canvasX;\n      var clientY = event.canvasY;\n      var result = clientToWorld(this.viewer, clientX, clientY);\n\n      if (result && this.pushPinInitData) {\n        this.pushPinInitData.position = { x: result.x, y: result.y, z: result.z };\n\n        pushPin = this.pushPinManager.createItem(this.pushPinInitData);\n        // Clear pin pin init data, as it is a one time data for creating only one push pin.\n        this.pushPinInitData = null;\n      }\n\n      return pushPin;\n    } }, { key: \"createPushPin\", value: function createPushPin(\n\n    event) {\n      if (this.autoCreate && !this.pushPinInitData) {\n        // Fake push pin data for auto create.\n        this.pushPinInitData = { id: this.testId + '1', status: 'issues-open', type: 'issues' };\n      }\n\n      if (this.pushPinInitData) {\n        return this.pushPinManager.is2D ? this.createTwoPushPin(event) : this.createThreePushPin(event);\n      }\n\n      return false;\n    }\n\n    // Below is the standard input handler, so far only care about single click for creating push pins.\n  }, { key: \"handleSingleTap\", value: function handleSingleTap(event) {\n      PushPinTool.convertEventHammerToMouse(event);\n\n      return this.handleSingleClick(event, 0);\n    } }, { key: \"triggerPushpinClick\", value: function triggerPushpinClick(\n\n    item) {\n      this.pushPinManager.selectOne(item.data.id);\n      this.pushPinManager.fireEvent({\n        type: PUSHPIN_EVENTS.PUSH_PIN_CLICKED_EVENT,\n        value: this.pushPinManager.getSelectedItem() });\n\n    } }, { key: \"checkPushpinClick\", value: function checkPushpinClick(\n\n    event) {\n      return this.renderTool.findIntersections(event);\n    } }, { key: \"handleSingleClick\", value: function handleSingleClick(\n\n    event, button) {\n      var pressedItem = this.checkPushpinClick(event);\n      var triggered = false;\n\n      if (!this.createMode) {\n        // Trigger selection only when createMode is false\n        if (pressedItem) {\n          this.triggerPushpinClick(pressedItem);\n          triggered = true;\n        } else if (this.pushPinManager.selectedItem) {\n          this.pushPinManager.selectNone();\n          this.pushPinManager.fireEvent({ type: PUSHPIN_EVENTS.PUSH_PIN_SELECT_NONE, value: null });\n        }\n      }\n\n      if (this.isActive && button === 0) {\n        if (pressedItem) {\n          if (!triggered) {\n            this.triggerPushpinClick(pressedItem);\n          }\n        } else {\n          return this.createPushPin(event);\n        }\n      }\n\n      if (pressedItem) {\n        var self = this;\n        // Prevent from other listeners to be alerted for this current click.\n        // This is necessary for a scenario when there is a pushpin on top of a callout rectangle for example.\n        this.addDocumentEventListener('click',\n        function handler(e) {\n          e.stopPropagation();\n          self.removeDocumentEventListener('click', handler, true);\n        }, true);\n      }\n\n      return !!pressedItem;\n    } }, { key: \"handleMouseMove\", value: function handleMouseMove(\n\n    event) {\n      var hoveredItem = this.checkPushpinClick(event);\n\n      this.isHover = !!hoveredItem;\n\n      var isEditingPushpin = this.pushPinManager.selectedItem && this.pushPinManager.selectedItem.draggable;\n\n      // When we are in pushpin edit mode, we want to update the hover of the location only when we actively drag the pushpin.\n      // In case the pushpin is draggable, but not we just move the mouse without dragging - don't do anything.\n      if (!isEditingPushpin) {\n        this.pushPinManager.hoverLocations(event);\n      }\n\n      return false;\n    } }], [{ key: \"convertEventHammerToMouse\", value: function convertEventHammerToMouse(\n\n    event) {\n      // Convert Hammer touch-event X,Y into mouse-event X,Y.\n      event.shiftKey = false;\n      event.clientX = event.pointers[0].clientX;\n      event.clientY = event.pointers[0].clientY;\n    } }]);return PushPinTool;}();export { PushPinTool as default };\n\n\n\nav.GlobalManagerMixin.call(PushPinTool.prototype);\n\nvar namespace = AutodeskNamespace('Autodesk.BIM360.Extension.PushPin');\n\nnamespace.PushPinTool = PushPinTool;","function _typeof(obj) {\"@babel/helpers - typeof\";if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;};}return _typeof(obj);}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError(\"Cannot call a class as a function\");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}function _inherits(subClass, superClass) {if (typeof superClass !== \"function\" && superClass !== null) {throw new TypeError(\"Super expression must either be null or a function\");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}function _createSuper(Derived) {var hasNativeReflectConstruct = _isNativeReflectConstruct();return function _createSuperInternal() {var Super = _getPrototypeOf(Derived),result;if (hasNativeReflectConstruct) {var NewTarget = _getPrototypeOf(this).constructor;result = Reflect.construct(Super, arguments, NewTarget);} else {result = Super.apply(this, arguments);}return _possibleConstructorReturn(this, result);};}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");}return self;}function _isNativeReflectConstruct() {if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;if (Reflect.construct.sham) return false;if (typeof Proxy === \"function\") return true;try {Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));return true;} catch (e) {return false;}}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}import PushPinVisButton from '../PushPinUi/PushPinVisButtonBase';var\n\nIssuePushPinVisButton = /*#__PURE__*/function (_PushPinVisButton) {_inherits(IssuePushPinVisButton, _PushPinVisButton);var _super = _createSuper(IssuePushPinVisButton);\n  function IssuePushPinVisButton(viewer, extension, initiallyHidePushpins) {var _this;_classCallCheck(this, IssuePushPinVisButton);\n    _this = _super.call(this, viewer, extension, initiallyHidePushpins);\n    _this.viewer = viewer;\n    _this.extension = extension;\n    _this.pushpinVisBtn = null;\n\n    _this.setButtonConstants();return _this;\n  }_createClass(IssuePushPinVisButton, [{ key: \"setButtonConstants\", value: function setButtonConstants()\n\n    {\n      this.buttonConstants = {\n        btnClass: 'toolbar-pushpinVis',\n        btnLabel: 'Show all pushpins',\n        noPushpinLabel: 'No issue in current doc',\n        hidePushpinLabel: 'Hide all issues',\n        showPushpinLabel: 'Show all issues',\n        pushpinNormalIcon: 'issueicon-issue_normal',\n        pushpinHideIcon: 'issueicon-issue_hide' };\n\n\n      this.type = this.extension.pushPinManager.PushPinTypes.ISSUES;\n    } }]);return IssuePushPinVisButton;}(PushPinVisButton);export { IssuePushPinVisButton as default };","function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError(\"Cannot call a class as a function\");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}import { PUSHPIN_EVENTS } from '../PushPinEvents';\n\nvar av = Autodesk.Viewing;var\n\nPushPinVisButton = /*#__PURE__*/function () {\n  function PushPinVisButton(viewer, extension, initiallyHidePushpins) {_classCallCheck(this, PushPinVisButton);\n    this.viewer = viewer;\n    this.setGlobalManager(viewer.globalManager);\n    this.extension = extension;\n    this.pushpinVisBtn = null;\n    this.initiallyHidePushpins = initiallyHidePushpins;\n\n    this.setButtonConstants();\n  }_createClass(PushPinVisButton, [{ key: \"setButtonConstants\", value: function setButtonConstants()\n\n    {\n      this.buttonConstants = {\n        btnClass: '',\n        btnLabel: '',\n        noPushpinLabel: '',\n        hidePushpinLabel: '',\n        showPushpinLabel: '',\n        pushpinNormalIcon: '',\n        pushpinHideIcon: '' };\n\n\n      this.type = '';\n    } }, { key: \"createButton\", value: function createButton()\n\n\n\n\n\n    {\n      var btn = new Autodesk.Viewing.UI.Button(this.buttonConstants.btnClass);\n      btn.setGlobalManager(this.globalManager);\n\n      btn.setToolTip(Autodesk.Viewing.i18n.translate(this.buttonConstants.btnLabel));\n      btn.setIcon(this.buttonConstants.pushpinNormalIcon);\n\n      btn.onClick = function () {\n        var state = btn.getState();\n        if (state === Autodesk.Viewing.UI.Button.State.DISABLED) {\n          return;\n        }\n\n        btn.setState(state === Autodesk.Viewing.UI.Button.State.INACTIVE ? Autodesk.Viewing.UI.Button.State.ACTIVE : Autodesk.Viewing.UI.Button.State.INACTIVE);\n      };\n\n      return btn;\n    } }, { key: \"onPushpinVisBtnStateChange\", value: function onPushpinVisBtnStateChange(\n\n    e) {\n      if (e.state === Autodesk.Viewing.UI.Button.State.DISABLED) {\n        this.pushpinVisBtn.setToolTip(Autodesk.Viewing.i18n.translate(this.buttonConstants.noPushpinLabel));\n        return;\n      }\n\n      var showAll = e.state === Autodesk.Viewing.UI.Button.State.ACTIVE && !this.initiallyHidePushpins;\n      if (this.initiallyHidePushpins) {\n        this.pushpinVisBtn.setState(Autodesk.Viewing.UI.Button.State.INACTIVE);\n        this.initiallyHidePushpins = false;\n      }\n\n      // Toggle the vis button\n      if (showAll) {\n        this.extension.tool.show(true);\n        this.extension.showByType(this.type);\n        this.pushpinVisBtn.setToolTip(Autodesk.Viewing.i18n.translate(this.buttonConstants.hidePushpinLabel));\n        this.pushpinVisBtn.setIcon(this.buttonConstants.pushpinNormalIcon);\n      } else {\n        this.extension.hideByType(this.type);\n        this.pushpinVisBtn.setToolTip(Autodesk.Viewing.i18n.translate(this.buttonConstants.showPushpinLabel));\n        this.pushpinVisBtn.setIcon(this.buttonConstants.pushpinHideIcon);\n      }\n    } }, { key: \"addButton\", value: function addButton()\n\n    {var _this = this;\n      if (this.pushpinVisBtn || !this.viewer.getToolbar) {\n        return;\n      }\n\n      var toolbar = this.viewer.getToolbar();\n\n      if (!toolbar) {\n        return;\n      }\n\n      var modelTools = toolbar.getControl(Autodesk.Viewing.TOOLBAR.MODELTOOLSID);\n\n      if (!modelTools) {\n        // insert model tool below navgiation tool\n        var navigationBar = toolbar.getControl(Autodesk.Viewing.TOOLBAR.NAVTOOLSID);\n        var toolbarOptions = {};\n\n        toolbarOptions.index = navigationBar ? toolbar.indexOf(navigationBar) + 1 : 0;\n\n        modelTools = new Autodesk.Viewing.UI.ControlGroup(Autodesk.Viewing.TOOLBAR.MODELTOOLSID);\n        modelTools.setGlobalManager(this.globalManager);\n        toolbar.addControl(modelTools, toolbarOptions);\n      }\n\n      this.pushpinVisBtn = this.createButton();\n\n      // Add button to the toolbar\n      this.pushpinVisBtn.addEventListener(Autodesk.Viewing.UI.Button.Event.STATE_CHANGED, function (e) {\n        _this.onPushpinVisBtnStateChange(e);\n      });\n      this.updateButtonStatus();\n      modelTools.addControl(this.pushpinVisBtn);\n\n      // add event listener to update visual button status\n      this.extension.pushPinManager.addEventListener(PUSHPIN_EVENTS.PUSH_PIN_REMOVED_EVENT, function () {\n        _this.updateButtonStatus();\n      });\n      this.extension.pushPinManager.addEventListener(PUSHPIN_EVENTS.PUSH_PIN_REMOVE_ALL_EVENT, function () {\n        _this.updateButtonStatus();\n      });\n      this.extension.pushPinManager.addEventListener(PUSHPIN_EVENTS.PUSH_PIN_CREATED_EVENT, function () {\n        _this.updateButtonStatus();\n      });\n      this.extension.pushPinManager.addEventListener(PUSHPIN_EVENTS.PUSH_PIN_ITEMS_LOADED, function () {\n        _this.updateButtonStatus();\n      });\n      this.extension.pushPinManager.addEventListener(PUSHPIN_EVENTS.PUSH_PIN_PREPARING_THUMBNAIL, function () {\n        _this.updateButtonStatus();\n      });\n      this.extension.pushPinManager.addEventListener(PUSHPIN_EVENTS.PUSH_PIN_ITEMS_LOADED, function () {\n        _this.updateButtonStatus();\n      });\n    } }, { key: \"updateButtonStatus\", value: function updateButtonStatus()\n\n    {\n      if (!this.pushpinVisBtn) {\n        return;\n      }\n\n      // during push pin is creating, show all push pins and disable show/hide button\n      if (this.extension.tool.createMode) {\n        if (this.pushpinVisBtn.getState() !== Autodesk.Viewing.UI.Button.State.DISABLED) {\n          this.pushpinVisBtn.setState(Autodesk.Viewing.UI.Button.State.DISABLED);\n        }\n      } else {\n        var issuePushpinCount = this.extension.pushPinManager.getItemCountByType(this.type);\n        var issueButtonDisable = this.pushpinVisBtn.getState() === Autodesk.Viewing.UI.Button.State.DISABLED;\n\n        if (issuePushpinCount > 0 && issueButtonDisable) {\n          this.pushpinVisBtn.setState(Autodesk.Viewing.UI.Button.State.ACTIVE);\n        } else if (issuePushpinCount === 0 && !issueButtonDisable) {\n          this.pushpinVisBtn.setState(Autodesk.Viewing.UI.Button.State.DISABLED);\n        }\n      }\n    } }, { key: \"destroyButton\", value: function destroyButton()\n\n    {\n      if (!this.pushpinVisBtn) {\n        return;\n      }\n\n      this.extension.pushPinManager.removeEventListener(PUSHPIN_EVENTS.PUSH_PIN_REMOVED_EVENT, this.updateButtonStatus);\n      this.extension.pushPinManager.removeEventListener(PUSHPIN_EVENTS.PUSH_PIN_REMOVE_ALL_EVENT, this.updateButtonStatus);\n      this.extension.pushPinManager.removeEventListener(PUSHPIN_EVENTS.PUSH_PIN_CREATED_EVENT, this.updateButtonStatus);\n\n      var toolbar = this.viewer.getToolbar();\n\n      if (toolbar) {\n        this.pushpinVisBtn.removeFromParent();\n      }\n\n      this.pushpinVisBtn.removeEventListener(Autodesk.Viewing.UI.Button.Event.STATE_CHANGED, this.onPushpinVisBtnStateChange);\n      this.pushpinVisBtn = null;\n    } }, { key: \"pushPinButton\", get: function get() {return this.pushpinVisBtn;} }]);return PushPinVisButton;}();export { PushPinVisButton as default };\n\n\nav.GlobalManagerMixin.call(PushPinVisButton.prototype);","function _typeof(obj) {\"@babel/helpers - typeof\";if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;};}return _typeof(obj);}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError(\"Cannot call a class as a function\");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}function _inherits(subClass, superClass) {if (typeof superClass !== \"function\" && superClass !== null) {throw new TypeError(\"Super expression must either be null or a function\");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}function _createSuper(Derived) {var hasNativeReflectConstruct = _isNativeReflectConstruct();return function _createSuperInternal() {var Super = _getPrototypeOf(Derived),result;if (hasNativeReflectConstruct) {var NewTarget = _getPrototypeOf(this).constructor;result = Reflect.construct(Super, arguments, NewTarget);} else {result = Super.apply(this, arguments);}return _possibleConstructorReturn(this, result);};}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");}return self;}function _isNativeReflectConstruct() {if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;if (Reflect.construct.sham) return false;if (typeof Proxy === \"function\") return true;try {Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));return true;} catch (e) {return false;}}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}import PushPinVisButton from '../PushPinUi/PushPinVisButtonBase';var\n\nQualityIssuePushPinVisButton = /*#__PURE__*/function (_PushPinVisButton) {_inherits(QualityIssuePushPinVisButton, _PushPinVisButton);var _super = _createSuper(QualityIssuePushPinVisButton);\n  function QualityIssuePushPinVisButton(viewer, extension, initiallyHidePushpins) {var _this;_classCallCheck(this, QualityIssuePushPinVisButton);\n    _this = _super.call(this, viewer, extension, initiallyHidePushpins);\n    _this.viewer = viewer;\n    _this.extension = extension;\n    _this.pushpinVisBtn = null;\n\n    _this.setButtonConstants();return _this;\n  }_createClass(QualityIssuePushPinVisButton, [{ key: \"setButtonConstants\", value: function setButtonConstants()\n\n    {\n      this.buttonConstants = {\n        btnClass: 'toolbar-pushpinFieldIssuesVis',\n        btnLabel: 'Show all field pushpins',\n        noPushpinLabel: 'No field issue in current doc',\n        hidePushpinLabel: 'Hide all field issues',\n        showPushpinLabel: 'Show all field issues',\n        pushpinNormalIcon: 'fieldissueicon-issue_normal',\n        pushpinHideIcon: 'fieldissueicon-issue_hide' };\n\n\n      this.type = this.extension.pushPinManager.PushPinTypes.QUALITY_ISSUES;\n    } }]);return QualityIssuePushPinVisButton;}(PushPinVisButton);export { QualityIssuePushPinVisButton as default };","function _typeof(obj) {\"@babel/helpers - typeof\";if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;};}return _typeof(obj);}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError(\"Cannot call a class as a function\");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}function _inherits(subClass, superClass) {if (typeof superClass !== \"function\" && superClass !== null) {throw new TypeError(\"Super expression must either be null or a function\");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}function _createSuper(Derived) {var hasNativeReflectConstruct = _isNativeReflectConstruct();return function _createSuperInternal() {var Super = _getPrototypeOf(Derived),result;if (hasNativeReflectConstruct) {var NewTarget = _getPrototypeOf(this).constructor;result = Reflect.construct(Super, arguments, NewTarget);} else {result = Super.apply(this, arguments);}return _possibleConstructorReturn(this, result);};}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");}return self;}function _isNativeReflectConstruct() {if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;if (Reflect.construct.sham) return false;if (typeof Proxy === \"function\") return true;try {Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));return true;} catch (e) {return false;}}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}import PushPinVisButton from '../PushPinUi/PushPinVisButtonBase';var\n\nRfiPushPinVisButton = /*#__PURE__*/function (_PushPinVisButton) {_inherits(RfiPushPinVisButton, _PushPinVisButton);var _super = _createSuper(RfiPushPinVisButton);\n  function RfiPushPinVisButton(viewer, extension, initiallyHidePushpins) {var _this;_classCallCheck(this, RfiPushPinVisButton);\n    _this = _super.call(this, viewer, extension, initiallyHidePushpins);\n    _this.viewer = viewer;\n    _this.extension = extension;\n    _this.pushpinVisBtn = null;\n\n    _this.setButtonConstants();return _this;\n  }_createClass(RfiPushPinVisButton, [{ key: \"setButtonConstants\", value: function setButtonConstants()\n\n    {\n      this.buttonConstants = {\n        btnClass: 'toolbar-pushpinRfisVis',\n        btnLabel: 'Show all rfis',\n        noPushpinLabel: 'No RFI in current doc',\n        hidePushpinLabel: 'Hide all RFIs',\n        showPushpinLabel: 'Show all RFIs',\n        pushpinNormalIcon: 'rfiicon-rfi_normal',\n        pushpinHideIcon: 'rfiicon-rfi_hide' };\n\n\n      this.type = this.extension.pushPinManager.PushPinTypes.RFIS;\n    } }]);return RfiPushPinVisButton;}(PushPinVisButton);export { RfiPushPinVisButton as default };","// Compute the max level from leaflet max resolution texture.\nfunction computeMaxLevel(w, h) {\n  // compute maxLevel that we would get for 1x1 resolution at level 0\n  var lx = Math.ceil(Math.log2(w));\n  var ly = Math.ceil(Math.log2(h));\n  var maxLevel = Math.max(lx, ly);\n\n  // since the actual root tile has tileSize x tileSize, we subtract the skipped levels.\n  return maxLevel;\n}\n\nexport function clientToWorldLeaflet(viewer, x, y) {\n  var loadOptions;\n  var bounds;\n\n  if (viewer.model.isPdf(true)) {\n    loadOptions = Autodesk.Viewing.PDFUtils.getLeafletLoadOptions(viewer);\n    bounds = Autodesk.Viewing.PDFUtils.getLeafletBoundingBox(viewer);\n  } else {\n    var modelData = viewer.model.getData();\n    loadOptions = modelData.loadOptions.loadOptions;\n    bounds = modelData.bbox;\n  }var _loadOptions =\n\n  loadOptions,texWidth = _loadOptions.texWidth,texHeight = _loadOptions.texHeight;\n\n  var worldPos = viewer.clientToWorld(x, y, undefined, true).point;\n  var worldTopLeft = new THREE.Vector3(bounds.min.x, bounds.max.y, 0);\n\n  worldPos.sub(worldTopLeft);\n  var newX = worldPos.x * texWidth / bounds.size().x;\n  var newY = worldPos.y * texHeight / bounds.size().y;\n\n  var point = new THREE.Vector3(newX, newY, 0);\n\n  var maxLevel = computeMaxLevel(texWidth, texHeight);\n  var scale = Math.pow(2, maxLevel);\n\n  var px = point.x / scale;\n  var py = point.y / scale;\n\n  // x & y are swapped for some reason. Can't change it now for backward compatibility.\n  return new THREE.Vector3(py, px, 0);\n}\n\nexport function clientToWorld(viewer, x, y) {\n  if (viewer.model.isLeaflet()) {\n    return clientToWorldLeaflet(viewer, x, y);\n  } else {\n    return viewer.clientToWorld(x, y, undefined, true).point;\n  }\n};\n\nexport function applyPdfWorldScaling(viewer, itemData) {\n  if (viewer.model.isLeaflet() || viewer.model.isPdf(true)) {\n    var originalDocumentResolution = itemData.viewerState && itemData.viewerState.originalDocumentResolution;\n\n    // In case of leaflet - it changes to world coordinates.\n    var clientPos = worldToClient(viewer, itemData.position, originalDocumentResolution);\n    var worldPos = viewer.clientToWorld(clientPos.x, clientPos.y, undefined, true).point;\n    return worldPos;\n  } else {\n    return itemData.position;\n  }\n}\n\nexport function worldToClient(viewer, point, originalDocumentResolution) {\n  if (!viewer.model.isLeaflet() && !viewer.model.isPdf(true)) {\n    return viewer.worldToClient(point);\n  }\n\n  var x = point.y;\n  var y = point.x;\n\n  var loadOptions;\n  var bounds;\n\n  if (viewer.model.isPdf(true)) {\n    loadOptions = Autodesk.Viewing.PDFUtils.getLeafletLoadOptions(viewer);\n    bounds = Autodesk.Viewing.PDFUtils.getLeafletBoundingBox(viewer);\n  } else {\n    var modelData = viewer.model.getData();\n    loadOptions = modelData.loadOptions.loadOptions;\n    bounds = modelData.bbox;\n  }var _loadOptions2 =\n\n  loadOptions,texWidth = _loadOptions2.texWidth,texHeight = _loadOptions2.texHeight;\n\n  var maxLevel = computeMaxLevel(texWidth, texHeight);\n  var scale = Math.pow(2, maxLevel);\n  x *= scale;\n  y *= scale;\n\n  // https://jira.autodesk.com/browse/BLMV-2853\n  // In case that the DPI of the current document is different than the DPI of the document where the pushpin has originally created (or edited)\n  // We need to scale the ratio back in order that the pushpin will appear in the same place.\n  var originalDocumentWidth = originalDocumentResolution && originalDocumentResolution[0] || texWidth;\n  var dpiCorrection = texWidth / originalDocumentWidth;\n\n  var wx = x / (texWidth / dpiCorrection) * bounds.size().x;\n  var wy = y / (texHeight / dpiCorrection) * bounds.size().y;\n\n  var worldPos = new THREE.Vector3(bounds.min.x + wx, bounds.max.y + wy, 0);\n\n  if (viewer.model.isPdf(true)) {\n    Autodesk.Viewing.PDFUtils.leafletToPdfWorld(viewer, worldPos);\n  }\n\n  return viewer.impl.worldToClient(worldPos);\n}\n\n// Used for saving pushpins in the backend like they were created in Leaflet, instead of PDF.\nexport function convertPdfToLeaflet(viewer, itemData) {\n  var p = Autodesk.Viewing.PDFUtils.pdfToLeafletWorld(viewer, new THREE.Vector3().copy(itemData.position));\n  itemData.position = { x: p.y - 1, y: p.x, z: 0 }; // x & y are swapped for some reason. Can't change it now for backward compatibility.\n}\n\nexport function applyModelTransform(point, model) {\n  var modelTransform = model === null || model === void 0 ? void 0 : model.getModelTransform();\n\n  if (modelTransform) {\n    point.applyMatrix4(modelTransform);\n  }\n}\n\nexport function invertModelTransform(point, model) {\n  var modelTransform = model === null || model === void 0 ? void 0 : model.getModelTransform();\n\n  if (modelTransform) {\n    point.applyMatrix4(new THREE.Matrix4().getInverse(modelTransform));\n  }\n}","function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError(\"Cannot call a class as a function\");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}import PushPinBillboardLabel from '../PushPinLabel/PushPinBillboardLabel';\nimport { applyPdfWorldScaling } from '../PushPinUtils';\nimport { statusHexValues, moveableIcon, markerOffsets, ATTRIBUTES_VERSION } from '../PushPinConstants';\n\nvar av = Autodesk.Viewing;var\n\nPushPinBillboardTool2D = /*#__PURE__*/function () {\n  function PushPinBillboardTool2D(viewer) {_classCallCheck(this, PushPinBillboardTool2D);\n    this.names = ['pushpinBillboard2D'];\n\n    this.viewer = viewer;\n    this.setGlobalManager(viewer.globalManager);\n    this.active = false;\n\n    this.pushpins = [];\n    this.selectedPushpin = null;\n    this.dirty = false;\n    this.camera = this.viewer.navigation.getCamera();\n    this.curCameraZ = 0;\n    this.curCameraRotationZ = 0;\n\n    this.tmpVec = new THREE.Vector3();\n    this.tmpMatrix = new THREE.Matrix4();\n  }_createClass(PushPinBillboardTool2D, [{ key: \"getNames\", value: function getNames()\n\n    {\n      return this.names;\n    } }, { key: \"getName\", value: function getName()\n\n    {\n      return this.names[0];\n    } }, { key: \"isActive\", value: function isActive()\n\n    {\n      return this.active;\n    } }, { key: \"activate\", value: function activate(\n\n    name) {var _this = this;\n      if (name === this.getName()) {\n        this.active = true;\n\n        this.onCameraChangeBinded = function (e) {return _this.onCameraChange(e);};\n        this.handleResizeBinded = function (e) {return _this.handleResize(e);};\n\n        this.viewer.addEventListener(Autodesk.Viewing.CAMERA_CHANGE_EVENT, this.onCameraChangeBinded);\n        this.viewer.addEventListener(Autodesk.Viewing.VIEWER_RESIZE_EVENT, this.handleResizeBinded);\n\n        this.createMarkerContainer();\n      }\n    } }, { key: \"deactivate\", value: function deactivate(\n\n    name) {\n      if (name === this.getName()) {\n        this.active = false;\n\n        this.viewer.removeEventListener(Autodesk.Viewing.CAMERA_CHANGE_EVENT, this.onCameraChangeBinded);\n        this.viewer.removeEventListener(Autodesk.Viewing.VIEWER_RESIZE_EVENT, this.handleResizeBinded);\n      }\n    } }, { key: \"onCameraChange\", value: function onCameraChange(\n\n    e) {\n      if (e.camera.position.z.toPrecision(5) !== this.curCameraZ.toPrecision(5) || e.camera.rotation.z.toPrecision(5) !== this.curCameraRotationZ.toPrecision(5)) {\n        this.updatePushpinsProjection();\n        this.curCameraZ = e.camera.position.z;\n        this.curCameraRotationZ = e.camera.rotation.z;\n      } else {\n        this.updateContainerProjection();\n      }\n    } }, { key: \"createMarkerContainer\", value: function createMarkerContainer()\n\n    {\n      if (!this.pushpinContainer) {\n        this.pushpinContainer = this.viewer.appendOrderedElementToViewer('pushpin-container');\n        this.pushpinContainer.className = 'pushpin-container';\n        this.pushpinContainer.position = new THREE.Vector3();\n      }\n    } }, { key: \"project\", value: function project(\n\n    pushpin) {\n      var position = pushpin.marker.intersectPoint;\n      var containerBounds = this.viewer.navigation.getScreenViewport();\n      var p = this.tmpVec.copy(position);\n\n      this.tmpMatrix.multiplyMatrices(this.camera.projectionMatrix, this.camera.matrixWorldInverse);\n\n      p.applyProjection(this.tmpMatrix);\n\n      return new THREE.Vector3(\n      Math.round((p.x + 1) / 2 * containerBounds.width),\n      Math.round((-p.y + 1) / 2 * containerBounds.height),\n      p.z);\n\n    } }, { key: \"unproject\", value: function unproject(\n\n    position) {\n      var containerBounds = this.viewer.navigation.getScreenViewport();\n      var p = new THREE.Vector3();\n\n      p.x = position.x / containerBounds.width * 2 - 1;\n      p.y = -(position.y / containerBounds.height * 2 - 1);\n      p.z = position.z;\n      p.unproject(this.camera);\n\n      return p;\n    } }, { key: \"initNewPushpin\", value: function initNewPushpin(\n\n    item) {\n      if (this.viewer.model.isLeaflet()) {\n        this.convertLeafletPosition(item);\n\n        // https://jira.autodesk.com/browse/BLMV-2918\n        // Update originalDocumentResolution when saving / updating a pushpin, in order to make sure that the pushpin will\n        // maintain the same position for different DPIs of the same document.\n        var modelData = this.viewer.model.getData();\n        var options = modelData.loadOptions.loadOptions;\n        item.setOriginalDocumentResolution([options.texWidth, options.texHeight]);\n      } else {\n        item.intersectPoint = item.data.position;\n      }\n\n      this.pushpins.push(item);\n\n      this.createMarker(item);\n\n      item.draggable ? this.enableDragging(item) : this.disableDragging(item);\n      item.visible ? this.showMarker(item.marker) : this.hideMarker(item.marker);\n    } }, { key: \"createPushpin\", value: function createPushpin(\n\n    item) {\n      item.data.attributesVersion = ATTRIBUTES_VERSION;\n\n      this.initNewPushpin(item);\n      this.selectPushpin(item);\n\n      return Promise.resolve();\n    } }, { key: \"convertLeafletPosition\", value: function convertLeafletPosition(\n\n    item) {\n      var worldPos = applyPdfWorldScaling(this.viewer, item.data);\n      item.intersectPoint = { x: worldPos.x, y: worldPos.y, z: worldPos.z };\n    } }, { key: \"loadPushpin\", value: function loadPushpin(\n\n    item) {\n      this.initNewPushpin(item);\n\n      return Promise.resolve();\n    } }, { key: \"createMarker\", value: function createMarker(\n\n    pushpin) {\n      var _document = this.getDocument();\n      var marker = _document.createElement('div');\n\n      var className = pushpin.data.type === 'rfis' ? 'rfi-billboard-marker' : 'pushpin-billboard-marker';\n\n      marker.classList.add(className);\n      marker.style.backgroundColor = statusHexValues[pushpin.data.status];\n      marker.style.boxShadow = '0px 1px 6px rgba(0, 0, 0, 0.6)';\n\n      this.pushpinContainer.appendChild(marker);\n\n      marker.id = pushpin.data.id;\n      marker.intersectPoint = pushpin.intersectPoint;\n\n      pushpin.marker = marker;\n      this.setMarkerPosition(pushpin);\n\n      // first pushpin\n      if (this.pushpins.length === 1) {\n        this.setPushpinContainerPosition(pushpin);\n      } else {\n        var newPosX = pushpin.marker.position.x - this.pushpinContainer.position.x;\n        var newPosY = pushpin.marker.position.y - this.pushpinContainer.position.y;\n        pushpin.marker.style.transform = \"translate(\".concat(newPosX, \"px, \").concat(newPosY, \"px)\");\n      }\n    } }, { key: \"removePushpin\", value: function removePushpin(\n\n    pushpin) {var _this2 = this;\n      this.pushpins = this.pushpins.filter(function (curPushpin) {\n        if (_this2.selectedPushpin && _this2.selectedPushpin.data.id === pushpin.data.id) {\n          _this2.selectedPushpin = null;\n        }\n\n        return curPushpin.data.id !== pushpin.data.id;\n      });\n\n      this.destroyMarker(pushpin);\n    } }, { key: \"removeAll\", value: function removeAll()\n\n    {var _this3 = this;\n      this.pushpins.forEach(function (pushpin) {\n        _this3.removePushpin(pushpin);\n      });\n    } }, { key: \"destroyMarker\", value: function destroyMarker(\n\n    pushpin) {\n      this.destroyLabel(pushpin);\n      this.pushpinContainer.removeChild(pushpin.marker);\n      pushpin.marker = undefined;\n    } }, { key: \"destroyLabel\", value: function destroyLabel(\n\n    pushpin) {\n      if (pushpin.label) {\n        pushpin.marker.removeChild(pushpin.label.container);\n        pushpin.label = undefined;\n      }\n    } }, { key: \"setPushpinContainerPosition\", value: function setPushpinContainerPosition(\n\n    pushpin) {\n      var xTranslate = pushpin.marker.position.x - markerOffsets.markerOffsetWidth / 2;\n      var yTranslate = pushpin.marker.position.y - markerOffsets.markerOffsetWidth / 2;\n\n      this.pushpinContainer.initPos = pushpin.intersectPoint;\n      this.pushpinContainer.position.x = pushpin.marker.position.x;\n      this.pushpinContainer.position.y = pushpin.marker.position.y;\n      this.pushpinContainer.style.transform = \"translate(\".concat(xTranslate, \"px, \").concat(yTranslate, \"px)\");\n    } }, { key: \"setMarkerPosition\", value: function setMarkerPosition(\n\n    pushpin) {\n      pushpin.marker.position = this.project(pushpin);\n    } }, { key: \"updateStyle\", value: function updateStyle(\n\n    status, size, hex) {\n      statusHexValues[status] = hex;\n      this.dirty = true;\n    } }, { key: \"updateContainerProjection\", value: function updateContainerProjection()\n\n    {var _this4 = this;\n      if (this.pushpins.length > 0) {\n        var newPosition = { marker: { intersectPoint: this.pushpinContainer.initPos } };\n        var updatedPosition = this.pushpinContainer.position = this.project(newPosition);\n        var offsetWidth = markerOffsets.markerOffsetWidth;\n\n        var xTranslate = updatedPosition.x - offsetWidth / 2;\n        var yTranslate = updatedPosition.y - offsetWidth / 2;\n\n        this.pushpinContainer.style.transform = \"translate(\".concat(xTranslate, \"px, \").concat(yTranslate, \"px)\");\n      }\n\n      // Update the DOM\n      this.pushpins.forEach(function (pushpin) {\n        _this4.updatePushpin(pushpin);\n      });\n\n      this.dirty = false;\n    } }, { key: \"updatePushpinsProjection\", value: function updatePushpinsProjection()\n\n    {var _this5 = this;\n      this.redraw = true;\n      this.pushpins.forEach(function (pushpin) {\n        _this5.setMarkerPosition(pushpin);\n      });\n\n      this.pushpins.forEach(function (pushpin) {\n        if (_this5.redraw) {\n          _this5.setPushpinContainerPosition(pushpin);\n          _this5.redraw = false;\n        }\n\n        var xPos = pushpin.marker.position.x - _this5.pushpinContainer.position.x;\n        var yPos = pushpin.marker.position.y - _this5.pushpinContainer.position.y;\n        pushpin.marker.style.transform = \"translate(\".concat(xPos, \"px, \").concat(yPos, \"px)\");\n\n        _this5.updatePushpin(pushpin);\n      });\n\n      this.dirty = false;\n    } }, { key: \"updatePushpin\", value: function updatePushpin(\n\n    pushpin) {\n      if (this.dirty) {\n        if (pushpin.label) {\n          pushpin.label.update(pushpin.data.label);\n        }\n\n        pushpin.draggable ? this.enableDragging(pushpin) : this.disableDragging(pushpin);\n        pushpin.marker.style.backgroundColor = statusHexValues[pushpin.data.status];\n        pushpin.visible ? this.showMarker(pushpin.marker) : this.hideMarker(pushpin.marker);\n      }\n    } }, { key: \"setDirty\", value: function setDirty()\n\n    {\n      this.dirty = true;\n    } }, { key: \"selectPushpin\", value: function selectPushpin(\n\n    pushpin) {\n      this.deselect();\n      this.viewer.clearSelection();\n\n      pushpin.label = new PushPinBillboardLabel(pushpin.marker, pushpin.data.label);\n      pushpin.marker.classList.add('selected');\n\n      this.selectedPushpin = pushpin;\n      pushpin.draggable ? this.enableDragging(pushpin) : this.disableDragging(pushpin);\n    } }, { key: \"deselect\", value: function deselect()\n\n    {\n      if (this.selectedPushpin) {\n        this.destroyLabel(this.selectedPushpin);\n        this.selectedPushpin.marker.style.pointerEvents = 'none';\n        this.selectedPushpin.marker.classList.remove('selected');\n        this.selectedPushpin = null;\n      }\n    } }, { key: \"enableDragging\", value: function enableDragging(\n\n    item) {\n      if (this.selectedPushpin && this.selectedPushpin.data.id === item.data.id) {\n        item.marker.style.pointerEvents = 'auto';\n      }\n\n      item.marker.style.backgroundImage = moveableIcon;\n    } }, { key: \"disableDragging\", value: function disableDragging(\n\n    item) {\n      var selectedItem = item || this.selectedPushpin;\n\n      selectedItem.marker.style.pointerEvents = 'none';\n      selectedItem.marker.style.backgroundImage = 'none';\n      selectedItem.draggable = false;\n    } }, { key: \"showMarker\", value: function showMarker(\n\n    marker) {\n      marker.style.display = '';\n    } }, { key: \"hideMarker\", value: function hideMarker(\n\n    marker) {\n      marker.style.display = 'none';\n    } }, { key: \"showMarkers\", value: function showMarkers()\n\n    {var _this6 = this;\n      this.pushpins.forEach(function (pushpin) {\n        pushpin.visible ? _this6.showMarker(pushpin.marker) : _this6.hideMarker(pushpin.marker);\n      });\n    } }, { key: \"hideMarkers\", value: function hideMarkers()\n\n    {var _this7 = this;\n      this.pushpins.forEach(function (pushpin) {\n        _this7.hideMarker(pushpin.marker);\n      });\n\n      if (this.selectedPushpin) {\n        this.destroyLabel(this.selectedPushpin);\n      }\n    } }, { key: \"handleButtonDown\", value: function handleButtonDown(\n\n\n    event, button) {\n      return false;\n    } }, { key: \"handleButtonUp\", value: function handleButtonUp(\n\n    event, button) {\n      return false;\n    } }, { key: \"handleResize\", value: function handleResize()\n\n    {var _this8 = this;\n      setTimeout(function () {\n        _this8.updatePushpinsProjection();\n      }, 1);\n    } }]);return PushPinBillboardTool2D;}();export { PushPinBillboardTool2D as default };\n\n\nav.GlobalManagerMixin.call(PushPinBillboardTool2D.prototype);\nvar namespace = AutodeskNamespace('Autodesk.BIM360.Extension.PushPin');\n\nnamespace.PushPinBillboardTool2D = PushPinBillboardTool2D;","function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError(\"Cannot call a class as a function\");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}import PushPinBillboardTool2D from '../PushPins2D/PushPinBillboardTool2D';\nimport PushPinInputHandler from '../PushPinInputHandler';\nimport { clientToWorld, convertPdfToLeaflet } from '../PushPinUtils';\nimport { PUSHPIN_EVENTS } from '../PushPinEvents';\n\nvar av = Autodesk.Viewing;var\n\nRenderHandler2D = /*#__PURE__*/function () {\n  function RenderHandler2D(viewerApi, pushPinManager) {var _this = this;_classCallCheck(this, RenderHandler2D);\n    this.viewer = viewerApi;\n    this.setGlobalManager(this.viewer.globalManager);\n    this.pushPinManager = pushPinManager;\n    this.pushpinDirty = false;\n    this.selectedItem = null;\n\n    this.onSelectedChangedBind = function (e) {return _this.onSelectedChanged(e);};\n    this.onRemoveBind = function (e) {return _this.onRemove(e);};\n    this.onRemoveAllBind = function (e) {return _this.onRemoveAll(e);};\n    this.onModifyBind = function (e) {return _this.onModify(e);};\n    this.onUpdateBind = function (e) {return _this.onUpdate(e);};\n    this.createBind = function (e) {return _this.create(e);};\n    this.onVisibilityChangedBind = function (e) {return _this.onVisibilityChanged(e);};\n  }_createClass(RenderHandler2D, [{ key: \"register\", value: function register()\n\n    {\n      this.pushpinBillboardTool = new PushPinBillboardTool2D(this.viewer);\n      this.viewer.toolController.registerTool(this.pushpinBillboardTool);\n    } }, { key: \"deregister\", value: function deregister()\n\n    {\n      if (this.pushpinBillboardTool) {\n        this.viewer.toolController.deregisterTool(this.pushpinBillboardTool);\n        this.pushpinBillboardTool = null;\n      }\n    } }, { key: \"activate\", value: function activate()\n\n    {\n      if (!this.pushpinBillboardTool.isActive()) {\n        this.viewer.toolController.activateTool('pushpinBillboard2D');\n      }\n\n      this.inputHandler = new PushPinInputHandler(this);\n\n      this.pushPinManager.addEventListener(PUSHPIN_EVENTS.PUSH_PIN_SELECTED_EVENT, this.onSelectedChangedBind);\n      this.pushPinManager.addEventListener(PUSHPIN_EVENTS.PUSH_PIN_REMOVED_EVENT, this.onRemoveBind);\n      this.pushPinManager.addEventListener(PUSHPIN_EVENTS.PUSH_PIN_REMOVE_ALL_EVENT, this.onRemoveAllBind);\n      this.pushPinManager.addEventListener(PUSHPIN_EVENTS.PUSH_PIN_MODIFY_EVENT, this.onModifyBind);\n      this.pushPinManager.addEventListener(PUSHPIN_EVENTS.PUSH_PIN_UPDATE_EVENT, this.onUpdateBind);\n      this.pushPinManager.addEventListener(PUSHPIN_EVENTS.PUSH_PIN_VISIBILITY_EVENT, this.onVisibilityChangedBind);\n      this.pushPinManager.setCreateFunction(this.createBind);\n\n      return true;\n    } }, { key: \"deactivate\", value: function deactivate()\n\n    {\n      if (this.pushpinBillboardTool.isActive()) {\n        this.viewer.toolController.deactivateTool('pushpinBillboard2D');\n      }\n\n      this.inputHandler.detach();\n\n      this.pushPinManager.removeEventListener(PUSHPIN_EVENTS.PUSH_PIN_SELECTED_EVENT, this.onSelectedChangedBind);\n      this.pushPinManager.removeEventListener(PUSHPIN_EVENTS.PUSH_PIN_REMOVED_EVENT, this.onRemoveBind);\n      this.pushPinManager.removeEventListener(PUSHPIN_EVENTS.PUSH_PIN_REMOVE_ALL_EVENT, this.onRemoveAllBind);\n      this.pushPinManager.removeEventListener(PUSHPIN_EVENTS.PUSH_PIN_MODIFY_EVENT, this.onModifyBind);\n      this.pushPinManager.removeEventListener(PUSHPIN_EVENTS.PUSH_PIN_UPDATE_EVENT, this.onUpdateBind);\n      this.pushPinManager.removeEventListener(PUSHPIN_EVENTS.PUSH_PIN_VISIBILITY_EVENT, this.onVisibilityChangedBind);\n      this.pushPinManager.removeCreateFunction(this.createBind);\n\n    } }, { key: \"setPushpinDirty\", value: function setPushpinDirty()\n\n    {\n      this.pushpinDirty = true;\n    } }, { key: \"onSelectedChanged\", value: function onSelectedChanged(\n\n    event) {\n      if (event.value) {\n        this.selectedItem = event.value;\n\n        if (!this.selectedItem.marker) {\n          this.create(this.selectedItem);\n        }\n\n        this.pushpinBillboardTool.selectPushpin(this.selectedItem);\n        this.focusCameraOnSelectedItem(this.selectedItem);\n\n        if (this.selectedItem.draggable) {\n          this.enableItemDragging(this.selectedItem);\n        }\n\n        this.viewer.dispatchEvent({ type: PUSHPIN_EVENTS.PUSH_PIN_SELECTED_EVENT });\n      } else {\n        this.deselectItem();\n        this.pushpinBillboardTool.deselect();\n      }\n\n      this.setPushpinDirty();\n    } }, { key: \"deselectItem\", value: function deselectItem()\n\n    {\n      this.selectedItem = null;\n      this.inputHandler.detach();\n    } }, { key: \"onRemove\", value: function onRemove(\n\n    event) {\n      if (this.selectedItem && event.value.data.id === this.selectedItem.data.id) {\n        this.deselectItem();\n      }\n\n      if (event.value && event.value.marker) {\n        this.pushpinBillboardTool.removePushpin(event.value);\n      }\n    } }, { key: \"onRemoveAll\", value: function onRemoveAll()\n\n    {\n      this.deselectItem();\n      this.pushpinBillboardTool.removeAll();\n    } }, { key: \"onModify\", value: function onModify()\n\n    {\n      this.pushpinDirty = true;\n    } }, { key: \"onVisibilityChanged\", value: function onVisibilityChanged()\n\n    {\n      this.pushpinBillboardTool.showMarkers();\n    } }, { key: \"onUpdate\", value: function onUpdate()\n\n    {var _this2 = this;\n      setTimeout(function () {\n        _this2.setPushpinDirty();\n\n        // it could happen that the extension was removed in the meantime\n        _this2.pushpinBillboardTool && _this2.pushpinBillboardTool.setDirty();\n        var selectedItem = _this2.pushPinManager ? _this2.pushPinManager.getSelectedItem() : null;\n\n        if (!selectedItem) {\n          return;\n        }\n\n        selectedItem.draggable && selectedItem.marker ?\n        _this2.enableItemDragging(selectedItem) :\n        _this2.disableItemDragging(selectedItem);\n      }, 1);\n    } }, { key: \"enableItemDragging\", value: function enableItemDragging(\n\n    item) {\n      this.pushpinBillboardTool.enableDragging(item);\n      this.inputHandler.attachTo(item.marker);\n    } }, { key: \"disableItemDragging\", value: function disableItemDragging(\n\n    item) {\n      this.pushpinBillboardTool.disableDragging(item);\n      this.inputHandler.detach();\n    } }, { key: \"create\", value: function create(\n\n    item) {\n      // iOS have a special case where they already have the UUID, so we act like we are re-selecting an existing item\n      return this.createRenderItem(item, Autodesk.Viewing.isIOSDevice());\n    } }, { key: \"createRenderItem\", value: function createRenderItem(\n\n    item, reselect) {\n      // Make sure it's a uuid and not a growing counter\n      var isLoaded = item.data.id.length > 20;\n\n      // If we are actually creating a new pushpin (and not just loading one), make sure to deselect the previous selected one.\n      if (!isLoaded) {\n        this.pushpinBillboardTool.deselect();\n      }\n\n      var promise;\n      if (isLoaded && !reselect) {\n        promise = this.pushpinBillboardTool.loadPushpin(item);\n      } else {\n        promise = this.pushpinBillboardTool.createPushpin(item);\n        this.pushPinManager.selectOne(item.data.id);\n      }\n\n      return promise;\n    } }, { key: \"updatePattern\", value: function updatePattern(\n\n    status, size, hex) {\n      this.pushpinBillboardTool.updateStyle(status, size, hex);\n\n      this.setPushpinDirty();\n    } }, { key: \"focusCameraOnSelectedItem\", value: function focusCameraOnSelectedItem(\n\n    item) {\n      if (item.marker) {\n        var padding = 0.2;\n\n        var modelBounds = this.viewer.utilities.getBoundingBox(true);\n        var modelWidth = (modelBounds.max.x - modelBounds.min.x) * padding;\n        var modelHeight = (modelBounds.max.y - modelBounds.min.y) * padding;\n\n        var min = new THREE.Vector3(item.marker.intersectPoint.x - modelWidth, item.marker.intersectPoint.y - modelHeight, 0);\n        var max = new THREE.Vector3(item.marker.intersectPoint.x + modelWidth, item.marker.intersectPoint.y + modelHeight, 0);\n        var bounds = new THREE.Box3(min, max);\n\n        this.viewer.navigation.fitBounds(this.pushPinManager.restoreViewerStateImmediate, bounds, false);\n      }\n    } }, { key: \"render\", value: function render()\n\n    {var _this3 = this;\n      if (!this.pushPinManager || !this.viewer.model) {\n        return;\n      }\n\n      this.pushPinManager.items().reverse().forEach(function (item) {\n        if (!item.marker) {\n          _this3.createRenderItem(item, false);\n        }\n      });\n\n      if (this.pushpinDirty) {\n        this.pushpinBillboardTool.updateContainerProjection();\n        this.pushpinDirty = false;\n      }\n    } }, { key: \"findIntersections\", value: function findIntersections(\n\n    event) {\n      var mouseX = event.clientX;\n      var mouseY = event.clientY;\n\n      var hitItem = null;\n\n      this.pushPinManager.items().some(function (item) {\n        if (item.selectable && item.marker) {\n          var bb = item.marker.getBoundingClientRect();\n          if (mouseX > bb.left && mouseX < bb.left + bb.width && mouseY > bb.top && mouseY < bb.top + bb.height) {\n            hitItem = item;\n            return true;\n          }\n        }\n        return false;\n      });\n\n      return hitItem;\n    } }, { key: \"handleMouseMove\", value: function handleMouseMove(\n\n    e) {\n      var self = this;\n      function mouseCoords(ev) {\n        if (ev.pageX || ev.pageY) {\n          return { x: ev.pageX, y: ev.pageY };\n        }\n\n        var _document = self.getDocument();\n        return {\n          x: ev.clientX + _document.body.scrollLeft - _document.body.clientLeft,\n          y: ev.clientY + _document.body.scrollTop - _document.body.clientTop };\n\n      }\n\n      if (this.selectedItem.marker && this.selectedItem.marker.startDragging) {\n        // only on first mouse movement\n        if (!this.newX) {\n          this.selectedItem.marker.style.transform = 'translate(0px, 0px)';\n        }\n\n        var mousePos = mouseCoords(e);\n\n        this.newX = mousePos.x - this.mouseOffset.x;\n        this.newY = mousePos.y - this.mouseOffset.y;\n\n        // Check left, top, right, bottom\n        var containerBounds = this.viewer.navigation.getScreenViewport();\n        var wi = this.selectedItem.marker.clientWidth;\n        var hi = this.selectedItem.marker.clientHeight;\n\n        if (this.newX < 5) {\n          this.newX = 0;\n        }\n        if (this.newY < 5) {\n          this.newY = 0;\n        }\n        if (containerBounds.width - 5 < this.newX + wi) {\n          this.newX = containerBounds.width - wi;\n        }\n        if (containerBounds.height - 5 < this.newY + hi) {\n          this.newY = containerBounds.height - hi;\n        }\n\n        var containerPosX = this.pushpinBillboardTool.pushpinContainer.position.x;\n        var containerPosY = this.pushpinBillboardTool.pushpinContainer.position.y;\n\n        this.selectedItem.marker.style.left = \"\".concat(this.newX - containerPosX, \"px\");\n        this.selectedItem.marker.style.top = \"\".concat(this.newY - containerPosY, \"px\");\n\n        this.selectedItem.marker.dragging = true;\n\n        this.pushPinManager.hoverLocations(event);\n      }\n    } }, { key: \"handleMouseUp\", value: function handleMouseUp(\n\n    e) {var _this4 = this;\n      if (this.selectedItem.marker) {\n        if (this.selectedItem.marker.dragging) {\n          var containerPosX = this.pushpinBillboardTool.pushpinContainer.position.x;\n          var containerPosY = this.pushpinBillboardTool.pushpinContainer.position.y;\n\n          this.selectedItem.marker.style.transform = \"translate(\".concat(this.newX - containerPosX, \"px, \").concat(this.newY - containerPosY, \"px)\");\n\n          var result = clientToWorld(this.viewer, this.newX, this.newY);\n\n          this.selectedItem.data.position = { x: result.x, y: result.y, z: result.z };\n\n          this.pushPinManager.setItemLocationIds(this.selectedItem);\n          this.pushPinManager.generateThumbnail(this.selectedItem).then(function (thumbnail) {var _this4$selectedItem$d =\n\n            _this4.selectedItem.data.position,x = _this4$selectedItem$d.x,y = _this4$selectedItem$d.y,z = _this4$selectedItem$d.z; // Backup position.\n\n            if (_this4.viewer.model.isPdf(true)) {\n              convertPdfToLeaflet(_this4.viewer, _this4.selectedItem.data);\n            }\n\n            _this4.pushPinManager.fireEvent({ type: PUSHPIN_EVENTS.PUSH_PIN_MODIFY_EVENT, value: _this4.selectedItem, thumbnail: thumbnail });\n\n            _this4.selectedItem.data.position = { x: x, y: y, z: z }; // Restore position.\n          });\n\n          this.pushpinBillboardTool.removeAll();\n          this.render();\n          this.pushpinBillboardTool.selectPushpin(this.pushPinManager.selectedItem);\n          if (this.selectedItem.draggable) {\n            this.enableItemDragging(this.selectedItem);\n          }\n        } else {\n          this.selectedItem.marker.startDragging = false;\n        }\n      }\n    } }, { key: \"handleMouseDown\", value: function handleMouseDown(\n\n    event) {\n      function getOffset(e) {\n        var left = 0;\n        var top = 0;\n\n        while (e.offsetParent) {\n          left += e.offsetLeft;\n          top += e.offsetTop;\n          e = e.offsetParent;\n        }\n\n        left += e.offsetLeft;\n        top += e.offsetTop;\n        return { x: left, y: top };\n      }\n\n      if (this.selectedItem.marker) {\n        if (event.target.tagName.toLowerCase() === 'textarea') {\n          return;\n        }\n\n        this.mouseOffset = getOffset(this.viewer.container);\n\n        this.newX = null;\n        this.newY = null;\n\n        this.selectedItem.marker.startDragging = true;\n      }\n    } }]);return RenderHandler2D;}();export { RenderHandler2D as default };\n\n\nav.GlobalManagerMixin.call(RenderHandler2D.prototype);","function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError(\"Cannot call a class as a function\");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}import PushPinBillboardLabel from '../PushPinLabel/PushPinBillboardLabel';\nimport { statusHexValues, moveableIcon, markerOffsets, ATTRIBUTES_VERSION } from '../PushPinConstants';\nimport { generateMetadata } from '../PushPins3D/PushPinViewerState';\nimport { applyModelTransform } from '../PushPinUtils';\n\nvar av = Autodesk.Viewing;var\n\nPushPinBillboardTool3D = /*#__PURE__*/function () {\n  function PushPinBillboardTool3D(viewer) {var _this = this;var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};_classCallCheck(this, PushPinBillboardTool3D);\n    this.names = ['pushpinBillboard3D'];\n\n    this.viewer = viewer;\n    this.setGlobalManager(viewer.globalManager);\n\n    this.active = false;\n\n    this.pushpins = [];\n    this.selectedPushpin = null;\n    this.dirty = false;\n    this.camera = this.viewer.navigation.getCamera();\n\n    var raycastLimitPerSecond = 200; // execute at most once every x milliseconds.\n    this.maxMsPerRayCastCycle = 20;\n    this.updateTimestamp = 0;\n\n    this.tmpVec = new THREE.Vector3();\n    this.tmpMatrix = new THREE.Matrix4();\n    this.tmpFrustum = new THREE.Frustum();\n\n    if (!options.disableOcclusionTest) {\n      // Ray-casts for occlusion tests. The only purpose is to change the opacity of occluded PushPins, at the costs of:\n      //  - Memory: Loading the externalID file (may be huge for large projects)\n      //  - Performance: Repeatedly firing lots of raytests and worker tasks (#PushPins separate queries per camera change)\n      this.raycastThrottle = this.throttle(function () {\n        _this.continueRayCasts();\n      }, raycastLimitPerSecond);\n    } else {\n      // Bypass raycasts for occlusion checks.\n      this.raycastThrottle = function () {};\n    }\n  }_createClass(PushPinBillboardTool3D, [{ key: \"continueRayCasts\", value: function continueRayCasts()\n\n    {\n      var stamp = performance.now();\n      var i = 0;\n      for (; i < this.pushpins.length; i++) {\n        var pushpin = this.pushpins[i];\n        if (!pushpin.visible) {\n          continue;\n        }\n        if (pushpin.updateTimestamp !== this.updateTimestamp) {\n          pushpin.updateTimestamp = this.updateTimestamp;\n          this.castRay(pushpin);\n          if (performance.now() > stamp + this.maxMsPerRayCastCycle) {\n            break;\n          }\n        }\n      }\n\n      // Make sure that we continue if we couldn't do them all\n      if (i < this.pushpins.length) {\n        this.raycastThrottle();\n      }\n    } }, { key: \"getNames\", value: function getNames()\n\n    {\n      return this.names;\n    } }, { key: \"getName\", value: function getName()\n\n    {\n      return this.names[0];\n    } }, { key: \"isActive\", value: function isActive()\n\n    {\n      return this.active;\n    } }, { key: \"activate\", value: function activate(\n\n    name) {var _this2 = this;\n      if (name === this.getName()) {\n        this.active = true;\n\n        this.onCameraChangeBinded = function (e) {return _this2.onCameraChange(e);};\n        this.handleResizeBinded = function (e) {return _this2.handleResize(e);};\n\n        this.viewer.addEventListener(Autodesk.Viewing.CAMERA_CHANGE_EVENT, this.onCameraChangeBinded);\n        this.viewer.addEventListener(Autodesk.Viewing.MODEL_TRANSFORM_CHANGED_EVENT, this.onCameraChangeBinded);\n        this.viewer.addEventListener(Autodesk.Viewing.VIEWER_RESIZE_EVENT, this.handleResizeBinded);\n      }\n    } }, { key: \"throttle\", value: function throttle(\n\n    callback, wait) {var context = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this;\n      var timeout = null;\n      var callbackArgs = null;\n\n      var later = function later() {\n        timeout = null;\n        callback.apply(context, callbackArgs);\n      };\n\n      return function () {\n        if (!timeout) {\n          callbackArgs = arguments;\n          timeout = setTimeout(later, wait);\n        }\n      };\n    } }, { key: \"deactivate\", value: function deactivate(\n\n    name) {\n      if (name === this.getName()) {\n        this.active = false;\n\n        this.viewer.removeEventListener(Autodesk.Viewing.CAMERA_CHANGE_EVENT, this.onCameraChangeBinded);\n        this.viewer.removeEventListener(Autodesk.Viewing.MODEL_TRANSFORM_CHANGED_EVENT, this.onCameraChangeBinded);\n        this.viewer.removeEventListener(Autodesk.Viewing.VIEWER_RESIZE_EVENT, this.handleResizeBinded);\n      }\n    } }, { key: \"onCameraChange\", value: function onCameraChange()\n\n    {\n      this.updatePushpins();\n    } }, { key: \"project\", value: function project(\n\n    pushpin) {\n      var position = pushpin.marker.intersectPoint;\n      var containerBounds = this.viewer.navigation.getScreenViewport();\n      var p = this.tmpVec.copy(position);\n\n      var model = pushpin.findModel(this.viewer);\n\n      applyModelTransform(p, model);\n\n      this.tmpMatrix.multiplyMatrices(this.camera.projectionMatrix, this.camera.matrixWorldInverse);\n\n      // We don't change visibility if pushpin is hidden anyway\n      if (pushpin.visible) {\n        this.tmpFrustum.setFromMatrix(this.tmpMatrix);\n        !this.tmpFrustum.containsPoint(p) ? this.hideMarker(pushpin.marker) : this.showMarker(pushpin.marker);\n      }\n\n      p.applyProjection(this.tmpMatrix);\n\n      return new THREE.Vector3(\n      Math.round((p.x + 1) / 2 * containerBounds.width),\n      Math.round((-p.y + 1) / 2 * containerBounds.height),\n      p.z);\n\n    } }, { key: \"unproject\", value: function unproject(\n\n    position) {\n      var containerBounds = this.viewer.navigation.getScreenViewport();\n      var p = new THREE.Vector3();\n\n      p.x = position.x / containerBounds.width * 2 - 1;\n      p.y = -(position.y / containerBounds.height * 2 - 1);\n      p.z = position.z;\n      p.unproject(this.camera);\n\n      return p;\n    } }, { key: \"initNewPushpin\", value: function initNewPushpin(\n\n    item) {\n      item.intersectPoint = item.data.position;\n\n      this.pushpins.push(item);\n\n      this.createMarker(item);\n\n      item.draggable ? this.enableDragging(item) : this.disableDragging(item);\n      item.visible ? this.showMarker(item.marker) : this.hideMarker(item.marker);\n    } }, { key: \"fetchExternalId\", value: function fetchExternalId(\n\n    model, dbId, callback) {var _this3 = this;\n      return new Promise(function (resolve, reject) {\n        var onSuccessCallback = function onSuccessCallback(props) {\n          var externalId = props.externalId;\n\n          // For some files (i.e. STEP) the externalId is an array that contains the whole hierarchy of the element\n          // Since we need only a string in the end we take the last element (the hierarchy is concatenated anyway,\n          // so each element contains the whole information needed to identify it)\n          if (externalId.startsWith('[') && externalId.endsWith(']')) {\n            try {\n              var parsedExternalId = JSON.parse(externalId);\n              if (Array.isArray(parsedExternalId)) {\n                externalId = parsedExternalId[parsedExternalId.length - 1];\n              }\n            } catch (e) {\n              console.error('Error ' + e + ' parsing externalId ', externalId);\n            }\n          }\n\n          // https://wiki.autodesk.com/pages/viewpage.action?spaceKey=saascore&title=Comparison+of+different+behaviors+between+SVF+and+SVF2\n          // Look for \"ifcGUID\" in the wiki above - In SVF2, the ifcGUID is used as the externalID of object.\n          if (!model.isOTG() && model.getData().loadOptions.fileExt === 'ifc') {\n            var ifcId = props.properties.find(function (el) {return el.displayName === 'IfcGUID' || el.displayName === 'GLOBALID' && el.displayCategory === 'IFC';});\n            if (ifcId) {\n              externalId = ifcId.displayValue;\n            } else {// If there's no IFC id, look at the parent\n              var parentDbId = props.properties.find(function (el) {return el.displayName === 'parent' && el.displayValue > -1;});\n              if (parentDbId) {\n                resolve(_this3.fetchExternalId(model, parentDbId.displayValue, callback));\n                return;\n              }\n            }\n          }\n          callback(externalId);\n          resolve();\n        };\n\n        var onErrorCallback = function onErrorCallback(status, message, data) {\n          Autodesk.Viewing.Private.logger.warn(message);\n          resolve(); // Log the message but don't fail\n        };\n\n        model.getProperties2(dbId, onSuccessCallback, onErrorCallback, { needsExternalId: true });\n      });\n    } }, { key: \"createPushpin\", value: function createPushpin(\n\n    item) {\n      item.data.attributesVersion = ATTRIBUTES_VERSION;\n\n      this.initNewPushpin(item);\n\n      item.setViewerState(generateMetadata(this.viewer, item));\n\n      this.selectPushpin(item);\n\n      var vpVec = this.viewer.impl.clientToViewport(item.marker.position.x, item.marker.position.y);\n      var res = this.viewer.impl.castRayViewport(vpVec, false);\n\n      if (res) {\n        item.setObjectId(res.dbId);\n        item.setObjectData(res);\n\n        var model = item.findModel(this.viewer);\n        if (!model) {\n          console.error('Failed to assign externalId: The model for this PushPin is not loaded.');\n          return Promise.resolve();\n        }\n\n        return this.fetchExternalId(model, res.dbId, function (externalId) {return item.setExternalId(externalId);});\n      } else {\n        return Promise.resolve();\n      }\n    } }, { key: \"loadPushpin\", value: function loadPushpin(\n\n    item) {\n      this.initNewPushpin(item);\n\n      return Promise.resolve();\n    } }, { key: \"createMarker\", value: function createMarker(\n\n    pushpin) {\n      var _document = this.getDocument();\n      var marker = _document.createElement('div');\n      pushpin.marker = marker;\n\n      marker.id = pushpin.data.id;\n      marker.intersectPoint = pushpin.intersectPoint;\n\n      if (pushpin.hasPosition()) {\n        var className = pushpin.data.type === 'rfis' ? 'rfi-billboard-marker' : 'pushpin-billboard-marker';\n\n        marker.classList.add(className);\n        marker.style.backgroundColor = statusHexValues[pushpin.data.status];\n\n        this.viewer.container.appendChild(marker);\n\n        this.setMarkerPosition(pushpin);\n\n        var xTranslate = pushpin.marker.position.x - markerOffsets.markerOffsetWidth / 2;\n        var yTranslate = pushpin.marker.position.y - markerOffsets.markerOffsetWidth / 2;\n\n        pushpin.marker.style.transform = \"translate(\".concat(xTranslate, \"px, \").concat(yTranslate, \"px)\");\n      } else {\n        // Imported issues (such as from BCF) can arrive without a position. They just store the camera state\n        // In that case create a dummy marker (since the extension assumes it exists in many places) and don't \n        // add it to the viewer.container\n        this.hideMarker(marker);\n        pushpin.visible = false;\n      }\n    } }, { key: \"removePushpin\", value: function removePushpin(\n\n    pushpin) {var _this4 = this;\n      this.pushpins = this.pushpins.filter(function (curPushpin) {\n        if (_this4.selectedPushpin && _this4.selectedPushpin.data.id === pushpin.data.id) {\n          _this4.selectedPushpin = null;\n        }\n\n        return curPushpin.data.id !== pushpin.data.id;\n      });\n\n      this.destroyMarker(pushpin);\n    } }, { key: \"removeAll\", value: function removeAll()\n\n    {var _this5 = this;\n      this.pushpins.forEach(function (pushpin) {\n        _this5.removePushpin(pushpin);\n      });\n    } }, { key: \"destroyMarker\", value: function destroyMarker(\n\n    pushpin) {\n      this.destroyLabel(pushpin);\n      this.viewer.container.removeChild(pushpin.marker);\n      pushpin.marker = undefined;\n    } }, { key: \"destroyLabel\", value: function destroyLabel(\n\n    pushpin) {\n      if (pushpin.label) {\n        pushpin.marker.removeChild(pushpin.label.container);\n        pushpin.label = undefined;\n      }\n    } }, { key: \"setMarkerPosition\", value: function setMarkerPosition(\n\n    pushpin) {\n      pushpin.marker.position = this.project(pushpin);\n    } }, { key: \"updateStyle\", value: function updateStyle(\n\n    status, size, hex) {\n      statusHexValues[status] = hex;\n      this.dirty = true;\n    } }, { key: \"castRay\", value: function castRay(\n\n    pushpin) {\n      var objectId = parseInt(pushpin.data.objectId, 10);\n      if (isNaN(objectId) || objectId === -1) {// no check needed\n        return;\n      }\n\n      var vpVec = this.viewer.impl.clientToViewport(pushpin.marker.position.x, pushpin.marker.position.y);\n      var res = this.viewer.impl.castRayViewport(vpVec, false);\n      if (res && res.dbId) {\n        if (pushpin.data.externalId) {\n          return this.fetchExternalId(res.model, res.dbId, function (externalId) {\n            // it could happen that the pushpin was removed in the meantime\n            if (pushpin && pushpin.marker && pushpin.data) {\n              pushpin.marker.style.opacity = externalId === pushpin.data.externalId ? '1.0' : '0.15';\n            }\n          });\n        }\n        if (pushpin.data.objectId && parseInt(pushpin.data.objectId, 10) !== -1) {\n          pushpin.marker.style.opacity = res.dbId === parseInt(pushpin.data.objectId, 10) ? '1.0' : '0.15';\n        }\n      } else {// no object was hit\n        pushpin.marker.style.opacity = '0.15';\n      }\n    } }, { key: \"updatePushpins\", value: function updatePushpins()\n\n    {var _this6 = this;\n      // Calc new position\n      this.updateTimestamp++;\n      this.raycastThrottle();\n\n      this.pushpins.forEach(function (pushpin) {\n        _this6.setMarkerPosition(pushpin);\n      });\n\n      // Update the DOM\n      this.pushpins.forEach(function (pushpin) {\n        var offsetWidth = pushpin.selected ? markerOffsets.selectedMarkerOffsetWidth : markerOffsets.markerOffsetWidth;\n\n        var xTranslate = pushpin.marker.position.x - offsetWidth / 2;\n        var yTranslate = pushpin.marker.position.y - offsetWidth / 2;\n\n        pushpin.marker.style.transform = \"translate(\".concat(xTranslate, \"px, \").concat(yTranslate, \"px)\");\n\n        if (_this6.dirty) {\n          if (pushpin.label) {\n            pushpin.label.update(pushpin.data.label);\n          }\n\n          pushpin.draggable ? _this6.enableDragging(pushpin) : _this6.disableDragging(pushpin);\n          pushpin.marker.style.backgroundColor = statusHexValues[pushpin.data.status];\n          pushpin.visible ? _this6.showMarker(pushpin.marker) : _this6.hideMarker(pushpin.marker);\n        }\n      });\n\n      this.dirty = false;\n    } }, { key: \"setDirty\", value: function setDirty()\n\n    {\n      this.dirty = true;\n    } }, { key: \"selectPushpin\", value: function selectPushpin(\n\n    pushpin) {\n      this.deselect();\n      this.viewer.clearSelection();\n\n      pushpin.label = new PushPinBillboardLabel(pushpin.marker, pushpin.data.label);\n      pushpin.marker.classList.add('selected');\n\n      this.selectedPushpin = pushpin;\n    } }, { key: \"deselect\", value: function deselect()\n\n    {\n      if (this.selectedPushpin) {\n        this.destroyLabel(this.selectedPushpin);\n        this.selectedPushpin.marker.style.pointerEvents = 'none';\n        this.selectedPushpin.marker.classList.remove('selected');\n        this.selectedPushpin = null;\n      }\n    } }, { key: \"enableDragging\", value: function enableDragging(\n\n    item) {\n      if (this.selectedPushpin && this.selectedPushpin.data.id === item.data.id) {\n        item.marker.style.pointerEvents = 'auto';\n      }\n      item.marker.style.backgroundImage = moveableIcon;\n    } }, { key: \"disableDragging\", value: function disableDragging(\n\n    item) {\n      var selectedItem = item || this.selectedPushpin;\n\n      selectedItem.marker.style.pointerEvents = 'none';\n      selectedItem.marker.style.backgroundImage = 'none';\n      selectedItem.draggable = false;\n    } }, { key: \"hideLabel\", value: function hideLabel()\n\n    {\n      if (this.selectedPushpin) {\n        this.selectedPushpin.label.hide();\n      }\n    } }, { key: \"showMarker\", value: function showMarker(\n\n    marker) {\n      marker.style.display = '';\n    } }, { key: \"hideMarker\", value: function hideMarker(\n\n    marker) {\n      marker.style.display = 'none';\n    } }, { key: \"showMarkers\", value: function showMarkers()\n\n    {var _this7 = this;\n      this.pushpins.forEach(function (pushpin) {\n        pushpin.visible ? _this7.project(pushpin) : _this7.hideMarker(pushpin.marker);\n      });\n    } }, { key: \"hideMarkers\", value: function hideMarkers()\n\n    {var _this8 = this;\n      this.pushpins.forEach(function (pushpin) {\n        _this8.hideMarker(pushpin.marker);\n      });\n\n      if (this.selectedPushpin) {\n        this.destroyLabel(this.selectedPushpin);\n      }\n    } }, { key: \"handleButtonDown\", value: function handleButtonDown(\n\n\n    event, button) {\n      return false;\n    } }, { key: \"handleButtonUp\", value: function handleButtonUp(\n\n    event, button) {\n      return false;\n    } }, { key: \"handleResize\", value: function handleResize()\n\n    {\n      this.updatePushpins();\n    } }]);return PushPinBillboardTool3D;}();export { PushPinBillboardTool3D as default };\n\n\nav.GlobalManagerMixin.call(PushPinBillboardTool3D.prototype);\n\nvar namespace = AutodeskNamespace('Autodesk.BIM360.Extension.PushPin');\n\nnamespace.PushPinBillboardTool3D = PushPinBillboardTool3D;","var applyOffsetToCamera = function applyOffsetToCamera(viewport, offset) {\n  if (!viewport || !offset) {\n    return;\n  }\n\n  if ('eye' in viewport) {\n    viewport.eye[0] = (Number(viewport.eye[0]) + offset.x).toString();\n    viewport.eye[1] = (Number(viewport.eye[1]) + offset.y).toString();\n    viewport.eye[2] = (Number(viewport.eye[2]) + offset.z).toString();\n  }\n\n  if ('target' in viewport) {\n    viewport.target[0] = (Number(viewport.target[0]) + offset.x).toString();\n    viewport.target[1] = (Number(viewport.target[1]) + offset.y).toString();\n    viewport.target[2] = (Number(viewport.target[2]) + offset.z).toString();\n  }\n\n  if ('pivotPoint' in viewport) {\n    viewport.pivotPoint[0] = (Number(viewport.pivotPoint[0]) + offset.x).toString();\n    viewport.pivotPoint[1] = (Number(viewport.pivotPoint[1]) + offset.y).toString();\n    viewport.pivotPoint[2] = (Number(viewport.pivotPoint[2]) + offset.z).toString();\n  }\n};\n\nvar applyOffsetToCutplanes = function applyOffsetToCutplanes(cutplanes, offset) {\n  if (!cutplanes || !offset) {\n    return;\n  }\n\n  var normal = new THREE.Vector3();\n\n  for (var i = 0; i < cutplanes.length; i++) {\n    var cutplane = cutplanes[i];\n    // A cutplane is an array of 4 numbers. The first 3 numbers represent the plane's normal vector\n    // and the 4th number is the distance along it\n    toVector(cutplane, normal);\n    // Translating a plane by an offset vector is equivalent to adding dot(n,of) where n is the plane normal\n    // This again is equivalent to adding or subtracting dot(n, of) to the constant of the plane\n    // We have plane.constant = -plane.normal.dot(onPlane + globalOffset)\n    //                        = -plane.normal.dot(onPlane) - plane.normal.dot(globalOffset)\n    //                        = oldConstant - plane.normal.dot(globalOffset)\n    cutplane[3] = Number(cutplane[3]) - normal.dot(offset);\n  }\n};\n\nvar amendViewportIfNeeded = function amendViewportIfNeeded(viewer, item) {\n  var globalOffset = viewer.model ? viewer.model.getData().globalOffset : null;\n  var state = JSON.parse(JSON.stringify(item.data.viewerState));\n\n  if (globalOffset) {\n    var invGlobalOffset = { x: -globalOffset.x, y: -globalOffset.y, z: -globalOffset.z };\n\n    applyOffsetToCamera(state.viewport, invGlobalOffset);\n\n    if (item.getAttributesVersion() >= 2) {\n      applyOffsetToCutplanes(state.cutplanes, invGlobalOffset);\n    }\n  }\n\n  var model = item.findModel(viewer);\n  var modelTransform = model === null || model === void 0 ? void 0 : model.getModelTransform();\n\n  if (modelTransform) {\n    transformViewerState(state, modelTransform);\n  }\n\n  //Support legacy edge cases where Viewer state doesn't contain objectState;\n  if (!state.objectSet) {\n    state.objectSet = [];\n  }\n\n  return state;\n};\n\nexport var generateMetadata = function generateMetadata(viewer, item) {\n  var globalOffset = viewer.model ? viewer.model.getData().globalOffset : null;\n  var viewerState = viewer.getState();\n  var state = JSON.parse(JSON.stringify(viewerState));\n\n  // Replace viewerState's seedURN with a specific model's seedURN.\n  // It's needed because viewer.getState() returns always the first model's seedUrn - and not really the relevant model's urn.\n  state.seedURN = item.getSeedUrn() || viewerState.seedURN;\n\n  if (globalOffset) {\n    applyOffsetToCamera(state.viewport, globalOffset);\n    applyOffsetToCutplanes(state.cutplanes, globalOffset);\n\n    state.globalOffset = globalOffset;\n  }\n\n  var model = item.findModel(viewer);\n  var modelTransform = model === null || model === void 0 ? void 0 : model.getModelTransform();\n\n  if (modelTransform) {\n    transformViewerState(state, new THREE.Matrix4().getInverse(modelTransform));\n  }\n\n  return state;\n};\n\nexport var restoreViewState = function restoreViewState(viewer, item, immediate) {\n  if (item.data && item.data.viewerState) {(function () {\n      var amendedData = amendViewportIfNeeded(viewer, item);\n      var visibleModels = viewer.getVisibleModels();\n\n      // While restoring Viewer state, check if any of isolated items exist in scene\n      // Remove non-existing dbIds from objectSet inside of Pushpin's viewer state (BLMV-4397)\n      var _loop = function _loop(i) {\n        var seedUrn = visibleModels[i].getSeedUrn();\n        var onlySingleModel = visibleModels.length === 1;\n\n        // Condition that checks if dbId exists before isolating\n        var itemExist = function itemExist(isolatedItem) {return visibleModels[i].isNodeExists(isolatedItem);};\n\n        for (var j = 0; j < amendedData.objectSet.length; j++) {\n          // Since Viewer state with single model has no seedUrn within objectSet,\n          // need to check indpendently states with single and multiple models in Viewer state\n          var isSingle = !amendedData.objectSet[j].seedUrn && onlySingleModel;\n          if (isSingle || amendedData.objectSet[j].seedUrn === seedUrn || amendedData.seedURN === seedUrn) {\n            var isolatedItems = amendedData.objectSet[j].isolated;\n            for (var k = 0; k < isolatedItems.length; k++) {\n              if (!visibleModels[i].isNodeExists(isolatedItems[k])) {\n                amendedData.objectSet[j].isolated.splice(k, 1);\n                k--;\n              }\n            }\n          }\n        }};for (var i = 0; i < visibleModels.length; i++) {_loop(i);\n      }\n\n\n      viewer.restoreState(amendedData, null, immediate);\n\n      // RestoreState will async to update camera's all data. Here force update camera before load pushpin.\n      var navapi = viewer.navigation;\n\n      if (navapi) {\n        navapi.updateCamera();\n        var camera = navapi.getCamera();\n\n        camera.updateMatrixWorld();\n      }})();\n  }\n};\n\n// Convert from array of values (or number-strings) to THREE.Vector.\n// Like THREE.Vector3.fromArray(), but with string->number conversion, because some viewerState values are stored as strings.\nvar toVector = function toVector(src, dst) {\n  dst.x = Number(src[0]);\n  dst.y = Number(src[1]);\n  dst.z = Number(src[2]);\n};\n\n// Transforms a point given as array-3 by a THREE.Matrix4\nvar transformPoint = function () {\n  var v = new THREE.Vector3();\n\n  return function (values, tf) {\n    toVector(values, v);\n    v.applyMatrix4(tf);\n    v.toArray(values);\n  };\n}();\n\n// Transforms a direction vector given as array-3 by a THREE.Matrix4\nvar transformNormal = function () {\n  var v = new THREE.Vector3();\n  var normalMatrix = new THREE.Matrix3();\n\n  return function (values, tf) {\n    toVector(values, v);\n\n    normalMatrix.getNormalMatrix(tf);\n    v.applyMatrix3(normalMatrix);\n    v.normalize(); // Re-normalize, so that scaling doesn't kill normalized directions.\n\n    v.toArray(values);\n  };\n}();\n\n// Transforms orthographic height by using transformed vector distances.\n// Orthographic height may be different from eye/target distance, so we calculate it separately\n// and let the viewerImpl work out which one to use.\n// It is necessary to use this approach because the transform matrix could contain transformations\n// which a naive scalar multiplication wouldn't handle correctly.\nvar transformOrthographicHeight = function () {\n  var eye = new THREE.Vector3();\n  var target = new THREE.Vector3();\n  var orthographicHeightVector = new THREE.Vector3();\n\n  return function (viewport, tf) {\n    // Convert to THREE.Vectors that we can calculate with as they may be provided as arrays.\n    toVector(viewport.eye, eye);\n    toVector(viewport.target, target);\n\n    // Compute a view-direction vector that is scaled to match orthographicHeight\n    orthographicHeightVector.subVectors(eye, target).normalize().multiplyScalar(viewport.orthographicHeight);\n\n    // Compute new eye vector with distance from target equal to orthographicHeight\n    eye.copy(target).add(orthographicHeightVector);\n\n    // Transform adjusted eye vector and target by the provided model transform.\n    eye.applyMatrix4(tf);\n    target.applyMatrix4(tf);\n\n    // Derive transformed length by getting the distance between the adjusted eye and the target after transform.\n    viewport.orthographicHeight = eye.distanceTo(target);\n  };\n}();\n\nexport var transformViewerState = function transformViewerState(state, tf) {\n  if (!state || !tf) {\n    return;\n  }\n\n  // If we are in orthographic mode and have a real orthographicHeight we need to calculate\n  // a new orthographicHeight using the provided transform.\n  if (state.viewport.isOrthographic && state.viewport.orthographicHeight > 0) {\n    transformOrthographicHeight(state.viewport, tf);\n  }\n\n  // Note that these values are not vectors, but arrays (in some cases even containing string-type-values).\n  transformPoint(state.viewport.eye, tf);\n  transformPoint(state.viewport.target, tf);\n  transformPoint(state.viewport.pivotPoint, tf);\n\n  transformNormal(state.viewport.up, tf); // may become relevant if tf contains a true-north rotation and the camera-up is not vertical\n  transformNormal(state.viewport.worldUpVector, tf);\n\n  if (state.cutplanes) {\n    var plane = new THREE.Plane();\n    var normal = new THREE.Vector3();\n\n    for (var i = 0; i < state.cutplanes.length; i++) {\n      var cutplane = state.cutplanes[i];\n\n      toVector(cutplane, normal);\n      var constant = Number(cutplane[3]);\n      plane.set(normal, constant);\n\n      plane.applyMatrix4(tf);\n\n      plane.normal.toArray(cutplane);\n      cutplane[3] = plane.constant;\n    }\n  }\n};","function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError(\"Cannot call a class as a function\");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}import PushPinBillboardTool3D from '../PushPins3D/PushPinBillboardTool3D';\nimport PushPinInputHandler from '../PushPinInputHandler';\nimport { PUSHPIN_EVENTS } from '../PushPinEvents';\nimport { restoreViewState } from '../PushPins3D/PushPinViewerState';\nimport { markerOffsets } from '../PushPinConstants';\nimport { invertModelTransform } from \"../PushPinUtils\";\n\nvar av = Autodesk.Viewing;var\n\nRenderHandler3D = /*#__PURE__*/function () {\n  function RenderHandler3D(viewerApi, pushPinManager) {var _this = this;_classCallCheck(this, RenderHandler3D);\n    this.viewer = viewerApi;\n    this.setGlobalManager(this.viewer.globalManager);\n    this.pushPinManager = pushPinManager;\n    this.pushpinDirty = false;\n    this.selectedItem = null;\n\n    this.onSectionBind = function (e) {return _this.onSection(e);};\n\n    this.onSelectedChangedBind = function (e) {return _this.onSelectedChanged(e);};\n    this.onRemoveBind = function (e) {return _this.onRemove(e);};\n    this.onRemoveAllBind = function (e) {return _this.onRemoveAll(e);};\n    this.onModifyBind = function (e) {return _this.onModify(e);};\n    this.onUpdateBind = function (e) {return _this.onUpdate(e);};\n    this.createBind = function (e) {return _this.create(e);};\n    this.onVisibilityChangedBind = function (e) {return _this.onVisibilityChanged(e);};\n  }_createClass(RenderHandler3D, [{ key: \"register\", value: function register()\n\n    {\n      this.pushpinBillboardTool = new PushPinBillboardTool3D(this.viewer, this.pushPinManager.options);\n      this.viewer.toolController.registerTool(this.pushpinBillboardTool);\n    } }, { key: \"deregister\", value: function deregister()\n\n    {\n      if (this.pushpinBillboardTool) {\n        this.viewer.toolController.deregisterTool(this.pushpinBillboardTool);\n        this.pushpinBillboardTool = null;\n      }\n    } }, { key: \"activate\", value: function activate()\n\n    {\n      if (!this.pushpinBillboardTool.isActive()) {\n        this.viewer.toolController.activateTool('pushpinBillboard3D');\n      }\n\n      this.inputHandler = new PushPinInputHandler(this);\n\n      this.viewer.addEventListener(Autodesk.Viewing.CUTPLANES_CHANGE_EVENT, this.onSectionBind);\n\n      this.pushPinManager.addEventListener(PUSHPIN_EVENTS.PUSH_PIN_SELECTED_EVENT, this.onSelectedChangedBind);\n      this.pushPinManager.addEventListener(PUSHPIN_EVENTS.PUSH_PIN_REMOVED_EVENT, this.onRemoveBind);\n      this.pushPinManager.addEventListener(PUSHPIN_EVENTS.PUSH_PIN_REMOVE_ALL_EVENT, this.onRemoveAllBind);\n      this.pushPinManager.addEventListener(PUSHPIN_EVENTS.PUSH_PIN_MODIFY_EVENT, this.onModifyBind);\n      this.pushPinManager.addEventListener(PUSHPIN_EVENTS.PUSH_PIN_UPDATE_EVENT, this.onUpdateBind);\n      this.pushPinManager.addEventListener(PUSHPIN_EVENTS.PUSH_PIN_VISIBILITY_EVENT, this.onVisibilityChangedBind);\n      this.pushPinManager.setCreateFunction(this.createBind);\n\n      return true;\n    } }, { key: \"deactivate\", value: function deactivate()\n\n    {\n      if (this.pushpinBillboardTool.isActive()) {\n        this.viewer.toolController.deactivateTool('pushpinBillboard3D');\n      }\n\n      this.inputHandler.detach();\n\n      this.viewer.removeEventListener(Autodesk.Viewing.CUTPLANES_CHANGE_EVENT, this.onSectionBind);\n\n      this.pushPinManager.removeEventListener(PUSHPIN_EVENTS.PUSH_PIN_SELECTED_EVENT, this.onSelectedChangedBind);\n      this.pushPinManager.removeEventListener(PUSHPIN_EVENTS.PUSH_PIN_REMOVED_EVENT, this.onRemoveBind);\n      this.pushPinManager.removeEventListener(PUSHPIN_EVENTS.PUSH_PIN_REMOVE_ALL_EVENT, this.onRemoveAllBind);\n      this.pushPinManager.removeEventListener(PUSHPIN_EVENTS.PUSH_PIN_MODIFY_EVENT, this.onModifyBind);\n      this.pushPinManager.removeEventListener(PUSHPIN_EVENTS.PUSH_PIN_UPDATE_EVENT, this.onUpdateBind);\n      this.pushPinManager.removeEventListener(PUSHPIN_EVENTS.PUSH_PIN_VISIBILITY_EVENT, this.onVisibilityChangedBind);\n      this.pushPinManager.removeCreateFunction(this.createBind);\n    } }, { key: \"setPushpinDirty\", value: function setPushpinDirty()\n\n    {\n      this.pushpinDirty = true;\n    } }, { key: \"onSelectedChanged\", value: function onSelectedChanged(\n\n    event) {\n      if (event.value) {\n        this.selectedItem = event.value;\n\n        if (!this.selectedItem.marker) {\n          this.create(this.selectedItem);\n        }\n\n        this.pushpinBillboardTool.selectPushpin(this.selectedItem);\n        restoreViewState(this.viewer, this.selectedItem, this.pushPinManager.restoreViewerStateImmediate);\n\n        if (this.selectedItem.draggable) {\n          this.enableItemDragging(this.selectedItem);\n        }\n\n        this.viewer.dispatchEvent({ type: PUSHPIN_EVENTS.PUSH_PIN_SELECTED_EVENT });\n      } else {\n        this.deselectItem();\n        this.pushpinBillboardTool.deselect();\n\n        var sectionExt = this.viewer.getExtension('Autodesk.Section');\n\n        if (sectionExt && sectionExt.getSectionPlanes().length === 1) {\n          sectionExt.setSectionFromPlane(null);\n        } else {\n          this.viewer.impl.setCutPlaneSet('__set_view', undefined);\n        }\n      }\n\n      this.setPushpinDirty();\n    } }, { key: \"deselectItem\", value: function deselectItem()\n\n    {\n      this.selectedItem = null;\n      this.inputHandler.detach();\n    } }, { key: \"onRemove\", value: function onRemove(\n\n    event) {\n      if (this.selectedItem && event.value.data.id === this.selectedItem.data.id) {\n        this.deselectItem();\n      }\n\n      if (event.value && event.value.marker) {\n        this.pushpinBillboardTool.removePushpin(event.value);\n      }\n    } }, { key: \"onRemoveAll\", value: function onRemoveAll()\n\n    {\n      this.deselectItem();\n      this.pushpinBillboardTool.removeAll();\n    } }, { key: \"onModify\", value: function onModify()\n\n    {\n      this.pushpinDirty = true;\n    } }, { key: \"onVisibilityChanged\", value: function onVisibilityChanged()\n\n    {\n      this.pushpinBillboardTool.showMarkers();\n    } }, { key: \"onUpdate\", value: function onUpdate()\n\n    {var _this2 = this;\n      setTimeout(function () {\n        _this2.setPushpinDirty();\n\n        // it could happen that the extension was removed in the meantime\n        _this2.pushpinBillboardTool && _this2.pushpinBillboardTool.setDirty();\n        var selectedItem = _this2.pushPinManager ? _this2.pushPinManager.getSelectedItem() : null;\n\n        if (!selectedItem) {\n          return;\n        }\n\n        selectedItem.draggable && selectedItem.marker ?\n        _this2.enableItemDragging(selectedItem) :\n        _this2.disableItemDragging(selectedItem);\n      }, 1);\n    } }, { key: \"enableItemDragging\", value: function enableItemDragging(\n\n    item) {\n      this.pushpinBillboardTool.enableDragging(item);\n      this.inputHandler.attachTo(item.marker);\n    } }, { key: \"disableItemDragging\", value: function disableItemDragging(\n\n    item) {\n      this.pushpinBillboardTool.disableDragging(item);\n      this.inputHandler.detach();\n    } }, { key: \"onSection\", value: function onSection()\n\n    {\n    } }, { key: \"create\", value: function create(\n\n    item) {\n      // iOS have a special case where they already have the UUID, so we act like we are re-selecting an existing item\n      return this.createRenderItem(item, Autodesk.Viewing.isIOSDevice());\n    } }, { key: \"createRenderItem\", value: function createRenderItem(\n\n    item, reselect) {\n      // Make sure it's a uuid and not a growing counter\n      var isLoaded = item.data.id.length > 20;\n\n      // If we are actually creating a new pushpin (and not just loading one), make sure to deselect the previous selected one.\n      if (!isLoaded) {\n        this.pushpinBillboardTool.deselect();\n      }\n\n      var promise;\n      if (isLoaded && !reselect) {\n        promise = this.pushpinBillboardTool.loadPushpin(item);\n      } else {\n        promise = this.pushpinBillboardTool.createPushpin(item);\n        this.pushPinManager.selectOne(item.data.id);\n      }\n\n      return promise;\n    } }, { key: \"updatePattern\", value: function updatePattern(\n\n    status, size, hex) {\n      this.pushpinBillboardTool.updateStyle(status, size, hex);\n\n      this.setPushpinDirty();\n    } }, { key: \"render\", value: function render()\n\n    {var _this3 = this;\n      if (!this.pushPinManager || !this.viewer.model) {\n        return;\n      }\n\n      this.pushPinManager.items().reverse().forEach(function (item) {\n        if (!item.marker) {\n          _this3.createRenderItem(item, false);\n        }\n      });\n\n      if (this.pushpinDirty) {\n        this.pushpinBillboardTool.updatePushpins();\n        this.pushpinDirty = false;\n      }\n    } }, { key: \"findIntersections\", value: function findIntersections(\n\n    event) {\n      var mouseX = event.clientX;\n      var mouseY = event.clientY;\n\n      var hitItem = null;\n\n      this.pushPinManager.items().some(function (item) {\n        if (item.selectable && item.marker) {\n          var bb = item.marker.getBoundingClientRect();\n          if (mouseX > bb.left && mouseX < bb.left + bb.width && mouseY > bb.top && mouseY < bb.top + bb.height) {\n            hitItem = item;\n            return true;\n          }\n        }\n        return false;\n      });\n\n      return hitItem;\n    } }, { key: \"handleMouseMove\", value: function handleMouseMove(\n\n    e) {\n      var self = this;\n      function mouseCoords(ev) {\n        if (ev.pageX || ev.pageY) {\n          return { x: ev.pageX, y: ev.pageY };\n        }\n\n        var _document = self.getDocument();\n        return {\n          x: ev.clientX + _document.body.scrollLeft - _document.body.clientLeft,\n          y: ev.clientY + _document.body.scrollTop - _document.body.clientTop };\n\n      }\n\n      if (this.selectedItem.marker.startDragging) {\n        // only on first mouse movement\n        if (!this.newX) {\n          this.selectedItem.marker.style.transform = 'translate(0px, 0px)';\n        }\n\n        var mousePos = mouseCoords(e);\n\n        this.newX = mousePos.x - this.mouseOffset.x;\n        this.newY = mousePos.y - this.mouseOffset.y;\n\n        // Check left, top, right, bottom\n        var containerBounds = this.viewer.navigation.getScreenViewport();\n        var wi = this.selectedItem.marker.clientWidth;\n        var hi = this.selectedItem.marker.clientHeight;\n\n        if (this.newX < 5) {\n          this.newX = 0;\n        }\n        if (this.newY < 5) {\n          this.newY = 0;\n        }\n        if (containerBounds.width - 5 < this.newX + wi) {\n          this.newX = containerBounds.width - wi;\n        }\n        if (containerBounds.height - 5 < this.newY + hi) {\n          this.newY = containerBounds.height - hi;\n        }\n\n        this.selectedItem.marker.style.left = \"\".concat(this.newX, \"px\");\n        this.selectedItem.marker.style.top = \"\".concat(this.newY, \"px\");\n\n        var vpVec = this.viewer.impl.clientToViewport(this.newX + this.offsetWidth / 2, this.newY + this.offsetWidth / 2);\n        var res = this.viewer.impl.castRayViewport(vpVec, false);\n\n        !res && !this.pushPinManager.isPseudo2D ? this.selectedItem.marker.classList.add('grey-out') : this.selectedItem.marker.classList.remove('grey-out');\n\n        this.selectedItem.marker.dragging = true;\n      }\n    } }, { key: \"handleMouseUp\", value: function handleMouseUp(\n\n    e) {var _this4 = this;\n      if (this.selectedItem.marker.dragging) {\n        this.selectedItem.marker.style.left = '0px';\n        this.selectedItem.marker.style.top = '0px';\n        this.selectedItem.marker.style.transform = \"translate(\".concat(this.newX, \"px, \").concat(this.newY, \"px)\");\n\n        this.newX += this.offsetWidth / 2;\n        this.newY += this.offsetWidth / 2;\n\n        var result;\n        if (!this.pushPinManager.isPseudo2D) {\n          result = this.viewer.impl.clientToWorld(this.newX, this.newY);\n        } else {\n          result = {\n            point: this.viewer.impl.intersectGround(this.newX, this.newY) };\n\n        }\n\n        if (result) {\n          this.selectedItem.data.position = new THREE.Vector3(result.point.x, result.point.y, result.point.z);\n          invertModelTransform(this.selectedItem.data.position, result.model);\n          this.selectedItem.setSeedUrn(result.model.getSeedUrn());\n        }\n\n        this.pushpinBillboardTool.removePushpin(this.selectedItem);\n        var promise = this.createRenderItem(this.selectedItem, true);\n\n        if (result) {\n          promise.then(function () {return _this4.pushPinManager.generateThumbnail(_this4.selectedItem);}).\n          then(function (thumbnail) {\n            _this4.pushPinManager.fireEvent({ type: PUSHPIN_EVENTS.PUSH_PIN_MODIFY_EVENT, value: _this4.selectedItem, thumbnail: thumbnail });\n          });\n        }\n\n        this.selectedItem.marker.startDragging = false;\n        this.selectedItem.marker.dragging = false;\n\n        this.onUpdate();\n      } else {\n        this.selectedItem.marker.startDragging = false;\n      }\n    } }, { key: \"handleMouseDown\", value: function handleMouseDown(\n\n    event) {\n      function getPosition(e) {\n        var left = 0;\n        var top = 0;\n\n        while (e.offsetParent) {\n          left += e.offsetLeft;\n          top += e.offsetTop;\n          e = e.offsetParent;\n        }\n\n        left += e.offsetLeft;\n        top += e.offsetTop;\n        return { x: left, y: top };\n      }\n\n      function getMouseOffset(target, offsetWidth) {\n        var docPos = getPosition(target);\n\n        docPos.x += offsetWidth / 2;\n        docPos.y += offsetWidth / 2;\n        return { x: docPos.x, y: docPos.y };\n      }\n\n      if (event.target.tagName.toLowerCase() === 'textarea') {\n        return;\n      }\n\n      this.offsetWidth = this.selectedItem.selected ? markerOffsets.selectedMarkerOffsetWidth : markerOffsets.markerOffsetWidth;\n\n      this.mouseOffset = getMouseOffset(this.viewer.container, this.offsetWidth);\n\n      this.selectedItem.marker.style.opacity = '1.0';\n\n      this.newX = null;\n      this.newY = null;\n\n      this.selectedItem.marker.startDragging = true;\n    } }]);return RenderHandler3D;}();export { RenderHandler3D as default };\n\n\nav.GlobalManagerMixin.call(RenderHandler3D.prototype);","exports = module.exports = require(\"../../node_modules/css-loader/lib/css-base.js\")(false);\n// imports\n\n\n// module\nexports.push([module.id, \"/*<editor-fold desc=\\\"ISSUES\\\">*/\\n@font-face {\\n  font-family: 'issueicon';\\n  src: url(data:application/font-woff;charset=utf-8;base64,d09GRgABAAAAAAbIAAsAAAAABnwAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAABPUy8yAAABCAAAAGAAAABgDxIFlWNtYXAAAAFoAAAAVAAAAFQXQdKyZ2FzcAAAAbwAAAAIAAAACAAAABBnbHlmAAABxAAAAqAAAAKgxE+X+WhlYWQAAARkAAAANgAAADYKqzOVaGhlYQAABJwAAAAkAAAAJAfCA8dobXR4AAAEwAAAABgAAAAYDgAAAGxvY2EAAATYAAAADgAAAA4BeADcbWF4cAAABOgAAAAgAAAAIAAPAIBuYW1lAAAFCAAAAZ4AAAGeHnABF3Bvc3QAAAaoAAAAIAAAACAAAwAAAAMDVQGQAAUAAAKZAswAAACPApkCzAAAAesAMwEJAAAAAAAAAAAAAAAAAAAAARAAAAAAAAAAAAAAAAAAAAAAQAAA6RYDwP/AAEADwABAAAAAAQAAAAAAAAAAAAAAIAAAAAAAAwAAAAMAAAAcAAEAAwAAABwAAwABAAAAHAAEADgAAAAKAAgAAgACAAEAIOkW//3//wAAAAAAIOkV//3//wAB/+MW7wADAAEAAAAAAAAAAAAAAAEAAf//AA8AAQAAAAAAAAAAAAIAADc5AQAAAAABAAAAAAAAAAAAAgAANzkBAAAAAAEAAAAAAAAAAAACAAA3OQEAAAAACAAA//cEAAN3AAsAHgAyAE4AZABqAHQAfQAAASYiBwMGFjMhMjYnJzAiIyoBMTA0NTwBMTAyMzoBMTUwIiMqATEwND0BPAExMDIzOgExEyYiDwEuASMiDgIHMR4BFwcGFBcWMjcBNjQnASoBIyIGFRwBFQcuATU0PgIzMhYXAx4BMzcHJTEuAScHEz4BNwUHHgEXNy4BJwLeChcK1QoMEwGrEA8KxBYQEBcXEBAWFhAQFxcQEBavDSINxCdNKlaehWcgHV05lQ0NDSINA0QNDf5vAwcDOlM3BwYhOEoqECMNZwoPCTxeAisgaUBIqyAzE/2mXRMrFzwQGgoBohAQ/poQFxcQBBENDREmGxA3ExgCSA0NxAoQMlRyQDlqKZYNIg0MDANFDSIM/qtTOgMGAzgQIBArSzcgBwb+wAMBZmKEQHAqSf7jIEYmt14GDANiAwcHAAcAAAAVBAACzQAKABUAGgA0AEAAUwBnAAABIgYVFBYXNy4BIwchHgMXNy4BNSEjFz4BJzMuAyMiDgIHITQ+AjMyFhc3NjIfAScmIgcDBhYzITI2JycwIiMqATEwNDU8ATEwMjM6ATE1MCIjKgExMDQ9ATwBMTAyMzoBMQIAOlNPOnsTPibN/s0bU2p9RTtGXALNwFUkNKm8IGeFnlZWnoVnIAEzIThKKjBRHQgNLw1VZgoXCtUKDBMBqxAPCsQWEBAXFxAQFhYQEBcXEBAWAiJTOjlQA9UdJ402Y1A5DWMQc0mRI0gmQHJUMjJUckAsSjgfKCAMFxeRDRAQ/poQFxcQCBENDREiGxA3ExgAAAAAAQAAAAEAAOgguddfDzz1AAsEAAAAAADTxfeVAAAAANPF95UAAP/3BAADdwAAAAgAAgAAAAAAAAABAAADwP/AAAAEAAAAAAAEAAABAAAAAAAAAAAAAAAAAAAABgQAAAAAAAAAAAAAAAIAAAAEAAAABAAAAAAAAAAACgAUAB4AyAFQAAAAAQAAAAYAfgAIAAAAAAACAAAAAAAAAAAAAAAAAAAAAAAAAA4ArgABAAAAAAABAAkAAAABAAAAAAACAAcAcgABAAAAAAADAAkAPAABAAAAAAAEAAkAhwABAAAAAAAFAAsAGwABAAAAAAAGAAkAVwABAAAAAAAKABoAogADAAEECQABABIACQADAAEECQACAA4AeQADAAEECQADABIARQADAAEECQAEABIAkAADAAEECQAFABYAJgADAAEECQAGABIAYAADAAEECQAKADQAvGlzc3VlaWNvbgBpAHMAcwB1AGUAaQBjAG8AblZlcnNpb24gMS4wAFYAZQByAHMAaQBvAG4AIAAxAC4AMGlzc3VlaWNvbgBpAHMAcwB1AGUAaQBjAG8Abmlzc3VlaWNvbgBpAHMAcwB1AGUAaQBjAG8AblJlZ3VsYXIAUgBlAGcAdQBsAGEAcmlzc3VlaWNvbgBpAHMAcwB1AGUAaQBjAG8AbkZvbnQgZ2VuZXJhdGVkIGJ5IEljb01vb24uAEYAbwBuAHQAIABnAGUAbgBlAHIAYQB0AGUAZAAgAGIAeQAgAEkAYwBvAE0AbwBvAG4ALgAAAAMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=);\\n  font-weight: normal;\\n  font-style: normal; }\\n\\n[class^=\\\"issueicon-\\\"], [class*=\\\" issueicon-\\\"] {\\n  font-family: 'issueicon';\\n  font-style: normal;\\n  font-weight: normal;\\n  font-variant: normal;\\n  line-height: 1;\\n  padding-top: 2px;\\n  speak: none;\\n  text-transform: none;\\n  /* Better Font Rendering =========== */\\n  -webkit-font-smoothing: antialiased;\\n  -moz-osx-font-smoothing: grayscale; }\\n\\n@font-face {\\n  font-family: 'rfiicon';\\n  src: url(data:application/font-woff;charset=utf-8;base64,d09GRk9UVE8AAAswAAsAAAAAEmAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAABDRkYgAAABCAAACA8AAA2TY1sJ2EZGVE0AAAkYAAAAGgAAABx62YowR0RFRgAACTQAAAAbAAAAHgAnAAtPUy8yAAAJUAAAAEsAAABgVnlR5GNtYXAAAAmcAAAAQAAAAVIAM+PPaGVhZAAACdwAAAAwAAAANgwjbUZoaGVhAAAKDAAAAB0AAAAkB5sEBGhtdHgAAAosAAAAEAAAABAKKACSbWF4cAAACjwAAAAGAAAABgAFUABuYW1lAAAKRAAAAOAAAAGJyIp2aHBvc3QAAAskAAAADAAAACAAAwAAeJzNV3lQVdcZP+/xNh/wlOUBEsqiIxa1SbMAEg0YoKgRl6QUlWHcAiqWQINLJmEsMWIiuaYxBRNBQFCSWGiVqJOKIMuo2BYtcaImyGhiG3DEhYgo+/v6++6976kzOplO/+mb4czvnvPdb/9+56IROp3QaDSmrJVpaa9mZgiNVmhEZL+/tj/Aqd9HJ7k4SS46f7MYtSHxKUlyABfjoW2DOQPX9H6iYrSfEGP8xF/c/ISrn2ucu9CzDosIFM+ICDFjNtSuXfpK3Gz+u//w69WZbzy8MystJZWB6ordI/w0mvc0WzV5imKt0GkHDLddJMs9C2lyP8DSlJtkJchFG0kY3NJIaL10JHSfLiPhVLQEyzsuJPT+R4DSahnVkNActkE4K0MiYdxvxWoqO0E0UrMIu9dPEQ1JMZCcnwyU1cPoCaKBY71Q8XIlUd+3+VCRbsLpjZdg+iPs3TlxCWjWYaLrJa9LOPq2YRpRg+sCEhMmNRlI+FijYGe0x3q86qyFzgEv2VUTaYN/dojE37YelsPQkAjJhLnLwZ+TCGpbRHThT1OhcOTF8QkGPGzvIOV3OXifvEjypolsEDCqZxe2d6ovsxQrhAZt/YkkAz/48tliRYAfA8gW6oOQlr611Ep0vEULle0HSkmEN0brEdoT40l4XAtH4E9+QsJl8zcIPHoeQgh3tiOklwYHCpWU02B1BaLsWOZAy/Huh1AoeqqJejPaOEF3L14h2vHCU0RnGjb2FZBI+yoI7vlue0lNg8fCVtSkfBZMmnO4ErcZNQEllZEYVdWsVsL43DEojQwDmmthFKq60VOeh0h+PJeN9UbjSXjzdjSeJ0HZXQF0J/sqoxdV1L3zPFH/qKlEXU+vJhpuRubMV6eg8uuj0CHXjuK0JRZW/NYARRSaGP6WYRHcyU6BwZ8/rTp7w+vvOP5h9WES/zStRYfRuaotRO/t95SAj6cdJbGqq0my7+9EcwDnR02TsyFJfQV60uiOHZRTYR0qUJNkRL/bfMtIO6myycqFrkfGZqYuUzMWcSGOqLk2BapqYouR43Nj29EzZ92CFQFqKyzipVDizYkQOP+bKPTMkaLdqkBzCEYkInYXWjWuNtXEawrr/RXvFrOt5f44q1z+D8W8vOhJfB3che1Dl1DNN6cAzXt5IlHy65UwoW0UcHL9xXKi3X+s5i7bTZTnu0RdeI/Ktuwhen9CAHTT+xmeELrTj90SzMWG4luwUToATZWVTXB2SuMJSMWPO0viXZ7VL05NJrH3D4kwOvU80Gf7FEdw2gzHoqaj2UTLL4PIFnwgGV7bXk1AW/1ur9JbZHumB7XuiwfqtT2I+t+ZB8MZieiOu5u4YW+uySERuAXJ9ijbjJDMEwKUaRMGZI2oNRmtPnIQ6K/xICCPL4ESQUVOgWg92xx0jjYOIzuy6BWgJxNVpBkPd4Y33kFMQ7WfYR0OnYEXJ5QrHYgXnWR3EUTnypUkctcdA094VkHdmH40bLcxHZyTkA1fAksO2gngekIdH73Gy2T5HBHYykoOGpQzpdp8Bi35EivcAgvfrZhnVHvJsypGPlPM8DnncVNuEtGkykaFcfGevyVRmTEwXHcp2GLQcA3T0JuNcEKGkZobJg6PqfPfHnKgjNx5nL+ws8VOGHGKABeZ0VBCU/xnTNvE17A3lApqycGeIZo5PKdBRWgpzF6fGfZH5a9nEv9Yp1RSGGrHw0pqOcSvINbhuSBg/fcnVZ7SeaCtBm7t5FKsNDH8RIZE9xKeV2vRU9PO1W7xbh1CI441/kgi9M12meNQdH31CtjTxfogye+i07Sf7wdync/oAKPRQB8mszegK+2SI1y8igeRbh2aa6A+lC+gTBh2jkVe8xd+gP7dlGcNNIMIIzeAGUufs/Z5EnV+Vz/kyXM/n2+iyuPu6uBx/qEMFMGJRuJHzlaqBDtSU2RH6h7iSdmEdKQULoJk99snVbbriHGX+Hkzqrxqsknpd77Q9IqAGJMzHeH61t2UBfh5I7zdCi4UeZoWSFU5nyIRlltCVJe6h0R8hz/RN7uukkh461+Pn0gSMS1aHhncCTFgfYU5I3ky4RIs7OLrZ9fvB/Vscppq3LfuliS7IDtnUm9euKxXBDgwSdaghofAcHFuG/cV2XaPXawkToI1unob1NfZBbIuDsFt2Ybyem/eQXTJKQFqI+do5QXh9b0xh4RbFi6Bob07MPiWNnjgkfm95GDGODszzrXw0cTJWN0vh+GFr/vw6uJ2vqUKWCtIRUS5LtCzGejy2ncXqRq3Xb3ULszsZsf2mx7FiwGktX65lURN8k1M3oyLOD/dEUDiWSbcBu7DoGWC6Gh4vINwhY8bgvrhsvqR4n16Nl9u4bC7vRNUULEgiJcVfDXJ7TRn1lp5QS69vMGB/UWon7f5BZ4hdLf381fs7ik03Jocgldbt53hCxhkczbrFyQsprUm0iSdn4HrbbG38j0jqSOtTIVCvhUP0/DM/18a3uOgYa3s+H0arrM6SJJbLQBdeX36GgcNqwycfp+B/R8kYOWnEnDBf03ATQ8RsF59RSb1e2c+QiGGxjEVd6lU/FOk3Osg5epHkHKDg5TTHaTc4CDl+odJ2Vkm5XWPIuU9Mimb1I56DCs7SHnV/0LKMhUvcNCzxUHKPQ4q3vsIUg5zkHLMY0g51Crh60zhZUka8tRbBgs8+0OskosZ/wF58L9T05WRgkfW0lB5XFgQXgdG4yNPhKVjeRa9bBc4bc5h7L8wXu/8Hx99d3AAeJxjYGBgZACCi88SbUH0lcoplTAaAEwCBwsAAHicY2BkYGDgAWIxIGZiYARCFjAG8RgAA8oAMwB4nGNgZp7JOIGBlYGDaSbTGQYGhn4IzfiawZiRk4GBiYGVmQEGGAUYECAgzTWFwYFB4QEz84H/BxhimEP+/wepgStQAEJGAKiDDfoAeJxjYGBgZoBgGQZGBhDwAfIYwXwWBgMgzQGETGAZhQfM//9DWYwg1v+HCoxQXWDAyMaAzMUKCMkPdQAA6jkI4XicY2BkYGAAYiWvHx7x/DZfGbhZGEDgSuWUKjitwcDI/Io5BMjlYGACiQIAFHsJinicY2BkYGAOYWBgiGFhAAHmVwyMDKiAGQAmnQGqAAAABAAAAAIAAAAEAABVACgAPQAAUAAABQAAeJx1jj1uwjAYhp9AoEKtqk5VRw8MXRLFHhg4QNSZgR0hE0VCRDKwcJCuPULHHqMH6BF6ib4J39IBW/78+PX7/QAPvJPRr4w7noxH4lfjMXMuxrn0T+MJ93wbT6X/ypnlMymPQ1bPI/GL8Zg3KuNc+ofxhGe+jKfSf0jsaLW3dBwg7dp22wlWRBrO7NnIwyo25/1GUA++03AnOSKOQKlujqXO/3pXzbOgUAyKQc7+Td0dTnWXmuhCWbmls84ivyh8KELl5bo13lqNE0f9XNv4YQTWMR1bFfFldTP3D4aYOgJ4nGNgZsALAAB9AAQ=);\\n  font-weight: normal;\\n  font-style: normal; }\\n\\n[class^=\\\"rfiicon-\\\"], [class*=\\\" rfiicon-\\\"] {\\n  font-family: 'rfiicon';\\n  font-style: normal;\\n  font-weight: normal;\\n  font-variant: normal;\\n  line-height: 1;\\n  padding-top: 2px;\\n  speak: none;\\n  text-transform: none;\\n  /* Better Font Rendering =========== */\\n  -webkit-font-smoothing: antialiased;\\n  -moz-osx-font-smoothing: grayscale; }\\n\\n@font-face {\\n  font-family: 'fieldissueicon';\\n  src: url(data:application/font-woff;charset=utf-8;base64,d09GRgABAAAAAAUAAA0AAAAAByQAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAABGRlRNAAAE5AAAABwAAAAcfzoDmUdERUYAAATIAAAAGwAAAB4AJwALT1MvMgAAAZwAAABKAAAAYC+xTDxjbWFwAAAB+AAAAEQAAAFKwBQjvWdhc3AAAATAAAAACAAAAAj//wADZ2x5ZgAAAkgAAAFeAAABhPocpV5oZWFkAAABMAAAADAAAAA2DEAuiWhoZWEAAAFgAAAAHAAAACQEIwIFaG10eAAAAegAAAAQAAAAEgYAAABsb2NhAAACPAAAAAwAAAAMAFgAwm1heHAAAAF8AAAAHgAAACAATgBKbmFtZQAAA6gAAADjAAAB47FU88Bwb3N0AAAEjAAAADIAAABR2shGr3icY2BkYGAA4uk3ErPi+W2+MnAzMYDAVZ+8TjB9te4fkGJnYmAE0RwMYGkALxEKOXicY2BkYGD8wsDAoMfEAAJAkpEBFbAAACM+AS54nGNgZGBgYGVwZ2BnAAEmIGZkAIk5gPkMAApQAJkAAHicY2BmYmCcwMDKwMHow5jGwMDgDqW/MkgytDAwMDGwcjLAgQCCyRCQ5prC4PCA8QET44P/Dxj0GL/8/wIUZkRSosDACAAr1Q1fAAB4nGNigAAmKGZgAAAAVgAHeJzdisEJwDAQw+RLyRR59NlBuv8M2STxpaWQFSowRiCg8Kwhktum5QeXv/pFQI8xMujKP+PtjSqfyGXWG+L3TGW0BrEAAAAAAAAAAABYAMJ4nG2PvU7CUBiGv4+fcyhwSiH0HAg/ASptKLQ1LaVoDTHGOOjohAnizwW46AU4GBNnZx2dZfQKSJzYvQYHE1fi0dnhXZ68w/NAGgBoAvAWmmDDCLZhAhC5SSua0MAXhtlHF40O0ctchC6Gw5GkhBrC53qgG2EggdCDkMp9j+db7RSheV20Nmy/9nRRV6unuaDdiwOz0rLqdkml/kJhfCGYwh3HOUuYoVvMKKxS4kU1c8eb3bhnjdOdVLdas7okL3/LpcIG0+mV48Cvq1wev3ANJWhDD3zpuwcHAGgW0JSilAtKBPcjHKX/ZKmEDaRDUxgdK+IxRjIj4sI06D8N+K5q56PK8UO7GR8WCqRI8Flbv04GZdYgzX4jcY2e45WrOMfkbtTKcZFllTfBssLzPPzUtEt2sh8PjrQCIfiifvR3aN1ukDqtPmpu7h4JToxN5rHsapVl7mx247o/vPQ77AAAeJyVj8FKw0AURc+0aUAUiht3ltnLhGQgCAXd2U/IFzQtgZJAmv6KOz/IT/ET3HmnPhe6EDrwmDN37rvzBrjhFUdajiXeeEbOs/GcB96MM3k+jBdcu1vjnKV7ktNlV1JW567EM+WXxnMaXowzed6NF9zxaZyzcvec6JnoVAdatgR2DGctUMGpn7rp0G7DbuinIOHX7Y+4MTHtI3sFeSKFxvGsVf8/8u2J1DqliuqreFSs4jfDuG99LEq/9n+GkRLrUIdYVjJf+pFGrpGjOpLLy5PmpWnHYzf0virKizO/AEzyTYUAeJxjYGJABowM6IAVLMrEyMTIzJ+WmZqToptZXFyaqpuZnCeCzM9PSwOK5ecBAP6rDY8AAAAAAAH//wACeJxjYGRgYOABYjEgZmJgBEIWMAbxGAADygAzAAAAAAEAAAAA1BgWEQAAAADVTG6JAAAAANXVfv4=);\\n  font-weight: normal;\\n  font-style: normal; }\\n\\n[class^=\\\"fieldissueicon-\\\"], [class*=\\\" fieldissueicon-\\\"] {\\n  font-family: 'fieldissueicon';\\n  font-style: normal;\\n  font-weight: normal;\\n  font-variant: normal;\\n  line-height: 1;\\n  padding-top: 2px;\\n  speak: none;\\n  text-transform: none;\\n  /* Better Font Rendering =========== */\\n  -webkit-font-smoothing: antialiased;\\n  -moz-osx-font-smoothing: grayscale; }\\n\\n.issueicon-issue_hide:before {\\n  content: \\\"\\\\E915\\\"; }\\n\\n.issueicon-issue_normal:before {\\n  content: \\\"\\\\E916\\\"; }\\n\\n.rfiicon-rfi_hide:before {\\n  content: \\\"\\\\E003\\\"; }\\n\\n.rfiicon-rfi_normal:before {\\n  content: \\\"\\\\E002\\\"; }\\n\\n.fieldissueicon-issue_hide:before {\\n  content: \\\"\\\\E002\\\"; }\\n\\n.fieldissueicon-issue_normal:before {\\n  content: \\\"\\\\E001\\\"; }\\n\\n.leaflet-text-label {\\n  display: inherit;\\n  font-family: 'HelveticaNeue-bold';\\n  font-style: normal;\\n  font-weight: normal;\\n  font-variant: normal;\\n  line-height: 0;\\n  pointer-events: none;\\n  /*margin-top: 40px;\\n    margin-left:-20px;*/\\n  text-align: center;\\n  font-size: 16px;\\n  border-radius: .5em;\\n  max-width: auto;\\n  min-width: 60px;\\n  /*real width = width + border*2*/\\n  height: 32px;\\n  /*real height = height + border*2*/\\n  position: absolute;\\n  background-color: rgba(0, 0, 0, 0.7);\\n  color: #FFF;\\n  border: 2px solid white; }\\n\\n.leaflet-marker-icon.leaflet-pin-icon {\\n  width: 40px; }\\n\\n.leaflet-text-label span {\\n  display: inline-block;\\n  vertical-align: middle;\\n  line-height: 32px;\\n  white-space: pre; }\\n\\n.leaflet-pushpin-hidden {\\n  visibility: hidden; }\\n\\n/* disable push pin visible button's border*/\\n#toolbar-pushpinVis, #toolbar-pushpinRfisVis, #toolbar-pushpinFieldIssuesVis {\\n  border: none; }\\n\\n/*</editor-fold>*/\\n/*<editor-fold desc=\\\"PUSHPIN BILLBOARD (3D)\\\">*/\\n.pushpin-billboard-marker {\\n  position: absolute;\\n  font-size: 10px;\\n  font-weight: bold;\\n  width: 22px;\\n  height: 22px;\\n  left: 0;\\n  top: 0;\\n  line-height: 16px;\\n  text-align: center;\\n  cursor: pointer;\\n  pointer-events: none;\\n  color: #1757a8;\\n  border: 4px solid rgba(255, 255, 255, 0.95);\\n  background: #4675A8 no-repeat center;\\n  background-size: 16px;\\n  border-radius: 15px;\\n  opacity: 1;\\n  transition: opacity 0.4s;\\n  -webkit-transition: opacity 0.4s;\\n  /* Used to optimize transform changes. Improves performance dramatically! */\\n  will-change: transform; }\\n\\n.rfi-billboard-marker {\\n  position: absolute;\\n  font-size: 10px;\\n  font-weight: bold;\\n  width: 22px;\\n  height: 22px;\\n  line-height: 16px;\\n  text-align: center;\\n  cursor: pointer;\\n  pointer-events: none;\\n  left: 0;\\n  top: 0;\\n  color: #1757a8;\\n  border: 4px solid rgba(255, 255, 255, 0.95);\\n  background: #4675A8 no-repeat center;\\n  background-size: 16px;\\n  border-radius: 3px;\\n  opacity: 1;\\n  transition: opacity 0.4s;\\n  -webkit-transition: opacity 0.4s;\\n  /* Used to optimize transform changes. Improves performance dramatically! */\\n  will-change: transform; }\\n\\n.pushpin-billboard-marker.selected {\\n  border: 5px solid rgba(255, 255, 255, 0.95);\\n  border-radius: 20px;\\n  background-size: 20px;\\n  z-index: 1;\\n  top: -3px;\\n  width: 28px;\\n  height: 28px;\\n  left: -3px; }\\n\\n.rfi-billboard-marker.selected {\\n  border: 5px solid rgba(255, 255, 255, 0.95);\\n  border-radius: 4px;\\n  background-size: 20px;\\n  z-index: 1;\\n  top: -3px;\\n  width: 28px;\\n  height: 28px;\\n  left: -3px; }\\n\\n.pushpin-billboard-marker.grey-out {\\n  background-color: #919191 !important;\\n  opacity: 0.5 !important;\\n  cursor: not-allowed; }\\n\\n.rfi-billboard-marker.grey-out {\\n  background-color: #919191 !important;\\n  opacity: 0.5 !important;\\n  cursor: not-allowed; }\\n\\n.pushpin-container {\\n  will-change: transform;\\n  transform: translateZ(0);\\n  left: 0;\\n  top: 0;\\n  position: absolute; }\\n\\n/*</editor-fold>*/\\n\", \"\"]);\n\n// exports\n","/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n// css base code, injected by the css-loader\nmodule.exports = function(useSourceMap) {\n\tvar list = [];\n\n\t// return the list of modules as css string\n\tlist.toString = function toString() {\n\t\treturn this.map(function (item) {\n\t\t\tvar content = cssWithMappingToString(item, useSourceMap);\n\t\t\tif(item[2]) {\n\t\t\t\treturn \"@media \" + item[2] + \"{\" + content + \"}\";\n\t\t\t} else {\n\t\t\t\treturn content;\n\t\t\t}\n\t\t}).join(\"\");\n\t};\n\n\t// import a list of modules into the list\n\tlist.i = function(modules, mediaQuery) {\n\t\tif(typeof modules === \"string\")\n\t\t\tmodules = [[null, modules, \"\"]];\n\t\tvar alreadyImportedModules = {};\n\t\tfor(var i = 0; i < this.length; i++) {\n\t\t\tvar id = this[i][0];\n\t\t\tif(typeof id === \"number\")\n\t\t\t\talreadyImportedModules[id] = true;\n\t\t}\n\t\tfor(i = 0; i < modules.length; i++) {\n\t\t\tvar item = modules[i];\n\t\t\t// skip already imported module\n\t\t\t// this implementation is not 100% perfect for weird media query combinations\n\t\t\t//  when a module is imported multiple times with different media queries.\n\t\t\t//  I hope this will never occur (Hey this way we have smaller bundles)\n\t\t\tif(typeof item[0] !== \"number\" || !alreadyImportedModules[item[0]]) {\n\t\t\t\tif(mediaQuery && !item[2]) {\n\t\t\t\t\titem[2] = mediaQuery;\n\t\t\t\t} else if(mediaQuery) {\n\t\t\t\t\titem[2] = \"(\" + item[2] + \") and (\" + mediaQuery + \")\";\n\t\t\t\t}\n\t\t\t\tlist.push(item);\n\t\t\t}\n\t\t}\n\t};\n\treturn list;\n};\n\nfunction cssWithMappingToString(item, useSourceMap) {\n\tvar content = item[1] || '';\n\tvar cssMapping = item[3];\n\tif (!cssMapping) {\n\t\treturn content;\n\t}\n\n\tif (useSourceMap && typeof btoa === 'function') {\n\t\tvar sourceMapping = toComment(cssMapping);\n\t\tvar sourceURLs = cssMapping.sources.map(function (source) {\n\t\t\treturn '/*# sourceURL=' + cssMapping.sourceRoot + source + ' */'\n\t\t});\n\n\t\treturn [content].concat(sourceURLs).concat([sourceMapping]).join('\\n');\n\t}\n\n\treturn [content].join('\\n');\n}\n\n// Adapted from convert-source-map (MIT)\nfunction toComment(sourceMap) {\n\t// eslint-disable-next-line no-undef\n\tvar base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));\n\tvar data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;\n\n\treturn '/*# ' + data + ' */';\n}\n","/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\nvar stylesInDom = {};\n\nvar\tmemoize = function (fn) {\n\tvar memo;\n\n\treturn function () {\n\t\tif (typeof memo === \"undefined\") memo = fn.apply(this, arguments);\n\t\treturn memo;\n\t};\n};\n\nvar isOldIE = memoize(function () {\n\t// Test for IE <= 9 as proposed by Browserhacks\n\t// @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805\n\t// Tests for existence of standard globals is to allow style-loader\n\t// to operate correctly into non-standard environments\n\t// @see https://github.com/webpack-contrib/style-loader/issues/177\n\treturn window && document && document.all && !window.atob;\n});\n\nvar getTarget = function (target, parent) {\n  if (parent){\n    return parent.querySelector(target);\n  }\n  return document.querySelector(target);\n};\n\nvar getElement = (function (fn) {\n\tvar memo = {};\n\n\treturn function(target, parent) {\n                // If passing function in options, then use it for resolve \"head\" element.\n                // Useful for Shadow Root style i.e\n                // {\n                //   insertInto: function () { return document.querySelector(\"#foo\").shadowRoot }\n                // }\n                if (typeof target === 'function') {\n                        return target();\n                }\n                if (typeof memo[target] === \"undefined\") {\n\t\t\tvar styleTarget = getTarget.call(this, target, parent);\n\t\t\t// Special case to return head of iframe instead of iframe itself\n\t\t\tif (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {\n\t\t\t\ttry {\n\t\t\t\t\t// This will throw an exception if access to iframe is blocked\n\t\t\t\t\t// due to cross-origin restrictions\n\t\t\t\t\tstyleTarget = styleTarget.contentDocument.head;\n\t\t\t\t} catch(e) {\n\t\t\t\t\tstyleTarget = null;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmemo[target] = styleTarget;\n\t\t}\n\t\treturn memo[target]\n\t};\n})();\n\nvar singleton = null;\nvar\tsingletonCounter = 0;\nvar\tstylesInsertedAtTop = [];\n\nvar\tfixUrls = require(\"./urls\");\n\nmodule.exports = function(list, options) {\n\tif (typeof DEBUG !== \"undefined\" && DEBUG) {\n\t\tif (typeof document !== \"object\") throw new Error(\"The style-loader cannot be used in a non-browser environment\");\n\t}\n\n\toptions = options || {};\n\n\toptions.attrs = typeof options.attrs === \"object\" ? options.attrs : {};\n\n\t// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\n\t// tags it will allow on a page\n\tif (!options.singleton && typeof options.singleton !== \"boolean\") options.singleton = isOldIE();\n\n\t// By default, add <style> tags to the <head> element\n        if (!options.insertInto) options.insertInto = \"head\";\n\n\t// By default, add <style> tags to the bottom of the target\n\tif (!options.insertAt) options.insertAt = \"bottom\";\n\n\tvar styles = listToStyles(list, options);\n\n\taddStylesToDom(styles, options);\n\n\treturn function update (newList) {\n\t\tvar mayRemove = [];\n\n\t\tfor (var i = 0; i < styles.length; i++) {\n\t\t\tvar item = styles[i];\n\t\t\tvar domStyle = stylesInDom[item.id];\n\n\t\t\tdomStyle.refs--;\n\t\t\tmayRemove.push(domStyle);\n\t\t}\n\n\t\tif(newList) {\n\t\t\tvar newStyles = listToStyles(newList, options);\n\t\t\taddStylesToDom(newStyles, options);\n\t\t}\n\n\t\tfor (var i = 0; i < mayRemove.length; i++) {\n\t\t\tvar domStyle = mayRemove[i];\n\n\t\t\tif(domStyle.refs === 0) {\n\t\t\t\tfor (var j = 0; j < domStyle.parts.length; j++) domStyle.parts[j]();\n\n\t\t\t\tdelete stylesInDom[domStyle.id];\n\t\t\t}\n\t\t}\n\t};\n};\n\nfunction addStylesToDom (styles, options) {\n\tfor (var i = 0; i < styles.length; i++) {\n\t\tvar item = styles[i];\n\t\tvar domStyle = stylesInDom[item.id];\n\n\t\tif(domStyle) {\n\t\t\tdomStyle.refs++;\n\n\t\t\tfor(var j = 0; j < domStyle.parts.length; j++) {\n\t\t\t\tdomStyle.parts[j](item.parts[j]);\n\t\t\t}\n\n\t\t\tfor(; j < item.parts.length; j++) {\n\t\t\t\tdomStyle.parts.push(addStyle(item.parts[j], options));\n\t\t\t}\n\t\t} else {\n\t\t\tvar parts = [];\n\n\t\t\tfor(var j = 0; j < item.parts.length; j++) {\n\t\t\t\tparts.push(addStyle(item.parts[j], options));\n\t\t\t}\n\n\t\t\tstylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};\n\t\t}\n\t}\n}\n\nfunction listToStyles (list, options) {\n\tvar styles = [];\n\tvar newStyles = {};\n\n\tfor (var i = 0; i < list.length; i++) {\n\t\tvar item = list[i];\n\t\tvar id = options.base ? item[0] + options.base : item[0];\n\t\tvar css = item[1];\n\t\tvar media = item[2];\n\t\tvar sourceMap = item[3];\n\t\tvar part = {css: css, media: media, sourceMap: sourceMap};\n\n\t\tif(!newStyles[id]) styles.push(newStyles[id] = {id: id, parts: [part]});\n\t\telse newStyles[id].parts.push(part);\n\t}\n\n\treturn styles;\n}\n\nfunction insertStyleElement (options, style) {\n\tvar target = getElement(options.insertInto)\n\n\tif (!target) {\n\t\tthrow new Error(\"Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.\");\n\t}\n\n\tvar lastStyleElementInsertedAtTop = stylesInsertedAtTop[stylesInsertedAtTop.length - 1];\n\n\tif (options.insertAt === \"top\") {\n\t\tif (!lastStyleElementInsertedAtTop) {\n\t\t\ttarget.insertBefore(style, target.firstChild);\n\t\t} else if (lastStyleElementInsertedAtTop.nextSibling) {\n\t\t\ttarget.insertBefore(style, lastStyleElementInsertedAtTop.nextSibling);\n\t\t} else {\n\t\t\ttarget.appendChild(style);\n\t\t}\n\t\tstylesInsertedAtTop.push(style);\n\t} else if (options.insertAt === \"bottom\") {\n\t\ttarget.appendChild(style);\n\t} else if (typeof options.insertAt === \"object\" && options.insertAt.before) {\n\t\tvar nextSibling = getElement(options.insertAt.before, target);\n\t\ttarget.insertBefore(style, nextSibling);\n\t} else {\n\t\tthrow new Error(\"[Style Loader]\\n\\n Invalid value for parameter 'insertAt' ('options.insertAt') found.\\n Must be 'top', 'bottom', or Object.\\n (https://github.com/webpack-contrib/style-loader#insertat)\\n\");\n\t}\n}\n\nfunction removeStyleElement (style) {\n\tif (style.parentNode === null) return false;\n\tstyle.parentNode.removeChild(style);\n\n\tvar idx = stylesInsertedAtTop.indexOf(style);\n\tif(idx >= 0) {\n\t\tstylesInsertedAtTop.splice(idx, 1);\n\t}\n}\n\nfunction createStyleElement (options) {\n\tvar style = document.createElement(\"style\");\n\n\tif(options.attrs.type === undefined) {\n\t\toptions.attrs.type = \"text/css\";\n\t}\n\n\tif(options.attrs.nonce === undefined) {\n\t\tvar nonce = getNonce();\n\t\tif (nonce) {\n\t\t\toptions.attrs.nonce = nonce;\n\t\t}\n\t}\n\n\taddAttrs(style, options.attrs);\n\tinsertStyleElement(options, style);\n\n\treturn style;\n}\n\nfunction createLinkElement (options) {\n\tvar link = document.createElement(\"link\");\n\n\tif(options.attrs.type === undefined) {\n\t\toptions.attrs.type = \"text/css\";\n\t}\n\toptions.attrs.rel = \"stylesheet\";\n\n\taddAttrs(link, options.attrs);\n\tinsertStyleElement(options, link);\n\n\treturn link;\n}\n\nfunction addAttrs (el, attrs) {\n\tObject.keys(attrs).forEach(function (key) {\n\t\tel.setAttribute(key, attrs[key]);\n\t});\n}\n\nfunction getNonce() {\n\tif (typeof __webpack_nonce__ === 'undefined') {\n\t\treturn null;\n\t}\n\n\treturn __webpack_nonce__;\n}\n\nfunction addStyle (obj, options) {\n\tvar style, update, remove, result;\n\n\t// If a transform function was defined, run it on the css\n\tif (options.transform && obj.css) {\n\t    result = typeof options.transform === 'function'\n\t\t ? options.transform(obj.css) \n\t\t : options.transform.default(obj.css);\n\n\t    if (result) {\n\t    \t// If transform returns a value, use that instead of the original css.\n\t    \t// This allows running runtime transformations on the css.\n\t    \tobj.css = result;\n\t    } else {\n\t    \t// If the transform function returns a falsy value, don't add this css.\n\t    \t// This allows conditional loading of css\n\t    \treturn function() {\n\t    \t\t// noop\n\t    \t};\n\t    }\n\t}\n\n\tif (options.singleton) {\n\t\tvar styleIndex = singletonCounter++;\n\n\t\tstyle = singleton || (singleton = createStyleElement(options));\n\n\t\tupdate = applyToSingletonTag.bind(null, style, styleIndex, false);\n\t\tremove = applyToSingletonTag.bind(null, style, styleIndex, true);\n\n\t} else if (\n\t\tobj.sourceMap &&\n\t\ttypeof URL === \"function\" &&\n\t\ttypeof URL.createObjectURL === \"function\" &&\n\t\ttypeof URL.revokeObjectURL === \"function\" &&\n\t\ttypeof Blob === \"function\" &&\n\t\ttypeof btoa === \"function\"\n\t) {\n\t\tstyle = createLinkElement(options);\n\t\tupdate = updateLink.bind(null, style, options);\n\t\tremove = function () {\n\t\t\tremoveStyleElement(style);\n\n\t\t\tif(style.href) URL.revokeObjectURL(style.href);\n\t\t};\n\t} else {\n\t\tstyle = createStyleElement(options);\n\t\tupdate = applyToTag.bind(null, style);\n\t\tremove = function () {\n\t\t\tremoveStyleElement(style);\n\t\t};\n\t}\n\n\tupdate(obj);\n\n\treturn function updateStyle (newObj) {\n\t\tif (newObj) {\n\t\t\tif (\n\t\t\t\tnewObj.css === obj.css &&\n\t\t\t\tnewObj.media === obj.media &&\n\t\t\t\tnewObj.sourceMap === obj.sourceMap\n\t\t\t) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tupdate(obj = newObj);\n\t\t} else {\n\t\t\tremove();\n\t\t}\n\t};\n}\n\nvar replaceText = (function () {\n\tvar textStore = [];\n\n\treturn function (index, replacement) {\n\t\ttextStore[index] = replacement;\n\n\t\treturn textStore.filter(Boolean).join('\\n');\n\t};\n})();\n\nfunction applyToSingletonTag (style, index, remove, obj) {\n\tvar css = remove ? \"\" : obj.css;\n\n\tif (style.styleSheet) {\n\t\tstyle.styleSheet.cssText = replaceText(index, css);\n\t} else {\n\t\tvar cssNode = document.createTextNode(css);\n\t\tvar childNodes = style.childNodes;\n\n\t\tif (childNodes[index]) style.removeChild(childNodes[index]);\n\n\t\tif (childNodes.length) {\n\t\t\tstyle.insertBefore(cssNode, childNodes[index]);\n\t\t} else {\n\t\t\tstyle.appendChild(cssNode);\n\t\t}\n\t}\n}\n\nfunction applyToTag (style, obj) {\n\tvar css = obj.css;\n\tvar media = obj.media;\n\n\tif(media) {\n\t\tstyle.setAttribute(\"media\", media)\n\t}\n\n\tif(style.styleSheet) {\n\t\tstyle.styleSheet.cssText = css;\n\t} else {\n\t\twhile(style.firstChild) {\n\t\t\tstyle.removeChild(style.firstChild);\n\t\t}\n\n\t\tstyle.appendChild(document.createTextNode(css));\n\t}\n}\n\nfunction updateLink (link, options, obj) {\n\tvar css = obj.css;\n\tvar sourceMap = obj.sourceMap;\n\n\t/*\n\t\tIf convertToAbsoluteUrls isn't defined, but sourcemaps are enabled\n\t\tand there is no publicPath defined then lets turn convertToAbsoluteUrls\n\t\ton by default.  Otherwise default to the convertToAbsoluteUrls option\n\t\tdirectly\n\t*/\n\tvar autoFixUrls = options.convertToAbsoluteUrls === undefined && sourceMap;\n\n\tif (options.convertToAbsoluteUrls || autoFixUrls) {\n\t\tcss = fixUrls(css);\n\t}\n\n\tif (sourceMap) {\n\t\t// http://stackoverflow.com/a/26603875\n\t\tcss += \"\\n/*# sourceMappingURL=data:application/json;base64,\" + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + \" */\";\n\t}\n\n\tvar blob = new Blob([css], { type: \"text/css\" });\n\n\tvar oldSrc = link.href;\n\n\tlink.href = URL.createObjectURL(blob);\n\n\tif(oldSrc) URL.revokeObjectURL(oldSrc);\n}\n","\n/**\n * When source maps are enabled, `style-loader` uses a link element with a data-uri to\n * embed the css on the page. This breaks all relative urls because now they are relative to a\n * bundle instead of the current page.\n *\n * One solution is to only use full urls, but that may be impossible.\n *\n * Instead, this function \"fixes\" the relative urls to be absolute according to the current page location.\n *\n * A rudimentary test suite is located at `test/fixUrls.js` and can be run via the `npm test` command.\n *\n */\n\nmodule.exports = function (css) {\n  // get current location\n  var location = typeof window !== \"undefined\" && window.location;\n\n  if (!location) {\n    throw new Error(\"fixUrls requires window.location\");\n  }\n\n\t// blank or null?\n\tif (!css || typeof css !== \"string\") {\n\t  return css;\n  }\n\n  var baseUrl = location.protocol + \"//\" + location.host;\n  var currentDir = baseUrl + location.pathname.replace(/\\/[^\\/]*$/, \"/\");\n\n\t// convert each url(...)\n\t/*\n\tThis regular expression is just a way to recursively match brackets within\n\ta string.\n\n\t /url\\s*\\(  = Match on the word \"url\" with any whitespace after it and then a parens\n\t   (  = Start a capturing group\n\t     (?:  = Start a non-capturing group\n\t         [^)(]  = Match anything that isn't a parentheses\n\t         |  = OR\n\t         \\(  = Match a start parentheses\n\t             (?:  = Start another non-capturing groups\n\t                 [^)(]+  = Match anything that isn't a parentheses\n\t                 |  = OR\n\t                 \\(  = Match a start parentheses\n\t                     [^)(]*  = Match anything that isn't a parentheses\n\t                 \\)  = Match a end parentheses\n\t             )  = End Group\n              *\\) = Match anything and then a close parens\n          )  = Close non-capturing group\n          *  = Match anything\n       )  = Close capturing group\n\t \\)  = Match a close parens\n\n\t /gi  = Get all matches, not the first.  Be case insensitive.\n\t */\n\tvar fixedCss = css.replace(/url\\s*\\(((?:[^)(]|\\((?:[^)(]+|\\([^)(]*\\))*\\))*)\\)/gi, function(fullMatch, origUrl) {\n\t\t// strip quotes (if they exist)\n\t\tvar unquotedOrigUrl = origUrl\n\t\t\t.trim()\n\t\t\t.replace(/^\"(.*)\"$/, function(o, $1){ return $1; })\n\t\t\t.replace(/^'(.*)'$/, function(o, $1){ return $1; });\n\n\t\t// already a full url? no change\n\t\tif (/^(#|data:|http:\\/\\/|https:\\/\\/|file:\\/\\/\\/|\\s*$)/i.test(unquotedOrigUrl)) {\n\t\t  return fullMatch;\n\t\t}\n\n\t\t// convert the url to a full url\n\t\tvar newUrl;\n\n\t\tif (unquotedOrigUrl.indexOf(\"//\") === 0) {\n\t\t  \t//TODO: should we add protocol?\n\t\t\tnewUrl = unquotedOrigUrl;\n\t\t} else if (unquotedOrigUrl.indexOf(\"/\") === 0) {\n\t\t\t// path should be relative to the base url\n\t\t\tnewUrl = baseUrl + unquotedOrigUrl; // already starts with '/'\n\t\t} else {\n\t\t\t// path should be relative to current directory\n\t\t\tnewUrl = currentDir + unquotedOrigUrl.replace(/^\\.\\//, \"\"); // Strip leading './'\n\t\t}\n\n\t\t// send back the fixed url(...)\n\t\treturn \"url(\" + JSON.stringify(newUrl) + \")\";\n\t});\n\n\t// send back the fixed css\n\treturn fixedCss;\n};\n"],"mappings":";;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AClFA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC9GA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACjBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACnBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC7YA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC5IA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AChWA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACpEA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC7CA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC9MA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACjDA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC5iBA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC/EA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACvRA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACxBA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC9KA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACxBA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACxBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACnIA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC3WA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC3WA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AChdA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACtPA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AC5XA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC3EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC/YA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;A","sourceRoot":""}