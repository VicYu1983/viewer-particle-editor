{"version":3,"file":"Wireframes/Wireframes.js","sources":["webpack://Autodesk.Extensions.[name]/webpack/bootstrap","webpack://Autodesk.Extensions.[name]/./extensions/Wireframes/Wireframes.js"],"sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./extensions/Wireframes/Wireframes.js\");\n","'use strict';function _typeof(obj) {\"@babel/helpers - typeof\";if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;};}return _typeof(obj);}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError(\"Cannot call a class as a function\");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}function _inherits(subClass, superClass) {if (typeof superClass !== \"function\" && superClass !== null) {throw new TypeError(\"Super expression must either be null or a function\");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}function _createSuper(Derived) {var hasNativeReflectConstruct = _isNativeReflectConstruct();return function _createSuperInternal() {var Super = _getPrototypeOf(Derived),result;if (hasNativeReflectConstruct) {var NewTarget = _getPrototypeOf(this).constructor;result = Reflect.construct(Super, arguments, NewTarget);} else {result = Super.apply(this, arguments);}return _possibleConstructorReturn(this, result);};}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");}return self;}function _isNativeReflectConstruct() {if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;if (Reflect.construct.sham) return false;if (typeof Proxy === \"function\") return true;try {Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));return true;} catch (e) {return false;}}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}\n\nvar av = Autodesk.Viewing;\n\n/**\n                            * Provides the ability of rendering the model in wireframe mode.\n                            * The method implemented is not very performant, so it's best to \n                            * avoid using it with large models.\n                            * \n                            * The extension id is: `Autodesk.Viewing.Wireframes`\n                            * \n                            * @example\n                            *   viewer.loadExtension('Autodesk.Viewing.Wireframes')\n                            * \n                            * @memberof Autodesk.Viewing.Extensions\n                            * @alias Autodesk.Viewing.Extensions.WireframesExtension\n                            * @see {@link Autodesk.Viewing.Extension} for common inherited methods.\n                            * @class\n                            */var\nWireframesExtension = /*#__PURE__*/function (_av$Extension) {_inherits(WireframesExtension, _av$Extension);var _super = _createSuper(WireframesExtension);\n\n  function WireframesExtension(viewer, options) {var _this;_classCallCheck(this, WireframesExtension);\n    _this = _super.call(this, viewer, options);\n\n    _this.groups = [];\n    _this.geometries = [];\n    _this.materials = [];\n    _this.lines = [];\n\n    _this.lightPreset = 4; //\"Photo Booth\";\n    _this.viewerLightPreset = 4;\n\n    _this.showingSolidMaterials = true;\n    _this.showingLines = true;\n\n    _this.linesMaterial = new THREE.LineBasicMaterial({\n      color: new THREE.Color(0x00000000),\n      opacity: 0.03,\n      transparent: true,\n      depthTest: true,\n      depthWrite: false });\n\n\n    _this.solidMaterial = new THREE.MeshPhongMaterial({\n      color: 0xFFCFCFCF,\n      specular: 0x00000000,\n      emissive: 0xFFCFCFCF,\n      ambient: 0,\n      opacity: 1.0,\n      transparent: false,\n      polygonOffset: true,\n      polygonOffsetFactor: 1.0,\n      polygonOffsetUnits: 5 });\n\n    _this.solidMaterial.packedNormals = true;\n    _this.name = 'wireframes';\n    _this.onProgressUpdate = _this.onProgressUpdate.bind(_assertThisInitialized(_this));return _this;\n  }_createClass(WireframesExtension, [{ key: \"onProgressUpdate\", value: function onProgressUpdate(\n\n    event) {\n      if (event.state === av.ProgressState.LOADING) {\n\n        // Add wireframes for newly loaded fragments.\n        this.createAndAddWireframes();\n      }\n    } }, { key: \"togglePolygonOffset\", value: function togglePolygonOffset()\n\n    {\n      // Functionality available in Viewer 2.15 and up, to make wireframe lines\n      // look better.\n      // However, wirelines may still work (though not as good) when the function is not present.\n      var matManager = this.viewer.impl.getMaterials();\n      if (matManager && matManager.togglePolygonOffset) {\n        matManager.togglePolygonOffset(true, 1.0, 5.0);\n      }\n    }\n\n    // Create and add wireframe geometry.\n  }, { key: \"createAndAddWireframes\", value: function createAndAddWireframes() {\n\n      var viewer = this.viewer;\n      var models = viewer.impl.modelQueue().getModels();\n      var modelsCount = models.length;\n\n      for (var i = 0; i < modelsCount; ++i) {\n\n        if (!models[i].getData().instanceTree) {\n          continue;\n        }\n\n        // Create group with all lines obtained for the model.\n        var group = createWireframes(models[i], this.geometries, this.lines, this.materials, this.linesMaterial);\n        group.model = models[i];\n        this.groups.push(group);\n\n        // Set solid material to new fragments only when tool is activated.\n        if (this.activeStatus) {\n          addWireframes(this.viewer, this.groups);\n          this.setSolidMaterial(this.solidMaterial);\n        }\n\n      }\n\n      this.togglePolygonOffset();\n      viewer.impl.invalidate(true, true, true);\n    } }, { key: \"load\", value: function load()\n\n    {\n      this.createAndAddWireframes();\n\n      // Keep adding wireframes if model is still loading.\n      this.viewer.addEventListener(av.PROGRESS_UPDATE_EVENT, this.onProgressUpdate);\n\n      // Enable line offset.\n      this.togglePolygonOffset();\n\n      return true;\n    } }, { key: \"unload\", value: function unload()\n\n    {\n\n      this.activeStatus = false;\n\n      revertSolidMaterials(this.viewer, this.materials);\n      revertWireframes(this.viewer, this.groups);\n\n      this.viewer.removeEventListener(av.PROGRESS_UPDATE_EVENT, this.onProgressUpdate);\n\n      this.geometries = [];\n      this.materials = [];\n      this.lines = [];\n      this.groups = [];\n\n      return true;\n    }\n\n    /**\n       * Enters wireframe mode.\n       * \n       * @memberof Autodesk.Viewing.Extensions.WireframesExtension\n       * @alias Autodesk.Viewing.Extensions.WireframesExtension#activate\n       */ }, { key: \"activate\", value: function activate()\n    {\n\n      this.activeStatus = true;\n\n      this.viewerLightPreset = this.viewer.prefs.get('lightPreset');\n      this.viewer.setLightPreset(this.lightPreset);\n\n      this.setSolidMaterial(this.solidMaterial);\n      this.setLinesMaterial(this.linesMaterial);\n\n      addWireframes(this.viewer, this.groups);\n\n      this.showSolidMaterial(this.showingSolidMaterials);\n      this.showLines(this.showingLines);\n\n      return true;\n    }\n\n    /**\n       * Exits wireframe mode.\n       * \n       * @memberof Autodesk.Viewing.Extensions.WireframesExtension\n       * @alias Autodesk.Viewing.Extensions.WireframesExtension#deactivate\n       */ }, { key: \"deactivate\", value: function deactivate()\n    {\n\n      this.activeStatus = false;\n      this.viewer.setLightPreset(this.viewerLightPreset);\n      revertWireframes(this.viewer, this.groups);\n      revertSolidMaterials(this.viewer, this.materials);\n      return true;\n    }\n\n    /**\n       * Whether to replace the standard materials with a solid one, or not.\n       * \n       * @param {boolean} show\n       * \n       * @memberof Autodesk.Viewing.Extensions.WireframesExtension\n       * @alias Autodesk.Viewing.Extensions.WireframesExtension#showSolidMaterial\n       */ }, { key: \"showSolidMaterial\", value: function showSolidMaterial(\n    show) {\n\n      this.showingSolidMaterials = show;\n\n      if (!this.activeStatus) {\n        return;\n      }\n\n      if (this.showingSolidMaterials) {\n        this.setSolidMaterial(this.solidMaterial);\n      } else {\n        revertSolidMaterials(this.viewer, this.materials);\n      }\n    }\n\n    /**\n       * Whether to render line edges or not.\n       * \n       * @param {boolean} show\n       * \n       * @memberof Autodesk.Viewing.Extensions.WireframesExtension\n       * @alias Autodesk.Viewing.Extensions.WireframesExtension#showLines\n       */ }, { key: \"showLines\", value: function showLines(\n    show) {\n\n      this.showingLines = show;\n\n      if (!this.activeStatus) {\n        return;\n      }\n\n      var lines = this.lines;\n      var linesCount = lines.length;\n\n      for (var i = 0; i < linesCount; ++i) {\n\n        var line = lines[i];\n        line.visible = show;\n      }\n\n      this.viewer.impl.invalidate(true, true, true);\n    }\n\n    /**\n       * Replaces the solid material.\n       * \n       * @param {THREE.Material} material\n       * \n       * @see {@link Autodesk.Viewing.Extensions.WireframesExtension#showSolidMaterial}\n       * @memberof Autodesk.Viewing.Extensions.WireframesExtension\n       * @alias Autodesk.Viewing.Extensions.WireframesExtension#setSolidMaterial\n       */ }, { key: \"setSolidMaterial\", value: function setSolidMaterial(\n    material) {\n\n      this.solidMaterial = material;\n      // TODO: We don't dispose of the material we may be replacing. It isn't\n      // clear whether we should do that, or whether it is the reponsibility of\n      // the application to dispose of materials.\n      var matman = this.viewer.impl.matman();\n      var name = matman._getMaterialHash(null, \"Autodesk.Viewing.Wireframes.solid\");\n      matman.addMaterial(name, material, true);\n\n      // Replace all fragments materials if extension active and showing solid materials.\n      if (!this.activeStatus || !this.showingSolidMaterials) {\n        return;\n      }\n\n      var materials = this.materials;\n      var materialsCount = materials.length;\n\n      for (var i = 0; i < materialsCount; ++i) {\n        var materialEntry = materials[i];\n        materialEntry.fragments.setMaterial(materialEntry.fragment, this.solidMaterial);\n      }\n\n      this.viewer.impl.invalidate(true, true, true);\n    }\n\n    /**\n       * Replaces the line material.\n       * \n       * @param {THREE.Material} material\n       * \n       * @see {@link Autodesk.Viewing.Extensions.WireframesExtension#showLines}\n       * @memberof Autodesk.Viewing.Extensions.WireframesExtension\n       * @alias Autodesk.Viewing.Extensions.WireframesExtension#setLinesMaterial\n       */ }, { key: \"setLinesMaterial\", value: function setLinesMaterial(\n    material) {\n\n      this.linesMaterial = material;\n      // TODO: We don't dispose of the material we may be replacing. It isn't\n      // clear whether we should do that, or whether it is the reponsibility of\n      // the application to dispose of materials.\n      var matman = this.viewer.impl.matman();\n      var name = matman._getMaterialHash(null, \"Autodesk.Viewing.Wireframes.lines\");\n      matman.addMaterialNonHDR(name, material);\n\n      // Replace all lines materials if extension is active and showing lines.\n      if (!this.activeStatus || !this.showingLines) {\n        return;\n      }\n\n      var lines = this.lines;\n      var linesCount = lines.length;\n\n      for (var i = 0; i < linesCount; ++i) {\n\n        var line = lines[i];\n        line.material = this.linesMaterial;\n      }\n\n      this.viewer.impl.invalidate(true, true, true);\n    }\n\n    /**\n       * Specifies the light preset to use when wireframe mode is activated.\n       * \n       * @param {string} name - the name of the light preset\n       * \n       * @memberof Autodesk.Viewing.Extensions.WireframesExtension\n       * @alias Autodesk.Viewing.Extensions.WireframesExtension#setLightPreset\n       */ }, { key: \"setLightPreset\", value: function setLightPreset(\n    name) {\n\n      this.lightPreset = name;\n      if (this.activeStatus) {\n        this.viewer.setLightPreset(name);\n      }\n    } }]);return WireframesExtension;}(av.Extension);\n\n\n\n\n/**\n                                                       * @param model\n                                                       * @param geometries\n                                                       * @param lines\n                                                       * @param materials\n                                                       * @param linesMaterial\n                                                       * @private\n                                                       */export { WireframesExtension as default };\nfunction createWireframes(model, geometries, lines, materials, linesMaterial) {\n\n  // Get Meshes in the model.\n  var tree = model.getData().instanceTree;\n  var fragments = model.getFragmentList();\n  var newGeometries = [];\n\n  tree.enumNodeChildren(model.getRootId(), function (dbId) {\n\n    if (tree.isNodeHidden(dbId) || tree.isNodeOff(dbId)) {\n      return;\n    }\n\n    //All fragments that belong to the same node make part of the\n    //same object so we have to accumulate all their intersections into one list\n    tree.enumNodeFragments(dbId, function (fragmentId) {\n\n      var mesh = fragments.getVizmesh(fragmentId);\n\n      if (!mesh.geometry) {\n        return;\n      }\n\n      if (mesh.geometry.is2d || mesh.geometry.isLines) {\n        return;\n      }\n\n      if (!mesh.material.cutplanes) {\n        return;\n      }\n\n      // Save materials to restore later.\n      materials.push({ fragment: fragmentId, fragments: fragments, material: fragments.getMaterial(fragmentId) });\n\n      // Add geometry if not already present.\n      var geometry = fragments.getGeometry(fragmentId);\n      if (!find(geometry, fragmentId, geometries)) {\n\n        var world = new THREE.Matrix4();\n        fragments.getWorldMatrix(fragmentId, world);\n        newGeometries.push({ geometry: geometry, world: world, fragment: fragmentId });\n      }\n    }.bind(this), false);\n  }, true);\n\n  // Create wire lines.\n  var group = new THREE.Group();\n  var newGeometriesCount = newGeometries.length;\n  var position = new THREE.Vector3(),quaternion = new THREE.Quaternion(),scale = new THREE.Vector3();\n\n  for (var i = 0; i < newGeometriesCount; ++i) {\n\n    var geometry = new THREE.Geometry();\n    var geometryVertices = geometry.vertices;\n\n    var srcWorld = newGeometries[i].world;\n    var srcGeometry = newGeometries[i].geometry;\n\n    var srcVertices = srcGeometry.vb;\n    var srcIndices = srcGeometry.ib;\n    var srcStride = srcGeometry.vbstride;\n\n    for (var j = 0; j < srcIndices.length;) {\n\n      var indexA = srcIndices[j++] * srcStride;\n      var indexB = srcIndices[j++] * srcStride;\n      var indexC = srcIndices[j++] * srcStride;\n\n      var vertexA = new THREE.Vector3(srcVertices[indexA++], srcVertices[indexA++], srcVertices[indexA]);\n      var vertexB = new THREE.Vector3(srcVertices[indexB++], srcVertices[indexB++], srcVertices[indexB]);\n      var vertexC = new THREE.Vector3(srcVertices[indexC++], srcVertices[indexC++], srcVertices[indexC]);\n\n      geometryVertices.push(vertexA);\n      geometryVertices.push(vertexB);\n\n      geometryVertices.push(vertexB);\n      geometryVertices.push(vertexC);\n\n      geometryVertices.push(vertexC);\n      geometryVertices.push(vertexA);\n    }\n\n    var line = new THREE.Line(geometry, linesMaterial, THREE.LinePieces);\n\n    srcWorld.decompose(position, quaternion, scale);\n    line.position.copy(position);\n    line.quaternion.copy(quaternion);\n    line.scale.copy(scale);\n    lines.push(line);\n\n    group.add(line);\n    geometries.push(newGeometries[i]);\n  }\n\n  return group;\n}\n\n/**\n   * @param {Viewer3D} viewer - Viewer instance\n   * @param groups\n   * @private\n   */\nfunction addWireframes(viewer, groups) {\n\n  var groupsCount = groups.length;\n  for (var i = 0; i < groupsCount; ++i) {\n\n    viewer.impl.sceneAfter.add(groups[i]);\n  }\n  viewer.impl.invalidate(true, true, true);\n}\n\n/**\n   * @param {Viewer3D} viewer - Viewer instance\n   * @param materials\n   * @private\n   */\nfunction revertSolidMaterials(viewer, materials) {\n\n  var materialsLength = materials.length;\n  for (var i = 0; i < materialsLength; ++i) {\n\n    var material = materials[i];\n    material.fragments.setMaterial(material.fragment, material.material);\n  }\n  viewer.impl.invalidate(true, true, true);\n}\n\n/**\n   * @param {Viewer3D} viewer - Viewer instance\n   * @param groups\n   * @private\n   */\nfunction revertWireframes(viewer, groups) {\n\n  var groupsCount = groups.length;\n  for (var i = 0; i < groupsCount; ++i) {\n\n    viewer.impl.sceneAfter.remove(groups[i]);\n  }\n  viewer.impl.invalidate(true, true, true);\n}\n\n/**\n   * @param geometry\n   * @param fragment\n   * @param geometries\n   * @private\n   */\nfunction find(geometry, fragment, geometries) {\n\n  var geometryCount = geometries.length;\n  for (var i = 0; i < geometryCount; ++i) {\n\n    if (geometries[i].geometry === geometry && geometries[i].fragment === fragment) {\n      return geometries[i];\n    }\n  }\n\n  return null;\n}\n\n\nAutodesk.Viewing.theExtensionManager.registerExtension('Autodesk.Viewing.Wireframes', WireframesExtension);"],"mappings":";;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AClFA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;A","sourceRoot":""}