{"version":3,"sources":["webpack://Autodesk.Extensions.[name]/webpack/bootstrap","webpack://Autodesk.Extensions.[name]/./node_modules/uuid/index.js","webpack://Autodesk.Extensions.[name]/./node_modules/uuid/lib/rng-browser.js","webpack://Autodesk.Extensions.[name]/./node_modules/uuid/lib/bytesToUuid.js","webpack://Autodesk.Extensions.[name]/./node_modules/uuid/v1.js","webpack://Autodesk.Extensions.[name]/./node_modules/uuid/v4.js","webpack://Autodesk.Extensions.[name]/./extensions/ModelAlignmentService/AlignmentService.js","webpack://Autodesk.Extensions.[name]/./extensions/ModelAlignmentService/AlignmentServiceLS.js","webpack://Autodesk.Extensions.[name]/./extensions/ModelAlignmentService/AlignedItemNucleus.js","webpack://Autodesk.Extensions.[name]/./extensions/ModelAlignmentService/AlignmentCache.js","webpack://Autodesk.Extensions.[name]/./extensions/ModelAlignmentService/RequestUtils.js","webpack://Autodesk.Extensions.[name]/./extensions/ModelAlignmentService/NucleusAlignmentAPI.js","webpack://Autodesk.Extensions.[name]/./extensions/ModelAlignmentService/NucleusRelationshipAPI.js","webpack://Autodesk.Extensions.[name]/./extensions/ModelAlignmentService/AlignmentServiceNucleus.js","webpack://Autodesk.Extensions.[name]/./extensions/ModelAlignmentService/AlignmentServiceNucleusOverridable.js","webpack://Autodesk.Extensions.[name]/./extensions/ModelAlignmentService/ModelAlignmentService.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","v1","v4","uuid","getRandomValues","crypto","window","msCrypto","rnds8","Uint8Array","rnds","Array","Math","random","byteToHex","toString","substr","buf","offset","bth","join","_nodeId","_clockseq","rng","bytesToUuid","_lastMSecs","_lastNSecs","options","b","node","clockseq","undefined","seedBytes","msecs","Date","getTime","nsecs","dt","Error","tl","tmh","ii","namespace","AutodeskNamespace","AlignmentService","urns","versionUrn","viewablePartId","transform","regionId","boundingBox","units","lineageUrn","modelLineageUrn","modelViewablePartId","sheetLineageUrn","sheetViewablePartId","type","relationshipId","RelationshipEntityTypes","Model3D","Region","RelationshipIdPrefix","Name","avp","Autodesk","Viewing","Private","keyPrefix","APIs","getKey","api","urn","length","newTransformItem","elements","isLocked","getRelationshipEntityId","viewablePart","region","AlignmentServiceLS","localStorage","LocalStorage","item","this","loadItem","Boolean","saveItem","getIsLocked","regions","index","findIndex","loadRegions","find","relationship","getRelationships","deleteRelationship","id","console","warn","filter","deleteItem","sheetEntityId","modelEntityId","getUUID","entities","domain","results","entityId","keys","getAllKeys","indexOf","itemStr","getItem","candidate","JSON","parse","some","entity","push","LmvMatrix4","fromArray","map","THREE","Box2","set","x","y","assign","from","min","max","stringify","setItem","removeItem","ObjectLocalStorage","data","AlignedItemNucleus","alignedItemID","init","checksum","updatedAt","updatedBy","toUrlSafeBase64","isArray","fromUrlSafeBase64","AlignmentCache","fetchItems","_fetchItems","cache","urnToRequestIndex","pendingRequests","alignedItemIds","needsLoad","alignedItemId","requestIndex","forEach","promise","result","getCachedItem","Retry","maxAttempts","startDelay","growFactor","numFailedAttempts","pow","callback","isSuccess","Promise","resolve","nextTry","delayInMs","getWaitingTime","setTimeout","sendRequest","getAccessToken","url","operation","body","success","token","xhr","XMLHttpRequest","open","setRequestHeader","onFailure","onload","status","response","e","onerror","ontimeout","onabort","send","sendRequestWithRetry","doRequest","res","run","av","chunk","array","chunkSize","chunks","slice","AlignedItemID","getDefaultServiceUrl","docsEnv","envConfig","EnvironmentConfigurations","getEnv","UPSTREAM","ROOT","getDefaultToken","accessToken","NucleusAlignmentAPI","projectId","serviceBaseUrl","serviceVersion","onError","serviceUrl","itemsEndPoint","items","promises","_doBatchRequest","all","toObject","loadedItems","load","existsOnServer","lock","postFix","encodeURIComponent","Domain","NucleusRelationshipAPI","idEncoded","relationships","decodeURIComponent","AlignmentServiceNucleus","alignmentApi","relationshipApi","alignedItemIDs","itemIds","fromUrns","clone","tfOld","tfNew","equals","createNew","setItemLocked","regionsBackup","saveRelationship","error","clear","partId","itemId","unlockAlignment","AlignmentServiceNucleusOverridable","overrideTf","getOverrideTransform","newItems","latestItem","overrideItem","isLatest","ModelAlignmentService","viewer","Extension","theExtensionManager","registerExtension"],"mappings":";;;;;;;;;;;;;;;;;;sDACE,IAAIA,EAAmB,GAGvB,SAASC,EAAoBC,GAG5B,GAAGF,EAAiBE,GACnB,OAAOF,EAAiBE,GAAUC,QAGnC,IAAIC,EAASJ,EAAiBE,GAAY,CACzCG,EAAGH,EACHI,GAAG,EACHH,QAAS,IAUV,OANAI,EAAQL,GAAUM,KAAKJ,EAAOD,QAASC,EAAQA,EAAOD,QAASF,GAG/DG,EAAOE,GAAI,EAGJF,EAAOD,QA0Df,OArDAF,EAAoBQ,EAAIF,EAGxBN,EAAoBS,EAAIV,EAGxBC,EAAoBU,EAAI,SAASR,EAASS,EAAMC,GAC3CZ,EAAoBa,EAAEX,EAASS,IAClCG,OAAOC,eAAeb,EAASS,EAAM,CAAEK,YAAY,EAAMC,IAAKL,KAKhEZ,EAAoBkB,EAAI,SAAShB,GACX,oBAAXiB,QAA0BA,OAAOC,aAC1CN,OAAOC,eAAeb,EAASiB,OAAOC,YAAa,CAAEC,MAAO,WAE7DP,OAAOC,eAAeb,EAAS,aAAc,CAAEmB,OAAO,KAQvDrB,EAAoBsB,EAAI,SAASD,EAAOE,GAEvC,GADU,EAAPA,IAAUF,EAAQrB,EAAoBqB,IAC/B,EAAPE,EAAU,OAAOF,EACpB,GAAW,EAAPE,GAA8B,iBAAVF,GAAsBA,GAASA,EAAMG,WAAY,OAAOH,EAChF,IAAII,EAAKX,OAAOY,OAAO,MAGvB,GAFA1B,EAAoBkB,EAAEO,GACtBX,OAAOC,eAAeU,EAAI,UAAW,CAAET,YAAY,EAAMK,MAAOA,IACtD,EAAPE,GAA4B,iBAATF,EAAmB,IAAI,IAAIM,KAAON,EAAOrB,EAAoBU,EAAEe,EAAIE,EAAK,SAASA,GAAO,OAAON,EAAMM,IAAQC,KAAK,KAAMD,IAC9I,OAAOF,GAIRzB,EAAoB6B,EAAI,SAAS1B,GAChC,IAAIS,EAAST,GAAUA,EAAOqB,WAC7B,WAAwB,OAAOrB,EAAgB,SAC/C,WAA8B,OAAOA,GAEtC,OADAH,EAAoBU,EAAEE,EAAQ,IAAKA,GAC5BA,GAIRZ,EAAoBa,EAAI,SAASiB,EAAQC,GAAY,OAAOjB,OAAOkB,UAAUC,eAAe1B,KAAKuB,EAAQC,IAGzG/B,EAAoBkC,EAAI,GAIjBlC,EAAoBA,EAAoBmC,EAAI,K,qBClFrD,IAAIC,EAAK,EAAQ,IACbC,EAAK,EAAQ,IAEbC,EAAOD,EACXC,EAAKF,GAAKA,EACVE,EAAKD,GAAKA,EAEVlC,EAAOD,QAAUoC,G,iBCAjB,IAAIC,EAAqC,oBAAZ,QAA2BC,OAAOD,iBAAmBC,OAAOD,gBAAgBX,KAAKY,SACnE,oBAAd,UAAuE,mBAAnCC,OAAOC,SAASH,iBAAiCG,SAASH,gBAAgBX,KAAKc,UAEhJ,GAAIH,EAAiB,CAEnB,IAAII,EAAQ,IAAIC,WAAW,IAE3BzC,EAAOD,QAAU,WAEf,OADAqC,EAAgBI,GACTA,OAEJ,CAKL,IAAIE,EAAO,IAAIC,MAAM,IAErB3C,EAAOD,QAAU,WACf,IAAK,IAAWgB,EAAPd,EAAI,EAAMA,EAAI,GAAIA,IACN,IAAV,EAAJA,KAAiBc,EAAoB,WAAhB6B,KAAKC,UAC/BH,EAAKzC,GAAKc,MAAY,EAAJd,IAAa,GAAK,IAGtC,OAAOyC,K,iBC1BX,IADA,IAAII,EAAY,GACP7C,EAAI,EAAGA,EAAI,MAAOA,EACzB6C,EAAU7C,IAAMA,EAAI,KAAO8C,SAAS,IAAIC,OAAO,GAmBjDhD,EAAOD,QAhBP,SAAqBkD,EAAKC,GACxB,IAAIjD,EAAIiD,GAAU,EACdC,EAAML,EAEV,MAAO,CACLK,EAAIF,EAAIhD,MAAOkD,EAAIF,EAAIhD,MACvBkD,EAAIF,EAAIhD,MAAOkD,EAAIF,EAAIhD,MAAO,IAC9BkD,EAAIF,EAAIhD,MAAOkD,EAAIF,EAAIhD,MAAO,IAC9BkD,EAAIF,EAAIhD,MAAOkD,EAAIF,EAAIhD,MAAO,IAC9BkD,EAAIF,EAAIhD,MAAOkD,EAAIF,EAAIhD,MAAO,IAC9BkD,EAAIF,EAAIhD,MAAOkD,EAAIF,EAAIhD,MACvBkD,EAAIF,EAAIhD,MAAOkD,EAAIF,EAAIhD,MACvBkD,EAAIF,EAAIhD,MAAOkD,EAAIF,EAAIhD,OACtBmD,KAAK,M,mBCtBV,IAQIC,EACAC,EATAC,EAAM,EAAQ,IACdC,EAAc,EAAQ,IAWtBC,EAAa,EACbC,EAAa,EA+FjB1D,EAAOD,QA5FP,SAAY4D,EAASV,EAAKC,GACxB,IAAIjD,EAAIgD,GAAOC,GAAU,EACrBU,EAAIX,GAAO,GAGXY,GADJF,EAAUA,GAAW,IACFE,MAAQR,EACvBS,OAAgCC,IAArBJ,EAAQG,SAAyBH,EAAQG,SAAWR,EAKnE,GAAY,MAARO,GAA4B,MAAZC,EAAkB,CACpC,IAAIE,EAAYT,IACJ,MAARM,IAEFA,EAAOR,EAAU,CACA,EAAfW,EAAU,GACVA,EAAU,GAAIA,EAAU,GAAIA,EAAU,GAAIA,EAAU,GAAIA,EAAU,KAGtD,MAAZF,IAEFA,EAAWR,EAAiD,OAApCU,EAAU,IAAM,EAAIA,EAAU,KAQ1D,IAAIC,OAA0BF,IAAlBJ,EAAQM,MAAsBN,EAAQM,OAAQ,IAAIC,MAAOC,UAIjEC,OAA0BL,IAAlBJ,EAAQS,MAAsBT,EAAQS,MAAQV,EAAa,EAGnEW,EAAMJ,EAAQR,GAAeW,EAAQV,GAAY,IAcrD,GAXIW,EAAK,QAA0BN,IAArBJ,EAAQG,WACpBA,EAAWA,EAAW,EAAI,QAKvBO,EAAK,GAAKJ,EAAQR,SAAiCM,IAAlBJ,EAAQS,QAC5CA,EAAQ,GAINA,GAAS,IACX,MAAM,IAAIE,MAAM,mDAGlBb,EAAaQ,EACbP,EAAaU,EACbd,EAAYQ,EAMZ,IAAIS,GAA4B,KAAb,WAHnBN,GAAS,cAG+BG,GAAS,WACjDR,EAAE3D,KAAOsE,IAAO,GAAK,IACrBX,EAAE3D,KAAOsE,IAAO,GAAK,IACrBX,EAAE3D,KAAOsE,IAAO,EAAI,IACpBX,EAAE3D,KAAY,IAALsE,EAGT,IAAIC,EAAOP,EAAQ,WAAc,IAAS,UAC1CL,EAAE3D,KAAOuE,IAAQ,EAAI,IACrBZ,EAAE3D,KAAa,IAANuE,EAGTZ,EAAE3D,KAAOuE,IAAQ,GAAK,GAAM,GAC5BZ,EAAE3D,KAAOuE,IAAQ,GAAK,IAGtBZ,EAAE3D,KAAO6D,IAAa,EAAI,IAG1BF,EAAE3D,KAAkB,IAAX6D,EAGT,IAAK,IAAIpC,EAAI,EAAGA,EAAI,IAAKA,EACvBkC,EAAE3D,EAAIyB,GAAKmC,EAAKnC,GAGlB,OAAOuB,GAAYO,EAAYI,K,mBCzGjC,IAAIL,EAAM,EAAQ,IACdC,EAAc,EAAQ,IA2B1BxD,EAAOD,QAzBP,SAAY4D,EAASV,EAAKC,GACxB,IAAIjD,EAAIgD,GAAOC,GAAU,EAEF,iBAAb,IACRD,EAAkB,WAAZU,EAAuB,IAAIhB,MAAM,IAAM,KAC7CgB,EAAU,MAIZ,IAAIjB,GAFJiB,EAAUA,GAAW,IAEFd,SAAWc,EAAQJ,KAAOA,KAO7C,GAJAb,EAAK,GAAgB,GAAVA,EAAK,GAAa,GAC7BA,EAAK,GAAgB,GAAVA,EAAK,GAAa,IAGzBO,EACF,IAAK,IAAIwB,EAAK,EAAGA,EAAK,KAAMA,EAC1BxB,EAAIhD,EAAIwE,GAAM/B,EAAK+B,GAIvB,OAAOxB,GAAOO,EAAYd,K,mjBCzB5B,IAAMgC,EAAYC,kBAAkB,6BAGfC,E,WAEjB,c,4FAAe,CAAD,Q,mFAMA,OAAO,I,uGASJC,G,sOAQGC,EAAYC,G,yGACrB,M,8HAWED,EAAYC,GACrB,OAAO,O,kCAOCD,EAAYC,GACpB,OAAO,I,oEAUSD,EAAYC,EAAgBC,G,0OAQ5BF,EAAYC,G,0OAQVD,EAAYC,G,4OASVD,EAAYC,G,qOAWnBD,EAAYC,EAAgBE,EAAUC,EAAaC,G,2OASnDL,EAAYC,EAAgBE,G,yGAClC,M,+JASOH,EAAYC,G,yGACnB,I,8JAUQK,EAAYN,EAAYC,EAAgBE,G,+OAWpCI,EAAiBC,EAAqBC,EAAiBC,EAAqBP,G,iPAY5EQ,EAAML,EAAYL,EAAgBE,G,yGAC9C,M,wIAMQS,S,gCAGvBhB,EAAUiB,wBAA0B,CAChCC,QAAS,aACTC,OAAQ,oBAGZnB,EAAUoB,qBAAuB,CAC7BC,KAAM,gBACNF,OAAQ,Y,wqDClKZ,IAAMG,EAAMC,SAASC,QAAQC,QAGvBC,EAAY,kCACZC,EACS,YADTA,EAEY,eAQZC,EAAS,SAACC,EAAKC,GAA8B,IAAzBzB,EAAwB,uDAAP,GACvC,gBAAUqB,GAAV,OAJmB,MAInB,OAAuCG,GAAvC,OAJmB,MAInB,OAA8DC,GAA9D,OAAoEzB,EAAe0B,OAAf,UAJjD,MAIiD,OAA4C1B,GAA5C,KAIlE2B,EAAmB,SAAC1B,GACtB,MAAO,CAEHA,UAAWA,EAAYA,EAAU2B,SAAW,KAG5CC,UAAU,IAKZC,EAA0B,SAACzB,EAAY0B,EAAcC,GACvD,gBAAU3B,EAAV,YAAwBa,SAASrB,iBAAiBkB,qBAAqBC,MAAvE,OAA8Ee,GAA9E,OAA6FC,EAAS,GAAH,OAAMd,SAASrB,iBAAiBkB,qBAAqBD,QAArD,OAA8DkB,GAAW,KAI3JC,E,oRAEjB,aAA8C,IAAD,EAAjCC,EAAiC,uDAAlBjB,EAAIkB,aAAc,kBACzC,gBACKD,aAAeA,EAFqB,E,+CAKhCnC,EAAYC,GAIrB,IAAMoC,EAAOC,KAAKC,SAAShB,EAAgBvB,EAAYC,GACvD,OAAOoC,aAAA,EAAAA,EAAMnC,YAAa,O,kCAGlBF,EAAYC,GAEpB,IAAMoC,EAAOC,KAAKC,SAAShB,EAAgBvB,EAAYC,GACvD,OAAOuC,QAAQH,aAAD,EAACA,EAAMP,Y,oEASL9B,EAAYC,G,6FACtBoC,EAAOC,KAAKC,SAAShB,EAAgBvB,EAAYC,G,kBAChDoC,a,EAAAA,EAAMnC,W,oKASGF,EAAYC,EAAgBC,G,6FACtCmC,EAAOC,KAAKC,SAAShB,EAAgBvB,EAAYC,IAAmB2B,KACrE1B,UAAYA,E,kBACVoC,KAAKG,SAASlB,EAAgBvB,EAAYC,EAAgBoC,I,sKASjDrC,EAAYC,G,6FACtBoC,EAAOC,KAAKC,SAAShB,EAAgBvB,EAAYC,IAAmB2B,KACrEE,UAAW,E,kBACTQ,KAAKG,SAASlB,EAAgBvB,EAAYC,EAAgBoC,I,wKAU7CrC,EAAYC,G,yGACzBqC,KAAKI,YAAY1C,EAAYC,I,iKAWvBD,EAAYC,EAAgBE,EAAUC,EAAaF,G,+FAC1DmC,EAAOC,KAAKC,SAAShB,EAAgBvB,EAAYC,IAAmB2B,KAEhEe,UACNN,EAAKM,QAAU,KAMJ,KAFXC,EAAQP,EAAKM,QAAQE,WAAU,SAAAZ,GAAM,OAAIA,EAAO9B,WAAaA,QAI7DyC,EAAQP,EAAKM,QAAQhB,QAGzBU,EAAKM,QAAQC,GAAS,CAClBzC,WACAC,cACAF,a,kBAGGoC,KAAKG,SAASlB,EAAgBvB,EAAYC,EAAgBoC,I,uKAUpDrC,EAAYC,EAAgBE,G,wGACnBmC,KAAKQ,YAAY9C,EAAYC,G,cAA7C0C,E,OAEAV,EAASU,EAAQI,MAAK,SAAA9G,GAAC,OAAIA,EAAEkE,WAAaA,K,kBAEzC8B,GAAU,M,oKASHjC,EAAYC,G,+FACpBoC,EAAOC,KAAKC,SAAShB,EAAgBvB,EAAYC,GAEjD0C,EAAUN,a,EAAAA,EAAMM,Q,kBAEfA,GAAW,I,mKAUHrC,EAAYN,EAAYC,EAAgBE,G,6FACjD6C,EAAeV,KAAKW,iBAAiB9B,SAASrB,iBAAiBe,wBAAwBE,OAAQT,EAAYL,EAAgBE,GACjImC,KAAKY,mBAAmBF,EAAaG,IAG/Bd,EAAOC,KAAKC,SAAShB,EAAgBvB,EAAYC,GACjD0C,EAAUN,a,EAAAA,EAAMM,Q,uBAElBS,QAAQC,KAAK,wB,0BAIbpB,OAAON,OAAS,GAEhBU,EAAKM,QAAUA,EAAQW,QAAO,SAAArH,GAAC,OAAIA,EAAEkE,WAAaA,KAClDmC,KAAKG,SAASlB,EAAgBvB,EAAYC,EAAgBoC,IAG1DC,KAAKiB,WAAWhC,EAAgBvB,EAAYC,G,2KAe7BM,EAAiBC,EAAqBC,EAAiBC,EAAqBP,G,mGAEzFqD,EAAgBzB,EAAwBtB,EAAiBC,EAAqBP,GAC9EsD,EAAgB1B,EAAwBxB,EAAiBC,GAEzDI,EAAiB8C,eAGjBrB,EAAO,CACbc,GAAIvC,EACJ+C,SAAU,CACN,CACAC,OA9Me,kCA+MfjD,KAAMQ,SAASrB,iBAAiBe,wBAAwBE,OACxDoC,GAAIK,GAEJ,CACAI,OAnNe,kCAoNfjD,KAAMQ,SAASrB,iBAAiBe,wBAAwBC,QACxDqC,GAAIM,K,kBAMDnB,KAAKG,SAASlB,EAAmBX,OAAgB3B,EAAWoD,I,6KAahD1B,EAAML,EAAYL,EAAgBE,G,oGAQrD,IAPM0D,EAAU,GAEVC,EAAW/B,EAAwBzB,EAAYL,EAAgBE,GAE/D4D,EAAO7C,EAAIkB,aAAa4B,aAGrB7I,EAAI,EAAGA,EAAI4I,EAAKpC,OAAQxG,KAGW,KAFlCuB,EAAMqH,EAAK5I,IAET8I,QAAQ1C,KACN2C,EAAUhD,EAAIkB,aAAa+B,QAAQzH,IAGrC0H,OAFEA,EAAYF,GAAWG,KAAKC,MAAMJ,KAExC,UAAIE,EAAWT,gBAAf,aAAI,EAAqBY,MAAK,SAACC,GAAD,OAAYA,EAAOrB,KAAOW,GAAYU,EAAO7D,OAASA,OAChFkD,EAAQY,KAAKL,I,yBAKlBP,G,wIAGQjD,GACf0B,KAAKiB,WAAWhC,EAAmBX,K,+BAG9Ba,EAAKC,EAAKzB,GACf,IAAMvD,EAAU8E,EAAOC,EAAKC,EAAKzB,GAC3BiE,EAAU5B,KAAKH,aAAagC,QAAQzH,GACpC2F,EAAU6B,GAAWG,KAAKC,MAAMJ,GAwBtC,OArBI7B,aAAJ,EAAIA,EAAMnC,aACNmC,EAAKnC,UAAY,IAAIgB,EAAIwD,YAAW,GAAMC,UAAUtC,EAAKnC,aAGzDmC,aAAJ,EAAIA,EAAMM,WACNN,EAAKM,QAAUN,EAAKM,QAAQiC,KAAI,SAAA3C,GAY5B,OAVIA,EAAO/B,YACP+B,EAAO/B,UAAY,IAAIgB,EAAIwD,YAAW,GAAMC,UAAU1C,EAAO/B,YAIjE+B,EAAO7B,aAAc,IAAIyE,MAAMC,MAAOC,IAClC,CAAEC,EAAG/C,EAAO7B,YAAY,GAAI6E,EAAGhD,EAAO7B,YAAY,IAClD,CAAE4E,EAAG/C,EAAO7B,YAAY,GAAI6E,EAAGhD,EAAO7B,YAAY,KAG/C6B,MAIRI,I,+BAGFZ,EAAKC,EAAKzB,EAAgBoC,GAAO,IAAD,KAGrC,UAAIA,SAAJ,aAAI,EAAMnC,cACNmC,EAAOxG,OAAOqJ,OAAO,GAAI7C,IAMpBnC,UAAYrC,MAAMsH,KAAK9C,EAAKnC,UAAU2B,YAG/C,UAAIQ,SAAJ,aAAI,EAAMM,YACNN,EAAOxG,OAAOqJ,OAAO,GAAI7C,IACpBM,QAAUN,EAAKM,QAAQiC,KAAI,SAAA3I,GAC5B,IAAMgG,EAASpG,OAAOqJ,OAAO,GAAIjJ,GASjC,OANIgG,EAAO/B,YACP+B,EAAO/B,UAAYrC,MAAMsH,KAAKlD,EAAO/B,UAAU2B,WAInDI,EAAO7B,YAAc,CAAC6B,EAAO7B,YAAYgF,IAAIJ,EAAG/C,EAAO7B,YAAYgF,IAAIH,EAAGhD,EAAO7B,YAAYiF,IAAIL,EAAG/C,EAAO7B,YAAYiF,IAAIJ,GACpHhD,MAIf,IAAMvF,EAAU8E,EAAOC,EAAKC,EAAKzB,GAC3BiE,EAAUG,KAAKiB,UAAUjD,GAG/B,OAFAC,KAAKH,aAAaoD,QAAQ7I,EAAKwH,IAExB,I,iCAGAzC,EAAKC,EAAKzB,GACjB,IAAMvD,EAAM8E,EAAOC,EAAKC,EAAKzB,GAC7BqC,KAAKH,aAAaqD,WAAW9I,O,GA9SWoD,GAmT1C2F,E,WAEF,aAAe,UACXnD,KAAKoD,KAAO,G,0CAGRhJ,EAAK2F,GACTC,KAAKoD,KAAKhJ,GAAO2F,I,8BAGb3F,GACJ,OAAO4F,KAAKoD,KAAKhJ,O,2KAIzBoD,EAAiB2F,mBAAqBA,ECxWtC,IACMvE,EADKC,SAASC,QACLC,QAGMsE,E,WAEjB,WAAYC,I,4FAAgB,SACxBtD,KAAKuD,KAAKD,G,oDAGTA,GAGDtD,KAAKwD,cAAW7G,EAGhBqD,KAAKpC,UAAY,KAGjBoC,KAAKR,UAAW,EAGhBQ,KAAKyD,eAAY9G,EAGjBqD,KAAK0D,eAAY/G,EAGjBqD,KAAKtC,WAAa4F,aAAlB,EAAkBA,EAAe5F,WAGjCsC,KAAKrC,eAAiB2F,aAAtB,EAAsBA,EAAe3F,eAGrCqC,KAAKK,aAAU1D,I,uCAKf,OAAQqD,KAAKpC,YAAcoC,KAAKR,WAAaQ,KAAKK,U,4CAIlDL,KAAKpC,UAAY,KACjBoC,KAAKR,UAAY,EACjBQ,KAAKK,QAAY,O,gCAMXiD,EAAe1F,GAKrB,OAJAoC,KAAKuD,OACLvD,KAAKtC,WAAiB4F,EAAc5F,WACpCsC,KAAKrC,eAAiB2F,EAAc3F,eACpCqC,KAAKpC,UAAiBA,EACfoC,O,2BAINoD,GA0CD,OAtCApD,KAAKtC,WAAakB,EAAI+E,gBAAgBP,EAAK1F,YAG3CsC,KAAKrC,eAAiByF,EAAKzF,eAEvByF,EAAK/C,UACLL,KAAKK,QAAU+C,EAAK/C,QAAQiC,KAAI,SAAA3C,GAY5B,OAVIA,EAAO/B,YACP+B,EAAO/B,UAAY,IAAIgB,EAAIwD,YAAW,GAAMC,UAAU1C,EAAO/B,YAIjE+B,EAAO7B,aAAc,IAAIyE,MAAMC,MAAOC,IAClC,CAAEC,EAAG/C,EAAO7B,YAAY,GAAI6E,EAAGhD,EAAO7B,YAAY,IAClD,CAAE4E,EAAG/C,EAAO7B,YAAY,GAAI6E,EAAGhD,EAAO7B,YAAY,KAG/C6B,MAMfK,KAAKwD,SAAWJ,EAAKI,SAGrBxD,KAAKR,SAAY4D,EAAK5D,WAAY,EAGlCQ,KAAKyD,UAAYL,EAAKK,UAGtBzD,KAAK0D,UAAYN,EAAKM,UAGtB1D,KAAKpC,UAAYrC,MAAMqI,QAAQR,aAAd,EAAcA,EAAMxF,WAAa,IAAIgB,EAAIwD,YAAW,GAAMC,UAAUe,aAAnC,EAAmCA,EAAMxF,WAAa,KAEjGoC,O,uCAMP,OAAOE,QAAQF,KAAKwD,Y,iCAKpB,MAAO,CACHA,SAAUxD,KAAKwD,SACfhE,SAAUQ,KAAKR,SACf5B,UAAWoC,KAAKpC,WAAarC,MAAMsH,KAAK7C,KAAKpC,UAAU2B,UACvDc,QAASL,KAAKK,QAAUL,KAAKK,QAAQiC,KAAI,SAAA3I,GACjC,IAAMgG,EAASpG,OAAOqJ,OAAO,GAAIjJ,GASjC,OANIgG,EAAO/B,YACP+B,EAAO/B,UAAYrC,MAAMsH,KAAKlD,EAAO/B,UAAU2B,WAInDI,EAAO7B,YAAc,CAAC6B,EAAO7B,YAAYgF,IAAIJ,EAAG/C,EAAO7B,YAAYgF,IAAIH,EAAGhD,EAAO7B,YAAYiF,IAAIL,EAAG/C,EAAO7B,YAAYiF,IAAIJ,GACpHhD,UACNhD,EACTe,WAAYkB,EAAIiF,kBAAkB7D,KAAKtC,YACvCC,eAAgBqC,KAAKrC,qB,sgBC5HZmG,E,WAKjB,WAAYC,I,4FAAa,SAGrB/D,KAAKgE,YAAcD,EAGnB/D,KAAKiE,MAAQ,GAIbjE,KAAKkE,kBAAoB,GAGzBlE,KAAKmE,gBAAkB,CAAC,M,2DAIxBnE,KAAKiE,MAAQ,K,iEAIAG,G,sGAGPC,EAAY,SAACC,GAAD,OAAoB,EAAKL,MAAMK,EAAc3I,cAC/DyI,EAAiBA,EAAepD,OAAOqD,IAGnBhF,O,iDAMpB,IADIkF,EAAe,EACbvE,KAAKmE,gBAAgBI,IAAeA,I,OAG1CH,EAAeI,SAAQ,SAAAF,GAAa,OAAI,EAAKJ,kBAAkBI,EAAc3I,YAAc4I,KAGrFE,EAAUzE,KAAKgE,YAAYI,GAGjCpE,KAAKmE,gBAAgBI,GAAgBE,E,UAGhBA,E,QAAfC,E,OAGN1E,KAAKmE,gBAAgBI,GAAgB,KAKjCG,GACAN,EAAeI,SAAQ,SAAAF,GACnB,IAAMlK,EAAMkK,EAAc3I,WAC1B,EAAKsI,MAAM7J,GAAOsK,EAAOtK,MAKjCgK,EAAeI,SAAQ,SAAAF,UAIZ,EAAKJ,kBAAkBI,EAAc3I,e,mIAKtC2I,GACV,IAAMlK,EAAMkK,EAAc3I,WAC1B,OAAOqE,KAAKiE,MAAM7J,K,8DAGRkK,G,+FAGNvE,EAAOC,KAAK2E,cAAcL,I,yCAEnBvE,G,UAKL3F,EAAMkK,EAAc3I,aACpB4I,EAAevE,KAAKkE,kBAAkB9J,I,iCAGlC4F,KAAKmE,gBAAgBI,G,gDAIrBvE,KAAK+D,WAAW,CAACO,I,iCAEpBtE,KAAK2E,cAAcL,I,6HAGtBA,EAAevE,GACnB,IAAM3F,EAAMkK,EAAc3I,WAC1BqE,KAAKiE,MAAM7J,GAAO2F,O,kgBC/GnB,IAAM6E,EAAb,WAEI,c,4FAAe,SAGX5E,KAAK6E,YAAc,GAGnB7E,KAAK8E,WAAa,IAGlB9E,KAAK+E,WAAa,I,UAX1B,O,EAAA,G,EAAA,sCAemBC,GACX,OAAOA,EAAoBhF,KAAK8E,WAAatJ,KAAKyJ,IAAIjF,KAAK+E,WAAYC,EAAkB,GAAK,IAhBtG,0BAsBQE,EAAUC,GAAY,IAAD,OAErB,OAAO,IAAIC,SAAQ,SAACC,GAGhB,IAAIL,EAAoB,EAElBM,EAAO,4CAAG,qHAGSJ,IAHT,UAGNR,EAHM,QAMRS,EAAUT,GANF,yCAODW,EAAQX,IAPP,cAWZM,GACyB,EAAKH,aAZlB,yCAaDQ,EAAQX,IAbP,OAiBNa,EAAY,EAAKC,eAAeR,GACtC9J,OAAOuK,WAAWH,EAASC,GAlBf,4CAAH,qDAoBbD,Y,2BAjDZ,KAuDaI,EAAW,4CAAG,WAAOC,EAAgBC,EAAKC,GAA5B,6GAAuCC,EAAvC,+BAA8C,KAE/DpB,EAAS,CACXqB,SAAU,EACV3C,KAAU,MAJS,SAOHuC,IAPG,cAOjBK,EAPiB,oBASNZ,SAAQ,SAACC,GAEtB,IAAMY,EAAM,IAAIC,eAChBD,EAAIE,KAAKN,EAAWD,GAAK,GACzBK,EAAIG,iBAAiB,eAAgB,oBACrCH,EAAIG,iBAAiB,SAAU,oBAC/BH,EAAIG,iBAAiB,8BAA+B,KACpDH,EAAIG,iBAAiB,gBAAiB,UAAYJ,GAGlD,IAAMK,EAAY,WACdhB,EAAQX,IA0BZuB,EAAIK,OAtBW,WAIX,GAAIL,EAAIM,OAAS,KAAON,EAAIM,QAAU,IAClCF,SAIJ,IAII3B,EAAOtB,KAAO6C,EAAIO,SAAWzE,KAAKC,MAAMiE,EAAIO,UAAY,KACxD9B,EAAOqB,SAAU,EACjBV,EAAQX,GACV,MAAM+B,GAEJJ,MAKRJ,EAAIS,QAAUL,EACdJ,EAAIU,UAAYN,EAChBJ,EAAIW,QAAUP,EAEdJ,EAAIY,KAAKf,GAAQ/D,KAAKiB,UAAU8C,OAnDb,mFAAH,0DAuDXgB,EAAoB,4CAAG,WAAMnB,EAAgBC,EAAKC,EAAWC,GAAtC,+FAC1BiB,EAAY,kBAAMrB,EAAYC,EAAgBC,EAAKC,EAAWC,IAC9DX,EAAY,SAAA6B,GAAG,OAAIA,EAAIjB,SAFG,UAGnB,IAAInB,GAAQqC,IAAIF,EAAW5B,GAHR,mFAAH,4D,ynBC5GjC,IAAM+B,EAAKrI,SAASC,QACdF,EAAMsI,EAAGnI,QAoBf,SAASoI,EAAMC,EAAOC,GAElB,IADA,IAAMC,EAAS,GACNzO,EAAI,EAAGA,EAAIuO,EAAM/H,OAAQxG,GAAKwO,EACnCC,EAAOnF,KAAKiF,EAAMG,MAAM1O,EAAGA,EAAIwO,IAEnC,OAAOC,EAIJ,IAAME,EAAb,WAII,WAAY9J,GAAyC,IAA7BC,EAA4B,4DAAXhB,EAAW,UAGhDqD,KAAKtC,WAAaA,EAGlBsC,KAAKrC,eAAiBA,EAV9B,6CAqBQ,MAAO,CAEHD,WAAYkB,EAAIiF,kBAAkB7D,KAAKtC,YAGvCC,eAAgBqC,KAAKrC,qBAAkBhB,KA1BnD,iCA+BQ,gBAAUqD,KAAKtC,YAAf,OAA4BsC,KAAKrC,eAAL,YAA4BqC,KAAKrC,gBAAoB,OA/BzF,gCAeoBF,GACZ,OAAOA,GAAQA,EAAK6E,KAAI,SAAAlD,GAAG,OAAI,IAAIoI,EAAcpI,UAhBzD,KAoCMqI,EAAuB,SAACC,GAC1B,IAAMC,EAAYT,EAAGU,0BAA0BV,EAAGW,UAGlD,OAFgBF,EAAUG,UAAYH,EAAUI,MAE/B,2BADa,OAAZL,EAAmB,OAAS,KAI5CM,EAAkB,WACpB,OAAOd,EAAGlB,MAAMiC,aAQPC,EAAb,WAQI,aAOQ,6DAAJ,GANAC,EAMI,EANJA,UAMI,IALJxC,sBAKI,MALaqC,EAKb,MAJJN,eAII,MAJM,GAIN,MAHJU,sBAGI,MAHaX,EAAqBC,GAGlC,MAFJW,sBAEI,MAFa,KAEb,MADJC,eACI,MADM,KACN,YAEJtI,KAAKmI,UAAYA,EACjBnI,KAAK2F,eAAiBA,EACtB3F,KAAKsI,QAAUA,EAEftI,KAAKuI,WAAL,UAAqBH,EAArB,YAAuCC,GAGvCrI,KAAKwI,cAAL,oBAAkCL,EAAlC,mBAtGe,UAsGf,UAEAnI,KAAK4F,IAAM5F,KAAKuI,WAAavI,KAAKwI,cA1B1C,2FAkCqBC,GAlCrB,oGAoCc/D,EAAS,GAGV+D,EAAMpJ,OAvCnB,yCAwCmBqF,GAxCnB,cAgDc4C,EAASH,EAAMsB,EADJ,IAEXC,EAAWpB,EAAOhF,KAAI,SAAApJ,GAAC,OAAI,EAAKyP,gBAAgBzP,EAAGwL,MAjDjE,SAkDcU,QAAQwD,IAAIF,GAlD1B,gCAmDehE,GAnDf,+JA0D0B+D,EAAO/D,GA1DjC,sGA8DQ,IADMoB,EAAO,GACJjN,EAAE,EAAGA,EAAE4P,EAAMpJ,OAAQxG,IAC1BiN,EAAKjN,GAAK4P,EAAM5P,GAAGgQ,WA/D/B,gBAmE0B/B,EAAqB9G,KAAK2F,eAAgB3F,KAAK4F,IADjD,YACgE,OAAQE,GAnEhG,WAmEckB,EAnEd,QAsEiBjB,QAtEjB,uBAuEY/F,KAAKsI,UAvEjB,6BA4Ec9B,EAAWQ,EAAI5D,KA5E7B,wBA+EYtC,QAAQC,KAAK,4EA/EzB,2BAuFQ,IALM+H,EAActC,EAASjF,QAKpB1I,EAAE,EAAGA,EAAE4P,EAAMpJ,OAAQxG,IAGpByL,EAAgB,IAAIkD,EAAciB,EAAM5P,GAAG6E,WAAY+K,EAAM5P,GAAG8E,gBAChEvD,EAAMkK,EAAc3I,WAKpByH,EAAO0F,GAAeA,EAAYjQ,GACxC6L,EAAOtK,GAAOgJ,GAAO,IAAIC,GAAqB0F,KAAK3F,GAAQ,IAAIC,EAAmBiB,GAjG9F,yBA+GeI,GA/Gf,gKAsHmB3E,GAtHnB,iGAwHc+F,EAAO/F,EAAK8I,WAiBZhD,EAAY9F,EAAKiJ,iBAAmB,QAAU,OAzI5D,SA0I0BlC,EAAqB9G,KAAK2F,eAAgB3F,KAAK4F,IAAKC,EAAWC,GA1IzF,WA0IckB,EA1Id,QA4IiBjB,QA5IjB,uBA6IY/F,KAAKsI,UA7IjB,mBA8ImB,GA9InB,cAmJYtB,EAAI5D,KACJrD,EAAKgJ,KAAK/B,EAAI5D,OAIdrD,EAAKyD,cAAW7G,EAIF,UAAbkJ,GAA0B/E,QAAQC,KAAK,wFA5JpD,mBA2Ke,GA3Kf,gKAmLqBhB,GAnLrB,6FAoLc+F,EAAO/F,EAAK8I,WApL1B,SAqLc/B,EAAqB9G,KAAK2F,eAAgB3F,KAAK4F,IAAK,SAAUE,GArL5E,kKAiMwB/F,EAAMkJ,GAjM9B,mGAmMc7F,EAAOrD,EAAK8I,WACZ/C,EAAO,CACTpI,WAAgB0F,EAAK1F,WACrBC,eAAgByF,EAAKzF,gBAGnBuL,EAAUD,EAAO,QAAU,UAzMzC,SA0M0BnC,EAAqB9G,KAAK2F,eAAgB3F,KAAK4F,IAAMsD,EAAS,QAASpD,GA1MjG,WA0MckB,EA1Md,QA2MiBjB,QA3MjB,uBA4MY/F,KAAKsI,UA5MjB,0BAiNQvI,EAAKgJ,KAAK/B,EAAI5D,MAjNtB,wG,mkBCnFA,IAAM8D,GAAKrI,SAASC,QAId2I,IAHMP,GAAGnI,QAGc,SAAC2I,GAC1B,IAAMC,EAAYT,GAAGU,0BAA0BV,GAAGW,UAGlD,OAFgBF,EAAUG,UAAYH,EAAUI,MAE/B,wBADa,OAAZL,EAAmB,OAAS,MAI5CM,GAAkB,WACpB,OAAOd,GAAGlB,MAAMiC,aAIdxI,GAA0B,SAACzB,EAAY0B,EAAcC,GAEvD,gBAAU3B,EAAV,YAAwBa,SAASrB,iBAAiBkB,qBAAqBC,MAAvE,OAA8EwK,mBAAmBzJ,IAAjG,OAAiHC,EAAS,GAAH,OAAMd,SAASrB,iBAAiBkB,qBAAqBD,QAArD,OAA8DkB,GAAW,KAG9LyJ,GAAS,kCAOFC,GAAb,WAQI,aAOQ,6DAAJ,GANAlB,EAMI,EANJA,UAMI,IALJxC,sBAKI,MALaqC,GAKb,MAJJN,eAII,MAJM,GAIN,MAHJU,sBAGI,MAHaX,GAAqBC,GAGlC,MAFJW,sBAEI,MAFa,KAEb,MADJC,eACI,MADM,KACN,aAEJtI,KAAKmI,UAAYA,EACjBnI,KAAK2F,eAAiBA,EACtB3F,KAAKsI,QAAUA,EAEftI,KAAKuI,WAAL,UAAqBH,EAArB,YAAuCC,GAGvCrI,KAAKwI,cAAL,sBAAoCL,EAApC,kBAEAnI,KAAK4F,IAAM5F,KAAKuI,WAAavI,KAAKwI,c,UA1B1C,a,EAAA,G,EAAA,yEA6B2BnK,EAAML,EAAYL,EAAgBE,GA7B7D,uGA+BcgD,EAAKpB,GAAwBzB,EAAYL,EAAgBE,GACzDyL,EAAYH,mBAAmBtI,GAE/BqI,EAlCd,yBAkC0CE,GAlC1C,iBAkCyD/K,EAlCzD,eAkCoEiL,GAlCpE,SAmC0BxC,EAAqB9G,KAAK2F,eAAgB3F,KAAK4F,IAAMsD,EAAS,OAnCxF,WAmCclC,EAnCd,QAsCiBjB,QAtCjB,uBAuCY/F,KAAKsI,UAvCjB,kBAwCmB,IAxCnB,UA4CciB,EA5Cd,UA4C8BvC,EAAI5D,YA5ClC,aA4C8B,EAAUmG,cA5CxC,wBAgDYzI,QAAQC,KAAK,+EAhDzB,kBAiDmB,IAjDnB,eAqDQwI,EAAc/E,SAAQ,SAAA9D,GAClBA,EAAaW,SAASmD,SAAQ,SAAAtC,GAC1BA,EAAOrB,GAAK2I,mBAAmBtH,EAAOrB,UAvDtD,kBA2De0I,GA3Df,6KA8D2BtL,EAAiBC,EAAqBC,EAAiBC,EAAqBP,GA9DvG,mGA+DcqD,EAAgBzB,GAAwBtB,EAAiBC,EAAqBP,GAC9EsD,EAAgB1B,GAAwBxB,EAAiBC,GAGzD6B,EAAO,CACTsB,SAAU,CACN,CACIC,OAAQ8H,GACR/K,KAAMQ,SAASrB,iBAAiBe,wBAAwBE,OACxDoC,GAAIK,GAER,CACII,OAAQ8H,GACR/K,KAAMQ,SAASrB,iBAAiBe,wBAAwBC,QACxDqC,GAAIM,KAKV2E,EAAO,CAAC/F,GAlFtB,SAoF0B+G,EAAqB9G,KAAK2F,eAAgB3F,KAAK4F,IAAK,MAAOE,GApFrF,iBAsFiBC,QAtFjB,wBAuFY/F,KAAKsI,UAvFjB,mBAwFmB,GAxFnB,kCA2Fe,GA3Ff,iLA8F6BhK,GA9F7B,6FA+FcwH,EAAO,CAACxH,GA/FtB,SAkG0BwI,EAAqB9G,KAAK2F,eAAgB3F,KAAK4F,IADjD,UACgE,OAAQE,GAlGhG,iBAqGiBC,QArGjB,uBAsGY/F,KAAKsI,UAtGjB,oH,6BAAA,K,0nDCpBA,IAcqBmB,G,oSAQjB,aAA2B,IAAD,EAAdlN,EAAc,uDAAJ,GAAI,WAItB,IAAM+L,GAHN,gBAGqBA,QAAQjO,KAAb,OAChBkC,EAAQ+L,QAAUA,EAClB,EAAKoB,aAAe,IAAIxB,EAAoB3L,GAC5C,EAAKoN,gBAAkB,IAAIN,GAAuB9M,GAGlD,IAAMwH,EAAU,6CAAG,WAAO6F,GAAP,gGACF,EAAKF,aAAa3F,WAAW6F,GAD3B,mFAAH,sDAVM,OActB,EAAK3F,MAAQ,IAAIH,EAAeC,GAdV,E,iFAiBTtG,G,6FACPoM,EAAUrC,EAAcsC,SAASrM,G,SACjCuC,KAAKiE,MAAMF,WAAW8F,G,iIAGnBnM,EAAYC,GAErB,IAAM2F,EAAgB,IAAIkE,EAAc9J,EAAYC,GAC9CoC,EAAOC,KAAKiE,MAAMU,cAAcrB,GAKtC,GAAKvD,EAEE,OAAKA,EAAKnC,UAKVmC,EAAKnC,UAAUmM,QAJX,O,kCAOHrM,EAAYC,GAEpB,IAAM2F,EAAgB,IAAIkE,EAAc9J,EAAYC,GAC9CoC,EAAOC,KAAKiE,MAAMU,cAAcrB,GACtC,OAAOvD,EAAOG,QAAQH,EAAKP,eAAY7C,I,qEAGvBe,EAAYC,G,iGAEtB2F,EAAgB,IAAIkE,EAAc9J,EAAYC,G,SACjCqC,KAAKiE,MAAMpC,QAAQyB,G,cAAhCvD,E,0BACCA,SAAA,UAAAA,EAAMnC,iBAAN,eAAiBmM,UAAW,M,qKAGnBrM,EAAYC,EAAgBC,G,iGACtC0F,EAAgB,IAAIkE,EAAc9J,EAAYC,G,SAEnCqC,KAAKiE,MAAMpC,QAAQyB,G,UAAhCvD,E,OA/EaiK,EAmFE,UAACjK,SAAD,aAAC,EAAMnC,UAnFFqM,EAmFarM,KAhFpCoM,IAAUC,GAIXD,GAASC,GACFA,EAAMC,OAAOF,I,0CA4ET,G,cAIPjK,EACAA,EAAKnC,UAAYA,GAGjBmC,GAAO,IAAIsD,GAAqB8G,UAAU7G,EAAe1F,GACzDoC,KAAKiE,MAAMhB,QAAQK,EAAevD,I,SAKzBC,KAAK0J,aAAavJ,SAASJ,G,0EAlGxB,IAACiK,EAAOC,I,mIAqGRvM,EAAYC,G,+FACtB2F,EAAgB,IAAIkE,EAAc9J,EAAYC,G,SACnCqC,KAAKiE,MAAMpC,QAAQyB,G,YAAhCvD,E,QAIKP,S,oDAKOO,EAAKiJ,iB,kCAIXhJ,KAAK0J,aAAavJ,SAASJ,G,yBAI/BC,KAAK0J,aAAaU,cAAcrK,GAAM,G,wKAI1BrC,EAAYC,G,+FACxB2F,EAAgB,IAAIkE,EAAc9J,EAAYC,G,SACjCqC,KAAKiE,MAAMpC,QAAQyB,G,WAAhCvD,E,SAIQA,EAAKP,S,iEAIbQ,KAAK0J,aAAaU,cAAcrK,GAAM,G,yKAGxBrC,EAAYC,G,+FAC1B2F,EAAgB,IAAIkE,EAAc9J,EAAYC,G,SACjCqC,KAAKiE,MAAMpC,QAAQyB,G,cAAhCvD,E,yBACCG,QAAQH,aAAD,EAACA,EAAMP,W,kKAGR9B,EAAYC,EAAgBE,EAAUC,EAAaF,G,qGAC1D0F,EAAgB,IAAIkE,EAAc9J,EAAYC,G,SAEnCqC,KAAKiE,MAAMpC,QAAQyB,G,cAAhCvD,E,UAIAA,GAAO,IAAIsD,GAAqB8G,UAAU7G,EAAe1F,GACzDoC,KAAKiE,MAAMhB,QAAQK,EAAevD,IAOtCA,EAAKM,QAAU,GAETgK,EAAgBtK,EAAKM,QAAQkH,SAKpB,KAFXjH,EAAQP,EAAKM,QAAQE,WAAU,SAAAZ,GAAM,OAAIA,EAAO9B,WAAaA,QAI7DyC,EAAQP,EAAKM,QAAQhB,QAGzBU,EAAKM,QAAQC,GAAS,CAClBzC,WACAC,cACAF,a,UAKcoC,KAAK0J,aAAavJ,SAASJ,G,eAAvCiH,E,UAIFjH,EAAKM,QAAUgK,G,kBAGZrD,G,0KAGOtJ,EAAYC,G,iGACpB2F,EAAgB,IAAIkE,EAAc9J,EAAYC,G,SAEjCqC,KAAKiE,MAAMpC,QAAQyB,G,cAAhCvD,E,OAEAM,EAAUN,a,EAAAA,EAAMM,Q,kBAEfA,GAAW,I,kKAGL3C,EAAYC,EAAgBE,G,wGACnBmC,KAAKQ,YAAY9C,EAAYC,G,cAA7C0C,E,OAEAV,EAASU,EAAQI,MAAK,SAAA9G,GAAC,OAAIA,EAAEkE,WAAaA,K,kBAEzC8B,GAAU,M,sKAGF3B,EAAYN,EAAYC,EAAgBE,G,0GACjDyF,EAAgB,IAAIkE,EAAc9J,EAAYC,G,SAExBqC,KAAKW,iBAAiB9B,SAASrB,iBAAiBe,wBAAwBE,OAAQT,EAAYL,EAAgBE,G,WAAlI0L,E,QACalK,O,iFAKT+F,QAAQwD,IAAIW,EAAcjH,KAAI,SAAA3I,GAAC,OAAI,EAAKiH,mBAAmBjH,EAAEkH,Q,+DAEnEC,QAAQC,KAAK,kC,8BAKEf,KAAKiE,MAAMpC,QAAQyB,G,WAAhCvD,E,OACAM,EAAUN,a,EAAAA,EAAMM,Q,wBAElBS,QAAQC,KAAK,wB,gCAIbV,EAAQhB,OAAS,G,wBAEjBU,EAAKM,QAAUA,EAAQW,QAAO,SAAArH,GAAC,OAAIA,EAAEkE,WAAaA,K,UAC5CmC,KAAK0J,aAAavJ,SAASJ,G,gCAGjCC,KAAKiB,WAAWvD,EAAYC,G,sLAIbU,EAAML,EAAYL,EAAgBE,G,gGAExCmC,KAAK2J,gBAAgBhJ,iBAAiBtC,EAAML,EAAYL,EAAgBE,G,oNAGlEI,EAAiBC,EAAqBC,EAAiBC,EAAqBP,G,gGAElFmC,KAAK2J,gBAAgBW,iBAAiBrM,EAAiBC,EAAqBC,EAAiBC,EAAqBP,G,wNAI1GS,G,gGACR0B,KAAK2J,gBAAgB/I,mBAAmBtC,G,sKAKrD0B,KAAKuK,OAAQ,I,kCAIb,OAAQvK,KAAKuK,Q,mCAIbvK,KAAKiE,MAAMuG,U,kEAIE9M,EAAY+M,G,+FAGnBC,EAAS,IAAIlD,EAAc9J,EAAY+M,G,SAC1BzK,KAAKiE,MAAMpC,QAAQ6I,G,WAAhC3K,E,QACIiJ,iB,qDAMNjJ,EAAKP,S,gCACCQ,KAAK2K,gBAAgBjN,EAAY+M,G,cAI3CzK,KAAKiE,MAAMhB,QAAQyH,EAAQ,M,UAGd1K,KAAK0J,aAAazI,WAAWyJ,G,6KAjRGlN,G,o0DCVhCoN,G,8QAEjB,WAAYrO,GAAU,IAAD,S,4FAAA,UACjB,cAAMA,IAGDkM,MAAQ,GAJI,E,kDAOR/K,EAAYC,GAGrB,IAAMkN,EAAa7K,KAAK8K,qBAAqBpN,EAAYC,GACzD,YAAmBhB,IAAfkO,EACOA,EAAaA,EAAWd,QAAU,KAG7C,kDAA0BrM,EAAYC,K,kCAG9BD,EAAYC,GAIpB,YAAmBhB,IADAqD,KAAK8K,qBAAqBpN,EAAYC,IAKzD,iDAAyBD,EAAYC,K,yEAGjBD,EAAYC,G,wFAIbhB,IADAqD,KAAK8K,qBAAqBpN,EAAYC,G,0CAE9C,G,8EAG0BD,EAAYC,G,6MAGjCD,EAAYC,G,8FAIThB,KADbkO,EAAa7K,KAAK8K,qBAAqBpN,EAAYC,I,yCAE9CkN,G,0EAGsBnN,EAAYC,G,oLAuB3B8K,GAClBzI,KAAKyI,MAAQA,I,uLASPhL,EAAOlE,OAAOkI,KAAKzB,KAAKyI,O,SACxBzI,KAAK+D,WAAWtG,G,OAIhBsN,EAAW,GAEjBtN,EAAK+G,SAAQ,SAAApF,GAGT,IAAMsL,EAAS,IAAIlD,EAAcpI,GAC3B4L,EAAa,EAAK/G,MAAMU,cAAc+F,GAGtCO,EAAe,EAAKxC,MAAMrJ,GAO1B8L,EAAWF,EAAWxH,UAAYyH,EAAazH,UAQ3B,OAA1ByH,EAAazH,UACc,OAA3ByH,EAAarN,WACY,OAAzBoN,EAAWpN,UACPoN,EAAWtN,YAAc0B,EACzB8L,KAKAH,EAAS3L,GAAO6L,MAIxBjL,KAAKyI,MAAQsC,E,wIAUIrN,EAAYC,GAG7B,IAAIA,EAAJ,CAKA,IAAMoC,EAAOC,KAAKyI,MAAM/K,GACxB,GAAKqC,EAOL,OAAIA,EAAKnC,UACEmC,EAAKnC,UAAUmM,QAInB,W,gCA5JiDN,I,+iCCbhE,IAAMvC,GAAKrI,SAASC,QACdxB,GAAYC,kBAAkB,kCAcf4N,G,kQACjB,WAAYC,EAAQ7O,GAAU,O,4FAAA,qBACpB6O,EAAQ7O,G,UAF6B2K,GAAGmE,WAOtDnE,GAAGoE,oBAAoBC,kBApBC,iCAoBkCJ,IAE1D7N,GAAUE,iBAAqBA,EAC/BF,GAAUsC,mBAAqBA,EAC/BtC,GAAU4K,oBAAsBA,EAChC5K,GAAUmM,wBAA0BA,GACpCnM,GAAUsN,mCAAqCA","file":"ModelAlignmentService/ModelAlignmentService.min.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 839);\n","var v1 = require('./v1');\nvar v4 = require('./v4');\n\nvar uuid = v4;\nuuid.v1 = v1;\nuuid.v4 = v4;\n\nmodule.exports = uuid;\n","// Unique ID creation requires a high quality random # generator.  In the\n// browser this is a little complicated due to unknown quality of Math.random()\n// and inconsistent support for the `crypto` API.  We do the best we can via\n// feature-detection\n\n// getRandomValues needs to be invoked in a context where \"this\" is a Crypto\n// implementation. Also, find the complete implementation of crypto on IE11.\nvar getRandomValues = (typeof(crypto) != 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto)) ||\n                      (typeof(msCrypto) != 'undefined' && typeof window.msCrypto.getRandomValues == 'function' && msCrypto.getRandomValues.bind(msCrypto));\n\nif (getRandomValues) {\n  // WHATWG crypto RNG - http://wiki.whatwg.org/wiki/Crypto\n  var rnds8 = new Uint8Array(16); // eslint-disable-line no-undef\n\n  module.exports = function whatwgRNG() {\n    getRandomValues(rnds8);\n    return rnds8;\n  };\n} else {\n  // Math.random()-based (RNG)\n  //\n  // If all else fails, use Math.random().  It's fast, but is of unspecified\n  // quality.\n  var rnds = new Array(16);\n\n  module.exports = function mathRNG() {\n    for (var i = 0, r; i < 16; i++) {\n      if ((i & 0x03) === 0) r = Math.random() * 0x100000000;\n      rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;\n    }\n\n    return rnds;\n  };\n}\n","/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\nvar byteToHex = [];\nfor (var i = 0; i < 256; ++i) {\n  byteToHex[i] = (i + 0x100).toString(16).substr(1);\n}\n\nfunction bytesToUuid(buf, offset) {\n  var i = offset || 0;\n  var bth = byteToHex;\n  // join used to fix memory issue caused by concatenation: https://bugs.chromium.org/p/v8/issues/detail?id=3175#c4\n  return ([\n    bth[buf[i++]], bth[buf[i++]],\n    bth[buf[i++]], bth[buf[i++]], '-',\n    bth[buf[i++]], bth[buf[i++]], '-',\n    bth[buf[i++]], bth[buf[i++]], '-',\n    bth[buf[i++]], bth[buf[i++]], '-',\n    bth[buf[i++]], bth[buf[i++]],\n    bth[buf[i++]], bth[buf[i++]],\n    bth[buf[i++]], bth[buf[i++]]\n  ]).join('');\n}\n\nmodule.exports = bytesToUuid;\n","var rng = require('./lib/rng');\nvar bytesToUuid = require('./lib/bytesToUuid');\n\n// **`v1()` - Generate time-based UUID**\n//\n// Inspired by https://github.com/LiosK/UUID.js\n// and http://docs.python.org/library/uuid.html\n\nvar _nodeId;\nvar _clockseq;\n\n// Previous uuid creation time\nvar _lastMSecs = 0;\nvar _lastNSecs = 0;\n\n// See https://github.com/uuidjs/uuid for API details\nfunction v1(options, buf, offset) {\n  var i = buf && offset || 0;\n  var b = buf || [];\n\n  options = options || {};\n  var node = options.node || _nodeId;\n  var clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq;\n\n  // node and clockseq need to be initialized to random values if they're not\n  // specified.  We do this lazily to minimize issues related to insufficient\n  // system entropy.  See #189\n  if (node == null || clockseq == null) {\n    var seedBytes = rng();\n    if (node == null) {\n      // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)\n      node = _nodeId = [\n        seedBytes[0] | 0x01,\n        seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]\n      ];\n    }\n    if (clockseq == null) {\n      // Per 4.2.2, randomize (14 bit) clockseq\n      clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 0x3fff;\n    }\n  }\n\n  // UUID timestamps are 100 nano-second units since the Gregorian epoch,\n  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so\n  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'\n  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.\n  var msecs = options.msecs !== undefined ? options.msecs : new Date().getTime();\n\n  // Per 4.2.1.2, use count of uuid's generated during the current clock\n  // cycle to simulate higher resolution clock\n  var nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1;\n\n  // Time since last uuid creation (in msecs)\n  var dt = (msecs - _lastMSecs) + (nsecs - _lastNSecs)/10000;\n\n  // Per 4.2.1.2, Bump clockseq on clock regression\n  if (dt < 0 && options.clockseq === undefined) {\n    clockseq = clockseq + 1 & 0x3fff;\n  }\n\n  // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new\n  // time interval\n  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {\n    nsecs = 0;\n  }\n\n  // Per 4.2.1.2 Throw error if too many uuids are requested\n  if (nsecs >= 10000) {\n    throw new Error('uuid.v1(): Can\\'t create more than 10M uuids/sec');\n  }\n\n  _lastMSecs = msecs;\n  _lastNSecs = nsecs;\n  _clockseq = clockseq;\n\n  // Per 4.1.4 - Convert from unix epoch to Gregorian epoch\n  msecs += 12219292800000;\n\n  // `time_low`\n  var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;\n  b[i++] = tl >>> 24 & 0xff;\n  b[i++] = tl >>> 16 & 0xff;\n  b[i++] = tl >>> 8 & 0xff;\n  b[i++] = tl & 0xff;\n\n  // `time_mid`\n  var tmh = (msecs / 0x100000000 * 10000) & 0xfffffff;\n  b[i++] = tmh >>> 8 & 0xff;\n  b[i++] = tmh & 0xff;\n\n  // `time_high_and_version`\n  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version\n  b[i++] = tmh >>> 16 & 0xff;\n\n  // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)\n  b[i++] = clockseq >>> 8 | 0x80;\n\n  // `clock_seq_low`\n  b[i++] = clockseq & 0xff;\n\n  // `node`\n  for (var n = 0; n < 6; ++n) {\n    b[i + n] = node[n];\n  }\n\n  return buf ? buf : bytesToUuid(b);\n}\n\nmodule.exports = v1;\n","var rng = require('./lib/rng');\nvar bytesToUuid = require('./lib/bytesToUuid');\n\nfunction v4(options, buf, offset) {\n  var i = buf && offset || 0;\n\n  if (typeof(options) == 'string') {\n    buf = options === 'binary' ? new Array(16) : null;\n    options = null;\n  }\n  options = options || {};\n\n  var rnds = options.random || (options.rng || rng)();\n\n  // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n  rnds[6] = (rnds[6] & 0x0f) | 0x40;\n  rnds[8] = (rnds[8] & 0x3f) | 0x80;\n\n  // Copy bytes to buffer, if provided\n  if (buf) {\n    for (var ii = 0; ii < 16; ++ii) {\n      buf[i + ii] = rnds[ii];\n    }\n  }\n\n  return buf || bytesToUuid(rnds);\n}\n\nmodule.exports = v4;\n","const namespace = AutodeskNamespace('Autodesk.AlignmentService');\n\n/* Interface for alignment service implementations. */\nexport default class AlignmentService {\n\n    constructor() {}\n\n    /**\n     * Changes to false if any connection errors happened. As long as it returns true, you can safely assume that\n     * any returned results from getTransform() reflect the latest service state. \n     */\n    isWorking() { return true; }\n\n    clearCache() {}\n\n    /**\n    * Fetch alignment data for a batch of urns. This can be used to avoid individual requests for individual loadTransform()/isAlignmentLocked() calls. \n    *  @param {string[]} urns\n    *  @throws {Object} error\n    */\n    async fetchItems(urns) {}\n\n    /**\n    * @param {string} versionUrn       - encoded versionUrn, e.g. dXJuOmFkc2sud2lwc3RnOmZzLmZpbGU6dmYuYi1oeldxakxTS0c2VlZvVTRZNm5KQT92ZXJzaW9uPTE\n    * @param {string} [viewablePartId] - encoded viewableName of the model.\n    * @throws {Object} error           - some implementation may throw. error.msg should provide an error message for logs.\n    * @returns {LmvMatrix|null}        - Null means that no custom matrix was stored. Model will use its refPointTransform in this case.\n    */\n    async loadTransform(versionUrn, viewablePartId) {\n        return null;\n    }\n\n   /**\n    * Direct access to cached transform in memory: If a transform was loaded by loadTransform or fetch() before, this function allows to get it directly\n    * within a sync function. However, note that it might return undefined if the transform state is not in memory yet.\n    *  \n    * NOTE: Once a transform was loaded, the AlignmentService implementation has to ensure that the result is cached and can be obtained again by this function.\n    * \n    * @returns {LmvMatrix|null|undefined} - Null: \"not set\", undefined: \"not in memory yet\".\n    */\n    getTransform(versionUrn, viewablePartId) {\n        return null;\n    }\n\n    /**\n     * Direct access to cached isLocked flag.\n     * @returns {bool|undefined} - undefined: \"not in memory yet\".\n     */\n    getIsLocked(versionUrn, viewablePartId) {\n        return false;\n    }\n\n   /**\n    * @param {string} versionUrn            - encoded versionUrn, e.g. dXJuOmFkc2sud2lwc3RnOmZzLmZpbGU6dmYuYi1oeldxakxTS0c2VlZvVTRZNm5KQT92ZXJzaW9uPTE\n    * @param {string} [viewablePartId]      - encoded viewableName of the model.\n    * @param {LmvMatrix4|null} transform    - LmvMatrix with 64 bit precision. Call with null to reset alignment, so that the source-file refPointTransform is used again.\n    * @throws {Object}         error        - some implementation may throw. error.msg should provide an error message.\n    * @returns {boolean}                    - success / failed\n    */\n    async saveTransform(versionUrn, viewablePartId, transform) {}\n\n    /**\n    * Mark alignment as locked, so that it cannot be changed anymore.\n    * @param {string} versionUrn       - encoded versionUrn, e.g. dXJuOmFkc2sud2lwc3RnOmZzLmZpbGU6dmYuYi1oeldxakxTS0c2VlZvVTRZNm5KQT92ZXJzaW9uPTE\n    * @param {string} [viewablePartId] - encoded viewableName of the model.\n    * @throws {Object}\n    */\n    async lockAlignment(versionUrn, viewablePartId) {}\n\n   /**\n    * Remove alignment lock, so that aligning is possible. We don't expose it per UI.\n    * @param {string} versionUrn       - encoded versionUrn, e.g. dXJuOmFkc2sud2lwc3RnOmZzLmZpbGU6dmYuYi1oeldxakxTS0c2VlZvVTRZNm5KQT92ZXJzaW9uPTE\n    * @param {string} [viewablePartId] - encoded viewableName of the model.\n    * @throws {Object}\n    */\n    async unlockAlignment(versionUrn, viewablePartId) {}\n\n    /**\n    * Check if alignment is locked, so that it cannot be changed anymore.\n    * @param {string} versionUrn       - encoded versionUrn, e.g. dXJuOmFkc2sud2lwc3RnOmZzLmZpbGU6dmYuYi1oeldxakxTS0c2VlZvVTRZNm5KQT92ZXJzaW9uPTE\n    * @param {string} [viewablePartId] - encoded viewableName of the model.\n    * @throws {Object}\n    * @returns {boolean}\n    */\n    async isAlignmentLocked(versionUrn, viewablePartId) { }\n    \n    /**\n    * @param {string} versionUrn       - encoded versionUrn, e.g. dXJuOmFkc2sud2lwc3RnOmZzLmZpbGU6dmYuYi1oeldxakxTS0c2VlZvVTRZNm5KQT92ZXJzaW9uPTE\n    * @param {string} viewablePartId   - encoded viewableName of the 2d sheet.\n    * @param {string} regionId         - unique region id.\n    * @param {THREE.Box3} boundingBox  - bounding box of the region in model space.\n    * @param {string} units            - unit string of the bounding box, e.g. 'mm'.\n    * @throws {Object}         error   - some implementation may throw. error.msg should provide an error message.\n    * @returns {boolean}               - success / failed\n    */\n    async saveRegion(versionUrn, viewablePartId, regionId, boundingBox, units) { }\n    \n    /**\n    * @param {string} versionUrn       - encoded versionUrn, e.g. dXJuOmFkc2sud2lwc3RnOmZzLmZpbGU6dmYuYi1oeldxakxTS0c2VlZvVTRZNm5KQT92ZXJzaW9uPTE\n    * @param {string} viewablePartId   - encoded viewableName of the 2d sheet.\n    * @param {string} regionId         - unique region id.\n    * @throws {Object} error           - some implementation may throw. error.msg should provide an error message for logs.\n    * @returns {Object|null}           - Null means that no custom region was stored.\n    */\n    async loadRegion(versionUrn, viewablePartId, regionId) {\n        return null;\n    }\n\n    /**\n    * @param {string} [versionUrn]      - encoded versionUrn, e.g. dXJuOmFkc2sud2lwc3RnOmZzLmZpbGU6dmYuYi1oeldxakxTS0c2VlZvVTRZNm5KQT92ZXJzaW9uPTE\n    * @param {string} [viewablePartId]  - encoded viewableName of the 2d sheet.\n    * @throws {Object} error            - some implementation may throw. error.msg should provide an error message for logs.\n    * @returns {object[]}               - Empty array means that no matching region was found.\n    */\n    async loadRegions(versionUrn, viewablePartId) {\n        return [];\n    }\n\n    /**\n    * @param {string} lineageUrn        - encoded lineageUrn of the model, e.g. dXJuOmFkc2sud2lwcWE6ZG0ubGluZWFnZTp2SlhCdld6WVFCV3FPVWd2NERyZndR\n    * @param {string} [versionUrn]      - encoded versionUrn, e.g. dXJuOmFkc2sud2lwc3RnOmZzLmZpbGU6dmYuYi1oeldxakxTS0c2VlZvVTRZNm5KQT92ZXJzaW9uPTE\n    * @param {string} [viewablePartId]  - encoded viewableName of the 2d sheet.\n    * @param {string} regionId         - unique region id.\n    * @throws {Object} error            - some implementation may throw. error.msg should provide an error message for logs.\n    */\n    async deleteRegion(lineageUrn, versionUrn, viewablePartId, regionId) {}\n\n    /**\n    * @param {string} modelLineageUrn       - encoded lineageUrn of the 3D model, e.g. dXJuOmFkc2sud2lwcWE6ZG0ubGluZWFnZTp2SlhCdld6WVFCV3FPVWd2NERyZndR\n    * @param {string} modelViewablePartId   - encoded viewableName of the 3D model\n    * @param {string} sheetLineageUrn       - encoded lineageUrn of the 2D sheet, e.g. dXJuOmFkc2sud2lwcWE6ZG0ubGluZWFnZTp2SlhCdld6WVFCV3FPVWd2NERyZndR\n    * @param {string} sheetViewablePartId   - encoded viewableName of the 2d sheet.\n    * @param {string} [regionId]            - A UUID of the sheet's region.\n    * @throws {Object} error                - some implementation may throw. error.msg should provide an error message.\n    * @returns {boolean}                    - success / failed\n    */\n    async saveRelationship(modelLineageUrn, modelViewablePartId, sheetLineageUrn, sheetViewablePartId, regionId) { }\n    \n    /**\n    * Given a model urn & viewablePartId, return all the relationships that it's part of.\n    * \n    * @param {string} type              - `viewable` or `region`.\n    * @param {string} lineageUrn        - encoded lineageUrn of the model, e.g. dXJuOmFkc2sud2lwcWE6ZG0ubGluZWFnZTp2SlhCdld6WVFCV3FPVWd2NERyZndR\n    * @param {string} viewablePartId    - encoded viewableName of the model.\n    * @param {string} [regionId]        - A UUID of the sheet's region.\n    * @throws {Object} error            - some implementation may throw. error.msg should provide an error message for logs.\n    * @returns {Object[]}\n    */\n    async getRelationships(type, lineageUrn, viewablePartId, regionId) {\n        return null;\n    }\n\n    /**\n     * @param {string} relationshipId - the UUID of the relationship to delete\n     */\n    deleteRelationship(relationshipId) { }\n}\n\nnamespace.RelationshipEntityTypes = {\n    Model3D: \"viewpart3d\",\n    Region: \"viewpartregion2d\",\n};\n\nnamespace.RelationshipIdPrefix = {\n    Name: 'viewablePart=',\n    Region: '&region=',\n};\n","import AlignmentService from \"./AlignmentService\";\nimport { v4 as getUUID } from 'uuid';\n\nconst avp = Autodesk.Viewing.Private;\n\n// Prefix used for LocalStorage entries for model-alignment\nconst keyPrefix = 'Autodesk.Viewing.ModelAlignment';\nconst APIs = {\n    Transform: 'transform',\n    Relationship: 'relationship'\n};\n\nconst RelationshipDomain = 'autodesk-construction-alignment';\n\nconst TokenSeparator = '__';\n\n// get LocalStorage key from model version urn\nconst getKey = (api, urn, viewablePartId = '') => {\n    return `${keyPrefix}${TokenSeparator}${api}${TokenSeparator}${urn}${viewablePartId.length ? `${TokenSeparator}${viewablePartId}` : ``}`;\n};\n\n// An single alignment item stored as json in LocalStorage  \nconst newTransformItem = (transform) => {\n    return {\n        // Optional: Array of floats\n        transform: transform ? transform.elements : null,\n\n        // If true, we forbid changing\n        isLocked: false\n    };\n};\n\n// Relationship entity ID is defined by lineageUrn + viewablePart + region.\nconst getRelationshipEntityId = (lineageUrn, viewablePart, region) => {\n    return `${lineageUrn}?${Autodesk.AlignmentService.RelationshipIdPrefix.Name}${viewablePart}${region ? `${Autodesk.AlignmentService.RelationshipIdPrefix.Region}${region}` : ''}`;\n};\n\n/* Implements model-alignment storage based on LocalStorage. */\nexport default class AlignmentServiceLS extends AlignmentService {\n\n    constructor(localStorage = avp.LocalStorage) {\n        super();\n        this.localStorage = localStorage;\n    }\n\n    getTransform(versionUrn, viewablePartId) {\n        // just read directly from localStorage\n        // Note: It's essential to return null (not undefined) if no matrix is set,\n        //       because \"undefined\" would indicate that the state is not in memory yet.\n        const item = this.loadItem(APIs.Transform, versionUrn, viewablePartId);\n        return item?.transform || null;\n    }\n\n    getIsLocked(versionUrn, viewablePartId) {\n        // item may be null if nothing was saved for this urn so far. In this case, isLocked is always false. \n        const item = this.loadItem(APIs.Transform, versionUrn, viewablePartId);\n        return Boolean(item?.isLocked);\n    }\n\n    /**\n    * @param {string} versionUrn       - encoded versionUrn, e.g. dXJuOmFkc2sud2lwc3RnOmZzLmZpbGU6dmYuYi1oeldxakxTS0c2VlZvVTRZNm5KQT92ZXJzaW9uPTE\n    * @param {string} [viewablePartId] - encoded viewableName of the model.\n    * @throws {Object} error           - some implementation may throw. error.msg should provide an error message for logs.\n    * @returns {LmvMatrix|null}        - Null means that no custom matrix was stored. Model will use its refPointTransform in this case.\n    */\n    async loadTransform(versionUrn, viewablePartId) {\n        const item = this.loadItem(APIs.Transform, versionUrn, viewablePartId);\n        return item?.transform;\n    }\n\n    /**\n    * @param {string} versionUrn       - encoded versionUrn, e.g. dXJuOmFkc2sud2lwc3RnOmZzLmZpbGU6dmYuYi1oeldxakxTS0c2VlZvVTRZNm5KQT92ZXJzaW9uPTE\n    * @param {string} [viewablePartId] - encoded viewableName of the model.\n    * @param {LmvMatrix4|null} transform  - LmvMatrix with 64 bit precision. Call with null to reset alignment, so that the source-file refPointTransform is used again.\n    * @throws {Object}         error   - some implementation may throw. error.msg should provide an error message.\n    */\n    async saveTransform(versionUrn, viewablePartId, transform) {\n        const item = this.loadItem(APIs.Transform, versionUrn, viewablePartId) || newTransformItem();\n        item.transform = transform;\n        return this.saveItem(APIs.Transform, versionUrn, viewablePartId, item);\n    }\n\n    /**\n    * Mark alignment as locked, so that it cannot be changed anymore.\n    * @param {string} versionUrn       - encoded versionUrn, e.g. dXJuOmFkc2sud2lwc3RnOmZzLmZpbGU6dmYuYi1oeldxakxTS0c2VlZvVTRZNm5KQT92ZXJzaW9uPTE\n    * @param {string} [viewablePartId] - encoded viewableName of the model.\n    * @throws {Object}\n    */\n    async lockAlignment(versionUrn, viewablePartId) {\n        const item = this.loadItem(APIs.Transform, versionUrn, viewablePartId) || newTransformItem();\n        item.isLocked = true;\n        return this.saveItem(APIs.Transform, versionUrn, viewablePartId, item);\n    }\n\n    /**\n    * Check if alignment is locked, so that it cannot be changed anymore.\n    * @param {string} versionUrn       - encoded versionUrn, e.g. dXJuOmFkc2sud2lwc3RnOmZzLmZpbGU6dmYuYi1oeldxakxTS0c2VlZvVTRZNm5KQT92ZXJzaW9uPTE\n    * @param {string} [viewablePartId] - encoded viewableName of the model.\n    * @throws {Object}\n    * @returns {boolean}\n    */\n    async isAlignmentLocked(versionUrn, viewablePartId) {\n        return this.getIsLocked(versionUrn, viewablePartId);\n    }\n\n    /**\n    * @param {string} versionUrn       - encoded versionUrn, e.g. dXJuOmFkc2sud2lwc3RnOmZzLmZpbGU6dmYuYi1oeldxakxTS0c2VlZvVTRZNm5KQT92ZXJzaW9uPTE\n    * @param {string} viewablePartId   - encoded viewableName of the 2d sheet.\n    * @param {string} regionId         - unique region id.\n    * @param {THREE.Box3} boundingBox         - bounding box of the viewport in model space.\n    * @param {string} units            - unit string of the bounding box, e.g. 'mm'.\n    * @throws {Object}         error   - some implementation may throw. error.msg should provide an error message.\n    */\n    async saveRegion(versionUrn, viewablePartId, regionId, boundingBox, transform) { \n        const item = this.loadItem(APIs.Transform, versionUrn, viewablePartId) || newTransformItem();\n        \n        if (!item.regions) {\n            item.regions = [];\n        }\n\n        // In case that this regionId already exists in the service, we'll override its content.\n        let index = item.regions.findIndex(region => region.regionId === regionId);\n        \n        if (index === -1) {\n            // Otherwise, we'll create a new entry to the array.\n            index = item.regions.length;\n        }\n\n        item.regions[index] = {\n            regionId,\n            boundingBox,\n            transform\n        };\n\n        return this.saveItem(APIs.Transform, versionUrn, viewablePartId, item);\n    }\n    \n    /**\n    * @param {string} versionUrn       - encoded versionUrn, e.g. dXJuOmFkc2sud2lwc3RnOmZzLmZpbGU6dmYuYi1oeldxakxTS0c2VlZvVTRZNm5KQT92ZXJzaW9uPTE\n    * @param {string} viewablePartId   - encoded viewableName of the 2d sheet.\n    * @param {string} regionId         - unique region id.\n    * @throws {Object} error           - some implementation may throw. error.msg should provide an error message for logs.\n    * @returns {Object|null}           - Null means that no custom viewport was stored.\n    */\n    async loadRegion(versionUrn, viewablePartId, regionId) {\n        const regions = await this.loadRegions(versionUrn, viewablePartId);\n\n        const region = regions.find(r => r.regionId === regionId);\n\n        return region || null;\n    }\n\n    /**\n    * @param {string} [versionUrn]      - encoded versionUrn, e.g. dXJuOmFkc2sud2lwc3RnOmZzLmZpbGU6dmYuYi1oeldxakxTS0c2VlZvVTRZNm5KQT92ZXJzaW9uPTE\n    * @param {string} [viewablePartId]  - encoded viewableName of the 2d sheet.\n    * @throws {Object} error            - some implementation may throw. error.msg should provide an error message for logs.\n    * @returns {object[]}               - Empty array means that no matching viewport was found.\n    */\n    async loadRegions(versionUrn, viewablePartId) {\n        const item = this.loadItem(APIs.Transform, versionUrn, viewablePartId);\n        \n        const regions = item?.regions;\n\n        return regions || [];\n    }\n\n    /**\n    * @param {string} lineageUrn        - encoded lineageUrn of the model, e.g. dXJuOmFkc2sud2lwcWE6ZG0ubGluZWFnZTp2SlhCdld6WVFCV3FPVWd2NERyZndR\n    * @param {string} [versionUrn]      - encoded versionUrn, e.g. dXJuOmFkc2sud2lwc3RnOmZzLmZpbGU6dmYuYi1oeldxakxTS0c2VlZvVTRZNm5KQT92ZXJzaW9uPTE\n    * @param {string} [viewablePartId]  - encoded viewableName of the 2d sheet.\n    * @param {string} regionId         - unique region id.\n    * @throws {Object} error            - some implementation may throw. error.msg should provide an error message for logs.\n    */\n    async deleteRegion(lineageUrn, versionUrn, viewablePartId, regionId) {\n        const relationship = this.getRelationships(Autodesk.AlignmentService.RelationshipEntityTypes.Region, lineageUrn, viewablePartId, regionId);\n        this.deleteRelationship(relationship.id);\n\n        // get current item from cache\n        const item = this.loadItem(APIs.Transform, versionUrn, viewablePartId);\n        const regions = item?.regions;\n        if (!regions) {\n            console.warn('No regions to delete');\n            return;\n        }\n\n        if (region.length > 1) {\n            // Update the regions list. This will overwrite the item.\n            item.regions = regions.filter(r => r.regionId !== regionId);\n            this.saveItem(APIs.Transform, versionUrn, viewablePartId, item);\n        } else {\n            // This is the only region in the item\n            this.deleteItem(APIs.Transform, versionUrn, viewablePartId);\n        }\n\n    }\n\n    ////////// Relationship Service //////////////\n\n    /**\n    * @param {string} modelLineageUrn       - encoded versionUrn of the 3D model, e.g. dXJuOmFkc2sud2lwcWE6ZG0ubGluZWFnZTp2SlhCdld6WVFCV3FPVWd2NERyZndR\n    * @param {string} modelViewablePartId   - encoded viewableName of the 3D model\n    * @param {string} sheetLineageUrn       - encoded versionUrn of the 2D sheet, e.g. dXJuOmFkc2sud2lwcWE6ZG0ubGluZWFnZTp2SlhCdld6WVFCV3FPVWd2NERyZndR\n    * @param {string} sheetViewablePartId   - encoded viewableName of the 2d sheet.\n    * @param {string} [regionId]            - A UUID of the sheet's region.\n    * @throws {Object} error                - some implementation may throw. error.msg should provide an error message.\n    */\n    async saveRelationship(modelLineageUrn, modelViewablePartId, sheetLineageUrn, sheetViewablePartId, regionId) {\n\n        const sheetEntityId = getRelationshipEntityId(sheetLineageUrn, sheetViewablePartId, regionId);\n        const modelEntityId = getRelationshipEntityId(modelLineageUrn, modelViewablePartId);\n\n        const relationshipId = getUUID();\n\n        // this is how this structure that it is stored in real Relationship service.\n        const item = {\n        id: relationshipId,\n        entities: [\n            {\n            domain: RelationshipDomain,\n            type: Autodesk.AlignmentService.RelationshipEntityTypes.Region,\n            id: sheetEntityId,\n            },\n            {\n            domain: RelationshipDomain,\n            type: Autodesk.AlignmentService.RelationshipEntityTypes.Model3D,\n            id: modelEntityId,\n            },\n        ],\n        };\n\n        // In the mock service we save the relationship according to a unique key, just like it's gonna be saved in the relationship service.\n        return this.saveItem(APIs.Relationship, relationshipId, undefined, item);\n    }\n\n    /**\n    * Given a model urn & viewablePartId, return all the relationships that it's part of.\n    * \n    * @param {string} type              - `viewable` or `region`.\n    * @param {string} lineageUrn        - encoded lineageUrn of the model, e.g. dXJuOmFkc2sud2lwcWE6ZG0ubGluZWFnZTp2SlhCdld6WVFCV3FPVWd2NERyZndR\n    * @param {string} viewablePartId    - encoded viewableName of the model.\n    * @param {string} [regionId]        - A UUID of the sheet's region.\n    * @throws {Object} error            - some implementation may throw. error.msg should provide an error message for logs.\n    * @returns {Object[]}\n    */\n    async getRelationships(type, lineageUrn, viewablePartId, regionId) {\n        const results = [];\n\n        const entityId = getRelationshipEntityId(lineageUrn, viewablePartId, regionId);\n        \n        const keys = avp.LocalStorage.getAllKeys();\n\n        // Simulates Relationship Service `search` API. The API can look for relationships according to `domain`, `type` & `entityId`.\n        for (let i = 0; i < keys.length; i++) {\n            const key = keys[i];\n\n            if (key.indexOf(APIs.Relationship) !== -1) {\n                const itemStr = avp.LocalStorage.getItem(key);\n                const candidate = itemStr && JSON.parse(itemStr);\n            \n                if (candidate?.entities?.some((entity) => entity.id === entityId && entity.type === type)) {\n                    results.push(candidate);\n                }\n            }\n        }\n\n        return results;\n    }\n\n    deleteRelationship(relationshipId) {\n        this.deleteItem(APIs.Relationship, relationshipId);\n    }\n\n    loadItem(api, urn, viewablePartId) {\n        const key     = getKey(api, urn, viewablePartId);\n        const itemStr = this.localStorage.getItem(key);\n        const item    = itemStr && JSON.parse(itemStr);\n    \n        // Convert array elements into LmvMatrix\n        if (item?.transform) {\n            item.transform = new avp.LmvMatrix4(true).fromArray(item.transform);\n        }\n        \n        if (item?.regions) {\n            item.regions = item.regions.map(region => {\n                // If region contains a matrix (and it should), convert it into LmvMatrix\n                if (region.transform) {\n                    region.transform = new avp.LmvMatrix4(true).fromArray(region.transform);\n                }\n    \n                // Convert array into THREE.Box2\n                region.boundingBox = new THREE.Box2().set(\n                    { x: region.boundingBox[0], y: region.boundingBox[1] },\n                    { x: region.boundingBox[2], y: region.boundingBox[3] }\n                );\n    \n                return region;\n            });\n        }\n\n        return item;\n    }\n    \n    saveItem(api, urn, viewablePartId, item) {\n    \n        // If the item contains a matrix, convert it to number array first\n        if (item?.transform) {\n            item = Object.assign({}, item);\n    \n            // Note that the Array.from(...) makes a difference here:\n            // TypedArrays (like matrix.elements) are not saved as arrays by JSON-stringify, but as objects,\n            // i.e., it would look like '{\"0\": 1, \"1\": 1, ... }' \n            // By converting to a JS array, the resulting json contains an actual array, i.e. \"[1, 0, 0, ... ]\"\n            item.transform = Array.from(item.transform.elements);\n        }\n        \n        if (item?.regions) {\n            item = Object.assign({}, item);\n            item.regions = item.regions.map(r => {\n                const region = Object.assign({}, r);\n    \n                // If region contains a matrix (and it should), convert it to number array first\n                if (region.transform) {\n                    region.transform = Array.from(region.transform.elements);\n                }\n    \n                // Convert THREE.Box2 into a flat array.\n                region.boundingBox = [region.boundingBox.min.x, region.boundingBox.min.y, region.boundingBox.max.x, region.boundingBox.max.y];\n                return region;\n            });\n        }\n    \n        const key     = getKey(api, urn, viewablePartId);\n        const itemStr = JSON.stringify(item);\n        this.localStorage.setItem(key, itemStr);\n\n        return true;\n    }\n\n    deleteItem(api, urn, viewablePartId) {\n        const key = getKey(api, urn, viewablePartId);\n        this.localStorage.removeItem(key);\n    }\n}\n\n// Implement LocalStorage interface, but just using a plain JS object for storage instead of actual LocalStorage.\nclass ObjectLocalStorage {\n\n    constructor() {\n        this.data = {};\n    }\n\n    setItem(key, item) {\n        this.data[key] = item;\n    }\n\n    getItem(key) {\n        return this.data[key];\n    }\n}\n\nAlignmentService.ObjectLocalStorage = ObjectLocalStorage;\n","const av = Autodesk.Viewing;\nconst avp = av.Private;\n\n// All data that is stored by the service per aligned item.\nexport default class AlignedItemNucleus {\n\n    constructor(alignedItemID) {\n        this.init(alignedItemID);\n    }\n\n    init(alignedItemID) {\n        // {string} Generated by AlignmentSerivce. Needed to send requests to change this item, e.g., \"51a0d0bea901804d3e1870ea337b965d\"\n        //          May be undefined if item was not saved before. Mandatory if item exists on the backend.\n        this.checksum = undefined;\n\n        // {LMVMatrix4} Initially assume null = \"no alignment transform set\".\n        this.transform = null;\n\n        // {bool} whether alignment is locked\n        this.isLocked = false;\n\n        // {string} e.g., \"2020-11-23T21:54:28.9862331+00:00\"\n        this.updatedAt = undefined;\n\n        // {string} oxygenId of the last user who updated it\n        this.updatedBy = undefined;\n\n        // base64-encoded versionUrn, e.g. \"dXJuOmFkc2sud2lwc3RnOmZzLmZpbGU6dmYuYi1oeldxakxTS0c2VlZvVTRZNm5KQT92ZXJzaW9uPTE\"\n        this.versionUrn = alignedItemID?.versionUrn;\n\n        // viewable part id - name of the specific viewable, e.g. \"Second Floor\"\n        this.viewablePartId = alignedItemID?.viewablePartId;\n\n        // {Region[]} - optional array of 2D regions.\n        this.regions = undefined;\n    }\n\n    // Returns true if alignment/lock state is the same as for new items that the backend doesn't know about.\n    isDefaultState() {\n        return !this.transform && !this.isLocked && !this.regions;\n    }\n\n    resetToDefaultState() {\n        this.transform = null;\n        this.isLocked  = false;\n        this.regions   = null;\n    }\n\n    // Init new item before saving a transform for the first time\n    //  @param {string}     versionUrn - base64-encoded versionUrn\n    //  @param {LmvMatrix4} transform\n    createNew(alignedItemID, transform) {\n        this.init();\n        this.versionUrn     = alignedItemID.versionUrn;\n        this.viewablePartId = alignedItemID.viewablePartId;\n        this.transform      = transform;\n        return this;\n    }\n\n    // Set from data that we got from alignment service\n    load(data) {\n\n        // Note: The serivce works with unencoded versionUrns, e.g. 'urn:adsk.wipstg:fs.file:vf.vSenZnaYQAOAZqzHB54kLQ?version=1'.\n        //       However, the rest of LMV usually uses encoded ones. So, we only use the decoded ones when receiving or sending service data.\n        this.versionUrn = avp.toUrlSafeBase64(data.versionUrn);\n\n        // {string} viewable part id - name of the specific viewable, e.g. \"Second Floor\"\n        this.viewablePartId = data.viewablePartId;\n\n        if (data.regions) {\n            this.regions = data.regions.map(region => {\n                // If region contains a matrix (and it should), convert it into LmvMatrix\n                if (region.transform) {\n                    region.transform = new avp.LmvMatrix4(true).fromArray(region.transform);\n                }\n\n                // Convert array into THREE.Box2\n                region.boundingBox = new THREE.Box2().set(\n                    { x: region.boundingBox[0], y: region.boundingBox[1] },\n                    { x: region.boundingBox[2], y: region.boundingBox[3] }\n                );\n\n                return region;\n            });\n        }\n\n        // {string} Generated by AlignmentSerivce. Needed to send requests to change this item, e.g., \"51a0d0bea901804d3e1870ea337b965d\"\n        //          May be undefined if item was not saved before. Mandatory if item exists on the backend.\n        this.checksum = data.checksum;\n\n        // {bool} whether alignment is locked\n        this.isLocked  = data.isLocked || false;\n\n        // {string} e.g., \"2020-11-23T21:54:28.9862331+00:00\"\n        this.updatedAt = data.updatedAt;\n\n        // {string} oxygenId of the last user who updated it\n        this.updatedBy = data.updatedBy;\n\n        // Create LmvMatrix4 from float array\n        this.transform = Array.isArray(data?.transform) ? new avp.LmvMatrix4(true).fromArray(data?.transform) : null;\n\n        return this;\n    }\n\n    // If this item actually exists on the server, there must be a checksum provided by the backend.\n    // If there is none, this indicates that the item does not exist on the server yet.\n    existsOnServer() {\n        return Boolean(this.checksum);\n    }\n\n    // Convert into object that we can serialize into a json request body\n    toObject() {\n        return {\n            checksum: this.checksum,\n            isLocked: this.isLocked,\n            transform: this.transform && Array.from(this.transform.elements),\n            regions: this.regions ? this.regions.map(r => {\n                    const region = Object.assign({}, r);\n\n                    // If region contains a matrix (and it should), convert it to number array first\n                    if (region.transform) {\n                        region.transform = Array.from(region.transform.elements);\n                    }\n\n                    // Convert THREE.Box2 into a flat array.\n                    region.boundingBox = [region.boundingBox.min.x, region.boundingBox.min.y, region.boundingBox.max.x, region.boundingBox.max.y];\n                    return region;\n                }) : undefined,\n            versionUrn: avp.fromUrlSafeBase64(this.versionUrn), // alignmentService requires decoded urns\n            viewablePartId: this.viewablePartId,\n        };\n    }\n}\n","\n\n// Helper class to implement batching and caching of alignment items (alignment transforms, locked-flags, and possible other service-specific data). \n//\n// Main purpose is to provide implementation of loadTransform/saveTransform in a way that\n// we don't fire a single request per call. Instead, all transforms can be prefetched in a single batch and loadTransform gets them from memory as soon as available.\nexport default class AlignmentCache {\n\n    // The actual content of cached items is left to the client. The cache cannot add items itself.\n    //\n    // @param {async function(string[])} fetchItems - Async function to make batch requests. On success it returns a map from versionUrn to data items.\n    constructor(fetchItems) {\n\n        // Keep callback to fetch items\n        this._fetchItems = fetchItems;\n\n        // AlignmentItems in memory. Indexed by alignedItemId key.\n        this.cache = {};\n\n        // If the alignment for an urn is not in memory, but already requested, this[urnToRequestIndex] gives us the index\n        // of the corresponding request in this.pendingRequests.\n        this.urnToRequestIndex = {};\n\n        // For each pending fetchItems-call, this array contains a promise that resolves when the request is finished.\n        this.pendingRequests = [null];\n    }\n\n    clear() {\n        this.cache = {};\n    }\n\n    // Prefetch alignment items for a given list of urns and add them to the cache.\n    async fetchItems(alignedItemIds) {\n\n        // Skip urls that we already know\n        const needsLoad = (alignedItemId) => !this.cache[alignedItemId.toString()];\n        alignedItemIds = alignedItemIds.filter(needsLoad);\n\n        // If all is in cache, we are done here\n        if (!alignedItemIds.length) {\n            return;\n        }\n\n        // find free request index\n        let requestIndex = 1;\n        while(this.pendingRequests[requestIndex]) requestIndex++;\n\n        // Mark all urns as pending and allow finding the request for a given urn\n        alignedItemIds.forEach(alignedItemId => this.urnToRequestIndex[alignedItemId.toString()] = requestIndex);\n\n        // Do the actual request\n        const promise = this._fetchItems(alignedItemIds);\n\n        // Keep promise so that later fetchSingleItem() calls to any of the urns can return it.\n        this.pendingRequests[requestIndex] = promise;\n\n        // Wait for request result\n        const result = await promise;\n\n        // remove promise from pendingRequests\n        this.pendingRequests[requestIndex] = null;\n\n\n        // If fetching succeeded, add results to cache.\n        // Otherwise, do nothing: It's up to the client to deal with errors\n        if (result) {\n            alignedItemIds.forEach(alignedItemId => {\n                const key = alignedItemId.toString();\n                this.cache[key] = result[key];\n            });\n        }\n\n        // Mark urn as resolved and not pending anymore. Note that this always needs to happen, no matter whether successful or not.\n        alignedItemIds.forEach(alignedItemId => {\n            // Use delete here to keep the dictionary cleaner. \n            // Although it's a bit slower than setting to undefined, this doesn't matter here,\n            // because the the call frequency is not critically high.\n            delete this.urnToRequestIndex[alignedItemId.toString()];\n        });\n    }\n\n    // Return immediately whatever we have in cache\n    getCachedItem(alignedItemId) {\n        const key = alignedItemId.toString();\n        return this.cache[key];\n    }\n\n    async getItem(alignedItemId) {\n\n        // Return from memory if possible\n        let item = this.getCachedItem(alignedItemId);\n        if (item) {\n            return item;\n        }\n\n        // Ideally, this item should already be handled by a pending batch request.\n        // If so, we just wait for it to finish.\n        const key = alignedItemId.toString();\n        const requestIndex = this.urnToRequestIndex[key];\n        if (requestIndex) {\n            // wait for request to finish\n            await this.pendingRequests[requestIndex];\n        } else {\n            // Not requested yet: We have to do an extra request for it.\n            // It's not dramatic if this happens, but for performance, it's preferable if all urns are already prefetched in batches.\n            await this.fetchItems([alignedItemId]);\n        }\n        return this.getCachedItem(alignedItemId);\n    }\n\n    setItem(alignedItemId, item) {\n        const key = alignedItemId.toString();\n        this.cache[key] = item;\n    }\n}\n","// Helper class for retrying requests\nexport class Retry {\n    \n    constructor() {\n\n        // Maximum number of attempts before giving up\n        this.maxAttempts = 10;\n\n        // Waiting time in ms for first retry\n        this.startDelay = 100;\n\n        // Exponential grow factor for the waiting time per attempt\n        this.growFactor = 1.1;\n    }\n\n    // Returns the waiting time in ms before retrying.    \n    getWaitingTime(numFailedAttempts) {\n        return numFailedAttempts ? this.startDelay * Math.pow(this.growFactor, numFailedAttempts-1) : 0;\n    }\n    \n    // Try the given (async) callback until either successful or until maximum retry count is reached.\n    //  - Return value is the last result of callback\n    //  - Callback is considered successful if isSuccess(result) is true.\n    run(callback, isSuccess) {\n\n        return new Promise((resolve) => {\n        \n            // track number of attempts\n            let numFailedAttempts = 0;\n        \n            const nextTry = async () => {\n\n                // try again\n                const result = await callback();\n\n                // On success, we are done here\n                if (isSuccess(result)) {\n                    return resolve(result);\n                }\n\n                // Give up if we reached the limit\n                numFailedAttempts++;\n                if (numFailedAttempts >= this.maxAttempts) {\n                    return resolve(result);\n                }\n\n                // schedule next attempt\n                const delayInMs = this.getWaitingTime(numFailedAttempts);\n                window.setTimeout(nextTry, delayInMs);\n            };\n            nextTry();\n        });\n    }\n}\n\n// Result is an object { success, response }.\nexport const sendRequest = async (getAccessToken, url, operation, body = null) => {\n\n    const result = {\n        success:  false,\n        data:     null\n    };\n\n    const token = await getAccessToken();\n\n    return await new Promise((resolve) => {\n\n        const xhr = new XMLHttpRequest();\n        xhr.open(operation, url, true);\n        xhr.setRequestHeader('Content-Type', 'application/json');\n        xhr.setRequestHeader('accept', 'application/json');\n        xhr.setRequestHeader('Access-Control-Allow-Origin', '*');\n        xhr.setRequestHeader('Authorization', 'Bearer ' + token);\n\n        // On failure: resolve with result.success == false\n        const onFailure = () => {\n            resolve(result);\n        };\n\n        // Parse response as json on success\n        const onLoad = () => {\n\n            // Even if the request didn't trigger an error callback,\n            // the server response may still indicate an error (e.g. this happens on authorization failure) \n            if (xhr.status < 200 || xhr.status >= 300) {\n                onFailure();\n                return;\n            }\n\n            try {\n                // If json parsing succeeds, return success\n                // Some requests (e.g. DELETE) may also get an empty string as result on success, but JSON.parse() would\n                // fail on those. Therefore, we accept empty responses as well and just set data to null for this case. \n                result.data = xhr.response ? JSON.parse(xhr.response) : null;\n                result.success = true;\n                resolve(result);\n            } catch(e) {\n                // json parsing failed.\n                onFailure();\n            }\n        };\n\n        xhr.onload = onLoad;\n        xhr.onerror = onFailure;\n        xhr.ontimeout = onFailure;\n        xhr.onabort = onFailure;\n        \n        xhr.send(body && JSON.stringify(body));\n    });\n};\n\nexport const sendRequestWithRetry = async(getAccessToken, url, operation, body) => {\n    const doRequest = () => sendRequest(getAccessToken, url, operation, body);\n    const isSuccess = res => res.success;\n    return await new Retry().run(doRequest, isSuccess);\n};\n","import AlignedItemNucleus from './AlignedItemNucleus';\nimport { sendRequestWithRetry } from './RequestUtils';\n\nconst av = Autodesk.Viewing;\nconst avp = av.Private;\n\n// We use the DefaultSpaceId for all requests\nconst DefaultSpaceId = 'default';\n\n// For debugging: Display reports of fetched/posted transforms\nconst DEBUG_OUTPUT = false;\n\n// Only for debugging: Find model name for given encoded urn\nconst urnToModelName = (urn) => {\n    // eslint-disable-next-line no-undef\n    const nodes = LMV_MAIN_VIEW.getVisibleNodes();\n    const node = nodes.find(node => node.getRootNode().urn() == urn);\n    return node?.getModelName() || `Unknown urn: ${urn}`;\n};\n\n// Todo: This should be shared at a more central place.\n//\n// returns an array of arrays each having at most chunkSize elements\n// TypeScript version:\nfunction chunk(array, chunkSize) {\n    const chunks = [];\n    for (let i = 0; i < array.length; i += chunkSize) {\n        chunks.push(array.slice(i, i + chunkSize));\n    }\n    return chunks;\n}\n\n// Combines strings to uniquely address an AlignedItem for 2D or 3D.\nexport class AlignedItemID {\n\n    // @param {string} urn - base64-encoded versionUrn, e.g. \"dXJuOmFkc2sud2lwc3RnOmZzLmZpbGU6dmYuYi1oeldxakxTS0c2VlZvVTRZNm5KQT92ZXJzaW9uPTE\"\n    // @param {string} viewablePartId - viewable part id - name of the specific viewable, e.g. \"Second Floor\"\n    constructor(versionUrn, viewablePartId = undefined) {\n\n        // base64-encoded versionUrn, e.g. \"dXJuOmFkc2sud2lwc3RnOmZzLmZpbGU6dmYuYi1oeldxakxTS0c2VlZvVTRZNm5KQT92ZXJzaW9uPTE\"\n        this.versionUrn = versionUrn;\n\n        // Only used for 2D: Id of view and region within the model\n        this.viewablePartId = viewablePartId;\n    }\n\n    // Convert array of urn strings to AlignedItem (if no partIds are needed) \n    //  @param {string[]} \n    static fromUrns(urns) {\n        return urns && urns.map(urn => new AlignedItemID(urn));\n    }\n\n    // Convert into object that we can serialize into a json request body\n    toObject() {\n        return {\n            // Note that (unlike most LMV code) alignment service backend works with decoded urns.\n            versionUrn: avp.fromUrlSafeBase64(this.versionUrn),\n\n            // Make sure they are set to undefined unless actually specified\n            viewablePartId: this.viewablePartId || undefined,\n        };\n    }\n\n    toString() {\n        return `${this.versionUrn}${this.viewablePartId ? `__${ this.viewablePartId }` : ''}`;\n    }\n}\n\n// Choose serviceUrl based on lmv environment (e.g. 'https://developer-stg.api.autodesk.com/construction/alignment' for staging)\nconst getDefaultServiceUrl = (docsEnv) => {\n    const envConfig = av.EnvironmentConfigurations[av.getEnv()];\n    const baseUrl = envConfig.UPSTREAM || envConfig.ROOT;\n    const envSuffix = docsEnv === 'QA' ? '-dev' : '';\n    return baseUrl + '/construction/alignment' + envSuffix;\n};\n\nconst getDefaultToken = () => {\n    return av.token.accessToken;\n};\n\n// Helper class to communicate with Nucleus AlignmentService backend\n//\n// Note:\n//  - All urns must belong to the same projectUrn\n//  - Particularly, projectUrn must not change at runtime.\nexport class NucleusAlignmentAPI {\n\n    // @param {string}           projectId             - E.g., 'e8c04026-1dc3-473b-bf1e-deedac2576ee'.\n    // @param {async ()=>string} [getAccessToken]      - By default, we get the token from LMV.\n    // @param {string}           [docsEnv]             - Docs environment. E.g. 'QA'.\n    // @param {string}           [serviceBaseUrl]      - Automatically derived from LMV env by default. E.g. 'https://developer-stg.api.autodesk.com/construction/alignment'\n    // @param {string}           [serviceVersion=\"v1\"]\n    // @param {function()}       [onError]\n    constructor({\n        projectId, \n        getAccessToken = getDefaultToken,\n        docsEnv = '',\n        serviceBaseUrl = getDefaultServiceUrl(docsEnv),\n        serviceVersion = \"v1\",\n        onError = null\n    } = {}) {\n\n        this.projectId = projectId;\n        this.getAccessToken = getAccessToken;\n        this.onError = onError;\n\n        this.serviceUrl = `${serviceBaseUrl}/${serviceVersion}`;\n\n        // Endpoint to read/write alignment items\n        this.itemsEndPoint = `/projects/${projectId}/spaces/${DefaultSpaceId}/items`;\n\n        this.url = this.serviceUrl + this.itemsEndPoint;\n    }\n\n\n    // Batch-request multiple items\n    //\n    // @param {AlignedItemID[]} items\n    // @returns {Object|undefined} A dictionary of AlignedItems, indexed by (encoded) versionUrn. Undefined on failure. \n    async fetchItems(items) {\n\n        const result = {};\n\n        // Avoid sending a request if the list is empty anyway.\n        if (!items.length) {\n            return result;\n        }\n\n        // Batch requests are limited to 20 items per request.\n        // https://stoplight.autodesk.com/bim360/bim360-nucleus-alignment/version%2F1.0/bim360-nucleus-alignment.oas3.yaml?view=%2Falignment-aligned-items%2Fgetaligneditembatch\n        // \n        // => Split if we have more.\n        const MaxItems = 20;\n        const chunks = chunk(items, MaxItems);\n        const promises = chunks.map(c => this._doBatchRequest(c, result));\n        await Promise.all(promises);\n        return result;\n    }\n\n    // Internal function to do a single batch request to query up to 20 items.\n    //\n    // @param {AlignmentItemId[]) itmes  - Single chunk of items. Max 20 items to request!\n    // @param {Object|undeinfed}  result - A dictionary of AlignedItems, indexed by (encoded) versionUrn. All obtained results are added to that dictionary. \n    async _doBatchRequest(items, result) {\n\n        // List items in request body\n        const body = {};\n        for (let i=0; i<items.length; i++) {\n            body[i] = items[i].toObject();\n        }\n\n        const postFix = ':getBatch';\n        const res = await sendRequestWithRetry(this.getAccessToken, this.url + postFix, 'POST', body);\n\n        // Report failure\n        if (!res.success) {\n            this.onError();\n            return;\n        }\n\n        // get response data (should exist)\n        const response = res.data;\n        if (!response) {\n            // Even if there are no alignments at all, the return value should be an empty object at the minimum\n            console.warn('Unepxected request response: items:getBatch should get an empty response');\n            return;\n        }\n        const loadedItems = response.results;\n\n        // get alignment data from each item.\n        // Response is not an array, but the keys for indexing are the same as we used in the body,\n        // so that they will just be indexed by array indices into the items array.\n        for (let i=0; i<items.length; i++) {\n\n            // get encoded versionUrn \n            const alignedItemId = new AlignedItemID(items[i].versionUrn, items[i].viewablePartId);\n            const key = alignedItemId.toString();\n\n            // Add items to result map, indexed by versionUrn.\n            // data will be null if no data was saved for this item before.\n            // In this case, we return a new \"blank\" AlignedItem, i.e. no transform and isLocked = false.\n            const data = loadedItems && loadedItems[i];\n            result[key] = data ? new AlignedItemNucleus().load(data) : new AlignedItemNucleus(alignedItemId);\n        }\n\n        // Optional debug output\n        if (DEBUG_OUTPUT) {\n            var report = {};\n            for (let i=0; i<items.length; i++) {\n                const name = urnToModelName(items[i].versionUrn);\n                const data = loadedItems && loadedItems[i];\n                report[name] = data || 'No alignment';\n            }\n            console.log('Fetch successful:', report); \n        }\n\n        return result;\n    }\n\n    // Store alignment item or create a new one.\n    //\n    // Note: Saving an item doesn't include the isLocked-flag, because setting the locked flag within an item-save request is not supported by alignmentService.\n    //       Setting the lockFlag requires a separate request to another endpoint.\n    async saveItem(item) {\n\n        const body = item.toObject();\n\n        // Decide which operation to perform:\n        //  - POST:   Item doesn't exist on alignment service yet => Create a new one.\n        //  - PATCH:  Modify or remove transform of existing item.\n        //\n        // Note: Even when resetting the transform back to source file transform, we must never send DELETE. Deleting an item would not guarantee\n        //       that the transform is always reset to the source file transform: If there is no alignment item for a versionUrn, the alignment transform\n        //       is inherited from the previous versions. So, instead of reseting to source-file transform, deleting the item would just \n        //       \"reset it to the state of the previous version\".\n        //\n        //       Example:\n        //         - Assume model v1 was aligned, then model was updated to v2, and finally v2 was aligned again.\n        //         - If we delete the alignment of v2, v2 would then inherit the alignment from v1.\n        //         - Expected behavior is: v1 keeps its alignment, but v2 is reset to source-file transform. \n        //           => We still have to store an alignment item, just with transform null. \n        //\n        const operation = item.existsOnServer() ? 'PATCH' : 'POST';\n        const res = await sendRequestWithRetry(this.getAccessToken, this.url, operation, body);\n\n        if (!res.success) {\n            this.onError();\n            return false;\n        }\n\n        // On success, update item with response from AlignmentService. Transform should usually\n        // keep the same, but checksum and timestamp will change.\n        if (res.data) {\n            item.load(res.data);\n        } else {\n            // item has been deleted from server. So, we must reset its checksum so that we don't try\n            // to send PATCH requests on next change.\n            item.checksum = undefined;\n\n            // If operation is delete, the response will be empty. In this case, we can keep the cache\n            // item as it is, because it already indicates that no transform is set.\n            (operation == 'DELETE') || console.warn('Unexpected request result: POST or PATCH should always respond an update item state'); \n        }\n\n        // Optional debug output\n        if (DEBUG_OUTPUT) {\n            const name = urnToModelName(item.versionUrn);\n            const report = {\n                model: name,\n                response: res.data,\n                operation\n            };\n\n            console.log('Transform saved: ', report);\n        }\n\n        return true;\n    }\n\n    // Note: Removing the alignment item will change the alignment to whatever state was defined by previous versions.\n    //       Therefore, actual delete is currently only used for debugging purposes. Resetting alignment is done by\n    //       changing the transform to null, but keeping the item live (see saveItem comments for details).\n    //\n    // @param {AlignedItemID} item\n    async deleteItem(item) {\n        const body = item.toObject();\n        await sendRequestWithRetry(this.getAccessToken, this.url, 'DELETE', body);\n    }\n\n    // Send request to lock or unlock an item.\n    //\n    // Requirements:\n    //  - Item must exist server-side and reflect latest state\n    //  - It must be ensured that the same item isn't locked/unlocked twice.\n    //  - Unlock only works with admin priviledges\n    //\n    // @param {AlignedItemNucleus} item\n    // @param {bool}               lock - whether to lock or unlock\n    async setItemLocked(item, lock) {\n\n        const data = item.toObject();\n        const body = {\n            versionUrn:     data.versionUrn,\n            viewablePartId: data.viewablePartId\n        };\n\n        const postFix = lock ? ':lock' : ':unlock';\n        const res = await sendRequestWithRetry(this.getAccessToken, this.url + postFix, 'PATCH', body);\n        if (!res.success) {\n            this.onError();\n            return;\n        }\n\n        // update item from server response. This should set the lock flag and update the checksum. \n        item.load(res.data);\n    }\n}\n","import { sendRequestWithRetry } from './RequestUtils';\n\nconst av = Autodesk.Viewing;\nconst avp = av.Private;\n\n// Choose serviceUrl based on lmv environment (e.g. 'https://developer-stg.api.autodesk.com/bim360/relationship-dev' for QA)\nconst getDefaultServiceUrl = (docsEnv) => {\n    const envConfig = av.EnvironmentConfigurations[av.getEnv()];\n    const baseUrl = envConfig.UPSTREAM || envConfig.ROOT;\n    const envSuffix = docsEnv === 'QA' ? '-dev' : '';\n    return baseUrl + '/bim360/relationship' + envSuffix;\n};\n\nconst getDefaultToken = () => {\n    return av.token.accessToken;\n};\n\n// Relationship entity ID is defined by lineageUrn + viewablePart + region.\nconst getRelationshipEntityId = (lineageUrn, viewablePart, region) => {\n    // https://wiki.autodesk.com/pages/viewpage.action?spaceKey=ACSB4C&title=Relationship+Service+Alignment+Authorizer\n    return `${lineageUrn}?${Autodesk.AlignmentService.RelationshipIdPrefix.Name}${encodeURIComponent(viewablePart)}${region ? `${Autodesk.AlignmentService.RelationshipIdPrefix.Region}${region}` : ''}`;\n};\n\nconst Domain = 'autodesk-construction-alignment';\n\n// Helper class to communicate with Nucleus Relationship Service backend\n//\n// Note:\n//  - All urns must belong to the same projectUrn\n//  - Particularly, projectUrn must not change at runtime.\nexport class NucleusRelationshipAPI {\n\n    // @param {string}           projectId             - E.g., 'e8c04026-1dc3-473b-bf1e-deedac2576ee'.\n    // @param {async ()=>string} [getAccessToken]      - By default, we get the token from LMV.\n    // @param {string}           [docsEnv]             - Docs environment. E.g. 'QA'.\n    // @param {string}           [serviceBaseUrl]      - Automatically derived from LMV env by default. E.g. 'https://developer-stg.api.autodesk.com/bim360/relationship'\n    // @param {string}           [serviceVersion=\"v2\"]\n    // @param {function()}       [onError]\n    constructor({\n        projectId, \n        getAccessToken = getDefaultToken,\n        docsEnv = '',\n        serviceBaseUrl = getDefaultServiceUrl(docsEnv),\n        serviceVersion = \"v2\",\n        onError = null\n    } = {}) {\n\n        this.projectId = projectId;\n        this.getAccessToken = getAccessToken;\n        this.onError = onError;\n\n        this.serviceUrl = `${serviceBaseUrl}/${serviceVersion}`;\n\n        // Endpoint to read/write alignment items\n        this.itemsEndPoint = `/containers/${projectId}/relationships`;\n\n        this.url = this.serviceUrl + this.itemsEndPoint;\n    }\n\n    async getRelationships(type, lineageUrn, viewablePartId, regionId) {\n\n        const id = getRelationshipEntityId(lineageUrn, viewablePartId, regionId);\n        const idEncoded = encodeURIComponent(id); // When using the search API, id must be URI encoded.\n\n        const postFix = `:search?domain=${Domain}&type=${type}&id=${idEncoded}`;\n        const res = await sendRequestWithRetry(this.getAccessToken, this.url + postFix, 'GET');\n\n        // Report failure\n        if (!res.success) {\n            this.onError();\n            return [];\n        }\n\n        // get response data (should exist)\n        const relationships = res.data?.relationships;\n\n        if (!relationships) {\n            // Even if there are no alignments at all, the return value should be an empty object at the minimum\n            console.warn('Unepxected request response: relationships:search should get an empty array');\n            return [];\n        }\n\n        // Decode ID for each entity. Viewer should not care that the service requires that it should be encoded.\n        relationships.forEach(relationship => {\n            relationship.entities.forEach(entity => {\n                entity.id = decodeURIComponent(entity.id);\n            });\n        });\n\n        return relationships;\n    }\n\n    async saveRelationship(modelLineageUrn, modelViewablePartId, sheetLineageUrn, sheetViewablePartId, regionId) {\n        const sheetEntityId = getRelationshipEntityId(sheetLineageUrn, sheetViewablePartId, regionId);\n        const modelEntityId = getRelationshipEntityId(modelLineageUrn, modelViewablePartId);\n\n        // this is how this structure that it is stored in real Relationship service.\n        const item = {\n            entities: [\n                {\n                    domain: Domain,\n                    type: Autodesk.AlignmentService.RelationshipEntityTypes.Region,\n                    id: sheetEntityId,\n                },\n                {\n                    domain: Domain,\n                    type: Autodesk.AlignmentService.RelationshipEntityTypes.Model3D,\n                    id: modelEntityId,\n                },\n            ],\n        };\n\n        const body = [item];\n\n        const res = await sendRequestWithRetry(this.getAccessToken, this.url, 'PUT', body);\n\n        if (!res.success) {\n            this.onError();\n            return false;\n        }\n\n        return true;\n    }\n\n    async deleteRelationship(relationshipId) {\n        const body = [relationshipId];\n\n        const postFix = ':delete';\n        const res = await sendRequestWithRetry(this.getAccessToken, this.url + postFix, 'POST', body);\n\n        // Report failure\n        if (!res.success) {\n            this.onError();\n            return;\n        }\n    }\n}\n","import AlignedItemNucleus from \"./AlignedItemNucleus\";\nimport AlignmentService from \"./AlignmentService\";\n\n// Using the cache in the LocalCS implementation is primarily for testing and as a reference implementation\n// for other (slower) services.\nimport AlignmentCache from \"./AlignmentCache\";\n\nimport { NucleusAlignmentAPI, AlignedItemID } from \"./NucleusAlignmentAPI\";\nimport { NucleusRelationshipAPI } from \"./NucleusRelationshipAPI\";\n\nconst isSameTransform = (tfOld, tfNew) => {\n\n    // If both transforms were not set, conisder them equal\n    if (!tfOld && !tfNew) {\n        return true;\n    }\n\n    if (tfOld && tfNew) {\n        return tfNew.equals(tfOld);\n    }\n    return false;\n};\n\n// Implements model-alignment storage based on Nucleus backend.\nexport default class AlignmentServiceNucleus extends AlignmentService {\n\n    // @param {Object}           options               - Additional initialization options:\n        // @param {string}           projectId             - E.g., 'e8c04026-1dc3-473b-bf1e-deedac2576ee'.\n        // @param {async ()=>string} [getAccessToken]      - By default, we get the token from LMV.\n        // @param {string}           [docsEnv]             - Docs environment. E.g. 'QA'.\n        // @param {string}           [serviceBaseUrl]      - Automatically derived from LMV env by default. E.g. 'https://developer-stg.api.autodesk.com/construction/alignment'\n        // @param {string}           [serviceVersion=\"v1\"]\n    constructor(options = {}) {\n        super();\n\n        // Activate error state if an error occurs\n        const onError = this.onError.bind(this);\n        options.onError = onError;\n        this.alignmentApi = new NucleusAlignmentAPI(options);\n        this.relationshipApi = new NucleusRelationshipAPI(options);\n\n        // Define function that the cache can use to perform batch requests \n        const fetchItems = async (alignedItemIDs) => {\n            return await this.alignmentApi.fetchItems(alignedItemIDs);\n        };\n\n        this.cache = new AlignmentCache(fetchItems);\n    }\n\n    async fetchItems(urns) {\n        const itemIds = AlignedItemID.fromUrns(urns);\n        await this.cache.fetchItems(itemIds);\n    }\n\n    getTransform(versionUrn, viewablePartId) {\n        // return transform - or undefined if not in cache\n        const alignedItemID = new AlignedItemID(versionUrn, viewablePartId);\n        const item = this.cache.getCachedItem(alignedItemID);\n\n        // Note: It's important to distinguish undefined vs. null here:\n        //  - If the item does not exists, we don't know the state => return undefined\n        //  - If the item exists, but has no transform, we know that no alignment transform is set => return null.\n        if (!item) {\n            return undefined;\n        } else if (!item.transform) {\n            return null;\n        }\n\n        // Return a copy, so that clients cannot accidentally modify it.\n        return item.transform.clone();\n    }\n\n    getIsLocked(versionUrn, viewablePartId) {\n        // return transform - or undefined if not in cache\n        const alignedItemID = new AlignedItemID(versionUrn, viewablePartId);\n        const item = this.cache.getCachedItem(alignedItemID);\n        return item ? Boolean(item.isLocked) : undefined;\n    }\n\n    async loadTransform(versionUrn, viewablePartId) {\n\n        const alignedItemID = new AlignedItemID(versionUrn, viewablePartId);\n        const item = await this.cache.getItem(alignedItemID);\n        return item?.transform?.clone() || null;\n    }\n\n    async saveTransform(versionUrn, viewablePartId, transform) {\n        const alignedItemID = new AlignedItemID(versionUrn, viewablePartId);\n        // get current item from cache\n        let item = await this.cache.getItem(alignedItemID);\n\n        // Do not save anything if there was no change anyway. E.g., if transform is null, because\n        // AlignmentService doesn't know about it, it's pointless to post a blank item just to tell that it's still null.\n        if (isSameTransform(item?.transform, transform)) {\n            return true;\n        }\n\n        // Update item in cache or create a new one\n        if (item) {\n            item.transform = transform;\n        } else {\n            // Transform was not saved before: Create a new item\n            item = new AlignedItemNucleus().createNew(alignedItemID, transform);\n            this.cache.setItem(alignedItemID, item);\n        }\n\n        // Note: If the server has changed meanwhile, we will overwrite it.\n        //       Ideally, we should have some conflict handling workflow for this case.\n        return await this.alignmentApi.saveItem(item);\n    }\n\n    async lockAlignment(versionUrn, viewablePartId) {\n        const alignedItemID = new AlignedItemID(versionUrn, viewablePartId);\n        let item = await this.cache.getItem(alignedItemID);\n\n        // Stop if already locked. Note that item always exists, because we add a new local item in the\n        // cache if item doesn't exist server-side, so that the item isn't requested again and can save local edits.\n        if (item.isLocked) {\n            return;\n        }\n\n        // Note that items may just exist locally. \n        const isSaved = item.existsOnServer();\n\n        // If there is no item, we have to create and save it to the service first.\n        if (!isSaved) {\n            await this.alignmentApi.saveItem(item);\n        }\n\n        // Lock-flag is not saved when saving a transform. The lock flag must be changed using a separate endpoint.\n        await this.alignmentApi.setItemLocked(item, true);\n    }\n\n    // Only used for testing. In practice, alignment \n    async unlockAlignment(versionUrn, viewablePartId) {\n        const alignedItemID = new AlignedItemID(versionUrn, viewablePartId);\n        const item = await this.cache.getItem(alignedItemID);\n\n        // Check if item is not locked anyway. Note that intial default state is unlocked.\n        // So, if there is no alignment item, we don't need unlock either.\n        if (!item || !item.isLocked) {\n            return;\n        }\n\n        await this.alignmentApi.setItemLocked(item, false);\n    }\n\n    async isAlignmentLocked(versionUrn, viewablePartId) {\n        const alignedItemID = new AlignedItemID(versionUrn, viewablePartId);\n        const item = await this.cache.getItem(alignedItemID);\n        return Boolean(item?.isLocked);\n    }\n\n    async saveRegion(versionUrn, viewablePartId, regionId, boundingBox, transform) { \n        const alignedItemID = new AlignedItemID(versionUrn, viewablePartId);\n        // get current item from cache\n        let item = await this.cache.getItem(alignedItemID);\n        \n        // Update item in cache or create a new one\n        if (!item) {\n            item = new AlignedItemNucleus().createNew(alignedItemID, transform);\n            this.cache.setItem(alignedItemID, item);\n        }\n\n        // if (!item.regions) {\n        //     item.regions = [];\n        // }\n        //TODO: BLMV-5813 - Multiple viewports are currently disabled, so always override the current regions\n        item.regions = [];\n\n        const regionsBackup = item.regions.slice();\n\n        // In case that this regionId already exists in the service, we'll override its content.\n        let index = item.regions.findIndex(region => region.regionId === regionId);\n        \n        if (index === -1) {\n            // Otherwise, we'll create a new entry to the array.\n            index = item.regions.length;\n        }\n\n        item.regions[index] = {\n            regionId,\n            boundingBox,\n            transform\n        };\n\n        // Note: If the server has changed meanwhile, we will overwrite it.\n        //       Ideally, we should have some conflict handling workflow for this case.\n        const res = await this.alignmentApi.saveItem(item);\n\n        if (!res) {\n            // Remove from cache if save failed\n            item.regions = regionsBackup;\n        }\n\n        return res;\n    }\n\n    async loadRegions(versionUrn, viewablePartId) {\n        const alignedItemID = new AlignedItemID(versionUrn, viewablePartId);\n        // get current item from cache\n        const item = await this.cache.getItem(alignedItemID);\n\n        const regions = item?.regions;\n\n        return regions || [];\n    }\n\n    async loadRegion(versionUrn, viewablePartId, regionId) {\n        const regions = await this.loadRegions(versionUrn, viewablePartId);\n\n        const region = regions.find(r => r.regionId === regionId);\n\n        return region || null;\n    }\n\n    async deleteRegion(lineageUrn, versionUrn, viewablePartId, regionId) {\n        const alignedItemID = new AlignedItemID(versionUrn, viewablePartId);\n\n        const relationships = await this.getRelationships(Autodesk.AlignmentService.RelationshipEntityTypes.Region, lineageUrn, viewablePartId, regionId);\n        if (!relationships.length) {\n            throw 'No relationship to delete';\n        }\n        \n        try {\n            await Promise.all(relationships.map(r => this.deleteRelationship(r.id)));\n        } catch (e) {\n            console.warn('Could not delete relationships');\n            throw e;\n        }\n\n        // get current item from cache\n        const item = await this.cache.getItem(alignedItemID);\n        const regions = item?.regions;\n        if (!regions) {\n            console.warn('No regions to delete');\n            return;\n        }\n\n        if (regions.length > 1) {\n            // Update the regions list. This will overwrite the item.\n            item.regions = regions.filter(r => r.regionId !== regionId);\n            await this.alignmentApi.saveItem(item);\n        } else {\n            // This is the only region in the item\n            this.deleteItem(versionUrn, viewablePartId);\n        }\n    }\n\n    async getRelationships(type, lineageUrn, viewablePartId, regionId) {\n\n        return await this.relationshipApi.getRelationships(type, lineageUrn, viewablePartId, regionId);\n    }\n\n    async saveRelationship(modelLineageUrn, modelViewablePartId, sheetLineageUrn, sheetViewablePartId, regionId) {\n\n        return await this.relationshipApi.saveRelationship(modelLineageUrn, modelViewablePartId, sheetLineageUrn, sheetViewablePartId, regionId);\n    }\n\n    // Delete item from backend.\n    async deleteRelationship(relationshipId) {\n        return await this.relationshipApi.deleteRelationship(relationshipId);\n    }\n\n    onError() {\n        // Report error state\n        this.error = true;\n    }\n\n    isWorking() {\n        return !this.error;\n    }\n\n    clearCache() {\n        this.cache.clear();\n    }\n\n    // Delete item from backend.\n    async deleteItem(versionUrn, partId) {\n\n        // If item doesn't exist server-side, do nothing to avoid request error\n        const itemId = new AlignedItemID(versionUrn, partId);\n        const item = await this.cache.getItem(itemId);\n        if (!item.existsOnServer()) {\n            return;\n        }\n\n        // If the item is locked, we have to unlock it first. Otherwise,\n        // alignmentService will refuse the delete request\n        if (item.isLocked) {\n            await this.unlockAlignment(versionUrn, partId);\n        }\n\n        // Remove from cache\n        this.cache.setItem(itemId, null);\n\n        // Send delete request\n        return await this.alignmentApi.deleteItem(itemId);\n    }\n}\n","import AlignmentServiceNucleus from './AlignmentServiceNucleus';\nimport { AlignedItemID } from './NucleusAlignmentAPI';\n\n// Extended variant of AlignmentServiceNucleus needed by Model Coordination:\n//\n// It allows for recovering previous alignment states - decoupled from the latest changes.\n//\n// For this, you specify alignment transforms and checksum for each model. If the checksum of an override\n// matches with the latest saved alignment state, the override is ignored and you can edit the model.\n//\n// If it doesn't (i.e. overriden state is outdated), the model is locked.\n//\n// Note that you must call (and await) the async function clearRedundantOverrides() to detect and unlock all overrides that\n// matches latest state.\nexport default class AlignmentServiceNucleusOverridable extends AlignmentServiceNucleus {\n\n    constructor(options) {\n        super(options);\n\n        // OverrideItems, indexed by (encoded) modelUrn, see typedef below.\n        this.items = {};\n    }\n\n    getTransform(versionUrn, viewablePartId) {\n\n        // If an override tf is defined, return this instead.\n        const overrideTf = this.getOverrideTransform(versionUrn, viewablePartId);\n        if (overrideTf !== undefined) {\n            return overrideTf ? overrideTf.clone() : null;\n        }\n\n        return super.getTransform(versionUrn, viewablePartId);\n    }\n\n    getIsLocked(versionUrn, viewablePartId) {\n\n        // If an override transform is used, the model is always locked for editing.\n        const overrideTf = this.getOverrideTransform(versionUrn, viewablePartId);\n        if (overrideTf !== undefined) {\n            return true;\n        }\n\n        return super.getIsLocked(versionUrn, viewablePartId);\n    }\n\n    async isAlignmentLocked(versionUrn, viewablePartId) {\n\n        // If an override transform is used, the model is always locked for editing.\n        const overrideTf = this.getOverrideTransform(versionUrn, viewablePartId);\n        if (overrideTf !== undefined) {\n            return true;\n        }\n\n        return await super.isAlignmentLocked(versionUrn, viewablePartId);\n    }\n\n    async loadTransform(versionUrn, viewablePartId) {\n\n        // If an override tf is defined, return this instead.\n        const overrideTf = this.getOverrideTransform(versionUrn, viewablePartId);\n        if (overrideTf !== undefined) {\n            return overrideTf;\n        }\n\n        return await super.loadTransform(versionUrn, viewablePartId);\n    }\n\n    // An OverrideItem defines the override transform for a single model:\n    //\n    // @typedef {\n    //    // must be 64-bit precision. Can be null to enforce original file transform.\n    //    transform: LmvMatrix4,\n    //\n    //    // Used to check whether the override matches with the latest state\n    //    // in alignmentService.\n    //    checksum:  string\n    //\n    //  } OverrideItem\n\n    // Set override transform for a set of models.\n    //\n    // Note:\n    //  - Overrides must be set before model loading, i.e. cannot be changed at runtime after loading.\n    //  - Alignment editing is only allowed if the checksum of the override matches with the latest state in alignment service.\n    //    Otherwise, the alignment editing is locked.\n    //\n    //  @param {Object.<string, OverrideItem>} items- Keys are base-64-encoded version urns. Values are Items.\n    setOverrideTransforms(items) {\n        this.items = items;\n    }\n\n    // Removes all overrides whose timestamp already matches with the latest\n    // state in alignment service. When using overrides, this function must be called\n    // (and waited for) before the editAPI can be used.\n    async clearRedundantOverrides() {\n\n        // Make sure that we fetch all in a single request, not one by one\n        const urns = Object.keys(this.items);\n        await this.fetchItems(urns);\n\n        // newItems is the subset of overrides that we have to keep active, because there is\n        // already a newer transform saved in alignment service.\n        const newItems = {};\n\n        urns.forEach(urn => {\n\n            // get latest item from cache\n            const itemId = new AlignedItemID(urn);\n            const latestItem = this.cache.getCachedItem(itemId);\n\n            // get corresponding override item\n            const overrideItem = this.items[urn];\n\n            // Compare checksums\n            //\n            // Note that both checksums may be null if no transform was saved at all.\n            // In this case, the overrideItem will usually not have a checksum either and\n            // we can consider it as being latest state.\n            const isLatest = latestItem.checksum == overrideItem.checksum;\n\n            // Note: https://jira.autodesk.com/browse/BIMCAS-13047\n            // Temporary workaround to check if latestItem.transform, override checksum & transform is null but the latest checksum is not null.\n            // If they're the same then this override alignment is the tip alignment, otherwise it is not the latest alignment.\n            // This resolves an issue in Model Coordination where Model Set service doesn't include checksum when alignment previously existed for a model.\n            // This can be removed when the Nucleus Model Set service includes the Alignment checksum for null alignment transforms where available.\n            const isLatestState =\n            overrideItem.checksum === null &&\n            overrideItem.transform === null &&\n            latestItem.transform === null\n              ? latestItem.versionUrn == urn\n              : isLatest;\n\n            // Only keep overrides for items that are not at latest state.\n            // For all latest ones, we drop the override, so that they can be edited.\n            if (!isLatestState) {\n                newItems[urn] = overrideItem;\n            }\n        });\n\n        this.items = newItems;\n    }\n\n    // Returns the override transform for the given urn (if specified).\n    // Return value is:\n    //  - undefined:  If no override is set\n    //  - null:       If null is set as override (= use file transform)\n    //  - LmvMatrix4: constant override transform\n    //\n    // @returns {LmvMatrix4|null|undefined}\n    getOverrideTransform(versionUrn, viewablePartId) {\n\n        // Overrides are only supported for 3D model alignment\n        if (viewablePartId) {\n            return undefined;\n        }\n\n        // Check if an override is defined for this urn.\n        const item = this.items[versionUrn];\n        if (!item) {\n            // No override => AlignmentService will return the actual transform.\n            return undefined;\n        }\n\n        // In case the returned matrix is modified for computations, this shouldn't accidentally\n        // change internal data. Therefore, return a copy instead of the original.\n        if (item.transform) {\n            return item.transform.clone();\n        }\n\n        // Return null to enforce original file tranform\n        return null;\n    }\n}\n","\nconst av = Autodesk.Viewing;\nconst namespace = AutodeskNamespace('Autodesk.ModelAlignmentService');\nconst myExtensionName = 'Autodesk.ModelAlignmentService';\n\nimport AlignmentService from './AlignmentService';\nimport AlignmentServiceLS from './AlignmentServiceLS';\nimport AlignmentServiceNucleus from './AlignmentServiceNucleus';\nimport AlignmentServiceNucleusOverridable from './AlignmentServiceNucleusOverridable';\nimport { NucleusAlignmentAPI } from './NucleusAlignmentAPI';\n\n/** \n * This extension defines the API for managing storage of model alignment transform\n * on a backend or in local storage. It provides a local-storage based implementation for reference. \n * The extension id is: `Autodesk.ModelAlignmentServiceAPI`\n */\nexport default class ModelAlignmentService extends av.Extension {\n    constructor(viewer, options) {\n        super(viewer, options);\n    }\n}\n\n// Register the extension with the extension manager.\nav.theExtensionManager.registerExtension(myExtensionName, ModelAlignmentService);\n\nnamespace.AlignmentService   = AlignmentService;\nnamespace.AlignmentServiceLS = AlignmentServiceLS;\nnamespace.NucleusAlignmentAPI = NucleusAlignmentAPI;\nnamespace.AlignmentServiceNucleus = AlignmentServiceNucleus;\nnamespace.AlignmentServiceNucleusOverridable = AlignmentServiceNucleusOverridable;\n"],"sourceRoot":""}