{"version":3,"file":"ModelAlignmentService/ModelAlignmentService.js","sources":["webpack://Autodesk.Extensions.[name]/webpack/bootstrap","webpack://Autodesk.Extensions.[name]/./extensions/ModelAlignmentService/AlignedItemNucleus.js","webpack://Autodesk.Extensions.[name]/./extensions/ModelAlignmentService/AlignmentCache.js","webpack://Autodesk.Extensions.[name]/./extensions/ModelAlignmentService/AlignmentService.js","webpack://Autodesk.Extensions.[name]/./extensions/ModelAlignmentService/AlignmentServiceLS.js","webpack://Autodesk.Extensions.[name]/./extensions/ModelAlignmentService/AlignmentServiceNucleus.js","webpack://Autodesk.Extensions.[name]/./extensions/ModelAlignmentService/AlignmentServiceNucleusOverridable.js","webpack://Autodesk.Extensions.[name]/./extensions/ModelAlignmentService/ModelAlignmentService.js","webpack://Autodesk.Extensions.[name]/./extensions/ModelAlignmentService/NucleusAlignmentAPI.js","webpack://Autodesk.Extensions.[name]/./extensions/ModelAlignmentService/NucleusRelationshipAPI.js","webpack://Autodesk.Extensions.[name]/./extensions/ModelAlignmentService/RequestUtils.js","webpack://Autodesk.Extensions.[name]/./node_modules/uuid/index.js","webpack://Autodesk.Extensions.[name]/./node_modules/uuid/lib/bytesToUuid.js","webpack://Autodesk.Extensions.[name]/./node_modules/uuid/lib/rng-browser.js","webpack://Autodesk.Extensions.[name]/./node_modules/uuid/v1.js","webpack://Autodesk.Extensions.[name]/./node_modules/uuid/v4.js"],"sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./extensions/ModelAlignmentService/ModelAlignmentService.js\");\n","function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError(\"Cannot call a class as a function\");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}var av = Autodesk.Viewing;\nvar avp = av.Private;\n\n// All data that is stored by the service per aligned item.\nvar AlignedItemNucleus = /*#__PURE__*/function () {\n\n  function AlignedItemNucleus(alignedItemID) {_classCallCheck(this, AlignedItemNucleus);\n    this.init(alignedItemID);\n  }_createClass(AlignedItemNucleus, [{ key: \"init\", value: function init(\n\n    alignedItemID) {\n      // {string} Generated by AlignmentSerivce. Needed to send requests to change this item, e.g., \"51a0d0bea901804d3e1870ea337b965d\"\n      //          May be undefined if item was not saved before. Mandatory if item exists on the backend.\n      this.checksum = undefined;\n\n      // {LMVMatrix4} Initially assume null = \"no alignment transform set\".\n      this.transform = null;\n\n      // {bool} whether alignment is locked\n      this.isLocked = false;\n\n      // {string} e.g., \"2020-11-23T21:54:28.9862331+00:00\"\n      this.updatedAt = undefined;\n\n      // {string} oxygenId of the last user who updated it\n      this.updatedBy = undefined;\n\n      // base64-encoded versionUrn, e.g. \"dXJuOmFkc2sud2lwc3RnOmZzLmZpbGU6dmYuYi1oeldxakxTS0c2VlZvVTRZNm5KQT92ZXJzaW9uPTE\"\n      this.versionUrn = alignedItemID === null || alignedItemID === void 0 ? void 0 : alignedItemID.versionUrn;\n\n      // viewable part id - name of the specific viewable, e.g. \"Second Floor\"\n      this.viewablePartId = alignedItemID === null || alignedItemID === void 0 ? void 0 : alignedItemID.viewablePartId;\n\n      // {Region[]} - optional array of 2D regions.\n      this.regions = undefined;\n    }\n\n    // Returns true if alignment/lock state is the same as for new items that the backend doesn't know about.\n  }, { key: \"isDefaultState\", value: function isDefaultState() {\n      return !this.transform && !this.isLocked && !this.regions;\n    } }, { key: \"resetToDefaultState\", value: function resetToDefaultState()\n\n    {\n      this.transform = null;\n      this.isLocked = false;\n      this.regions = null;\n    }\n\n    // Init new item before saving a transform for the first time\n    //  @param {string}     versionUrn - base64-encoded versionUrn\n    //  @param {LmvMatrix4} transform\n  }, { key: \"createNew\", value: function createNew(alignedItemID, transform) {\n      this.init();\n      this.versionUrn = alignedItemID.versionUrn;\n      this.viewablePartId = alignedItemID.viewablePartId;\n      this.transform = transform;\n      return this;\n    }\n\n    // Set from data that we got from alignment service\n  }, { key: \"load\", value: function load(data) {\n\n      // Note: The serivce works with unencoded versionUrns, e.g. 'urn:adsk.wipstg:fs.file:vf.vSenZnaYQAOAZqzHB54kLQ?version=1'.\n      //       However, the rest of LMV usually uses encoded ones. So, we only use the decoded ones when receiving or sending service data.\n      this.versionUrn = avp.toUrlSafeBase64(data.versionUrn);\n\n      // {string} viewable part id - name of the specific viewable, e.g. \"Second Floor\"\n      this.viewablePartId = data.viewablePartId;\n\n      if (data.regions) {\n        this.regions = data.regions.map(function (region) {\n          // If region contains a matrix (and it should), convert it into LmvMatrix\n          if (region.transform) {\n            region.transform = new avp.LmvMatrix4(true).fromArray(region.transform);\n          }\n\n          // Convert array into THREE.Box2\n          region.boundingBox = new THREE.Box2().set(\n          { x: region.boundingBox[0], y: region.boundingBox[1] },\n          { x: region.boundingBox[2], y: region.boundingBox[3] });\n\n\n          return region;\n        });\n      }\n\n      // {string} Generated by AlignmentSerivce. Needed to send requests to change this item, e.g., \"51a0d0bea901804d3e1870ea337b965d\"\n      //          May be undefined if item was not saved before. Mandatory if item exists on the backend.\n      this.checksum = data.checksum;\n\n      // {bool} whether alignment is locked\n      this.isLocked = data.isLocked || false;\n\n      // {string} e.g., \"2020-11-23T21:54:28.9862331+00:00\"\n      this.updatedAt = data.updatedAt;\n\n      // {string} oxygenId of the last user who updated it\n      this.updatedBy = data.updatedBy;\n\n      // Create LmvMatrix4 from float array\n      this.transform = Array.isArray(data === null || data === void 0 ? void 0 : data.transform) ? new avp.LmvMatrix4(true).fromArray(data === null || data === void 0 ? void 0 : data.transform) : null;\n\n      return this;\n    }\n\n    // If this item actually exists on the server, there must be a checksum provided by the backend.\n    // If there is none, this indicates that the item does not exist on the server yet.\n  }, { key: \"existsOnServer\", value: function existsOnServer() {\n      return Boolean(this.checksum);\n    }\n\n    // Convert into object that we can serialize into a json request body\n  }, { key: \"toObject\", value: function toObject() {\n      return {\n        checksum: this.checksum,\n        isLocked: this.isLocked,\n        transform: this.transform && Array.from(this.transform.elements),\n        regions: this.regions ? this.regions.map(function (r) {\n          var region = Object.assign({}, r);\n\n          // If region contains a matrix (and it should), convert it to number array first\n          if (region.transform) {\n            region.transform = Array.from(region.transform.elements);\n          }\n\n          // Convert THREE.Box2 into a flat array.\n          region.boundingBox = [region.boundingBox.min.x, region.boundingBox.min.y, region.boundingBox.max.x, region.boundingBox.max.y];\n          return region;\n        }) : undefined,\n        versionUrn: avp.fromUrlSafeBase64(this.versionUrn), // alignmentService requires decoded urns\n        viewablePartId: this.viewablePartId };\n\n    } }]);return AlignedItemNucleus;}();export { AlignedItemNucleus as default };","function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {try {var info = gen[key](arg);var value = info.value;} catch (error) {reject(error);return;}if (info.done) {resolve(value);} else {Promise.resolve(value).then(_next, _throw);}}function _asyncToGenerator(fn) {return function () {var self = this,args = arguments;return new Promise(function (resolve, reject) {var gen = fn.apply(self, args);function _next(value) {asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);}function _throw(err) {asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);}_next(undefined);});};}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError(\"Cannot call a class as a function\");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}\n\n// Helper class to implement batching and caching of alignment items (alignment transforms, locked-flags, and possible other service-specific data). \n//\n// Main purpose is to provide implementation of loadTransform/saveTransform in a way that\n// we don't fire a single request per call. Instead, all transforms can be prefetched in a single batch and loadTransform gets them from memory as soon as available.\nvar AlignmentCache = /*#__PURE__*/function () {\n\n  // The actual content of cached items is left to the client. The cache cannot add items itself.\n  //\n  // @param {async function(string[])} fetchItems - Async function to make batch requests. On success it returns a map from versionUrn to data items.\n  function AlignmentCache(fetchItems) {_classCallCheck(this, AlignmentCache);\n\n    // Keep callback to fetch items\n    this._fetchItems = fetchItems;\n\n    // AlignmentItems in memory. Indexed by alignedItemId key.\n    this.cache = {};\n\n    // If the alignment for an urn is not in memory, but already requested, this[urnToRequestIndex] gives us the index\n    // of the corresponding request in this.pendingRequests.\n    this.urnToRequestIndex = {};\n\n    // For each pending fetchItems-call, this array contains a promise that resolves when the request is finished.\n    this.pendingRequests = [null];\n  }_createClass(AlignmentCache, [{ key: \"clear\", value: function clear()\n\n    {\n      this.cache = {};\n    }\n\n    // Prefetch alignment items for a given list of urns and add them to the cache.\n  }, { key: \"fetchItems\", value: function () {var _fetchItems = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(alignedItemIds) {var _this = this;var needsLoad, requestIndex, promise, result;return regeneratorRuntime.wrap(function _callee$(_context) {while (1) {switch (_context.prev = _context.next) {case 0:\n\n                // Skip urls that we already know\n                needsLoad = function needsLoad(alignedItemId) {return !_this.cache[alignedItemId.toString()];};\n                alignedItemIds = alignedItemIds.filter(needsLoad);\n\n                // If all is in cache, we are done here\n                if (alignedItemIds.length) {_context.next = 4;break;}return _context.abrupt(\"return\");case 4:\n\n\n\n                // find free request index\n                requestIndex = 1;\n                while (this.pendingRequests[requestIndex]) {requestIndex++;}\n\n                // Mark all urns as pending and allow finding the request for a given urn\n                alignedItemIds.forEach(function (alignedItemId) {return _this.urnToRequestIndex[alignedItemId.toString()] = requestIndex;});\n\n                // Do the actual request\n                promise = this._fetchItems(alignedItemIds);\n\n                // Keep promise so that later fetchSingleItem() calls to any of the urns can return it.\n                this.pendingRequests[requestIndex] = promise;\n\n                // Wait for request result\n                _context.next = 11;return promise;case 11:result = _context.sent;\n\n                // remove promise from pendingRequests\n                this.pendingRequests[requestIndex] = null;\n\n\n                // If fetching succeeded, add results to cache.\n                // Otherwise, do nothing: It's up to the client to deal with errors\n                if (result) {\n                  alignedItemIds.forEach(function (alignedItemId) {\n                    var key = alignedItemId.toString();\n                    _this.cache[key] = result[key];\n                  });\n                }\n\n                // Mark urn as resolved and not pending anymore. Note that this always needs to happen, no matter whether successful or not.\n                alignedItemIds.forEach(function (alignedItemId) {\n                  // Use delete here to keep the dictionary cleaner. \n                  // Although it's a bit slower than setting to undefined, this doesn't matter here,\n                  // because the the call frequency is not critically high.\n                  delete _this.urnToRequestIndex[alignedItemId.toString()];\n                });case 15:case \"end\":return _context.stop();}}}, _callee, this);}));function fetchItems(_x) {return _fetchItems.apply(this, arguments);}return fetchItems;}()\n\n\n    // Return immediately whatever we have in cache\n  }, { key: \"getCachedItem\", value: function getCachedItem(alignedItemId) {\n      var key = alignedItemId.toString();\n      return this.cache[key];\n    } }, { key: \"getItem\", value: function () {var _getItem = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(\n\n      alignedItemId) {var item, key, requestIndex;return regeneratorRuntime.wrap(function _callee2$(_context2) {while (1) {switch (_context2.prev = _context2.next) {case 0:\n\n                // Return from memory if possible\n                item = this.getCachedItem(alignedItemId);if (!\n                item) {_context2.next = 3;break;}return _context2.abrupt(\"return\",\n                item);case 3:\n\n\n                // Ideally, this item should already be handled by a pending batch request.\n                // If so, we just wait for it to finish.\n                key = alignedItemId.toString();\n                requestIndex = this.urnToRequestIndex[key];if (!\n                requestIndex) {_context2.next = 10;break;}_context2.next = 8;return (\n\n                  this.pendingRequests[requestIndex]);case 8:_context2.next = 12;break;case 10:_context2.next = 12;return (\n\n\n\n                  this.fetchItems([alignedItemId]));case 12:return _context2.abrupt(\"return\",\n\n                this.getCachedItem(alignedItemId));case 13:case \"end\":return _context2.stop();}}}, _callee2, this);}));function getItem(_x2) {return _getItem.apply(this, arguments);}return getItem;}() }, { key: \"setItem\", value: function setItem(\n\n\n    alignedItemId, item) {\n      var key = alignedItemId.toString();\n      this.cache[key] = item;\n    } }]);return AlignmentCache;}();export { AlignmentCache as default };","function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {try {var info = gen[key](arg);var value = info.value;} catch (error) {reject(error);return;}if (info.done) {resolve(value);} else {Promise.resolve(value).then(_next, _throw);}}function _asyncToGenerator(fn) {return function () {var self = this,args = arguments;return new Promise(function (resolve, reject) {var gen = fn.apply(self, args);function _next(value) {asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);}function _throw(err) {asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);}_next(undefined);});};}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError(\"Cannot call a class as a function\");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}var namespace = AutodeskNamespace('Autodesk.AlignmentService');\n\n/* Interface for alignment service implementations. */var\nAlignmentService = /*#__PURE__*/function () {\n\n  function AlignmentService() {_classCallCheck(this, AlignmentService);}\n\n  /**\n                                                                          * Changes to false if any connection errors happened. As long as it returns true, you can safely assume that\n                                                                          * any returned results from getTransform() reflect the latest service state. \n                                                                          */_createClass(AlignmentService, [{ key: \"isWorking\", value: function isWorking()\n    {return true;} }, { key: \"clearCache\", value: function clearCache()\n\n    {}\n\n    /**\n       * Fetch alignment data for a batch of urns. This can be used to avoid individual requests for individual loadTransform()/isAlignmentLocked() calls. \n       *  @param {string[]} urns\n       *  @throws {Object} error\n       */ }, { key: \"fetchItems\", value: function () {var _fetchItems = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(\n      urns) {return regeneratorRuntime.wrap(function _callee$(_context) {while (1) {switch (_context.prev = _context.next) {case 0:case \"end\":return _context.stop();}}}, _callee);}));function fetchItems(_x) {return _fetchItems.apply(this, arguments);}return fetchItems;}()\n\n    /**\n                                                                                                                                                                                                                                                                                 * @param {string} versionUrn       - encoded versionUrn, e.g. dXJuOmFkc2sud2lwc3RnOmZzLmZpbGU6dmYuYi1oeldxakxTS0c2VlZvVTRZNm5KQT92ZXJzaW9uPTE\n                                                                                                                                                                                                                                                                                 * @param {string} [viewablePartId] - encoded viewableName of the model.\n                                                                                                                                                                                                                                                                                 * @throws {Object} error           - some implementation may throw. error.msg should provide an error message for logs.\n                                                                                                                                                                                                                                                                                 * @returns {LmvMatrix|null}        - Null means that no custom matrix was stored. Model will use its refPointTransform in this case.\n                                                                                                                                                                                                                                                                                 */ }, { key: \"loadTransform\", value: function () {var _loadTransform = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(\n      versionUrn, viewablePartId) {return regeneratorRuntime.wrap(function _callee2$(_context2) {while (1) {switch (_context2.prev = _context2.next) {case 0:return _context2.abrupt(\"return\",\n                null);case 1:case \"end\":return _context2.stop();}}}, _callee2);}));function loadTransform(_x2, _x3) {return _loadTransform.apply(this, arguments);}return loadTransform;}()\n\n\n    /**\n                                                                                                                                                                                             * Direct access to cached transform in memory: If a transform was loaded by loadTransform or fetch() before, this function allows to get it directly\n                                                                                                                                                                                             * within a sync function. However, note that it might return undefined if the transform state is not in memory yet.\n                                                                                                                                                                                             *  \n                                                                                                                                                                                             * NOTE: Once a transform was loaded, the AlignmentService implementation has to ensure that the result is cached and can be obtained again by this function.\n                                                                                                                                                                                             * \n                                                                                                                                                                                             * @returns {LmvMatrix|null|undefined} - Null: \"not set\", undefined: \"not in memory yet\".\n                                                                                                                                                                                             */ }, { key: \"getTransform\", value: function getTransform(\n    versionUrn, viewablePartId) {\n      return null;\n    }\n\n    /**\n       * Direct access to cached isLocked flag.\n       * @returns {bool|undefined} - undefined: \"not in memory yet\".\n       */ }, { key: \"getIsLocked\", value: function getIsLocked(\n    versionUrn, viewablePartId) {\n      return false;\n    }\n\n    /**\n       * @param {string} versionUrn            - encoded versionUrn, e.g. dXJuOmFkc2sud2lwc3RnOmZzLmZpbGU6dmYuYi1oeldxakxTS0c2VlZvVTRZNm5KQT92ZXJzaW9uPTE\n       * @param {string} [viewablePartId]      - encoded viewableName of the model.\n       * @param {LmvMatrix4|null} transform    - LmvMatrix with 64 bit precision. Call with null to reset alignment, so that the source-file refPointTransform is used again.\n       * @throws {Object}         error        - some implementation may throw. error.msg should provide an error message.\n       * @returns {boolean}                    - success / failed\n       */ }, { key: \"saveTransform\", value: function () {var _saveTransform = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(\n      versionUrn, viewablePartId, transform) {return regeneratorRuntime.wrap(function _callee3$(_context3) {while (1) {switch (_context3.prev = _context3.next) {case 0:case \"end\":return _context3.stop();}}}, _callee3);}));function saveTransform(_x4, _x5, _x6) {return _saveTransform.apply(this, arguments);}return saveTransform;}()\n\n    /**\n                                                                                                                                                                                                                                                                                                                                            * Mark alignment as locked, so that it cannot be changed anymore.\n                                                                                                                                                                                                                                                                                                                                            * @param {string} versionUrn       - encoded versionUrn, e.g. dXJuOmFkc2sud2lwc3RnOmZzLmZpbGU6dmYuYi1oeldxakxTS0c2VlZvVTRZNm5KQT92ZXJzaW9uPTE\n                                                                                                                                                                                                                                                                                                                                            * @param {string} [viewablePartId] - encoded viewableName of the model.\n                                                                                                                                                                                                                                                                                                                                            * @throws {Object}\n                                                                                                                                                                                                                                                                                                                                            */ }, { key: \"lockAlignment\", value: function () {var _lockAlignment = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(\n      versionUrn, viewablePartId) {return regeneratorRuntime.wrap(function _callee4$(_context4) {while (1) {switch (_context4.prev = _context4.next) {case 0:case \"end\":return _context4.stop();}}}, _callee4);}));function lockAlignment(_x7, _x8) {return _lockAlignment.apply(this, arguments);}return lockAlignment;}()\n\n    /**\n                                                                                                                                                                                                                                                                                                                             * Remove alignment lock, so that aligning is possible. We don't expose it per UI.\n                                                                                                                                                                                                                                                                                                                             * @param {string} versionUrn       - encoded versionUrn, e.g. dXJuOmFkc2sud2lwc3RnOmZzLmZpbGU6dmYuYi1oeldxakxTS0c2VlZvVTRZNm5KQT92ZXJzaW9uPTE\n                                                                                                                                                                                                                                                                                                                             * @param {string} [viewablePartId] - encoded viewableName of the model.\n                                                                                                                                                                                                                                                                                                                             * @throws {Object}\n                                                                                                                                                                                                                                                                                                                             */ }, { key: \"unlockAlignment\", value: function () {var _unlockAlignment = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(\n      versionUrn, viewablePartId) {return regeneratorRuntime.wrap(function _callee5$(_context5) {while (1) {switch (_context5.prev = _context5.next) {case 0:case \"end\":return _context5.stop();}}}, _callee5);}));function unlockAlignment(_x9, _x10) {return _unlockAlignment.apply(this, arguments);}return unlockAlignment;}()\n\n    /**\n                                                                                                                                                                                                                                                                                                                                   * Check if alignment is locked, so that it cannot be changed anymore.\n                                                                                                                                                                                                                                                                                                                                   * @param {string} versionUrn       - encoded versionUrn, e.g. dXJuOmFkc2sud2lwc3RnOmZzLmZpbGU6dmYuYi1oeldxakxTS0c2VlZvVTRZNm5KQT92ZXJzaW9uPTE\n                                                                                                                                                                                                                                                                                                                                   * @param {string} [viewablePartId] - encoded viewableName of the model.\n                                                                                                                                                                                                                                                                                                                                   * @throws {Object}\n                                                                                                                                                                                                                                                                                                                                   * @returns {boolean}\n                                                                                                                                                                                                                                                                                                                                   */ }, { key: \"isAlignmentLocked\", value: function () {var _isAlignmentLocked = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(\n      versionUrn, viewablePartId) {return regeneratorRuntime.wrap(function _callee6$(_context6) {while (1) {switch (_context6.prev = _context6.next) {case 0:case \"end\":return _context6.stop();}}}, _callee6);}));function isAlignmentLocked(_x11, _x12) {return _isAlignmentLocked.apply(this, arguments);}return isAlignmentLocked;}()\n\n    /**\n                                                                                                                                                                                                                                                                                                                                          * @param {string} versionUrn       - encoded versionUrn, e.g. dXJuOmFkc2sud2lwc3RnOmZzLmZpbGU6dmYuYi1oeldxakxTS0c2VlZvVTRZNm5KQT92ZXJzaW9uPTE\n                                                                                                                                                                                                                                                                                                                                          * @param {string} viewablePartId   - encoded viewableName of the 2d sheet.\n                                                                                                                                                                                                                                                                                                                                          * @param {string} regionId         - unique region id.\n                                                                                                                                                                                                                                                                                                                                          * @param {THREE.Box3} boundingBox  - bounding box of the region in model space.\n                                                                                                                                                                                                                                                                                                                                          * @param {string} units            - unit string of the bounding box, e.g. 'mm'.\n                                                                                                                                                                                                                                                                                                                                          * @throws {Object}         error   - some implementation may throw. error.msg should provide an error message.\n                                                                                                                                                                                                                                                                                                                                          * @returns {boolean}               - success / failed\n                                                                                                                                                                                                                                                                                                                                          */ }, { key: \"saveRegion\", value: function () {var _saveRegion = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7(\n      versionUrn, viewablePartId, regionId, boundingBox, units) {return regeneratorRuntime.wrap(function _callee7$(_context7) {while (1) {switch (_context7.prev = _context7.next) {case 0:case \"end\":return _context7.stop();}}}, _callee7);}));function saveRegion(_x13, _x14, _x15, _x16, _x17) {return _saveRegion.apply(this, arguments);}return saveRegion;}()\n\n    /**\n                                                                                                                                                                                                                                                                                                                                                                     * @param {string} versionUrn       - encoded versionUrn, e.g. dXJuOmFkc2sud2lwc3RnOmZzLmZpbGU6dmYuYi1oeldxakxTS0c2VlZvVTRZNm5KQT92ZXJzaW9uPTE\n                                                                                                                                                                                                                                                                                                                                                                     * @param {string} viewablePartId   - encoded viewableName of the 2d sheet.\n                                                                                                                                                                                                                                                                                                                                                                     * @param {string} regionId         - unique region id.\n                                                                                                                                                                                                                                                                                                                                                                     * @throws {Object} error           - some implementation may throw. error.msg should provide an error message for logs.\n                                                                                                                                                                                                                                                                                                                                                                     * @returns {Object|null}           - Null means that no custom region was stored.\n                                                                                                                                                                                                                                                                                                                                                                     */ }, { key: \"loadRegion\", value: function () {var _loadRegion = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee8(\n      versionUrn, viewablePartId, regionId) {return regeneratorRuntime.wrap(function _callee8$(_context8) {while (1) {switch (_context8.prev = _context8.next) {case 0:return _context8.abrupt(\"return\",\n                null);case 1:case \"end\":return _context8.stop();}}}, _callee8);}));function loadRegion(_x18, _x19, _x20) {return _loadRegion.apply(this, arguments);}return loadRegion;}()\n\n\n    /**\n                                                                                                                                                                                           * @param {string} [versionUrn]      - encoded versionUrn, e.g. dXJuOmFkc2sud2lwc3RnOmZzLmZpbGU6dmYuYi1oeldxakxTS0c2VlZvVTRZNm5KQT92ZXJzaW9uPTE\n                                                                                                                                                                                           * @param {string} [viewablePartId]  - encoded viewableName of the 2d sheet.\n                                                                                                                                                                                           * @throws {Object} error            - some implementation may throw. error.msg should provide an error message for logs.\n                                                                                                                                                                                           * @returns {object[]}               - Empty array means that no matching region was found.\n                                                                                                                                                                                           */ }, { key: \"loadRegions\", value: function () {var _loadRegions = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee9(\n      versionUrn, viewablePartId) {return regeneratorRuntime.wrap(function _callee9$(_context9) {while (1) {switch (_context9.prev = _context9.next) {case 0:return _context9.abrupt(\"return\",\n                []);case 1:case \"end\":return _context9.stop();}}}, _callee9);}));function loadRegions(_x21, _x22) {return _loadRegions.apply(this, arguments);}return loadRegions;}()\n\n\n    /**\n                                                                                                                                                                                      * @param {string} lineageUrn        - encoded lineageUrn of the model, e.g. dXJuOmFkc2sud2lwcWE6ZG0ubGluZWFnZTp2SlhCdld6WVFCV3FPVWd2NERyZndR\n                                                                                                                                                                                      * @param {string} [versionUrn]      - encoded versionUrn, e.g. dXJuOmFkc2sud2lwc3RnOmZzLmZpbGU6dmYuYi1oeldxakxTS0c2VlZvVTRZNm5KQT92ZXJzaW9uPTE\n                                                                                                                                                                                      * @param {string} [viewablePartId]  - encoded viewableName of the 2d sheet.\n                                                                                                                                                                                      * @param {string} regionId         - unique region id.\n                                                                                                                                                                                      * @throws {Object} error            - some implementation may throw. error.msg should provide an error message for logs.\n                                                                                                                                                                                      */ }, { key: \"deleteRegion\", value: function () {var _deleteRegion = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee10(\n      lineageUrn, versionUrn, viewablePartId, regionId) {return regeneratorRuntime.wrap(function _callee10$(_context10) {while (1) {switch (_context10.prev = _context10.next) {case 0:case \"end\":return _context10.stop();}}}, _callee10);}));function deleteRegion(_x23, _x24, _x25, _x26) {return _deleteRegion.apply(this, arguments);}return deleteRegion;}()\n\n    /**\n                                                                                                                                                                                                                                                                                                                                                                   * @param {string} modelLineageUrn       - encoded lineageUrn of the 3D model, e.g. dXJuOmFkc2sud2lwcWE6ZG0ubGluZWFnZTp2SlhCdld6WVFCV3FPVWd2NERyZndR\n                                                                                                                                                                                                                                                                                                                                                                   * @param {string} modelViewablePartId   - encoded viewableName of the 3D model\n                                                                                                                                                                                                                                                                                                                                                                   * @param {string} sheetLineageUrn       - encoded lineageUrn of the 2D sheet, e.g. dXJuOmFkc2sud2lwcWE6ZG0ubGluZWFnZTp2SlhCdld6WVFCV3FPVWd2NERyZndR\n                                                                                                                                                                                                                                                                                                                                                                   * @param {string} sheetViewablePartId   - encoded viewableName of the 2d sheet.\n                                                                                                                                                                                                                                                                                                                                                                   * @param {string} [regionId]            - A UUID of the sheet's region.\n                                                                                                                                                                                                                                                                                                                                                                   * @throws {Object} error                - some implementation may throw. error.msg should provide an error message.\n                                                                                                                                                                                                                                                                                                                                                                   * @returns {boolean}                    - success / failed\n                                                                                                                                                                                                                                                                                                                                                                   */ }, { key: \"saveRelationship\", value: function () {var _saveRelationship = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee11(\n      modelLineageUrn, modelViewablePartId, sheetLineageUrn, sheetViewablePartId, regionId) {return regeneratorRuntime.wrap(function _callee11$(_context11) {while (1) {switch (_context11.prev = _context11.next) {case 0:case \"end\":return _context11.stop();}}}, _callee11);}));function saveRelationship(_x27, _x28, _x29, _x30, _x31) {return _saveRelationship.apply(this, arguments);}return saveRelationship;}()\n\n    /**\n                                                                                                                                                                                                                                                                                                                                                                                                                         * Given a model urn & viewablePartId, return all the relationships that it's part of.\n                                                                                                                                                                                                                                                                                                                                                                                                                         * \n                                                                                                                                                                                                                                                                                                                                                                                                                         * @param {string} type              - `viewable` or `region`.\n                                                                                                                                                                                                                                                                                                                                                                                                                         * @param {string} lineageUrn        - encoded lineageUrn of the model, e.g. dXJuOmFkc2sud2lwcWE6ZG0ubGluZWFnZTp2SlhCdld6WVFCV3FPVWd2NERyZndR\n                                                                                                                                                                                                                                                                                                                                                                                                                         * @param {string} viewablePartId    - encoded viewableName of the model.\n                                                                                                                                                                                                                                                                                                                                                                                                                         * @param {string} [regionId]        - A UUID of the sheet's region.\n                                                                                                                                                                                                                                                                                                                                                                                                                         * @throws {Object} error            - some implementation may throw. error.msg should provide an error message for logs.\n                                                                                                                                                                                                                                                                                                                                                                                                                         * @returns {Object[]}\n                                                                                                                                                                                                                                                                                                                                                                                                                         */ }, { key: \"getRelationships\", value: function () {var _getRelationships = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee12(\n      type, lineageUrn, viewablePartId, regionId) {return regeneratorRuntime.wrap(function _callee12$(_context12) {while (1) {switch (_context12.prev = _context12.next) {case 0:return _context12.abrupt(\"return\",\n                null);case 1:case \"end\":return _context12.stop();}}}, _callee12);}));function getRelationships(_x32, _x33, _x34, _x35) {return _getRelationships.apply(this, arguments);}return getRelationships;}()\n\n\n    /**\n                                                                                                                                                                                                                      * @param {string} relationshipId - the UUID of the relationship to delete\n                                                                                                                                                                                                                      */ }, { key: \"deleteRelationship\", value: function deleteRelationship(\n    relationshipId) {} }]);return AlignmentService;}();export { AlignmentService as default };\n\n\nnamespace.RelationshipEntityTypes = {\n  Model3D: \"viewpart3d\",\n  Region: \"viewpartregion2d\" };\n\n\nnamespace.RelationshipIdPrefix = {\n  Name: 'viewablePart=',\n  Region: '&region=' };","function _typeof(obj) {\"@babel/helpers - typeof\";if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;};}return _typeof(obj);}function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {try {var info = gen[key](arg);var value = info.value;} catch (error) {reject(error);return;}if (info.done) {resolve(value);} else {Promise.resolve(value).then(_next, _throw);}}function _asyncToGenerator(fn) {return function () {var self = this,args = arguments;return new Promise(function (resolve, reject) {var gen = fn.apply(self, args);function _next(value) {asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);}function _throw(err) {asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);}_next(undefined);});};}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError(\"Cannot call a class as a function\");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}function _inherits(subClass, superClass) {if (typeof superClass !== \"function\" && superClass !== null) {throw new TypeError(\"Super expression must either be null or a function\");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}function _createSuper(Derived) {var hasNativeReflectConstruct = _isNativeReflectConstruct();return function _createSuperInternal() {var Super = _getPrototypeOf(Derived),result;if (hasNativeReflectConstruct) {var NewTarget = _getPrototypeOf(this).constructor;result = Reflect.construct(Super, arguments, NewTarget);} else {result = Super.apply(this, arguments);}return _possibleConstructorReturn(this, result);};}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");}return self;}function _isNativeReflectConstruct() {if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;if (Reflect.construct.sham) return false;if (typeof Proxy === \"function\") return true;try {Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));return true;} catch (e) {return false;}}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}import AlignmentService from \"./AlignmentService\";\nimport { v4 as getUUID } from 'uuid';\n\nvar avp = Autodesk.Viewing.Private;\n\n// Prefix used for LocalStorage entries for model-alignment\nvar keyPrefix = 'Autodesk.Viewing.ModelAlignment';\nvar APIs = {\n  Transform: 'transform',\n  Relationship: 'relationship' };\n\n\nvar RelationshipDomain = 'autodesk-construction-alignment';\n\nvar TokenSeparator = '__';\n\n// get LocalStorage key from model version urn\nvar getKey = function getKey(api, urn) {var viewablePartId = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n  return \"\".concat(keyPrefix).concat(TokenSeparator).concat(api).concat(TokenSeparator).concat(urn).concat(viewablePartId.length ? \"\".concat(TokenSeparator).concat(viewablePartId) : \"\");\n};\n\n// An single alignment item stored as json in LocalStorage  \nvar newTransformItem = function newTransformItem(transform) {\n  return {\n    // Optional: Array of floats\n    transform: transform ? transform.elements : null,\n\n    // If true, we forbid changing\n    isLocked: false };\n\n};\n\n// Relationship entity ID is defined by lineageUrn + viewablePart + region.\nvar getRelationshipEntityId = function getRelationshipEntityId(lineageUrn, viewablePart, region) {\n  return \"\".concat(lineageUrn, \"?\").concat(Autodesk.AlignmentService.RelationshipIdPrefix.Name).concat(viewablePart).concat(region ? \"\".concat(Autodesk.AlignmentService.RelationshipIdPrefix.Region).concat(region) : '');\n};\n\n/* Implements model-alignment storage based on LocalStorage. */var\nAlignmentServiceLS = /*#__PURE__*/function (_AlignmentService) {_inherits(AlignmentServiceLS, _AlignmentService);var _super = _createSuper(AlignmentServiceLS);\n\n  function AlignmentServiceLS() {var _this;var localStorage = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : avp.LocalStorage;_classCallCheck(this, AlignmentServiceLS);\n    _this = _super.call(this);\n    _this.localStorage = localStorage;return _this;\n  }_createClass(AlignmentServiceLS, [{ key: \"getTransform\", value: function getTransform(\n\n    versionUrn, viewablePartId) {\n      // just read directly from localStorage\n      // Note: It's essential to return null (not undefined) if no matrix is set,\n      //       because \"undefined\" would indicate that the state is not in memory yet.\n      var item = this.loadItem(APIs.Transform, versionUrn, viewablePartId);\n      return (item === null || item === void 0 ? void 0 : item.transform) || null;\n    } }, { key: \"getIsLocked\", value: function getIsLocked(\n\n    versionUrn, viewablePartId) {\n      // item may be null if nothing was saved for this urn so far. In this case, isLocked is always false. \n      var item = this.loadItem(APIs.Transform, versionUrn, viewablePartId);\n      return Boolean(item === null || item === void 0 ? void 0 : item.isLocked);\n    }\n\n    /**\n      * @param {string} versionUrn       - encoded versionUrn, e.g. dXJuOmFkc2sud2lwc3RnOmZzLmZpbGU6dmYuYi1oeldxakxTS0c2VlZvVTRZNm5KQT92ZXJzaW9uPTE\n      * @param {string} [viewablePartId] - encoded viewableName of the model.\n      * @throws {Object} error           - some implementation may throw. error.msg should provide an error message for logs.\n      * @returns {LmvMatrix|null}        - Null means that no custom matrix was stored. Model will use its refPointTransform in this case.\n      */ }, { key: \"loadTransform\", value: function () {var _loadTransform = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(\n      versionUrn, viewablePartId) {var item;return regeneratorRuntime.wrap(function _callee$(_context) {while (1) {switch (_context.prev = _context.next) {case 0:\n                item = this.loadItem(APIs.Transform, versionUrn, viewablePartId);return _context.abrupt(\"return\",\n                item === null || item === void 0 ? void 0 : item.transform);case 2:case \"end\":return _context.stop();}}}, _callee, this);}));function loadTransform(_x, _x2) {return _loadTransform.apply(this, arguments);}return loadTransform;}()\n\n\n    /**\n                                                                                                                                                                                                                                                     * @param {string} versionUrn       - encoded versionUrn, e.g. dXJuOmFkc2sud2lwc3RnOmZzLmZpbGU6dmYuYi1oeldxakxTS0c2VlZvVTRZNm5KQT92ZXJzaW9uPTE\n                                                                                                                                                                                                                                                     * @param {string} [viewablePartId] - encoded viewableName of the model.\n                                                                                                                                                                                                                                                     * @param {LmvMatrix4|null} transform  - LmvMatrix with 64 bit precision. Call with null to reset alignment, so that the source-file refPointTransform is used again.\n                                                                                                                                                                                                                                                     * @throws {Object}         error   - some implementation may throw. error.msg should provide an error message.\n                                                                                                                                                                                                                                                     */ }, { key: \"saveTransform\", value: function () {var _saveTransform = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(\n      versionUrn, viewablePartId, transform) {var item;return regeneratorRuntime.wrap(function _callee2$(_context2) {while (1) {switch (_context2.prev = _context2.next) {case 0:\n                item = this.loadItem(APIs.Transform, versionUrn, viewablePartId) || newTransformItem();\n                item.transform = transform;return _context2.abrupt(\"return\",\n                this.saveItem(APIs.Transform, versionUrn, viewablePartId, item));case 3:case \"end\":return _context2.stop();}}}, _callee2, this);}));function saveTransform(_x3, _x4, _x5) {return _saveTransform.apply(this, arguments);}return saveTransform;}()\n\n\n    /**\n                                                                                                                                                                                                                                                                  * Mark alignment as locked, so that it cannot be changed anymore.\n                                                                                                                                                                                                                                                                  * @param {string} versionUrn       - encoded versionUrn, e.g. dXJuOmFkc2sud2lwc3RnOmZzLmZpbGU6dmYuYi1oeldxakxTS0c2VlZvVTRZNm5KQT92ZXJzaW9uPTE\n                                                                                                                                                                                                                                                                  * @param {string} [viewablePartId] - encoded viewableName of the model.\n                                                                                                                                                                                                                                                                  * @throws {Object}\n                                                                                                                                                                                                                                                                  */ }, { key: \"lockAlignment\", value: function () {var _lockAlignment = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(\n      versionUrn, viewablePartId) {var item;return regeneratorRuntime.wrap(function _callee3$(_context3) {while (1) {switch (_context3.prev = _context3.next) {case 0:\n                item = this.loadItem(APIs.Transform, versionUrn, viewablePartId) || newTransformItem();\n                item.isLocked = true;return _context3.abrupt(\"return\",\n                this.saveItem(APIs.Transform, versionUrn, viewablePartId, item));case 3:case \"end\":return _context3.stop();}}}, _callee3, this);}));function lockAlignment(_x6, _x7) {return _lockAlignment.apply(this, arguments);}return lockAlignment;}()\n\n\n    /**\n                                                                                                                                                                                                                                                             * Check if alignment is locked, so that it cannot be changed anymore.\n                                                                                                                                                                                                                                                             * @param {string} versionUrn       - encoded versionUrn, e.g. dXJuOmFkc2sud2lwc3RnOmZzLmZpbGU6dmYuYi1oeldxakxTS0c2VlZvVTRZNm5KQT92ZXJzaW9uPTE\n                                                                                                                                                                                                                                                             * @param {string} [viewablePartId] - encoded viewableName of the model.\n                                                                                                                                                                                                                                                             * @throws {Object}\n                                                                                                                                                                                                                                                             * @returns {boolean}\n                                                                                                                                                                                                                                                             */ }, { key: \"isAlignmentLocked\", value: function () {var _isAlignmentLocked = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(\n      versionUrn, viewablePartId) {return regeneratorRuntime.wrap(function _callee4$(_context4) {while (1) {switch (_context4.prev = _context4.next) {case 0:return _context4.abrupt(\"return\",\n                this.getIsLocked(versionUrn, viewablePartId));case 1:case \"end\":return _context4.stop();}}}, _callee4, this);}));function isAlignmentLocked(_x8, _x9) {return _isAlignmentLocked.apply(this, arguments);}return isAlignmentLocked;}()\n\n\n    /**\n                                                                                                                                                                                                                                                      * @param {string} versionUrn       - encoded versionUrn, e.g. dXJuOmFkc2sud2lwc3RnOmZzLmZpbGU6dmYuYi1oeldxakxTS0c2VlZvVTRZNm5KQT92ZXJzaW9uPTE\n                                                                                                                                                                                                                                                      * @param {string} viewablePartId   - encoded viewableName of the 2d sheet.\n                                                                                                                                                                                                                                                      * @param {string} regionId         - unique region id.\n                                                                                                                                                                                                                                                      * @param {THREE.Box3} boundingBox         - bounding box of the viewport in model space.\n                                                                                                                                                                                                                                                      * @param {string} units            - unit string of the bounding box, e.g. 'mm'.\n                                                                                                                                                                                                                                                      * @throws {Object}         error   - some implementation may throw. error.msg should provide an error message.\n                                                                                                                                                                                                                                                      */ }, { key: \"saveRegion\", value: function () {var _saveRegion = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(\n      versionUrn, viewablePartId, regionId, boundingBox, transform) {var item, index;return regeneratorRuntime.wrap(function _callee5$(_context5) {while (1) {switch (_context5.prev = _context5.next) {case 0:\n                item = this.loadItem(APIs.Transform, versionUrn, viewablePartId) || newTransformItem();\n\n                if (!item.regions) {\n                  item.regions = [];\n                }\n\n                // In case that this regionId already exists in the service, we'll override its content.\n                index = item.regions.findIndex(function (region) {return region.regionId === regionId;});\n\n                if (index === -1) {\n                  // Otherwise, we'll create a new entry to the array.\n                  index = item.regions.length;\n                }\n\n                item.regions[index] = {\n                  regionId: regionId,\n                  boundingBox: boundingBox,\n                  transform: transform };return _context5.abrupt(\"return\",\n\n\n                this.saveItem(APIs.Transform, versionUrn, viewablePartId, item));case 6:case \"end\":return _context5.stop();}}}, _callee5, this);}));function saveRegion(_x10, _x11, _x12, _x13, _x14) {return _saveRegion.apply(this, arguments);}return saveRegion;}()\n\n\n    /**\n                                                                                                                                                                                                                                                                        * @param {string} versionUrn       - encoded versionUrn, e.g. dXJuOmFkc2sud2lwc3RnOmZzLmZpbGU6dmYuYi1oeldxakxTS0c2VlZvVTRZNm5KQT92ZXJzaW9uPTE\n                                                                                                                                                                                                                                                                        * @param {string} viewablePartId   - encoded viewableName of the 2d sheet.\n                                                                                                                                                                                                                                                                        * @param {string} regionId         - unique region id.\n                                                                                                                                                                                                                                                                        * @throws {Object} error           - some implementation may throw. error.msg should provide an error message for logs.\n                                                                                                                                                                                                                                                                        * @returns {Object|null}           - Null means that no custom viewport was stored.\n                                                                                                                                                                                                                                                                        */ }, { key: \"loadRegion\", value: function () {var _loadRegion = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(\n      versionUrn, viewablePartId, regionId) {var regions, region;return regeneratorRuntime.wrap(function _callee6$(_context6) {while (1) {switch (_context6.prev = _context6.next) {case 0:_context6.next = 2;return (\n                  this.loadRegions(versionUrn, viewablePartId));case 2:regions = _context6.sent;\n\n                region = regions.find(function (r) {return r.regionId === regionId;});return _context6.abrupt(\"return\",\n\n                region || null);case 5:case \"end\":return _context6.stop();}}}, _callee6, this);}));function loadRegion(_x15, _x16, _x17) {return _loadRegion.apply(this, arguments);}return loadRegion;}()\n\n\n    /**\n                                                                                                                                                                                                           * @param {string} [versionUrn]      - encoded versionUrn, e.g. dXJuOmFkc2sud2lwc3RnOmZzLmZpbGU6dmYuYi1oeldxakxTS0c2VlZvVTRZNm5KQT92ZXJzaW9uPTE\n                                                                                                                                                                                                           * @param {string} [viewablePartId]  - encoded viewableName of the 2d sheet.\n                                                                                                                                                                                                           * @throws {Object} error            - some implementation may throw. error.msg should provide an error message for logs.\n                                                                                                                                                                                                           * @returns {object[]}               - Empty array means that no matching viewport was found.\n                                                                                                                                                                                                           */ }, { key: \"loadRegions\", value: function () {var _loadRegions = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7(\n      versionUrn, viewablePartId) {var item, regions;return regeneratorRuntime.wrap(function _callee7$(_context7) {while (1) {switch (_context7.prev = _context7.next) {case 0:\n                item = this.loadItem(APIs.Transform, versionUrn, viewablePartId);\n\n                regions = item === null || item === void 0 ? void 0 : item.regions;return _context7.abrupt(\"return\",\n\n                regions || []);case 3:case \"end\":return _context7.stop();}}}, _callee7, this);}));function loadRegions(_x18, _x19) {return _loadRegions.apply(this, arguments);}return loadRegions;}()\n\n\n    /**\n                                                                                                                                                                                                       * @param {string} lineageUrn        - encoded lineageUrn of the model, e.g. dXJuOmFkc2sud2lwcWE6ZG0ubGluZWFnZTp2SlhCdld6WVFCV3FPVWd2NERyZndR\n                                                                                                                                                                                                       * @param {string} [versionUrn]      - encoded versionUrn, e.g. dXJuOmFkc2sud2lwc3RnOmZzLmZpbGU6dmYuYi1oeldxakxTS0c2VlZvVTRZNm5KQT92ZXJzaW9uPTE\n                                                                                                                                                                                                       * @param {string} [viewablePartId]  - encoded viewableName of the 2d sheet.\n                                                                                                                                                                                                       * @param {string} regionId         - unique region id.\n                                                                                                                                                                                                       * @throws {Object} error            - some implementation may throw. error.msg should provide an error message for logs.\n                                                                                                                                                                                                       */ }, { key: \"deleteRegion\", value: function () {var _deleteRegion = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee8(\n      lineageUrn, versionUrn, viewablePartId, regionId) {var relationship, item, regions;return regeneratorRuntime.wrap(function _callee8$(_context8) {while (1) {switch (_context8.prev = _context8.next) {case 0:\n                relationship = this.getRelationships(Autodesk.AlignmentService.RelationshipEntityTypes.Region, lineageUrn, viewablePartId, regionId);\n                this.deleteRelationship(relationship.id);\n\n                // get current item from cache\n                item = this.loadItem(APIs.Transform, versionUrn, viewablePartId);\n                regions = item === null || item === void 0 ? void 0 : item.regions;if (\n                regions) {_context8.next = 7;break;}\n                console.warn('No regions to delete');return _context8.abrupt(\"return\");case 7:\n\n\n\n                if (region.length > 1) {\n                  // Update the regions list. This will overwrite the item.\n                  item.regions = regions.filter(function (r) {return r.regionId !== regionId;});\n                  this.saveItem(APIs.Transform, versionUrn, viewablePartId, item);\n                } else {\n                  // This is the only region in the item\n                  this.deleteItem(APIs.Transform, versionUrn, viewablePartId);\n                }case 8:case \"end\":return _context8.stop();}}}, _callee8, this);}));function deleteRegion(_x20, _x21, _x22, _x23) {return _deleteRegion.apply(this, arguments);}return deleteRegion;}()\n\n\n\n    ////////// Relationship Service //////////////\n\n    /**\n    * @param {string} modelLineageUrn       - encoded versionUrn of the 3D model, e.g. dXJuOmFkc2sud2lwcWE6ZG0ubGluZWFnZTp2SlhCdld6WVFCV3FPVWd2NERyZndR\n    * @param {string} modelViewablePartId   - encoded viewableName of the 3D model\n    * @param {string} sheetLineageUrn       - encoded versionUrn of the 2D sheet, e.g. dXJuOmFkc2sud2lwcWE6ZG0ubGluZWFnZTp2SlhCdld6WVFCV3FPVWd2NERyZndR\n    * @param {string} sheetViewablePartId   - encoded viewableName of the 2d sheet.\n    * @param {string} [regionId]            - A UUID of the sheet's region.\n    * @throws {Object} error                - some implementation may throw. error.msg should provide an error message.\n    */ }, { key: \"saveRelationship\", value: function () {var _saveRelationship = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee9(\n      modelLineageUrn, modelViewablePartId, sheetLineageUrn, sheetViewablePartId, regionId) {var sheetEntityId, modelEntityId, relationshipId, item;return regeneratorRuntime.wrap(function _callee9$(_context9) {while (1) {switch (_context9.prev = _context9.next) {case 0:\n\n                sheetEntityId = getRelationshipEntityId(sheetLineageUrn, sheetViewablePartId, regionId);\n                modelEntityId = getRelationshipEntityId(modelLineageUrn, modelViewablePartId);\n\n                relationshipId = getUUID();\n\n                // this is how this structure that it is stored in real Relationship service.\n                item = {\n                  id: relationshipId,\n                  entities: [\n                  {\n                    domain: RelationshipDomain,\n                    type: Autodesk.AlignmentService.RelationshipEntityTypes.Region,\n                    id: sheetEntityId },\n\n                  {\n                    domain: RelationshipDomain,\n                    type: Autodesk.AlignmentService.RelationshipEntityTypes.Model3D,\n                    id: modelEntityId }] };\n\n\n\n\n                // In the mock service we save the relationship according to a unique key, just like it's gonna be saved in the relationship service.\n                return _context9.abrupt(\"return\", this.saveItem(APIs.Relationship, relationshipId, undefined, item));case 5:case \"end\":return _context9.stop();}}}, _callee9, this);}));function saveRelationship(_x24, _x25, _x26, _x27, _x28) {return _saveRelationship.apply(this, arguments);}return saveRelationship;}()\n\n\n    /**\n                                                                                                                                                                                                                                                                                                                              * Given a model urn & viewablePartId, return all the relationships that it's part of.\n                                                                                                                                                                                                                                                                                                                              * \n                                                                                                                                                                                                                                                                                                                              * @param {string} type              - `viewable` or `region`.\n                                                                                                                                                                                                                                                                                                                              * @param {string} lineageUrn        - encoded lineageUrn of the model, e.g. dXJuOmFkc2sud2lwcWE6ZG0ubGluZWFnZTp2SlhCdld6WVFCV3FPVWd2NERyZndR\n                                                                                                                                                                                                                                                                                                                              * @param {string} viewablePartId    - encoded viewableName of the model.\n                                                                                                                                                                                                                                                                                                                              * @param {string} [regionId]        - A UUID of the sheet's region.\n                                                                                                                                                                                                                                                                                                                              * @throws {Object} error            - some implementation may throw. error.msg should provide an error message for logs.\n                                                                                                                                                                                                                                                                                                                              * @returns {Object[]}\n                                                                                                                                                                                                                                                                                                                              */ }, { key: \"getRelationships\", value: function () {var _getRelationships = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee10(\n      type, lineageUrn, viewablePartId, regionId) {var results, entityId, keys, i, key, _candidate$entities, itemStr, candidate;return regeneratorRuntime.wrap(function _callee10$(_context10) {while (1) {switch (_context10.prev = _context10.next) {case 0:\n                results = [];\n\n                entityId = getRelationshipEntityId(lineageUrn, viewablePartId, regionId);\n\n                keys = avp.LocalStorage.getAllKeys();\n\n                // Simulates Relationship Service `search` API. The API can look for relationships according to `domain`, `type` & `entityId`.\n                for (i = 0; i < keys.length; i++) {\n                  key = keys[i];\n\n                  if (key.indexOf(APIs.Relationship) !== -1) {\n                    itemStr = avp.LocalStorage.getItem(key);\n                    candidate = itemStr && JSON.parse(itemStr);\n\n                    if (candidate === null || candidate === void 0 ? void 0 : (_candidate$entities = candidate.entities) === null || _candidate$entities === void 0 ? void 0 : _candidate$entities.some(function (entity) {return entity.id === entityId && entity.type === type;})) {\n                      results.push(candidate);\n                    }\n                  }\n                }return _context10.abrupt(\"return\",\n\n                results);case 5:case \"end\":return _context10.stop();}}}, _callee10);}));function getRelationships(_x29, _x30, _x31, _x32) {return _getRelationships.apply(this, arguments);}return getRelationships;}() }, { key: \"deleteRelationship\", value: function deleteRelationship(\n\n\n    relationshipId) {\n      this.deleteItem(APIs.Relationship, relationshipId);\n    } }, { key: \"loadItem\", value: function loadItem(\n\n    api, urn, viewablePartId) {\n      var key = getKey(api, urn, viewablePartId);\n      var itemStr = this.localStorage.getItem(key);\n      var item = itemStr && JSON.parse(itemStr);\n\n      // Convert array elements into LmvMatrix\n      if (item === null || item === void 0 ? void 0 : item.transform) {\n        item.transform = new avp.LmvMatrix4(true).fromArray(item.transform);\n      }\n\n      if (item === null || item === void 0 ? void 0 : item.regions) {\n        item.regions = item.regions.map(function (region) {\n          // If region contains a matrix (and it should), convert it into LmvMatrix\n          if (region.transform) {\n            region.transform = new avp.LmvMatrix4(true).fromArray(region.transform);\n          }\n\n          // Convert array into THREE.Box2\n          region.boundingBox = new THREE.Box2().set(\n          { x: region.boundingBox[0], y: region.boundingBox[1] },\n          { x: region.boundingBox[2], y: region.boundingBox[3] });\n\n\n          return region;\n        });\n      }\n\n      return item;\n    } }, { key: \"saveItem\", value: function saveItem(\n\n    api, urn, viewablePartId, item) {var _item, _item2;\n\n      // If the item contains a matrix, convert it to number array first\n      if ((_item = item) === null || _item === void 0 ? void 0 : _item.transform) {\n        item = Object.assign({}, item);\n\n        // Note that the Array.from(...) makes a difference here:\n        // TypedArrays (like matrix.elements) are not saved as arrays by JSON-stringify, but as objects,\n        // i.e., it would look like '{\"0\": 1, \"1\": 1, ... }' \n        // By converting to a JS array, the resulting json contains an actual array, i.e. \"[1, 0, 0, ... ]\"\n        item.transform = Array.from(item.transform.elements);\n      }\n\n      if ((_item2 = item) === null || _item2 === void 0 ? void 0 : _item2.regions) {\n        item = Object.assign({}, item);\n        item.regions = item.regions.map(function (r) {\n          var region = Object.assign({}, r);\n\n          // If region contains a matrix (and it should), convert it to number array first\n          if (region.transform) {\n            region.transform = Array.from(region.transform.elements);\n          }\n\n          // Convert THREE.Box2 into a flat array.\n          region.boundingBox = [region.boundingBox.min.x, region.boundingBox.min.y, region.boundingBox.max.x, region.boundingBox.max.y];\n          return region;\n        });\n      }\n\n      var key = getKey(api, urn, viewablePartId);\n      var itemStr = JSON.stringify(item);\n      this.localStorage.setItem(key, itemStr);\n\n      return true;\n    } }, { key: \"deleteItem\", value: function deleteItem(\n\n    api, urn, viewablePartId) {\n      var key = getKey(api, urn, viewablePartId);\n      this.localStorage.removeItem(key);\n    } }]);return AlignmentServiceLS;}(AlignmentService);\n\n\n// Implement LocalStorage interface, but just using a plain JS object for storage instead of actual LocalStorage.\nexport { AlignmentServiceLS as default };var ObjectLocalStorage = /*#__PURE__*/function () {\n\n  function ObjectLocalStorage() {_classCallCheck(this, ObjectLocalStorage);\n    this.data = {};\n  }_createClass(ObjectLocalStorage, [{ key: \"setItem\", value: function setItem(\n\n    key, item) {\n      this.data[key] = item;\n    } }, { key: \"getItem\", value: function getItem(\n\n    key) {\n      return this.data[key];\n    } }]);return ObjectLocalStorage;}();\n\n\nAlignmentService.ObjectLocalStorage = ObjectLocalStorage;","function _typeof(obj) {\"@babel/helpers - typeof\";if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;};}return _typeof(obj);}function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {try {var info = gen[key](arg);var value = info.value;} catch (error) {reject(error);return;}if (info.done) {resolve(value);} else {Promise.resolve(value).then(_next, _throw);}}function _asyncToGenerator(fn) {return function () {var self = this,args = arguments;return new Promise(function (resolve, reject) {var gen = fn.apply(self, args);function _next(value) {asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);}function _throw(err) {asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);}_next(undefined);});};}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError(\"Cannot call a class as a function\");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}function _inherits(subClass, superClass) {if (typeof superClass !== \"function\" && superClass !== null) {throw new TypeError(\"Super expression must either be null or a function\");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}function _createSuper(Derived) {var hasNativeReflectConstruct = _isNativeReflectConstruct();return function _createSuperInternal() {var Super = _getPrototypeOf(Derived),result;if (hasNativeReflectConstruct) {var NewTarget = _getPrototypeOf(this).constructor;result = Reflect.construct(Super, arguments, NewTarget);} else {result = Super.apply(this, arguments);}return _possibleConstructorReturn(this, result);};}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");}return self;}function _isNativeReflectConstruct() {if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;if (Reflect.construct.sham) return false;if (typeof Proxy === \"function\") return true;try {Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));return true;} catch (e) {return false;}}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}import AlignedItemNucleus from \"./AlignedItemNucleus\";\nimport AlignmentService from \"./AlignmentService\";\n\n// Using the cache in the LocalCS implementation is primarily for testing and as a reference implementation\n// for other (slower) services.\nimport AlignmentCache from \"./AlignmentCache\";\n\nimport { NucleusAlignmentAPI, AlignedItemID } from \"./NucleusAlignmentAPI\";\nimport { NucleusRelationshipAPI } from \"./NucleusRelationshipAPI\";\n\nvar isSameTransform = function isSameTransform(tfOld, tfNew) {\n\n  // If both transforms were not set, conisder them equal\n  if (!tfOld && !tfNew) {\n    return true;\n  }\n\n  if (tfOld && tfNew) {\n    return tfNew.equals(tfOld);\n  }\n  return false;\n};\n\n// Implements model-alignment storage based on Nucleus backend.\nvar AlignmentServiceNucleus = /*#__PURE__*/function (_AlignmentService) {_inherits(AlignmentServiceNucleus, _AlignmentService);var _super = _createSuper(AlignmentServiceNucleus);\n\n  // @param {Object}           options               - Additional initialization options:\n  // @param {string}           projectId             - E.g., 'e8c04026-1dc3-473b-bf1e-deedac2576ee'.\n  // @param {async ()=>string} [getAccessToken]      - By default, we get the token from LMV.\n  // @param {string}           [docsEnv]             - Docs environment. E.g. 'QA'.\n  // @param {string}           [serviceBaseUrl]      - Automatically derived from LMV env by default. E.g. 'https://developer-stg.api.autodesk.com/construction/alignment'\n  // @param {string}           [serviceVersion=\"v1\"]\n  function AlignmentServiceNucleus() {var _this;var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};_classCallCheck(this, AlignmentServiceNucleus);\n    _this = _super.call(this);\n\n    // Activate error state if an error occurs\n    var onError = _this.onError.bind(_assertThisInitialized(_this));\n    options.onError = onError;\n    _this.alignmentApi = new NucleusAlignmentAPI(options);\n    _this.relationshipApi = new NucleusRelationshipAPI(options);\n\n    // Define function that the cache can use to perform batch requests \n    var fetchItems = /*#__PURE__*/function () {var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(alignedItemIDs) {return regeneratorRuntime.wrap(function _callee$(_context) {while (1) {switch (_context.prev = _context.next) {case 0:_context.next = 2;return (\n                  _this.alignmentApi.fetchItems(alignedItemIDs));case 2:return _context.abrupt(\"return\", _context.sent);case 3:case \"end\":return _context.stop();}}}, _callee);}));return function fetchItems(_x) {return _ref.apply(this, arguments);};}();\n\n\n    _this.cache = new AlignmentCache(fetchItems);return _this;\n  }_createClass(AlignmentServiceNucleus, [{ key: \"fetchItems\", value: function () {var _fetchItems = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(\n\n      urns) {var itemIds;return regeneratorRuntime.wrap(function _callee2$(_context2) {while (1) {switch (_context2.prev = _context2.next) {case 0:\n                itemIds = AlignedItemID.fromUrns(urns);_context2.next = 3;return (\n                  this.cache.fetchItems(itemIds));case 3:case \"end\":return _context2.stop();}}}, _callee2, this);}));function fetchItems(_x2) {return _fetchItems.apply(this, arguments);}return fetchItems;}() }, { key: \"getTransform\", value: function getTransform(\n\n\n    versionUrn, viewablePartId) {\n      // return transform - or undefined if not in cache\n      var alignedItemID = new AlignedItemID(versionUrn, viewablePartId);\n      var item = this.cache.getCachedItem(alignedItemID);\n\n      // Note: It's important to distinguish undefined vs. null here:\n      //  - If the item does not exists, we don't know the state => return undefined\n      //  - If the item exists, but has no transform, we know that no alignment transform is set => return null.\n      if (!item) {\n        return undefined;\n      } else if (!item.transform) {\n        return null;\n      }\n\n      // Return a copy, so that clients cannot accidentally modify it.\n      return item.transform.clone();\n    } }, { key: \"getIsLocked\", value: function getIsLocked(\n\n    versionUrn, viewablePartId) {\n      // return transform - or undefined if not in cache\n      var alignedItemID = new AlignedItemID(versionUrn, viewablePartId);\n      var item = this.cache.getCachedItem(alignedItemID);\n      return item ? Boolean(item.isLocked) : undefined;\n    } }, { key: \"loadTransform\", value: function () {var _loadTransform = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(\n\n      versionUrn, viewablePartId) {var _item$transform;var alignedItemID, item;return regeneratorRuntime.wrap(function _callee3$(_context3) {while (1) {switch (_context3.prev = _context3.next) {case 0:\n\n                alignedItemID = new AlignedItemID(versionUrn, viewablePartId);_context3.next = 3;return (\n                  this.cache.getItem(alignedItemID));case 3:item = _context3.sent;return _context3.abrupt(\"return\",\n                (item === null || item === void 0 ? void 0 : (_item$transform = item.transform) === null || _item$transform === void 0 ? void 0 : _item$transform.clone()) || null);case 5:case \"end\":return _context3.stop();}}}, _callee3, this);}));function loadTransform(_x3, _x4) {return _loadTransform.apply(this, arguments);}return loadTransform;}() }, { key: \"saveTransform\", value: function () {var _saveTransform = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(\n\n\n      versionUrn, viewablePartId, transform) {var _item;var alignedItemID, item;return regeneratorRuntime.wrap(function _callee4$(_context4) {while (1) {switch (_context4.prev = _context4.next) {case 0:\n                alignedItemID = new AlignedItemID(versionUrn, viewablePartId);\n                // get current item from cache\n                _context4.next = 3;return this.cache.getItem(alignedItemID);case 3:item = _context4.sent;if (!\n\n\n\n                isSameTransform((_item = item) === null || _item === void 0 ? void 0 : _item.transform, transform)) {_context4.next = 6;break;}return _context4.abrupt(\"return\",\n                true);case 6:\n\n\n                // Update item in cache or create a new one\n                if (item) {\n                  item.transform = transform;\n                } else {\n                  // Transform was not saved before: Create a new item\n                  item = new AlignedItemNucleus().createNew(alignedItemID, transform);\n                  this.cache.setItem(alignedItemID, item);\n                }\n\n                // Note: If the server has changed meanwhile, we will overwrite it.\n                //       Ideally, we should have some conflict handling workflow for this case.\n                _context4.next = 9;return this.alignmentApi.saveItem(item);case 9:return _context4.abrupt(\"return\", _context4.sent);case 10:case \"end\":return _context4.stop();}}}, _callee4, this);}));function saveTransform(_x5, _x6, _x7) {return _saveTransform.apply(this, arguments);}return saveTransform;}() }, { key: \"lockAlignment\", value: function () {var _lockAlignment = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(\n\n\n      versionUrn, viewablePartId) {var alignedItemID, item, isSaved;return regeneratorRuntime.wrap(function _callee5$(_context5) {while (1) {switch (_context5.prev = _context5.next) {case 0:\n                alignedItemID = new AlignedItemID(versionUrn, viewablePartId);_context5.next = 3;return (\n                  this.cache.getItem(alignedItemID));case 3:item = _context5.sent;if (!\n\n\n\n                item.isLocked) {_context5.next = 6;break;}return _context5.abrupt(\"return\");case 6:\n\n\n\n                // Note that items may just exist locally. \n                isSaved = item.existsOnServer();\n\n                // If there is no item, we have to create and save it to the service first.\n                if (isSaved) {_context5.next = 10;break;}_context5.next = 10;return (\n                  this.alignmentApi.saveItem(item));case 10:_context5.next = 12;return (\n\n\n\n                  this.alignmentApi.setItemLocked(item, true));case 12:case \"end\":return _context5.stop();}}}, _callee5, this);}));function lockAlignment(_x8, _x9) {return _lockAlignment.apply(this, arguments);}return lockAlignment;}()\n\n\n    // Only used for testing. In practice, alignment \n  }, { key: \"unlockAlignment\", value: function () {var _unlockAlignment = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(versionUrn, viewablePartId) {var alignedItemID, item;return regeneratorRuntime.wrap(function _callee6$(_context6) {while (1) {switch (_context6.prev = _context6.next) {case 0:\n                alignedItemID = new AlignedItemID(versionUrn, viewablePartId);_context6.next = 3;return (\n                  this.cache.getItem(alignedItemID));case 3:item = _context6.sent;if (!(\n\n\n\n                !item || !item.isLocked)) {_context6.next = 6;break;}return _context6.abrupt(\"return\");case 6:_context6.next = 8;return (\n\n\n\n                  this.alignmentApi.setItemLocked(item, false));case 8:case \"end\":return _context6.stop();}}}, _callee6, this);}));function unlockAlignment(_x10, _x11) {return _unlockAlignment.apply(this, arguments);}return unlockAlignment;}() }, { key: \"isAlignmentLocked\", value: function () {var _isAlignmentLocked = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7(\n\n\n      versionUrn, viewablePartId) {var alignedItemID, item;return regeneratorRuntime.wrap(function _callee7$(_context7) {while (1) {switch (_context7.prev = _context7.next) {case 0:\n                alignedItemID = new AlignedItemID(versionUrn, viewablePartId);_context7.next = 3;return (\n                  this.cache.getItem(alignedItemID));case 3:item = _context7.sent;return _context7.abrupt(\"return\",\n                Boolean(item === null || item === void 0 ? void 0 : item.isLocked));case 5:case \"end\":return _context7.stop();}}}, _callee7, this);}));function isAlignmentLocked(_x12, _x13) {return _isAlignmentLocked.apply(this, arguments);}return isAlignmentLocked;}() }, { key: \"saveRegion\", value: function () {var _saveRegion = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee8(\n\n\n      versionUrn, viewablePartId, regionId, boundingBox, transform) {var alignedItemID, item, regionsBackup, index, res;return regeneratorRuntime.wrap(function _callee8$(_context8) {while (1) {switch (_context8.prev = _context8.next) {case 0:\n                alignedItemID = new AlignedItemID(versionUrn, viewablePartId);\n                // get current item from cache\n                _context8.next = 3;return this.cache.getItem(alignedItemID);case 3:item = _context8.sent;\n\n                // Update item in cache or create a new one\n                if (!item) {\n                  item = new AlignedItemNucleus().createNew(alignedItemID, transform);\n                  this.cache.setItem(alignedItemID, item);\n                }\n\n                // if (!item.regions) {\n                //     item.regions = [];\n                // }\n                //TODO: BLMV-5813 - Multiple viewports are currently disabled, so always override the current regions\n                item.regions = [];\n\n                regionsBackup = item.regions.slice();\n\n                // In case that this regionId already exists in the service, we'll override its content.\n                index = item.regions.findIndex(function (region) {return region.regionId === regionId;});\n\n                if (index === -1) {\n                  // Otherwise, we'll create a new entry to the array.\n                  index = item.regions.length;\n                }\n\n                item.regions[index] = {\n                  regionId: regionId,\n                  boundingBox: boundingBox,\n                  transform: transform };\n\n\n                // Note: If the server has changed meanwhile, we will overwrite it.\n                //       Ideally, we should have some conflict handling workflow for this case.\n                _context8.next = 12;return this.alignmentApi.saveItem(item);case 12:res = _context8.sent;\n\n                if (!res) {\n                  // Remove from cache if save failed\n                  item.regions = regionsBackup;\n                }return _context8.abrupt(\"return\",\n\n                res);case 15:case \"end\":return _context8.stop();}}}, _callee8, this);}));function saveRegion(_x14, _x15, _x16, _x17, _x18) {return _saveRegion.apply(this, arguments);}return saveRegion;}() }, { key: \"loadRegions\", value: function () {var _loadRegions = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee9(\n\n\n      versionUrn, viewablePartId) {var alignedItemID, item, regions;return regeneratorRuntime.wrap(function _callee9$(_context9) {while (1) {switch (_context9.prev = _context9.next) {case 0:\n                alignedItemID = new AlignedItemID(versionUrn, viewablePartId);\n                // get current item from cache\n                _context9.next = 3;return this.cache.getItem(alignedItemID);case 3:item = _context9.sent;\n\n                regions = item === null || item === void 0 ? void 0 : item.regions;return _context9.abrupt(\"return\",\n\n                regions || []);case 6:case \"end\":return _context9.stop();}}}, _callee9, this);}));function loadRegions(_x19, _x20) {return _loadRegions.apply(this, arguments);}return loadRegions;}() }, { key: \"loadRegion\", value: function () {var _loadRegion = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee10(\n\n\n      versionUrn, viewablePartId, regionId) {var regions, region;return regeneratorRuntime.wrap(function _callee10$(_context10) {while (1) {switch (_context10.prev = _context10.next) {case 0:_context10.next = 2;return (\n                  this.loadRegions(versionUrn, viewablePartId));case 2:regions = _context10.sent;\n\n                region = regions.find(function (r) {return r.regionId === regionId;});return _context10.abrupt(\"return\",\n\n                region || null);case 5:case \"end\":return _context10.stop();}}}, _callee10, this);}));function loadRegion(_x21, _x22, _x23) {return _loadRegion.apply(this, arguments);}return loadRegion;}() }, { key: \"deleteRegion\", value: function () {var _deleteRegion = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee11(\n\n\n      lineageUrn, versionUrn, viewablePartId, regionId) {var _this2 = this;var alignedItemID, relationships, item, regions;return regeneratorRuntime.wrap(function _callee11$(_context11) {while (1) {switch (_context11.prev = _context11.next) {case 0:\n                alignedItemID = new AlignedItemID(versionUrn, viewablePartId);_context11.next = 3;return (\n\n                  this.getRelationships(Autodesk.AlignmentService.RelationshipEntityTypes.Region, lineageUrn, viewablePartId, regionId));case 3:relationships = _context11.sent;if (\n                relationships.length) {_context11.next = 6;break;}throw (\n                  'No relationship to delete');case 6:_context11.prev = 6;_context11.next = 9;return (\n\n\n\n                  Promise.all(relationships.map(function (r) {return _this2.deleteRelationship(r.id);})));case 9:_context11.next = 15;break;case 11:_context11.prev = 11;_context11.t0 = _context11[\"catch\"](6);\n\n                console.warn('Could not delete relationships');throw _context11.t0;case 15:_context11.next = 17;return (\n\n\n\n\n                  this.cache.getItem(alignedItemID));case 17:item = _context11.sent;\n                regions = item === null || item === void 0 ? void 0 : item.regions;if (\n                regions) {_context11.next = 22;break;}\n                console.warn('No regions to delete');return _context11.abrupt(\"return\");case 22:if (!(\n\n\n\n                regions.length > 1)) {_context11.next = 28;break;}\n                // Update the regions list. This will overwrite the item.\n                item.regions = regions.filter(function (r) {return r.regionId !== regionId;});_context11.next = 26;return (\n                  this.alignmentApi.saveItem(item));case 26:_context11.next = 29;break;case 28:\n\n                // This is the only region in the item\n                this.deleteItem(versionUrn, viewablePartId);case 29:case \"end\":return _context11.stop();}}}, _callee11, this, [[6, 11]]);}));function deleteRegion(_x24, _x25, _x26, _x27) {return _deleteRegion.apply(this, arguments);}return deleteRegion;}() }, { key: \"getRelationships\", value: function () {var _getRelationships = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee12(\n\n\n\n      type, lineageUrn, viewablePartId, regionId) {return regeneratorRuntime.wrap(function _callee12$(_context12) {while (1) {switch (_context12.prev = _context12.next) {case 0:_context12.next = 2;return (\n\n                  this.relationshipApi.getRelationships(type, lineageUrn, viewablePartId, regionId));case 2:return _context12.abrupt(\"return\", _context12.sent);case 3:case \"end\":return _context12.stop();}}}, _callee12, this);}));function getRelationships(_x28, _x29, _x30, _x31) {return _getRelationships.apply(this, arguments);}return getRelationships;}() }, { key: \"saveRelationship\", value: function () {var _saveRelationship = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee13(\n\n\n      modelLineageUrn, modelViewablePartId, sheetLineageUrn, sheetViewablePartId, regionId) {return regeneratorRuntime.wrap(function _callee13$(_context13) {while (1) {switch (_context13.prev = _context13.next) {case 0:_context13.next = 2;return (\n\n                  this.relationshipApi.saveRelationship(modelLineageUrn, modelViewablePartId, sheetLineageUrn, sheetViewablePartId, regionId));case 2:return _context13.abrupt(\"return\", _context13.sent);case 3:case \"end\":return _context13.stop();}}}, _callee13, this);}));function saveRelationship(_x32, _x33, _x34, _x35, _x36) {return _saveRelationship.apply(this, arguments);}return saveRelationship;}()\n\n\n    // Delete item from backend.\n  }, { key: \"deleteRelationship\", value: function () {var _deleteRelationship = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee14(relationshipId) {return regeneratorRuntime.wrap(function _callee14$(_context14) {while (1) {switch (_context14.prev = _context14.next) {case 0:_context14.next = 2;return (\n                  this.relationshipApi.deleteRelationship(relationshipId));case 2:return _context14.abrupt(\"return\", _context14.sent);case 3:case \"end\":return _context14.stop();}}}, _callee14, this);}));function deleteRelationship(_x37) {return _deleteRelationship.apply(this, arguments);}return deleteRelationship;}() }, { key: \"onError\", value: function onError()\n\n\n    {\n      // Report error state\n      this.error = true;\n    } }, { key: \"isWorking\", value: function isWorking()\n\n    {\n      return !this.error;\n    } }, { key: \"clearCache\", value: function clearCache()\n\n    {\n      this.cache.clear();\n    }\n\n    // Delete item from backend.\n  }, { key: \"deleteItem\", value: function () {var _deleteItem = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee15(versionUrn, partId) {var itemId, item;return regeneratorRuntime.wrap(function _callee15$(_context15) {while (1) {switch (_context15.prev = _context15.next) {case 0:\n\n                // If item doesn't exist server-side, do nothing to avoid request error\n                itemId = new AlignedItemID(versionUrn, partId);_context15.next = 3;return (\n                  this.cache.getItem(itemId));case 3:item = _context15.sent;if (\n                item.existsOnServer()) {_context15.next = 6;break;}return _context15.abrupt(\"return\");case 6:if (!\n\n\n\n\n\n                item.isLocked) {_context15.next = 9;break;}_context15.next = 9;return (\n                  this.unlockAlignment(versionUrn, partId));case 9:\n\n\n                // Remove from cache\n                this.cache.setItem(itemId, null);\n\n                // Send delete request\n                _context15.next = 12;return this.alignmentApi.deleteItem(itemId);case 12:return _context15.abrupt(\"return\", _context15.sent);case 13:case \"end\":return _context15.stop();}}}, _callee15, this);}));function deleteItem(_x38, _x39) {return _deleteItem.apply(this, arguments);}return deleteItem;}() }]);return AlignmentServiceNucleus;}(AlignmentService);export { AlignmentServiceNucleus as default };","function _typeof(obj) {\"@babel/helpers - typeof\";if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;};}return _typeof(obj);}function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {try {var info = gen[key](arg);var value = info.value;} catch (error) {reject(error);return;}if (info.done) {resolve(value);} else {Promise.resolve(value).then(_next, _throw);}}function _asyncToGenerator(fn) {return function () {var self = this,args = arguments;return new Promise(function (resolve, reject) {var gen = fn.apply(self, args);function _next(value) {asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);}function _throw(err) {asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);}_next(undefined);});};}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError(\"Cannot call a class as a function\");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}function _get(target, property, receiver) {if (typeof Reflect !== \"undefined\" && Reflect.get) {_get = Reflect.get;} else {_get = function _get(target, property, receiver) {var base = _superPropBase(target, property);if (!base) return;var desc = Object.getOwnPropertyDescriptor(base, property);if (desc.get) {return desc.get.call(receiver);}return desc.value;};}return _get(target, property, receiver || target);}function _superPropBase(object, property) {while (!Object.prototype.hasOwnProperty.call(object, property)) {object = _getPrototypeOf(object);if (object === null) break;}return object;}function _inherits(subClass, superClass) {if (typeof superClass !== \"function\" && superClass !== null) {throw new TypeError(\"Super expression must either be null or a function\");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}function _createSuper(Derived) {var hasNativeReflectConstruct = _isNativeReflectConstruct();return function _createSuperInternal() {var Super = _getPrototypeOf(Derived),result;if (hasNativeReflectConstruct) {var NewTarget = _getPrototypeOf(this).constructor;result = Reflect.construct(Super, arguments, NewTarget);} else {result = Super.apply(this, arguments);}return _possibleConstructorReturn(this, result);};}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");}return self;}function _isNativeReflectConstruct() {if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;if (Reflect.construct.sham) return false;if (typeof Proxy === \"function\") return true;try {Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));return true;} catch (e) {return false;}}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}import AlignmentServiceNucleus from './AlignmentServiceNucleus';\nimport { AlignedItemID } from './NucleusAlignmentAPI';\n\n// Extended variant of AlignmentServiceNucleus needed by Model Coordination:\n//\n// It allows for recovering previous alignment states - decoupled from the latest changes.\n//\n// For this, you specify alignment transforms and checksum for each model. If the checksum of an override\n// matches with the latest saved alignment state, the override is ignored and you can edit the model.\n//\n// If it doesn't (i.e. overriden state is outdated), the model is locked.\n//\n// Note that you must call (and await) the async function clearRedundantOverrides() to detect and unlock all overrides that\n// matches latest state.\nvar AlignmentServiceNucleusOverridable = /*#__PURE__*/function (_AlignmentServiceNucl) {_inherits(AlignmentServiceNucleusOverridable, _AlignmentServiceNucl);var _super = _createSuper(AlignmentServiceNucleusOverridable);\n\n  function AlignmentServiceNucleusOverridable(options) {var _this;_classCallCheck(this, AlignmentServiceNucleusOverridable);\n    _this = _super.call(this, options);\n\n    // OverrideItems, indexed by (encoded) modelUrn, see typedef below.\n    _this.items = {};return _this;\n  }_createClass(AlignmentServiceNucleusOverridable, [{ key: \"getTransform\", value: function getTransform(\n\n    versionUrn, viewablePartId) {\n\n      // If an override tf is defined, return this instead.\n      var overrideTf = this.getOverrideTransform(versionUrn, viewablePartId);\n      if (overrideTf !== undefined) {\n        return overrideTf ? overrideTf.clone() : null;\n      }\n\n      return _get(_getPrototypeOf(AlignmentServiceNucleusOverridable.prototype), \"getTransform\", this).call(this, versionUrn, viewablePartId);\n    } }, { key: \"getIsLocked\", value: function getIsLocked(\n\n    versionUrn, viewablePartId) {\n\n      // If an override transform is used, the model is always locked for editing.\n      var overrideTf = this.getOverrideTransform(versionUrn, viewablePartId);\n      if (overrideTf !== undefined) {\n        return true;\n      }\n\n      return _get(_getPrototypeOf(AlignmentServiceNucleusOverridable.prototype), \"getIsLocked\", this).call(this, versionUrn, viewablePartId);\n    } }, { key: \"isAlignmentLocked\", value: function () {var _isAlignmentLocked = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(\n\n      versionUrn, viewablePartId) {var overrideTf;return regeneratorRuntime.wrap(function _callee$(_context) {while (1) {switch (_context.prev = _context.next) {case 0:\n\n                // If an override transform is used, the model is always locked for editing.\n                overrideTf = this.getOverrideTransform(versionUrn, viewablePartId);if (!(\n                overrideTf !== undefined)) {_context.next = 3;break;}return _context.abrupt(\"return\",\n                true);case 3:_context.next = 5;return _get(_getPrototypeOf(AlignmentServiceNucleusOverridable.prototype), \"isAlignmentLocked\", this).call(this,\n\n\n                versionUrn, viewablePartId);case 5:return _context.abrupt(\"return\", _context.sent);case 6:case \"end\":return _context.stop();}}}, _callee, this);}));function isAlignmentLocked(_x, _x2) {return _isAlignmentLocked.apply(this, arguments);}return isAlignmentLocked;}() }, { key: \"loadTransform\", value: function () {var _loadTransform = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(\n\n\n      versionUrn, viewablePartId) {var overrideTf;return regeneratorRuntime.wrap(function _callee2$(_context2) {while (1) {switch (_context2.prev = _context2.next) {case 0:\n\n                // If an override tf is defined, return this instead.\n                overrideTf = this.getOverrideTransform(versionUrn, viewablePartId);if (!(\n                overrideTf !== undefined)) {_context2.next = 3;break;}return _context2.abrupt(\"return\",\n                overrideTf);case 3:_context2.next = 5;return _get(_getPrototypeOf(AlignmentServiceNucleusOverridable.prototype), \"loadTransform\", this).call(this,\n\n\n                versionUrn, viewablePartId);case 5:return _context2.abrupt(\"return\", _context2.sent);case 6:case \"end\":return _context2.stop();}}}, _callee2, this);}));function loadTransform(_x3, _x4) {return _loadTransform.apply(this, arguments);}return loadTransform;}()\n\n\n    // An OverrideItem defines the override transform for a single model:\n    //\n    // @typedef {\n    //    // must be 64-bit precision. Can be null to enforce original file transform.\n    //    transform: LmvMatrix4,\n    //\n    //    // Used to check whether the override matches with the latest state\n    //    // in alignmentService.\n    //    checksum:  string\n    //\n    //  } OverrideItem\n\n    // Set override transform for a set of models.\n    //\n    // Note:\n    //  - Overrides must be set before model loading, i.e. cannot be changed at runtime after loading.\n    //  - Alignment editing is only allowed if the checksum of the override matches with the latest state in alignment service.\n    //    Otherwise, the alignment editing is locked.\n    //\n    //  @param {Object.<string, OverrideItem>} items- Keys are base-64-encoded version urns. Values are Items.\n  }, { key: \"setOverrideTransforms\", value: function setOverrideTransforms(items) {\n      this.items = items;\n    }\n\n    // Removes all overrides whose timestamp already matches with the latest\n    // state in alignment service. When using overrides, this function must be called\n    // (and waited for) before the editAPI can be used.\n  }, { key: \"clearRedundantOverrides\", value: function () {var _clearRedundantOverrides = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3() {var _this2 = this;var urns, newItems;return regeneratorRuntime.wrap(function _callee3$(_context3) {while (1) {switch (_context3.prev = _context3.next) {case 0:\n\n                // Make sure that we fetch all in a single request, not one by one\n                urns = Object.keys(this.items);_context3.next = 3;return (\n                  this.fetchItems(urns));case 3:\n\n                // newItems is the subset of overrides that we have to keep active, because there is\n                // already a newer transform saved in alignment service.\n                newItems = {};\n\n                urns.forEach(function (urn) {\n\n                  // get latest item from cache\n                  var itemId = new AlignedItemID(urn);\n                  var latestItem = _this2.cache.getCachedItem(itemId);\n\n                  // get corresponding override item\n                  var overrideItem = _this2.items[urn];\n\n                  // Compare checksums\n                  //\n                  // Note that both checksums may be null if no transform was saved at all.\n                  // In this case, the overrideItem will usually not have a checksum either and\n                  // we can consider it as being latest state.\n                  var isLatest = latestItem.checksum == overrideItem.checksum;\n\n                  // Note: https://jira.autodesk.com/browse/BIMCAS-13047\n                  // Temporary workaround to check if latestItem.transform, override checksum & transform is null but the latest checksum is not null.\n                  // If they're the same then this override alignment is the tip alignment, otherwise it is not the latest alignment.\n                  // This resolves an issue in Model Coordination where Model Set service doesn't include checksum when alignment previously existed for a model.\n                  // This can be removed when the Nucleus Model Set service includes the Alignment checksum for null alignment transforms where available.\n                  var isLatestState =\n                  overrideItem.checksum === null &&\n                  overrideItem.transform === null &&\n                  latestItem.transform === null ?\n                  latestItem.versionUrn == urn :\n                  isLatest;\n\n                  // Only keep overrides for items that are not at latest state.\n                  // For all latest ones, we drop the override, so that they can be edited.\n                  if (!isLatestState) {\n                    newItems[urn] = overrideItem;\n                  }\n                });\n\n                this.items = newItems;case 6:case \"end\":return _context3.stop();}}}, _callee3, this);}));function clearRedundantOverrides() {return _clearRedundantOverrides.apply(this, arguments);}return clearRedundantOverrides;}()\n\n\n    // Returns the override transform for the given urn (if specified).\n    // Return value is:\n    //  - undefined:  If no override is set\n    //  - null:       If null is set as override (= use file transform)\n    //  - LmvMatrix4: constant override transform\n    //\n    // @returns {LmvMatrix4|null|undefined}\n  }, { key: \"getOverrideTransform\", value: function getOverrideTransform(versionUrn, viewablePartId) {\n\n      // Overrides are only supported for 3D model alignment\n      if (viewablePartId) {\n        return undefined;\n      }\n\n      // Check if an override is defined for this urn.\n      var item = this.items[versionUrn];\n      if (!item) {\n        // No override => AlignmentService will return the actual transform.\n        return undefined;\n      }\n\n      // In case the returned matrix is modified for computations, this shouldn't accidentally\n      // change internal data. Therefore, return a copy instead of the original.\n      if (item.transform) {\n        return item.transform.clone();\n      }\n\n      // Return null to enforce original file tranform\n      return null;\n    } }]);return AlignmentServiceNucleusOverridable;}(AlignmentServiceNucleus);export { AlignmentServiceNucleusOverridable as default };","function _typeof(obj) {\"@babel/helpers - typeof\";if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;};}return _typeof(obj);}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError(\"Cannot call a class as a function\");}}function _inherits(subClass, superClass) {if (typeof superClass !== \"function\" && superClass !== null) {throw new TypeError(\"Super expression must either be null or a function\");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}function _createSuper(Derived) {var hasNativeReflectConstruct = _isNativeReflectConstruct();return function _createSuperInternal() {var Super = _getPrototypeOf(Derived),result;if (hasNativeReflectConstruct) {var NewTarget = _getPrototypeOf(this).constructor;result = Reflect.construct(Super, arguments, NewTarget);} else {result = Super.apply(this, arguments);}return _possibleConstructorReturn(this, result);};}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");}return self;}function _isNativeReflectConstruct() {if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;if (Reflect.construct.sham) return false;if (typeof Proxy === \"function\") return true;try {Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));return true;} catch (e) {return false;}}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}\nvar av = Autodesk.Viewing;\nvar namespace = AutodeskNamespace('Autodesk.ModelAlignmentService');\nvar myExtensionName = 'Autodesk.ModelAlignmentService';\n\nimport AlignmentService from './AlignmentService';\nimport AlignmentServiceLS from './AlignmentServiceLS';\nimport AlignmentServiceNucleus from './AlignmentServiceNucleus';\nimport AlignmentServiceNucleusOverridable from './AlignmentServiceNucleusOverridable';\nimport { NucleusAlignmentAPI } from './NucleusAlignmentAPI';\n\n/** \n                                                              * This extension defines the API for managing storage of model alignment transform\n                                                              * on a backend or in local storage. It provides a local-storage based implementation for reference. \n                                                              * The extension id is: `Autodesk.ModelAlignmentServiceAPI`\n                                                              */var\nModelAlignmentService = /*#__PURE__*/function (_av$Extension) {_inherits(ModelAlignmentService, _av$Extension);var _super = _createSuper(ModelAlignmentService);\n  function ModelAlignmentService(viewer, options) {_classCallCheck(this, ModelAlignmentService);return _super.call(this,\n    viewer, options);\n  }return ModelAlignmentService;}(av.Extension);\n\n\n// Register the extension with the extension manager.\nexport { ModelAlignmentService as default };av.theExtensionManager.registerExtension(myExtensionName, ModelAlignmentService);\n\nnamespace.AlignmentService = AlignmentService;\nnamespace.AlignmentServiceLS = AlignmentServiceLS;\nnamespace.NucleusAlignmentAPI = NucleusAlignmentAPI;\nnamespace.AlignmentServiceNucleus = AlignmentServiceNucleus;\nnamespace.AlignmentServiceNucleusOverridable = AlignmentServiceNucleusOverridable;","function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {try {var info = gen[key](arg);var value = info.value;} catch (error) {reject(error);return;}if (info.done) {resolve(value);} else {Promise.resolve(value).then(_next, _throw);}}function _asyncToGenerator(fn) {return function () {var self = this,args = arguments;return new Promise(function (resolve, reject) {var gen = fn.apply(self, args);function _next(value) {asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);}function _throw(err) {asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);}_next(undefined);});};}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError(\"Cannot call a class as a function\");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}import AlignedItemNucleus from './AlignedItemNucleus';\nimport { sendRequestWithRetry } from './RequestUtils';\n\nvar av = Autodesk.Viewing;\nvar avp = av.Private;\n\n// We use the DefaultSpaceId for all requests\nvar DefaultSpaceId = 'default';\n\n// For debugging: Display reports of fetched/posted transforms\nvar DEBUG_OUTPUT = false;\n\n// Only for debugging: Find model name for given encoded urn\nvar urnToModelName = function urnToModelName(urn) {\n  // eslint-disable-next-line no-undef\n  var nodes = LMV_MAIN_VIEW.getVisibleNodes();\n  var node = nodes.find(function (node) {return node.getRootNode().urn() == urn;});\n  return (node === null || node === void 0 ? void 0 : node.getModelName()) || \"Unknown urn: \".concat(urn);\n};\n\n// Todo: This should be shared at a more central place.\n//\n// returns an array of arrays each having at most chunkSize elements\n// TypeScript version:\nfunction chunk(array, chunkSize) {\n  var chunks = [];\n  for (var i = 0; i < array.length; i += chunkSize) {\n    chunks.push(array.slice(i, i + chunkSize));\n  }\n  return chunks;\n}\n\n// Combines strings to uniquely address an AlignedItem for 2D or 3D.\nexport var AlignedItemID = /*#__PURE__*/function () {\n\n  // @param {string} urn - base64-encoded versionUrn, e.g. \"dXJuOmFkc2sud2lwc3RnOmZzLmZpbGU6dmYuYi1oeldxakxTS0c2VlZvVTRZNm5KQT92ZXJzaW9uPTE\"\n  // @param {string} viewablePartId - viewable part id - name of the specific viewable, e.g. \"Second Floor\"\n  function AlignedItemID(versionUrn) {var viewablePartId = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;_classCallCheck(this, AlignedItemID);\n\n    // base64-encoded versionUrn, e.g. \"dXJuOmFkc2sud2lwc3RnOmZzLmZpbGU6dmYuYi1oeldxakxTS0c2VlZvVTRZNm5KQT92ZXJzaW9uPTE\"\n    this.versionUrn = versionUrn;\n\n    // Only used for 2D: Id of view and region within the model\n    this.viewablePartId = viewablePartId;\n  }\n\n  // Convert array of urn strings to AlignedItem (if no partIds are needed) \n  //  @param {string[]} \n  _createClass(AlignedItemID, [{ key: \"toObject\",\n\n\n\n    // Convert into object that we can serialize into a json request body\n    value: function toObject() {\n      return {\n        // Note that (unlike most LMV code) alignment service backend works with decoded urns.\n        versionUrn: avp.fromUrlSafeBase64(this.versionUrn),\n\n        // Make sure they are set to undefined unless actually specified\n        viewablePartId: this.viewablePartId || undefined };\n\n    } }, { key: \"toString\", value: function toString()\n\n    {\n      return \"\".concat(this.versionUrn).concat(this.viewablePartId ? \"__\".concat(this.viewablePartId) : '');\n    } }], [{ key: \"fromUrns\", value: function fromUrns(urns) {return urns && urns.map(function (urn) {return new AlignedItemID(urn);});} }]);return AlignedItemID;}();\n\n\n// Choose serviceUrl based on lmv environment (e.g. 'https://developer-stg.api.autodesk.com/construction/alignment' for staging)\nvar getDefaultServiceUrl = function getDefaultServiceUrl(docsEnv) {\n  var envConfig = av.EnvironmentConfigurations[av.getEnv()];\n  var baseUrl = envConfig.UPSTREAM || envConfig.ROOT;\n  var envSuffix = docsEnv === 'QA' ? '-dev' : '';\n  return baseUrl + '/construction/alignment' + envSuffix;\n};\n\nvar getDefaultToken = function getDefaultToken() {\n  return av.token.accessToken;\n};\n\n// Helper class to communicate with Nucleus AlignmentService backend\n//\n// Note:\n//  - All urns must belong to the same projectUrn\n//  - Particularly, projectUrn must not change at runtime.\nexport var NucleusAlignmentAPI = /*#__PURE__*/function () {\n\n  // @param {string}           projectId             - E.g., 'e8c04026-1dc3-473b-bf1e-deedac2576ee'.\n  // @param {async ()=>string} [getAccessToken]      - By default, we get the token from LMV.\n  // @param {string}           [docsEnv]             - Docs environment. E.g. 'QA'.\n  // @param {string}           [serviceBaseUrl]      - Automatically derived from LMV env by default. E.g. 'https://developer-stg.api.autodesk.com/construction/alignment'\n  // @param {string}           [serviceVersion=\"v1\"]\n  // @param {function()}       [onError]\n  function NucleusAlignmentAPI()\n\n\n\n\n\n\n  {var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},projectId = _ref.projectId,_ref$getAccessToken = _ref.getAccessToken,getAccessToken = _ref$getAccessToken === void 0 ? getDefaultToken : _ref$getAccessToken,_ref$docsEnv = _ref.docsEnv,docsEnv = _ref$docsEnv === void 0 ? '' : _ref$docsEnv,_ref$serviceBaseUrl = _ref.serviceBaseUrl,serviceBaseUrl = _ref$serviceBaseUrl === void 0 ? getDefaultServiceUrl(docsEnv) : _ref$serviceBaseUrl,_ref$serviceVersion = _ref.serviceVersion,serviceVersion = _ref$serviceVersion === void 0 ? \"v1\" : _ref$serviceVersion,_ref$onError = _ref.onError,onError = _ref$onError === void 0 ? null : _ref$onError;_classCallCheck(this, NucleusAlignmentAPI);\n\n    this.projectId = projectId;\n    this.getAccessToken = getAccessToken;\n    this.onError = onError;\n\n    this.serviceUrl = \"\".concat(serviceBaseUrl, \"/\").concat(serviceVersion);\n\n    // Endpoint to read/write alignment items\n    this.itemsEndPoint = \"/projects/\".concat(projectId, \"/spaces/\").concat(DefaultSpaceId, \"/items\");\n\n    this.url = this.serviceUrl + this.itemsEndPoint;\n  }\n\n\n  // Batch-request multiple items\n  //\n  // @param {AlignedItemID[]} items\n  // @returns {Object|undefined} A dictionary of AlignedItems, indexed by (encoded) versionUrn. Undefined on failure. \n  _createClass(NucleusAlignmentAPI, [{ key: \"fetchItems\", value: function () {var _fetchItems = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(items) {var _this = this;var result, MaxItems, chunks, promises;return regeneratorRuntime.wrap(function _callee$(_context) {while (1) {switch (_context.prev = _context.next) {case 0:\n\n                result = {};\n\n                // Avoid sending a request if the list is empty anyway.\n                if (items.length) {_context.next = 3;break;}return _context.abrupt(\"return\",\n                result);case 3:\n\n\n                // Batch requests are limited to 20 items per request.\n                // https://stoplight.autodesk.com/bim360/bim360-nucleus-alignment/version%2F1.0/bim360-nucleus-alignment.oas3.yaml?view=%2Falignment-aligned-items%2Fgetaligneditembatch\n                // \n                // => Split if we have more.\n                MaxItems = 20;\n                chunks = chunk(items, MaxItems);\n                promises = chunks.map(function (c) {return _this._doBatchRequest(c, result);});_context.next = 8;return (\n                  Promise.all(promises));case 8:return _context.abrupt(\"return\",\n                result);case 9:case \"end\":return _context.stop();}}}, _callee);}));function fetchItems(_x) {return _fetchItems.apply(this, arguments);}return fetchItems;}()\n\n\n    // Internal function to do a single batch request to query up to 20 items.\n    //\n    // @param {AlignmentItemId[]) itmes  - Single chunk of items. Max 20 items to request!\n    // @param {Object|undeinfed}  result - A dictionary of AlignedItems, indexed by (encoded) versionUrn. All obtained results are added to that dictionary. \n  }, { key: \"_doBatchRequest\", value: function () {var _doBatchRequest2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(items, result) {var body, i, postFix, res, response, loadedItems, _i, alignedItemId, key, data, report, _i2, name, _data;return regeneratorRuntime.wrap(function _callee2$(_context2) {while (1) {switch (_context2.prev = _context2.next) {case 0:\n\n                // List items in request body\n                body = {};\n                for (i = 0; i < items.length; i++) {\n                  body[i] = items[i].toObject();\n                }\n\n                postFix = ':getBatch';_context2.next = 5;return (\n                  sendRequestWithRetry(this.getAccessToken, this.url + postFix, 'POST', body));case 5:res = _context2.sent;if (\n\n\n                res.success) {_context2.next = 9;break;}\n                this.onError();return _context2.abrupt(\"return\");case 9:\n\n\n\n                // get response data (should exist)\n                response = res.data;if (\n                response) {_context2.next = 13;break;}\n                // Even if there are no alignments at all, the return value should be an empty object at the minimum\n                console.warn('Unepxected request response: items:getBatch should get an empty response');return _context2.abrupt(\"return\");case 13:\n\n\n                loadedItems = response.results;\n\n                // get alignment data from each item.\n                // Response is not an array, but the keys for indexing are the same as we used in the body,\n                // so that they will just be indexed by array indices into the items array.\n                for (_i = 0; _i < items.length; _i++) {\n\n                  // get encoded versionUrn \n                  alignedItemId = new AlignedItemID(items[_i].versionUrn, items[_i].viewablePartId);\n                  key = alignedItemId.toString();\n\n                  // Add items to result map, indexed by versionUrn.\n                  // data will be null if no data was saved for this item before.\n                  // In this case, we return a new \"blank\" AlignedItem, i.e. no transform and isLocked = false.\n                  data = loadedItems && loadedItems[_i];\n                  result[key] = data ? new AlignedItemNucleus().load(data) : new AlignedItemNucleus(alignedItemId);\n                }\n\n                // Optional debug output\n                if (DEBUG_OUTPUT) {\n                  report = {};\n                  for (_i2 = 0; _i2 < items.length; _i2++) {\n                    name = urnToModelName(items[_i2].versionUrn);\n                    _data = loadedItems && loadedItems[_i2];\n                    report[name] = _data || 'No alignment';\n                  }\n                  console.log('Fetch successful:', report);\n                }return _context2.abrupt(\"return\",\n\n                result);case 17:case \"end\":return _context2.stop();}}}, _callee2, this);}));function _doBatchRequest(_x2, _x3) {return _doBatchRequest2.apply(this, arguments);}return _doBatchRequest;}()\n\n\n    // Store alignment item or create a new one.\n    //\n    // Note: Saving an item doesn't include the isLocked-flag, because setting the locked flag within an item-save request is not supported by alignmentService.\n    //       Setting the lockFlag requires a separate request to another endpoint.\n  }, { key: \"saveItem\", value: function () {var _saveItem = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(item) {var body, operation, res, name, report;return regeneratorRuntime.wrap(function _callee3$(_context3) {while (1) {switch (_context3.prev = _context3.next) {case 0:\n\n                body = item.toObject();\n\n                // Decide which operation to perform:\n                //  - POST:   Item doesn't exist on alignment service yet => Create a new one.\n                //  - PATCH:  Modify or remove transform of existing item.\n                //\n                // Note: Even when resetting the transform back to source file transform, we must never send DELETE. Deleting an item would not guarantee\n                //       that the transform is always reset to the source file transform: If there is no alignment item for a versionUrn, the alignment transform\n                //       is inherited from the previous versions. So, instead of reseting to source-file transform, deleting the item would just \n                //       \"reset it to the state of the previous version\".\n                //\n                //       Example:\n                //         - Assume model v1 was aligned, then model was updated to v2, and finally v2 was aligned again.\n                //         - If we delete the alignment of v2, v2 would then inherit the alignment from v1.\n                //         - Expected behavior is: v1 keeps its alignment, but v2 is reset to source-file transform. \n                //           => We still have to store an alignment item, just with transform null. \n                //\n                operation = item.existsOnServer() ? 'PATCH' : 'POST';_context3.next = 4;return (\n                  sendRequestWithRetry(this.getAccessToken, this.url, operation, body));case 4:res = _context3.sent;if (\n\n                res.success) {_context3.next = 8;break;}\n                this.onError();return _context3.abrupt(\"return\",\n                false);case 8:\n\n\n                // On success, update item with response from AlignmentService. Transform should usually\n                // keep the same, but checksum and timestamp will change.\n                if (res.data) {\n                  item.load(res.data);\n                } else {\n                  // item has been deleted from server. So, we must reset its checksum so that we don't try\n                  // to send PATCH requests on next change.\n                  item.checksum = undefined;\n\n                  // If operation is delete, the response will be empty. In this case, we can keep the cache\n                  // item as it is, because it already indicates that no transform is set.\n                  operation == 'DELETE' || console.warn('Unexpected request result: POST or PATCH should always respond an update item state');\n                }\n\n                // Optional debug output\n                if (DEBUG_OUTPUT) {\n                  name = urnToModelName(item.versionUrn);\n                  report = {\n                    model: name,\n                    response: res.data,\n                    operation: operation };\n\n\n                  console.log('Transform saved: ', report);\n                }return _context3.abrupt(\"return\",\n\n                true);case 11:case \"end\":return _context3.stop();}}}, _callee3, this);}));function saveItem(_x4) {return _saveItem.apply(this, arguments);}return saveItem;}()\n\n\n    // Note: Removing the alignment item will change the alignment to whatever state was defined by previous versions.\n    //       Therefore, actual delete is currently only used for debugging purposes. Resetting alignment is done by\n    //       changing the transform to null, but keeping the item live (see saveItem comments for details).\n    //\n    // @param {AlignedItemID} item\n  }, { key: \"deleteItem\", value: function () {var _deleteItem = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(item) {var body;return regeneratorRuntime.wrap(function _callee4$(_context4) {while (1) {switch (_context4.prev = _context4.next) {case 0:\n                body = item.toObject();_context4.next = 3;return (\n                  sendRequestWithRetry(this.getAccessToken, this.url, 'DELETE', body));case 3:case \"end\":return _context4.stop();}}}, _callee4, this);}));function deleteItem(_x5) {return _deleteItem.apply(this, arguments);}return deleteItem;}()\n\n\n    // Send request to lock or unlock an item.\n    //\n    // Requirements:\n    //  - Item must exist server-side and reflect latest state\n    //  - It must be ensured that the same item isn't locked/unlocked twice.\n    //  - Unlock only works with admin priviledges\n    //\n    // @param {AlignedItemNucleus} item\n    // @param {bool}               lock - whether to lock or unlock\n  }, { key: \"setItemLocked\", value: function () {var _setItemLocked = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(item, lock) {var data, body, postFix, res;return regeneratorRuntime.wrap(function _callee5$(_context5) {while (1) {switch (_context5.prev = _context5.next) {case 0:\n\n                data = item.toObject();\n                body = {\n                  versionUrn: data.versionUrn,\n                  viewablePartId: data.viewablePartId };\n\n\n                postFix = lock ? ':lock' : ':unlock';_context5.next = 5;return (\n                  sendRequestWithRetry(this.getAccessToken, this.url + postFix, 'PATCH', body));case 5:res = _context5.sent;if (\n                res.success) {_context5.next = 9;break;}\n                this.onError();return _context5.abrupt(\"return\");case 9:\n\n\n\n                // update item from server response. This should set the lock flag and update the checksum. \n                item.load(res.data);case 10:case \"end\":return _context5.stop();}}}, _callee5, this);}));function setItemLocked(_x6, _x7) {return _setItemLocked.apply(this, arguments);}return setItemLocked;}() }]);return NucleusAlignmentAPI;}();","function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {try {var info = gen[key](arg);var value = info.value;} catch (error) {reject(error);return;}if (info.done) {resolve(value);} else {Promise.resolve(value).then(_next, _throw);}}function _asyncToGenerator(fn) {return function () {var self = this,args = arguments;return new Promise(function (resolve, reject) {var gen = fn.apply(self, args);function _next(value) {asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);}function _throw(err) {asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);}_next(undefined);});};}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError(\"Cannot call a class as a function\");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}import { sendRequestWithRetry } from './RequestUtils';\n\nvar av = Autodesk.Viewing;\nvar avp = av.Private;\n\n// Choose serviceUrl based on lmv environment (e.g. 'https://developer-stg.api.autodesk.com/bim360/relationship-dev' for QA)\nvar getDefaultServiceUrl = function getDefaultServiceUrl(docsEnv) {\n  var envConfig = av.EnvironmentConfigurations[av.getEnv()];\n  var baseUrl = envConfig.UPSTREAM || envConfig.ROOT;\n  var envSuffix = docsEnv === 'QA' ? '-dev' : '';\n  return baseUrl + '/bim360/relationship' + envSuffix;\n};\n\nvar getDefaultToken = function getDefaultToken() {\n  return av.token.accessToken;\n};\n\n// Relationship entity ID is defined by lineageUrn + viewablePart + region.\nvar getRelationshipEntityId = function getRelationshipEntityId(lineageUrn, viewablePart, region) {\n  // https://wiki.autodesk.com/pages/viewpage.action?spaceKey=ACSB4C&title=Relationship+Service+Alignment+Authorizer\n  return \"\".concat(lineageUrn, \"?\").concat(Autodesk.AlignmentService.RelationshipIdPrefix.Name).concat(encodeURIComponent(viewablePart)).concat(region ? \"\".concat(Autodesk.AlignmentService.RelationshipIdPrefix.Region).concat(region) : '');\n};\n\nvar Domain = 'autodesk-construction-alignment';\n\n// Helper class to communicate with Nucleus Relationship Service backend\n//\n// Note:\n//  - All urns must belong to the same projectUrn\n//  - Particularly, projectUrn must not change at runtime.\nexport var NucleusRelationshipAPI = /*#__PURE__*/function () {\n\n  // @param {string}           projectId             - E.g., 'e8c04026-1dc3-473b-bf1e-deedac2576ee'.\n  // @param {async ()=>string} [getAccessToken]      - By default, we get the token from LMV.\n  // @param {string}           [docsEnv]             - Docs environment. E.g. 'QA'.\n  // @param {string}           [serviceBaseUrl]      - Automatically derived from LMV env by default. E.g. 'https://developer-stg.api.autodesk.com/bim360/relationship'\n  // @param {string}           [serviceVersion=\"v2\"]\n  // @param {function()}       [onError]\n  function NucleusRelationshipAPI()\n\n\n\n\n\n\n  {var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},projectId = _ref.projectId,_ref$getAccessToken = _ref.getAccessToken,getAccessToken = _ref$getAccessToken === void 0 ? getDefaultToken : _ref$getAccessToken,_ref$docsEnv = _ref.docsEnv,docsEnv = _ref$docsEnv === void 0 ? '' : _ref$docsEnv,_ref$serviceBaseUrl = _ref.serviceBaseUrl,serviceBaseUrl = _ref$serviceBaseUrl === void 0 ? getDefaultServiceUrl(docsEnv) : _ref$serviceBaseUrl,_ref$serviceVersion = _ref.serviceVersion,serviceVersion = _ref$serviceVersion === void 0 ? \"v2\" : _ref$serviceVersion,_ref$onError = _ref.onError,onError = _ref$onError === void 0 ? null : _ref$onError;_classCallCheck(this, NucleusRelationshipAPI);\n\n    this.projectId = projectId;\n    this.getAccessToken = getAccessToken;\n    this.onError = onError;\n\n    this.serviceUrl = \"\".concat(serviceBaseUrl, \"/\").concat(serviceVersion);\n\n    // Endpoint to read/write alignment items\n    this.itemsEndPoint = \"/containers/\".concat(projectId, \"/relationships\");\n\n    this.url = this.serviceUrl + this.itemsEndPoint;\n  }_createClass(NucleusRelationshipAPI, [{ key: \"getRelationships\", value: function () {var _getRelationships = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(\n\n      type, lineageUrn, viewablePartId, regionId) {var _res$data;var id, idEncoded, postFix, res, relationships;return regeneratorRuntime.wrap(function _callee$(_context) {while (1) {switch (_context.prev = _context.next) {case 0:\n\n                id = getRelationshipEntityId(lineageUrn, viewablePartId, regionId);\n                idEncoded = encodeURIComponent(id); // When using the search API, id must be URI encoded.\n\n                postFix = \":search?domain=\".concat(Domain, \"&type=\").concat(type, \"&id=\").concat(idEncoded);_context.next = 5;return (\n                  sendRequestWithRetry(this.getAccessToken, this.url + postFix, 'GET'));case 5:res = _context.sent;if (\n\n\n                res.success) {_context.next = 9;break;}\n                this.onError();return _context.abrupt(\"return\",\n                []);case 9:\n\n\n                // get response data (should exist)\n                relationships = (_res$data = res.data) === null || _res$data === void 0 ? void 0 : _res$data.relationships;if (\n\n                relationships) {_context.next = 13;break;}\n                // Even if there are no alignments at all, the return value should be an empty object at the minimum\n                console.warn('Unepxected request response: relationships:search should get an empty array');return _context.abrupt(\"return\",\n                []);case 13:\n\n\n                // Decode ID for each entity. Viewer should not care that the service requires that it should be encoded.\n                relationships.forEach(function (relationship) {\n                  relationship.entities.forEach(function (entity) {\n                    entity.id = decodeURIComponent(entity.id);\n                  });\n                });return _context.abrupt(\"return\",\n\n                relationships);case 15:case \"end\":return _context.stop();}}}, _callee, this);}));function getRelationships(_x, _x2, _x3, _x4) {return _getRelationships.apply(this, arguments);}return getRelationships;}() }, { key: \"saveRelationship\", value: function () {var _saveRelationship = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(\n\n\n      modelLineageUrn, modelViewablePartId, sheetLineageUrn, sheetViewablePartId, regionId) {var sheetEntityId, modelEntityId, item, body, res;return regeneratorRuntime.wrap(function _callee2$(_context2) {while (1) {switch (_context2.prev = _context2.next) {case 0:\n                sheetEntityId = getRelationshipEntityId(sheetLineageUrn, sheetViewablePartId, regionId);\n                modelEntityId = getRelationshipEntityId(modelLineageUrn, modelViewablePartId);\n\n                // this is how this structure that it is stored in real Relationship service.\n                item = {\n                  entities: [\n                  {\n                    domain: Domain,\n                    type: Autodesk.AlignmentService.RelationshipEntityTypes.Region,\n                    id: sheetEntityId },\n\n                  {\n                    domain: Domain,\n                    type: Autodesk.AlignmentService.RelationshipEntityTypes.Model3D,\n                    id: modelEntityId }] };\n\n\n\n\n                body = [item];_context2.next = 6;return (\n\n                  sendRequestWithRetry(this.getAccessToken, this.url, 'PUT', body));case 6:res = _context2.sent;if (\n\n                res.success) {_context2.next = 10;break;}\n                this.onError();return _context2.abrupt(\"return\",\n                false);case 10:return _context2.abrupt(\"return\",\n\n\n                true);case 11:case \"end\":return _context2.stop();}}}, _callee2, this);}));function saveRelationship(_x5, _x6, _x7, _x8, _x9) {return _saveRelationship.apply(this, arguments);}return saveRelationship;}() }, { key: \"deleteRelationship\", value: function () {var _deleteRelationship = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(\n\n\n      relationshipId) {var body, postFix, res;return regeneratorRuntime.wrap(function _callee3$(_context3) {while (1) {switch (_context3.prev = _context3.next) {case 0:\n                body = [relationshipId];\n\n                postFix = ':delete';_context3.next = 4;return (\n                  sendRequestWithRetry(this.getAccessToken, this.url + postFix, 'POST', body));case 4:res = _context3.sent;if (\n\n\n                res.success) {_context3.next = 8;break;}\n                this.onError();return _context3.abrupt(\"return\");case 8:case \"end\":return _context3.stop();}}}, _callee3, this);}));function deleteRelationship(_x10) {return _deleteRelationship.apply(this, arguments);}return deleteRelationship;}() }]);return NucleusRelationshipAPI;}();","function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {try {var info = gen[key](arg);var value = info.value;} catch (error) {reject(error);return;}if (info.done) {resolve(value);} else {Promise.resolve(value).then(_next, _throw);}}function _asyncToGenerator(fn) {return function () {var self = this,args = arguments;return new Promise(function (resolve, reject) {var gen = fn.apply(self, args);function _next(value) {asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);}function _throw(err) {asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);}_next(undefined);});};}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError(\"Cannot call a class as a function\");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;} // Helper class for retrying requests\nexport var Retry = /*#__PURE__*/function () {\n\n  function Retry() {_classCallCheck(this, Retry);\n\n    // Maximum number of attempts before giving up\n    this.maxAttempts = 10;\n\n    // Waiting time in ms for first retry\n    this.startDelay = 100;\n\n    // Exponential grow factor for the waiting time per attempt\n    this.growFactor = 1.1;\n  }\n\n  // Returns the waiting time in ms before retrying.    \n  _createClass(Retry, [{ key: \"getWaitingTime\", value: function getWaitingTime(numFailedAttempts) {\n      return numFailedAttempts ? this.startDelay * Math.pow(this.growFactor, numFailedAttempts - 1) : 0;\n    }\n\n    // Try the given (async) callback until either successful or until maximum retry count is reached.\n    //  - Return value is the last result of callback\n    //  - Callback is considered successful if isSuccess(result) is true.\n  }, { key: \"run\", value: function run(callback, isSuccess) {var _this = this;\n\n      return new Promise(function (resolve) {\n\n        // track number of attempts\n        var numFailedAttempts = 0;\n\n        var nextTry = /*#__PURE__*/function () {var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {var result, delayInMs;return regeneratorRuntime.wrap(function _callee$(_context) {while (1) {switch (_context.prev = _context.next) {case 0:_context.next = 2;return (\n\n\n                      callback());case 2:result = _context.sent;if (!\n\n\n                    isSuccess(result)) {_context.next = 5;break;}return _context.abrupt(\"return\",\n                    resolve(result));case 5:\n\n\n                    // Give up if we reached the limit\n                    numFailedAttempts++;if (!(\n                    numFailedAttempts >= _this.maxAttempts)) {_context.next = 8;break;}return _context.abrupt(\"return\",\n                    resolve(result));case 8:\n\n\n                    // schedule next attempt\n                    delayInMs = _this.getWaitingTime(numFailedAttempts);\n                    window.setTimeout(nextTry, delayInMs);case 10:case \"end\":return _context.stop();}}}, _callee);}));return function nextTry() {return _ref.apply(this, arguments);};}();\n\n        nextTry();\n      });\n    } }]);return Retry;}();\n\n\n// Result is an object { success, response }.\nexport var sendRequest = /*#__PURE__*/function () {var _ref2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(getAccessToken, url, operation) {var body,result,token,_args2 = arguments;return regeneratorRuntime.wrap(function _callee2$(_context2) {while (1) {switch (_context2.prev = _context2.next) {case 0:body = _args2.length > 3 && _args2[3] !== undefined ? _args2[3] : null;\n\n            result = {\n              success: false,\n              data: null };_context2.next = 4;return (\n\n\n              getAccessToken());case 4:token = _context2.sent;_context2.next = 7;return (\n\n              new Promise(function (resolve) {\n\n                var xhr = new XMLHttpRequest();\n                xhr.open(operation, url, true);\n                xhr.setRequestHeader('Content-Type', 'application/json');\n                xhr.setRequestHeader('accept', 'application/json');\n                xhr.setRequestHeader('Access-Control-Allow-Origin', '*');\n                xhr.setRequestHeader('Authorization', 'Bearer ' + token);\n\n                // On failure: resolve with result.success == false\n                var onFailure = function onFailure() {\n                  resolve(result);\n                };\n\n                // Parse response as json on success\n                var onLoad = function onLoad() {\n\n                  // Even if the request didn't trigger an error callback,\n                  // the server response may still indicate an error (e.g. this happens on authorization failure) \n                  if (xhr.status < 200 || xhr.status >= 300) {\n                    onFailure();\n                    return;\n                  }\n\n                  try {\n                    // If json parsing succeeds, return success\n                    // Some requests (e.g. DELETE) may also get an empty string as result on success, but JSON.parse() would\n                    // fail on those. Therefore, we accept empty responses as well and just set data to null for this case. \n                    result.data = xhr.response ? JSON.parse(xhr.response) : null;\n                    result.success = true;\n                    resolve(result);\n                  } catch (e) {\n                    // json parsing failed.\n                    onFailure();\n                  }\n                };\n\n                xhr.onload = onLoad;\n                xhr.onerror = onFailure;\n                xhr.ontimeout = onFailure;\n                xhr.onabort = onFailure;\n\n                xhr.send(body && JSON.stringify(body));\n              }));case 7:return _context2.abrupt(\"return\", _context2.sent);case 8:case \"end\":return _context2.stop();}}}, _callee2);}));return function sendRequest(_x, _x2, _x3) {return _ref2.apply(this, arguments);};}();\n\n\nexport var sendRequestWithRetry = /*#__PURE__*/function () {var _ref3 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(getAccessToken, url, operation, body) {var doRequest, isSuccess;return regeneratorRuntime.wrap(function _callee3$(_context3) {while (1) {switch (_context3.prev = _context3.next) {case 0:\n            doRequest = function doRequest() {return sendRequest(getAccessToken, url, operation, body);};\n            isSuccess = function isSuccess(res) {return res.success;};_context3.next = 4;return (\n              new Retry().run(doRequest, isSuccess));case 4:return _context3.abrupt(\"return\", _context3.sent);case 5:case \"end\":return _context3.stop();}}}, _callee3);}));return function sendRequestWithRetry(_x4, _x5, _x6, _x7) {return _ref3.apply(this, arguments);};}();","var v1 = require('./v1');\nvar v4 = require('./v4');\n\nvar uuid = v4;\nuuid.v1 = v1;\nuuid.v4 = v4;\n\nmodule.exports = uuid;\n","/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\nvar byteToHex = [];\nfor (var i = 0; i < 256; ++i) {\n  byteToHex[i] = (i + 0x100).toString(16).substr(1);\n}\n\nfunction bytesToUuid(buf, offset) {\n  var i = offset || 0;\n  var bth = byteToHex;\n  // join used to fix memory issue caused by concatenation: https://bugs.chromium.org/p/v8/issues/detail?id=3175#c4\n  return ([\n    bth[buf[i++]], bth[buf[i++]],\n    bth[buf[i++]], bth[buf[i++]], '-',\n    bth[buf[i++]], bth[buf[i++]], '-',\n    bth[buf[i++]], bth[buf[i++]], '-',\n    bth[buf[i++]], bth[buf[i++]], '-',\n    bth[buf[i++]], bth[buf[i++]],\n    bth[buf[i++]], bth[buf[i++]],\n    bth[buf[i++]], bth[buf[i++]]\n  ]).join('');\n}\n\nmodule.exports = bytesToUuid;\n","// Unique ID creation requires a high quality random # generator.  In the\n// browser this is a little complicated due to unknown quality of Math.random()\n// and inconsistent support for the `crypto` API.  We do the best we can via\n// feature-detection\n\n// getRandomValues needs to be invoked in a context where \"this\" is a Crypto\n// implementation. Also, find the complete implementation of crypto on IE11.\nvar getRandomValues = (typeof(crypto) != 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto)) ||\n                      (typeof(msCrypto) != 'undefined' && typeof window.msCrypto.getRandomValues == 'function' && msCrypto.getRandomValues.bind(msCrypto));\n\nif (getRandomValues) {\n  // WHATWG crypto RNG - http://wiki.whatwg.org/wiki/Crypto\n  var rnds8 = new Uint8Array(16); // eslint-disable-line no-undef\n\n  module.exports = function whatwgRNG() {\n    getRandomValues(rnds8);\n    return rnds8;\n  };\n} else {\n  // Math.random()-based (RNG)\n  //\n  // If all else fails, use Math.random().  It's fast, but is of unspecified\n  // quality.\n  var rnds = new Array(16);\n\n  module.exports = function mathRNG() {\n    for (var i = 0, r; i < 16; i++) {\n      if ((i & 0x03) === 0) r = Math.random() * 0x100000000;\n      rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;\n    }\n\n    return rnds;\n  };\n}\n","var rng = require('./lib/rng');\nvar bytesToUuid = require('./lib/bytesToUuid');\n\n// **`v1()` - Generate time-based UUID**\n//\n// Inspired by https://github.com/LiosK/UUID.js\n// and http://docs.python.org/library/uuid.html\n\nvar _nodeId;\nvar _clockseq;\n\n// Previous uuid creation time\nvar _lastMSecs = 0;\nvar _lastNSecs = 0;\n\n// See https://github.com/uuidjs/uuid for API details\nfunction v1(options, buf, offset) {\n  var i = buf && offset || 0;\n  var b = buf || [];\n\n  options = options || {};\n  var node = options.node || _nodeId;\n  var clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq;\n\n  // node and clockseq need to be initialized to random values if they're not\n  // specified.  We do this lazily to minimize issues related to insufficient\n  // system entropy.  See #189\n  if (node == null || clockseq == null) {\n    var seedBytes = rng();\n    if (node == null) {\n      // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)\n      node = _nodeId = [\n        seedBytes[0] | 0x01,\n        seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]\n      ];\n    }\n    if (clockseq == null) {\n      // Per 4.2.2, randomize (14 bit) clockseq\n      clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 0x3fff;\n    }\n  }\n\n  // UUID timestamps are 100 nano-second units since the Gregorian epoch,\n  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so\n  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'\n  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.\n  var msecs = options.msecs !== undefined ? options.msecs : new Date().getTime();\n\n  // Per 4.2.1.2, use count of uuid's generated during the current clock\n  // cycle to simulate higher resolution clock\n  var nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1;\n\n  // Time since last uuid creation (in msecs)\n  var dt = (msecs - _lastMSecs) + (nsecs - _lastNSecs)/10000;\n\n  // Per 4.2.1.2, Bump clockseq on clock regression\n  if (dt < 0 && options.clockseq === undefined) {\n    clockseq = clockseq + 1 & 0x3fff;\n  }\n\n  // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new\n  // time interval\n  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {\n    nsecs = 0;\n  }\n\n  // Per 4.2.1.2 Throw error if too many uuids are requested\n  if (nsecs >= 10000) {\n    throw new Error('uuid.v1(): Can\\'t create more than 10M uuids/sec');\n  }\n\n  _lastMSecs = msecs;\n  _lastNSecs = nsecs;\n  _clockseq = clockseq;\n\n  // Per 4.1.4 - Convert from unix epoch to Gregorian epoch\n  msecs += 12219292800000;\n\n  // `time_low`\n  var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;\n  b[i++] = tl >>> 24 & 0xff;\n  b[i++] = tl >>> 16 & 0xff;\n  b[i++] = tl >>> 8 & 0xff;\n  b[i++] = tl & 0xff;\n\n  // `time_mid`\n  var tmh = (msecs / 0x100000000 * 10000) & 0xfffffff;\n  b[i++] = tmh >>> 8 & 0xff;\n  b[i++] = tmh & 0xff;\n\n  // `time_high_and_version`\n  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version\n  b[i++] = tmh >>> 16 & 0xff;\n\n  // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)\n  b[i++] = clockseq >>> 8 | 0x80;\n\n  // `clock_seq_low`\n  b[i++] = clockseq & 0xff;\n\n  // `node`\n  for (var n = 0; n < 6; ++n) {\n    b[i + n] = node[n];\n  }\n\n  return buf ? buf : bytesToUuid(b);\n}\n\nmodule.exports = v1;\n","var rng = require('./lib/rng');\nvar bytesToUuid = require('./lib/bytesToUuid');\n\nfunction v4(options, buf, offset) {\n  var i = buf && offset || 0;\n\n  if (typeof(options) == 'string') {\n    buf = options === 'binary' ? new Array(16) : null;\n    options = null;\n  }\n  options = options || {};\n\n  var rnds = options.random || (options.rng || rng)();\n\n  // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n  rnds[6] = (rnds[6] & 0x0f) | 0x40;\n  rnds[8] = (rnds[8] & 0x3f) | 0x80;\n\n  // Copy bytes to buffer, if provided\n  if (buf) {\n    for (var ii = 0; ii < 16; ++ii) {\n      buf[i + ii] = rnds[ii];\n    }\n  }\n\n  return buf || bytesToUuid(rnds);\n}\n\nmodule.exports = v4;\n"],"mappings":";;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AClFA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACpIA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACjHA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACrKA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACxWA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACzSA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC3KA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC7BA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACtSA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACpIA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AClHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACjCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC5GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;A","sourceRoot":""}