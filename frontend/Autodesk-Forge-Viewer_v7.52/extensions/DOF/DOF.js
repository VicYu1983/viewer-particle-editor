/*!
 * LMV v7.52.0
 * 
 * Copyright 2021 Autodesk, Inc.
 * All rights reserved.
 * 
 * This computer source code and related instructions and comments are the
 * unpublished confidential and proprietary information of Autodesk, Inc.
 * and are protected under Federal copyright and state trade secret law.
 * They may not be disclosed to, copied or used by any third party without
 * the prior written consent of Autodesk, Inc.
 * 
 * Autodesk Forge Viewer Usage Limitations:
 * 
 * The Autodesk Forge viewer can only be used to view files generated by
 * Autodesk Forge services. The Autodesk Forge Viewer JavaScript must be
 * delivered from an Autodesk hosted URL.
 */
Autodesk.Extensions.DOF =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./extensions/DOF/DOFExtension.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./extensions/DOF/DOFExtension.js":
/*!****************************************!*\
  !*** ./extensions/DOF/DOFExtension.js ***!
  \****************************************/
/*! exports provided: DOFExtension */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DOFExtension", function() { return DOFExtension; });
/* harmony import */ var _DOFRenderContext__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./DOFRenderContext */ "./extensions/DOF/DOFRenderContext.js");
/* harmony import */ var _DOFRenderOptionsPanel__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./DOFRenderOptionsPanel */ "./extensions/DOF/DOFRenderOptionsPanel.js");
/* harmony import */ var _DOFTool__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./DOFTool */ "./extensions/DOF/DOFTool.js");
/* harmony import */ var _DOFLocales__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./DOFLocales */ "./extensions/DOF/DOFLocales.js");





var Extension = Autodesk.Viewing.Extension;

function DOFExtension(viewer, options) {
  Extension.call(this, viewer, options);

  this.openPanel = this.openPanel.bind(this);
}

DOFExtension.prototype = Object.create(Autodesk.Viewing.Extension.prototype);
DOFExtension.prototype.constructor = DOFExtension;

/**
                                                    * Load the Depth of Field extension.
                                                    * It will fail to load when running a headless viewer.
                                                    */
DOFExtension.prototype.load = function () {
  this.extendLocalization(_DOFLocales__WEBPACK_IMPORTED_MODULE_3__["locales"]);

  this.dofRenderContext = new _DOFRenderContext__WEBPACK_IMPORTED_MODULE_0__["DOFRenderContext"](this.viewer.impl.renderer(), this.viewer);
  this.dofRenderContext.load();
  this.viewer.impl.renderer().postShadingManager().registerPostProcessingExtension(this.dofRenderContext);

  this.tool = new _DOFTool__WEBPACK_IMPORTED_MODULE_2__["default"](this.viewer, this);
  this.viewer.toolController.registerTool(this.tool);

  this.firstTime = true;

  // Create UI by default. Panel could be found in the viewer settings panel.
  if (this.options.createUI !== false) {
    this.panel = new _DOFRenderOptionsPanel__WEBPACK_IMPORTED_MODULE_1__["DOFRenderOptionsPanel"](this.viewer, this);
  }

  return true;
};

/**
    * Unload the Depth of Field extension.
    */
DOFExtension.prototype.unload = function () {
  if (this.dofRenderContext) {
    this.viewer.impl.renderer().postShadingManager().removePostProcessingExtension(this.dofRenderContext);
    this.viewer.impl.invalidate(true, true, true);
    this.dofRenderContext = null;
  }

  if (this.panel) {
    if (this._configButtonId !== null) {
      this.viewer.viewerSettingsPanel.removeConfigButton(this._configButtonId);
      this._configButtonId = null;
    }

    this.panel.setVisible(false);
    this.panel.destroy();
    this.panel = null;
  }

  return true;
};

DOFExtension.prototype.getInitialFocalPlane = function (params) {
  var customDistance = parseFloat(Autodesk.Viewing.Private.getParameterByName('focalPlane')) || this.options.focalPlane;

  if (customDistance) {
    return customDistance;
  }

  // Cast a ray from camera to the object in the center of the screen, and use it as a default value.
  var camera = this.viewer.getCamera();
  var eyeVec = camera.target.clone().sub(camera.position).normalize();
  var hit = this.viewer.impl.rayIntersect(new THREE.Ray(camera.position, eyeVec));

  if (hit) {
    var toMeters = this.viewer.impl.renderer().getUnitScale();
    return hit.distance * toMeters;
  }

  return 2; // Fallback - 2 meters from camera.
};

DOFExtension.prototype.loadDefaultValues = function () {
  var defaultFocalLength = parseFloat(Autodesk.Viewing.Private.getParameterByName("focalLength")) || this.options.focalLength || this.getFocalLength();
  var defaultFstop = parseFloat(Autodesk.Viewing.Private.getParameterByName('fStop')) || this.options.fStop || 8;
  var defaultMaxBlur = parseFloat(Autodesk.Viewing.Private.getParameterByName('maxBlur')) || this.options.maxBlur || 2.0;
  var defaultBlurQuality = parseFloat(Autodesk.Viewing.Private.getParameterByName('blurQuality')) || this.options.blurQuality || 8.0;
  var defaultFocalPlane = this.getInitialFocalPlane();
  var defaultUseCursor = Autodesk.Viewing.Private.getParameterByName("blurUseCursor") === 'true' || this.options.blurUseCursor || false;
  var defaultDebug = Autodesk.Viewing.Private.getParameterByName("blurDebug") === 'true' || this.options.blurDebug || false;

  this.setFocalLength(defaultFocalLength);
  this.setFStop(defaultFstop);
  this.setMaxBlur(defaultMaxBlur);
  this.setBlurQuality(defaultBlurQuality);
  this.setFocalPlane(defaultFocalPlane);
  this.setUseCursor(defaultUseCursor);
  this.setDebug(defaultDebug);
};

DOFExtension.prototype.onToolbarCreated = function () {
  if (this.panel) {
    this._initButtonConfig();
  }
};

/**
    * Adds a button to the Settings Panel.
    * @private
    */
DOFExtension.prototype._initButtonConfig = function () {
  var settingsPanel = this.viewer.getSettingsPanel();
  if (!settingsPanel) {
    this.addEventListener(Autodesk.Viewing.SETTINGSpanel_CREATED_EVENT, this._initButtonConfig, { once: true });
    return;
  }
  this._configButtonId = settingsPanel.addConfigButton("Depth of Field", this.openPanel);
};

DOFExtension.prototype.openPanel = function () {var _this$panel;
  this.setEnabled(true);
  (_this$panel = this.panel) === null || _this$panel === void 0 ? void 0 : _this$panel.setVisible(true);
};

DOFExtension.prototype.activate = function () {var _this$panel2;
  // Already active
  if (this.isActive()) {
    return;
  }

  if (this.firstTime) {
    this.firstTime = false;

    // Although it does work with orthographic, DOF works much better with perspective camera.
    this.viewer.navigation.toPerspective();

    this.loadDefaultValues();
  }

  this.dofRenderContext.enable();

  if (this.useCursor && !this.viewer.toolController.isToolActivated(this.tool.getName())) {
    this.viewer.toolController.activateTool(this.tool.getName());
  }

  (_this$panel2 = this.panel) === null || _this$panel2 === void 0 ? void 0 : _this$panel2.enabledToggle.setValue(true);

  this.activeStatus = true;
};

DOFExtension.prototype.deactivate = function () {var _this$panel3;
  // Already inactive.
  if (!this.isActive()) {
    return;
  }

  this.dofRenderContext.disable();

  if (this.useCursor && this.viewer.toolController.isToolActivated(this.tool.getName())) {
    this.viewer.toolController.deactivateTool(this.tool.getName());
  }

  (_this$panel3 = this.panel) === null || _this$panel3 === void 0 ? void 0 : _this$panel3.enabledToggle.setValue(false);

  this.activeStatus = false;
};

DOFExtension.prototype.setEnabled = function (enable) {
  if (enable) {
    this.activate();
  } else {
    this.deactivate();
  }
};

DOFExtension.prototype.getUseCursor = function () {
  return this.useCursor;
};

DOFExtension.prototype.setUseCursor = function (enable) {var _this$panel4;
  this.useCursor = enable;

  if (enable) {
    this.viewer.toolController.activateTool(this.tool.getName());
  } else {
    this.viewer.toolController.deactivateTool(this.tool.getName());
  }

  (_this$panel4 = this.panel) === null || _this$panel4 === void 0 ? void 0 : _this$panel4.setUseCursor(enable);
};

DOFExtension.prototype.getDebug = function () {
  return this.dofRenderContext.getDefineValue("DEBUG");
};

DOFExtension.prototype.setDebug = function (enable) {var _this$panel5;
  this.dofRenderContext.updateDefineValue("DEBUG", enable ? true : null);
  (_this$panel5 = this.panel) === null || _this$panel5 === void 0 ? void 0 : _this$panel5.debug.setValue(enable);
};

DOFExtension.prototype.getFStop = function () {
  return this.dofRenderContext.getUniformValue("fStop");
};

DOFExtension.prototype.setFStop = function (value) {var _this$panel6;
  this.dofRenderContext.updateUniformValue("fStop", value);
  (_this$panel6 = this.panel) === null || _this$panel6 === void 0 ? void 0 : _this$panel6.fStop.setValue(value);
};

// Value in meters
DOFExtension.prototype.getFocalPlane = function () {
  return this.dofRenderContext.getUniformValue("focalPlane");
};

// Value in meters
DOFExtension.prototype.setFocalPlane = function (value) {var _this$panel7;
  this.dofRenderContext.updateUniformValue("focalPlane", value);
  (_this$panel7 = this.panel) === null || _this$panel7 === void 0 ? void 0 : _this$panel7.setFocalPlane(value);
};

DOFExtension.prototype.getMaxBlur = function () {
  return this.dofRenderContext.getUniformValue("maxBlur");
};

DOFExtension.prototype.setMaxBlur = function (value) {var _this$panel8;
  this.dofRenderContext.updateUniformValue("maxBlur", value);
  (_this$panel8 = this.panel) === null || _this$panel8 === void 0 ? void 0 : _this$panel8.maxBlur.setValue(value);
};

DOFExtension.prototype.getFocalLength = function () {
  return Autodesk.Viewing.Navigation.prototype.fov2fl(this.viewer.getCamera().fov);
};

DOFExtension.prototype.setFocalLength = function (value) {
  // No need to explicitly update the DOF panel. It has an event listener on the camera.
  this.viewer.setFocalLength(value);
};

DOFExtension.prototype.getBlurQuality = function () {
  return this.dofRenderContext.getDefineValue("BLUR_QUALITY");
};

DOFExtension.prototype.setBlurQuality = function (value) {var _this$panel9;
  this.dofRenderContext.updateDefineValue("BLUR_QUALITY", value);
  (_this$panel9 = this.panel) === null || _this$panel9 === void 0 ? void 0 : _this$panel9.blurQuality.setValue(value);
};

/**
    * Register the extension with the extension manager.
    */
Autodesk.Viewing.theExtensionManager.registerExtension('Autodesk.DOF', DOFExtension);

/***/ }),

/***/ "./extensions/DOF/DOFLocales.js":
/*!**************************************!*\
  !*** ./extensions/DOF/DOFLocales.js ***!
  \**************************************/
/*! exports provided: locales */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "locales", function() { return locales; });
/* harmony import */ var _res_locales_en_nobundle_dof_loc_json__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../res/locales/en/nobundle-dof.loc.json */ "./res/locales/en/nobundle-dof.loc.json");
var _res_locales_en_nobundle_dof_loc_json__WEBPACK_IMPORTED_MODULE_0___namespace = /*#__PURE__*/__webpack_require__.t(/*! ../../res/locales/en/nobundle-dof.loc.json */ "./res/locales/en/nobundle-dof.loc.json", 1);
/**
 * Include each locale json file and return it in an object
 * that can be consumed by i18n
 */



var locales = {
  en: _res_locales_en_nobundle_dof_loc_json__WEBPACK_IMPORTED_MODULE_0__ };

/***/ }),

/***/ "./extensions/DOF/DOFRenderContext.js":
/*!********************************************!*\
  !*** ./extensions/DOF/DOFRenderContext.js ***!
  \********************************************/
/*! exports provided: DOFRenderContext */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DOFRenderContext", function() { return DOFRenderContext; });
/* harmony import */ var _DOFShader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./DOFShader */ "./extensions/DOF/DOFShader.js");


var ShaderPass = Autodesk.Viewing.Private.ShaderPass;
var RenderContextPostProcessExtension = Autodesk.Viewing.Private.RenderContextPostProcessExtension;

var av = Autodesk.Viewing;

var DOFRenderContext = function DOFRenderContext(renderContext, viewer) {
  RenderContextPostProcessExtension.call(this, renderContext, viewer);

  // Make sure to render DOF before other post processing passes.
  this.getOrder = function () {
    return 0;
  };

  // This flag is needed in order to render the DOF pass only after the selection overlay has been rendered - it looks a lot better.
  this.shouldRenderAfterOverlays = function () {
    return true;
  };

  this.load = function () {
    this.postProcPass = new ShaderPass(_DOFShader__WEBPACK_IMPORTED_MODULE_0__["DOFShader"]);
    this.renderContext.setNoDepthNoBlend(this.postProcPass);
  };
};

DOFRenderContext.prototype = Object.create(RenderContextPostProcessExtension.prototype);
DOFRenderContext.prototype.constructor = DOFRenderContext;
av.GlobalManagerMixin.call(DOFRenderContext.prototype);



/***/ }),

/***/ "./extensions/DOF/DOFRenderOptionsPanel.js":
/*!*************************************************!*\
  !*** ./extensions/DOF/DOFRenderOptionsPanel.js ***!
  \*************************************************/
/*! exports provided: DOFRenderOptionsPanel */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DOFRenderOptionsPanel", function() { return DOFRenderOptionsPanel; });



var TAB_ID = 'configTab';
var TAB_LABEL = 'Configuration';

var DOFRenderOptionsPanel = function DOFRenderOptionsPanel(viewer, dofExtension) {var _this = this;
  var PANEL_ID = 'adsk_dof_renderoptions_panel_' + viewer.id;
  var opts = { heightAdjustment: 90, width: 500 };
  Autodesk.Viewing.UI.SettingsPanel.call(this, viewer.container, PANEL_ID, 'Depth of Field', opts);
  this.setGlobalManager(viewer.globalManager);
  this.container.classList.add('viewer-settings-panel');
  this.viewer = viewer;

  // Add a default tab called Render Options
  this.addTab(TAB_ID, TAB_LABEL, { className: 'config' });
  this.selectTab(TAB_ID);

  // Checkbox "Enabled"
  var enabledToggleId = this.addCheckbox(TAB_ID, 'Enabled', false, function (checked) {
    dofExtension.setEnabled(checked);
  });

  this.enabledToggle = this.getControl(enabledToggleId);

  // Slider Focal Length
  var focalLengthId = this.addSlider(TAB_ID, 'Focal Length (mm)',
  10.0, 200.0, 10,
  function (event) {
    var value = event.detail.value;
    dofExtension.setFocalLength(parseFloat(value));
  },
  { step: 1 });

  this.focalLength = this.getControl(focalLengthId);

  this.viewer.addEventListener(Autodesk.Viewing.CAMERA_CHANGE_EVENT, function () {
    var myFocalLength = parseFloat(_this.focalLength.value);
    var camFocalLength = viewer.getFocalLength();

    if (myFocalLength != camFocalLength) _this.focalLength.setValue(camFocalLength);
  });

  // Slider "f-stop"
  var fStopId = this.addSlider(TAB_ID, 'f-stop (Aperture)',
  2.0, 22.0, 1.4,
  function (event) {
    var value = event.detail.value;
    dofExtension.setFStop(parseFloat(value));
  },
  { step: 0.1 });

  this.fStop = this.getControl(fStopId);

  // Slider "Max Blur"
  var maxBlurId = this.addSlider(TAB_ID, 'Max Blur',
  1, 3, 2,
  function (event) {
    var value = event.detail.value;
    dofExtension.setMaxBlur(parseFloat(value));
  },
  { step: 0.1 });

  this.maxBlur = this.getControl(maxBlurId);

  // Slider "Blur Quality"
  var blurSizeId = this.addSlider(TAB_ID, 'Blur Quality',
  1, 16, 8,
  function (event) {
    var value = event.detail.value;
    dofExtension.setBlurQuality(value);
  },
  { step: 1 });

  this.blurQuality = this.getControl(blurSizeId);

  // Checkbox "Use Cursor"
  var useCursor = this.addCheckbox(TAB_ID, 'Focus on Cursor', false, function (checked) {
    dofExtension.setUseCursor(checked);
    _this.setUseCursor(checked);
  });

  this.useCursor = this.getControl(useCursor);

  this.setUseCursor = function (checked) {
    _this.focalPlane.setDisabled(checked);

    if (!checked) {
      var focalPlane = parseFloat(_this.focalPlane.value);
      dofExtension.setFocalPlane(focalPlane * _this.unitsToMeters);
    }
  };

  // Slider "Focal Plane"
  var focalPlaneId = this.addSlider(TAB_ID, 'Focal Plane',
  0.01, 50.0, 1,
  function (event) {
    var value = event.detail.value;
    dofExtension.setFocalPlane(parseFloat(value) * _this.unitsToMeters);
  },
  { step: 0.1 });


  this.focalPlane = this.getControl(focalPlaneId);

  // Finding the "correct" range for the focal plane is hard.
  // If we use a constant value, we might end up with a really long range for tiny models, or really short range for large models.
  // In order to find the right range - we need to consider:
  // - Display units - if we are viewing the model in `mm`, it's a good asumption that the focal plane won't be 1000 meters from the camera.
  // - Visible bounds - the hard coded "maxInMeters" values are the upper bound of the range. If we find out that we a have a model that is relativaly small, but our
  // display units in meters - we can make the range tighter according to the bounding box of the model.
  // Bear in mind that this is just a heuristic. Another possible solution for this is to take the camera distance from the model into account.
  var updateFocalPlaneRange = function updateFocalPlaneRange() {var _this$viewer$getExten;
    var units = ((_this$viewer$getExten = _this.viewer.getExtension("Autodesk.Measure")) === null || _this$viewer$getExten === void 0 ? void 0 : _this$viewer$getExten.getUnits()) || 'm';
    var unitsString = Autodesk.Viewing.i18n.translate(Autodesk.Viewing.Private.displayUnits[Autodesk.Viewing.Private.displayUnitsEnum.indexOf(units)]);
    _this.focalPlane.caption.textContent = "".concat(Autodesk.Viewing.i18n.translate("Focal Plane"), " (").concat(unitsString, ")");

    var minInMeters;
    var maxInMeters;
    var step;

    switch (units) {
      case 'mm':
      case 'pt':
        minInMeters = 0.001;
        maxInMeters = 10;
        step = 1;
        break;
      case 'cm':
      case 'in':
      case 'fractional-in':
      case 'decimal-in':
        minInMeters = 0.01;
        maxInMeters = 50;
        step = 0.1;
        break;
      case 'm':
      case 'm-and-cm':
      case 'ft-and-decimal-in':
      case 'ft':
      case 'ft-and-fractional-in':
      case 'decimal-ft':
      default:
        minInMeters = 0.05;
        maxInMeters = 100;
        step = 0.01;
        break;}


    var bounds = _this.viewer.impl.getVisibleBounds(true);
    var toMeters = _this.viewer.impl.renderer().getUnitScale();
    var size = bounds.size();

    // Set the max range to be 5 times of the visible bounds size.
    var maxModelBounds = 5 * Math.max(size.x, size.y, size.z) * toMeters;
    maxInMeters = Math.min(maxModelBounds, maxInMeters);

    _this.unitsToMeters = Autodesk.Viewing.Private.convertUnits(units, 'm', 1, 1);

    var min = parseFloat((minInMeters / _this.unitsToMeters).toFixed(3));
    var max = parseFloat((maxInMeters / _this.unitsToMeters).toFixed(3));


    _this.focalPlane.sliderElement.min = min;
    _this.focalPlane.stepperElement.min = min;
    _this.focalPlane.sliderElement.max = max;
    _this.focalPlane.stepperElement.max = max;
    _this.focalPlane.sliderElement.step = step;

    // Update values according to the new units.
    dofExtension.setFocalPlane(dofExtension.getFocalPlane());
  };

  updateFocalPlaneRange();

  this.setFocalPlane = function (value) {
    _this.focalPlane.setValue(parseFloat((value / _this.unitsToMeters).toFixed(3)));
  };

  // Checkbox "Debug"
  var debug = this.addCheckbox(TAB_ID, 'Debug DOF', false, function (checked) {
    dofExtension.setDebug(checked);
  });
  this.debug = this.getControl(debug);

  this.viewer.addEventListener(Autodesk.Viewing.MODEL_ROOT_LOADED_EVENT, updateFocalPlaneRange);
  this.viewer.addEventListener(Autodesk.Viewing.MeasureCommon.Events.DISPLAY_UNITS_CHANGED, updateFocalPlaneRange);

  this.destroy = function () {
    _this.viewer.removeEventListener(Autodesk.Viewing.MODEL_ROOT_LOADED_EVENT, updateFocalPlaneRange);
    _this.viewer.removeEventListener(Autodesk.Viewing.MeasureCommon.Events.DISPLAY_UNITS_CHANGED, updateFocalPlaneRange);
  };
};

DOFRenderOptionsPanel.prototype = Object.create(Autodesk.Viewing.UI.SettingsPanel.prototype);
DOFRenderOptionsPanel.prototype.constructor = DOFRenderOptionsPanel;



/***/ }),

/***/ "./extensions/DOF/DOFShader.js":
/*!*************************************!*\
  !*** ./extensions/DOF/DOFShader.js ***!
  \*************************************/
/*! exports provided: DOFShader */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DOFShader", function() { return DOFShader; });
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ "three");
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(three__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _src_wgs_render_ShaderChunks__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../src/wgs/render/ShaderChunks */ "./src/wgs/render/ShaderChunks.js");
/* harmony import */ var _src_wgs_render_shaders_screen_quad_uv_vert_glsl__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../src/wgs/render/shaders/screen_quad_uv_vert.glsl */ "./src/wgs/render/shaders/screen_quad_uv_vert.glsl");
/* harmony import */ var _src_wgs_render_shaders_screen_quad_uv_vert_glsl__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_src_wgs_render_shaders_screen_quad_uv_vert_glsl__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _Shader_dof_frag_glsl__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Shader/dof_frag.glsl */ "./extensions/DOF/Shader/dof_frag.glsl");
/* harmony import */ var _Shader_dof_frag_glsl__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_Shader_dof_frag_glsl__WEBPACK_IMPORTED_MODULE_3__);





var DOFShader = {
  uniforms: three__WEBPACK_IMPORTED_MODULE_0__["UniformsUtils"].merge([
  _src_wgs_render_ShaderChunks__WEBPACK_IMPORTED_MODULE_1__["ShaderChunks"].DepthTextureUniforms,

  {
    tDiffuse: { type: "t", value: null },
    resolution: { type: "v2", value: new three__WEBPACK_IMPORTED_MODULE_0__["Vector2"](1 / 1024, 1 / 512) },
    cameraNear: { type: "f", value: 1 },
    cameraFar: { type: "f", value: 100 },
    fStop: { type: "f", value: 22.0 },
    focalLength: { type: "f", value: 100.0 }, // in mm.
    focalPlane: { type: "f", value: 5.0 }, // in meters.
    unitScale: { type: "f", value: 1.0 }, // conversion from model units to meters.
    maxBlur: { type: "f", value: 2.0 }, // max blur multiplier.
    cameraPos: { type: "v3", value: new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"]() } }]),



  vertexShader: _src_wgs_render_shaders_screen_quad_uv_vert_glsl__WEBPACK_IMPORTED_MODULE_2___default.a,
  fragmentShader: _Shader_dof_frag_glsl__WEBPACK_IMPORTED_MODULE_3___default.a };

/***/ }),

/***/ "./extensions/DOF/DOFTool.js":
/*!***********************************!*\
  !*** ./extensions/DOF/DOFTool.js ***!
  \***********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return DOFTool; });
function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}var throttle = __webpack_require__(/*! lodash/throttle */ "./node_modules/lodash/throttle.js");

var GlobalManagerMixin = Autodesk.Viewing.GlobalManagerMixin;

var AnimDuration = 0.25; // s
var ThrottleDuration = 100; // ms

/**
 * Provides functionality for changing focal plane according to the cursor position.
 **/var
DOFTool = /*#__PURE__*/function () {
  function DOFTool(viewer, dofExtension) {var _this = this;_classCallCheck(this, DOFTool);
    this.viewer = viewer;
    this.dofExtension = dofExtension;

    // Is tool active.
    this.active = false;

    // Tool name.
    this.names = ["dof-tool"];

    this.lastMousePos = new THREE.Vector2();

    this.onCameraChange = this.onCameraChange.bind(this);

    this.updateFocalPlaneThrottled = throttle(function (targetFocalPlane) {
      if (_this.anim) {
        _this.anim.stop();
        _this.anim = null;
      }

      var startValue = _this.dofExtension.getFocalPlane();

      _this.anim = Autodesk.Viewing.Private.fadeValue(startValue, targetFocalPlane, AnimDuration, function (value) {
        _this.dofExtension.setFocalPlane(value);
      }, function () {
        _this.anim = null;
      });
    }, ThrottleDuration);
  }_createClass(DOFTool, [{ key: "getNames", value: function getNames()

    {
      return this.names;
    } }, { key: "getName", value: function getName()

    {
      return this.names[0];
    } }, { key: "getPriority", value: function getPriority()

    {
      return 1000;
    } }, { key: "isActive", value: function isActive()

    {
      return this.active;
    } }, { key: "activate", value: function activate()

    {
      if (this.isActive()) {
        return;
      }

      this.viewer.addEventListener(Autodesk.Viewing.CAMERA_CHANGE_EVENT, this.onCameraChange);

      this.active = true;
    } }, { key: "deactivate", value: function deactivate()

    {
      if (!this.isActive()) {
        return;
      }

      this.viewer.removeEventListener(Autodesk.Viewing.CAMERA_CHANGE_EVENT, this.onCameraChange);

      if (this.anim) {
        this.anim.stop();
        this.anim = null;
      }

      this.active = false;
    }

    // In case that the camera moved and the mouse didn't (bimwalk / wheel) - update.
  }, { key: "onCameraChange", value: function onCameraChange() {
      return this.handleMouseMove({ canvasX: this.lastMousePos.x, canvasY: this.lastMousePos.y });
    } }, { key: "handleMouseMove", value: function handleMouseMove(

    event) {
      this.lastMousePos.set(event.canvasX, event.canvasY);

      var result = this.viewer.impl.snappingHitTest(event.canvasX, event.canvasY);
      var cameraPos = this.viewer.getCamera().position;

      var target = result === null || result === void 0 ? void 0 : result.intersectPoint;

      if (!target) {
        return false;
      }

      var targetFocalPlane = cameraPos.distanceTo(target) * this.viewer.impl.renderer().getUnitScale();

      this.updateFocalPlaneThrottled(targetFocalPlane);

      // don't consume event
      return false;
    } }]);return DOFTool;}();


GlobalManagerMixin.call(DOFTool.prototype);

/***/ }),

/***/ "./extensions/DOF/Shader/dof_frag.glsl":
/*!*********************************************!*\
  !*** ./extensions/DOF/Shader/dof_frag.glsl ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "\nuniform sampler2D tDiffuse;\nvarying vec2 vUv;\nuniform vec2 resolution;\nuniform float fStop;\nuniform float focalLength;\nuniform vec3 cameraPos;\nuniform float unitScale;\nuniform float focalPlane;\nuniform float maxBlur;\n#include<depth_texture>\n#define TAU 6.28318530718\n#define DIRECTIONS 16.\nfloat COC = 0.03;\nvec4 debugFocus(float blur){    \n    vec4 color = texture2D(tDiffuse,vUv);\n    color = mix(color, vec4(0.,0.,0.,1.), min(0.95, blur));\n    return color;\n}\nfloat calculateBlur() {\n    float subjectDistance = focalPlane*1000.;\n    vec3 worldPos = reconstructWorldPosition(gl_FragCoord.xy, vUv);\n    float unitScaleMM = unitScale * 1000.;\n    worldPos *= unitScaleMM;\n    vec3 cameraPosMM = vec3(cameraPos) * unitScaleMM;\n    float pixelDistance = distance(worldPos, cameraPosMM);\n    float hyperfocalDistance = (focalLength * focalLength) / (fStop * COC);\n    float DOFNear = (hyperfocalDistance * subjectDistance) / (hyperfocalDistance + (subjectDistance - focalLength));\n    float DOFFar = (hyperfocalDistance * subjectDistance) / (hyperfocalDistance - (subjectDistance - focalLength));\n    float dist = subjectDistance - pixelDistance;\n    float blur;\n    if (dist > 0.) {\n        if (DOFNear < 0.) {\n            blur = 0.;\n        } else {\n            blur = dist / (subjectDistance - DOFNear);    \n        }\n    } else {\n        if (DOFFar < 0.) {\n            blur = 0.;\n        } else {\n            blur = -dist / (DOFFar - subjectDistance);\n        }\n    }\n    float logScale = log(blur+1.) / log(2.);\n    blur = clamp(0., maxBlur, logScale);\n    return blur;\n}\nvec4 gaussianBlur(float blurAmount) {\n    vec4 color=texture2D(tDiffuse,vUv);\n    float quality = float(BLUR_QUALITY);\n    float radius = 8. * blurAmount;\n    for(float d = 0.; d < DIRECTIONS; d++)\n    {\n        float angle= d * TAU / DIRECTIONS;\n        vec2 angleVec = vec2(cos(angle),sin(angle));\n        for(int i = 1; i <= BLUR_QUALITY; i++)\n        {\n            float distance = radius * (float(i) / quality);\n            color += texture2D(tDiffuse, vUv.xy + angleVec * resolution * distance );\n        }\n    }\n    \n    color /= quality * DIRECTIONS;\n    return color;\n}\nvoid main() {\n    float blur = calculateBlur();\n    #ifdef DEBUG\n    vec4 color = debugFocus(blur);\n    #else\n    vec4 color = gaussianBlur(blur);\n    #endif\n    gl_FragColor = color;\n}\n";

/***/ }),

/***/ "./node_modules/lodash/_Symbol.js":
/*!****************************************!*\
  !*** ./node_modules/lodash/_Symbol.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var root = __webpack_require__(/*! ./_root */ "./node_modules/lodash/_root.js");

/** Built-in value references. */
var Symbol = root.Symbol;

module.exports = Symbol;


/***/ }),

/***/ "./node_modules/lodash/_baseGetTag.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_baseGetTag.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var Symbol = __webpack_require__(/*! ./_Symbol */ "./node_modules/lodash/_Symbol.js"),
    getRawTag = __webpack_require__(/*! ./_getRawTag */ "./node_modules/lodash/_getRawTag.js"),
    objectToString = __webpack_require__(/*! ./_objectToString */ "./node_modules/lodash/_objectToString.js");

/** `Object#toString` result references. */
var nullTag = '[object Null]',
    undefinedTag = '[object Undefined]';

/** Built-in value references. */
var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function baseGetTag(value) {
  if (value == null) {
    return value === undefined ? undefinedTag : nullTag;
  }
  return (symToStringTag && symToStringTag in Object(value))
    ? getRawTag(value)
    : objectToString(value);
}

module.exports = baseGetTag;


/***/ }),

/***/ "./node_modules/lodash/_baseTrim.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_baseTrim.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var trimmedEndIndex = __webpack_require__(/*! ./_trimmedEndIndex */ "./node_modules/lodash/_trimmedEndIndex.js");

/** Used to match leading whitespace. */
var reTrimStart = /^\s+/;

/**
 * The base implementation of `_.trim`.
 *
 * @private
 * @param {string} string The string to trim.
 * @returns {string} Returns the trimmed string.
 */
function baseTrim(string) {
  return string
    ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, '')
    : string;
}

module.exports = baseTrim;


/***/ }),

/***/ "./node_modules/lodash/_freeGlobal.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_freeGlobal.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

module.exports = freeGlobal;

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/lodash/_getRawTag.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_getRawTag.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var Symbol = __webpack_require__(/*! ./_Symbol */ "./node_modules/lodash/_Symbol.js");

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/** Built-in value references. */
var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */
function getRawTag(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag),
      tag = value[symToStringTag];

  try {
    value[symToStringTag] = undefined;
    var unmasked = true;
  } catch (e) {}

  var result = nativeObjectToString.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }
  return result;
}

module.exports = getRawTag;


/***/ }),

/***/ "./node_modules/lodash/_objectToString.js":
/*!************************************************!*\
  !*** ./node_modules/lodash/_objectToString.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */
function objectToString(value) {
  return nativeObjectToString.call(value);
}

module.exports = objectToString;


/***/ }),

/***/ "./node_modules/lodash/_root.js":
/*!**************************************!*\
  !*** ./node_modules/lodash/_root.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var freeGlobal = __webpack_require__(/*! ./_freeGlobal */ "./node_modules/lodash/_freeGlobal.js");

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

module.exports = root;


/***/ }),

/***/ "./node_modules/lodash/_trimmedEndIndex.js":
/*!*************************************************!*\
  !*** ./node_modules/lodash/_trimmedEndIndex.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/** Used to match a single whitespace character. */
var reWhitespace = /\s/;

/**
 * Used by `_.trim` and `_.trimEnd` to get the index of the last non-whitespace
 * character of `string`.
 *
 * @private
 * @param {string} string The string to inspect.
 * @returns {number} Returns the index of the last non-whitespace character.
 */
function trimmedEndIndex(string) {
  var index = string.length;

  while (index-- && reWhitespace.test(string.charAt(index))) {}
  return index;
}

module.exports = trimmedEndIndex;


/***/ }),

/***/ "./node_modules/lodash/debounce.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/debounce.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(/*! ./isObject */ "./node_modules/lodash/isObject.js"),
    now = __webpack_require__(/*! ./now */ "./node_modules/lodash/now.js"),
    toNumber = __webpack_require__(/*! ./toNumber */ "./node_modules/lodash/toNumber.js");

/** Error message constants. */
var FUNC_ERROR_TEXT = 'Expected a function';

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max,
    nativeMin = Math.min;

/**
 * Creates a debounced function that delays invoking `func` until after `wait`
 * milliseconds have elapsed since the last time the debounced function was
 * invoked. The debounced function comes with a `cancel` method to cancel
 * delayed `func` invocations and a `flush` method to immediately invoke them.
 * Provide `options` to indicate whether `func` should be invoked on the
 * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
 * with the last arguments provided to the debounced function. Subsequent
 * calls to the debounced function return the result of the last `func`
 * invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the debounced function
 * is invoked more than once during the `wait` timeout.
 *
 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.debounce` and `_.throttle`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to debounce.
 * @param {number} [wait=0] The number of milliseconds to delay.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=false]
 *  Specify invoking on the leading edge of the timeout.
 * @param {number} [options.maxWait]
 *  The maximum time `func` is allowed to be delayed before it's invoked.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new debounced function.
 * @example
 *
 * // Avoid costly calculations while the window size is in flux.
 * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
 *
 * // Invoke `sendMail` when clicked, debouncing subsequent calls.
 * jQuery(element).on('click', _.debounce(sendMail, 300, {
 *   'leading': true,
 *   'trailing': false
 * }));
 *
 * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
 * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
 * var source = new EventSource('/stream');
 * jQuery(source).on('message', debounced);
 *
 * // Cancel the trailing debounced invocation.
 * jQuery(window).on('popstate', debounced.cancel);
 */
function debounce(func, wait, options) {
  var lastArgs,
      lastThis,
      maxWait,
      result,
      timerId,
      lastCallTime,
      lastInvokeTime = 0,
      leading = false,
      maxing = false,
      trailing = true;

  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  wait = toNumber(wait) || 0;
  if (isObject(options)) {
    leading = !!options.leading;
    maxing = 'maxWait' in options;
    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
    trailing = 'trailing' in options ? !!options.trailing : trailing;
  }

  function invokeFunc(time) {
    var args = lastArgs,
        thisArg = lastThis;

    lastArgs = lastThis = undefined;
    lastInvokeTime = time;
    result = func.apply(thisArg, args);
    return result;
  }

  function leadingEdge(time) {
    // Reset any `maxWait` timer.
    lastInvokeTime = time;
    // Start the timer for the trailing edge.
    timerId = setTimeout(timerExpired, wait);
    // Invoke the leading edge.
    return leading ? invokeFunc(time) : result;
  }

  function remainingWait(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime,
        timeWaiting = wait - timeSinceLastCall;

    return maxing
      ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke)
      : timeWaiting;
  }

  function shouldInvoke(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime;

    // Either this is the first call, activity has stopped and we're at the
    // trailing edge, the system time has gone backwards and we're treating
    // it as the trailing edge, or we've hit the `maxWait` limit.
    return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||
      (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));
  }

  function timerExpired() {
    var time = now();
    if (shouldInvoke(time)) {
      return trailingEdge(time);
    }
    // Restart the timer.
    timerId = setTimeout(timerExpired, remainingWait(time));
  }

  function trailingEdge(time) {
    timerId = undefined;

    // Only invoke if we have `lastArgs` which means `func` has been
    // debounced at least once.
    if (trailing && lastArgs) {
      return invokeFunc(time);
    }
    lastArgs = lastThis = undefined;
    return result;
  }

  function cancel() {
    if (timerId !== undefined) {
      clearTimeout(timerId);
    }
    lastInvokeTime = 0;
    lastArgs = lastCallTime = lastThis = timerId = undefined;
  }

  function flush() {
    return timerId === undefined ? result : trailingEdge(now());
  }

  function debounced() {
    var time = now(),
        isInvoking = shouldInvoke(time);

    lastArgs = arguments;
    lastThis = this;
    lastCallTime = time;

    if (isInvoking) {
      if (timerId === undefined) {
        return leadingEdge(lastCallTime);
      }
      if (maxing) {
        // Handle invocations in a tight loop.
        clearTimeout(timerId);
        timerId = setTimeout(timerExpired, wait);
        return invokeFunc(lastCallTime);
      }
    }
    if (timerId === undefined) {
      timerId = setTimeout(timerExpired, wait);
    }
    return result;
  }
  debounced.cancel = cancel;
  debounced.flush = flush;
  return debounced;
}

module.exports = debounce;


/***/ }),

/***/ "./node_modules/lodash/isObject.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/isObject.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return value != null && (type == 'object' || type == 'function');
}

module.exports = isObject;


/***/ }),

/***/ "./node_modules/lodash/isObjectLike.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/isObjectLike.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return value != null && typeof value == 'object';
}

module.exports = isObjectLike;


/***/ }),

/***/ "./node_modules/lodash/isSymbol.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/isSymbol.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var baseGetTag = __webpack_require__(/*! ./_baseGetTag */ "./node_modules/lodash/_baseGetTag.js"),
    isObjectLike = __webpack_require__(/*! ./isObjectLike */ "./node_modules/lodash/isObjectLike.js");

/** `Object#toString` result references. */
var symbolTag = '[object Symbol]';

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (isObjectLike(value) && baseGetTag(value) == symbolTag);
}

module.exports = isSymbol;


/***/ }),

/***/ "./node_modules/lodash/now.js":
/*!************************************!*\
  !*** ./node_modules/lodash/now.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var root = __webpack_require__(/*! ./_root */ "./node_modules/lodash/_root.js");

/**
 * Gets the timestamp of the number of milliseconds that have elapsed since
 * the Unix epoch (1 January 1970 00:00:00 UTC).
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Date
 * @returns {number} Returns the timestamp.
 * @example
 *
 * _.defer(function(stamp) {
 *   console.log(_.now() - stamp);
 * }, _.now());
 * // => Logs the number of milliseconds it took for the deferred invocation.
 */
var now = function() {
  return root.Date.now();
};

module.exports = now;


/***/ }),

/***/ "./node_modules/lodash/throttle.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/throttle.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var debounce = __webpack_require__(/*! ./debounce */ "./node_modules/lodash/debounce.js"),
    isObject = __webpack_require__(/*! ./isObject */ "./node_modules/lodash/isObject.js");

/** Error message constants. */
var FUNC_ERROR_TEXT = 'Expected a function';

/**
 * Creates a throttled function that only invokes `func` at most once per
 * every `wait` milliseconds. The throttled function comes with a `cancel`
 * method to cancel delayed `func` invocations and a `flush` method to
 * immediately invoke them. Provide `options` to indicate whether `func`
 * should be invoked on the leading and/or trailing edge of the `wait`
 * timeout. The `func` is invoked with the last arguments provided to the
 * throttled function. Subsequent calls to the throttled function return the
 * result of the last `func` invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the throttled function
 * is invoked more than once during the `wait` timeout.
 *
 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.throttle` and `_.debounce`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to throttle.
 * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=true]
 *  Specify invoking on the leading edge of the timeout.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new throttled function.
 * @example
 *
 * // Avoid excessively updating the position while scrolling.
 * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
 *
 * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.
 * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });
 * jQuery(element).on('click', throttled);
 *
 * // Cancel the trailing throttled invocation.
 * jQuery(window).on('popstate', throttled.cancel);
 */
function throttle(func, wait, options) {
  var leading = true,
      trailing = true;

  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  if (isObject(options)) {
    leading = 'leading' in options ? !!options.leading : leading;
    trailing = 'trailing' in options ? !!options.trailing : trailing;
  }
  return debounce(func, wait, {
    'leading': leading,
    'maxWait': wait,
    'trailing': trailing
  });
}

module.exports = throttle;


/***/ }),

/***/ "./node_modules/lodash/toNumber.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/toNumber.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var baseTrim = __webpack_require__(/*! ./_baseTrim */ "./node_modules/lodash/_baseTrim.js"),
    isObject = __webpack_require__(/*! ./isObject */ "./node_modules/lodash/isObject.js"),
    isSymbol = __webpack_require__(/*! ./isSymbol */ "./node_modules/lodash/isSymbol.js");

/** Used as references for various `Number` constants. */
var NAN = 0 / 0;

/** Used to detect bad signed hexadecimal string values. */
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

/** Used to detect binary string values. */
var reIsBinary = /^0b[01]+$/i;

/** Used to detect octal string values. */
var reIsOctal = /^0o[0-7]+$/i;

/** Built-in method references without a dependency on `root`. */
var freeParseInt = parseInt;

/**
 * Converts `value` to a number.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {number} Returns the number.
 * @example
 *
 * _.toNumber(3.2);
 * // => 3.2
 *
 * _.toNumber(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toNumber(Infinity);
 * // => Infinity
 *
 * _.toNumber('3.2');
 * // => 3.2
 */
function toNumber(value) {
  if (typeof value == 'number') {
    return value;
  }
  if (isSymbol(value)) {
    return NAN;
  }
  if (isObject(value)) {
    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
    value = isObject(other) ? (other + '') : other;
  }
  if (typeof value != 'string') {
    return value === 0 ? value : +value;
  }
  value = baseTrim(value);
  var isBinary = reIsBinary.test(value);
  return (isBinary || reIsOctal.test(value))
    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
    : (reIsBadHex.test(value) ? NAN : +value);
}

module.exports = toNumber;


/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || new Function("return this")();
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),

/***/ "./res/locales/en/nobundle-dof.loc.json":
/*!**********************************************!*\
  !*** ./res/locales/en/nobundle-dof.loc.json ***!
  \**********************************************/
/*! exports provided: @@locale, @@context, Depth of Field, Configuration, Enabled, Focal Length (mm), f-stop (Aperture), Max Blur, Blur Quality, Focus on Cursor, Focal Plane, Debug DOF, default */
/***/ (function(module) {

module.exports = JSON.parse("{\"@@locale\":\"en\",\"@@context\":\"Depth of Field extension\",\"Depth of Field\":\"Depth of Field\",\"Configuration\":\"Configuration\",\"Enabled\":\"Enabled\",\"Focal Length (mm)\":\"Focal Length (mm)\",\"f-stop (Aperture)\":\"f-stop (Aperture)\",\"Max Blur\":\"Max Blur\",\"Blur Quality\":\"Blur Quality\",\"Focus on Cursor\":\"Focus on Cursor\",\"Focal Plane\":\"Focal Plane\",\"Debug DOF\":\"Debug DOF\"}");

/***/ }),

/***/ "./src/wgs/render/ShaderChunks.js":
/*!****************************************!*\
  !*** ./src/wgs/render/ShaderChunks.js ***!
  \****************************************/
/*! exports provided: CutPlanesUniforms, IdUniforms, ThemingUniform, ShadowMapCommonUniforms, ShadowMapUniforms, PointSizeUniforms, WideLinesUniforms, DepthTextureUniforms, DepthTextureTestUniforms, GetPrismMapSampleChunk, GetPrismMapUniformChunk, resolve, PackDepthShaderChunk, TonemapShaderChunk, OrderedDitheringShaderChunk, CutPlanesShaderChunk, PackNormalsShaderChunk, HatchPatternShaderChunk, EnvSamplingShaderChunk, IdVertexDeclaration, IdVertexShaderChunk, IdFragmentDeclaration, IdOutputShaderChunk, FinalOutputShaderChunk, ThemingFragmentDeclaration, ThemingFragmentShaderChunk, InstancingVertexDeclaration, ShadowMapDeclareCommonUniforms, ShadowMapVertexDeclaration, ShadowMapVertexShaderChunk, ShadowMapFragmentDeclaration, PointSizeDeclaration, PointSizeShaderChunk, ShaderChunks */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CutPlanesUniforms", function() { return CutPlanesUniforms; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IdUniforms", function() { return IdUniforms; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ThemingUniform", function() { return ThemingUniform; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ShadowMapCommonUniforms", function() { return ShadowMapCommonUniforms; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ShadowMapUniforms", function() { return ShadowMapUniforms; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PointSizeUniforms", function() { return PointSizeUniforms; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WideLinesUniforms", function() { return WideLinesUniforms; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DepthTextureUniforms", function() { return DepthTextureUniforms; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DepthTextureTestUniforms", function() { return DepthTextureTestUniforms; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GetPrismMapSampleChunk", function() { return GetPrismMapSampleChunk; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GetPrismMapUniformChunk", function() { return GetPrismMapUniformChunk; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "resolve", function() { return resolve; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PackDepthShaderChunk", function() { return PackDepthShaderChunk; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TonemapShaderChunk", function() { return TonemapShaderChunk; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "OrderedDitheringShaderChunk", function() { return OrderedDitheringShaderChunk; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CutPlanesShaderChunk", function() { return CutPlanesShaderChunk; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PackNormalsShaderChunk", function() { return PackNormalsShaderChunk; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HatchPatternShaderChunk", function() { return HatchPatternShaderChunk; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EnvSamplingShaderChunk", function() { return EnvSamplingShaderChunk; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IdVertexDeclaration", function() { return IdVertexDeclaration; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IdVertexShaderChunk", function() { return IdVertexShaderChunk; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IdFragmentDeclaration", function() { return IdFragmentDeclaration; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IdOutputShaderChunk", function() { return IdOutputShaderChunk; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FinalOutputShaderChunk", function() { return FinalOutputShaderChunk; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ThemingFragmentDeclaration", function() { return ThemingFragmentDeclaration; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ThemingFragmentShaderChunk", function() { return ThemingFragmentShaderChunk; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "InstancingVertexDeclaration", function() { return InstancingVertexDeclaration; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ShadowMapDeclareCommonUniforms", function() { return ShadowMapDeclareCommonUniforms; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ShadowMapVertexDeclaration", function() { return ShadowMapVertexDeclaration; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ShadowMapVertexShaderChunk", function() { return ShadowMapVertexShaderChunk; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ShadowMapFragmentDeclaration", function() { return ShadowMapFragmentDeclaration; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PointSizeDeclaration", function() { return PointSizeDeclaration; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PointSizeShaderChunk", function() { return PointSizeShaderChunk; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ShaderChunks", function() { return ShaderChunks; });
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ "three");
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(three__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _chunks_pack_depth_glsl__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./chunks/pack_depth.glsl */ "./src/wgs/render/chunks/pack_depth.glsl");
/* harmony import */ var _chunks_pack_depth_glsl__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_chunks_pack_depth_glsl__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _chunks_depth_texture_glsl__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./chunks/depth_texture.glsl */ "./src/wgs/render/chunks/depth_texture.glsl");
/* harmony import */ var _chunks_depth_texture_glsl__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_chunks_depth_texture_glsl__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _chunks_tonemap_glsl__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./chunks/tonemap.glsl */ "./src/wgs/render/chunks/tonemap.glsl");
/* harmony import */ var _chunks_tonemap_glsl__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_chunks_tonemap_glsl__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _chunks_ordered_dither_glsl__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./chunks/ordered_dither.glsl */ "./src/wgs/render/chunks/ordered_dither.glsl");
/* harmony import */ var _chunks_ordered_dither_glsl__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_chunks_ordered_dither_glsl__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _chunks_cutplanes_glsl__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./chunks/cutplanes.glsl */ "./src/wgs/render/chunks/cutplanes.glsl");
/* harmony import */ var _chunks_cutplanes_glsl__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_chunks_cutplanes_glsl__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _chunks_pack_normals_glsl__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./chunks/pack_normals.glsl */ "./src/wgs/render/chunks/pack_normals.glsl");
/* harmony import */ var _chunks_pack_normals_glsl__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(_chunks_pack_normals_glsl__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var _chunks_hatch_pattern_glsl__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./chunks/hatch_pattern.glsl */ "./src/wgs/render/chunks/hatch_pattern.glsl");
/* harmony import */ var _chunks_hatch_pattern_glsl__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(_chunks_hatch_pattern_glsl__WEBPACK_IMPORTED_MODULE_7__);
/* harmony import */ var _chunks_env_sample_glsl__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./chunks/env_sample.glsl */ "./src/wgs/render/chunks/env_sample.glsl");
/* harmony import */ var _chunks_env_sample_glsl__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(_chunks_env_sample_glsl__WEBPACK_IMPORTED_MODULE_8__);
/* harmony import */ var _chunks_id_decl_vert_glsl__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./chunks/id_decl_vert.glsl */ "./src/wgs/render/chunks/id_decl_vert.glsl");
/* harmony import */ var _chunks_id_decl_vert_glsl__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(_chunks_id_decl_vert_glsl__WEBPACK_IMPORTED_MODULE_9__);
/* harmony import */ var _chunks_id_vert_glsl__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./chunks/id_vert.glsl */ "./src/wgs/render/chunks/id_vert.glsl");
/* harmony import */ var _chunks_id_vert_glsl__WEBPACK_IMPORTED_MODULE_10___default = /*#__PURE__*/__webpack_require__.n(_chunks_id_vert_glsl__WEBPACK_IMPORTED_MODULE_10__);
/* harmony import */ var _chunks_id_decl_frag_glsl__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./chunks/id_decl_frag.glsl */ "./src/wgs/render/chunks/id_decl_frag.glsl");
/* harmony import */ var _chunks_id_decl_frag_glsl__WEBPACK_IMPORTED_MODULE_11___default = /*#__PURE__*/__webpack_require__.n(_chunks_id_decl_frag_glsl__WEBPACK_IMPORTED_MODULE_11__);
/* harmony import */ var _chunks_id_frag_glsl__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./chunks/id_frag.glsl */ "./src/wgs/render/chunks/id_frag.glsl");
/* harmony import */ var _chunks_id_frag_glsl__WEBPACK_IMPORTED_MODULE_12___default = /*#__PURE__*/__webpack_require__.n(_chunks_id_frag_glsl__WEBPACK_IMPORTED_MODULE_12__);
/* harmony import */ var _chunks_final_frag_glsl__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./chunks/final_frag.glsl */ "./src/wgs/render/chunks/final_frag.glsl");
/* harmony import */ var _chunks_final_frag_glsl__WEBPACK_IMPORTED_MODULE_13___default = /*#__PURE__*/__webpack_require__.n(_chunks_final_frag_glsl__WEBPACK_IMPORTED_MODULE_13__);
/* harmony import */ var _chunks_theming_decl_frag_glsl__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./chunks/theming_decl_frag.glsl */ "./src/wgs/render/chunks/theming_decl_frag.glsl");
/* harmony import */ var _chunks_theming_decl_frag_glsl__WEBPACK_IMPORTED_MODULE_14___default = /*#__PURE__*/__webpack_require__.n(_chunks_theming_decl_frag_glsl__WEBPACK_IMPORTED_MODULE_14__);
/* harmony import */ var _chunks_theming_frag_glsl__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./chunks/theming_frag.glsl */ "./src/wgs/render/chunks/theming_frag.glsl");
/* harmony import */ var _chunks_theming_frag_glsl__WEBPACK_IMPORTED_MODULE_15___default = /*#__PURE__*/__webpack_require__.n(_chunks_theming_frag_glsl__WEBPACK_IMPORTED_MODULE_15__);
/* harmony import */ var _chunks_instancing_decl_vert_glsl__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./chunks/instancing_decl_vert.glsl */ "./src/wgs/render/chunks/instancing_decl_vert.glsl");
/* harmony import */ var _chunks_instancing_decl_vert_glsl__WEBPACK_IMPORTED_MODULE_16___default = /*#__PURE__*/__webpack_require__.n(_chunks_instancing_decl_vert_glsl__WEBPACK_IMPORTED_MODULE_16__);
/* harmony import */ var _chunks_shadowmap_decl_common_glsl__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./chunks/shadowmap_decl_common.glsl */ "./src/wgs/render/chunks/shadowmap_decl_common.glsl");
/* harmony import */ var _chunks_shadowmap_decl_common_glsl__WEBPACK_IMPORTED_MODULE_17___default = /*#__PURE__*/__webpack_require__.n(_chunks_shadowmap_decl_common_glsl__WEBPACK_IMPORTED_MODULE_17__);
/* harmony import */ var _chunks_shadowmap_decl_vert_glsl__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./chunks/shadowmap_decl_vert.glsl */ "./src/wgs/render/chunks/shadowmap_decl_vert.glsl");
/* harmony import */ var _chunks_shadowmap_decl_vert_glsl__WEBPACK_IMPORTED_MODULE_18___default = /*#__PURE__*/__webpack_require__.n(_chunks_shadowmap_decl_vert_glsl__WEBPACK_IMPORTED_MODULE_18__);
/* harmony import */ var _chunks_shadowmap_vert_glsl__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./chunks/shadowmap_vert.glsl */ "./src/wgs/render/chunks/shadowmap_vert.glsl");
/* harmony import */ var _chunks_shadowmap_vert_glsl__WEBPACK_IMPORTED_MODULE_19___default = /*#__PURE__*/__webpack_require__.n(_chunks_shadowmap_vert_glsl__WEBPACK_IMPORTED_MODULE_19__);
/* harmony import */ var _chunks_shadowmap_decl_frag_glsl__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./chunks/shadowmap_decl_frag.glsl */ "./src/wgs/render/chunks/shadowmap_decl_frag.glsl");
/* harmony import */ var _chunks_shadowmap_decl_frag_glsl__WEBPACK_IMPORTED_MODULE_20___default = /*#__PURE__*/__webpack_require__.n(_chunks_shadowmap_decl_frag_glsl__WEBPACK_IMPORTED_MODULE_20__);
/* harmony import */ var _chunks_float3_average_glsl__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./chunks/float3_average.glsl */ "./src/wgs/render/chunks/float3_average.glsl");
/* harmony import */ var _chunks_float3_average_glsl__WEBPACK_IMPORTED_MODULE_21___default = /*#__PURE__*/__webpack_require__.n(_chunks_float3_average_glsl__WEBPACK_IMPORTED_MODULE_21__);
/* harmony import */ var _chunks_line_decl_common_glsl__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./chunks/line_decl_common.glsl */ "./src/wgs/render/chunks/line_decl_common.glsl");
/* harmony import */ var _chunks_line_decl_common_glsl__WEBPACK_IMPORTED_MODULE_22___default = /*#__PURE__*/__webpack_require__.n(_chunks_line_decl_common_glsl__WEBPACK_IMPORTED_MODULE_22__);
/* harmony import */ var _chunks_prism_wood_glsl__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./chunks/prism_wood.glsl */ "./src/wgs/render/chunks/prism_wood.glsl");
/* harmony import */ var _chunks_prism_wood_glsl__WEBPACK_IMPORTED_MODULE_23___default = /*#__PURE__*/__webpack_require__.n(_chunks_prism_wood_glsl__WEBPACK_IMPORTED_MODULE_23__);
/* harmony import */ var _chunks_prism_glazing_glsl__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./chunks/prism_glazing.glsl */ "./src/wgs/render/chunks/prism_glazing.glsl");
/* harmony import */ var _chunks_prism_glazing_glsl__WEBPACK_IMPORTED_MODULE_24___default = /*#__PURE__*/__webpack_require__.n(_chunks_prism_glazing_glsl__WEBPACK_IMPORTED_MODULE_24__);
/* harmony import */ var _chunks_prism_transparency_glsl__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./chunks/prism_transparency.glsl */ "./src/wgs/render/chunks/prism_transparency.glsl");
/* harmony import */ var _chunks_prism_transparency_glsl__WEBPACK_IMPORTED_MODULE_25___default = /*#__PURE__*/__webpack_require__.n(_chunks_prism_transparency_glsl__WEBPACK_IMPORTED_MODULE_25__);
/* harmony import */ var _chunks_normal_map_glsl__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./chunks/normal_map.glsl */ "./src/wgs/render/chunks/normal_map.glsl");
/* harmony import */ var _chunks_normal_map_glsl__WEBPACK_IMPORTED_MODULE_26___default = /*#__PURE__*/__webpack_require__.n(_chunks_normal_map_glsl__WEBPACK_IMPORTED_MODULE_26__);
/* harmony import */ var _chunks_decl_point_size_glsl__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ./chunks/decl_point_size.glsl */ "./src/wgs/render/chunks/decl_point_size.glsl");
/* harmony import */ var _chunks_decl_point_size_glsl__WEBPACK_IMPORTED_MODULE_27___default = /*#__PURE__*/__webpack_require__.n(_chunks_decl_point_size_glsl__WEBPACK_IMPORTED_MODULE_27__);
/* harmony import */ var _chunks_point_size_glsl__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ./chunks/point_size.glsl */ "./src/wgs/render/chunks/point_size.glsl");
/* harmony import */ var _chunks_point_size_glsl__WEBPACK_IMPORTED_MODULE_28___default = /*#__PURE__*/__webpack_require__.n(_chunks_point_size_glsl__WEBPACK_IMPORTED_MODULE_28__);
/* harmony import */ var _chunks_wide_lines_decl_glsl__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! ./chunks/wide_lines_decl.glsl */ "./src/wgs/render/chunks/wide_lines_decl.glsl");
/* harmony import */ var _chunks_wide_lines_decl_glsl__WEBPACK_IMPORTED_MODULE_29___default = /*#__PURE__*/__webpack_require__.n(_chunks_wide_lines_decl_glsl__WEBPACK_IMPORTED_MODULE_29__);
/* harmony import */ var _chunks_wide_lines_vert_glsl__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! ./chunks/wide_lines_vert.glsl */ "./src/wgs/render/chunks/wide_lines_vert.glsl");
/* harmony import */ var _chunks_wide_lines_vert_glsl__WEBPACK_IMPORTED_MODULE_30___default = /*#__PURE__*/__webpack_require__.n(_chunks_wide_lines_vert_glsl__WEBPACK_IMPORTED_MODULE_30__);
/* harmony import */ var _chunks_hsv_glsl__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(/*! ./chunks/hsv.glsl */ "./src/wgs/render/chunks/hsv.glsl");
/* harmony import */ var _chunks_hsv_glsl__WEBPACK_IMPORTED_MODULE_31___default = /*#__PURE__*/__webpack_require__.n(_chunks_hsv_glsl__WEBPACK_IMPORTED_MODULE_31__);
/*
 * Reusable sets of uniforms that can be merged with other uniforms in specific shaders.
 */



var CutPlanesUniforms = {
  "cutplanes": { type: "v4v", value: [] },
  "hatchParams": { type: "v2", value: new three__WEBPACK_IMPORTED_MODULE_0__["Vector2"](1.0, 10.0) },
  "hatchTintColor": { type: "c", value: new three__WEBPACK_IMPORTED_MODULE_0__["Color"](0xFFFFFF) },
  "hatchTintIntensity": { type: "f", value: 1.0 } };


var IdUniforms = {
  "dbId": { type: "v3", value: new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"](0, 0, 0) },
  "modelId": { type: "v3", value: new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"](0, 0, 0) } };


var ThemingUniform = {
  "themingColor": { type: "v4", value: new three__WEBPACK_IMPORTED_MODULE_0__["Vector4"](0, 0, 0, 0) } };


// Uniforms shared by material shader chunks and ShadowMapShader
// Included by ShadowMapUniforms below.
var ShadowMapCommonUniforms = {
  "shadowESMConstant": { type: "f", value: 0.0 } };


// Uniforms needed by material shaders to apply shadow mapping.
var ShadowMapUniforms = three__WEBPACK_IMPORTED_MODULE_0__["UniformsUtils"].merge([
{
  "shadowMap": { type: "t", value: null },
  "shadowMapSize": { type: "v2", value: new three__WEBPACK_IMPORTED_MODULE_0__["Vector2"](0, 0) },
  "shadowBias": { type: "f", value: 0.0 },
  "shadowDarkness": { type: "f", value: 0.0 },
  "shadowMatrix": { type: "m4", value: new three__WEBPACK_IMPORTED_MODULE_0__["Matrix4"]() },
  "shadowLightDir": { type: "v3", value: new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"]() } },

ShadowMapCommonUniforms]);


// Uniform for point-set point size
var PointSizeUniforms = {
  "point_size": { type: "f", value: 1.0 } };


// Uniform for wide lines shader
var WideLinesUniforms = {
  "view_size": { type: "v2", value: new three__WEBPACK_IMPORTED_MODULE_0__["Vector2"](640, 480) } };


// Uniforms used for reconstructing positions from depth-texture in post-passes. (depth_texture.glsl)
var DepthTextureUniforms = {
  "tDepth": { type: "t", value: null },
  "projInfo": { type: "v4", value: new three__WEBPACK_IMPORTED_MODULE_0__["Vector4"]() },
  "isOrtho": { type: "f", value: 0.0 },
  "worldMatrix_mainPass": { type: "m4", value: new three__WEBPACK_IMPORTED_MODULE_0__["Matrix4"]() } };


var DepthTextureTestUniforms = {
  "tDepthTest": { type: "t", value: null },
  "tDepthResolution": { type: "v2", value: new three__WEBPACK_IMPORTED_MODULE_0__["Vector2"](1 / 1024, 1 / 1024) } };



/*
                                                                                       * Chunks are code snippets that can be included in specific shaders
                                                                                       * using the three.js-style include directive:
                                                                                       *
                                                                                       *      #include<name_of_chunk>
                                                                                       *
                                                                                       * During runtime this directive can be expanded into the corresponding
                                                                                       * code snippet using the `resolve` method available below.
                                                                                       */
var chunks = {};

// We include default three.js chunks, too
for (var name in three__WEBPACK_IMPORTED_MODULE_0__["ShaderChunk"]) {
  chunks[name] = three__WEBPACK_IMPORTED_MODULE_0__["ShaderChunk"][name];
}

































chunks['pack_depth'] = _chunks_pack_depth_glsl__WEBPACK_IMPORTED_MODULE_1___default.a;
chunks['depth_texture'] = _chunks_depth_texture_glsl__WEBPACK_IMPORTED_MODULE_2___default.a;
chunks['tonemap'] = _chunks_tonemap_glsl__WEBPACK_IMPORTED_MODULE_3___default.a;
chunks['ordered_dither'] = _chunks_ordered_dither_glsl__WEBPACK_IMPORTED_MODULE_4___default.a;
chunks['cutplanes'] = _chunks_cutplanes_glsl__WEBPACK_IMPORTED_MODULE_5___default.a;
chunks['pack_normals'] = _chunks_pack_normals_glsl__WEBPACK_IMPORTED_MODULE_6___default.a;
chunks['hatch_pattern'] = _chunks_hatch_pattern_glsl__WEBPACK_IMPORTED_MODULE_7___default.a;
chunks['env_sample'] = _chunks_env_sample_glsl__WEBPACK_IMPORTED_MODULE_8___default.a;
chunks['id_decl_vert'] = _chunks_id_decl_vert_glsl__WEBPACK_IMPORTED_MODULE_9___default.a;
chunks['id_vert'] = _chunks_id_vert_glsl__WEBPACK_IMPORTED_MODULE_10___default.a;
chunks['id_decl_frag'] = _chunks_id_decl_frag_glsl__WEBPACK_IMPORTED_MODULE_11___default.a;
chunks['id_frag'] = _chunks_id_frag_glsl__WEBPACK_IMPORTED_MODULE_12___default.a;
chunks['final_frag'] = _chunks_final_frag_glsl__WEBPACK_IMPORTED_MODULE_13___default.a;
chunks['theming_decl_frag'] = _chunks_theming_decl_frag_glsl__WEBPACK_IMPORTED_MODULE_14___default.a;
chunks['theming_frag'] = _chunks_theming_frag_glsl__WEBPACK_IMPORTED_MODULE_15___default.a;
chunks['instancing_decl_vert'] = _chunks_instancing_decl_vert_glsl__WEBPACK_IMPORTED_MODULE_16___default.a;
chunks['shadowmap_decl_common'] = _chunks_shadowmap_decl_common_glsl__WEBPACK_IMPORTED_MODULE_17___default.a;
chunks['shadowmap_decl_vert'] = _chunks_shadowmap_decl_vert_glsl__WEBPACK_IMPORTED_MODULE_18___default.a;
chunks['shadowmap_vert'] = _chunks_shadowmap_vert_glsl__WEBPACK_IMPORTED_MODULE_19___default.a;
chunks['shadowmap_decl_frag'] = _chunks_shadowmap_decl_frag_glsl__WEBPACK_IMPORTED_MODULE_20___default.a;
chunks['float3_average'] = _chunks_float3_average_glsl__WEBPACK_IMPORTED_MODULE_21___default.a;
chunks['line_decl_common'] = _chunks_line_decl_common_glsl__WEBPACK_IMPORTED_MODULE_22___default.a;
chunks['prism_wood'] = _chunks_prism_wood_glsl__WEBPACK_IMPORTED_MODULE_23___default.a;
chunks['prism_glazing'] = _chunks_prism_glazing_glsl__WEBPACK_IMPORTED_MODULE_24___default.a;
chunks['prism_transparency'] = _chunks_prism_transparency_glsl__WEBPACK_IMPORTED_MODULE_25___default.a;
chunks['normal_map'] = _chunks_normal_map_glsl__WEBPACK_IMPORTED_MODULE_26___default.a;
chunks['decl_point_size'] = _chunks_decl_point_size_glsl__WEBPACK_IMPORTED_MODULE_27___default.a;
chunks['point_size'] = _chunks_point_size_glsl__WEBPACK_IMPORTED_MODULE_28___default.a;
chunks['wide_lines_decl'] = _chunks_wide_lines_decl_glsl__WEBPACK_IMPORTED_MODULE_29___default.a;
chunks['wide_lines_vert'] = _chunks_wide_lines_vert_glsl__WEBPACK_IMPORTED_MODULE_30___default.a;
chunks['hsv'] = _chunks_hsv_glsl__WEBPACK_IMPORTED_MODULE_31___default.a;

/*
                      * Macros are simple JavaScript functions that can be evaluated from
                      * within the shader code using a similar syntax as the include directive:
                      *
                      *      #name_of_macro<first_param, second_param, third_param, ...>
                      *
                      * All parameters are simply passed to the JavaScript code as strings,
                      * i.e., they are not parsed in any way.
                      *
                      * We use this as a way to call the various Prism helper methods (such as
                      * GetPrismMapsDefinitionChunk below) without having to compose the shader
                      * code from lists of strings.
                      */
var macros = {};

// If any map type is defined, then do whatever "content" is;
// typically it's "#define USE_MAP". In other words, if any map
// is defined, then USE_MAP will also be defined. This constant
// is then checked and determines whether a UV variable is defined, etc.
function GetPrismMapsDefinitionChunk(flag) {
  var def = ["#if defined( USE_SURFACE_ALBEDO_MAP )" +
  " || defined( USE_SURFACE_ROUGHNESS_MAP )" +
  " || defined( USE_SURFACE_CUTOUT_MAP )" +
  " || defined( USE_SURFACE_ANISOTROPY_MAP )" +
  " || defined( USE_SURFACE_ROTATION_MAP )" +
  " || defined( USE_OPAQUE_ALBEDO_MAP )" +
  " || defined( USE_OPAQUE_F0_MAP )" +
  " || defined( USE_OPAQUE_LUMINANCE_MODIFIER_MAP )" +
  " || defined( USE_LAYERED_BOTTOM_F0_MAP )" +
  " || defined( USE_LAYERED_F0_MAP )" +
  " || defined( USE_LAYERED_DIFFUSE_MAP )" +
  " || defined( USE_LAYERED_FRACTION_MAP )" +
  " || defined( USE_LAYERED_ROUGHNESS_MAP )" +
  " || defined( USE_LAYERED_ANISOTROPY_MAP )" +
  " || defined( USE_LAYERED_ROTATION_MAP )" +
  " || defined( USE_METAL_F0_MAP )" +
  " || defined( USE_SURFACE_NORMAL_MAP )" +
  " || defined( USE_LAYERED_NORMAL_MAP )",
  "#define " + flag,
  "#endif"].
  join("\n");
  return def;
}

macros['prism_check'] = GetPrismMapsDefinitionChunk;

// Set up code for texture access. If USE_SURFACE_ALBEDO_MAP is defined, for example, this texture access code gets executed.
// If it's not defined, then a simply copy occurs, e.g. "surfaceAlbedo = surface_albedo;" from the variableName and mapType.
function GetPrismMapSampleChunk(mapType, variableName, isFloat, linearize) {
  var suffix = isFloat ? "_v3" : "";
  var declare = isFloat ? "vec3 " : "";
  var average = isFloat ? variableName + " = average(" + variableName + suffix + ");" : "";
  var colorLinearization = linearize ? variableName + suffix + " = SRGBToLinear(" + variableName + suffix + ");" : "";
  var shader = [
  "#if defined( USE_" + mapType.toUpperCase() + "_MAP )",
  // note: the tiling system needs to modify the uv of the texture per tile, so we use the modified "uv" here, not vUv.
  "vec2 uv_" + mapType + "_map = (" + mapType + "_map_texMatrix * vec3(uv, 1.0)).xy;",
  mapType.toUpperCase() + "_CLAMP_TEST;",
  declare + variableName + suffix + " = texture2D(" + mapType + "_map, uv_" + mapType + "_map).xyz;",
  colorLinearization,
  "if(" + mapType + "_map_invert) " + variableName + suffix + " = vec3(1.0) - " + variableName + suffix + ";",
  average,
  "#else",
  variableName + " = " + mapType + ";",
  "#endif"].
  join("\n");

  return shader;
}

macros['prism_sample_texture'] = function (mapType, varName, isFloat, linearize) {
  return GetPrismMapSampleChunk(mapType, varName, isFloat === 'true', linearize === 'true');
};

function GetPrismMapUniformChunk(mapName) {

  var mtxName = mapName + "_texMatrix";
  var mapInvt = mapName + "_invert";
  var macroName = "USE_" + mapName;

  var uniforms = [
  "#if defined( " + macroName.toUpperCase() + " )",
  "uniform sampler2D " + mapName + ";",
  "uniform mat3 " + mtxName + ";",
  "uniform bool " + mapInvt + ";",
  "#endif"].
  join("\n");

  return uniforms;
}

macros['prism_uniforms'] = GetPrismMapUniformChunk;

function GetPrismBumpMapUniformChunk(mapName) {

  var mtxName = mapName + "_texMatrix";
  var mapScale = mapName + "_bumpScale";
  var mapType = mapName + "_bumpmapType";
  var macroName = "USE_" + mapName;

  var uniforms = [
  "#if defined( " + macroName.toUpperCase() + " )",
  "uniform sampler2D " + mapName + ";",
  "uniform mat3 " + mtxName + ";",
  "uniform vec2 " + mapScale + ";",
  "uniform int " + mapType + ";",
  "#endif"].
  join("\n");

  return uniforms;
}

macros['prism_bump_uniforms'] = GetPrismBumpMapUniformChunk;

// Precompile regexes for the macros
var _regExCache = {};
for (name in macros) {
  _regExCache[name] = new RegExp('#' + name + ' *<([\\w\\d., ]*)>', 'g');
}

/**
   * Recursively resolves include directives and macros.
   * @param {string} source Original shader code.
   * @returns {string} Shader code with all includes resolved.
   */
var resolve = function resolve(source) {
  for (var name in macros) {
    var re = _regExCache[name];
    source = source.replace(re, function (match, parens) {
      var params = parens.split(',').map(function (param) {return param.trim();});
      return macros[name].apply(null, params);
    });
  }

  var pattern = /#include *<([\w\d.]+)>/g;
  var func = function func(match, include) {
    if (!chunks[include]) {
      throw new Error('Cannot resolve #include<' + include + '>');
    }
    return resolve(chunks[include]);
  };
  return source.replace(pattern, func);
};

// The chunks don't have to be exported anymore, but we keep them
// for backwards compatibility (they're still referenced in LegacyNamespace.js)
var PackDepthShaderChunk = chunks['pack_depth'];
var TonemapShaderChunk = chunks['tonemap'];
var OrderedDitheringShaderChunk = chunks['ordered_dither'];
var CutPlanesShaderChunk = chunks['cutplanes'];
var PackNormalsShaderChunk = chunks['pack_normals'];
var HatchPatternShaderChunk = chunks['hatch_pattern'];
var EnvSamplingShaderChunk = chunks['env_sample'];
var IdVertexDeclaration = chunks['id_decl_vert'];
var IdVertexShaderChunk = chunks['id_vert'];
var IdFragmentDeclaration = chunks['id_decl_frag'];
var IdOutputShaderChunk = chunks['id_frag'];
var FinalOutputShaderChunk = chunks['final_frag'];
var ThemingFragmentDeclaration = chunks['theming_decl_frag'];
var ThemingFragmentShaderChunk = chunks['theming_frag'];
var InstancingVertexDeclaration = chunks['instancing_decl_vert'];
var ShadowMapDeclareCommonUniforms = chunks['shadowmap_decl_common'];
var ShadowMapVertexDeclaration = chunks['shadowmap_decl_vert'];
var ShadowMapVertexShaderChunk = chunks['shadowmap_vert'];
var ShadowMapFragmentDeclaration = chunks['shadowmap_decl_frag'];
var PointSizeDeclaration = chunks['decl_point_size'];
var PointSizeShaderChunk = chunks['point_size'];

var ShaderChunks = {
  IdUniforms: IdUniforms,
  ThemingUniform: ThemingUniform,
  CutPlanesUniforms: CutPlanesUniforms,
  ShadowMapCommonUniforms: ShadowMapCommonUniforms,
  ShadowMapUniforms: ShadowMapUniforms,
  PointSizeUniforms: PointSizeUniforms,
  WideLinesUniforms: WideLinesUniforms,
  DepthTextureUniforms: DepthTextureUniforms,
  DepthTextureTestUniforms: DepthTextureTestUniforms,

  PackDepthShaderChunk: PackDepthShaderChunk,
  TonemapShaderChunk: TonemapShaderChunk,
  OrderedDitheringShaderChunk: OrderedDitheringShaderChunk,
  CutPlanesShaderChunk: CutPlanesShaderChunk,
  PackNormalsShaderChunk: PackNormalsShaderChunk,
  HatchPatternShaderChunk: HatchPatternShaderChunk,
  EnvSamplingShaderChunk: EnvSamplingShaderChunk,
  IdVertexDeclaration: IdVertexDeclaration,
  IdVertexShaderChunk: IdVertexShaderChunk,
  IdFragmentDeclaration: IdFragmentDeclaration,
  IdOutputShaderChunk: IdOutputShaderChunk,
  FinalOutputShaderChunk: FinalOutputShaderChunk,
  ThemingFragmentDeclaration: ThemingFragmentDeclaration,
  ThemingFragmentShaderChunk: ThemingFragmentShaderChunk,
  InstancingVertexDeclaration: InstancingVertexDeclaration,
  ShadowMapDeclareCommonUniforms: ShadowMapDeclareCommonUniforms,
  ShadowMapVertexDeclaration: ShadowMapVertexDeclaration,
  ShadowMapVertexShaderChunk: ShadowMapVertexShaderChunk,
  ShadowMapFragmentDeclaration: ShadowMapFragmentDeclaration,
  PointSizeDeclaration: PointSizeDeclaration,
  PointSizeShaderChunk: PointSizeShaderChunk,

  GetPrismMapSampleChunk: GetPrismMapSampleChunk,
  GetPrismMapUniformChunk: GetPrismMapUniformChunk,

  resolve: resolve };

/***/ }),

/***/ "./src/wgs/render/chunks/cutplanes.glsl":
/*!**********************************************!*\
  !*** ./src/wgs/render/chunks/cutplanes.glsl ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "#if NUM_CUTPLANES > 0\nuniform vec4 cutplanes[NUM_CUTPLANES];\nvoid checkCutPlanes(vec3 worldPosition) {\n    for (int i=0; i<NUM_CUTPLANES; i++) {\n        if (dot(vec4(worldPosition, 1.0), cutplanes[i]) > 0.0) {\n            discard;\n        }\n    }\n}\n#endif\n";

/***/ }),

/***/ "./src/wgs/render/chunks/decl_point_size.glsl":
/*!****************************************************!*\
  !*** ./src/wgs/render/chunks/decl_point_size.glsl ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "uniform float point_size;";

/***/ }),

/***/ "./src/wgs/render/chunks/depth_texture.glsl":
/*!**************************************************!*\
  !*** ./src/wgs/render/chunks/depth_texture.glsl ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "\nuniform sampler2D tDepth;\nuniform vec4 projInfo;\nuniform float isOrtho;\nuniform mat4 worldMatrix_mainPass;\nvec3 reconstructCSPosition(vec2 fragCoords, float z) {\n    return vec3((fragCoords * projInfo.xy + projInfo.zw) * mix(z, -1.0, isOrtho), z);\n}\nvec3 reconstructWorldPosition(vec2 fragCoords, vec2 screenUv) {\n    float zCam = texture2D(tDepth, screenUv).z;\n    vec3 csPos = reconstructCSPosition(fragCoords, zCam);\n    return (worldMatrix_mainPass * vec4(csPos, 1.0)).xyz;\n}\n";

/***/ }),

/***/ "./src/wgs/render/chunks/env_sample.glsl":
/*!***********************************************!*\
  !*** ./src/wgs/render/chunks/env_sample.glsl ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "\nuniform float envRotationSin;\nuniform float envRotationCos;\nvec3 adjustLookupVector(in vec3 lookup) {\n    return vec3(\n            envRotationCos * lookup.x - envRotationSin * lookup.z,\n            lookup.y,\n            envRotationSin * lookup.x + envRotationCos * lookup.z);\n}\nvec3 RGBMDecode(in vec4 vRGBM, in float exposure) {\n    vec3 ret = vRGBM.rgb * (vRGBM.a * 16.0);\n    ret *= ret;\n    ret *= exposure;\n    return ret;\n}\nvec3 GammaDecode(in vec4 vRGBA, in float exposure) {\n    return vRGBA.xyz * vRGBA.xyz * exposure;\n}\nvec3 sampleIrradianceMap(vec3 dirWorld, samplerCube irrMap, float exposure) {\n    vec4 cubeColor4 = textureCube(irrMap, adjustLookupVector(dirWorld));\n#ifdef IRR_GAMMA\n    vec3 indirectDiffuse = GammaDecode(cubeColor4, exposure);\n#elif defined(IRR_RGBM)\n    vec3 indirectDiffuse = RGBMDecode(cubeColor4, exposure);\n#else\n    vec3 indirectDiffuse = cubeColor4.xyz;\n#ifdef GAMMA_INPUT\n    indirectDiffuse.xyz *= indirectDiffuse.xyz;\n#endif\n#endif\n    return indirectDiffuse;\n}\n";

/***/ }),

/***/ "./src/wgs/render/chunks/final_frag.glsl":
/*!***********************************************!*\
  !*** ./src/wgs/render/chunks/final_frag.glsl ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "#ifdef HATCH_PATTERN\ngl_FragColor = calculateHatchPattern(hatchParams, gl_FragCoord.xy, gl_FragColor, hatchTintColor, hatchTintIntensity);\n#endif\n#ifdef MRT_NORMALS\noutNormal = vec4(geomNormal.x, geomNormal.y, depth, gl_FragColor.a < 1.0 ? 0.0 : 1.0);\n#endif\n#include<id_frag>\n";

/***/ }),

/***/ "./src/wgs/render/chunks/float3_average.glsl":
/*!***************************************************!*\
  !*** ./src/wgs/render/chunks/float3_average.glsl ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "float averageOfFloat3(in vec3 value) { \n    const float oneThird = 1.0 / 3.0; \n    return dot(value, vec3(oneThird, oneThird, oneThird)); \n} \n";

/***/ }),

/***/ "./src/wgs/render/chunks/hatch_pattern.glsl":
/*!**************************************************!*\
  !*** ./src/wgs/render/chunks/hatch_pattern.glsl ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "#ifdef HATCH_PATTERN\nuniform vec2 hatchParams;\nuniform vec3 hatchTintColor;\nuniform float hatchTintIntensity;\nfloat curveGaussian(float r, float invWidth) {\n    float amt = clamp(r * invWidth, 0.0, 1.0);\n    float exponent = amt * 3.5;\n    return exp(-exponent*exponent);\n}\nvec4 calculateHatchPattern(vec2 hatchParams, vec2 coord, vec4 fragColor, vec3 hatchTintColor, float hatchTintIntensity ) {\n    float hatchSlope = hatchParams.x;\n    float hatchPeriod = hatchParams.y;\n    if (abs(hatchSlope) <= 1.0) {\n        float hatchPhase = coord.y - hatchSlope * coord.x;\n        float dist = abs(mod((hatchPhase), (hatchPeriod)));\n        if (dist < 1.0) {\n            fragColor = vec4(0.0,0.0,0.0,1.0);\n        } else {\n            fragColor.xyz = mix(fragColor.xyz, hatchTintColor, hatchTintIntensity);\n        }\n    } else {\n        float hatchPhase = - coord.y / hatchSlope + coord.x;\n        float dist = abs(mod((hatchPhase), (hatchPeriod)));\n        if (dist < 1.0) {\n            fragColor = vec4(0.0,0.0,0.0,1.0);\n        } else {\n            fragColor.xyz = mix(fragColor.xyz, hatchTintColor, hatchTintIntensity);\n        }\n    }\n    return fragColor;\n}\n#endif\n";

/***/ }),

/***/ "./src/wgs/render/chunks/hsv.glsl":
/*!****************************************!*\
  !*** ./src/wgs/render/chunks/hsv.glsl ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "vec3 rgb2hsv(vec3 color)\n{\n    float delta;\n    float colorMax, colorMin;\n    float h,s,v;\n    vec3 hsv;\n    colorMax = max(color.r,color.g);\n    colorMax = max(colorMax,color.b);\n    colorMin = min(color.r,color.g);\n    colorMin = min(colorMin,color.b);\n    v = colorMax;\n    if(colorMax != 0.0)\n    {\n        s = (colorMax - colorMin)/colorMax;\n    }\n    else\n    {\n        s = 0.0;\n    }\n    if(s != 0.0)\n    {\n        delta = colorMax-colorMin;\n        if (color.r == colorMax)\n        {\n            h = (color.g-color.b)/delta;\n        }\n        else if (color.g == colorMax)\n        {\n            h = 2.0 + (color.b-color.r) / delta;\n        }\n        else\n        {\n            h = 4.0 + (color.r-color.g)/delta;\n        }\n        h /= 6.0;\n        if( h < 0.0)\n        {\n            h +=1.0;\n        }\n    }\n    else\n    {\n        h = 0.0;\n    }\n    hsv = vec3(h,s,v);\n    return hsv;\n}\nvec3 hsv2rgb(vec3 hsv)\n{\n    vec3 color;\n    float f,p,q,t;\n    float h,s,v;\n    float i,hi;\n    {\n        h = hsv.x*6.0;\n        s = hsv.y;\n        v = hsv.z;\n        i = floor(h);\n        f = h-i;\n        p = v * (1.0 - s);\n        q = v * (1.0 - (s * f));\n        t = v * (1.0 - (s * (1.0 - f)));\n        float r,g,b;\n        if (i == 0.0)\n        {\n            r = v;\n            g = t;\n            b = p;\n        }\n        else if (i == 1.0)\n        {\n            r = q;\n            g = v;\n            b = p;\n        }\n        else if (i == 2.0)\n        {\n            r = p;\n            g = v;\n            b = t;\n        }\n        else if (i == 3.0)\n        {\n            r = p;\n            g = q;\n            b = v;\n        }\n        else if (i == 4.0)\n        {\n            r = t;\n            g = p;\n            b = v;\n        }\n        else\n        {\n            r = v;\n            g = p;\n            b = q;\n        }\n        color = vec3(r,g,b);\n    }\n    return color;\n}";

/***/ }),

/***/ "./src/wgs/render/chunks/id_decl_frag.glsl":
/*!*************************************************!*\
  !*** ./src/wgs/render/chunks/id_decl_frag.glsl ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "#if defined(MRT_NORMALS) || defined(MRT_ID_BUFFER)\n    varying highp float depth;\n#endif\n#if defined(MRT_ID_BUFFER) || defined(ID_COLOR)\n    #ifdef USE_VERTEX_ID\n        varying vec3 vId;\n    #elif defined(LINE_2D_SHADER)\n        varying vec4 dbId;\n    #else\n        uniform vec3 dbId;\n    #endif\n#endif\n#if defined(MRT_ID_BUFFER) || defined(MODEL_COLOR)\n    uniform vec3 modelId;\n#endif\n#ifdef _LMVWEBGL2_\n    #if defined(MRT_NORMALS)\n        layout(location = 1) out vec4 outNormal;\n        #if defined(MRT_ID_BUFFER)\n            layout(location = 2) out vec4 outId;\n            #if defined(MODEL_COLOR)\n                layout(location = 3) out vec4 outModelId;\n            #endif\n        #endif\n    #elif defined(MRT_ID_BUFFER)\n        layout(location = 1) out vec4 outId;\n        #if defined(MODEL_COLOR)\n            layout(location = 2) out vec4 outModelId;\n        #endif\n    #endif\n#else\n    #define gl_FragColor gl_FragData[0]\n    #if defined(MRT_NORMALS)\n        #define outNormal gl_FragData[1]\n        #if defined(MRT_ID_BUFFER)\n            #define outId gl_FragData[2]\n            #if defined(MODEL_COLOR)\n                #define outModelId gl_FragData[3]\n            #endif\n        #endif\n    #elif defined(MRT_ID_BUFFER)\n        #define outId gl_FragData[1]\n        #if defined(MODEL_COLOR)\n            #define outModelId gl_FragData[2]\n        #endif\n    #endif\n#endif";

/***/ }),

/***/ "./src/wgs/render/chunks/id_decl_vert.glsl":
/*!*************************************************!*\
  !*** ./src/wgs/render/chunks/id_decl_vert.glsl ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "#ifdef USE_VERTEX_ID\nattribute vec3 id;\nvarying   vec3 vId;\n#endif\n";

/***/ }),

/***/ "./src/wgs/render/chunks/id_frag.glsl":
/*!********************************************!*\
  !*** ./src/wgs/render/chunks/id_frag.glsl ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "\n#if defined(USE_VERTEX_ID) && (defined(MRT_ID_BUFFER) || defined(ID_COLOR))\n    vec3 dbId = vId;\n#endif\n#ifdef MRT_ID_BUFFER\n    #ifndef ENABLE_ID_DISCARD\n        const float writeId = 1.0;\n    #endif\n    outId = vec4(dbId.rgb, writeId);\n    #ifdef MODEL_COLOR\n        outModelId = vec4(modelId.rgb, writeId);\n    #endif\n#elif defined(ID_COLOR)\n    #ifdef ENABLE_ID_DISCARD\n        if (writeId==0.0) {\n            discard;\n        }\n    #endif\n    gl_FragColor = vec4(dbId.rgb, 1.0);\n#elif defined(MODEL_COLOR)\n    #ifdef ENABLE_ID_DISCARD\n        if (writeId==0.0) {\n            discard;\n        }\n    #endif\n    gl_FragColor = vec4(modelId.rgb, 1.0);\n#endif\n";

/***/ }),

/***/ "./src/wgs/render/chunks/id_vert.glsl":
/*!********************************************!*\
  !*** ./src/wgs/render/chunks/id_vert.glsl ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "\n#ifdef USE_VERTEX_ID\nvId = id;\n#endif\n";

/***/ }),

/***/ "./src/wgs/render/chunks/instancing_decl_vert.glsl":
/*!*********************************************************!*\
  !*** ./src/wgs/render/chunks/instancing_decl_vert.glsl ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "\n#ifdef USE_INSTANCING\nattribute vec3 instOffset;\nattribute vec4 instRotation;\nattribute vec3 instScaling;\nvec3 applyQuaternion(vec3 p, vec4 q) {\n    return p + 2.0 * cross(q.xyz, cross(q.xyz, p) + q.w * p);\n}\nvec3 getInstancePos(vec3 pos) {\n    return instOffset + applyQuaternion(instScaling * pos, instRotation);\n}\nvec3 getInstanceNormal(vec3 normal) {\n    return applyQuaternion(normal/instScaling, instRotation);\n}\n#else\nvec3 getInstancePos(vec3 pos)       { return pos;    }\nvec3 getInstanceNormal(vec3 normal) { return normal; }\n#endif\n";

/***/ }),

/***/ "./src/wgs/render/chunks/line_decl_common.glsl":
/*!*****************************************************!*\
  !*** ./src/wgs/render/chunks/line_decl_common.glsl ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "\n#define LINE_2D_SHADER 1\n#define TAU     6.28318530718\n#define PI      3.14159265358979\n#define HALF_PI 1.57079632679\n#define PI_0_5  HALF_PI\n#define PI_1_5  4.71238898038\n#define ENABLE_ID_DISCARD\n#define VBB_GT_TRIANGLE_INDEXED  0.0\n#define VBB_GT_LINE_SEGMENT      1.0\n#define VBB_GT_ARC_CIRCULAR      2.0\n#define VBB_GT_ARC_ELLIPTICAL    3.0\n#define VBB_GT_TEX_QUAD          4.0\n#define VBB_GT_ONE_TRIANGLE      5.0\n#define VBB_GT_MSDF_TRIANGLE_INDEXED 6.0\n#define VBB_INSTANCED_FLAG   0.0\n#define VBB_SEG_START_RIGHT  0.0\n#define VBB_SEG_START_LEFT   1.0\n#define VBB_SEG_END_RIGHT    2.0\n#define VBB_SEG_END_LEFT     3.0\n#define LTSCALE 0.25\nvarying vec4 fsColor;\nvarying vec2 fsOffsetDirection;\nvarying vec4 fsMultipurpose;\nvarying float fsHalfWidth;\nvarying vec2 fsVpTC;\nvarying float fsGhosting;\n#ifdef LOADING_ANIMATION\nvarying float loadingProgress;\n#endif\n";

/***/ }),

/***/ "./src/wgs/render/chunks/normal_map.glsl":
/*!***********************************************!*\
  !*** ./src/wgs/render/chunks/normal_map.glsl ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "#if defined(USE_SURFACE_NORMAL_MAP) || defined( USE_LAYERED_NORMAL_MAP ) || defined( USE_TILING_NORMAL )\nvoid heightMapTransform(\n    sampler2D bumpTexture,\n    vec2 uv,\n    mat3 transform,\n    vec2 bumpScale,\n    inout vec3 T,\n    inout vec3 B,\n    inout vec3 N\n) {\n    vec2 st = (transform * vec3(uv, 1.0)).xy;\n    mat3 mtxTangent = mat3(T, B, N);\n    T = normalize(mtxTangent * (transform * vec3(1.0, 0.0, 0.0)));\n    B = normalize(mtxTangent * (transform * vec3(0.0, 1.0, 0.0)));\n    const float oneThird = 1.0 / 3.0;\n    vec3 avg = vec3(oneThird, oneThird, oneThird);\n    vec2 offset = fwidth(st);\n    float h0 = dot(texture2D(bumpTexture, st).xyz, avg);\n    float hx = dot(texture2D(bumpTexture, st + vec2(offset.x, 0.0)).xyz, avg);\n    float hy = dot(texture2D(bumpTexture, st + vec2(0.0, offset.y)).xyz, avg);\n    vec2 diff = vec2(h0 - hx, h0 - hy) / offset;\n    N = normalize(\n        N + (\n            diff.x * T * bumpScale.x +\n            diff.y * B * bumpScale.y\n        )\n    );\n}\nvoid normalMapTransform(\n    sampler2D bumpTexture,\n    vec2 uv,\n    mat3 transform,\n    vec2 bumpScale,\n    inout vec3 T,\n    inout vec3 B,\n    inout vec3 N\n) {\n    vec2 st = (transform * vec3(uv, 1.0)).xy;\n    vec3 mapN =  2.0 * texture2D(bumpTexture, st).xyz - 1.0;\n    mapN.xy *= bumpScale.x;\n    mapN.z *= bumpScale.y;\n    vec3 v = vec3(mapN.y, -mapN.x, 0.0);\n    float c = -mapN.z;\n    mat3 skewV = mat3(\n        0.0, v.z, -v.y,\n        -v.z, 0.0, v.x,\n        v.y, -v.x, 0.0\n    );\n    mat3 rot = mat3(1.0) + skewV + skewV*skewV * 1.0/(1.0-c);\n    N *= rot;\n    T *= rot;\n    B *= rot;\n}\n#endif\n";

/***/ }),

/***/ "./src/wgs/render/chunks/ordered_dither.glsl":
/*!***************************************************!*\
  !*** ./src/wgs/render/chunks/ordered_dither.glsl ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "vec3 orderedDithering(vec3 col) {\n    const vec4 m0 = vec4( 1.0, 13.0,  4.0, 16.0);\n    const vec4 m1 = vec4( 9.0,  5.0, 12.0,  8.0);\n    const vec4 m2 = vec4( 3.0, 15.0,  2.0, 14.0);\n    const vec4 m3 = vec4(11.0,  7.0, 10.0,  6.0);\n    int i = int(mod(float(gl_FragCoord.x), 4.0));\n    int j = int(mod(float(gl_FragCoord.y), 4.0));\n    vec4 biasRow;\n    if      (i==0) biasRow = m0;\n    else if (i==1) biasRow = m1;\n    else if (i==2) biasRow = m2;\n    else           biasRow = m3;\n    float bias;\n    if      (j==0) bias = biasRow.x;\n    else if (j==1) bias = biasRow.y;\n    else if (j==2) bias = biasRow.z;\n    else           bias = biasRow.w;\n    return col + bias / 17.0 / 256.0;\n}\n";

/***/ }),

/***/ "./src/wgs/render/chunks/pack_depth.glsl":
/*!***********************************************!*\
  !*** ./src/wgs/render/chunks/pack_depth.glsl ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "\nvec4 packDepth( const in float depth ) {\n    vec4 enc = vec4(1.0, 255.0, 65025.0, 160581375.0) * depth;\n    enc = fract(enc);\n    enc -= enc.yzww * vec4(1.0/255.0,1.0/255.0,1.0/255.0,0.0);\n    return enc;\n}\nfloat unpackDepth( const in vec4 rgba_depth ) {\n    return dot( rgba_depth, vec4(1.0, 1.0/255.0, 1.0/65025.0, 1.0/160581375.0) );\n}\n";

/***/ }),

/***/ "./src/wgs/render/chunks/pack_normals.glsl":
/*!*************************************************!*\
  !*** ./src/wgs/render/chunks/pack_normals.glsl ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "\n#define kPI 3.14159265358979\nvec2 encodeNormal (vec3 n) {\n    return (vec2(atan(n.y,n.x)/kPI, n.z)+1.0)*0.5;\n}\nvec3 decodeNormal (vec2 enc) {\n    vec2 ang = enc * 2.0 - 1.0;\n    vec2 scth = vec2(sin(ang.x * kPI), cos(ang.x * kPI));\n    vec2 scphi = vec2(sqrt(1.0 - ang.y * ang.y), ang.y);\n    return vec3(scth.y * scphi.x, scth.x * scphi.x, scphi.y);\n}\n";

/***/ }),

/***/ "./src/wgs/render/chunks/point_size.glsl":
/*!***********************************************!*\
  !*** ./src/wgs/render/chunks/point_size.glsl ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "gl_PointSize = point_size;";

/***/ }),

/***/ "./src/wgs/render/chunks/prism_glazing.glsl":
/*!**************************************************!*\
  !*** ./src/wgs/render/chunks/prism_glazing.glsl ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "\nvec3 TransmitAdjust(vec3 transmission, vec3 f0) \n{ \n   vec3 limit = max(1.0 - f0, 0.00001); \n   return clamp(transmission, vec3(0.0, 0.0, 0.0), limit) / limit; \n} \nfloat ColorToIlluminance(in vec3 color) \n{ \n   const vec3 rgb2grey = vec3(0.299, 0.587, 0.114); \n   float illuminance = dot(rgb2grey, color); \n   return illuminance; \n} \nvoid applyPrismGlazingOpacity(\n    inout vec4 color,\n    vec3 transmissionF,\n    float transmissionAlpha,\n    float NdotV,\n    float glazingIlluminace) \n{\n    const float third = 1.0/3.0; \n    float transSurface = exp(-(transmissionAlpha + (transmissionAlpha < 0.0025 ? 0.0 : 0.25)) * NdotV * PI); \n    float opacity = 1.0- dot((1.0 - transmissionF), vec3(third,third,third)) * transSurface * glazingIlluminace; \n    opacity = clamp(opacity, 0.01, 0.99);\n    color.a *= opacity;\n} \n";

/***/ }),

/***/ "./src/wgs/render/chunks/prism_transparency.glsl":
/*!*******************************************************!*\
  !*** ./src/wgs/render/chunks/prism_transparency.glsl ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "void applyPrismTransparency(\n    inout vec4 color,\n    vec3 transparentColor,\n    float transparentIor\n) {\n    float fsLevel = max(max(color.r, color.g), color.b);\n    color = vec4(color.rgb/fsLevel, fsLevel);\n    float transLevel = min(min(transparentColor.r, transparentColor.g), transparentColor.b);\n    transLevel = min( (1.0 - surface_roughness), transLevel );\n    float transAlpha = (1.0 - transLevel) * 0.4 + surface_roughness * 0.55;\n    vec3 tr_g_color = sqrt(transparentColor);\n    vec4 transColor = vec4(0.5 * vec3(tr_g_color), transAlpha);\n    float strength = 1.0 - (1.0 - fsLevel) * (1.0 - fsLevel);\n    color = mix(transColor, color, strength);\n    color.a = max(color.a, 0.05);\n    if (transparentIor == 1.0 && tr_g_color == vec3(1.0)) {\n        color.a = 0.0;\n    }\n}";

/***/ }),

/***/ "./src/wgs/render/chunks/prism_wood.glsl":
/*!***********************************************!*\
  !*** ./src/wgs/render/chunks/prism_wood.glsl ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "#if defined( PRISMWOOD )\n#define ONE 0.00390625\nfloat GetIndexedValue(vec4 array, int index)\n{\n    if (index == 0)\n        return array[0];\n    else if (index == 1)\n        return array[1];\n    else if (index == 2)\n        return array[2];\n    else if (index == 3)\n        return array[3];\n    else\n        return 0.0;\n}\nint GetIndexedValue(ivec2 array, int index)\n{\n    if (index == 0)\n        return array[0];\n    else if (index == 1)\n        return array[1];\n    else\n        return 0;\n}\n#if defined( USE_WOOD_CURLY_DISTORTION_MAP )\nfloat SampleCurlyPattern(vec2 uv)\n{\n    vec2 uv_wood_curly_distortion_map = (wood_curly_distortion_map_texMatrix * vec3(uv, 1.0)).xy;\n    WOOD_CURLY_DISTORTION_CLAMP_TEST;\n    vec3 curlyDistortion = texture2D(wood_curly_distortion_map, uv_wood_curly_distortion_map).xyz;\n    if(wood_curly_distortion_map_invert) curlyDistortion = vec3(1.0) - curlyDistortion;\n    return curlyDistortion.r;\n}\nvec3 DistortCurly(vec3 p)\n{\n    if (!wood_curly_distortion_enable) return p;\n    float r = length(p.xy);\n    if (r < 0.00001) return p;\n    const float INV_ANGLE_INTERVAL = 1.27323954;\n    const float NUM_INTERVAL = 8.0;\n    float theta = atan(p.y, p.x);\n    if (theta < 0.0)\n        theta += PI2;\n    float intIdx = theta * INV_ANGLE_INTERVAL;\n    int idx0 = int(mod(floor(intIdx), NUM_INTERVAL));\n    int idx1 = int(mod(ceil(intIdx), NUM_INTERVAL));\n    const vec4 HASH_TABLE1 = vec4(0.450572,0.114598, 0.886043, 0.315119);\n    const vec4 HASH_TABLE2 = vec4(0.216133,0.306264, 0.685616, 0.317907);\n    float offset0 = idx0 < 4 ? GetIndexedValue(HASH_TABLE1, idx0) : GetIndexedValue(HASH_TABLE2, idx0-4);\n    float offset1 = idx1 < 4 ? GetIndexedValue(HASH_TABLE1, idx1) : GetIndexedValue(HASH_TABLE2, idx1-4);\n    const float maxOffset = 100.0;\n    offset0 = (offset0 - 0.5) * maxOffset;\n    offset1 = (offset1 - 0.5) * maxOffset;\n    vec2 uv0 = vec2(p.z + offset0, r);\n    float shiftWeight0 =  SampleCurlyPattern(uv0);\n    vec2 uv1 = vec2(p.z + offset1, r);\n    float shiftWeight1 =  SampleCurlyPattern(uv1);\n    float interpWeight = fract(intIdx);\n    float shiftWeight = mix(shiftWeight0, shiftWeight1, interpWeight);\n    const float INV_MIN_RADIUS = 2.0;\n    float shiftWeightAdjust = smoothstep(0.0, 1.0, r * INV_MIN_RADIUS);\n    r -= wood_curly_distortion_scale * (shiftWeight * shiftWeightAdjust);\n    float thetaNew = atan(p.y, p.x);\n    vec3 pNew = p;\n    pNew.x = r * cos(thetaNew);\n    pNew.y = r * sin(thetaNew);\n    return pNew;\n}\n#endif\nvec3 un2sn(vec3 range)\n{\n    return range * 2.0 - 1.0;\n}\nfloat inoise(vec3 p)\n{\n    vec3 modp = mod(floor(p), 256.0);\n    modp.xy = modp.xy * ONE;\n    vec4 AA = texture2D(perm2DMap, vec2(modp.x, modp.y), 0.0) * 255.0;\n    AA = AA + modp.z;\n    AA = mod(floor(AA), 256.0);\n    AA *= ONE;\n    vec3 gradx1 = un2sn(texture2D(permGradMap,vec2(AA.x,0.0),0.0).xyz);\n    vec3 grady1 = un2sn(texture2D(permGradMap,vec2(AA.y,0.0),0.0).xyz);\n    vec3 gradz1 = un2sn(texture2D(permGradMap,vec2(AA.z,0.0),0.0).xyz);\n    vec3 gradw1 = un2sn(texture2D(permGradMap,vec2(AA.w,0.0),0.0).xyz);\n    vec3 gradx2 = un2sn(texture2D(permGradMap,vec2(AA.x + ONE,0.0),0.0).xyz);\n    vec3 grady2 = un2sn(texture2D(permGradMap,vec2(AA.y + ONE,0.0),0.0).xyz);\n    vec3 gradz2 = un2sn(texture2D(permGradMap,vec2(AA.z + ONE,0.0),0.0).xyz);\n    vec3 gradw2 = un2sn(texture2D(permGradMap,vec2(AA.w + ONE,0.0),0.0).xyz);\n    p -= floor(p);\n    vec3 fadep = p * p * p * (p * (p * 6.0 - 15.0) + 10.0);\n    return mix( mix( mix( dot(gradx1, p ),\n                          dot(gradz1, p + vec3(-1.0, 0.0, 0.0)), fadep.x),\n                     mix( dot(grady1, p + vec3(0.0, -1.0, 0.0)),\n                          dot(gradw1, p + vec3(-1.0, -1.0, 0.0)), fadep.x), fadep.y),\n                mix( mix( dot(gradx2, p + vec3(0.0, 0.0, -1.0)),\n                          dot(gradz2, p + vec3(-1.0, 0.0, -1.0)), fadep.x),\n                     mix( dot(grady2, p + vec3(0.0, -1.0, -1.0)),\n                          dot(gradw2, p + vec3(-1.0, -1.0, -1.0)), fadep.x), fadep.y), fadep.z);\n}\nfloat inoise(float p)\n{\n    float modp = mod(floor(p), 256.0);\n    modp = (modp + 256.0) * ONE;\n    float permx = texture2D(permutationMap, vec2(modp, 0.0), 0.0).r;\n    float gradx = texture2D(gradientMap, vec2(permx, 0.0), 0.0).r*2.0-1.0;\n    float permy = texture2D(permutationMap, vec2(modp + ONE, 0.0), 0.0).r;\n    float grady = texture2D(gradientMap, vec2(permy, 0.0), 0.0).r*2.0-1.0;\n    p -= floor(p);\n    float fadep = p * p * p * (p * (p * 6.0 - 15.0) + 10.0);\n    return mix(gradx * p, grady * (p - 1.0), fadep);\n}\nfloat multiband_inoise(vec3 p, int bands, vec4 w, vec4 f)\n{\n    float noise = 0.0;\n    for(int i = 0; i < 4; ++i)\n    {\n        if (i >= bands) break;\n        noise += GetIndexedValue(w, i) * inoise(p * GetIndexedValue(f, i));\n    }\n    return noise;\n}\nfloat multiband_inoise(float p, int bands, vec4 w, vec4 f)\n{\n    float noise = 0.0;\n    for(int i = 0; i < 4; ++i)\n    {\n        if (i >= bands) break;\n        noise += GetIndexedValue(w, i) * inoise(p * GetIndexedValue(f, i));\n    }\n    return noise;\n}\nvec3 Distort3DCosineRadialDir(vec3 p)\n{\n    float radius = length(p.xy);\n    if (radius < 0.00001) return p;\n    vec2 theta = p.xy / radius;\n    float radiusShift = 0.0;\n    for (int i = 0; i < 4; ++i)\n    {\n        if (i >= wood_fiber_cosine_bands) break;\n        radiusShift += GetIndexedValue(wood_fiber_cosine_weights, i) * cos(p.z * RECIPROCAL_PI2 * GetIndexedValue(wood_fiber_cosine_frequencies, i));\n    }\n    const float MIN_RADIUS = 1.5;\n    float weight = clamp(radius / MIN_RADIUS, 0.0, 1.0);\n    if(weight >= 0.5)\n        weight = weight * weight * (3.0 - (weight + weight));\n    p.xy += theta * radiusShift * weight;\n    return p;\n}\nvec3 Distort3DPerlin(vec3 p)\n{\n    vec3 pAniso = vec3(p.xy, p.z * wood_fiber_perlin_scale_z);\n    p.xy += multiband_inoise(pAniso, wood_fiber_perlin_bands, wood_fiber_perlin_weights, wood_fiber_perlin_frequencies);\n    return p;\n}\nvec3 Distort(vec3 p)\n{\n    if(wood_fiber_cosine_enable)\n        p = Distort3DCosineRadialDir(p);\n    if(wood_fiber_perlin_enable)\n        p = Distort3DPerlin(p);\n    return p;\n}\nfloat DistortRadiusLength(float radiusLength)\n{\n    radiusLength += multiband_inoise(radiusLength, wood_growth_perlin_bands, wood_growth_perlin_weights, wood_growth_perlin_frequencies);\n    if (radiusLength < 0.0) radiusLength = 0.0;\n    return radiusLength;\n}\nfloat ComputeEarlyWoodRatio(float radiusLength)\n{\n    float fraction = mod(radiusLength, wood_ring_thickness) / wood_ring_thickness;\n    if (fraction <= wood_ring_fraction.y)\n       return 1.0;\n    else if(fraction <= wood_ring_fraction.x)\n       return (1.0 - (fraction - wood_ring_fraction.y) / wood_fall_rise.x);\n    else if(fraction <= wood_ring_fraction.w)\n       return 0.0;\n    else\n       return ((fraction - wood_ring_fraction.w) / wood_fall_rise.y);\n}\nvec3 DistortEarlyColor(vec3 earlyColor, float radiusLength)\n{\n    float expValue = 1.0 + multiband_inoise(radiusLength,wood_earlycolor_perlin_bands,wood_earlycolor_perlin_weights,wood_earlycolor_perlin_frequencies);\n    earlyColor = pow(abs(earlyColor), vec3(expValue));\n    return earlyColor;\n}\nvec3 DistortLateColor(vec3 lateColor, float radiusLength)\n{\n    float expValue = 1.0 + multiband_inoise(radiusLength,wood_latecolor_perlin_bands,wood_latecolor_perlin_weights,wood_latecolor_perlin_frequencies);\n    lateColor = pow(abs(lateColor), vec3(expValue));\n    return lateColor;\n}\nvec3 DistortDiffuseColor(vec3 diffAlbedo, vec3 p)\n{\n    p.z *= wood_diffuse_perlin_scale_z;\n    float expValue = 1.0 + multiband_inoise(p, wood_diffuse_perlin_bands, wood_diffuse_perlin_weights, wood_diffuse_perlin_frequencies);\n    diffAlbedo = pow(abs(diffAlbedo), vec3(expValue));\n    return diffAlbedo;\n}\nfloat LayerRoughnessVar(float roughness, float earlyWoodRatio)\n{\n    return earlyWoodRatio * wood_groove_roughness + (1.0 - earlyWoodRatio) * roughness;\n}\nfloat hashword(vec2 k)\n{\n    k = mod(k, vec2(256.0)) * ONE;\n    float a = texture2D(permutationMap, vec2(k.x, 0.0)).x + k.y ;\n    a = texture2D(permutationMap, vec2(a, 0.0)).x ;\n    return a*255.0;\n}\nfloat wyvillsq(float rsq)\n{\n    if (rsq >= 1.0) return 0.0;\n    float tmp = 1.0 - rsq;\n    return tmp*tmp*tmp;\n}\nfloat Weight2DNeighborImpulses(vec3 p, float woodWeight)\n{\n    if(woodWeight <= 0.0) return 0.0;\n    float poreRadius = wood_pore_radius * woodWeight;\n    vec2 left = floor((p.xy - poreRadius) / wood_pore_cell_dim);\n    vec2 right = floor((p.xy + poreRadius) / wood_pore_cell_dim);\n    float weight = 0.0;\n    float invRsq = 1.0 / (poreRadius * poreRadius);\n    const float norm =  1.0 / 15.0;\n    for (int j = 0; j <= 4; j++)\n    {\n        if (j > int(right.y - left.y)) continue;\n        for (int i = 0; i <= 4; i++)\n        {\n            if (i > int(right.x - left.x)) continue;\n            vec2 pij = vec2(float(i) + left.x,float(j) + left.y);\n            float hRNum = hashword(pij);\n            float impPosX = mod(hRNum, 16.0) * norm;\n            float impPosY = floor(hRNum / 16.0) * norm;\n            impPosX = (pij.x + impPosX)* wood_pore_cell_dim;\n            impPosY = (pij.y + impPosY)* wood_pore_cell_dim;\n            float dsq = (p.x - impPosX) * (p.x - impPosX) + (p.y - impPosY) * (p.y - impPosY);\n            weight += wyvillsq(dsq * invRsq);\n        }\n    }\n    return weight;\n}\nfloat Weight3DRayImpulses(vec3 p)\n{\n    int segIdx = int(floor(p.z / wood_ray_seg_length_z));\n    float factor = p.z / wood_ray_seg_length_z - float(segIdx);\n    int segIdx1 = segIdx - 1;\n    if ( factor > 0.5 )\n        segIdx1 = segIdx + 1;\n    float theta = atan(p.y, p.x);\n    float sliceIdx = floor(((theta + PI) * RECIPROCAL_PI2) * wood_ray_num_slices);\n    if ( sliceIdx == wood_ray_num_slices)\n        sliceIdx-=1.0;\n    ivec2 arrSegs = ivec2(segIdx, segIdx1);\n    float weight = 0.0;\n    const float norm =  1.0 / 15.0;\n    float radialOffset = 5.0;\n    float radialLength = length(p.xy);\n    for (int seg = 0; seg < 2; seg++)\n    {\n        float hRNum = hashword(vec2(sliceIdx, GetIndexedValue(arrSegs, seg)));\n        float rn1 = mod(hRNum,16.0) * norm;\n        if (radialLength < radialOffset * rn1)\n            continue;\n        float rayTheta = rn1;\n        rayTheta = ( ( sliceIdx + rayTheta ) / wood_ray_num_slices ) * ( 2.0 * PI ) - PI;\n        float rayPosZ = (hRNum/16.0)* norm;\n        rayPosZ = ( float(GetIndexedValue(arrSegs, seg)) + rayPosZ ) * wood_ray_seg_length_z;\n        vec3 pt1 = vec3(0.0);\n        vec3 pt2 = vec3(cos(rayTheta), sin(rayTheta), 0.0);\n        vec3 p1 = p;\n        p1.z -= rayPosZ;\n        p1.z /=  wood_ray_ellipse_z2x;\n        vec3 v1 = pt2 - pt1;\n        vec3 v2 = pt1 - p1;\n        v2 = cross(v1, v2);\n        float dist = length(v2) / length(v1);\n        float invRsq = 1.0 / ( wood_ray_ellipse_radius_x * wood_ray_ellipse_radius_x);\n        weight += wyvillsq( (dist * dist) * invRsq );\n    }\n    return weight;\n}\nvec3 DarkenColorWithPores(vec3 p, vec3 diffColor, float woodWeight)\n{\n    float poresWeight = Weight2DNeighborImpulses(p, woodWeight);\n    float a = wood_pore_color_power - 1.0;\n    float b = 1.0;\n    float y = a * poresWeight + b;\n    return pow(abs(diffColor), vec3(y));\n}\nvec3 DarkenColorWithRays(vec3 p, vec3 diffColor)\n{\n    float raysWeight = Weight3DRayImpulses(p);\n    float a = wood_ray_color_power - 1.0;\n    float b = 1.0;\n    float y = a * raysWeight + b;\n    return pow(abs(diffColor), vec3(y));\n}\nfloat ComputeWoodWeight(float earlyWoodRatio)\n{\n    float woodWeight = 0.0;\n    if (wood_pore_type == 0)\n        woodWeight = 1.0;\n    else if (wood_pore_type == 1)\n        woodWeight = earlyWoodRatio;\n    else if (wood_pore_type == 2)\n        woodWeight = 1.0 - earlyWoodRatio;\n    else\n        woodWeight = -1.0;\n    return woodWeight;\n}\n#if defined( PRISMWOODBUMP )\nfloat ComputeEarlyWoodRatioAA(float radiusLength, float invUnitExt)\n{\n    float transPixels = min(wood_fall_rise.x, wood_fall_rise.y) * wood_ring_thickness * invUnitExt;\n    float samplesf = clamp(4.0 / transPixels, 1.0, 4.0);\n    int samples = int(samplesf);\n    float inverseSamples = 1.0 / float(samples);\n    vec2 rdelta = vec2(dFdx(radiusLength), dFdy(radiusLength)) * inverseSamples;\n    float earlywoodRatio = 0.0;\n    for (int i = 0; i < 4; ++i)\n    {\n        if (i >= samples) break;\n        for (int j = 0; j < 4; ++j)\n        {\n            if (j >= samples) break;\n            float r = radiusLength + dot(vec2(i, j), rdelta);\n            earlywoodRatio += ComputeEarlyWoodRatio(r);\n        }\n    }\n    return earlywoodRatio * (inverseSamples * inverseSamples);\n}\nfloat LatewoodDepthVariation(float invUnitExt)\n{\n    float transPixels = min(wood_fall_rise.x, wood_fall_rise.y) * wood_ring_thickness * invUnitExt;\n    return clamp(transPixels * 0.5, 0.0, 1.0);\n}\nfloat LatewoodHeightVariation(float earlyWoodRatio, float latewoodBumpDepth,\n                              float depthVar)\n{\n    return ( 1.0 - earlyWoodRatio ) * latewoodBumpDepth * depthVar;\n}\nfloat PoreDepthVariation(float woodWeight, float invUnitExt)\n{\n    float porePixels = woodWeight * wood_pore_radius * invUnitExt;\n    return clamp(porePixels, 0.0, 1.0);\n}\nfloat PoreHeightVariation(float earlyWoodRatio, float poresWeight, float poreDepth,\n                          float depthVar)\n{\n    return poresWeight * (-1.0 * poreDepth) * depthVar;\n}\nvoid ComputeTangents(vec3 normal, out vec3 u, out vec3 v)\n{\n    float scale = normal.z < 0.0 ? -1.0 : 1.0;\n    vec3 temp = scale * normal;\n    float e    = temp.z;\n    float h    = 1.0/(1.0 + e);\n    float hvx  = h   *  temp.y;\n    float hvxy = hvx * -temp.x;\n    u = vec3(e + hvx * temp.y, hvxy,                -temp.x);\n    v = vec3(hvxy,             e + h * temp.x * temp.x, -temp.y);\n    u *= scale;\n    v *= scale;\n}\nvec3 WoodBumpHeight(float heightLeft, float heightRight, float heightBack, float heightFront)\n{\n    const float epsilon = 0.001;\n    float heightDeltaX = heightRight - heightLeft;\n    vec3 Tu = vec3(2.0 * epsilon, 0.0, heightDeltaX);\n    float heightDeltaY = heightFront - heightBack;\n    vec3 Tv = vec3(0.0, 2.0 * epsilon, heightDeltaY);\n    return cross(Tu, Tv);\n}\nvec3 SelectNormal(vec3 N, vec3 bumpN, vec3 V)\n{\n    float bumpNdotV = dot(bumpN, V);\n    if(bumpNdotV > 0.0)\n        return bumpN;\n    else return N;\n}\nfloat MinInverseUnitExtent(vec3 p)\n{\n    return 1.0 / max(max(length(dFdx(p.xy)), length(dFdy(p.xy))), 0.000001);\n}\nfloat HeightVariation(vec3 pos)\n{\n    vec3 p = Distort(pos);\n    float radiusLength = length(p.xy);\n    if (wood_growth_perlin_enable)\n        radiusLength = DistortRadiusLength(radiusLength);\n    float invUnitExt = MinInverseUnitExtent(p);\n    float earlyWoodRatio = ComputeEarlyWoodRatioAA(radiusLength, invUnitExt);\n    float woodWeight = ComputeWoodWeight(earlyWoodRatio);\n    float poresWeight = Weight2DNeighborImpulses(p, woodWeight);\n    float depthVar = PoreDepthVariation(woodWeight, invUnitExt);\n    float poreHeightVariation = -1.0 * poresWeight * wood_pore_depth * depthVar;\n    float latewoodHeightVariation = 0.0;\n    if (wood_use_latewood_bump)\n    {\n        float latewoodDepthVar = LatewoodDepthVariation(invUnitExt);\n        latewoodHeightVariation = (1.0 - earlyWoodRatio) * wood_latewood_bump_depth * latewoodDepthVar;\n    }\n    float sumHeightVariation = poreHeightVariation + latewoodHeightVariation;\n    return sumHeightVariation;\n}\n#endif\nvec3 NoiseWood(vec3 p, inout float roughness)\n{\n    p = Distort(p);\n    float radiusLength = length(p.xy);\n    if(wood_growth_perlin_enable)\n        radiusLength = DistortRadiusLength(radiusLength);\n#if defined( PRISMWOODBUMP )\n    float invUnitExt = MinInverseUnitExtent( p );\n    float earlyWoodRatio = ComputeEarlyWoodRatioAA(radiusLength, invUnitExt);\n#else\n    float earlyWoodRatio = ComputeEarlyWoodRatio(radiusLength);\n#endif\n    vec3 earlyColor = wood_early_color;\n    if (wood_earlycolor_perlin_enable)\n        earlyColor = DistortEarlyColor(earlyColor, radiusLength);\n    vec3 lateColor;\n    if (wood_use_manual_late_color)\n        lateColor = wood_manual_late_color;\n    else\n        lateColor = pow(abs(earlyColor), vec3(wood_late_color_power));\n    if(wood_latecolor_perlin_enable)\n        lateColor = DistortLateColor(lateColor, radiusLength);\n    vec3 diffAlbedo = earlyWoodRatio * earlyColor + (1.0 - earlyWoodRatio) * lateColor;\n    if(wood_diffuse_perlin_enable)\n        diffAlbedo = DistortDiffuseColor(diffAlbedo, p);\n    if (wood_use_pores)\n    {\n        float woodWeight = ComputeWoodWeight(earlyWoodRatio);\n        diffAlbedo = DarkenColorWithPores(p, diffAlbedo, woodWeight);\n    }\n    if (wood_use_rays)\n        diffAlbedo = DarkenColorWithRays(p, diffAlbedo);\n    if(wood_use_groove_roughness)\n        roughness = LayerRoughnessVar(roughness, earlyWoodRatio);\n    return clamp(diffAlbedo, vec3(0.0), vec3(1.0));\n}\n#if defined(PRISMWOODBUMP)\nvoid getFinalWoodContext(\n    inout vec3 N, vec3 V, inout vec3 Tu, inout vec3 Tv, vec3 p,\n    vec3 geoNormal, vec3 tNormal, mat3 normalMatrix\n) {\n    vec3 offsetTuLeft = p - 0.001 * Tu;\n    vec3 offsetTuRight = p + 0.001 * Tu;\n    vec3 offsetTvLeft = p - 0.001 * Tv;\n    vec3 offsetTvRight = p + 0.001 * Tv;\n    float heightVariationTuLeft = HeightVariation(offsetTuLeft);\n    float heightVariationTuRight = HeightVariation(offsetTuRight);\n    float heightVariationTvLeft = HeightVariation(offsetTvLeft);\n    float heightVariationTvRight = HeightVariation(offsetTvRight);\n    vec3 bumpHeight = WoodBumpHeight(heightVariationTuLeft, heightVariationTuRight, heightVariationTvLeft, heightVariationTvRight);\n    vec3 newNormal = normalize(bumpHeight.x * Tu + bumpHeight.y * Tv + bumpHeight.z * vtNormal);\n    vec3 newNormalView = normalize(vNormalMatrix * newNormal);\n    vec3 selectedNormal = SelectNormal(geoNormal, newNormalView, V);\n    ComputeTangents(selectedNormal, Tu, Tv);\n    Tu = normalize(Tu);\n    Tv = normalize(Tv);\n    N = faceforward(selectedNormal, -V, selectedNormal);\n}\n#endif\n#endif\n";

/***/ }),

/***/ "./src/wgs/render/chunks/shadowmap_decl_common.glsl":
/*!**********************************************************!*\
  !*** ./src/wgs/render/chunks/shadowmap_decl_common.glsl ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "\nuniform float shadowESMConstant;\nuniform float shadowMapRangeMin;\nuniform float shadowMapRangeSize;\n";

/***/ }),

/***/ "./src/wgs/render/chunks/shadowmap_decl_frag.glsl":
/*!********************************************************!*\
  !*** ./src/wgs/render/chunks/shadowmap_decl_frag.glsl ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "\n#ifdef USE_SHADOWMAP\nuniform sampler2D shadowMap;\nuniform vec2      shadowMapSize;\nuniform float     shadowDarkness;\nuniform float     shadowBias;\nuniform vec3      shadowLightDir;\nvarying vec4 vShadowCoord;\n#include<shadowmap_decl_common>\nfloat getShadowValue() {\n    float fDepth;\n    vec3 shadowColor = vec3( 1.0 );\n    vec3 shadowCoord = vShadowCoord.xyz / vShadowCoord.w;\n    shadowCoord.xyz = 0.5 * (shadowCoord.xyz + vec3(1.0, 1.0, 1.0));\n    bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n    bool inFrustum = all( inFrustumVec );\n    float shadowValue = 1.0;\n    if (inFrustum) {\n        shadowCoord.z = min(0.999, shadowCoord.z);\n        shadowCoord.z -= shadowBias;\n#ifdef USE_HARD_SHADOWS\n        vec4 rgbaDepth = texture2D( shadowMap, shadowCoord.xy );\n        float fDepth = rgbaDepth.r;\n        if ( fDepth < shadowCoord.z ) {\n            shadowValue = 1.0 - shadowDarkness;\n        }\n#else\n        vec4 rgbaDepth = texture2D( shadowMap, shadowCoord.xy );\n        float shadowMapValue = rgbaDepth.r;\n        shadowValue = exp(-shadowESMConstant * shadowCoord.z) * shadowMapValue;\n        shadowValue = min(shadowValue, 1.0);\n        shadowValue = mix(1.0 - shadowDarkness, 1.0, shadowValue);\n#endif\n    }\n    return shadowValue;\n}\n#else\nfloat getShadowValue() { return 1.0; }\n#endif\nvec3 applyEnvShadow(vec3 colorWithoutShadow, vec3 worldNormal) {\n#if defined(USE_SHADOWMAP)\n    float dp  = dot(shadowLightDir, worldNormal);\n    float dpValue = (dp + 1.0) / 2.0;\n    dpValue = min(1.0, dpValue * 1.5);\n    float sv = getShadowValue();\n    vec3 result = colorWithoutShadow * min(sv, dpValue);\n    return result;\n#else\n    return colorWithoutShadow;\n#endif\n}\n";

/***/ }),

/***/ "./src/wgs/render/chunks/shadowmap_decl_vert.glsl":
/*!********************************************************!*\
  !*** ./src/wgs/render/chunks/shadowmap_decl_vert.glsl ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "\n#ifdef USE_SHADOWMAP\nvarying vec4 vShadowCoord;\nuniform mat4 shadowMatrix;\n#endif\n";

/***/ }),

/***/ "./src/wgs/render/chunks/shadowmap_vert.glsl":
/*!***************************************************!*\
  !*** ./src/wgs/render/chunks/shadowmap_vert.glsl ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "\n#ifdef USE_SHADOWMAP\n{\n    vec4 worldPosition = modelMatrix * vec4( position, 1.0 );\n    vShadowCoord = shadowMatrix * worldPosition;\n}\n#endif\n";

/***/ }),

/***/ "./src/wgs/render/chunks/theming_decl_frag.glsl":
/*!******************************************************!*\
  !*** ./src/wgs/render/chunks/theming_decl_frag.glsl ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "uniform vec4 themingColor;\n";

/***/ }),

/***/ "./src/wgs/render/chunks/theming_frag.glsl":
/*!*************************************************!*\
  !*** ./src/wgs/render/chunks/theming_frag.glsl ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "gl_FragColor.rgb = mix(gl_FragColor.rgb, themingColor.rgb, themingColor.a);\n";

/***/ }),

/***/ "./src/wgs/render/chunks/tonemap.glsl":
/*!********************************************!*\
  !*** ./src/wgs/render/chunks/tonemap.glsl ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "\nfloat luminance_post(vec3 rgb) {\n    return dot(rgb, vec3(0.299, 0.587, 0.114));\n}\nfloat luminance_pre(vec3 rgb) {\n    return dot(rgb, vec3(0.212671, 0.715160, 0.072169));\n}\nvec3 xyz2rgb(vec3 xyz) {\n    vec3 R = vec3( 3.240479, -1.537150, -0.498535);\n    vec3 G = vec3(-0.969256,  1.875992,  0.041556);\n    vec3 B = vec3( 0.055648, -0.204043,  1.057311);\n    vec3 rgb;\n    rgb.b = dot(xyz, B);\n    rgb.g = dot(xyz, G);\n    rgb.r = dot(xyz, R);\n    return rgb;\n}\nvec3 rgb2xyz(vec3 rgb) {\n    vec3 X = vec3(0.412453, 0.35758, 0.180423);\n    vec3 Y = vec3(0.212671, 0.71516, 0.0721688);\n    vec3 Z = vec3(0.0193338, 0.119194, 0.950227);\n    vec3 xyz;\n    xyz.x = dot(rgb, X);\n    xyz.y = dot(rgb, Y);\n    xyz.z = dot(rgb, Z);\n    return xyz;\n}\nvec3 xyz2xyY(vec3 xyz) {\n    float sum = xyz.x + xyz.y + xyz.z;\n    sum = 1.0 / sum;\n    vec3 xyY;\n    xyY.z = xyz.y;\n    xyY.x = xyz.x * sum;\n    xyY.y = xyz.y * sum;\n    return xyY;\n}\nvec3 xyY2xyz(vec3 xyY) {\n    float x = xyY.x;\n    float y = xyY.y;\n    float Y = xyY.z;\n    vec3 xyz;\n    xyz.y = Y;\n    xyz.x = x * (Y / y);\n    xyz.z = (1.0 - x - y) * (Y / y);\n    return xyz;\n}\nfloat toneMapCanon_T(float x)\n{\n    float xpow = pow(x, 1.60525727);\n    float tmp = ((1.05542877*4.68037409)*xpow) / (4.68037409*xpow + 1.0);\n    return clamp(tmp, 0.0, 1.0);\n}\nconst float Shift = 1.0 / 0.18;\nfloat toneMapCanonFilmic_NoGamma(float x) {\n    x *= Shift;\n    const float A = 0.2;\n    const float B = 0.34;\n    const float C = 0.002;\n    const float D = 1.68;\n    const float E = 0.0005;\n    const float F = 0.252;\n    const float scale = 1.0/0.833837;\n    return (((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F))-E/F) * scale;\n}\nvec3 toneMapCanonFilmic_WithGamma(vec3 x) {\n    x *= Shift;\n    const float A = 0.27;\n    const float B = 0.29;\n    const float C = 0.052;\n    const float D = 0.2;\n    const float F = 0.18;\n    const float scale = 1.0/0.897105;\n    return (((x*(A*x+C*B))/(x*(A*x+B)+D*F))) * scale;\n}\nvec3 toneMapCanonOGS_WithGamma_WithColorPerserving(vec3 x) {\n    vec3 outColor = x.rgb;\n    outColor = min(outColor, vec3(3.0));\n    float inLum = luminance_pre(outColor);\n    if (inLum > 0.0) {\n        float outLum = toneMapCanon_T(inLum);\n        outColor = outColor * (outLum / inLum);\n        outColor = clamp(outColor, vec3(0.0), vec3(1.0));\n    }\n    float gamma = 1.0/2.2;\n    outColor = pow(outColor, vec3(gamma));\n    return outColor;\n}\n";

/***/ }),

/***/ "./src/wgs/render/chunks/wide_lines_decl.glsl":
/*!****************************************************!*\
  !*** ./src/wgs/render/chunks/wide_lines_decl.glsl ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "\n#ifdef WIDE_LINES\nattribute vec3 prev;\nattribute vec3 next;\nattribute float side;\nuniform vec2 view_size;\nvec2 to2d(vec4 i) {\n  return i.xy / i.w;\n}\n#endif\n";

/***/ }),

/***/ "./src/wgs/render/chunks/wide_lines_vert.glsl":
/*!****************************************************!*\
  !*** ./src/wgs/render/chunks/wide_lines_vert.glsl ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "\n#ifdef WIDE_LINES\nvec4 mvpPosition = projectionMatrix * mvPosition; \nmat3 vectorMatrix = mat3(modelViewMatrix);\nvec2 _pos = to2d(mvpPosition) * view_size;\nvec2 _prev = to2d(projectionMatrix * vec4(mvPosition.xyz + vectorMatrix * (prev * 0.01), 1.0)) * view_size;\nvec2 _next = to2d(projectionMatrix * vec4(mvPosition.xyz - vectorMatrix * (next * 0.01), 1.0)) * view_size;\nvec2 dir1 = _pos - _next;\nvec2 dir2 = _prev - _pos;\ndir2 = (length(dir2) > 0.0000001) ? normalize(dir2) : vec2(0.0, 0.0);\ndir1 = (length(dir1) > 0.0000001) ? normalize(dir1) : dir2;\nvec2 dir_sharp = normalize(dir1 + dir2);\nvec2 dir = normalize(dir1 + dir_sharp);\nvec2 offset = vec2(-dir.y, dir.x);\nfloat len = 1.0 / cross(vec3(offset, 0), vec3(dir1, 0)).z;\noffset *= len;\noffset /= view_size;\noffset *= side;\noffset *= mvpPosition.w;\nmvpPosition.xy += offset;\ngl_Position = mvpPosition;\n#endif\n";

/***/ }),

/***/ "./src/wgs/render/shaders/screen_quad_uv_vert.glsl":
/*!*********************************************************!*\
  !*** ./src/wgs/render/shaders/screen_quad_uv_vert.glsl ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "varying vec2 vUv;\nvoid main() {\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}\n";

/***/ }),

/***/ "three":
/*!************************!*\
  !*** external "THREE" ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = THREE;

/***/ })

/******/ });
//# sourceMappingURL=DOF.js.map