/*!
 * LMV v7.52.0
 * 
 * Copyright 2021 Autodesk, Inc.
 * All rights reserved.
 * 
 * This computer source code and related instructions and comments are the
 * unpublished confidential and proprietary information of Autodesk, Inc.
 * and are protected under Federal copyright and state trade secret law.
 * They may not be disclosed to, copied or used by any third party without
 * the prior written consent of Autodesk, Inc.
 * 
 * Autodesk Forge Viewer Usage Limitations:
 * 
 * The Autodesk Forge viewer can only be used to view files generated by
 * Autodesk Forge services. The Autodesk Forge Viewer JavaScript must be
 * delivered from an Autodesk hosted URL.
 */
Autodesk.Extensions.DOF=function(e){var n={};function t(o){if(n[o])return n[o].exports;var i=n[o]={i:o,l:!1,exports:{}};return e[o].call(i.exports,i,i.exports,t),i.l=!0,i.exports}return t.m=e,t.c=n,t.d=function(e,n,o){t.o(e,n)||Object.defineProperty(e,n,{enumerable:!0,get:o})},t.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},t.t=function(e,n){if(1&n&&(e=t(e)),8&n)return e;if(4&n&&"object"==typeof e&&e&&e.__esModule)return e;var o=Object.create(null);if(t.r(o),Object.defineProperty(o,"default",{enumerable:!0,value:e}),2&n&&"string"!=typeof e)for(var i in e)t.d(o,i,function(n){return e[n]}.bind(null,i));return o},t.n=function(e){var n=e&&e.__esModule?function(){return e.default}:function(){return e};return t.d(n,"a",n),n},t.o=function(e,n){return Object.prototype.hasOwnProperty.call(e,n)},t.p="",t(t.s=843)}({0:function(e,n){e.exports=THREE},10:function(e,n){e.exports=function(e){var n=typeof e;return null!=e&&("object"==n||"function"==n)}},11:function(e,n,t){var o=t(19),i="object"==typeof self&&self&&self.Object===Object&&self,a=o||i||Function("return this")();e.exports=a},13:function(e,n,t){var o=t(11).Symbol;e.exports=o},14:function(e,n){e.exports=function(e){return null!=e&&"object"==typeof e}},15:function(e,n,t){var o=t(13),i=t(25),a=t(26),r=o?o.toStringTag:void 0;e.exports=function(e){return null==e?void 0===e?"[object Undefined]":"[object Null]":r&&r in Object(e)?i(e):a(e)}},17:function(e,n,t){var o=t(15),i=t(14);e.exports=function(e){return"symbol"==typeof e||i(e)&&"[object Symbol]"==o(e)}},18:function(e,n,t){var o=t(10),i=t(22),a=t(20),r=Math.max,l=Math.min;e.exports=function(e,n,t){var s,f,d,c,u,p,v=0,h=!1,m=!1,g=!0;if("function"!=typeof e)throw new TypeError("Expected a function");function _(n){var t=s,o=f;return s=f=void 0,v=n,c=e.apply(o,t)}function x(e){return v=e,u=setTimeout(w,n),h?_(e):c}function y(e){var t=e-p;return void 0===p||t>=n||t<0||m&&e-v>=d}function w(){var e=i();if(y(e))return C(e);u=setTimeout(w,function(e){var t=n-(e-p);return m?l(t,d-(e-v)):t}(e))}function C(e){return u=void 0,g&&s?_(e):(s=f=void 0,c)}function D(){var e=i(),t=y(e);if(s=arguments,f=this,p=e,t){if(void 0===u)return x(p);if(m)return clearTimeout(u),u=setTimeout(w,n),_(p)}return void 0===u&&(u=setTimeout(w,n)),c}return n=a(n)||0,o(t)&&(h=!!t.leading,d=(m="maxWait"in t)?r(a(t.maxWait)||0,n):d,g="trailing"in t?!!t.trailing:g),D.cancel=function(){void 0!==u&&clearTimeout(u),v=0,s=p=f=u=void 0},D.flush=function(){return void 0===u?c:C(i())},D}},19:function(e,n,t){(function(n){var t="object"==typeof n&&n&&n.Object===Object&&n;e.exports=t}).call(this,t(7))},20:function(e,n,t){var o=t(23),i=t(10),a=t(17),r=/^[-+]0x[0-9a-f]+$/i,l=/^0b[01]+$/i,s=/^0o[0-7]+$/i,f=parseInt;e.exports=function(e){if("number"==typeof e)return e;if(a(e))return NaN;if(i(e)){var n="function"==typeof e.valueOf?e.valueOf():e;e=i(n)?n+"":n}if("string"!=typeof e)return 0===e?e:+e;e=o(e);var t=l.test(e);return t||s.test(e)?f(e.slice(2),t?2:8):r.test(e)?NaN:+e}},22:function(e,n,t){var o=t(11);e.exports=function(){return o.Date.now()}},23:function(e,n,t){var o=t(24),i=/^\s+/;e.exports=function(e){return e?e.slice(0,o(e)+1).replace(i,""):e}},24:function(e,n){var t=/\s/;e.exports=function(e){for(var n=e.length;n--&&t.test(e.charAt(n)););return n}},25:function(e,n,t){var o=t(13),i=Object.prototype,a=i.hasOwnProperty,r=i.toString,l=o?o.toStringTag:void 0;e.exports=function(e){var n=a.call(e,l),t=e[l];try{e[l]=void 0;var o=!0}catch(e){}var i=r.call(e);return o&&(n?e[l]=t:delete e[l]),i}},26:function(e,n){var t=Object.prototype.toString;e.exports=function(e){return t.call(e)}},318:function(e,n){e.exports="\nvec4 packDepth( const in float depth ) {\n    vec4 enc = vec4(1.0, 255.0, 65025.0, 160581375.0) * depth;\n    enc = fract(enc);\n    enc -= enc.yzww * vec4(1.0/255.0,1.0/255.0,1.0/255.0,0.0);\n    return enc;\n}\nfloat unpackDepth( const in vec4 rgba_depth ) {\n    return dot( rgba_depth, vec4(1.0, 1.0/255.0, 1.0/65025.0, 1.0/160581375.0) );\n}\n"},319:function(e,n){e.exports="\nuniform sampler2D tDepth;\nuniform vec4 projInfo;\nuniform float isOrtho;\nuniform mat4 worldMatrix_mainPass;\nvec3 reconstructCSPosition(vec2 fragCoords, float z) {\n    return vec3((fragCoords * projInfo.xy + projInfo.zw) * mix(z, -1.0, isOrtho), z);\n}\nvec3 reconstructWorldPosition(vec2 fragCoords, vec2 screenUv) {\n    float zCam = texture2D(tDepth, screenUv).z;\n    vec3 csPos = reconstructCSPosition(fragCoords, zCam);\n    return (worldMatrix_mainPass * vec4(csPos, 1.0)).xyz;\n}\n"},320:function(e,n){e.exports="\nfloat luminance_post(vec3 rgb) {\n    return dot(rgb, vec3(0.299, 0.587, 0.114));\n}\nfloat luminance_pre(vec3 rgb) {\n    return dot(rgb, vec3(0.212671, 0.715160, 0.072169));\n}\nvec3 xyz2rgb(vec3 xyz) {\n    vec3 R = vec3( 3.240479, -1.537150, -0.498535);\n    vec3 G = vec3(-0.969256,  1.875992,  0.041556);\n    vec3 B = vec3( 0.055648, -0.204043,  1.057311);\n    vec3 rgb;\n    rgb.b = dot(xyz, B);\n    rgb.g = dot(xyz, G);\n    rgb.r = dot(xyz, R);\n    return rgb;\n}\nvec3 rgb2xyz(vec3 rgb) {\n    vec3 X = vec3(0.412453, 0.35758, 0.180423);\n    vec3 Y = vec3(0.212671, 0.71516, 0.0721688);\n    vec3 Z = vec3(0.0193338, 0.119194, 0.950227);\n    vec3 xyz;\n    xyz.x = dot(rgb, X);\n    xyz.y = dot(rgb, Y);\n    xyz.z = dot(rgb, Z);\n    return xyz;\n}\nvec3 xyz2xyY(vec3 xyz) {\n    float sum = xyz.x + xyz.y + xyz.z;\n    sum = 1.0 / sum;\n    vec3 xyY;\n    xyY.z = xyz.y;\n    xyY.x = xyz.x * sum;\n    xyY.y = xyz.y * sum;\n    return xyY;\n}\nvec3 xyY2xyz(vec3 xyY) {\n    float x = xyY.x;\n    float y = xyY.y;\n    float Y = xyY.z;\n    vec3 xyz;\n    xyz.y = Y;\n    xyz.x = x * (Y / y);\n    xyz.z = (1.0 - x - y) * (Y / y);\n    return xyz;\n}\nfloat toneMapCanon_T(float x)\n{\n    float xpow = pow(x, 1.60525727);\n    float tmp = ((1.05542877*4.68037409)*xpow) / (4.68037409*xpow + 1.0);\n    return clamp(tmp, 0.0, 1.0);\n}\nconst float Shift = 1.0 / 0.18;\nfloat toneMapCanonFilmic_NoGamma(float x) {\n    x *= Shift;\n    const float A = 0.2;\n    const float B = 0.34;\n    const float C = 0.002;\n    const float D = 1.68;\n    const float E = 0.0005;\n    const float F = 0.252;\n    const float scale = 1.0/0.833837;\n    return (((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F))-E/F) * scale;\n}\nvec3 toneMapCanonFilmic_WithGamma(vec3 x) {\n    x *= Shift;\n    const float A = 0.27;\n    const float B = 0.29;\n    const float C = 0.052;\n    const float D = 0.2;\n    const float F = 0.18;\n    const float scale = 1.0/0.897105;\n    return (((x*(A*x+C*B))/(x*(A*x+B)+D*F))) * scale;\n}\nvec3 toneMapCanonOGS_WithGamma_WithColorPerserving(vec3 x) {\n    vec3 outColor = x.rgb;\n    outColor = min(outColor, vec3(3.0));\n    float inLum = luminance_pre(outColor);\n    if (inLum > 0.0) {\n        float outLum = toneMapCanon_T(inLum);\n        outColor = outColor * (outLum / inLum);\n        outColor = clamp(outColor, vec3(0.0), vec3(1.0));\n    }\n    float gamma = 1.0/2.2;\n    outColor = pow(outColor, vec3(gamma));\n    return outColor;\n}\n"},321:function(e,n){e.exports="vec3 orderedDithering(vec3 col) {\n    const vec4 m0 = vec4( 1.0, 13.0,  4.0, 16.0);\n    const vec4 m1 = vec4( 9.0,  5.0, 12.0,  8.0);\n    const vec4 m2 = vec4( 3.0, 15.0,  2.0, 14.0);\n    const vec4 m3 = vec4(11.0,  7.0, 10.0,  6.0);\n    int i = int(mod(float(gl_FragCoord.x), 4.0));\n    int j = int(mod(float(gl_FragCoord.y), 4.0));\n    vec4 biasRow;\n    if      (i==0) biasRow = m0;\n    else if (i==1) biasRow = m1;\n    else if (i==2) biasRow = m2;\n    else           biasRow = m3;\n    float bias;\n    if      (j==0) bias = biasRow.x;\n    else if (j==1) bias = biasRow.y;\n    else if (j==2) bias = biasRow.z;\n    else           bias = biasRow.w;\n    return col + bias / 17.0 / 256.0;\n}\n"},322:function(e,n){e.exports="#if NUM_CUTPLANES > 0\nuniform vec4 cutplanes[NUM_CUTPLANES];\nvoid checkCutPlanes(vec3 worldPosition) {\n    for (int i=0; i<NUM_CUTPLANES; i++) {\n        if (dot(vec4(worldPosition, 1.0), cutplanes[i]) > 0.0) {\n            discard;\n        }\n    }\n}\n#endif\n"},323:function(e,n){e.exports="\n#define kPI 3.14159265358979\nvec2 encodeNormal (vec3 n) {\n    return (vec2(atan(n.y,n.x)/kPI, n.z)+1.0)*0.5;\n}\nvec3 decodeNormal (vec2 enc) {\n    vec2 ang = enc * 2.0 - 1.0;\n    vec2 scth = vec2(sin(ang.x * kPI), cos(ang.x * kPI));\n    vec2 scphi = vec2(sqrt(1.0 - ang.y * ang.y), ang.y);\n    return vec3(scth.y * scphi.x, scth.x * scphi.x, scphi.y);\n}\n"},324:function(e,n){e.exports="#ifdef HATCH_PATTERN\nuniform vec2 hatchParams;\nuniform vec3 hatchTintColor;\nuniform float hatchTintIntensity;\nfloat curveGaussian(float r, float invWidth) {\n    float amt = clamp(r * invWidth, 0.0, 1.0);\n    float exponent = amt * 3.5;\n    return exp(-exponent*exponent);\n}\nvec4 calculateHatchPattern(vec2 hatchParams, vec2 coord, vec4 fragColor, vec3 hatchTintColor, float hatchTintIntensity ) {\n    float hatchSlope = hatchParams.x;\n    float hatchPeriod = hatchParams.y;\n    if (abs(hatchSlope) <= 1.0) {\n        float hatchPhase = coord.y - hatchSlope * coord.x;\n        float dist = abs(mod((hatchPhase), (hatchPeriod)));\n        if (dist < 1.0) {\n            fragColor = vec4(0.0,0.0,0.0,1.0);\n        } else {\n            fragColor.xyz = mix(fragColor.xyz, hatchTintColor, hatchTintIntensity);\n        }\n    } else {\n        float hatchPhase = - coord.y / hatchSlope + coord.x;\n        float dist = abs(mod((hatchPhase), (hatchPeriod)));\n        if (dist < 1.0) {\n            fragColor = vec4(0.0,0.0,0.0,1.0);\n        } else {\n            fragColor.xyz = mix(fragColor.xyz, hatchTintColor, hatchTintIntensity);\n        }\n    }\n    return fragColor;\n}\n#endif\n"},325:function(e,n){e.exports="\nuniform float envRotationSin;\nuniform float envRotationCos;\nvec3 adjustLookupVector(in vec3 lookup) {\n    return vec3(\n            envRotationCos * lookup.x - envRotationSin * lookup.z,\n            lookup.y,\n            envRotationSin * lookup.x + envRotationCos * lookup.z);\n}\nvec3 RGBMDecode(in vec4 vRGBM, in float exposure) {\n    vec3 ret = vRGBM.rgb * (vRGBM.a * 16.0);\n    ret *= ret;\n    ret *= exposure;\n    return ret;\n}\nvec3 GammaDecode(in vec4 vRGBA, in float exposure) {\n    return vRGBA.xyz * vRGBA.xyz * exposure;\n}\nvec3 sampleIrradianceMap(vec3 dirWorld, samplerCube irrMap, float exposure) {\n    vec4 cubeColor4 = textureCube(irrMap, adjustLookupVector(dirWorld));\n#ifdef IRR_GAMMA\n    vec3 indirectDiffuse = GammaDecode(cubeColor4, exposure);\n#elif defined(IRR_RGBM)\n    vec3 indirectDiffuse = RGBMDecode(cubeColor4, exposure);\n#else\n    vec3 indirectDiffuse = cubeColor4.xyz;\n#ifdef GAMMA_INPUT\n    indirectDiffuse.xyz *= indirectDiffuse.xyz;\n#endif\n#endif\n    return indirectDiffuse;\n}\n"},326:function(e,n){e.exports="#ifdef USE_VERTEX_ID\nattribute vec3 id;\nvarying   vec3 vId;\n#endif\n"},327:function(e,n){e.exports="\n#ifdef USE_VERTEX_ID\nvId = id;\n#endif\n"},328:function(e,n){e.exports="#if defined(MRT_NORMALS) || defined(MRT_ID_BUFFER)\n    varying highp float depth;\n#endif\n#if defined(MRT_ID_BUFFER) || defined(ID_COLOR)\n    #ifdef USE_VERTEX_ID\n        varying vec3 vId;\n    #elif defined(LINE_2D_SHADER)\n        varying vec4 dbId;\n    #else\n        uniform vec3 dbId;\n    #endif\n#endif\n#if defined(MRT_ID_BUFFER) || defined(MODEL_COLOR)\n    uniform vec3 modelId;\n#endif\n#ifdef _LMVWEBGL2_\n    #if defined(MRT_NORMALS)\n        layout(location = 1) out vec4 outNormal;\n        #if defined(MRT_ID_BUFFER)\n            layout(location = 2) out vec4 outId;\n            #if defined(MODEL_COLOR)\n                layout(location = 3) out vec4 outModelId;\n            #endif\n        #endif\n    #elif defined(MRT_ID_BUFFER)\n        layout(location = 1) out vec4 outId;\n        #if defined(MODEL_COLOR)\n            layout(location = 2) out vec4 outModelId;\n        #endif\n    #endif\n#else\n    #define gl_FragColor gl_FragData[0]\n    #if defined(MRT_NORMALS)\n        #define outNormal gl_FragData[1]\n        #if defined(MRT_ID_BUFFER)\n            #define outId gl_FragData[2]\n            #if defined(MODEL_COLOR)\n                #define outModelId gl_FragData[3]\n            #endif\n        #endif\n    #elif defined(MRT_ID_BUFFER)\n        #define outId gl_FragData[1]\n        #if defined(MODEL_COLOR)\n            #define outModelId gl_FragData[2]\n        #endif\n    #endif\n#endif"},329:function(e,n){e.exports="\n#if defined(USE_VERTEX_ID) && (defined(MRT_ID_BUFFER) || defined(ID_COLOR))\n    vec3 dbId = vId;\n#endif\n#ifdef MRT_ID_BUFFER\n    #ifndef ENABLE_ID_DISCARD\n        const float writeId = 1.0;\n    #endif\n    outId = vec4(dbId.rgb, writeId);\n    #ifdef MODEL_COLOR\n        outModelId = vec4(modelId.rgb, writeId);\n    #endif\n#elif defined(ID_COLOR)\n    #ifdef ENABLE_ID_DISCARD\n        if (writeId==0.0) {\n            discard;\n        }\n    #endif\n    gl_FragColor = vec4(dbId.rgb, 1.0);\n#elif defined(MODEL_COLOR)\n    #ifdef ENABLE_ID_DISCARD\n        if (writeId==0.0) {\n            discard;\n        }\n    #endif\n    gl_FragColor = vec4(modelId.rgb, 1.0);\n#endif\n"},330:function(e,n){e.exports="#ifdef HATCH_PATTERN\ngl_FragColor = calculateHatchPattern(hatchParams, gl_FragCoord.xy, gl_FragColor, hatchTintColor, hatchTintIntensity);\n#endif\n#ifdef MRT_NORMALS\noutNormal = vec4(geomNormal.x, geomNormal.y, depth, gl_FragColor.a < 1.0 ? 0.0 : 1.0);\n#endif\n#include<id_frag>\n"},331:function(e,n){e.exports="uniform vec4 themingColor;\n"},332:function(e,n){e.exports="gl_FragColor.rgb = mix(gl_FragColor.rgb, themingColor.rgb, themingColor.a);\n"},333:function(e,n){e.exports="\n#ifdef USE_INSTANCING\nattribute vec3 instOffset;\nattribute vec4 instRotation;\nattribute vec3 instScaling;\nvec3 applyQuaternion(vec3 p, vec4 q) {\n    return p + 2.0 * cross(q.xyz, cross(q.xyz, p) + q.w * p);\n}\nvec3 getInstancePos(vec3 pos) {\n    return instOffset + applyQuaternion(instScaling * pos, instRotation);\n}\nvec3 getInstanceNormal(vec3 normal) {\n    return applyQuaternion(normal/instScaling, instRotation);\n}\n#else\nvec3 getInstancePos(vec3 pos)       { return pos;    }\nvec3 getInstanceNormal(vec3 normal) { return normal; }\n#endif\n"},334:function(e,n){e.exports="\nuniform float shadowESMConstant;\nuniform float shadowMapRangeMin;\nuniform float shadowMapRangeSize;\n"},335:function(e,n){e.exports="\n#ifdef USE_SHADOWMAP\nvarying vec4 vShadowCoord;\nuniform mat4 shadowMatrix;\n#endif\n"},336:function(e,n){e.exports="\n#ifdef USE_SHADOWMAP\n{\n    vec4 worldPosition = modelMatrix * vec4( position, 1.0 );\n    vShadowCoord = shadowMatrix * worldPosition;\n}\n#endif\n"},337:function(e,n){e.exports="\n#ifdef USE_SHADOWMAP\nuniform sampler2D shadowMap;\nuniform vec2      shadowMapSize;\nuniform float     shadowDarkness;\nuniform float     shadowBias;\nuniform vec3      shadowLightDir;\nvarying vec4 vShadowCoord;\n#include<shadowmap_decl_common>\nfloat getShadowValue() {\n    float fDepth;\n    vec3 shadowColor = vec3( 1.0 );\n    vec3 shadowCoord = vShadowCoord.xyz / vShadowCoord.w;\n    shadowCoord.xyz = 0.5 * (shadowCoord.xyz + vec3(1.0, 1.0, 1.0));\n    bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n    bool inFrustum = all( inFrustumVec );\n    float shadowValue = 1.0;\n    if (inFrustum) {\n        shadowCoord.z = min(0.999, shadowCoord.z);\n        shadowCoord.z -= shadowBias;\n#ifdef USE_HARD_SHADOWS\n        vec4 rgbaDepth = texture2D( shadowMap, shadowCoord.xy );\n        float fDepth = rgbaDepth.r;\n        if ( fDepth < shadowCoord.z ) {\n            shadowValue = 1.0 - shadowDarkness;\n        }\n#else\n        vec4 rgbaDepth = texture2D( shadowMap, shadowCoord.xy );\n        float shadowMapValue = rgbaDepth.r;\n        shadowValue = exp(-shadowESMConstant * shadowCoord.z) * shadowMapValue;\n        shadowValue = min(shadowValue, 1.0);\n        shadowValue = mix(1.0 - shadowDarkness, 1.0, shadowValue);\n#endif\n    }\n    return shadowValue;\n}\n#else\nfloat getShadowValue() { return 1.0; }\n#endif\nvec3 applyEnvShadow(vec3 colorWithoutShadow, vec3 worldNormal) {\n#if defined(USE_SHADOWMAP)\n    float dp  = dot(shadowLightDir, worldNormal);\n    float dpValue = (dp + 1.0) / 2.0;\n    dpValue = min(1.0, dpValue * 1.5);\n    float sv = getShadowValue();\n    vec3 result = colorWithoutShadow * min(sv, dpValue);\n    return result;\n#else\n    return colorWithoutShadow;\n#endif\n}\n"},338:function(e,n){e.exports="float averageOfFloat3(in vec3 value) { \n    const float oneThird = 1.0 / 3.0; \n    return dot(value, vec3(oneThird, oneThird, oneThird)); \n} \n"},339:function(e,n){e.exports="\n#define LINE_2D_SHADER 1\n#define TAU     6.28318530718\n#define PI      3.14159265358979\n#define HALF_PI 1.57079632679\n#define PI_0_5  HALF_PI\n#define PI_1_5  4.71238898038\n#define ENABLE_ID_DISCARD\n#define VBB_GT_TRIANGLE_INDEXED  0.0\n#define VBB_GT_LINE_SEGMENT      1.0\n#define VBB_GT_ARC_CIRCULAR      2.0\n#define VBB_GT_ARC_ELLIPTICAL    3.0\n#define VBB_GT_TEX_QUAD          4.0\n#define VBB_GT_ONE_TRIANGLE      5.0\n#define VBB_GT_MSDF_TRIANGLE_INDEXED 6.0\n#define VBB_INSTANCED_FLAG   0.0\n#define VBB_SEG_START_RIGHT  0.0\n#define VBB_SEG_START_LEFT   1.0\n#define VBB_SEG_END_RIGHT    2.0\n#define VBB_SEG_END_LEFT     3.0\n#define LTSCALE 0.25\nvarying vec4 fsColor;\nvarying vec2 fsOffsetDirection;\nvarying vec4 fsMultipurpose;\nvarying float fsHalfWidth;\nvarying vec2 fsVpTC;\nvarying float fsGhosting;\n#ifdef LOADING_ANIMATION\nvarying float loadingProgress;\n#endif\n"},340:function(e,n){e.exports="#if defined( PRISMWOOD )\n#define ONE 0.00390625\nfloat GetIndexedValue(vec4 array, int index)\n{\n    if (index == 0)\n        return array[0];\n    else if (index == 1)\n        return array[1];\n    else if (index == 2)\n        return array[2];\n    else if (index == 3)\n        return array[3];\n    else\n        return 0.0;\n}\nint GetIndexedValue(ivec2 array, int index)\n{\n    if (index == 0)\n        return array[0];\n    else if (index == 1)\n        return array[1];\n    else\n        return 0;\n}\n#if defined( USE_WOOD_CURLY_DISTORTION_MAP )\nfloat SampleCurlyPattern(vec2 uv)\n{\n    vec2 uv_wood_curly_distortion_map = (wood_curly_distortion_map_texMatrix * vec3(uv, 1.0)).xy;\n    WOOD_CURLY_DISTORTION_CLAMP_TEST;\n    vec3 curlyDistortion = texture2D(wood_curly_distortion_map, uv_wood_curly_distortion_map).xyz;\n    if(wood_curly_distortion_map_invert) curlyDistortion = vec3(1.0) - curlyDistortion;\n    return curlyDistortion.r;\n}\nvec3 DistortCurly(vec3 p)\n{\n    if (!wood_curly_distortion_enable) return p;\n    float r = length(p.xy);\n    if (r < 0.00001) return p;\n    const float INV_ANGLE_INTERVAL = 1.27323954;\n    const float NUM_INTERVAL = 8.0;\n    float theta = atan(p.y, p.x);\n    if (theta < 0.0)\n        theta += PI2;\n    float intIdx = theta * INV_ANGLE_INTERVAL;\n    int idx0 = int(mod(floor(intIdx), NUM_INTERVAL));\n    int idx1 = int(mod(ceil(intIdx), NUM_INTERVAL));\n    const vec4 HASH_TABLE1 = vec4(0.450572,0.114598, 0.886043, 0.315119);\n    const vec4 HASH_TABLE2 = vec4(0.216133,0.306264, 0.685616, 0.317907);\n    float offset0 = idx0 < 4 ? GetIndexedValue(HASH_TABLE1, idx0) : GetIndexedValue(HASH_TABLE2, idx0-4);\n    float offset1 = idx1 < 4 ? GetIndexedValue(HASH_TABLE1, idx1) : GetIndexedValue(HASH_TABLE2, idx1-4);\n    const float maxOffset = 100.0;\n    offset0 = (offset0 - 0.5) * maxOffset;\n    offset1 = (offset1 - 0.5) * maxOffset;\n    vec2 uv0 = vec2(p.z + offset0, r);\n    float shiftWeight0 =  SampleCurlyPattern(uv0);\n    vec2 uv1 = vec2(p.z + offset1, r);\n    float shiftWeight1 =  SampleCurlyPattern(uv1);\n    float interpWeight = fract(intIdx);\n    float shiftWeight = mix(shiftWeight0, shiftWeight1, interpWeight);\n    const float INV_MIN_RADIUS = 2.0;\n    float shiftWeightAdjust = smoothstep(0.0, 1.0, r * INV_MIN_RADIUS);\n    r -= wood_curly_distortion_scale * (shiftWeight * shiftWeightAdjust);\n    float thetaNew = atan(p.y, p.x);\n    vec3 pNew = p;\n    pNew.x = r * cos(thetaNew);\n    pNew.y = r * sin(thetaNew);\n    return pNew;\n}\n#endif\nvec3 un2sn(vec3 range)\n{\n    return range * 2.0 - 1.0;\n}\nfloat inoise(vec3 p)\n{\n    vec3 modp = mod(floor(p), 256.0);\n    modp.xy = modp.xy * ONE;\n    vec4 AA = texture2D(perm2DMap, vec2(modp.x, modp.y), 0.0) * 255.0;\n    AA = AA + modp.z;\n    AA = mod(floor(AA), 256.0);\n    AA *= ONE;\n    vec3 gradx1 = un2sn(texture2D(permGradMap,vec2(AA.x,0.0),0.0).xyz);\n    vec3 grady1 = un2sn(texture2D(permGradMap,vec2(AA.y,0.0),0.0).xyz);\n    vec3 gradz1 = un2sn(texture2D(permGradMap,vec2(AA.z,0.0),0.0).xyz);\n    vec3 gradw1 = un2sn(texture2D(permGradMap,vec2(AA.w,0.0),0.0).xyz);\n    vec3 gradx2 = un2sn(texture2D(permGradMap,vec2(AA.x + ONE,0.0),0.0).xyz);\n    vec3 grady2 = un2sn(texture2D(permGradMap,vec2(AA.y + ONE,0.0),0.0).xyz);\n    vec3 gradz2 = un2sn(texture2D(permGradMap,vec2(AA.z + ONE,0.0),0.0).xyz);\n    vec3 gradw2 = un2sn(texture2D(permGradMap,vec2(AA.w + ONE,0.0),0.0).xyz);\n    p -= floor(p);\n    vec3 fadep = p * p * p * (p * (p * 6.0 - 15.0) + 10.0);\n    return mix( mix( mix( dot(gradx1, p ),\n                          dot(gradz1, p + vec3(-1.0, 0.0, 0.0)), fadep.x),\n                     mix( dot(grady1, p + vec3(0.0, -1.0, 0.0)),\n                          dot(gradw1, p + vec3(-1.0, -1.0, 0.0)), fadep.x), fadep.y),\n                mix( mix( dot(gradx2, p + vec3(0.0, 0.0, -1.0)),\n                          dot(gradz2, p + vec3(-1.0, 0.0, -1.0)), fadep.x),\n                     mix( dot(grady2, p + vec3(0.0, -1.0, -1.0)),\n                          dot(gradw2, p + vec3(-1.0, -1.0, -1.0)), fadep.x), fadep.y), fadep.z);\n}\nfloat inoise(float p)\n{\n    float modp = mod(floor(p), 256.0);\n    modp = (modp + 256.0) * ONE;\n    float permx = texture2D(permutationMap, vec2(modp, 0.0), 0.0).r;\n    float gradx = texture2D(gradientMap, vec2(permx, 0.0), 0.0).r*2.0-1.0;\n    float permy = texture2D(permutationMap, vec2(modp + ONE, 0.0), 0.0).r;\n    float grady = texture2D(gradientMap, vec2(permy, 0.0), 0.0).r*2.0-1.0;\n    p -= floor(p);\n    float fadep = p * p * p * (p * (p * 6.0 - 15.0) + 10.0);\n    return mix(gradx * p, grady * (p - 1.0), fadep);\n}\nfloat multiband_inoise(vec3 p, int bands, vec4 w, vec4 f)\n{\n    float noise = 0.0;\n    for(int i = 0; i < 4; ++i)\n    {\n        if (i >= bands) break;\n        noise += GetIndexedValue(w, i) * inoise(p * GetIndexedValue(f, i));\n    }\n    return noise;\n}\nfloat multiband_inoise(float p, int bands, vec4 w, vec4 f)\n{\n    float noise = 0.0;\n    for(int i = 0; i < 4; ++i)\n    {\n        if (i >= bands) break;\n        noise += GetIndexedValue(w, i) * inoise(p * GetIndexedValue(f, i));\n    }\n    return noise;\n}\nvec3 Distort3DCosineRadialDir(vec3 p)\n{\n    float radius = length(p.xy);\n    if (radius < 0.00001) return p;\n    vec2 theta = p.xy / radius;\n    float radiusShift = 0.0;\n    for (int i = 0; i < 4; ++i)\n    {\n        if (i >= wood_fiber_cosine_bands) break;\n        radiusShift += GetIndexedValue(wood_fiber_cosine_weights, i) * cos(p.z * RECIPROCAL_PI2 * GetIndexedValue(wood_fiber_cosine_frequencies, i));\n    }\n    const float MIN_RADIUS = 1.5;\n    float weight = clamp(radius / MIN_RADIUS, 0.0, 1.0);\n    if(weight >= 0.5)\n        weight = weight * weight * (3.0 - (weight + weight));\n    p.xy += theta * radiusShift * weight;\n    return p;\n}\nvec3 Distort3DPerlin(vec3 p)\n{\n    vec3 pAniso = vec3(p.xy, p.z * wood_fiber_perlin_scale_z);\n    p.xy += multiband_inoise(pAniso, wood_fiber_perlin_bands, wood_fiber_perlin_weights, wood_fiber_perlin_frequencies);\n    return p;\n}\nvec3 Distort(vec3 p)\n{\n    if(wood_fiber_cosine_enable)\n        p = Distort3DCosineRadialDir(p);\n    if(wood_fiber_perlin_enable)\n        p = Distort3DPerlin(p);\n    return p;\n}\nfloat DistortRadiusLength(float radiusLength)\n{\n    radiusLength += multiband_inoise(radiusLength, wood_growth_perlin_bands, wood_growth_perlin_weights, wood_growth_perlin_frequencies);\n    if (radiusLength < 0.0) radiusLength = 0.0;\n    return radiusLength;\n}\nfloat ComputeEarlyWoodRatio(float radiusLength)\n{\n    float fraction = mod(radiusLength, wood_ring_thickness) / wood_ring_thickness;\n    if (fraction <= wood_ring_fraction.y)\n       return 1.0;\n    else if(fraction <= wood_ring_fraction.x)\n       return (1.0 - (fraction - wood_ring_fraction.y) / wood_fall_rise.x);\n    else if(fraction <= wood_ring_fraction.w)\n       return 0.0;\n    else\n       return ((fraction - wood_ring_fraction.w) / wood_fall_rise.y);\n}\nvec3 DistortEarlyColor(vec3 earlyColor, float radiusLength)\n{\n    float expValue = 1.0 + multiband_inoise(radiusLength,wood_earlycolor_perlin_bands,wood_earlycolor_perlin_weights,wood_earlycolor_perlin_frequencies);\n    earlyColor = pow(abs(earlyColor), vec3(expValue));\n    return earlyColor;\n}\nvec3 DistortLateColor(vec3 lateColor, float radiusLength)\n{\n    float expValue = 1.0 + multiband_inoise(radiusLength,wood_latecolor_perlin_bands,wood_latecolor_perlin_weights,wood_latecolor_perlin_frequencies);\n    lateColor = pow(abs(lateColor), vec3(expValue));\n    return lateColor;\n}\nvec3 DistortDiffuseColor(vec3 diffAlbedo, vec3 p)\n{\n    p.z *= wood_diffuse_perlin_scale_z;\n    float expValue = 1.0 + multiband_inoise(p, wood_diffuse_perlin_bands, wood_diffuse_perlin_weights, wood_diffuse_perlin_frequencies);\n    diffAlbedo = pow(abs(diffAlbedo), vec3(expValue));\n    return diffAlbedo;\n}\nfloat LayerRoughnessVar(float roughness, float earlyWoodRatio)\n{\n    return earlyWoodRatio * wood_groove_roughness + (1.0 - earlyWoodRatio) * roughness;\n}\nfloat hashword(vec2 k)\n{\n    k = mod(k, vec2(256.0)) * ONE;\n    float a = texture2D(permutationMap, vec2(k.x, 0.0)).x + k.y ;\n    a = texture2D(permutationMap, vec2(a, 0.0)).x ;\n    return a*255.0;\n}\nfloat wyvillsq(float rsq)\n{\n    if (rsq >= 1.0) return 0.0;\n    float tmp = 1.0 - rsq;\n    return tmp*tmp*tmp;\n}\nfloat Weight2DNeighborImpulses(vec3 p, float woodWeight)\n{\n    if(woodWeight <= 0.0) return 0.0;\n    float poreRadius = wood_pore_radius * woodWeight;\n    vec2 left = floor((p.xy - poreRadius) / wood_pore_cell_dim);\n    vec2 right = floor((p.xy + poreRadius) / wood_pore_cell_dim);\n    float weight = 0.0;\n    float invRsq = 1.0 / (poreRadius * poreRadius);\n    const float norm =  1.0 / 15.0;\n    for (int j = 0; j <= 4; j++)\n    {\n        if (j > int(right.y - left.y)) continue;\n        for (int i = 0; i <= 4; i++)\n        {\n            if (i > int(right.x - left.x)) continue;\n            vec2 pij = vec2(float(i) + left.x,float(j) + left.y);\n            float hRNum = hashword(pij);\n            float impPosX = mod(hRNum, 16.0) * norm;\n            float impPosY = floor(hRNum / 16.0) * norm;\n            impPosX = (pij.x + impPosX)* wood_pore_cell_dim;\n            impPosY = (pij.y + impPosY)* wood_pore_cell_dim;\n            float dsq = (p.x - impPosX) * (p.x - impPosX) + (p.y - impPosY) * (p.y - impPosY);\n            weight += wyvillsq(dsq * invRsq);\n        }\n    }\n    return weight;\n}\nfloat Weight3DRayImpulses(vec3 p)\n{\n    int segIdx = int(floor(p.z / wood_ray_seg_length_z));\n    float factor = p.z / wood_ray_seg_length_z - float(segIdx);\n    int segIdx1 = segIdx - 1;\n    if ( factor > 0.5 )\n        segIdx1 = segIdx + 1;\n    float theta = atan(p.y, p.x);\n    float sliceIdx = floor(((theta + PI) * RECIPROCAL_PI2) * wood_ray_num_slices);\n    if ( sliceIdx == wood_ray_num_slices)\n        sliceIdx-=1.0;\n    ivec2 arrSegs = ivec2(segIdx, segIdx1);\n    float weight = 0.0;\n    const float norm =  1.0 / 15.0;\n    float radialOffset = 5.0;\n    float radialLength = length(p.xy);\n    for (int seg = 0; seg < 2; seg++)\n    {\n        float hRNum = hashword(vec2(sliceIdx, GetIndexedValue(arrSegs, seg)));\n        float rn1 = mod(hRNum,16.0) * norm;\n        if (radialLength < radialOffset * rn1)\n            continue;\n        float rayTheta = rn1;\n        rayTheta = ( ( sliceIdx + rayTheta ) / wood_ray_num_slices ) * ( 2.0 * PI ) - PI;\n        float rayPosZ = (hRNum/16.0)* norm;\n        rayPosZ = ( float(GetIndexedValue(arrSegs, seg)) + rayPosZ ) * wood_ray_seg_length_z;\n        vec3 pt1 = vec3(0.0);\n        vec3 pt2 = vec3(cos(rayTheta), sin(rayTheta), 0.0);\n        vec3 p1 = p;\n        p1.z -= rayPosZ;\n        p1.z /=  wood_ray_ellipse_z2x;\n        vec3 v1 = pt2 - pt1;\n        vec3 v2 = pt1 - p1;\n        v2 = cross(v1, v2);\n        float dist = length(v2) / length(v1);\n        float invRsq = 1.0 / ( wood_ray_ellipse_radius_x * wood_ray_ellipse_radius_x);\n        weight += wyvillsq( (dist * dist) * invRsq );\n    }\n    return weight;\n}\nvec3 DarkenColorWithPores(vec3 p, vec3 diffColor, float woodWeight)\n{\n    float poresWeight = Weight2DNeighborImpulses(p, woodWeight);\n    float a = wood_pore_color_power - 1.0;\n    float b = 1.0;\n    float y = a * poresWeight + b;\n    return pow(abs(diffColor), vec3(y));\n}\nvec3 DarkenColorWithRays(vec3 p, vec3 diffColor)\n{\n    float raysWeight = Weight3DRayImpulses(p);\n    float a = wood_ray_color_power - 1.0;\n    float b = 1.0;\n    float y = a * raysWeight + b;\n    return pow(abs(diffColor), vec3(y));\n}\nfloat ComputeWoodWeight(float earlyWoodRatio)\n{\n    float woodWeight = 0.0;\n    if (wood_pore_type == 0)\n        woodWeight = 1.0;\n    else if (wood_pore_type == 1)\n        woodWeight = earlyWoodRatio;\n    else if (wood_pore_type == 2)\n        woodWeight = 1.0 - earlyWoodRatio;\n    else\n        woodWeight = -1.0;\n    return woodWeight;\n}\n#if defined( PRISMWOODBUMP )\nfloat ComputeEarlyWoodRatioAA(float radiusLength, float invUnitExt)\n{\n    float transPixels = min(wood_fall_rise.x, wood_fall_rise.y) * wood_ring_thickness * invUnitExt;\n    float samplesf = clamp(4.0 / transPixels, 1.0, 4.0);\n    int samples = int(samplesf);\n    float inverseSamples = 1.0 / float(samples);\n    vec2 rdelta = vec2(dFdx(radiusLength), dFdy(radiusLength)) * inverseSamples;\n    float earlywoodRatio = 0.0;\n    for (int i = 0; i < 4; ++i)\n    {\n        if (i >= samples) break;\n        for (int j = 0; j < 4; ++j)\n        {\n            if (j >= samples) break;\n            float r = radiusLength + dot(vec2(i, j), rdelta);\n            earlywoodRatio += ComputeEarlyWoodRatio(r);\n        }\n    }\n    return earlywoodRatio * (inverseSamples * inverseSamples);\n}\nfloat LatewoodDepthVariation(float invUnitExt)\n{\n    float transPixels = min(wood_fall_rise.x, wood_fall_rise.y) * wood_ring_thickness * invUnitExt;\n    return clamp(transPixels * 0.5, 0.0, 1.0);\n}\nfloat LatewoodHeightVariation(float earlyWoodRatio, float latewoodBumpDepth,\n                              float depthVar)\n{\n    return ( 1.0 - earlyWoodRatio ) * latewoodBumpDepth * depthVar;\n}\nfloat PoreDepthVariation(float woodWeight, float invUnitExt)\n{\n    float porePixels = woodWeight * wood_pore_radius * invUnitExt;\n    return clamp(porePixels, 0.0, 1.0);\n}\nfloat PoreHeightVariation(float earlyWoodRatio, float poresWeight, float poreDepth,\n                          float depthVar)\n{\n    return poresWeight * (-1.0 * poreDepth) * depthVar;\n}\nvoid ComputeTangents(vec3 normal, out vec3 u, out vec3 v)\n{\n    float scale = normal.z < 0.0 ? -1.0 : 1.0;\n    vec3 temp = scale * normal;\n    float e    = temp.z;\n    float h    = 1.0/(1.0 + e);\n    float hvx  = h   *  temp.y;\n    float hvxy = hvx * -temp.x;\n    u = vec3(e + hvx * temp.y, hvxy,                -temp.x);\n    v = vec3(hvxy,             e + h * temp.x * temp.x, -temp.y);\n    u *= scale;\n    v *= scale;\n}\nvec3 WoodBumpHeight(float heightLeft, float heightRight, float heightBack, float heightFront)\n{\n    const float epsilon = 0.001;\n    float heightDeltaX = heightRight - heightLeft;\n    vec3 Tu = vec3(2.0 * epsilon, 0.0, heightDeltaX);\n    float heightDeltaY = heightFront - heightBack;\n    vec3 Tv = vec3(0.0, 2.0 * epsilon, heightDeltaY);\n    return cross(Tu, Tv);\n}\nvec3 SelectNormal(vec3 N, vec3 bumpN, vec3 V)\n{\n    float bumpNdotV = dot(bumpN, V);\n    if(bumpNdotV > 0.0)\n        return bumpN;\n    else return N;\n}\nfloat MinInverseUnitExtent(vec3 p)\n{\n    return 1.0 / max(max(length(dFdx(p.xy)), length(dFdy(p.xy))), 0.000001);\n}\nfloat HeightVariation(vec3 pos)\n{\n    vec3 p = Distort(pos);\n    float radiusLength = length(p.xy);\n    if (wood_growth_perlin_enable)\n        radiusLength = DistortRadiusLength(radiusLength);\n    float invUnitExt = MinInverseUnitExtent(p);\n    float earlyWoodRatio = ComputeEarlyWoodRatioAA(radiusLength, invUnitExt);\n    float woodWeight = ComputeWoodWeight(earlyWoodRatio);\n    float poresWeight = Weight2DNeighborImpulses(p, woodWeight);\n    float depthVar = PoreDepthVariation(woodWeight, invUnitExt);\n    float poreHeightVariation = -1.0 * poresWeight * wood_pore_depth * depthVar;\n    float latewoodHeightVariation = 0.0;\n    if (wood_use_latewood_bump)\n    {\n        float latewoodDepthVar = LatewoodDepthVariation(invUnitExt);\n        latewoodHeightVariation = (1.0 - earlyWoodRatio) * wood_latewood_bump_depth * latewoodDepthVar;\n    }\n    float sumHeightVariation = poreHeightVariation + latewoodHeightVariation;\n    return sumHeightVariation;\n}\n#endif\nvec3 NoiseWood(vec3 p, inout float roughness)\n{\n    p = Distort(p);\n    float radiusLength = length(p.xy);\n    if(wood_growth_perlin_enable)\n        radiusLength = DistortRadiusLength(radiusLength);\n#if defined( PRISMWOODBUMP )\n    float invUnitExt = MinInverseUnitExtent( p );\n    float earlyWoodRatio = ComputeEarlyWoodRatioAA(radiusLength, invUnitExt);\n#else\n    float earlyWoodRatio = ComputeEarlyWoodRatio(radiusLength);\n#endif\n    vec3 earlyColor = wood_early_color;\n    if (wood_earlycolor_perlin_enable)\n        earlyColor = DistortEarlyColor(earlyColor, radiusLength);\n    vec3 lateColor;\n    if (wood_use_manual_late_color)\n        lateColor = wood_manual_late_color;\n    else\n        lateColor = pow(abs(earlyColor), vec3(wood_late_color_power));\n    if(wood_latecolor_perlin_enable)\n        lateColor = DistortLateColor(lateColor, radiusLength);\n    vec3 diffAlbedo = earlyWoodRatio * earlyColor + (1.0 - earlyWoodRatio) * lateColor;\n    if(wood_diffuse_perlin_enable)\n        diffAlbedo = DistortDiffuseColor(diffAlbedo, p);\n    if (wood_use_pores)\n    {\n        float woodWeight = ComputeWoodWeight(earlyWoodRatio);\n        diffAlbedo = DarkenColorWithPores(p, diffAlbedo, woodWeight);\n    }\n    if (wood_use_rays)\n        diffAlbedo = DarkenColorWithRays(p, diffAlbedo);\n    if(wood_use_groove_roughness)\n        roughness = LayerRoughnessVar(roughness, earlyWoodRatio);\n    return clamp(diffAlbedo, vec3(0.0), vec3(1.0));\n}\n#if defined(PRISMWOODBUMP)\nvoid getFinalWoodContext(\n    inout vec3 N, vec3 V, inout vec3 Tu, inout vec3 Tv, vec3 p,\n    vec3 geoNormal, vec3 tNormal, mat3 normalMatrix\n) {\n    vec3 offsetTuLeft = p - 0.001 * Tu;\n    vec3 offsetTuRight = p + 0.001 * Tu;\n    vec3 offsetTvLeft = p - 0.001 * Tv;\n    vec3 offsetTvRight = p + 0.001 * Tv;\n    float heightVariationTuLeft = HeightVariation(offsetTuLeft);\n    float heightVariationTuRight = HeightVariation(offsetTuRight);\n    float heightVariationTvLeft = HeightVariation(offsetTvLeft);\n    float heightVariationTvRight = HeightVariation(offsetTvRight);\n    vec3 bumpHeight = WoodBumpHeight(heightVariationTuLeft, heightVariationTuRight, heightVariationTvLeft, heightVariationTvRight);\n    vec3 newNormal = normalize(bumpHeight.x * Tu + bumpHeight.y * Tv + bumpHeight.z * vtNormal);\n    vec3 newNormalView = normalize(vNormalMatrix * newNormal);\n    vec3 selectedNormal = SelectNormal(geoNormal, newNormalView, V);\n    ComputeTangents(selectedNormal, Tu, Tv);\n    Tu = normalize(Tu);\n    Tv = normalize(Tv);\n    N = faceforward(selectedNormal, -V, selectedNormal);\n}\n#endif\n#endif\n"},341:function(e,n){e.exports="\nvec3 TransmitAdjust(vec3 transmission, vec3 f0) \n{ \n   vec3 limit = max(1.0 - f0, 0.00001); \n   return clamp(transmission, vec3(0.0, 0.0, 0.0), limit) / limit; \n} \nfloat ColorToIlluminance(in vec3 color) \n{ \n   const vec3 rgb2grey = vec3(0.299, 0.587, 0.114); \n   float illuminance = dot(rgb2grey, color); \n   return illuminance; \n} \nvoid applyPrismGlazingOpacity(\n    inout vec4 color,\n    vec3 transmissionF,\n    float transmissionAlpha,\n    float NdotV,\n    float glazingIlluminace) \n{\n    const float third = 1.0/3.0; \n    float transSurface = exp(-(transmissionAlpha + (transmissionAlpha < 0.0025 ? 0.0 : 0.25)) * NdotV * PI); \n    float opacity = 1.0- dot((1.0 - transmissionF), vec3(third,third,third)) * transSurface * glazingIlluminace; \n    opacity = clamp(opacity, 0.01, 0.99);\n    color.a *= opacity;\n} \n"},342:function(e,n){e.exports="void applyPrismTransparency(\n    inout vec4 color,\n    vec3 transparentColor,\n    float transparentIor\n) {\n    float fsLevel = max(max(color.r, color.g), color.b);\n    color = vec4(color.rgb/fsLevel, fsLevel);\n    float transLevel = min(min(transparentColor.r, transparentColor.g), transparentColor.b);\n    transLevel = min( (1.0 - surface_roughness), transLevel );\n    float transAlpha = (1.0 - transLevel) * 0.4 + surface_roughness * 0.55;\n    vec3 tr_g_color = sqrt(transparentColor);\n    vec4 transColor = vec4(0.5 * vec3(tr_g_color), transAlpha);\n    float strength = 1.0 - (1.0 - fsLevel) * (1.0 - fsLevel);\n    color = mix(transColor, color, strength);\n    color.a = max(color.a, 0.05);\n    if (transparentIor == 1.0 && tr_g_color == vec3(1.0)) {\n        color.a = 0.0;\n    }\n}"},343:function(e,n){e.exports="#if defined(USE_SURFACE_NORMAL_MAP) || defined( USE_LAYERED_NORMAL_MAP ) || defined( USE_TILING_NORMAL )\nvoid heightMapTransform(\n    sampler2D bumpTexture,\n    vec2 uv,\n    mat3 transform,\n    vec2 bumpScale,\n    inout vec3 T,\n    inout vec3 B,\n    inout vec3 N\n) {\n    vec2 st = (transform * vec3(uv, 1.0)).xy;\n    mat3 mtxTangent = mat3(T, B, N);\n    T = normalize(mtxTangent * (transform * vec3(1.0, 0.0, 0.0)));\n    B = normalize(mtxTangent * (transform * vec3(0.0, 1.0, 0.0)));\n    const float oneThird = 1.0 / 3.0;\n    vec3 avg = vec3(oneThird, oneThird, oneThird);\n    vec2 offset = fwidth(st);\n    float h0 = dot(texture2D(bumpTexture, st).xyz, avg);\n    float hx = dot(texture2D(bumpTexture, st + vec2(offset.x, 0.0)).xyz, avg);\n    float hy = dot(texture2D(bumpTexture, st + vec2(0.0, offset.y)).xyz, avg);\n    vec2 diff = vec2(h0 - hx, h0 - hy) / offset;\n    N = normalize(\n        N + (\n            diff.x * T * bumpScale.x +\n            diff.y * B * bumpScale.y\n        )\n    );\n}\nvoid normalMapTransform(\n    sampler2D bumpTexture,\n    vec2 uv,\n    mat3 transform,\n    vec2 bumpScale,\n    inout vec3 T,\n    inout vec3 B,\n    inout vec3 N\n) {\n    vec2 st = (transform * vec3(uv, 1.0)).xy;\n    vec3 mapN =  2.0 * texture2D(bumpTexture, st).xyz - 1.0;\n    mapN.xy *= bumpScale.x;\n    mapN.z *= bumpScale.y;\n    vec3 v = vec3(mapN.y, -mapN.x, 0.0);\n    float c = -mapN.z;\n    mat3 skewV = mat3(\n        0.0, v.z, -v.y,\n        -v.z, 0.0, v.x,\n        v.y, -v.x, 0.0\n    );\n    mat3 rot = mat3(1.0) + skewV + skewV*skewV * 1.0/(1.0-c);\n    N *= rot;\n    T *= rot;\n    B *= rot;\n}\n#endif\n"},344:function(e,n){e.exports="uniform float point_size;"},345:function(e,n){e.exports="gl_PointSize = point_size;"},346:function(e,n){e.exports="\n#ifdef WIDE_LINES\nattribute vec3 prev;\nattribute vec3 next;\nattribute float side;\nuniform vec2 view_size;\nvec2 to2d(vec4 i) {\n  return i.xy / i.w;\n}\n#endif\n"},347:function(e,n){e.exports="\n#ifdef WIDE_LINES\nvec4 mvpPosition = projectionMatrix * mvPosition; \nmat3 vectorMatrix = mat3(modelViewMatrix);\nvec2 _pos = to2d(mvpPosition) * view_size;\nvec2 _prev = to2d(projectionMatrix * vec4(mvPosition.xyz + vectorMatrix * (prev * 0.01), 1.0)) * view_size;\nvec2 _next = to2d(projectionMatrix * vec4(mvPosition.xyz - vectorMatrix * (next * 0.01), 1.0)) * view_size;\nvec2 dir1 = _pos - _next;\nvec2 dir2 = _prev - _pos;\ndir2 = (length(dir2) > 0.0000001) ? normalize(dir2) : vec2(0.0, 0.0);\ndir1 = (length(dir1) > 0.0000001) ? normalize(dir1) : dir2;\nvec2 dir_sharp = normalize(dir1 + dir2);\nvec2 dir = normalize(dir1 + dir_sharp);\nvec2 offset = vec2(-dir.y, dir.x);\nfloat len = 1.0 / cross(vec3(offset, 0), vec3(dir1, 0)).z;\noffset *= len;\noffset /= view_size;\noffset *= side;\noffset *= mvpPosition.w;\nmvpPosition.xy += offset;\ngl_Position = mvpPosition;\n#endif\n"},348:function(e,n){e.exports="vec3 rgb2hsv(vec3 color)\n{\n    float delta;\n    float colorMax, colorMin;\n    float h,s,v;\n    vec3 hsv;\n    colorMax = max(color.r,color.g);\n    colorMax = max(colorMax,color.b);\n    colorMin = min(color.r,color.g);\n    colorMin = min(colorMin,color.b);\n    v = colorMax;\n    if(colorMax != 0.0)\n    {\n        s = (colorMax - colorMin)/colorMax;\n    }\n    else\n    {\n        s = 0.0;\n    }\n    if(s != 0.0)\n    {\n        delta = colorMax-colorMin;\n        if (color.r == colorMax)\n        {\n            h = (color.g-color.b)/delta;\n        }\n        else if (color.g == colorMax)\n        {\n            h = 2.0 + (color.b-color.r) / delta;\n        }\n        else\n        {\n            h = 4.0 + (color.r-color.g)/delta;\n        }\n        h /= 6.0;\n        if( h < 0.0)\n        {\n            h +=1.0;\n        }\n    }\n    else\n    {\n        h = 0.0;\n    }\n    hsv = vec3(h,s,v);\n    return hsv;\n}\nvec3 hsv2rgb(vec3 hsv)\n{\n    vec3 color;\n    float f,p,q,t;\n    float h,s,v;\n    float i,hi;\n    {\n        h = hsv.x*6.0;\n        s = hsv.y;\n        v = hsv.z;\n        i = floor(h);\n        f = h-i;\n        p = v * (1.0 - s);\n        q = v * (1.0 - (s * f));\n        t = v * (1.0 - (s * (1.0 - f)));\n        float r,g,b;\n        if (i == 0.0)\n        {\n            r = v;\n            g = t;\n            b = p;\n        }\n        else if (i == 1.0)\n        {\n            r = q;\n            g = v;\n            b = p;\n        }\n        else if (i == 2.0)\n        {\n            r = p;\n            g = v;\n            b = t;\n        }\n        else if (i == 3.0)\n        {\n            r = p;\n            g = q;\n            b = v;\n        }\n        else if (i == 4.0)\n        {\n            r = t;\n            g = p;\n            b = v;\n        }\n        else\n        {\n            r = v;\n            g = p;\n            b = q;\n        }\n        color = vec3(r,g,b);\n    }\n    return color;\n}"},349:function(e,n){e.exports="varying vec2 vUv;\nvoid main() {\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}\n"},350:function(e,n){e.exports="\nuniform sampler2D tDiffuse;\nvarying vec2 vUv;\nuniform vec2 resolution;\nuniform float fStop;\nuniform float focalLength;\nuniform vec3 cameraPos;\nuniform float unitScale;\nuniform float focalPlane;\nuniform float maxBlur;\n#include<depth_texture>\n#define TAU 6.28318530718\n#define DIRECTIONS 16.\nfloat COC = 0.03;\nvec4 debugFocus(float blur){    \n    vec4 color = texture2D(tDiffuse,vUv);\n    color = mix(color, vec4(0.,0.,0.,1.), min(0.95, blur));\n    return color;\n}\nfloat calculateBlur() {\n    float subjectDistance = focalPlane*1000.;\n    vec3 worldPos = reconstructWorldPosition(gl_FragCoord.xy, vUv);\n    float unitScaleMM = unitScale * 1000.;\n    worldPos *= unitScaleMM;\n    vec3 cameraPosMM = vec3(cameraPos) * unitScaleMM;\n    float pixelDistance = distance(worldPos, cameraPosMM);\n    float hyperfocalDistance = (focalLength * focalLength) / (fStop * COC);\n    float DOFNear = (hyperfocalDistance * subjectDistance) / (hyperfocalDistance + (subjectDistance - focalLength));\n    float DOFFar = (hyperfocalDistance * subjectDistance) / (hyperfocalDistance - (subjectDistance - focalLength));\n    float dist = subjectDistance - pixelDistance;\n    float blur;\n    if (dist > 0.) {\n        if (DOFNear < 0.) {\n            blur = 0.;\n        } else {\n            blur = dist / (subjectDistance - DOFNear);    \n        }\n    } else {\n        if (DOFFar < 0.) {\n            blur = 0.;\n        } else {\n            blur = -dist / (DOFFar - subjectDistance);\n        }\n    }\n    float logScale = log(blur+1.) / log(2.);\n    blur = clamp(0., maxBlur, logScale);\n    return blur;\n}\nvec4 gaussianBlur(float blurAmount) {\n    vec4 color=texture2D(tDiffuse,vUv);\n    float quality = float(BLUR_QUALITY);\n    float radius = 8. * blurAmount;\n    for(float d = 0.; d < DIRECTIONS; d++)\n    {\n        float angle= d * TAU / DIRECTIONS;\n        vec2 angleVec = vec2(cos(angle),sin(angle));\n        for(int i = 1; i <= BLUR_QUALITY; i++)\n        {\n            float distance = radius * (float(i) / quality);\n            color += texture2D(tDiffuse, vUv.xy + angleVec * resolution * distance );\n        }\n    }\n    \n    color /= quality * DIRECTIONS;\n    return color;\n}\nvoid main() {\n    float blur = calculateBlur();\n    #ifdef DEBUG\n    vec4 color = debugFocus(blur);\n    #else\n    vec4 color = gaussianBlur(blur);\n    #endif\n    gl_FragColor = color;\n}\n"},351:function(e){e.exports=JSON.parse('{"@@locale":"en","@@context":"Depth of Field extension","Depth of Field":"Depth of Field","Configuration":"Configuration","Enabled":"Enabled","Focal Length (mm)":"Focal Length (mm)","f-stop (Aperture)":"f-stop (Aperture)","Max Blur":"Max Blur","Blur Quality":"Blur Quality","Focus on Cursor":"Focus on Cursor","Focal Plane":"Focal Plane","Debug DOF":"Debug DOF"}')},47:function(e,n,t){var o=t(18),i=t(10);e.exports=function(e,n,t){var a=!0,r=!0;if("function"!=typeof e)throw new TypeError("Expected a function");return i(t)&&(a="leading"in t?!!t.leading:a,r="trailing"in t?!!t.trailing:r),o(e,n,{leading:a,maxWait:n,trailing:r})}},7:function(e,n){var t;t=function(){return this}();try{t=t||new Function("return this")()}catch(e){"object"==typeof window&&(t=window)}e.exports=t},843:function(e,n,t){"use strict";t.r(n),t.d(n,"DOFExtension",(function(){return je}));var o=t(0),i=t(318),a=t.n(i),r=t(319),l=t.n(r),s=t(320),f=t.n(s),d=t(321),c=t.n(d),u=t(322),p=t.n(u),v=t(323),h=t.n(v),m=t(324),g=t.n(m),_=t(325),x=t.n(_),y=t(326),w=t.n(y),C=t(327),D=t.n(C),b=t(328),E=t.n(b),A=t(329),P=t.n(A),R=t(330),S=t.n(R),T=t(331),M=t.n(T),I=t(332),L=t.n(I),V=t(333),N=t.n(V),U=t(334),F=t.n(U),O=t(335),z=t.n(O),B=t(336),k=t.n(B),W=t(337),G=t.n(W),j=t(338),H=t.n(j),Y=t(339),q=t.n(Y),Q=t(340),X=t.n(Q),Z=t(341),$=t.n(Z),J=t(342),K=t.n(J),ee=t(343),ne=t.n(ee),te=t(344),oe=t.n(te),ie=t(345),ae=t.n(ie),re=t(346),le=t.n(re),se=t(347),fe=t.n(se),de=t(348),ce=t.n(de),ue={cutplanes:{type:"v4v",value:[]},hatchParams:{type:"v2",value:new o.Vector2(1,10)},hatchTintColor:{type:"c",value:new o.Color(16777215)},hatchTintIntensity:{type:"f",value:1}},pe={dbId:{type:"v3",value:new o.Vector3(0,0,0)},modelId:{type:"v3",value:new o.Vector3(0,0,0)}},ve={themingColor:{type:"v4",value:new o.Vector4(0,0,0,0)}},he={shadowESMConstant:{type:"f",value:0}},me=o.UniformsUtils.merge([{shadowMap:{type:"t",value:null},shadowMapSize:{type:"v2",value:new o.Vector2(0,0)},shadowBias:{type:"f",value:0},shadowDarkness:{type:"f",value:0},shadowMatrix:{type:"m4",value:new o.Matrix4},shadowLightDir:{type:"v3",value:new o.Vector3}},he]),ge={view_size:{type:"v2",value:new o.Vector2(640,480)}},_e={tDepth:{type:"t",value:null},projInfo:{type:"v4",value:new o.Vector4},isOrtho:{type:"f",value:0},worldMatrix_mainPass:{type:"m4",value:new o.Matrix4}},xe={tDepthTest:{type:"t",value:null},tDepthResolution:{type:"v2",value:new o.Vector2(1/1024,1/1024)}},ye={};for(var we in o.ShaderChunk)ye[we]=o.ShaderChunk[we];ye.pack_depth=a.a,ye.depth_texture=l.a,ye.tonemap=f.a,ye.ordered_dither=c.a,ye.cutplanes=p.a,ye.pack_normals=h.a,ye.hatch_pattern=g.a,ye.env_sample=x.a,ye.id_decl_vert=w.a,ye.id_vert=D.a,ye.id_decl_frag=E.a,ye.id_frag=P.a,ye.final_frag=S.a,ye.theming_decl_frag=M.a,ye.theming_frag=L.a,ye.instancing_decl_vert=N.a,ye.shadowmap_decl_common=F.a,ye.shadowmap_decl_vert=z.a,ye.shadowmap_vert=k.a,ye.shadowmap_decl_frag=G.a,ye.float3_average=H.a,ye.line_decl_common=q.a,ye.prism_wood=X.a,ye.prism_glazing=$.a,ye.prism_transparency=K.a,ye.normal_map=ne.a,ye.decl_point_size=oe.a,ye.point_size=ae.a,ye.wide_lines_decl=le.a,ye.wide_lines_vert=fe.a,ye.hsv=ce.a;var Ce={};function De(e,n,t,o){var i=t?"_v3":"",a=t?"vec3 ":"",r=t?n+" = average("+n+i+");":"",l=o?n+i+" = SRGBToLinear("+n+i+");":"";return["#if defined( USE_"+e.toUpperCase()+"_MAP )","vec2 uv_"+e+"_map = ("+e+"_map_texMatrix * vec3(uv, 1.0)).xy;",e.toUpperCase()+"_CLAMP_TEST;",a+n+i+" = texture2D("+e+"_map, uv_"+e+"_map).xyz;",l,"if("+e+"_map_invert) "+n+i+" = vec3(1.0) - "+n+i+";",r,"#else",n+" = "+e+";","#endif"].join("\n")}function be(e){var n=e+"_texMatrix",t=e+"_invert";return["#if defined( "+("USE_"+e).toUpperCase()+" )","uniform sampler2D "+e+";","uniform mat3 "+n+";","uniform bool "+t+";","#endif"].join("\n")}Ce.prism_check=function(e){return["#if defined( USE_SURFACE_ALBEDO_MAP ) || defined( USE_SURFACE_ROUGHNESS_MAP ) || defined( USE_SURFACE_CUTOUT_MAP ) || defined( USE_SURFACE_ANISOTROPY_MAP ) || defined( USE_SURFACE_ROTATION_MAP ) || defined( USE_OPAQUE_ALBEDO_MAP ) || defined( USE_OPAQUE_F0_MAP ) || defined( USE_OPAQUE_LUMINANCE_MODIFIER_MAP ) || defined( USE_LAYERED_BOTTOM_F0_MAP ) || defined( USE_LAYERED_F0_MAP ) || defined( USE_LAYERED_DIFFUSE_MAP ) || defined( USE_LAYERED_FRACTION_MAP ) || defined( USE_LAYERED_ROUGHNESS_MAP ) || defined( USE_LAYERED_ANISOTROPY_MAP ) || defined( USE_LAYERED_ROTATION_MAP ) || defined( USE_METAL_F0_MAP ) || defined( USE_SURFACE_NORMAL_MAP ) || defined( USE_LAYERED_NORMAL_MAP )","#define "+e,"#endif"].join("\n")},Ce.prism_sample_texture=function(e,n,t,o){return De(e,n,"true"===t,"true"===o)},Ce.prism_uniforms=be,Ce.prism_bump_uniforms=function(e){var n=e+"_texMatrix",t=e+"_bumpScale",o=e+"_bumpmapType";return["#if defined( "+("USE_"+e).toUpperCase()+" )","uniform sampler2D "+e+";","uniform mat3 "+n+";","uniform vec2 "+t+";","uniform int "+o+";","#endif"].join("\n")};var Ee={};for(we in Ce)Ee[we]=new RegExp("#"+we+" *<([\\w\\d., ]*)>","g");var Ae={IdUniforms:pe,ThemingUniform:ve,CutPlanesUniforms:ue,ShadowMapCommonUniforms:he,ShadowMapUniforms:me,PointSizeUniforms:{point_size:{type:"f",value:1}},WideLinesUniforms:ge,DepthTextureUniforms:_e,DepthTextureTestUniforms:xe,PackDepthShaderChunk:ye.pack_depth,TonemapShaderChunk:ye.tonemap,OrderedDitheringShaderChunk:ye.ordered_dither,CutPlanesShaderChunk:ye.cutplanes,PackNormalsShaderChunk:ye.pack_normals,HatchPatternShaderChunk:ye.hatch_pattern,EnvSamplingShaderChunk:ye.env_sample,IdVertexDeclaration:ye.id_decl_vert,IdVertexShaderChunk:ye.id_vert,IdFragmentDeclaration:ye.id_decl_frag,IdOutputShaderChunk:ye.id_frag,FinalOutputShaderChunk:ye.final_frag,ThemingFragmentDeclaration:ye.theming_decl_frag,ThemingFragmentShaderChunk:ye.theming_frag,InstancingVertexDeclaration:ye.instancing_decl_vert,ShadowMapDeclareCommonUniforms:ye.shadowmap_decl_common,ShadowMapVertexDeclaration:ye.shadowmap_decl_vert,ShadowMapVertexShaderChunk:ye.shadowmap_vert,ShadowMapFragmentDeclaration:ye.shadowmap_decl_frag,PointSizeDeclaration:ye.decl_point_size,PointSizeShaderChunk:ye.point_size,GetPrismMapSampleChunk:De,GetPrismMapUniformChunk:be,resolve:function e(n){for(var t in Ce){var o=Ee[t];n=n.replace(o,(function(e,n){var o=n.split(",").map((function(e){return e.trim()}));return Ce[t].apply(null,o)}))}return n.replace(/#include *<([\w\d.]+)>/g,(function(n,t){if(!ye[t])throw new Error("Cannot resolve #include<"+t+">");return e(ye[t])}))}},Pe=t(349),Re=t.n(Pe),Se=t(350),Te=t.n(Se),Me={uniforms:o.UniformsUtils.merge([Ae.DepthTextureUniforms,{tDiffuse:{type:"t",value:null},resolution:{type:"v2",value:new o.Vector2(1/1024,1/512)},cameraNear:{type:"f",value:1},cameraFar:{type:"f",value:100},fStop:{type:"f",value:22},focalLength:{type:"f",value:100},focalPlane:{type:"f",value:5},unitScale:{type:"f",value:1},maxBlur:{type:"f",value:2},cameraPos:{type:"v3",value:new o.Vector3}}]),vertexShader:Re.a,fragmentShader:Te.a},Ie=Autodesk.Viewing.Private.ShaderPass,Le=Autodesk.Viewing.Private.RenderContextPostProcessExtension,Ve=Autodesk.Viewing,Ne=function(e,n){Le.call(this,e,n),this.getOrder=function(){return 0},this.shouldRenderAfterOverlays=function(){return!0},this.load=function(){this.postProcPass=new Ie(Me),this.renderContext.setNoDepthNoBlend(this.postProcPass)}};(Ne.prototype=Object.create(Le.prototype)).constructor=Ne,Ve.GlobalManagerMixin.call(Ne.prototype);var Ue="configTab",Fe=function(e,n){var t=this,o="adsk_dof_renderoptions_panel_"+e.id;Autodesk.Viewing.UI.SettingsPanel.call(this,e.container,o,"Depth of Field",{heightAdjustment:90,width:500}),this.setGlobalManager(e.globalManager),this.container.classList.add("viewer-settings-panel"),this.viewer=e,this.addTab(Ue,"Configuration",{className:"config"}),this.selectTab(Ue);var i=this.addCheckbox(Ue,"Enabled",!1,(function(e){n.setEnabled(e)}));this.enabledToggle=this.getControl(i);var a=this.addSlider(Ue,"Focal Length (mm)",10,200,10,(function(e){var t=e.detail.value;n.setFocalLength(parseFloat(t))}),{step:1});this.focalLength=this.getControl(a),this.viewer.addEventListener(Autodesk.Viewing.CAMERA_CHANGE_EVENT,(function(){var n=parseFloat(t.focalLength.value),o=e.getFocalLength();n!=o&&t.focalLength.setValue(o)}));var r=this.addSlider(Ue,"f-stop (Aperture)",2,22,1.4,(function(e){var t=e.detail.value;n.setFStop(parseFloat(t))}),{step:.1});this.fStop=this.getControl(r);var l=this.addSlider(Ue,"Max Blur",1,3,2,(function(e){var t=e.detail.value;n.setMaxBlur(parseFloat(t))}),{step:.1});this.maxBlur=this.getControl(l);var s=this.addSlider(Ue,"Blur Quality",1,16,8,(function(e){var t=e.detail.value;n.setBlurQuality(t)}),{step:1});this.blurQuality=this.getControl(s);var f=this.addCheckbox(Ue,"Focus on Cursor",!1,(function(e){n.setUseCursor(e),t.setUseCursor(e)}));this.useCursor=this.getControl(f),this.setUseCursor=function(e){if(t.focalPlane.setDisabled(e),!e){var o=parseFloat(t.focalPlane.value);n.setFocalPlane(o*t.unitsToMeters)}};var d=this.addSlider(Ue,"Focal Plane",.01,50,1,(function(e){var o=e.detail.value;n.setFocalPlane(parseFloat(o)*t.unitsToMeters)}),{step:.1});this.focalPlane=this.getControl(d);var c=function(){var e,o,i,a,r=(null===(e=t.viewer.getExtension("Autodesk.Measure"))||void 0===e?void 0:e.getUnits())||"m",l=Autodesk.Viewing.i18n.translate(Autodesk.Viewing.Private.displayUnits[Autodesk.Viewing.Private.displayUnitsEnum.indexOf(r)]);switch(t.focalPlane.caption.textContent="".concat(Autodesk.Viewing.i18n.translate("Focal Plane")," (").concat(l,")"),r){case"mm":case"pt":o=.001,i=10,a=1;break;case"cm":case"in":case"fractional-in":case"decimal-in":o=.01,i=50,a=.1;break;case"m":case"m-and-cm":case"ft-and-decimal-in":case"ft":case"ft-and-fractional-in":case"decimal-ft":default:o=.05,i=100,a=.01}var s=t.viewer.impl.getVisibleBounds(!0),f=t.viewer.impl.renderer().getUnitScale(),d=s.size(),c=5*Math.max(d.x,d.y,d.z)*f;i=Math.min(c,i),t.unitsToMeters=Autodesk.Viewing.Private.convertUnits(r,"m",1,1);var u=parseFloat((o/t.unitsToMeters).toFixed(3)),p=parseFloat((i/t.unitsToMeters).toFixed(3));t.focalPlane.sliderElement.min=u,t.focalPlane.stepperElement.min=u,t.focalPlane.sliderElement.max=p,t.focalPlane.stepperElement.max=p,t.focalPlane.sliderElement.step=a,n.setFocalPlane(n.getFocalPlane())};c(),this.setFocalPlane=function(e){t.focalPlane.setValue(parseFloat((e/t.unitsToMeters).toFixed(3)))};var u=this.addCheckbox(Ue,"Debug DOF",!1,(function(e){n.setDebug(e)}));this.debug=this.getControl(u),this.viewer.addEventListener(Autodesk.Viewing.MODEL_ROOT_LOADED_EVENT,c),this.viewer.addEventListener(Autodesk.Viewing.MeasureCommon.Events.DISPLAY_UNITS_CHANGED,c),this.destroy=function(){t.viewer.removeEventListener(Autodesk.Viewing.MODEL_ROOT_LOADED_EVENT,c),t.viewer.removeEventListener(Autodesk.Viewing.MeasureCommon.Events.DISPLAY_UNITS_CHANGED,c)}};function Oe(e,n){for(var t=0;t<n.length;t++){var o=n[t];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o)}}(Fe.prototype=Object.create(Autodesk.Viewing.UI.SettingsPanel.prototype)).constructor=Fe;var ze=t(47),Be=Autodesk.Viewing.GlobalManagerMixin,ke=function(){function e(n,t){var o=this;!function(e,n){if(!(e instanceof n))throw new TypeError("Cannot call a class as a function")}(this,e),this.viewer=n,this.dofExtension=t,this.active=!1,this.names=["dof-tool"],this.lastMousePos=new THREE.Vector2,this.onCameraChange=this.onCameraChange.bind(this),this.updateFocalPlaneThrottled=ze((function(e){o.anim&&(o.anim.stop(),o.anim=null);var n=o.dofExtension.getFocalPlane();o.anim=Autodesk.Viewing.Private.fadeValue(n,e,.25,(function(e){o.dofExtension.setFocalPlane(e)}),(function(){o.anim=null}))}),100)}var n,t,o;return n=e,(t=[{key:"getNames",value:function(){return this.names}},{key:"getName",value:function(){return this.names[0]}},{key:"getPriority",value:function(){return 1e3}},{key:"isActive",value:function(){return this.active}},{key:"activate",value:function(){this.isActive()||(this.viewer.addEventListener(Autodesk.Viewing.CAMERA_CHANGE_EVENT,this.onCameraChange),this.active=!0)}},{key:"deactivate",value:function(){this.isActive()&&(this.viewer.removeEventListener(Autodesk.Viewing.CAMERA_CHANGE_EVENT,this.onCameraChange),this.anim&&(this.anim.stop(),this.anim=null),this.active=!1)}},{key:"onCameraChange",value:function(){return this.handleMouseMove({canvasX:this.lastMousePos.x,canvasY:this.lastMousePos.y})}},{key:"handleMouseMove",value:function(e){this.lastMousePos.set(e.canvasX,e.canvasY);var n=this.viewer.impl.snappingHitTest(e.canvasX,e.canvasY),t=this.viewer.getCamera().position,o=null==n?void 0:n.intersectPoint;if(!o)return!1;var i=t.distanceTo(o)*this.viewer.impl.renderer().getUnitScale();return this.updateFocalPlaneThrottled(i),!1}}])&&Oe(n.prototype,t),o&&Oe(n,o),e}();Be.call(ke.prototype);var We={en:t(351)},Ge=Autodesk.Viewing.Extension;function je(e,n){Ge.call(this,e,n),this.openPanel=this.openPanel.bind(this)}je.prototype=Object.create(Autodesk.Viewing.Extension.prototype),je.prototype.constructor=je,je.prototype.load=function(){return this.extendLocalization(We),this.dofRenderContext=new Ne(this.viewer.impl.renderer(),this.viewer),this.dofRenderContext.load(),this.viewer.impl.renderer().postShadingManager().registerPostProcessingExtension(this.dofRenderContext),this.tool=new ke(this.viewer,this),this.viewer.toolController.registerTool(this.tool),this.firstTime=!0,!1!==this.options.createUI&&(this.panel=new Fe(this.viewer,this)),!0},je.prototype.unload=function(){return this.dofRenderContext&&(this.viewer.impl.renderer().postShadingManager().removePostProcessingExtension(this.dofRenderContext),this.viewer.impl.invalidate(!0,!0,!0),this.dofRenderContext=null),this.panel&&(null!==this._configButtonId&&(this.viewer.viewerSettingsPanel.removeConfigButton(this._configButtonId),this._configButtonId=null),this.panel.setVisible(!1),this.panel.destroy(),this.panel=null),!0},je.prototype.getInitialFocalPlane=function(e){var n=parseFloat(Autodesk.Viewing.Private.getParameterByName("focalPlane"))||this.options.focalPlane;if(n)return n;var t=this.viewer.getCamera(),o=t.target.clone().sub(t.position).normalize(),i=this.viewer.impl.rayIntersect(new THREE.Ray(t.position,o));if(i){var a=this.viewer.impl.renderer().getUnitScale();return i.distance*a}return 2},je.prototype.loadDefaultValues=function(){var e=parseFloat(Autodesk.Viewing.Private.getParameterByName("focalLength"))||this.options.focalLength||this.getFocalLength(),n=parseFloat(Autodesk.Viewing.Private.getParameterByName("fStop"))||this.options.fStop||8,t=parseFloat(Autodesk.Viewing.Private.getParameterByName("maxBlur"))||this.options.maxBlur||2,o=parseFloat(Autodesk.Viewing.Private.getParameterByName("blurQuality"))||this.options.blurQuality||8,i=this.getInitialFocalPlane(),a="true"===Autodesk.Viewing.Private.getParameterByName("blurUseCursor")||this.options.blurUseCursor||!1,r="true"===Autodesk.Viewing.Private.getParameterByName("blurDebug")||this.options.blurDebug||!1;this.setFocalLength(e),this.setFStop(n),this.setMaxBlur(t),this.setBlurQuality(o),this.setFocalPlane(i),this.setUseCursor(a),this.setDebug(r)},je.prototype.onToolbarCreated=function(){this.panel&&this._initButtonConfig()},je.prototype._initButtonConfig=function(){var e=this.viewer.getSettingsPanel();e?this._configButtonId=e.addConfigButton("Depth of Field",this.openPanel):this.addEventListener(Autodesk.Viewing.SETTINGSpanel_CREATED_EVENT,this._initButtonConfig,{once:!0})},je.prototype.openPanel=function(){var e;this.setEnabled(!0),null===(e=this.panel)||void 0===e||e.setVisible(!0)},je.prototype.activate=function(){var e;this.isActive()||(this.firstTime&&(this.firstTime=!1,this.viewer.navigation.toPerspective(),this.loadDefaultValues()),this.dofRenderContext.enable(),this.useCursor&&!this.viewer.toolController.isToolActivated(this.tool.getName())&&this.viewer.toolController.activateTool(this.tool.getName()),null===(e=this.panel)||void 0===e||e.enabledToggle.setValue(!0),this.activeStatus=!0)},je.prototype.deactivate=function(){var e;this.isActive()&&(this.dofRenderContext.disable(),this.useCursor&&this.viewer.toolController.isToolActivated(this.tool.getName())&&this.viewer.toolController.deactivateTool(this.tool.getName()),null===(e=this.panel)||void 0===e||e.enabledToggle.setValue(!1),this.activeStatus=!1)},je.prototype.setEnabled=function(e){e?this.activate():this.deactivate()},je.prototype.getUseCursor=function(){return this.useCursor},je.prototype.setUseCursor=function(e){var n;this.useCursor=e,e?this.viewer.toolController.activateTool(this.tool.getName()):this.viewer.toolController.deactivateTool(this.tool.getName()),null===(n=this.panel)||void 0===n||n.setUseCursor(e)},je.prototype.getDebug=function(){return this.dofRenderContext.getDefineValue("DEBUG")},je.prototype.setDebug=function(e){var n;this.dofRenderContext.updateDefineValue("DEBUG",!!e||null),null===(n=this.panel)||void 0===n||n.debug.setValue(e)},je.prototype.getFStop=function(){return this.dofRenderContext.getUniformValue("fStop")},je.prototype.setFStop=function(e){var n;this.dofRenderContext.updateUniformValue("fStop",e),null===(n=this.panel)||void 0===n||n.fStop.setValue(e)},je.prototype.getFocalPlane=function(){return this.dofRenderContext.getUniformValue("focalPlane")},je.prototype.setFocalPlane=function(e){var n;this.dofRenderContext.updateUniformValue("focalPlane",e),null===(n=this.panel)||void 0===n||n.setFocalPlane(e)},je.prototype.getMaxBlur=function(){return this.dofRenderContext.getUniformValue("maxBlur")},je.prototype.setMaxBlur=function(e){var n;this.dofRenderContext.updateUniformValue("maxBlur",e),null===(n=this.panel)||void 0===n||n.maxBlur.setValue(e)},je.prototype.getFocalLength=function(){return Autodesk.Viewing.Navigation.prototype.fov2fl(this.viewer.getCamera().fov)},je.prototype.setFocalLength=function(e){this.viewer.setFocalLength(e)},je.prototype.getBlurQuality=function(){return this.dofRenderContext.getDefineValue("BLUR_QUALITY")},je.prototype.setBlurQuality=function(e){var n;this.dofRenderContext.updateDefineValue("BLUR_QUALITY",e),null===(n=this.panel)||void 0===n||n.blurQuality.setValue(e)},Autodesk.Viewing.theExtensionManager.registerExtension("Autodesk.DOF",je)}});
//# sourceMappingURL=DOF.min.js.map