{"version":3,"sources":["webpack://Autodesk.Extensions.[name]/webpack/bootstrap","webpack://Autodesk.Extensions.[name]/external \"THREE\"","webpack://Autodesk.Extensions.[name]/./node_modules/lodash/isObject.js","webpack://Autodesk.Extensions.[name]/./node_modules/lodash/_root.js","webpack://Autodesk.Extensions.[name]/./node_modules/lodash/_Symbol.js","webpack://Autodesk.Extensions.[name]/./node_modules/lodash/isObjectLike.js","webpack://Autodesk.Extensions.[name]/./node_modules/lodash/_baseGetTag.js","webpack://Autodesk.Extensions.[name]/./node_modules/lodash/isSymbol.js","webpack://Autodesk.Extensions.[name]/./node_modules/lodash/debounce.js","webpack://Autodesk.Extensions.[name]/./node_modules/lodash/_freeGlobal.js","webpack://Autodesk.Extensions.[name]/./node_modules/lodash/toNumber.js","webpack://Autodesk.Extensions.[name]/./node_modules/lodash/now.js","webpack://Autodesk.Extensions.[name]/./node_modules/lodash/_baseTrim.js","webpack://Autodesk.Extensions.[name]/./node_modules/lodash/_trimmedEndIndex.js","webpack://Autodesk.Extensions.[name]/./node_modules/lodash/_getRawTag.js","webpack://Autodesk.Extensions.[name]/./node_modules/lodash/_objectToString.js","webpack://Autodesk.Extensions.[name]/./src/wgs/render/chunks/pack_depth.glsl","webpack://Autodesk.Extensions.[name]/./src/wgs/render/chunks/depth_texture.glsl","webpack://Autodesk.Extensions.[name]/./src/wgs/render/chunks/tonemap.glsl","webpack://Autodesk.Extensions.[name]/./src/wgs/render/chunks/ordered_dither.glsl","webpack://Autodesk.Extensions.[name]/./src/wgs/render/chunks/cutplanes.glsl","webpack://Autodesk.Extensions.[name]/./src/wgs/render/chunks/pack_normals.glsl","webpack://Autodesk.Extensions.[name]/./src/wgs/render/chunks/hatch_pattern.glsl","webpack://Autodesk.Extensions.[name]/./src/wgs/render/chunks/env_sample.glsl","webpack://Autodesk.Extensions.[name]/./src/wgs/render/chunks/id_decl_vert.glsl","webpack://Autodesk.Extensions.[name]/./src/wgs/render/chunks/id_vert.glsl","webpack://Autodesk.Extensions.[name]/./src/wgs/render/chunks/id_decl_frag.glsl","webpack://Autodesk.Extensions.[name]/./src/wgs/render/chunks/id_frag.glsl","webpack://Autodesk.Extensions.[name]/./src/wgs/render/chunks/final_frag.glsl","webpack://Autodesk.Extensions.[name]/./src/wgs/render/chunks/theming_decl_frag.glsl","webpack://Autodesk.Extensions.[name]/./src/wgs/render/chunks/theming_frag.glsl","webpack://Autodesk.Extensions.[name]/./src/wgs/render/chunks/instancing_decl_vert.glsl","webpack://Autodesk.Extensions.[name]/./src/wgs/render/chunks/shadowmap_decl_common.glsl","webpack://Autodesk.Extensions.[name]/./src/wgs/render/chunks/shadowmap_decl_vert.glsl","webpack://Autodesk.Extensions.[name]/./src/wgs/render/chunks/shadowmap_vert.glsl","webpack://Autodesk.Extensions.[name]/./src/wgs/render/chunks/shadowmap_decl_frag.glsl","webpack://Autodesk.Extensions.[name]/./src/wgs/render/chunks/float3_average.glsl","webpack://Autodesk.Extensions.[name]/./src/wgs/render/chunks/line_decl_common.glsl","webpack://Autodesk.Extensions.[name]/./src/wgs/render/chunks/prism_wood.glsl","webpack://Autodesk.Extensions.[name]/./src/wgs/render/chunks/prism_glazing.glsl","webpack://Autodesk.Extensions.[name]/./src/wgs/render/chunks/prism_transparency.glsl","webpack://Autodesk.Extensions.[name]/./src/wgs/render/chunks/normal_map.glsl","webpack://Autodesk.Extensions.[name]/./src/wgs/render/chunks/decl_point_size.glsl","webpack://Autodesk.Extensions.[name]/./src/wgs/render/chunks/point_size.glsl","webpack://Autodesk.Extensions.[name]/./src/wgs/render/chunks/wide_lines_decl.glsl","webpack://Autodesk.Extensions.[name]/./src/wgs/render/chunks/wide_lines_vert.glsl","webpack://Autodesk.Extensions.[name]/./src/wgs/render/chunks/hsv.glsl","webpack://Autodesk.Extensions.[name]/./src/wgs/render/shaders/screen_quad_uv_vert.glsl","webpack://Autodesk.Extensions.[name]/./extensions/DOF/Shader/dof_frag.glsl","webpack://Autodesk.Extensions.[name]/./node_modules/lodash/throttle.js","webpack://Autodesk.Extensions.[name]/(webpack)/buildin/global.js","webpack://Autodesk.Extensions.[name]/./src/wgs/render/ShaderChunks.js","webpack://Autodesk.Extensions.[name]/./extensions/DOF/DOFShader.js","webpack://Autodesk.Extensions.[name]/./extensions/DOF/DOFRenderContext.js","webpack://Autodesk.Extensions.[name]/./extensions/DOF/DOFRenderOptionsPanel.js","webpack://Autodesk.Extensions.[name]/./extensions/DOF/DOFTool.js","webpack://Autodesk.Extensions.[name]/./extensions/DOF/DOFLocales.js","webpack://Autodesk.Extensions.[name]/./extensions/DOF/DOFExtension.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","THREE","type","freeGlobal","freeSelf","self","root","Function","getRawTag","objectToString","symToStringTag","undefined","baseGetTag","isObjectLike","isObject","now","toNumber","nativeMax","Math","max","nativeMin","min","func","wait","options","lastArgs","lastThis","maxWait","result","timerId","lastCallTime","lastInvokeTime","leading","maxing","trailing","TypeError","invokeFunc","time","args","thisArg","apply","leadingEdge","setTimeout","timerExpired","shouldInvoke","timeSinceLastCall","trailingEdge","timeWaiting","remainingWait","debounced","isInvoking","arguments","this","clearTimeout","cancel","flush","global","baseTrim","isSymbol","reIsBadHex","reIsBinary","reIsOctal","freeParseInt","parseInt","other","valueOf","isBinary","test","slice","Date","trimmedEndIndex","reTrimStart","string","replace","reWhitespace","index","length","charAt","objectProto","nativeObjectToString","toString","isOwn","tag","unmasked","e","debounce","g","window","CutPlanesUniforms","IdUniforms","ThemingUniform","ShadowMapCommonUniforms","ShadowMapUniforms","merge","WideLinesUniforms","DepthTextureUniforms","DepthTextureTestUniforms","chunks","pack_depth","depth_texture","tonemap","ordered_dither","cutplanes","pack_normals","hatch_pattern","env_sample","id_decl_vert","id_vert","id_decl_frag","id_frag","final_frag","theming_decl_frag","theming_frag","instancing_decl_vert","shadowmap_decl_common","shadowmap_decl_vert","shadowmap_vert","shadowmap_decl_frag","float3_average","line_decl_common","prism_wood","prism_glazing","prism_transparency","normal_map","decl_point_size","point_size","wide_lines_decl","wide_lines_vert","hsv","macros","GetPrismMapSampleChunk","mapType","variableName","isFloat","linearize","suffix","declare","average","colorLinearization","toUpperCase","join","GetPrismMapUniformChunk","mapName","mtxName","mapInvt","flag","varName","mapScale","_regExCache","RegExp","ShaderChunks","PointSizeUniforms","PackDepthShaderChunk","TonemapShaderChunk","OrderedDitheringShaderChunk","CutPlanesShaderChunk","PackNormalsShaderChunk","HatchPatternShaderChunk","EnvSamplingShaderChunk","IdVertexDeclaration","IdVertexShaderChunk","IdFragmentDeclaration","IdOutputShaderChunk","FinalOutputShaderChunk","ThemingFragmentDeclaration","ThemingFragmentShaderChunk","InstancingVertexDeclaration","ShadowMapDeclareCommonUniforms","ShadowMapVertexDeclaration","ShadowMapVertexShaderChunk","ShadowMapFragmentDeclaration","PointSizeDeclaration","PointSizeShaderChunk","resolve","source","re","match","parens","params","split","map","param","trim","include","Error","DOFShader","uniforms","tDiffuse","resolution","cameraNear","cameraFar","fStop","focalLength","focalPlane","unitScale","maxBlur","cameraPos","vertexShader","screen_quad_uv_vert","fragmentShader","dofFrag","ShaderPass","Autodesk","Viewing","Private","RenderContextPostProcessExtension","av","DOFRenderContext","renderContext","viewer","getOrder","shouldRenderAfterOverlays","load","postProcPass","setNoDepthNoBlend","constructor","GlobalManagerMixin","TAB_ID","DOFRenderOptionsPanel","dofExtension","PANEL_ID","id","UI","SettingsPanel","container","heightAdjustment","width","setGlobalManager","globalManager","classList","add","addTab","className","selectTab","enabledToggleId","addCheckbox","checked","setEnabled","enabledToggle","getControl","focalLengthId","addSlider","event","detail","setFocalLength","parseFloat","step","addEventListener","CAMERA_CHANGE_EVENT","myFocalLength","camFocalLength","getFocalLength","setValue","fStopId","setFStop","maxBlurId","setMaxBlur","blurSizeId","setBlurQuality","blurQuality","useCursor","setUseCursor","setDisabled","setFocalPlane","unitsToMeters","focalPlaneId","updateFocalPlaneRange","minInMeters","maxInMeters","units","getExtension","getUnits","unitsString","i18n","translate","displayUnits","displayUnitsEnum","indexOf","caption","textContent","bounds","impl","getVisibleBounds","toMeters","renderer","getUnitScale","size","maxModelBounds","x","y","z","convertUnits","toFixed","sliderElement","stepperElement","getFocalPlane","debug","setDebug","MODEL_ROOT_LOADED_EVENT","MeasureCommon","Events","DISPLAY_UNITS_CHANGED","destroy","removeEventListener","throttle","require","DOFTool","active","names","lastMousePos","Vector2","onCameraChange","updateFocalPlaneThrottled","targetFocalPlane","anim","stop","startValue","fadeValue","isActive","handleMouseMove","canvasX","canvasY","set","snappingHitTest","getCamera","position","target","intersectPoint","distanceTo","locales","en","Extension","DOFExtension","openPanel","extendLocalization","dofRenderContext","postShadingManager","registerPostProcessingExtension","tool","toolController","registerTool","firstTime","createUI","panel","unload","removePostProcessingExtension","invalidate","_configButtonId","viewerSettingsPanel","removeConfigButton","setVisible","getInitialFocalPlane","customDistance","getParameterByName","camera","eyeVec","clone","sub","normalize","hit","rayIntersect","Ray","distance","loadDefaultValues","defaultFocalLength","defaultFstop","defaultMaxBlur","defaultBlurQuality","defaultFocalPlane","defaultUseCursor","blurUseCursor","defaultDebug","blurDebug","onToolbarCreated","_initButtonConfig","settingsPanel","getSettingsPanel","addConfigButton","SETTINGSpanel_CREATED_EVENT","once","activate","navigation","toPerspective","enable","isToolActivated","getName","activateTool","activeStatus","deactivate","disable","deactivateTool","getUseCursor","getDebug","getDefineValue","updateDefineValue","getFStop","getUniformValue","updateUniformValue","getMaxBlur","Navigation","fov2fl","fov","getBlurQuality","theExtensionManager","registerExtension"],"mappings":"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","file":"DOF/DOF.min.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 843);\n","module.exports = THREE;","/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return value != null && (type == 'object' || type == 'function');\n}\n\nmodule.exports = isObject;\n","var freeGlobal = require('./_freeGlobal');\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\nmodule.exports = root;\n","var root = require('./_root');\n\n/** Built-in value references. */\nvar Symbol = root.Symbol;\n\nmodule.exports = Symbol;\n","/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return value != null && typeof value == 'object';\n}\n\nmodule.exports = isObjectLike;\n","var Symbol = require('./_Symbol'),\n    getRawTag = require('./_getRawTag'),\n    objectToString = require('./_objectToString');\n\n/** `Object#toString` result references. */\nvar nullTag = '[object Null]',\n    undefinedTag = '[object Undefined]';\n\n/** Built-in value references. */\nvar symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n/**\n * The base implementation of `getTag` without fallbacks for buggy environments.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nfunction baseGetTag(value) {\n  if (value == null) {\n    return value === undefined ? undefinedTag : nullTag;\n  }\n  return (symToStringTag && symToStringTag in Object(value))\n    ? getRawTag(value)\n    : objectToString(value);\n}\n\nmodule.exports = baseGetTag;\n","var baseGetTag = require('./_baseGetTag'),\n    isObjectLike = require('./isObjectLike');\n\n/** `Object#toString` result references. */\nvar symbolTag = '[object Symbol]';\n\n/**\n * Checks if `value` is classified as a `Symbol` primitive or object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n * @example\n *\n * _.isSymbol(Symbol.iterator);\n * // => true\n *\n * _.isSymbol('abc');\n * // => false\n */\nfunction isSymbol(value) {\n  return typeof value == 'symbol' ||\n    (isObjectLike(value) && baseGetTag(value) == symbolTag);\n}\n\nmodule.exports = isSymbol;\n","var isObject = require('./isObject'),\n    now = require('./now'),\n    toNumber = require('./toNumber');\n\n/** Error message constants. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeMax = Math.max,\n    nativeMin = Math.min;\n\n/**\n * Creates a debounced function that delays invoking `func` until after `wait`\n * milliseconds have elapsed since the last time the debounced function was\n * invoked. The debounced function comes with a `cancel` method to cancel\n * delayed `func` invocations and a `flush` method to immediately invoke them.\n * Provide `options` to indicate whether `func` should be invoked on the\n * leading and/or trailing edge of the `wait` timeout. The `func` is invoked\n * with the last arguments provided to the debounced function. Subsequent\n * calls to the debounced function return the result of the last `func`\n * invocation.\n *\n * **Note:** If `leading` and `trailing` options are `true`, `func` is\n * invoked on the trailing edge of the timeout only if the debounced function\n * is invoked more than once during the `wait` timeout.\n *\n * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\n * until to the next tick, similar to `setTimeout` with a timeout of `0`.\n *\n * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\n * for details over the differences between `_.debounce` and `_.throttle`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to debounce.\n * @param {number} [wait=0] The number of milliseconds to delay.\n * @param {Object} [options={}] The options object.\n * @param {boolean} [options.leading=false]\n *  Specify invoking on the leading edge of the timeout.\n * @param {number} [options.maxWait]\n *  The maximum time `func` is allowed to be delayed before it's invoked.\n * @param {boolean} [options.trailing=true]\n *  Specify invoking on the trailing edge of the timeout.\n * @returns {Function} Returns the new debounced function.\n * @example\n *\n * // Avoid costly calculations while the window size is in flux.\n * jQuery(window).on('resize', _.debounce(calculateLayout, 150));\n *\n * // Invoke `sendMail` when clicked, debouncing subsequent calls.\n * jQuery(element).on('click', _.debounce(sendMail, 300, {\n *   'leading': true,\n *   'trailing': false\n * }));\n *\n * // Ensure `batchLog` is invoked once after 1 second of debounced calls.\n * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });\n * var source = new EventSource('/stream');\n * jQuery(source).on('message', debounced);\n *\n * // Cancel the trailing debounced invocation.\n * jQuery(window).on('popstate', debounced.cancel);\n */\nfunction debounce(func, wait, options) {\n  var lastArgs,\n      lastThis,\n      maxWait,\n      result,\n      timerId,\n      lastCallTime,\n      lastInvokeTime = 0,\n      leading = false,\n      maxing = false,\n      trailing = true;\n\n  if (typeof func != 'function') {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  wait = toNumber(wait) || 0;\n  if (isObject(options)) {\n    leading = !!options.leading;\n    maxing = 'maxWait' in options;\n    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;\n    trailing = 'trailing' in options ? !!options.trailing : trailing;\n  }\n\n  function invokeFunc(time) {\n    var args = lastArgs,\n        thisArg = lastThis;\n\n    lastArgs = lastThis = undefined;\n    lastInvokeTime = time;\n    result = func.apply(thisArg, args);\n    return result;\n  }\n\n  function leadingEdge(time) {\n    // Reset any `maxWait` timer.\n    lastInvokeTime = time;\n    // Start the timer for the trailing edge.\n    timerId = setTimeout(timerExpired, wait);\n    // Invoke the leading edge.\n    return leading ? invokeFunc(time) : result;\n  }\n\n  function remainingWait(time) {\n    var timeSinceLastCall = time - lastCallTime,\n        timeSinceLastInvoke = time - lastInvokeTime,\n        timeWaiting = wait - timeSinceLastCall;\n\n    return maxing\n      ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke)\n      : timeWaiting;\n  }\n\n  function shouldInvoke(time) {\n    var timeSinceLastCall = time - lastCallTime,\n        timeSinceLastInvoke = time - lastInvokeTime;\n\n    // Either this is the first call, activity has stopped and we're at the\n    // trailing edge, the system time has gone backwards and we're treating\n    // it as the trailing edge, or we've hit the `maxWait` limit.\n    return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||\n      (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));\n  }\n\n  function timerExpired() {\n    var time = now();\n    if (shouldInvoke(time)) {\n      return trailingEdge(time);\n    }\n    // Restart the timer.\n    timerId = setTimeout(timerExpired, remainingWait(time));\n  }\n\n  function trailingEdge(time) {\n    timerId = undefined;\n\n    // Only invoke if we have `lastArgs` which means `func` has been\n    // debounced at least once.\n    if (trailing && lastArgs) {\n      return invokeFunc(time);\n    }\n    lastArgs = lastThis = undefined;\n    return result;\n  }\n\n  function cancel() {\n    if (timerId !== undefined) {\n      clearTimeout(timerId);\n    }\n    lastInvokeTime = 0;\n    lastArgs = lastCallTime = lastThis = timerId = undefined;\n  }\n\n  function flush() {\n    return timerId === undefined ? result : trailingEdge(now());\n  }\n\n  function debounced() {\n    var time = now(),\n        isInvoking = shouldInvoke(time);\n\n    lastArgs = arguments;\n    lastThis = this;\n    lastCallTime = time;\n\n    if (isInvoking) {\n      if (timerId === undefined) {\n        return leadingEdge(lastCallTime);\n      }\n      if (maxing) {\n        // Handle invocations in a tight loop.\n        clearTimeout(timerId);\n        timerId = setTimeout(timerExpired, wait);\n        return invokeFunc(lastCallTime);\n      }\n    }\n    if (timerId === undefined) {\n      timerId = setTimeout(timerExpired, wait);\n    }\n    return result;\n  }\n  debounced.cancel = cancel;\n  debounced.flush = flush;\n  return debounced;\n}\n\nmodule.exports = debounce;\n","/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\nmodule.exports = freeGlobal;\n","var baseTrim = require('./_baseTrim'),\n    isObject = require('./isObject'),\n    isSymbol = require('./isSymbol');\n\n/** Used as references for various `Number` constants. */\nvar NAN = 0 / 0;\n\n/** Used to detect bad signed hexadecimal string values. */\nvar reIsBadHex = /^[-+]0x[0-9a-f]+$/i;\n\n/** Used to detect binary string values. */\nvar reIsBinary = /^0b[01]+$/i;\n\n/** Used to detect octal string values. */\nvar reIsOctal = /^0o[0-7]+$/i;\n\n/** Built-in method references without a dependency on `root`. */\nvar freeParseInt = parseInt;\n\n/**\n * Converts `value` to a number.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to process.\n * @returns {number} Returns the number.\n * @example\n *\n * _.toNumber(3.2);\n * // => 3.2\n *\n * _.toNumber(Number.MIN_VALUE);\n * // => 5e-324\n *\n * _.toNumber(Infinity);\n * // => Infinity\n *\n * _.toNumber('3.2');\n * // => 3.2\n */\nfunction toNumber(value) {\n  if (typeof value == 'number') {\n    return value;\n  }\n  if (isSymbol(value)) {\n    return NAN;\n  }\n  if (isObject(value)) {\n    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;\n    value = isObject(other) ? (other + '') : other;\n  }\n  if (typeof value != 'string') {\n    return value === 0 ? value : +value;\n  }\n  value = baseTrim(value);\n  var isBinary = reIsBinary.test(value);\n  return (isBinary || reIsOctal.test(value))\n    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)\n    : (reIsBadHex.test(value) ? NAN : +value);\n}\n\nmodule.exports = toNumber;\n","var root = require('./_root');\n\n/**\n * Gets the timestamp of the number of milliseconds that have elapsed since\n * the Unix epoch (1 January 1970 00:00:00 UTC).\n *\n * @static\n * @memberOf _\n * @since 2.4.0\n * @category Date\n * @returns {number} Returns the timestamp.\n * @example\n *\n * _.defer(function(stamp) {\n *   console.log(_.now() - stamp);\n * }, _.now());\n * // => Logs the number of milliseconds it took for the deferred invocation.\n */\nvar now = function() {\n  return root.Date.now();\n};\n\nmodule.exports = now;\n","var trimmedEndIndex = require('./_trimmedEndIndex');\n\n/** Used to match leading whitespace. */\nvar reTrimStart = /^\\s+/;\n\n/**\n * The base implementation of `_.trim`.\n *\n * @private\n * @param {string} string The string to trim.\n * @returns {string} Returns the trimmed string.\n */\nfunction baseTrim(string) {\n  return string\n    ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, '')\n    : string;\n}\n\nmodule.exports = baseTrim;\n","/** Used to match a single whitespace character. */\nvar reWhitespace = /\\s/;\n\n/**\n * Used by `_.trim` and `_.trimEnd` to get the index of the last non-whitespace\n * character of `string`.\n *\n * @private\n * @param {string} string The string to inspect.\n * @returns {number} Returns the index of the last non-whitespace character.\n */\nfunction trimmedEndIndex(string) {\n  var index = string.length;\n\n  while (index-- && reWhitespace.test(string.charAt(index))) {}\n  return index;\n}\n\nmodule.exports = trimmedEndIndex;\n","var Symbol = require('./_Symbol');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/** Built-in value references. */\nvar symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n/**\n * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the raw `toStringTag`.\n */\nfunction getRawTag(value) {\n  var isOwn = hasOwnProperty.call(value, symToStringTag),\n      tag = value[symToStringTag];\n\n  try {\n    value[symToStringTag] = undefined;\n    var unmasked = true;\n  } catch (e) {}\n\n  var result = nativeObjectToString.call(value);\n  if (unmasked) {\n    if (isOwn) {\n      value[symToStringTag] = tag;\n    } else {\n      delete value[symToStringTag];\n    }\n  }\n  return result;\n}\n\nmodule.exports = getRawTag;\n","/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/**\n * Converts `value` to a string using `Object.prototype.toString`.\n *\n * @private\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n */\nfunction objectToString(value) {\n  return nativeObjectToString.call(value);\n}\n\nmodule.exports = objectToString;\n","module.exports = \"\\nvec4 packDepth( const in float depth ) {\\n    vec4 enc = vec4(1.0, 255.0, 65025.0, 160581375.0) * depth;\\n    enc = fract(enc);\\n    enc -= enc.yzww * vec4(1.0/255.0,1.0/255.0,1.0/255.0,0.0);\\n    return enc;\\n}\\nfloat unpackDepth( const in vec4 rgba_depth ) {\\n    return dot( rgba_depth, vec4(1.0, 1.0/255.0, 1.0/65025.0, 1.0/160581375.0) );\\n}\\n\";","module.exports = \"\\nuniform sampler2D tDepth;\\nuniform vec4 projInfo;\\nuniform float isOrtho;\\nuniform mat4 worldMatrix_mainPass;\\nvec3 reconstructCSPosition(vec2 fragCoords, float z) {\\n    return vec3((fragCoords * projInfo.xy + projInfo.zw) * mix(z, -1.0, isOrtho), z);\\n}\\nvec3 reconstructWorldPosition(vec2 fragCoords, vec2 screenUv) {\\n    float zCam = texture2D(tDepth, screenUv).z;\\n    vec3 csPos = reconstructCSPosition(fragCoords, zCam);\\n    return (worldMatrix_mainPass * vec4(csPos, 1.0)).xyz;\\n}\\n\";","module.exports = \"\\nfloat luminance_post(vec3 rgb) {\\n    return dot(rgb, vec3(0.299, 0.587, 0.114));\\n}\\nfloat luminance_pre(vec3 rgb) {\\n    return dot(rgb, vec3(0.212671, 0.715160, 0.072169));\\n}\\nvec3 xyz2rgb(vec3 xyz) {\\n    vec3 R = vec3( 3.240479, -1.537150, -0.498535);\\n    vec3 G = vec3(-0.969256,  1.875992,  0.041556);\\n    vec3 B = vec3( 0.055648, -0.204043,  1.057311);\\n    vec3 rgb;\\n    rgb.b = dot(xyz, B);\\n    rgb.g = dot(xyz, G);\\n    rgb.r = dot(xyz, R);\\n    return rgb;\\n}\\nvec3 rgb2xyz(vec3 rgb) {\\n    vec3 X = vec3(0.412453, 0.35758, 0.180423);\\n    vec3 Y = vec3(0.212671, 0.71516, 0.0721688);\\n    vec3 Z = vec3(0.0193338, 0.119194, 0.950227);\\n    vec3 xyz;\\n    xyz.x = dot(rgb, X);\\n    xyz.y = dot(rgb, Y);\\n    xyz.z = dot(rgb, Z);\\n    return xyz;\\n}\\nvec3 xyz2xyY(vec3 xyz) {\\n    float sum = xyz.x + xyz.y + xyz.z;\\n    sum = 1.0 / sum;\\n    vec3 xyY;\\n    xyY.z = xyz.y;\\n    xyY.x = xyz.x * sum;\\n    xyY.y = xyz.y * sum;\\n    return xyY;\\n}\\nvec3 xyY2xyz(vec3 xyY) {\\n    float x = xyY.x;\\n    float y = xyY.y;\\n    float Y = xyY.z;\\n    vec3 xyz;\\n    xyz.y = Y;\\n    xyz.x = x * (Y / y);\\n    xyz.z = (1.0 - x - y) * (Y / y);\\n    return xyz;\\n}\\nfloat toneMapCanon_T(float x)\\n{\\n    float xpow = pow(x, 1.60525727);\\n    float tmp = ((1.05542877*4.68037409)*xpow) / (4.68037409*xpow + 1.0);\\n    return clamp(tmp, 0.0, 1.0);\\n}\\nconst float Shift = 1.0 / 0.18;\\nfloat toneMapCanonFilmic_NoGamma(float x) {\\n    x *= Shift;\\n    const float A = 0.2;\\n    const float B = 0.34;\\n    const float C = 0.002;\\n    const float D = 1.68;\\n    const float E = 0.0005;\\n    const float F = 0.252;\\n    const float scale = 1.0/0.833837;\\n    return (((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F))-E/F) * scale;\\n}\\nvec3 toneMapCanonFilmic_WithGamma(vec3 x) {\\n    x *= Shift;\\n    const float A = 0.27;\\n    const float B = 0.29;\\n    const float C = 0.052;\\n    const float D = 0.2;\\n    const float F = 0.18;\\n    const float scale = 1.0/0.897105;\\n    return (((x*(A*x+C*B))/(x*(A*x+B)+D*F))) * scale;\\n}\\nvec3 toneMapCanonOGS_WithGamma_WithColorPerserving(vec3 x) {\\n    vec3 outColor = x.rgb;\\n    outColor = min(outColor, vec3(3.0));\\n    float inLum = luminance_pre(outColor);\\n    if (inLum > 0.0) {\\n        float outLum = toneMapCanon_T(inLum);\\n        outColor = outColor * (outLum / inLum);\\n        outColor = clamp(outColor, vec3(0.0), vec3(1.0));\\n    }\\n    float gamma = 1.0/2.2;\\n    outColor = pow(outColor, vec3(gamma));\\n    return outColor;\\n}\\n\";","module.exports = \"vec3 orderedDithering(vec3 col) {\\n    const vec4 m0 = vec4( 1.0, 13.0,  4.0, 16.0);\\n    const vec4 m1 = vec4( 9.0,  5.0, 12.0,  8.0);\\n    const vec4 m2 = vec4( 3.0, 15.0,  2.0, 14.0);\\n    const vec4 m3 = vec4(11.0,  7.0, 10.0,  6.0);\\n    int i = int(mod(float(gl_FragCoord.x), 4.0));\\n    int j = int(mod(float(gl_FragCoord.y), 4.0));\\n    vec4 biasRow;\\n    if      (i==0) biasRow = m0;\\n    else if (i==1) biasRow = m1;\\n    else if (i==2) biasRow = m2;\\n    else           biasRow = m3;\\n    float bias;\\n    if      (j==0) bias = biasRow.x;\\n    else if (j==1) bias = biasRow.y;\\n    else if (j==2) bias = biasRow.z;\\n    else           bias = biasRow.w;\\n    return col + bias / 17.0 / 256.0;\\n}\\n\";","module.exports = \"#if NUM_CUTPLANES > 0\\nuniform vec4 cutplanes[NUM_CUTPLANES];\\nvoid checkCutPlanes(vec3 worldPosition) {\\n    for (int i=0; i<NUM_CUTPLANES; i++) {\\n        if (dot(vec4(worldPosition, 1.0), cutplanes[i]) > 0.0) {\\n            discard;\\n        }\\n    }\\n}\\n#endif\\n\";","module.exports = \"\\n#define kPI 3.14159265358979\\nvec2 encodeNormal (vec3 n) {\\n    return (vec2(atan(n.y,n.x)/kPI, n.z)+1.0)*0.5;\\n}\\nvec3 decodeNormal (vec2 enc) {\\n    vec2 ang = enc * 2.0 - 1.0;\\n    vec2 scth = vec2(sin(ang.x * kPI), cos(ang.x * kPI));\\n    vec2 scphi = vec2(sqrt(1.0 - ang.y * ang.y), ang.y);\\n    return vec3(scth.y * scphi.x, scth.x * scphi.x, scphi.y);\\n}\\n\";","module.exports = \"#ifdef HATCH_PATTERN\\nuniform vec2 hatchParams;\\nuniform vec3 hatchTintColor;\\nuniform float hatchTintIntensity;\\nfloat curveGaussian(float r, float invWidth) {\\n    float amt = clamp(r * invWidth, 0.0, 1.0);\\n    float exponent = amt * 3.5;\\n    return exp(-exponent*exponent);\\n}\\nvec4 calculateHatchPattern(vec2 hatchParams, vec2 coord, vec4 fragColor, vec3 hatchTintColor, float hatchTintIntensity ) {\\n    float hatchSlope = hatchParams.x;\\n    float hatchPeriod = hatchParams.y;\\n    if (abs(hatchSlope) <= 1.0) {\\n        float hatchPhase = coord.y - hatchSlope * coord.x;\\n        float dist = abs(mod((hatchPhase), (hatchPeriod)));\\n        if (dist < 1.0) {\\n            fragColor = vec4(0.0,0.0,0.0,1.0);\\n        } else {\\n            fragColor.xyz = mix(fragColor.xyz, hatchTintColor, hatchTintIntensity);\\n        }\\n    } else {\\n        float hatchPhase = - coord.y / hatchSlope + coord.x;\\n        float dist = abs(mod((hatchPhase), (hatchPeriod)));\\n        if (dist < 1.0) {\\n            fragColor = vec4(0.0,0.0,0.0,1.0);\\n        } else {\\n            fragColor.xyz = mix(fragColor.xyz, hatchTintColor, hatchTintIntensity);\\n        }\\n    }\\n    return fragColor;\\n}\\n#endif\\n\";","module.exports = \"\\nuniform float envRotationSin;\\nuniform float envRotationCos;\\nvec3 adjustLookupVector(in vec3 lookup) {\\n    return vec3(\\n            envRotationCos * lookup.x - envRotationSin * lookup.z,\\n            lookup.y,\\n            envRotationSin * lookup.x + envRotationCos * lookup.z);\\n}\\nvec3 RGBMDecode(in vec4 vRGBM, in float exposure) {\\n    vec3 ret = vRGBM.rgb * (vRGBM.a * 16.0);\\n    ret *= ret;\\n    ret *= exposure;\\n    return ret;\\n}\\nvec3 GammaDecode(in vec4 vRGBA, in float exposure) {\\n    return vRGBA.xyz * vRGBA.xyz * exposure;\\n}\\nvec3 sampleIrradianceMap(vec3 dirWorld, samplerCube irrMap, float exposure) {\\n    vec4 cubeColor4 = textureCube(irrMap, adjustLookupVector(dirWorld));\\n#ifdef IRR_GAMMA\\n    vec3 indirectDiffuse = GammaDecode(cubeColor4, exposure);\\n#elif defined(IRR_RGBM)\\n    vec3 indirectDiffuse = RGBMDecode(cubeColor4, exposure);\\n#else\\n    vec3 indirectDiffuse = cubeColor4.xyz;\\n#ifdef GAMMA_INPUT\\n    indirectDiffuse.xyz *= indirectDiffuse.xyz;\\n#endif\\n#endif\\n    return indirectDiffuse;\\n}\\n\";","module.exports = \"#ifdef USE_VERTEX_ID\\nattribute vec3 id;\\nvarying   vec3 vId;\\n#endif\\n\";","module.exports = \"\\n#ifdef USE_VERTEX_ID\\nvId = id;\\n#endif\\n\";","module.exports = \"#if defined(MRT_NORMALS) || defined(MRT_ID_BUFFER)\\n    varying highp float depth;\\n#endif\\n#if defined(MRT_ID_BUFFER) || defined(ID_COLOR)\\n    #ifdef USE_VERTEX_ID\\n        varying vec3 vId;\\n    #elif defined(LINE_2D_SHADER)\\n        varying vec4 dbId;\\n    #else\\n        uniform vec3 dbId;\\n    #endif\\n#endif\\n#if defined(MRT_ID_BUFFER) || defined(MODEL_COLOR)\\n    uniform vec3 modelId;\\n#endif\\n#ifdef _LMVWEBGL2_\\n    #if defined(MRT_NORMALS)\\n        layout(location = 1) out vec4 outNormal;\\n        #if defined(MRT_ID_BUFFER)\\n            layout(location = 2) out vec4 outId;\\n            #if defined(MODEL_COLOR)\\n                layout(location = 3) out vec4 outModelId;\\n            #endif\\n        #endif\\n    #elif defined(MRT_ID_BUFFER)\\n        layout(location = 1) out vec4 outId;\\n        #if defined(MODEL_COLOR)\\n            layout(location = 2) out vec4 outModelId;\\n        #endif\\n    #endif\\n#else\\n    #define gl_FragColor gl_FragData[0]\\n    #if defined(MRT_NORMALS)\\n        #define outNormal gl_FragData[1]\\n        #if defined(MRT_ID_BUFFER)\\n            #define outId gl_FragData[2]\\n            #if defined(MODEL_COLOR)\\n                #define outModelId gl_FragData[3]\\n            #endif\\n        #endif\\n    #elif defined(MRT_ID_BUFFER)\\n        #define outId gl_FragData[1]\\n        #if defined(MODEL_COLOR)\\n            #define outModelId gl_FragData[2]\\n        #endif\\n    #endif\\n#endif\";","module.exports = \"\\n#if defined(USE_VERTEX_ID) && (defined(MRT_ID_BUFFER) || defined(ID_COLOR))\\n    vec3 dbId = vId;\\n#endif\\n#ifdef MRT_ID_BUFFER\\n    #ifndef ENABLE_ID_DISCARD\\n        const float writeId = 1.0;\\n    #endif\\n    outId = vec4(dbId.rgb, writeId);\\n    #ifdef MODEL_COLOR\\n        outModelId = vec4(modelId.rgb, writeId);\\n    #endif\\n#elif defined(ID_COLOR)\\n    #ifdef ENABLE_ID_DISCARD\\n        if (writeId==0.0) {\\n            discard;\\n        }\\n    #endif\\n    gl_FragColor = vec4(dbId.rgb, 1.0);\\n#elif defined(MODEL_COLOR)\\n    #ifdef ENABLE_ID_DISCARD\\n        if (writeId==0.0) {\\n            discard;\\n        }\\n    #endif\\n    gl_FragColor = vec4(modelId.rgb, 1.0);\\n#endif\\n\";","module.exports = \"#ifdef HATCH_PATTERN\\ngl_FragColor = calculateHatchPattern(hatchParams, gl_FragCoord.xy, gl_FragColor, hatchTintColor, hatchTintIntensity);\\n#endif\\n#ifdef MRT_NORMALS\\noutNormal = vec4(geomNormal.x, geomNormal.y, depth, gl_FragColor.a < 1.0 ? 0.0 : 1.0);\\n#endif\\n#include<id_frag>\\n\";","module.exports = \"uniform vec4 themingColor;\\n\";","module.exports = \"gl_FragColor.rgb = mix(gl_FragColor.rgb, themingColor.rgb, themingColor.a);\\n\";","module.exports = \"\\n#ifdef USE_INSTANCING\\nattribute vec3 instOffset;\\nattribute vec4 instRotation;\\nattribute vec3 instScaling;\\nvec3 applyQuaternion(vec3 p, vec4 q) {\\n    return p + 2.0 * cross(q.xyz, cross(q.xyz, p) + q.w * p);\\n}\\nvec3 getInstancePos(vec3 pos) {\\n    return instOffset + applyQuaternion(instScaling * pos, instRotation);\\n}\\nvec3 getInstanceNormal(vec3 normal) {\\n    return applyQuaternion(normal/instScaling, instRotation);\\n}\\n#else\\nvec3 getInstancePos(vec3 pos)       { return pos;    }\\nvec3 getInstanceNormal(vec3 normal) { return normal; }\\n#endif\\n\";","module.exports = \"\\nuniform float shadowESMConstant;\\nuniform float shadowMapRangeMin;\\nuniform float shadowMapRangeSize;\\n\";","module.exports = \"\\n#ifdef USE_SHADOWMAP\\nvarying vec4 vShadowCoord;\\nuniform mat4 shadowMatrix;\\n#endif\\n\";","module.exports = \"\\n#ifdef USE_SHADOWMAP\\n{\\n    vec4 worldPosition = modelMatrix * vec4( position, 1.0 );\\n    vShadowCoord = shadowMatrix * worldPosition;\\n}\\n#endif\\n\";","module.exports = \"\\n#ifdef USE_SHADOWMAP\\nuniform sampler2D shadowMap;\\nuniform vec2      shadowMapSize;\\nuniform float     shadowDarkness;\\nuniform float     shadowBias;\\nuniform vec3      shadowLightDir;\\nvarying vec4 vShadowCoord;\\n#include<shadowmap_decl_common>\\nfloat getShadowValue() {\\n    float fDepth;\\n    vec3 shadowColor = vec3( 1.0 );\\n    vec3 shadowCoord = vShadowCoord.xyz / vShadowCoord.w;\\n    shadowCoord.xyz = 0.5 * (shadowCoord.xyz + vec3(1.0, 1.0, 1.0));\\n    bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\\n    bool inFrustum = all( inFrustumVec );\\n    float shadowValue = 1.0;\\n    if (inFrustum) {\\n        shadowCoord.z = min(0.999, shadowCoord.z);\\n        shadowCoord.z -= shadowBias;\\n#ifdef USE_HARD_SHADOWS\\n        vec4 rgbaDepth = texture2D( shadowMap, shadowCoord.xy );\\n        float fDepth = rgbaDepth.r;\\n        if ( fDepth < shadowCoord.z ) {\\n            shadowValue = 1.0 - shadowDarkness;\\n        }\\n#else\\n        vec4 rgbaDepth = texture2D( shadowMap, shadowCoord.xy );\\n        float shadowMapValue = rgbaDepth.r;\\n        shadowValue = exp(-shadowESMConstant * shadowCoord.z) * shadowMapValue;\\n        shadowValue = min(shadowValue, 1.0);\\n        shadowValue = mix(1.0 - shadowDarkness, 1.0, shadowValue);\\n#endif\\n    }\\n    return shadowValue;\\n}\\n#else\\nfloat getShadowValue() { return 1.0; }\\n#endif\\nvec3 applyEnvShadow(vec3 colorWithoutShadow, vec3 worldNormal) {\\n#if defined(USE_SHADOWMAP)\\n    float dp  = dot(shadowLightDir, worldNormal);\\n    float dpValue = (dp + 1.0) / 2.0;\\n    dpValue = min(1.0, dpValue * 1.5);\\n    float sv = getShadowValue();\\n    vec3 result = colorWithoutShadow * min(sv, dpValue);\\n    return result;\\n#else\\n    return colorWithoutShadow;\\n#endif\\n}\\n\";","module.exports = \"float averageOfFloat3(in vec3 value) { \\n    const float oneThird = 1.0 / 3.0; \\n    return dot(value, vec3(oneThird, oneThird, oneThird)); \\n} \\n\";","module.exports = \"\\n#define LINE_2D_SHADER 1\\n#define TAU     6.28318530718\\n#define PI      3.14159265358979\\n#define HALF_PI 1.57079632679\\n#define PI_0_5  HALF_PI\\n#define PI_1_5  4.71238898038\\n#define ENABLE_ID_DISCARD\\n#define VBB_GT_TRIANGLE_INDEXED  0.0\\n#define VBB_GT_LINE_SEGMENT      1.0\\n#define VBB_GT_ARC_CIRCULAR      2.0\\n#define VBB_GT_ARC_ELLIPTICAL    3.0\\n#define VBB_GT_TEX_QUAD          4.0\\n#define VBB_GT_ONE_TRIANGLE      5.0\\n#define VBB_GT_MSDF_TRIANGLE_INDEXED 6.0\\n#define VBB_INSTANCED_FLAG   0.0\\n#define VBB_SEG_START_RIGHT  0.0\\n#define VBB_SEG_START_LEFT   1.0\\n#define VBB_SEG_END_RIGHT    2.0\\n#define VBB_SEG_END_LEFT     3.0\\n#define LTSCALE 0.25\\nvarying vec4 fsColor;\\nvarying vec2 fsOffsetDirection;\\nvarying vec4 fsMultipurpose;\\nvarying float fsHalfWidth;\\nvarying vec2 fsVpTC;\\nvarying float fsGhosting;\\n#ifdef LOADING_ANIMATION\\nvarying float loadingProgress;\\n#endif\\n\";","module.exports = \"#if defined( PRISMWOOD )\\n#define ONE 0.00390625\\nfloat GetIndexedValue(vec4 array, int index)\\n{\\n    if (index == 0)\\n        return array[0];\\n    else if (index == 1)\\n        return array[1];\\n    else if (index == 2)\\n        return array[2];\\n    else if (index == 3)\\n        return array[3];\\n    else\\n        return 0.0;\\n}\\nint GetIndexedValue(ivec2 array, int index)\\n{\\n    if (index == 0)\\n        return array[0];\\n    else if (index == 1)\\n        return array[1];\\n    else\\n        return 0;\\n}\\n#if defined( USE_WOOD_CURLY_DISTORTION_MAP )\\nfloat SampleCurlyPattern(vec2 uv)\\n{\\n    vec2 uv_wood_curly_distortion_map = (wood_curly_distortion_map_texMatrix * vec3(uv, 1.0)).xy;\\n    WOOD_CURLY_DISTORTION_CLAMP_TEST;\\n    vec3 curlyDistortion = texture2D(wood_curly_distortion_map, uv_wood_curly_distortion_map).xyz;\\n    if(wood_curly_distortion_map_invert) curlyDistortion = vec3(1.0) - curlyDistortion;\\n    return curlyDistortion.r;\\n}\\nvec3 DistortCurly(vec3 p)\\n{\\n    if (!wood_curly_distortion_enable) return p;\\n    float r = length(p.xy);\\n    if (r < 0.00001) return p;\\n    const float INV_ANGLE_INTERVAL = 1.27323954;\\n    const float NUM_INTERVAL = 8.0;\\n    float theta = atan(p.y, p.x);\\n    if (theta < 0.0)\\n        theta += PI2;\\n    float intIdx = theta * INV_ANGLE_INTERVAL;\\n    int idx0 = int(mod(floor(intIdx), NUM_INTERVAL));\\n    int idx1 = int(mod(ceil(intIdx), NUM_INTERVAL));\\n    const vec4 HASH_TABLE1 = vec4(0.450572,0.114598, 0.886043, 0.315119);\\n    const vec4 HASH_TABLE2 = vec4(0.216133,0.306264, 0.685616, 0.317907);\\n    float offset0 = idx0 < 4 ? GetIndexedValue(HASH_TABLE1, idx0) : GetIndexedValue(HASH_TABLE2, idx0-4);\\n    float offset1 = idx1 < 4 ? GetIndexedValue(HASH_TABLE1, idx1) : GetIndexedValue(HASH_TABLE2, idx1-4);\\n    const float maxOffset = 100.0;\\n    offset0 = (offset0 - 0.5) * maxOffset;\\n    offset1 = (offset1 - 0.5) * maxOffset;\\n    vec2 uv0 = vec2(p.z + offset0, r);\\n    float shiftWeight0 =  SampleCurlyPattern(uv0);\\n    vec2 uv1 = vec2(p.z + offset1, r);\\n    float shiftWeight1 =  SampleCurlyPattern(uv1);\\n    float interpWeight = fract(intIdx);\\n    float shiftWeight = mix(shiftWeight0, shiftWeight1, interpWeight);\\n    const float INV_MIN_RADIUS = 2.0;\\n    float shiftWeightAdjust = smoothstep(0.0, 1.0, r * INV_MIN_RADIUS);\\n    r -= wood_curly_distortion_scale * (shiftWeight * shiftWeightAdjust);\\n    float thetaNew = atan(p.y, p.x);\\n    vec3 pNew = p;\\n    pNew.x = r * cos(thetaNew);\\n    pNew.y = r * sin(thetaNew);\\n    return pNew;\\n}\\n#endif\\nvec3 un2sn(vec3 range)\\n{\\n    return range * 2.0 - 1.0;\\n}\\nfloat inoise(vec3 p)\\n{\\n    vec3 modp = mod(floor(p), 256.0);\\n    modp.xy = modp.xy * ONE;\\n    vec4 AA = texture2D(perm2DMap, vec2(modp.x, modp.y), 0.0) * 255.0;\\n    AA = AA + modp.z;\\n    AA = mod(floor(AA), 256.0);\\n    AA *= ONE;\\n    vec3 gradx1 = un2sn(texture2D(permGradMap,vec2(AA.x,0.0),0.0).xyz);\\n    vec3 grady1 = un2sn(texture2D(permGradMap,vec2(AA.y,0.0),0.0).xyz);\\n    vec3 gradz1 = un2sn(texture2D(permGradMap,vec2(AA.z,0.0),0.0).xyz);\\n    vec3 gradw1 = un2sn(texture2D(permGradMap,vec2(AA.w,0.0),0.0).xyz);\\n    vec3 gradx2 = un2sn(texture2D(permGradMap,vec2(AA.x + ONE,0.0),0.0).xyz);\\n    vec3 grady2 = un2sn(texture2D(permGradMap,vec2(AA.y + ONE,0.0),0.0).xyz);\\n    vec3 gradz2 = un2sn(texture2D(permGradMap,vec2(AA.z + ONE,0.0),0.0).xyz);\\n    vec3 gradw2 = un2sn(texture2D(permGradMap,vec2(AA.w + ONE,0.0),0.0).xyz);\\n    p -= floor(p);\\n    vec3 fadep = p * p * p * (p * (p * 6.0 - 15.0) + 10.0);\\n    return mix( mix( mix( dot(gradx1, p ),\\n                          dot(gradz1, p + vec3(-1.0, 0.0, 0.0)), fadep.x),\\n                     mix( dot(grady1, p + vec3(0.0, -1.0, 0.0)),\\n                          dot(gradw1, p + vec3(-1.0, -1.0, 0.0)), fadep.x), fadep.y),\\n                mix( mix( dot(gradx2, p + vec3(0.0, 0.0, -1.0)),\\n                          dot(gradz2, p + vec3(-1.0, 0.0, -1.0)), fadep.x),\\n                     mix( dot(grady2, p + vec3(0.0, -1.0, -1.0)),\\n                          dot(gradw2, p + vec3(-1.0, -1.0, -1.0)), fadep.x), fadep.y), fadep.z);\\n}\\nfloat inoise(float p)\\n{\\n    float modp = mod(floor(p), 256.0);\\n    modp = (modp + 256.0) * ONE;\\n    float permx = texture2D(permutationMap, vec2(modp, 0.0), 0.0).r;\\n    float gradx = texture2D(gradientMap, vec2(permx, 0.0), 0.0).r*2.0-1.0;\\n    float permy = texture2D(permutationMap, vec2(modp + ONE, 0.0), 0.0).r;\\n    float grady = texture2D(gradientMap, vec2(permy, 0.0), 0.0).r*2.0-1.0;\\n    p -= floor(p);\\n    float fadep = p * p * p * (p * (p * 6.0 - 15.0) + 10.0);\\n    return mix(gradx * p, grady * (p - 1.0), fadep);\\n}\\nfloat multiband_inoise(vec3 p, int bands, vec4 w, vec4 f)\\n{\\n    float noise = 0.0;\\n    for(int i = 0; i < 4; ++i)\\n    {\\n        if (i >= bands) break;\\n        noise += GetIndexedValue(w, i) * inoise(p * GetIndexedValue(f, i));\\n    }\\n    return noise;\\n}\\nfloat multiband_inoise(float p, int bands, vec4 w, vec4 f)\\n{\\n    float noise = 0.0;\\n    for(int i = 0; i < 4; ++i)\\n    {\\n        if (i >= bands) break;\\n        noise += GetIndexedValue(w, i) * inoise(p * GetIndexedValue(f, i));\\n    }\\n    return noise;\\n}\\nvec3 Distort3DCosineRadialDir(vec3 p)\\n{\\n    float radius = length(p.xy);\\n    if (radius < 0.00001) return p;\\n    vec2 theta = p.xy / radius;\\n    float radiusShift = 0.0;\\n    for (int i = 0; i < 4; ++i)\\n    {\\n        if (i >= wood_fiber_cosine_bands) break;\\n        radiusShift += GetIndexedValue(wood_fiber_cosine_weights, i) * cos(p.z * RECIPROCAL_PI2 * GetIndexedValue(wood_fiber_cosine_frequencies, i));\\n    }\\n    const float MIN_RADIUS = 1.5;\\n    float weight = clamp(radius / MIN_RADIUS, 0.0, 1.0);\\n    if(weight >= 0.5)\\n        weight = weight * weight * (3.0 - (weight + weight));\\n    p.xy += theta * radiusShift * weight;\\n    return p;\\n}\\nvec3 Distort3DPerlin(vec3 p)\\n{\\n    vec3 pAniso = vec3(p.xy, p.z * wood_fiber_perlin_scale_z);\\n    p.xy += multiband_inoise(pAniso, wood_fiber_perlin_bands, wood_fiber_perlin_weights, wood_fiber_perlin_frequencies);\\n    return p;\\n}\\nvec3 Distort(vec3 p)\\n{\\n    if(wood_fiber_cosine_enable)\\n        p = Distort3DCosineRadialDir(p);\\n    if(wood_fiber_perlin_enable)\\n        p = Distort3DPerlin(p);\\n    return p;\\n}\\nfloat DistortRadiusLength(float radiusLength)\\n{\\n    radiusLength += multiband_inoise(radiusLength, wood_growth_perlin_bands, wood_growth_perlin_weights, wood_growth_perlin_frequencies);\\n    if (radiusLength < 0.0) radiusLength = 0.0;\\n    return radiusLength;\\n}\\nfloat ComputeEarlyWoodRatio(float radiusLength)\\n{\\n    float fraction = mod(radiusLength, wood_ring_thickness) / wood_ring_thickness;\\n    if (fraction <= wood_ring_fraction.y)\\n       return 1.0;\\n    else if(fraction <= wood_ring_fraction.x)\\n       return (1.0 - (fraction - wood_ring_fraction.y) / wood_fall_rise.x);\\n    else if(fraction <= wood_ring_fraction.w)\\n       return 0.0;\\n    else\\n       return ((fraction - wood_ring_fraction.w) / wood_fall_rise.y);\\n}\\nvec3 DistortEarlyColor(vec3 earlyColor, float radiusLength)\\n{\\n    float expValue = 1.0 + multiband_inoise(radiusLength,wood_earlycolor_perlin_bands,wood_earlycolor_perlin_weights,wood_earlycolor_perlin_frequencies);\\n    earlyColor = pow(abs(earlyColor), vec3(expValue));\\n    return earlyColor;\\n}\\nvec3 DistortLateColor(vec3 lateColor, float radiusLength)\\n{\\n    float expValue = 1.0 + multiband_inoise(radiusLength,wood_latecolor_perlin_bands,wood_latecolor_perlin_weights,wood_latecolor_perlin_frequencies);\\n    lateColor = pow(abs(lateColor), vec3(expValue));\\n    return lateColor;\\n}\\nvec3 DistortDiffuseColor(vec3 diffAlbedo, vec3 p)\\n{\\n    p.z *= wood_diffuse_perlin_scale_z;\\n    float expValue = 1.0 + multiband_inoise(p, wood_diffuse_perlin_bands, wood_diffuse_perlin_weights, wood_diffuse_perlin_frequencies);\\n    diffAlbedo = pow(abs(diffAlbedo), vec3(expValue));\\n    return diffAlbedo;\\n}\\nfloat LayerRoughnessVar(float roughness, float earlyWoodRatio)\\n{\\n    return earlyWoodRatio * wood_groove_roughness + (1.0 - earlyWoodRatio) * roughness;\\n}\\nfloat hashword(vec2 k)\\n{\\n    k = mod(k, vec2(256.0)) * ONE;\\n    float a = texture2D(permutationMap, vec2(k.x, 0.0)).x + k.y ;\\n    a = texture2D(permutationMap, vec2(a, 0.0)).x ;\\n    return a*255.0;\\n}\\nfloat wyvillsq(float rsq)\\n{\\n    if (rsq >= 1.0) return 0.0;\\n    float tmp = 1.0 - rsq;\\n    return tmp*tmp*tmp;\\n}\\nfloat Weight2DNeighborImpulses(vec3 p, float woodWeight)\\n{\\n    if(woodWeight <= 0.0) return 0.0;\\n    float poreRadius = wood_pore_radius * woodWeight;\\n    vec2 left = floor((p.xy - poreRadius) / wood_pore_cell_dim);\\n    vec2 right = floor((p.xy + poreRadius) / wood_pore_cell_dim);\\n    float weight = 0.0;\\n    float invRsq = 1.0 / (poreRadius * poreRadius);\\n    const float norm =  1.0 / 15.0;\\n    for (int j = 0; j <= 4; j++)\\n    {\\n        if (j > int(right.y - left.y)) continue;\\n        for (int i = 0; i <= 4; i++)\\n        {\\n            if (i > int(right.x - left.x)) continue;\\n            vec2 pij = vec2(float(i) + left.x,float(j) + left.y);\\n            float hRNum = hashword(pij);\\n            float impPosX = mod(hRNum, 16.0) * norm;\\n            float impPosY = floor(hRNum / 16.0) * norm;\\n            impPosX = (pij.x + impPosX)* wood_pore_cell_dim;\\n            impPosY = (pij.y + impPosY)* wood_pore_cell_dim;\\n            float dsq = (p.x - impPosX) * (p.x - impPosX) + (p.y - impPosY) * (p.y - impPosY);\\n            weight += wyvillsq(dsq * invRsq);\\n        }\\n    }\\n    return weight;\\n}\\nfloat Weight3DRayImpulses(vec3 p)\\n{\\n    int segIdx = int(floor(p.z / wood_ray_seg_length_z));\\n    float factor = p.z / wood_ray_seg_length_z - float(segIdx);\\n    int segIdx1 = segIdx - 1;\\n    if ( factor > 0.5 )\\n        segIdx1 = segIdx + 1;\\n    float theta = atan(p.y, p.x);\\n    float sliceIdx = floor(((theta + PI) * RECIPROCAL_PI2) * wood_ray_num_slices);\\n    if ( sliceIdx == wood_ray_num_slices)\\n        sliceIdx-=1.0;\\n    ivec2 arrSegs = ivec2(segIdx, segIdx1);\\n    float weight = 0.0;\\n    const float norm =  1.0 / 15.0;\\n    float radialOffset = 5.0;\\n    float radialLength = length(p.xy);\\n    for (int seg = 0; seg < 2; seg++)\\n    {\\n        float hRNum = hashword(vec2(sliceIdx, GetIndexedValue(arrSegs, seg)));\\n        float rn1 = mod(hRNum,16.0) * norm;\\n        if (radialLength < radialOffset * rn1)\\n            continue;\\n        float rayTheta = rn1;\\n        rayTheta = ( ( sliceIdx + rayTheta ) / wood_ray_num_slices ) * ( 2.0 * PI ) - PI;\\n        float rayPosZ = (hRNum/16.0)* norm;\\n        rayPosZ = ( float(GetIndexedValue(arrSegs, seg)) + rayPosZ ) * wood_ray_seg_length_z;\\n        vec3 pt1 = vec3(0.0);\\n        vec3 pt2 = vec3(cos(rayTheta), sin(rayTheta), 0.0);\\n        vec3 p1 = p;\\n        p1.z -= rayPosZ;\\n        p1.z /=  wood_ray_ellipse_z2x;\\n        vec3 v1 = pt2 - pt1;\\n        vec3 v2 = pt1 - p1;\\n        v2 = cross(v1, v2);\\n        float dist = length(v2) / length(v1);\\n        float invRsq = 1.0 / ( wood_ray_ellipse_radius_x * wood_ray_ellipse_radius_x);\\n        weight += wyvillsq( (dist * dist) * invRsq );\\n    }\\n    return weight;\\n}\\nvec3 DarkenColorWithPores(vec3 p, vec3 diffColor, float woodWeight)\\n{\\n    float poresWeight = Weight2DNeighborImpulses(p, woodWeight);\\n    float a = wood_pore_color_power - 1.0;\\n    float b = 1.0;\\n    float y = a * poresWeight + b;\\n    return pow(abs(diffColor), vec3(y));\\n}\\nvec3 DarkenColorWithRays(vec3 p, vec3 diffColor)\\n{\\n    float raysWeight = Weight3DRayImpulses(p);\\n    float a = wood_ray_color_power - 1.0;\\n    float b = 1.0;\\n    float y = a * raysWeight + b;\\n    return pow(abs(diffColor), vec3(y));\\n}\\nfloat ComputeWoodWeight(float earlyWoodRatio)\\n{\\n    float woodWeight = 0.0;\\n    if (wood_pore_type == 0)\\n        woodWeight = 1.0;\\n    else if (wood_pore_type == 1)\\n        woodWeight = earlyWoodRatio;\\n    else if (wood_pore_type == 2)\\n        woodWeight = 1.0 - earlyWoodRatio;\\n    else\\n        woodWeight = -1.0;\\n    return woodWeight;\\n}\\n#if defined( PRISMWOODBUMP )\\nfloat ComputeEarlyWoodRatioAA(float radiusLength, float invUnitExt)\\n{\\n    float transPixels = min(wood_fall_rise.x, wood_fall_rise.y) * wood_ring_thickness * invUnitExt;\\n    float samplesf = clamp(4.0 / transPixels, 1.0, 4.0);\\n    int samples = int(samplesf);\\n    float inverseSamples = 1.0 / float(samples);\\n    vec2 rdelta = vec2(dFdx(radiusLength), dFdy(radiusLength)) * inverseSamples;\\n    float earlywoodRatio = 0.0;\\n    for (int i = 0; i < 4; ++i)\\n    {\\n        if (i >= samples) break;\\n        for (int j = 0; j < 4; ++j)\\n        {\\n            if (j >= samples) break;\\n            float r = radiusLength + dot(vec2(i, j), rdelta);\\n            earlywoodRatio += ComputeEarlyWoodRatio(r);\\n        }\\n    }\\n    return earlywoodRatio * (inverseSamples * inverseSamples);\\n}\\nfloat LatewoodDepthVariation(float invUnitExt)\\n{\\n    float transPixels = min(wood_fall_rise.x, wood_fall_rise.y) * wood_ring_thickness * invUnitExt;\\n    return clamp(transPixels * 0.5, 0.0, 1.0);\\n}\\nfloat LatewoodHeightVariation(float earlyWoodRatio, float latewoodBumpDepth,\\n                              float depthVar)\\n{\\n    return ( 1.0 - earlyWoodRatio ) * latewoodBumpDepth * depthVar;\\n}\\nfloat PoreDepthVariation(float woodWeight, float invUnitExt)\\n{\\n    float porePixels = woodWeight * wood_pore_radius * invUnitExt;\\n    return clamp(porePixels, 0.0, 1.0);\\n}\\nfloat PoreHeightVariation(float earlyWoodRatio, float poresWeight, float poreDepth,\\n                          float depthVar)\\n{\\n    return poresWeight * (-1.0 * poreDepth) * depthVar;\\n}\\nvoid ComputeTangents(vec3 normal, out vec3 u, out vec3 v)\\n{\\n    float scale = normal.z < 0.0 ? -1.0 : 1.0;\\n    vec3 temp = scale * normal;\\n    float e    = temp.z;\\n    float h    = 1.0/(1.0 + e);\\n    float hvx  = h   *  temp.y;\\n    float hvxy = hvx * -temp.x;\\n    u = vec3(e + hvx * temp.y, hvxy,                -temp.x);\\n    v = vec3(hvxy,             e + h * temp.x * temp.x, -temp.y);\\n    u *= scale;\\n    v *= scale;\\n}\\nvec3 WoodBumpHeight(float heightLeft, float heightRight, float heightBack, float heightFront)\\n{\\n    const float epsilon = 0.001;\\n    float heightDeltaX = heightRight - heightLeft;\\n    vec3 Tu = vec3(2.0 * epsilon, 0.0, heightDeltaX);\\n    float heightDeltaY = heightFront - heightBack;\\n    vec3 Tv = vec3(0.0, 2.0 * epsilon, heightDeltaY);\\n    return cross(Tu, Tv);\\n}\\nvec3 SelectNormal(vec3 N, vec3 bumpN, vec3 V)\\n{\\n    float bumpNdotV = dot(bumpN, V);\\n    if(bumpNdotV > 0.0)\\n        return bumpN;\\n    else return N;\\n}\\nfloat MinInverseUnitExtent(vec3 p)\\n{\\n    return 1.0 / max(max(length(dFdx(p.xy)), length(dFdy(p.xy))), 0.000001);\\n}\\nfloat HeightVariation(vec3 pos)\\n{\\n    vec3 p = Distort(pos);\\n    float radiusLength = length(p.xy);\\n    if (wood_growth_perlin_enable)\\n        radiusLength = DistortRadiusLength(radiusLength);\\n    float invUnitExt = MinInverseUnitExtent(p);\\n    float earlyWoodRatio = ComputeEarlyWoodRatioAA(radiusLength, invUnitExt);\\n    float woodWeight = ComputeWoodWeight(earlyWoodRatio);\\n    float poresWeight = Weight2DNeighborImpulses(p, woodWeight);\\n    float depthVar = PoreDepthVariation(woodWeight, invUnitExt);\\n    float poreHeightVariation = -1.0 * poresWeight * wood_pore_depth * depthVar;\\n    float latewoodHeightVariation = 0.0;\\n    if (wood_use_latewood_bump)\\n    {\\n        float latewoodDepthVar = LatewoodDepthVariation(invUnitExt);\\n        latewoodHeightVariation = (1.0 - earlyWoodRatio) * wood_latewood_bump_depth * latewoodDepthVar;\\n    }\\n    float sumHeightVariation = poreHeightVariation + latewoodHeightVariation;\\n    return sumHeightVariation;\\n}\\n#endif\\nvec3 NoiseWood(vec3 p, inout float roughness)\\n{\\n    p = Distort(p);\\n    float radiusLength = length(p.xy);\\n    if(wood_growth_perlin_enable)\\n        radiusLength = DistortRadiusLength(radiusLength);\\n#if defined( PRISMWOODBUMP )\\n    float invUnitExt = MinInverseUnitExtent( p );\\n    float earlyWoodRatio = ComputeEarlyWoodRatioAA(radiusLength, invUnitExt);\\n#else\\n    float earlyWoodRatio = ComputeEarlyWoodRatio(radiusLength);\\n#endif\\n    vec3 earlyColor = wood_early_color;\\n    if (wood_earlycolor_perlin_enable)\\n        earlyColor = DistortEarlyColor(earlyColor, radiusLength);\\n    vec3 lateColor;\\n    if (wood_use_manual_late_color)\\n        lateColor = wood_manual_late_color;\\n    else\\n        lateColor = pow(abs(earlyColor), vec3(wood_late_color_power));\\n    if(wood_latecolor_perlin_enable)\\n        lateColor = DistortLateColor(lateColor, radiusLength);\\n    vec3 diffAlbedo = earlyWoodRatio * earlyColor + (1.0 - earlyWoodRatio) * lateColor;\\n    if(wood_diffuse_perlin_enable)\\n        diffAlbedo = DistortDiffuseColor(diffAlbedo, p);\\n    if (wood_use_pores)\\n    {\\n        float woodWeight = ComputeWoodWeight(earlyWoodRatio);\\n        diffAlbedo = DarkenColorWithPores(p, diffAlbedo, woodWeight);\\n    }\\n    if (wood_use_rays)\\n        diffAlbedo = DarkenColorWithRays(p, diffAlbedo);\\n    if(wood_use_groove_roughness)\\n        roughness = LayerRoughnessVar(roughness, earlyWoodRatio);\\n    return clamp(diffAlbedo, vec3(0.0), vec3(1.0));\\n}\\n#if defined(PRISMWOODBUMP)\\nvoid getFinalWoodContext(\\n    inout vec3 N, vec3 V, inout vec3 Tu, inout vec3 Tv, vec3 p,\\n    vec3 geoNormal, vec3 tNormal, mat3 normalMatrix\\n) {\\n    vec3 offsetTuLeft = p - 0.001 * Tu;\\n    vec3 offsetTuRight = p + 0.001 * Tu;\\n    vec3 offsetTvLeft = p - 0.001 * Tv;\\n    vec3 offsetTvRight = p + 0.001 * Tv;\\n    float heightVariationTuLeft = HeightVariation(offsetTuLeft);\\n    float heightVariationTuRight = HeightVariation(offsetTuRight);\\n    float heightVariationTvLeft = HeightVariation(offsetTvLeft);\\n    float heightVariationTvRight = HeightVariation(offsetTvRight);\\n    vec3 bumpHeight = WoodBumpHeight(heightVariationTuLeft, heightVariationTuRight, heightVariationTvLeft, heightVariationTvRight);\\n    vec3 newNormal = normalize(bumpHeight.x * Tu + bumpHeight.y * Tv + bumpHeight.z * vtNormal);\\n    vec3 newNormalView = normalize(vNormalMatrix * newNormal);\\n    vec3 selectedNormal = SelectNormal(geoNormal, newNormalView, V);\\n    ComputeTangents(selectedNormal, Tu, Tv);\\n    Tu = normalize(Tu);\\n    Tv = normalize(Tv);\\n    N = faceforward(selectedNormal, -V, selectedNormal);\\n}\\n#endif\\n#endif\\n\";","module.exports = \"\\nvec3 TransmitAdjust(vec3 transmission, vec3 f0) \\n{ \\n   vec3 limit = max(1.0 - f0, 0.00001); \\n   return clamp(transmission, vec3(0.0, 0.0, 0.0), limit) / limit; \\n} \\nfloat ColorToIlluminance(in vec3 color) \\n{ \\n   const vec3 rgb2grey = vec3(0.299, 0.587, 0.114); \\n   float illuminance = dot(rgb2grey, color); \\n   return illuminance; \\n} \\nvoid applyPrismGlazingOpacity(\\n    inout vec4 color,\\n    vec3 transmissionF,\\n    float transmissionAlpha,\\n    float NdotV,\\n    float glazingIlluminace) \\n{\\n    const float third = 1.0/3.0; \\n    float transSurface = exp(-(transmissionAlpha + (transmissionAlpha < 0.0025 ? 0.0 : 0.25)) * NdotV * PI); \\n    float opacity = 1.0- dot((1.0 - transmissionF), vec3(third,third,third)) * transSurface * glazingIlluminace; \\n    opacity = clamp(opacity, 0.01, 0.99);\\n    color.a *= opacity;\\n} \\n\";","module.exports = \"void applyPrismTransparency(\\n    inout vec4 color,\\n    vec3 transparentColor,\\n    float transparentIor\\n) {\\n    float fsLevel = max(max(color.r, color.g), color.b);\\n    color = vec4(color.rgb/fsLevel, fsLevel);\\n    float transLevel = min(min(transparentColor.r, transparentColor.g), transparentColor.b);\\n    transLevel = min( (1.0 - surface_roughness), transLevel );\\n    float transAlpha = (1.0 - transLevel) * 0.4 + surface_roughness * 0.55;\\n    vec3 tr_g_color = sqrt(transparentColor);\\n    vec4 transColor = vec4(0.5 * vec3(tr_g_color), transAlpha);\\n    float strength = 1.0 - (1.0 - fsLevel) * (1.0 - fsLevel);\\n    color = mix(transColor, color, strength);\\n    color.a = max(color.a, 0.05);\\n    if (transparentIor == 1.0 && tr_g_color == vec3(1.0)) {\\n        color.a = 0.0;\\n    }\\n}\";","module.exports = \"#if defined(USE_SURFACE_NORMAL_MAP) || defined( USE_LAYERED_NORMAL_MAP ) || defined( USE_TILING_NORMAL )\\nvoid heightMapTransform(\\n    sampler2D bumpTexture,\\n    vec2 uv,\\n    mat3 transform,\\n    vec2 bumpScale,\\n    inout vec3 T,\\n    inout vec3 B,\\n    inout vec3 N\\n) {\\n    vec2 st = (transform * vec3(uv, 1.0)).xy;\\n    mat3 mtxTangent = mat3(T, B, N);\\n    T = normalize(mtxTangent * (transform * vec3(1.0, 0.0, 0.0)));\\n    B = normalize(mtxTangent * (transform * vec3(0.0, 1.0, 0.0)));\\n    const float oneThird = 1.0 / 3.0;\\n    vec3 avg = vec3(oneThird, oneThird, oneThird);\\n    vec2 offset = fwidth(st);\\n    float h0 = dot(texture2D(bumpTexture, st).xyz, avg);\\n    float hx = dot(texture2D(bumpTexture, st + vec2(offset.x, 0.0)).xyz, avg);\\n    float hy = dot(texture2D(bumpTexture, st + vec2(0.0, offset.y)).xyz, avg);\\n    vec2 diff = vec2(h0 - hx, h0 - hy) / offset;\\n    N = normalize(\\n        N + (\\n            diff.x * T * bumpScale.x +\\n            diff.y * B * bumpScale.y\\n        )\\n    );\\n}\\nvoid normalMapTransform(\\n    sampler2D bumpTexture,\\n    vec2 uv,\\n    mat3 transform,\\n    vec2 bumpScale,\\n    inout vec3 T,\\n    inout vec3 B,\\n    inout vec3 N\\n) {\\n    vec2 st = (transform * vec3(uv, 1.0)).xy;\\n    vec3 mapN =  2.0 * texture2D(bumpTexture, st).xyz - 1.0;\\n    mapN.xy *= bumpScale.x;\\n    mapN.z *= bumpScale.y;\\n    vec3 v = vec3(mapN.y, -mapN.x, 0.0);\\n    float c = -mapN.z;\\n    mat3 skewV = mat3(\\n        0.0, v.z, -v.y,\\n        -v.z, 0.0, v.x,\\n        v.y, -v.x, 0.0\\n    );\\n    mat3 rot = mat3(1.0) + skewV + skewV*skewV * 1.0/(1.0-c);\\n    N *= rot;\\n    T *= rot;\\n    B *= rot;\\n}\\n#endif\\n\";","module.exports = \"uniform float point_size;\";","module.exports = \"gl_PointSize = point_size;\";","module.exports = \"\\n#ifdef WIDE_LINES\\nattribute vec3 prev;\\nattribute vec3 next;\\nattribute float side;\\nuniform vec2 view_size;\\nvec2 to2d(vec4 i) {\\n  return i.xy / i.w;\\n}\\n#endif\\n\";","module.exports = \"\\n#ifdef WIDE_LINES\\nvec4 mvpPosition = projectionMatrix * mvPosition; \\nmat3 vectorMatrix = mat3(modelViewMatrix);\\nvec2 _pos = to2d(mvpPosition) * view_size;\\nvec2 _prev = to2d(projectionMatrix * vec4(mvPosition.xyz + vectorMatrix * (prev * 0.01), 1.0)) * view_size;\\nvec2 _next = to2d(projectionMatrix * vec4(mvPosition.xyz - vectorMatrix * (next * 0.01), 1.0)) * view_size;\\nvec2 dir1 = _pos - _next;\\nvec2 dir2 = _prev - _pos;\\ndir2 = (length(dir2) > 0.0000001) ? normalize(dir2) : vec2(0.0, 0.0);\\ndir1 = (length(dir1) > 0.0000001) ? normalize(dir1) : dir2;\\nvec2 dir_sharp = normalize(dir1 + dir2);\\nvec2 dir = normalize(dir1 + dir_sharp);\\nvec2 offset = vec2(-dir.y, dir.x);\\nfloat len = 1.0 / cross(vec3(offset, 0), vec3(dir1, 0)).z;\\noffset *= len;\\noffset /= view_size;\\noffset *= side;\\noffset *= mvpPosition.w;\\nmvpPosition.xy += offset;\\ngl_Position = mvpPosition;\\n#endif\\n\";","module.exports = \"vec3 rgb2hsv(vec3 color)\\n{\\n    float delta;\\n    float colorMax, colorMin;\\n    float h,s,v;\\n    vec3 hsv;\\n    colorMax = max(color.r,color.g);\\n    colorMax = max(colorMax,color.b);\\n    colorMin = min(color.r,color.g);\\n    colorMin = min(colorMin,color.b);\\n    v = colorMax;\\n    if(colorMax != 0.0)\\n    {\\n        s = (colorMax - colorMin)/colorMax;\\n    }\\n    else\\n    {\\n        s = 0.0;\\n    }\\n    if(s != 0.0)\\n    {\\n        delta = colorMax-colorMin;\\n        if (color.r == colorMax)\\n        {\\n            h = (color.g-color.b)/delta;\\n        }\\n        else if (color.g == colorMax)\\n        {\\n            h = 2.0 + (color.b-color.r) / delta;\\n        }\\n        else\\n        {\\n            h = 4.0 + (color.r-color.g)/delta;\\n        }\\n        h /= 6.0;\\n        if( h < 0.0)\\n        {\\n            h +=1.0;\\n        }\\n    }\\n    else\\n    {\\n        h = 0.0;\\n    }\\n    hsv = vec3(h,s,v);\\n    return hsv;\\n}\\nvec3 hsv2rgb(vec3 hsv)\\n{\\n    vec3 color;\\n    float f,p,q,t;\\n    float h,s,v;\\n    float i,hi;\\n    {\\n        h = hsv.x*6.0;\\n        s = hsv.y;\\n        v = hsv.z;\\n        i = floor(h);\\n        f = h-i;\\n        p = v * (1.0 - s);\\n        q = v * (1.0 - (s * f));\\n        t = v * (1.0 - (s * (1.0 - f)));\\n        float r,g,b;\\n        if (i == 0.0)\\n        {\\n            r = v;\\n            g = t;\\n            b = p;\\n        }\\n        else if (i == 1.0)\\n        {\\n            r = q;\\n            g = v;\\n            b = p;\\n        }\\n        else if (i == 2.0)\\n        {\\n            r = p;\\n            g = v;\\n            b = t;\\n        }\\n        else if (i == 3.0)\\n        {\\n            r = p;\\n            g = q;\\n            b = v;\\n        }\\n        else if (i == 4.0)\\n        {\\n            r = t;\\n            g = p;\\n            b = v;\\n        }\\n        else\\n        {\\n            r = v;\\n            g = p;\\n            b = q;\\n        }\\n        color = vec3(r,g,b);\\n    }\\n    return color;\\n}\";","module.exports = \"varying vec2 vUv;\\nvoid main() {\\n    vUv = uv;\\n    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n}\\n\";","module.exports = \"\\nuniform sampler2D tDiffuse;\\nvarying vec2 vUv;\\nuniform vec2 resolution;\\nuniform float fStop;\\nuniform float focalLength;\\nuniform vec3 cameraPos;\\nuniform float unitScale;\\nuniform float focalPlane;\\nuniform float maxBlur;\\n#include<depth_texture>\\n#define TAU 6.28318530718\\n#define DIRECTIONS 16.\\nfloat COC = 0.03;\\nvec4 debugFocus(float blur){    \\n    vec4 color = texture2D(tDiffuse,vUv);\\n    color = mix(color, vec4(0.,0.,0.,1.), min(0.95, blur));\\n    return color;\\n}\\nfloat calculateBlur() {\\n    float subjectDistance = focalPlane*1000.;\\n    vec3 worldPos = reconstructWorldPosition(gl_FragCoord.xy, vUv);\\n    float unitScaleMM = unitScale * 1000.;\\n    worldPos *= unitScaleMM;\\n    vec3 cameraPosMM = vec3(cameraPos) * unitScaleMM;\\n    float pixelDistance = distance(worldPos, cameraPosMM);\\n    float hyperfocalDistance = (focalLength * focalLength) / (fStop * COC);\\n    float DOFNear = (hyperfocalDistance * subjectDistance) / (hyperfocalDistance + (subjectDistance - focalLength));\\n    float DOFFar = (hyperfocalDistance * subjectDistance) / (hyperfocalDistance - (subjectDistance - focalLength));\\n    float dist = subjectDistance - pixelDistance;\\n    float blur;\\n    if (dist > 0.) {\\n        if (DOFNear < 0.) {\\n            blur = 0.;\\n        } else {\\n            blur = dist / (subjectDistance - DOFNear);    \\n        }\\n    } else {\\n        if (DOFFar < 0.) {\\n            blur = 0.;\\n        } else {\\n            blur = -dist / (DOFFar - subjectDistance);\\n        }\\n    }\\n    float logScale = log(blur+1.) / log(2.);\\n    blur = clamp(0., maxBlur, logScale);\\n    return blur;\\n}\\nvec4 gaussianBlur(float blurAmount) {\\n    vec4 color=texture2D(tDiffuse,vUv);\\n    float quality = float(BLUR_QUALITY);\\n    float radius = 8. * blurAmount;\\n    for(float d = 0.; d < DIRECTIONS; d++)\\n    {\\n        float angle= d * TAU / DIRECTIONS;\\n        vec2 angleVec = vec2(cos(angle),sin(angle));\\n        for(int i = 1; i <= BLUR_QUALITY; i++)\\n        {\\n            float distance = radius * (float(i) / quality);\\n            color += texture2D(tDiffuse, vUv.xy + angleVec * resolution * distance );\\n        }\\n    }\\n    \\n    color /= quality * DIRECTIONS;\\n    return color;\\n}\\nvoid main() {\\n    float blur = calculateBlur();\\n    #ifdef DEBUG\\n    vec4 color = debugFocus(blur);\\n    #else\\n    vec4 color = gaussianBlur(blur);\\n    #endif\\n    gl_FragColor = color;\\n}\\n\";","var debounce = require('./debounce'),\n    isObject = require('./isObject');\n\n/** Error message constants. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/**\n * Creates a throttled function that only invokes `func` at most once per\n * every `wait` milliseconds. The throttled function comes with a `cancel`\n * method to cancel delayed `func` invocations and a `flush` method to\n * immediately invoke them. Provide `options` to indicate whether `func`\n * should be invoked on the leading and/or trailing edge of the `wait`\n * timeout. The `func` is invoked with the last arguments provided to the\n * throttled function. Subsequent calls to the throttled function return the\n * result of the last `func` invocation.\n *\n * **Note:** If `leading` and `trailing` options are `true`, `func` is\n * invoked on the trailing edge of the timeout only if the throttled function\n * is invoked more than once during the `wait` timeout.\n *\n * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\n * until to the next tick, similar to `setTimeout` with a timeout of `0`.\n *\n * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\n * for details over the differences between `_.throttle` and `_.debounce`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to throttle.\n * @param {number} [wait=0] The number of milliseconds to throttle invocations to.\n * @param {Object} [options={}] The options object.\n * @param {boolean} [options.leading=true]\n *  Specify invoking on the leading edge of the timeout.\n * @param {boolean} [options.trailing=true]\n *  Specify invoking on the trailing edge of the timeout.\n * @returns {Function} Returns the new throttled function.\n * @example\n *\n * // Avoid excessively updating the position while scrolling.\n * jQuery(window).on('scroll', _.throttle(updatePosition, 100));\n *\n * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.\n * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });\n * jQuery(element).on('click', throttled);\n *\n * // Cancel the trailing throttled invocation.\n * jQuery(window).on('popstate', throttled.cancel);\n */\nfunction throttle(func, wait, options) {\n  var leading = true,\n      trailing = true;\n\n  if (typeof func != 'function') {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  if (isObject(options)) {\n    leading = 'leading' in options ? !!options.leading : leading;\n    trailing = 'trailing' in options ? !!options.trailing : trailing;\n  }\n  return debounce(func, wait, {\n    'leading': leading,\n    'maxWait': wait,\n    'trailing': trailing\n  });\n}\n\nmodule.exports = throttle;\n","var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n","/*\n * Reusable sets of uniforms that can be merged with other uniforms in specific shaders.\n */\n\nimport * as THREE from \"three\";\n\nexport let CutPlanesUniforms = {\n    \"cutplanes\": { type: \"v4v\", value: [] },\n    \"hatchParams\": { type: \"v2\", value: new THREE.Vector2(1.0, 10.0) },\n    \"hatchTintColor\": { type: \"c\", value: new THREE.Color( 0xFFFFFF ) },\n    \"hatchTintIntensity\": { type: \"f\", value: 1.0 },\n};\n\nexport let IdUniforms = {\n    \"dbId\" : { type: \"v3\", value : new THREE.Vector3(0,0,0) },\n    \"modelId\": { type: \"v3\", value : new THREE.Vector3(0,0,0) }\n};\n\nexport let ThemingUniform = {\n    \"themingColor\": { type: \"v4\", value : new THREE.Vector4(0,0,0,0) }\n};\n\n// Uniforms shared by material shader chunks and ShadowMapShader\n// Included by ShadowMapUniforms below.\nexport let ShadowMapCommonUniforms = {\n    \"shadowESMConstant\":  { type: \"f\", value: 0.0 },\n};\n\n// Uniforms needed by material shaders to apply shadow mapping.\nexport let ShadowMapUniforms = THREE.UniformsUtils.merge([\n    {\n        \"shadowMap\":      { type: \"t\",  value: null },\n        \"shadowMapSize\":  { type: \"v2\", value: new THREE.Vector2(0,0) },\n        \"shadowBias\":     { type: \"f\",  value: 0.0 },\n        \"shadowDarkness\": { type: \"f\",  value: 0.0 },\n        \"shadowMatrix\":   { type: \"m4\", value: new THREE.Matrix4() },\n        \"shadowLightDir\": { type: \"v3\", value: new THREE.Vector3() }\n    },\n    ShadowMapCommonUniforms\n]);\n\n// Uniform for point-set point size\nexport let PointSizeUniforms = {\n    \"point_size\" : { type: \"f\", value: 1.0 }\n};\n\n// Uniform for wide lines shader\nexport let WideLinesUniforms = {\n    \"view_size\": { type: \"v2\", value: new THREE.Vector2(640,480) }\n};\n\n// Uniforms used for reconstructing positions from depth-texture in post-passes. (depth_texture.glsl)\nexport let DepthTextureUniforms = {\t\n    \"tDepth\":   { type: \"t\",  value: null },\t\n    \"projInfo\": { type: \"v4\", value: new THREE.Vector4() },\t\n    \"isOrtho\":  { type: \"f\",  value: 0.0 },\t\n    \"worldMatrix_mainPass\": { type: \"m4\", value: new THREE.Matrix4() }\t\n};\n\nexport let DepthTextureTestUniforms = {\n    \"tDepthTest\":   { type: \"t\",  value: null },\t\n    \"tDepthResolution\":   { type: \"v2\", value: new THREE.Vector2( 1/1024,  1/1024 )  },\n};\n\n\n/*\n * Chunks are code snippets that can be included in specific shaders\n * using the three.js-style include directive:\n *\n *      #include<name_of_chunk>\n *\n * During runtime this directive can be expanded into the corresponding\n * code snippet using the `resolve` method available below.\n */\nvar chunks = {};\n\n// We include default three.js chunks, too\nfor (var name in THREE.ShaderChunk) {\n    chunks[name] = THREE.ShaderChunk[name];\n}\n\nimport pack_depth from './chunks/pack_depth.glsl';\nimport depth_texture from './chunks/depth_texture.glsl';\nimport tonemap from './chunks/tonemap.glsl';\nimport ordered_dither from './chunks/ordered_dither.glsl';\nimport cutplanes from './chunks/cutplanes.glsl';\nimport pack_normals from './chunks/pack_normals.glsl';\nimport hatch_pattern from './chunks/hatch_pattern.glsl';\nimport env_sample from './chunks/env_sample.glsl';\nimport id_decl_vert from './chunks/id_decl_vert.glsl';\nimport id_vert from './chunks/id_vert.glsl';\nimport id_decl_frag from './chunks/id_decl_frag.glsl';\nimport id_frag from './chunks/id_frag.glsl';\nimport final_frag from './chunks/final_frag.glsl';\nimport theming_decl_frag from './chunks/theming_decl_frag.glsl';\nimport theming_frag from './chunks/theming_frag.glsl';\nimport instancing_decl_vert from './chunks/instancing_decl_vert.glsl';\nimport shadowmap_decl_common from './chunks/shadowmap_decl_common.glsl';\nimport shadowmap_decl_vert from './chunks/shadowmap_decl_vert.glsl';\nimport shadowmap_vert from './chunks/shadowmap_vert.glsl';\nimport shadowmap_decl_frag from './chunks/shadowmap_decl_frag.glsl';\nimport float3_average from './chunks/float3_average.glsl';\nimport line_decl_common from './chunks/line_decl_common.glsl';\nimport prism_wood from './chunks/prism_wood.glsl';\nimport prism_glazing from './chunks/prism_glazing.glsl';\nimport prism_transparency from './chunks/prism_transparency.glsl';\nimport normal_map from './chunks/normal_map.glsl';\nimport decl_point_size from './chunks/decl_point_size.glsl';\nimport point_size from './chunks/point_size.glsl';\nimport wide_lines_decl from './chunks/wide_lines_decl.glsl';\nimport wide_lines_vert from './chunks/wide_lines_vert.glsl';\nimport hsv from './chunks/hsv.glsl';\n\nchunks['pack_depth'] = pack_depth;\nchunks['depth_texture'] = depth_texture;\nchunks['tonemap'] = tonemap;\nchunks['ordered_dither'] = ordered_dither;\nchunks['cutplanes'] = cutplanes;\nchunks['pack_normals'] = pack_normals;\nchunks['hatch_pattern'] = hatch_pattern;\nchunks['env_sample'] = env_sample;\nchunks['id_decl_vert'] = id_decl_vert;\nchunks['id_vert'] = id_vert;\nchunks['id_decl_frag'] = id_decl_frag;\nchunks['id_frag'] = id_frag;\nchunks['final_frag'] = final_frag;\nchunks['theming_decl_frag'] = theming_decl_frag;\nchunks['theming_frag'] = theming_frag;\nchunks['instancing_decl_vert'] = instancing_decl_vert;\nchunks['shadowmap_decl_common'] = shadowmap_decl_common;\nchunks['shadowmap_decl_vert'] = shadowmap_decl_vert;\nchunks['shadowmap_vert'] = shadowmap_vert;\nchunks['shadowmap_decl_frag'] = shadowmap_decl_frag;\nchunks['float3_average'] = float3_average;\nchunks['line_decl_common'] = line_decl_common;\nchunks['prism_wood'] = prism_wood;\nchunks['prism_glazing'] = prism_glazing;\nchunks['prism_transparency'] = prism_transparency;\nchunks['normal_map'] = normal_map;\nchunks['decl_point_size'] = decl_point_size;\nchunks['point_size'] = point_size;\nchunks['wide_lines_decl'] = wide_lines_decl;\nchunks['wide_lines_vert'] = wide_lines_vert;\nchunks['hsv'] = hsv;\n\n/*\n * Macros are simple JavaScript functions that can be evaluated from\n * within the shader code using a similar syntax as the include directive:\n *\n *      #name_of_macro<first_param, second_param, third_param, ...>\n *\n * All parameters are simply passed to the JavaScript code as strings,\n * i.e., they are not parsed in any way.\n *\n * We use this as a way to call the various Prism helper methods (such as\n * GetPrismMapsDefinitionChunk below) without having to compose the shader\n * code from lists of strings.\n */\nvar macros = {};\n\n// If any map type is defined, then do whatever \"content\" is;\n// typically it's \"#define USE_MAP\". In other words, if any map\n// is defined, then USE_MAP will also be defined. This constant\n// is then checked and determines whether a UV variable is defined, etc.\nfunction GetPrismMapsDefinitionChunk(flag) {\n    var def = [\"#if defined( USE_SURFACE_ALBEDO_MAP )\" +\n        \" || defined( USE_SURFACE_ROUGHNESS_MAP )\" +\n        \" || defined( USE_SURFACE_CUTOUT_MAP )\" +\n        \" || defined( USE_SURFACE_ANISOTROPY_MAP )\" +\n        \" || defined( USE_SURFACE_ROTATION_MAP )\" +\n        \" || defined( USE_OPAQUE_ALBEDO_MAP )\" +\n        \" || defined( USE_OPAQUE_F0_MAP )\" +\n        \" || defined( USE_OPAQUE_LUMINANCE_MODIFIER_MAP )\" +\n        \" || defined( USE_LAYERED_BOTTOM_F0_MAP )\" +\n        \" || defined( USE_LAYERED_F0_MAP )\" +\n        \" || defined( USE_LAYERED_DIFFUSE_MAP )\" +\n        \" || defined( USE_LAYERED_FRACTION_MAP )\" +\n        \" || defined( USE_LAYERED_ROUGHNESS_MAP )\" +\n        \" || defined( USE_LAYERED_ANISOTROPY_MAP )\" +\n        \" || defined( USE_LAYERED_ROTATION_MAP )\" +\n        \" || defined( USE_METAL_F0_MAP )\" +\n        \" || defined( USE_SURFACE_NORMAL_MAP )\" +\n        \" || defined( USE_LAYERED_NORMAL_MAP )\",\n        \"#define \" + flag,\n    \"#endif\"\n    ].join(\"\\n\");\n    return def;\n}\n\nmacros['prism_check'] = GetPrismMapsDefinitionChunk;\n\n// Set up code for texture access. If USE_SURFACE_ALBEDO_MAP is defined, for example, this texture access code gets executed.\n// If it's not defined, then a simply copy occurs, e.g. \"surfaceAlbedo = surface_albedo;\" from the variableName and mapType.\nexport function GetPrismMapSampleChunk( mapType, variableName, isFloat, linearize ) {\n    var suffix = isFloat ? \"_v3\" : \"\";\n    var declare = isFloat ? \"vec3 \" : \"\";\n    var average = isFloat ? variableName + \" = average(\" + variableName + suffix + \");\" : \"\";\n    var colorLinearization = linearize ? variableName + suffix + \" = SRGBToLinear(\" + variableName + suffix + \");\" : \"\";\n    var shader = [\n        \"#if defined( USE_\" + mapType.toUpperCase() +  \"_MAP )\",\n        // note: the tiling system needs to modify the uv of the texture per tile, so we use the modified \"uv\" here, not vUv.\n        \"vec2 uv_\" + mapType + \"_map = (\" + mapType + \"_map_texMatrix * vec3(uv, 1.0)).xy;\",\n        mapType.toUpperCase()+\"_CLAMP_TEST;\",\n        declare + variableName + suffix + \" = texture2D(\" + mapType +\"_map, uv_\" + mapType + \"_map).xyz;\",\n        colorLinearization,\n        \"if(\" + mapType + \"_map_invert) \" + variableName + suffix +\" = vec3(1.0) - \" + variableName + suffix + \";\",\n        average,\n        \"#else\",\n        variableName + \" = \" + mapType + \";\",\n        \"#endif\"\n    ].join(\"\\n\");\n\n    return shader;\n}\n\nmacros['prism_sample_texture'] = function(mapType, varName, isFloat, linearize) {\n    return GetPrismMapSampleChunk(mapType, varName, isFloat === 'true', linearize === 'true');\n};\n\nexport function GetPrismMapUniformChunk(mapName) {\n\n    var mtxName = mapName + \"_texMatrix\";\n    var mapInvt = mapName + \"_invert\";\n    var macroName = \"USE_\" + mapName;\n\n    var uniforms = [\n        \"#if defined( \" + macroName.toUpperCase() + \" )\",\n        \"uniform sampler2D \" + mapName + \";\",\n        \"uniform mat3 \" + mtxName + \";\",\n        \"uniform bool \" + mapInvt + \";\",\n        \"#endif\",\n    ].join(\"\\n\");\n\n    return uniforms;\n}\n\nmacros['prism_uniforms'] = GetPrismMapUniformChunk;\n\nfunction GetPrismBumpMapUniformChunk(mapName) {\n\n    var mtxName = mapName + \"_texMatrix\";\n    var mapScale = mapName + \"_bumpScale\";\n    var mapType = mapName + \"_bumpmapType\";\n    var macroName = \"USE_\" + mapName;\n\n    var uniforms = [\n        \"#if defined( \" + macroName.toUpperCase() + \" )\",\n        \"uniform sampler2D \" + mapName + \";\",\n        \"uniform mat3 \" + mtxName + \";\",\n        \"uniform vec2 \" + mapScale + \";\",\n        \"uniform int \" + mapType + \";\",\n        \"#endif\",\n    ].join(\"\\n\");\n\n    return uniforms;\n}\n\nmacros['prism_bump_uniforms'] = GetPrismBumpMapUniformChunk;\n\n// Precompile regexes for the macros\nvar _regExCache = {};\nfor (name in macros) {\n    _regExCache[name] = new RegExp('#' + name + ' *<([\\\\w\\\\d., ]*)>', 'g');\n}\n\n/**\n * Recursively resolves include directives and macros.\n * @param {string} source Original shader code.\n * @returns {string} Shader code with all includes resolved.\n */\nexport let resolve = function(source) {\n    for (var name in macros) {\n        var re = _regExCache[name];\n        source = source.replace(re, function(match, parens) {\n            var params = parens.split(',').map(function(param) { return param.trim(); });\n            return macros[name].apply(null, params);\n        });\n    }\n\n    var pattern = /#include *<([\\w\\d.]+)>/g;\n    var func = function(match, include) {\n        if (!chunks[include]) {\n            throw new Error('Cannot resolve #include<' + include + '>');\n        }\n        return resolve(chunks[include]);\n    };\n    return source.replace(pattern, func);\n};\n\n// The chunks don't have to be exported anymore, but we keep them\n// for backwards compatibility (they're still referenced in LegacyNamespace.js)\nexport let PackDepthShaderChunk = chunks['pack_depth'];\nexport let TonemapShaderChunk = chunks['tonemap'];\nexport let OrderedDitheringShaderChunk = chunks['ordered_dither'];\nexport let CutPlanesShaderChunk = chunks['cutplanes'];\nexport let PackNormalsShaderChunk = chunks['pack_normals'];\nexport let HatchPatternShaderChunk = chunks['hatch_pattern'];\nexport let EnvSamplingShaderChunk = chunks['env_sample'];\nexport let IdVertexDeclaration = chunks['id_decl_vert'];\nexport let IdVertexShaderChunk = chunks['id_vert'];\nexport let IdFragmentDeclaration = chunks['id_decl_frag'];\nexport let IdOutputShaderChunk = chunks['id_frag'];\nexport let FinalOutputShaderChunk = chunks['final_frag'];\nexport let ThemingFragmentDeclaration = chunks['theming_decl_frag'];\nexport let ThemingFragmentShaderChunk = chunks['theming_frag'];\nexport let InstancingVertexDeclaration = chunks['instancing_decl_vert'];\nexport let ShadowMapDeclareCommonUniforms = chunks['shadowmap_decl_common'];\nexport let ShadowMapVertexDeclaration = chunks['shadowmap_decl_vert'];\nexport let ShadowMapVertexShaderChunk = chunks['shadowmap_vert'];\nexport let ShadowMapFragmentDeclaration = chunks['shadowmap_decl_frag'];\nexport let PointSizeDeclaration = chunks['decl_point_size'];\nexport let PointSizeShaderChunk = chunks['point_size'];\n\nexport let ShaderChunks = {\n    IdUniforms: IdUniforms,\n    ThemingUniform: ThemingUniform,\n    CutPlanesUniforms: CutPlanesUniforms,\n    ShadowMapCommonUniforms: ShadowMapCommonUniforms,\n    ShadowMapUniforms: ShadowMapUniforms,\n    PointSizeUniforms: PointSizeUniforms,\n    WideLinesUniforms: WideLinesUniforms,\n    DepthTextureUniforms: DepthTextureUniforms,\n    DepthTextureTestUniforms: DepthTextureTestUniforms,\n\n    PackDepthShaderChunk: PackDepthShaderChunk,\n    TonemapShaderChunk: TonemapShaderChunk,\n    OrderedDitheringShaderChunk: OrderedDitheringShaderChunk,\n    CutPlanesShaderChunk: CutPlanesShaderChunk,\n    PackNormalsShaderChunk: PackNormalsShaderChunk,\n    HatchPatternShaderChunk: HatchPatternShaderChunk,\n    EnvSamplingShaderChunk: EnvSamplingShaderChunk,\n    IdVertexDeclaration: IdVertexDeclaration,\n    IdVertexShaderChunk: IdVertexShaderChunk,\n    IdFragmentDeclaration: IdFragmentDeclaration,\n    IdOutputShaderChunk: IdOutputShaderChunk,\n    FinalOutputShaderChunk: FinalOutputShaderChunk,\n    ThemingFragmentDeclaration: ThemingFragmentDeclaration,\n    ThemingFragmentShaderChunk: ThemingFragmentShaderChunk,\n    InstancingVertexDeclaration: InstancingVertexDeclaration,\n    ShadowMapDeclareCommonUniforms: ShadowMapDeclareCommonUniforms,\n    ShadowMapVertexDeclaration: ShadowMapVertexDeclaration,\n    ShadowMapVertexShaderChunk: ShadowMapVertexShaderChunk,\n    ShadowMapFragmentDeclaration: ShadowMapFragmentDeclaration,\n    PointSizeDeclaration: PointSizeDeclaration,\n    PointSizeShaderChunk: PointSizeShaderChunk,\n\n    GetPrismMapSampleChunk: GetPrismMapSampleChunk,\n    GetPrismMapUniformChunk: GetPrismMapUniformChunk,\n\n    resolve: resolve\n};\n","import * as THREE from \"three\";\nimport { ShaderChunks as chunks } from \"../../src/wgs/render/ShaderChunks\";\nimport screen_quad_uv_vert from \"../../src/wgs/render/shaders/screen_quad_uv_vert.glsl\";\nimport dofFrag from \"./Shader/dof_frag.glsl\";\n\nexport let DOFShader = {\n  uniforms: THREE.UniformsUtils.merge([\n    chunks.DepthTextureUniforms,\n\n    {\n      tDiffuse: { type: \"t\", value: null },\n      resolution: { type: \"v2\", value: new THREE.Vector2(1 / 1024, 1 / 512) },\n      cameraNear: { type: \"f\", value: 1 },\n      cameraFar: { type: \"f\", value: 100 },\n      fStop: { type: \"f\", value: 22.0 },\n      focalLength: { type: \"f\", value: 100.0 }, // in mm.\n      focalPlane: { type: \"f\", value: 5.0 }, // in meters.\n      unitScale: { type: \"f\", value: 1.0 }, // conversion from model units to meters.\n      maxBlur: { type: \"f\", value: 2.0 }, // max blur multiplier.\n      cameraPos: { type: \"v3\", value: new THREE.Vector3() },\n    },\n  ]),\n\n  vertexShader: screen_quad_uv_vert,\n  fragmentShader: dofFrag,\n};\n","import { DOFShader } from './DOFShader';\n\nconst ShaderPass = Autodesk.Viewing.Private.ShaderPass;\nconst RenderContextPostProcessExtension = Autodesk.Viewing.Private.RenderContextPostProcessExtension;\n\nconst av = Autodesk.Viewing;\n\nvar DOFRenderContext = function (renderContext, viewer) {\n    RenderContextPostProcessExtension.call(this, renderContext, viewer);\n\n    // Make sure to render DOF before other post processing passes.\n    this.getOrder = function () {\n        return 0;\n    };\n\n    // This flag is needed in order to render the DOF pass only after the selection overlay has been rendered - it looks a lot better.\n    this.shouldRenderAfterOverlays = function () {\n        return true;\n    };\n\n    this.load = function () {\n        this.postProcPass = new ShaderPass(DOFShader);\n        this.renderContext.setNoDepthNoBlend(this.postProcPass);\n    };\n};\n\nDOFRenderContext.prototype = Object.create(RenderContextPostProcessExtension.prototype);\nDOFRenderContext.prototype.constructor = DOFRenderContext;\nav.GlobalManagerMixin.call(DOFRenderContext.prototype);\n\nexport { DOFRenderContext };","\n'use strict';\n\nconst TAB_ID = 'configTab';\nconst TAB_LABEL = 'Configuration';\n\nvar DOFRenderOptionsPanel = function (viewer, dofExtension) {\n    const PANEL_ID = 'adsk_dof_renderoptions_panel_' + viewer.id;\n    const opts = { heightAdjustment: 90, width: 500 };\n    Autodesk.Viewing.UI.SettingsPanel.call(this, viewer.container, PANEL_ID, 'Depth of Field', opts);\n    this.setGlobalManager(viewer.globalManager);\n    this.container.classList.add('viewer-settings-panel');\n    this.viewer = viewer;\n\n    // Add a default tab called Render Options\n    this.addTab(TAB_ID, TAB_LABEL, { className: 'config' });\n    this.selectTab(TAB_ID);\n\n    // Checkbox \"Enabled\"\n    const enabledToggleId = this.addCheckbox(TAB_ID, 'Enabled', false, (checked) => {\n        dofExtension.setEnabled(checked);\n    });\n\n    this.enabledToggle = this.getControl(enabledToggleId);\n\n    // Slider Focal Length\n    const focalLengthId = this.addSlider(TAB_ID, 'Focal Length (mm)',\n        10.0, 200.0, 10,\n        (event) => {\n            var value = event.detail.value;\n            dofExtension.setFocalLength(parseFloat(value));\n        },\n        { step: 1 }\n    );\n    this.focalLength = this.getControl(focalLengthId);\n\n    this.viewer.addEventListener(Autodesk.Viewing.CAMERA_CHANGE_EVENT, () => {\n        var myFocalLength = parseFloat(this.focalLength.value);\n        var camFocalLength = viewer.getFocalLength();\n\n        if (myFocalLength != camFocalLength) this.focalLength.setValue(camFocalLength);\n    });\n\n    // Slider \"f-stop\"\n    const fStopId = this.addSlider(TAB_ID, 'f-stop (Aperture)',\n        2.0, 22.0, 1.4,\n        (event) => {\n            var value = event.detail.value;\n            dofExtension.setFStop(parseFloat(value));\n        },\n        { step: 0.1 }\n    );\n    this.fStop = this.getControl(fStopId);\n\n    // Slider \"Max Blur\"\n    const maxBlurId = this.addSlider(TAB_ID, 'Max Blur',\n        1, 3, 2,\n        (event) => {\n            var value = event.detail.value;\n            dofExtension.setMaxBlur(parseFloat(value));\n        },\n        { step: 0.1 }\n    );\n    this.maxBlur = this.getControl(maxBlurId);\n\n    // Slider \"Blur Quality\"\n    const blurSizeId = this.addSlider(TAB_ID, 'Blur Quality',\n        1, 16, 8,\n        (event) => {\n            var value = event.detail.value;\n            dofExtension.setBlurQuality(value);\n        },\n        { step: 1 }\n    );\n    this.blurQuality = this.getControl(blurSizeId);\n\n    // Checkbox \"Use Cursor\"\n    const useCursor = this.addCheckbox(TAB_ID, 'Focus on Cursor', false, (checked) => {\n        dofExtension.setUseCursor(checked);\n        this.setUseCursor(checked);\n    });\n\n    this.useCursor = this.getControl(useCursor);\n\n    this.setUseCursor = (checked) => {\n        this.focalPlane.setDisabled(checked);\n\n        if (!checked) {\n            const focalPlane = parseFloat(this.focalPlane.value);\n            dofExtension.setFocalPlane(focalPlane * this.unitsToMeters);\n        }\n    };\n\n    // Slider \"Focal Plane\"\n    const focalPlaneId = this.addSlider(TAB_ID, 'Focal Plane',\n        0.01, 50.0, 1,\n        (event) => {\n            var value = event.detail.value;\n            dofExtension.setFocalPlane(parseFloat(value) * this.unitsToMeters);\n        },\n        { step: 0.1 }\n    );\n\n    this.focalPlane = this.getControl(focalPlaneId);\n\n    // Finding the \"correct\" range for the focal plane is hard.\n    // If we use a constant value, we might end up with a really long range for tiny models, or really short range for large models.\n    // In order to find the right range - we need to consider:\n    // - Display units - if we are viewing the model in `mm`, it's a good asumption that the focal plane won't be 1000 meters from the camera.\n    // - Visible bounds - the hard coded \"maxInMeters\" values are the upper bound of the range. If we find out that we a have a model that is relativaly small, but our\n    // display units in meters - we can make the range tighter according to the bounding box of the model.\n    // Bear in mind that this is just a heuristic. Another possible solution for this is to take the camera distance from the model into account.\n    const updateFocalPlaneRange = () => {\n        const units = this.viewer.getExtension(\"Autodesk.Measure\")?.getUnits() || 'm';\n        const unitsString = Autodesk.Viewing.i18n.translate(Autodesk.Viewing.Private.displayUnits[Autodesk.Viewing.Private.displayUnitsEnum.indexOf(units)]);\n        this.focalPlane.caption.textContent = `${Autodesk.Viewing.i18n.translate(\"Focal Plane\")} (${unitsString})`;\n\n        let minInMeters;\n        let maxInMeters;\n        let step;\n\n        switch (units) {\n            case 'mm':\n            case 'pt':\n                minInMeters = 0.001;\n                maxInMeters = 10;\n                step = 1;\n                break;\n            case 'cm':\n            case 'in':\n            case 'fractional-in':\n            case 'decimal-in':\n                minInMeters = 0.01;\n                maxInMeters = 50;\n                step = 0.1;\n                break;\n            case 'm':\n            case 'm-and-cm':\n            case 'ft-and-decimal-in':\n            case 'ft':\n            case 'ft-and-fractional-in':\n            case 'decimal-ft':\n            default:\n                minInMeters = 0.05;\n                maxInMeters = 100;\n                step = 0.01;\n                break;\n        }\n\n        const bounds = this.viewer.impl.getVisibleBounds(true);\n        const toMeters = this.viewer.impl.renderer().getUnitScale();\n        const size = bounds.size();\n\n        // Set the max range to be 5 times of the visible bounds size.\n        const maxModelBounds = 5 * Math.max(size.x, size.y, size.z) * toMeters;\n        maxInMeters = Math.min(maxModelBounds, maxInMeters);\n        \n        this.unitsToMeters = Autodesk.Viewing.Private.convertUnits(units, 'm', 1, 1);\n\n        const min = parseFloat((minInMeters / this.unitsToMeters).toFixed(3));\n        const max = parseFloat((maxInMeters / this.unitsToMeters).toFixed(3));\n\n\n        this.focalPlane.sliderElement.min = min;\n        this.focalPlane.stepperElement.min = min;\n        this.focalPlane.sliderElement.max = max;\n        this.focalPlane.stepperElement.max = max;\n        this.focalPlane.sliderElement.step = step;\n\n        // Update values according to the new units.\n        dofExtension.setFocalPlane(dofExtension.getFocalPlane());\n    };\n\n    updateFocalPlaneRange();\n\n    this.setFocalPlane = (value) => {\n        this.focalPlane.setValue(parseFloat((value / this.unitsToMeters).toFixed(3)));\n    };\n\n    // Checkbox \"Debug\"\n    const debug = this.addCheckbox(TAB_ID, 'Debug DOF', false, (checked) => {\n        dofExtension.setDebug(checked);\n    });\n    this.debug = this.getControl(debug);\n\n    this.viewer.addEventListener(Autodesk.Viewing.MODEL_ROOT_LOADED_EVENT, updateFocalPlaneRange);\n    this.viewer.addEventListener(Autodesk.Viewing.MeasureCommon.Events.DISPLAY_UNITS_CHANGED, updateFocalPlaneRange);\n\n    this.destroy = () => {\n        this.viewer.removeEventListener(Autodesk.Viewing.MODEL_ROOT_LOADED_EVENT, updateFocalPlaneRange);\n        this.viewer.removeEventListener(Autodesk.Viewing.MeasureCommon.Events.DISPLAY_UNITS_CHANGED, updateFocalPlaneRange);\n    };\n};\n\nDOFRenderOptionsPanel.prototype = Object.create(Autodesk.Viewing.UI.SettingsPanel.prototype);\nDOFRenderOptionsPanel.prototype.constructor = DOFRenderOptionsPanel;\n\nexport { DOFRenderOptionsPanel };","const throttle = require(\"lodash/throttle\");\n\nconst GlobalManagerMixin = Autodesk.Viewing.GlobalManagerMixin;\n\nconst AnimDuration = 0.25; // s\nconst ThrottleDuration = 100; // ms\n\n/**\n * Provides functionality for changing focal plane according to the cursor position.\n **/\nexport default class DOFTool {\n    constructor(viewer, dofExtension) {\n        this.viewer = viewer;\n        this.dofExtension = dofExtension;\n\n\t\t// Is tool active.\n\t\tthis.active = false;\n\n\t\t// Tool name.\n        this.names = [\"dof-tool\"];\n\n        this.lastMousePos = new THREE.Vector2();\n\n        this.onCameraChange = this.onCameraChange.bind(this);\n\n        this.updateFocalPlaneThrottled = throttle((targetFocalPlane) => {\n            if (this.anim) {\n                this.anim.stop();\n                this.anim = null;\n            }\n\n            const startValue = this.dofExtension.getFocalPlane();\n\n            this.anim = Autodesk.Viewing.Private.fadeValue(startValue, targetFocalPlane, AnimDuration, (value) => {\n                this.dofExtension.setFocalPlane(value);\n            }, () => {\n                this.anim = null;\n            });\n        }, ThrottleDuration);\n\t}\n\n\tgetNames() {\n\t\treturn this.names;\n\t}\n\n\tgetName() {\n\t\treturn this.names[0];\n    }\n\n    getPriority() {\n        return 1000;\n    }\n\n    isActive() {\n\t\treturn this.active;\n\t}\n\n\tactivate() {\n\t\tif (this.isActive()) {\n\t\t\treturn;\n        }\n\n        this.viewer.addEventListener(Autodesk.Viewing.CAMERA_CHANGE_EVENT, this.onCameraChange);\n\n\t\tthis.active = true;\n\t}\n\n\tdeactivate() {\n\t\tif (!this.isActive()) {\n\t\t\treturn;\n        }\n\n        this.viewer.removeEventListener(Autodesk.Viewing.CAMERA_CHANGE_EVENT, this.onCameraChange);\n\n        if (this.anim) {\n            this.anim.stop();\n            this.anim = null;\n        }\n\n\t\tthis.active = false;\n    }\n\n    // In case that the camera moved and the mouse didn't (bimwalk / wheel) - update.\n    onCameraChange() {\n        return this.handleMouseMove({ canvasX: this.lastMousePos.x, canvasY: this.lastMousePos.y });\n    }\n    \n    handleMouseMove(event) {\n        this.lastMousePos.set(event.canvasX, event.canvasY);\n\n        const result = this.viewer.impl.snappingHitTest(event.canvasX, event.canvasY);\n        const cameraPos = this.viewer.getCamera().position;\n\n        const target = result?.intersectPoint;\n\n        if (!target) {\n            return false;\n        }\n\n        const targetFocalPlane = cameraPos.distanceTo(target) * this.viewer.impl.renderer().getUnitScale();\n\n        this.updateFocalPlaneThrottled(targetFocalPlane);\n\n        // don't consume event\n        return false;\n    }\n}\n\nGlobalManagerMixin.call(DOFTool.prototype);\n","/**\n * Include each locale json file and return it in an object\n * that can be consumed by i18n\n */\n\nimport json_en from '../../res/locales/en/nobundle-dof.loc.json';\n\nexport const locales = {\n    en: json_en,\n};\n","import { DOFRenderContext } from \"./DOFRenderContext\";\nimport { DOFRenderOptionsPanel } from \"./DOFRenderOptionsPanel\";\nimport DOFTool from \"./DOFTool\";\nimport { locales } from \"./DOFLocales\";\n\nconst Extension = Autodesk.Viewing.Extension;\n\nexport function DOFExtension(viewer, options) {\n    Extension.call(this, viewer, options);\n\n    this.openPanel = this.openPanel.bind(this);\n}\n\nDOFExtension.prototype = Object.create(Autodesk.Viewing.Extension.prototype);\nDOFExtension.prototype.constructor = DOFExtension;\n\n/**\n * Load the Depth of Field extension.\n * It will fail to load when running a headless viewer.\n */\nDOFExtension.prototype.load = function () {\n    this.extendLocalization(locales);\n\n    this.dofRenderContext = new DOFRenderContext(this.viewer.impl.renderer(), this.viewer);\n    this.dofRenderContext.load();\n    this.viewer.impl.renderer().postShadingManager().registerPostProcessingExtension(this.dofRenderContext);\n\n    this.tool = new DOFTool(this.viewer, this);\n    this.viewer.toolController.registerTool(this.tool);\n\n    this.firstTime = true;\n\n    // Create UI by default. Panel could be found in the viewer settings panel.\n    if (this.options.createUI !== false) {\n        this.panel = new DOFRenderOptionsPanel(this.viewer, this);\n    }\n    \n    return true;\n};\n\n/**\n * Unload the Depth of Field extension.\n */\nDOFExtension.prototype.unload = function () {        \n    if (this.dofRenderContext) {\n        this.viewer.impl.renderer().postShadingManager().removePostProcessingExtension(this.dofRenderContext);\n        this.viewer.impl.invalidate(true,true,true);\n        this.dofRenderContext = null;\n    }\n\n    if (this.panel) {\n        if (this._configButtonId !== null) {\n           this.viewer.viewerSettingsPanel.removeConfigButton(this._configButtonId);\n            this._configButtonId = null;   \n        }\n\n        this.panel.setVisible(false);\n        this.panel.destroy();\n        this.panel = null;\n    }\n\n    return true;\n};\n\nDOFExtension.prototype.getInitialFocalPlane = function (params) {\n    const customDistance = parseFloat(Autodesk.Viewing.Private.getParameterByName('focalPlane')) || this.options.focalPlane;\n\n    if (customDistance) {\n        return customDistance;\n    }\n\n    // Cast a ray from camera to the object in the center of the screen, and use it as a default value.\n    const camera = this.viewer.getCamera();\n    const eyeVec = camera.target.clone().sub(camera.position).normalize();\n    const hit = this.viewer.impl.rayIntersect(new THREE.Ray(camera.position, eyeVec));\n    \n    if (hit) {\n        const toMeters = this.viewer.impl.renderer().getUnitScale();\n        return hit.distance * toMeters;\n    }\n\n    return 2; // Fallback - 2 meters from camera.\n};\n\nDOFExtension.prototype.loadDefaultValues = function () {\n    const defaultFocalLength = parseFloat(Autodesk.Viewing.Private.getParameterByName(\"focalLength\")) || this.options.focalLength || this.getFocalLength();\n    const defaultFstop = parseFloat(Autodesk.Viewing.Private.getParameterByName('fStop')) || this.options.fStop || 8;\n    const defaultMaxBlur = parseFloat(Autodesk.Viewing.Private.getParameterByName('maxBlur')) || this.options.maxBlur || 2.0;\n    const defaultBlurQuality = parseFloat(Autodesk.Viewing.Private.getParameterByName('blurQuality')) || this.options.blurQuality || 8.0;\n    const defaultFocalPlane = this.getInitialFocalPlane();\n    const defaultUseCursor = Autodesk.Viewing.Private.getParameterByName(\"blurUseCursor\") === 'true' || this.options.blurUseCursor || false;\n    const defaultDebug = Autodesk.Viewing.Private.getParameterByName(\"blurDebug\") === 'true' || this.options.blurDebug || false;\n\n    this.setFocalLength(defaultFocalLength);\n    this.setFStop(defaultFstop);\n    this.setMaxBlur(defaultMaxBlur);\n    this.setBlurQuality(defaultBlurQuality);\n    this.setFocalPlane(defaultFocalPlane);\n    this.setUseCursor(defaultUseCursor);\n    this.setDebug(defaultDebug);\n};\n\nDOFExtension.prototype.onToolbarCreated = function () {\n    if (this.panel) {\n        this._initButtonConfig();\n    }\n};\n\n/**\n * Adds a button to the Settings Panel.\n * @private\n */\nDOFExtension.prototype._initButtonConfig = function() {   \n    var settingsPanel = this.viewer.getSettingsPanel();\n    if (!settingsPanel) {\n        this.addEventListener(Autodesk.Viewing.SETTINGSpanel_CREATED_EVENT, this._initButtonConfig, {once: true});\n        return;\n    }\n    this._configButtonId = settingsPanel.addConfigButton(\"Depth of Field\", this.openPanel);\n};\n\nDOFExtension.prototype.openPanel = function () {\n    this.setEnabled(true);\n    this.panel?.setVisible(true);\n};\n\nDOFExtension.prototype.activate = function () {\n    // Already active\n    if (this.isActive()) {\n        return;\n    }\n\n    if (this.firstTime) {\n        this.firstTime = false;\n\n        // Although it does work with orthographic, DOF works much better with perspective camera.\n        this.viewer.navigation.toPerspective();\n\n        this.loadDefaultValues();\n    }\n\n    this.dofRenderContext.enable();\n\n    if (this.useCursor && !this.viewer.toolController.isToolActivated(this.tool.getName())) {   \n        this.viewer.toolController.activateTool(this.tool.getName());\n    }\n\n    this.panel?.enabledToggle.setValue(true);\n\n    this.activeStatus = true;\n};\n\nDOFExtension.prototype.deactivate = function () {\n    // Already inactive.\n    if (!this.isActive()) {\n        return;\n    }\n\n    this.dofRenderContext.disable();\n\n    if (this.useCursor && this.viewer.toolController.isToolActivated(this.tool.getName())) {   \n        this.viewer.toolController.deactivateTool(this.tool.getName());\n    }\n\n    this.panel?.enabledToggle.setValue(false);\n\n    this.activeStatus = false;\n};\n\nDOFExtension.prototype.setEnabled = function (enable) {\n    if (enable) {\n        this.activate();\n    } else {\n        this.deactivate();\n    }\n};\n\nDOFExtension.prototype.getUseCursor = function () {\n    return this.useCursor;\n};\n\nDOFExtension.prototype.setUseCursor = function (enable) {\n    this.useCursor = enable;\n\n    if (enable) {\n        this.viewer.toolController.activateTool(this.tool.getName());\n    } else {\n        this.viewer.toolController.deactivateTool(this.tool.getName());\n    }\n\n    this.panel?.setUseCursor(enable);\n};\n\nDOFExtension.prototype.getDebug = function () {\n    return this.dofRenderContext.getDefineValue(\"DEBUG\");\n};\n\nDOFExtension.prototype.setDebug = function (enable) {\n    this.dofRenderContext.updateDefineValue(\"DEBUG\", enable ? true : null);\n    this.panel?.debug.setValue(enable);\n};\n\nDOFExtension.prototype.getFStop = function () {\n    return this.dofRenderContext.getUniformValue(\"fStop\");\n};\n\nDOFExtension.prototype.setFStop = function (value) {\n    this.dofRenderContext.updateUniformValue(\"fStop\", value);\n    this.panel?.fStop.setValue(value);\n};\n\n// Value in meters\nDOFExtension.prototype.getFocalPlane = function () {\n    return this.dofRenderContext.getUniformValue(\"focalPlane\");\n};\n\n// Value in meters\nDOFExtension.prototype.setFocalPlane = function (value) {\n    this.dofRenderContext.updateUniformValue(\"focalPlane\", value);\n    this.panel?.setFocalPlane(value);\n};\n\nDOFExtension.prototype.getMaxBlur = function () {\n    return this.dofRenderContext.getUniformValue(\"maxBlur\");\n};\n\nDOFExtension.prototype.setMaxBlur = function (value) {\n    this.dofRenderContext.updateUniformValue(\"maxBlur\", value);\n    this.panel?.maxBlur.setValue(value);\n};\n\nDOFExtension.prototype.getFocalLength = function () {\n    return Autodesk.Viewing.Navigation.prototype.fov2fl(this.viewer.getCamera().fov);\n};\n\nDOFExtension.prototype.setFocalLength = function (value) {\n    // No need to explicitly update the DOF panel. It has an event listener on the camera.\n    this.viewer.setFocalLength(value);\n};\n\nDOFExtension.prototype.getBlurQuality = function () {\n    return this.dofRenderContext.getDefineValue(\"BLUR_QUALITY\");\n};\n\nDOFExtension.prototype.setBlurQuality = function (value) {\n    this.dofRenderContext.updateDefineValue(\"BLUR_QUALITY\", value);\n    this.panel?.blurQuality.setValue(value);\n};\n\n/**\n * Register the extension with the extension manager.\n */\nAutodesk.Viewing.theExtensionManager.registerExtension('Autodesk.DOF', DOFExtension);\n"],"sourceRoot":""}