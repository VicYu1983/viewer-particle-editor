{"version":3,"file":"DOF/DOF.js","sources":["webpack://Autodesk.Extensions.[name]/webpack/bootstrap","webpack://Autodesk.Extensions.[name]/./extensions/DOF/DOFExtension.js","webpack://Autodesk.Extensions.[name]/./extensions/DOF/DOFLocales.js","webpack://Autodesk.Extensions.[name]/./extensions/DOF/DOFRenderContext.js","webpack://Autodesk.Extensions.[name]/./extensions/DOF/DOFRenderOptionsPanel.js","webpack://Autodesk.Extensions.[name]/./extensions/DOF/DOFShader.js","webpack://Autodesk.Extensions.[name]/./extensions/DOF/DOFTool.js","webpack://Autodesk.Extensions.[name]/./extensions/DOF/Shader/dof_frag.glsl","webpack://Autodesk.Extensions.[name]/./node_modules/lodash/_Symbol.js","webpack://Autodesk.Extensions.[name]/./node_modules/lodash/_baseGetTag.js","webpack://Autodesk.Extensions.[name]/./node_modules/lodash/_baseTrim.js","webpack://Autodesk.Extensions.[name]/./node_modules/lodash/_freeGlobal.js","webpack://Autodesk.Extensions.[name]/./node_modules/lodash/_getRawTag.js","webpack://Autodesk.Extensions.[name]/./node_modules/lodash/_objectToString.js","webpack://Autodesk.Extensions.[name]/./node_modules/lodash/_root.js","webpack://Autodesk.Extensions.[name]/./node_modules/lodash/_trimmedEndIndex.js","webpack://Autodesk.Extensions.[name]/./node_modules/lodash/debounce.js","webpack://Autodesk.Extensions.[name]/./node_modules/lodash/isObject.js","webpack://Autodesk.Extensions.[name]/./node_modules/lodash/isObjectLike.js","webpack://Autodesk.Extensions.[name]/./node_modules/lodash/isSymbol.js","webpack://Autodesk.Extensions.[name]/./node_modules/lodash/now.js","webpack://Autodesk.Extensions.[name]/./node_modules/lodash/throttle.js","webpack://Autodesk.Extensions.[name]/./node_modules/lodash/toNumber.js","webpack://Autodesk.Extensions.[name]/(webpack)/buildin/global.js","webpack://Autodesk.Extensions.[name]/./src/wgs/render/ShaderChunks.js","webpack://Autodesk.Extensions.[name]/./src/wgs/render/chunks/cutplanes.glsl","webpack://Autodesk.Extensions.[name]/./src/wgs/render/chunks/decl_point_size.glsl","webpack://Autodesk.Extensions.[name]/./src/wgs/render/chunks/depth_texture.glsl","webpack://Autodesk.Extensions.[name]/./src/wgs/render/chunks/env_sample.glsl","webpack://Autodesk.Extensions.[name]/./src/wgs/render/chunks/final_frag.glsl","webpack://Autodesk.Extensions.[name]/./src/wgs/render/chunks/float3_average.glsl","webpack://Autodesk.Extensions.[name]/./src/wgs/render/chunks/hatch_pattern.glsl","webpack://Autodesk.Extensions.[name]/./src/wgs/render/chunks/hsv.glsl","webpack://Autodesk.Extensions.[name]/./src/wgs/render/chunks/id_decl_frag.glsl","webpack://Autodesk.Extensions.[name]/./src/wgs/render/chunks/id_decl_vert.glsl","webpack://Autodesk.Extensions.[name]/./src/wgs/render/chunks/id_frag.glsl","webpack://Autodesk.Extensions.[name]/./src/wgs/render/chunks/id_vert.glsl","webpack://Autodesk.Extensions.[name]/./src/wgs/render/chunks/instancing_decl_vert.glsl","webpack://Autodesk.Extensions.[name]/./src/wgs/render/chunks/line_decl_common.glsl","webpack://Autodesk.Extensions.[name]/./src/wgs/render/chunks/normal_map.glsl","webpack://Autodesk.Extensions.[name]/./src/wgs/render/chunks/ordered_dither.glsl","webpack://Autodesk.Extensions.[name]/./src/wgs/render/chunks/pack_depth.glsl","webpack://Autodesk.Extensions.[name]/./src/wgs/render/chunks/pack_normals.glsl","webpack://Autodesk.Extensions.[name]/./src/wgs/render/chunks/point_size.glsl","webpack://Autodesk.Extensions.[name]/./src/wgs/render/chunks/prism_glazing.glsl","webpack://Autodesk.Extensions.[name]/./src/wgs/render/chunks/prism_transparency.glsl","webpack://Autodesk.Extensions.[name]/./src/wgs/render/chunks/prism_wood.glsl","webpack://Autodesk.Extensions.[name]/./src/wgs/render/chunks/shadowmap_decl_common.glsl","webpack://Autodesk.Extensions.[name]/./src/wgs/render/chunks/shadowmap_decl_frag.glsl","webpack://Autodesk.Extensions.[name]/./src/wgs/render/chunks/shadowmap_decl_vert.glsl","webpack://Autodesk.Extensions.[name]/./src/wgs/render/chunks/shadowmap_vert.glsl","webpack://Autodesk.Extensions.[name]/./src/wgs/render/chunks/theming_decl_frag.glsl","webpack://Autodesk.Extensions.[name]/./src/wgs/render/chunks/theming_frag.glsl","webpack://Autodesk.Extensions.[name]/./src/wgs/render/chunks/tonemap.glsl","webpack://Autodesk.Extensions.[name]/./src/wgs/render/chunks/wide_lines_decl.glsl","webpack://Autodesk.Extensions.[name]/./src/wgs/render/chunks/wide_lines_vert.glsl","webpack://Autodesk.Extensions.[name]/./src/wgs/render/shaders/screen_quad_uv_vert.glsl"],"sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./extensions/DOF/DOFExtension.js\");\n","import { DOFRenderContext } from \"./DOFRenderContext\";\nimport { DOFRenderOptionsPanel } from \"./DOFRenderOptionsPanel\";\nimport DOFTool from \"./DOFTool\";\nimport { locales } from \"./DOFLocales\";\n\nvar Extension = Autodesk.Viewing.Extension;\n\nexport function DOFExtension(viewer, options) {\n  Extension.call(this, viewer, options);\n\n  this.openPanel = this.openPanel.bind(this);\n}\n\nDOFExtension.prototype = Object.create(Autodesk.Viewing.Extension.prototype);\nDOFExtension.prototype.constructor = DOFExtension;\n\n/**\n                                                    * Load the Depth of Field extension.\n                                                    * It will fail to load when running a headless viewer.\n                                                    */\nDOFExtension.prototype.load = function () {\n  this.extendLocalization(locales);\n\n  this.dofRenderContext = new DOFRenderContext(this.viewer.impl.renderer(), this.viewer);\n  this.dofRenderContext.load();\n  this.viewer.impl.renderer().postShadingManager().registerPostProcessingExtension(this.dofRenderContext);\n\n  this.tool = new DOFTool(this.viewer, this);\n  this.viewer.toolController.registerTool(this.tool);\n\n  this.firstTime = true;\n\n  // Create UI by default. Panel could be found in the viewer settings panel.\n  if (this.options.createUI !== false) {\n    this.panel = new DOFRenderOptionsPanel(this.viewer, this);\n  }\n\n  return true;\n};\n\n/**\n    * Unload the Depth of Field extension.\n    */\nDOFExtension.prototype.unload = function () {\n  if (this.dofRenderContext) {\n    this.viewer.impl.renderer().postShadingManager().removePostProcessingExtension(this.dofRenderContext);\n    this.viewer.impl.invalidate(true, true, true);\n    this.dofRenderContext = null;\n  }\n\n  if (this.panel) {\n    if (this._configButtonId !== null) {\n      this.viewer.viewerSettingsPanel.removeConfigButton(this._configButtonId);\n      this._configButtonId = null;\n    }\n\n    this.panel.setVisible(false);\n    this.panel.destroy();\n    this.panel = null;\n  }\n\n  return true;\n};\n\nDOFExtension.prototype.getInitialFocalPlane = function (params) {\n  var customDistance = parseFloat(Autodesk.Viewing.Private.getParameterByName('focalPlane')) || this.options.focalPlane;\n\n  if (customDistance) {\n    return customDistance;\n  }\n\n  // Cast a ray from camera to the object in the center of the screen, and use it as a default value.\n  var camera = this.viewer.getCamera();\n  var eyeVec = camera.target.clone().sub(camera.position).normalize();\n  var hit = this.viewer.impl.rayIntersect(new THREE.Ray(camera.position, eyeVec));\n\n  if (hit) {\n    var toMeters = this.viewer.impl.renderer().getUnitScale();\n    return hit.distance * toMeters;\n  }\n\n  return 2; // Fallback - 2 meters from camera.\n};\n\nDOFExtension.prototype.loadDefaultValues = function () {\n  var defaultFocalLength = parseFloat(Autodesk.Viewing.Private.getParameterByName(\"focalLength\")) || this.options.focalLength || this.getFocalLength();\n  var defaultFstop = parseFloat(Autodesk.Viewing.Private.getParameterByName('fStop')) || this.options.fStop || 8;\n  var defaultMaxBlur = parseFloat(Autodesk.Viewing.Private.getParameterByName('maxBlur')) || this.options.maxBlur || 2.0;\n  var defaultBlurQuality = parseFloat(Autodesk.Viewing.Private.getParameterByName('blurQuality')) || this.options.blurQuality || 8.0;\n  var defaultFocalPlane = this.getInitialFocalPlane();\n  var defaultUseCursor = Autodesk.Viewing.Private.getParameterByName(\"blurUseCursor\") === 'true' || this.options.blurUseCursor || false;\n  var defaultDebug = Autodesk.Viewing.Private.getParameterByName(\"blurDebug\") === 'true' || this.options.blurDebug || false;\n\n  this.setFocalLength(defaultFocalLength);\n  this.setFStop(defaultFstop);\n  this.setMaxBlur(defaultMaxBlur);\n  this.setBlurQuality(defaultBlurQuality);\n  this.setFocalPlane(defaultFocalPlane);\n  this.setUseCursor(defaultUseCursor);\n  this.setDebug(defaultDebug);\n};\n\nDOFExtension.prototype.onToolbarCreated = function () {\n  if (this.panel) {\n    this._initButtonConfig();\n  }\n};\n\n/**\n    * Adds a button to the Settings Panel.\n    * @private\n    */\nDOFExtension.prototype._initButtonConfig = function () {\n  var settingsPanel = this.viewer.getSettingsPanel();\n  if (!settingsPanel) {\n    this.addEventListener(Autodesk.Viewing.SETTINGSpanel_CREATED_EVENT, this._initButtonConfig, { once: true });\n    return;\n  }\n  this._configButtonId = settingsPanel.addConfigButton(\"Depth of Field\", this.openPanel);\n};\n\nDOFExtension.prototype.openPanel = function () {var _this$panel;\n  this.setEnabled(true);\n  (_this$panel = this.panel) === null || _this$panel === void 0 ? void 0 : _this$panel.setVisible(true);\n};\n\nDOFExtension.prototype.activate = function () {var _this$panel2;\n  // Already active\n  if (this.isActive()) {\n    return;\n  }\n\n  if (this.firstTime) {\n    this.firstTime = false;\n\n    // Although it does work with orthographic, DOF works much better with perspective camera.\n    this.viewer.navigation.toPerspective();\n\n    this.loadDefaultValues();\n  }\n\n  this.dofRenderContext.enable();\n\n  if (this.useCursor && !this.viewer.toolController.isToolActivated(this.tool.getName())) {\n    this.viewer.toolController.activateTool(this.tool.getName());\n  }\n\n  (_this$panel2 = this.panel) === null || _this$panel2 === void 0 ? void 0 : _this$panel2.enabledToggle.setValue(true);\n\n  this.activeStatus = true;\n};\n\nDOFExtension.prototype.deactivate = function () {var _this$panel3;\n  // Already inactive.\n  if (!this.isActive()) {\n    return;\n  }\n\n  this.dofRenderContext.disable();\n\n  if (this.useCursor && this.viewer.toolController.isToolActivated(this.tool.getName())) {\n    this.viewer.toolController.deactivateTool(this.tool.getName());\n  }\n\n  (_this$panel3 = this.panel) === null || _this$panel3 === void 0 ? void 0 : _this$panel3.enabledToggle.setValue(false);\n\n  this.activeStatus = false;\n};\n\nDOFExtension.prototype.setEnabled = function (enable) {\n  if (enable) {\n    this.activate();\n  } else {\n    this.deactivate();\n  }\n};\n\nDOFExtension.prototype.getUseCursor = function () {\n  return this.useCursor;\n};\n\nDOFExtension.prototype.setUseCursor = function (enable) {var _this$panel4;\n  this.useCursor = enable;\n\n  if (enable) {\n    this.viewer.toolController.activateTool(this.tool.getName());\n  } else {\n    this.viewer.toolController.deactivateTool(this.tool.getName());\n  }\n\n  (_this$panel4 = this.panel) === null || _this$panel4 === void 0 ? void 0 : _this$panel4.setUseCursor(enable);\n};\n\nDOFExtension.prototype.getDebug = function () {\n  return this.dofRenderContext.getDefineValue(\"DEBUG\");\n};\n\nDOFExtension.prototype.setDebug = function (enable) {var _this$panel5;\n  this.dofRenderContext.updateDefineValue(\"DEBUG\", enable ? true : null);\n  (_this$panel5 = this.panel) === null || _this$panel5 === void 0 ? void 0 : _this$panel5.debug.setValue(enable);\n};\n\nDOFExtension.prototype.getFStop = function () {\n  return this.dofRenderContext.getUniformValue(\"fStop\");\n};\n\nDOFExtension.prototype.setFStop = function (value) {var _this$panel6;\n  this.dofRenderContext.updateUniformValue(\"fStop\", value);\n  (_this$panel6 = this.panel) === null || _this$panel6 === void 0 ? void 0 : _this$panel6.fStop.setValue(value);\n};\n\n// Value in meters\nDOFExtension.prototype.getFocalPlane = function () {\n  return this.dofRenderContext.getUniformValue(\"focalPlane\");\n};\n\n// Value in meters\nDOFExtension.prototype.setFocalPlane = function (value) {var _this$panel7;\n  this.dofRenderContext.updateUniformValue(\"focalPlane\", value);\n  (_this$panel7 = this.panel) === null || _this$panel7 === void 0 ? void 0 : _this$panel7.setFocalPlane(value);\n};\n\nDOFExtension.prototype.getMaxBlur = function () {\n  return this.dofRenderContext.getUniformValue(\"maxBlur\");\n};\n\nDOFExtension.prototype.setMaxBlur = function (value) {var _this$panel8;\n  this.dofRenderContext.updateUniformValue(\"maxBlur\", value);\n  (_this$panel8 = this.panel) === null || _this$panel8 === void 0 ? void 0 : _this$panel8.maxBlur.setValue(value);\n};\n\nDOFExtension.prototype.getFocalLength = function () {\n  return Autodesk.Viewing.Navigation.prototype.fov2fl(this.viewer.getCamera().fov);\n};\n\nDOFExtension.prototype.setFocalLength = function (value) {\n  // No need to explicitly update the DOF panel. It has an event listener on the camera.\n  this.viewer.setFocalLength(value);\n};\n\nDOFExtension.prototype.getBlurQuality = function () {\n  return this.dofRenderContext.getDefineValue(\"BLUR_QUALITY\");\n};\n\nDOFExtension.prototype.setBlurQuality = function (value) {var _this$panel9;\n  this.dofRenderContext.updateDefineValue(\"BLUR_QUALITY\", value);\n  (_this$panel9 = this.panel) === null || _this$panel9 === void 0 ? void 0 : _this$panel9.blurQuality.setValue(value);\n};\n\n/**\n    * Register the extension with the extension manager.\n    */\nAutodesk.Viewing.theExtensionManager.registerExtension('Autodesk.DOF', DOFExtension);","/**\n * Include each locale json file and return it in an object\n * that can be consumed by i18n\n */\n\nimport json_en from '../../res/locales/en/nobundle-dof.loc.json';\n\nexport var locales = {\n  en: json_en };","import { DOFShader } from './DOFShader';\n\nvar ShaderPass = Autodesk.Viewing.Private.ShaderPass;\nvar RenderContextPostProcessExtension = Autodesk.Viewing.Private.RenderContextPostProcessExtension;\n\nvar av = Autodesk.Viewing;\n\nvar DOFRenderContext = function DOFRenderContext(renderContext, viewer) {\n  RenderContextPostProcessExtension.call(this, renderContext, viewer);\n\n  // Make sure to render DOF before other post processing passes.\n  this.getOrder = function () {\n    return 0;\n  };\n\n  // This flag is needed in order to render the DOF pass only after the selection overlay has been rendered - it looks a lot better.\n  this.shouldRenderAfterOverlays = function () {\n    return true;\n  };\n\n  this.load = function () {\n    this.postProcPass = new ShaderPass(DOFShader);\n    this.renderContext.setNoDepthNoBlend(this.postProcPass);\n  };\n};\n\nDOFRenderContext.prototype = Object.create(RenderContextPostProcessExtension.prototype);\nDOFRenderContext.prototype.constructor = DOFRenderContext;\nav.GlobalManagerMixin.call(DOFRenderContext.prototype);\n\nexport { DOFRenderContext };","\n'use strict';\n\nvar TAB_ID = 'configTab';\nvar TAB_LABEL = 'Configuration';\n\nvar DOFRenderOptionsPanel = function DOFRenderOptionsPanel(viewer, dofExtension) {var _this = this;\n  var PANEL_ID = 'adsk_dof_renderoptions_panel_' + viewer.id;\n  var opts = { heightAdjustment: 90, width: 500 };\n  Autodesk.Viewing.UI.SettingsPanel.call(this, viewer.container, PANEL_ID, 'Depth of Field', opts);\n  this.setGlobalManager(viewer.globalManager);\n  this.container.classList.add('viewer-settings-panel');\n  this.viewer = viewer;\n\n  // Add a default tab called Render Options\n  this.addTab(TAB_ID, TAB_LABEL, { className: 'config' });\n  this.selectTab(TAB_ID);\n\n  // Checkbox \"Enabled\"\n  var enabledToggleId = this.addCheckbox(TAB_ID, 'Enabled', false, function (checked) {\n    dofExtension.setEnabled(checked);\n  });\n\n  this.enabledToggle = this.getControl(enabledToggleId);\n\n  // Slider Focal Length\n  var focalLengthId = this.addSlider(TAB_ID, 'Focal Length (mm)',\n  10.0, 200.0, 10,\n  function (event) {\n    var value = event.detail.value;\n    dofExtension.setFocalLength(parseFloat(value));\n  },\n  { step: 1 });\n\n  this.focalLength = this.getControl(focalLengthId);\n\n  this.viewer.addEventListener(Autodesk.Viewing.CAMERA_CHANGE_EVENT, function () {\n    var myFocalLength = parseFloat(_this.focalLength.value);\n    var camFocalLength = viewer.getFocalLength();\n\n    if (myFocalLength != camFocalLength) _this.focalLength.setValue(camFocalLength);\n  });\n\n  // Slider \"f-stop\"\n  var fStopId = this.addSlider(TAB_ID, 'f-stop (Aperture)',\n  2.0, 22.0, 1.4,\n  function (event) {\n    var value = event.detail.value;\n    dofExtension.setFStop(parseFloat(value));\n  },\n  { step: 0.1 });\n\n  this.fStop = this.getControl(fStopId);\n\n  // Slider \"Max Blur\"\n  var maxBlurId = this.addSlider(TAB_ID, 'Max Blur',\n  1, 3, 2,\n  function (event) {\n    var value = event.detail.value;\n    dofExtension.setMaxBlur(parseFloat(value));\n  },\n  { step: 0.1 });\n\n  this.maxBlur = this.getControl(maxBlurId);\n\n  // Slider \"Blur Quality\"\n  var blurSizeId = this.addSlider(TAB_ID, 'Blur Quality',\n  1, 16, 8,\n  function (event) {\n    var value = event.detail.value;\n    dofExtension.setBlurQuality(value);\n  },\n  { step: 1 });\n\n  this.blurQuality = this.getControl(blurSizeId);\n\n  // Checkbox \"Use Cursor\"\n  var useCursor = this.addCheckbox(TAB_ID, 'Focus on Cursor', false, function (checked) {\n    dofExtension.setUseCursor(checked);\n    _this.setUseCursor(checked);\n  });\n\n  this.useCursor = this.getControl(useCursor);\n\n  this.setUseCursor = function (checked) {\n    _this.focalPlane.setDisabled(checked);\n\n    if (!checked) {\n      var focalPlane = parseFloat(_this.focalPlane.value);\n      dofExtension.setFocalPlane(focalPlane * _this.unitsToMeters);\n    }\n  };\n\n  // Slider \"Focal Plane\"\n  var focalPlaneId = this.addSlider(TAB_ID, 'Focal Plane',\n  0.01, 50.0, 1,\n  function (event) {\n    var value = event.detail.value;\n    dofExtension.setFocalPlane(parseFloat(value) * _this.unitsToMeters);\n  },\n  { step: 0.1 });\n\n\n  this.focalPlane = this.getControl(focalPlaneId);\n\n  // Finding the \"correct\" range for the focal plane is hard.\n  // If we use a constant value, we might end up with a really long range for tiny models, or really short range for large models.\n  // In order to find the right range - we need to consider:\n  // - Display units - if we are viewing the model in `mm`, it's a good asumption that the focal plane won't be 1000 meters from the camera.\n  // - Visible bounds - the hard coded \"maxInMeters\" values are the upper bound of the range. If we find out that we a have a model that is relativaly small, but our\n  // display units in meters - we can make the range tighter according to the bounding box of the model.\n  // Bear in mind that this is just a heuristic. Another possible solution for this is to take the camera distance from the model into account.\n  var updateFocalPlaneRange = function updateFocalPlaneRange() {var _this$viewer$getExten;\n    var units = ((_this$viewer$getExten = _this.viewer.getExtension(\"Autodesk.Measure\")) === null || _this$viewer$getExten === void 0 ? void 0 : _this$viewer$getExten.getUnits()) || 'm';\n    var unitsString = Autodesk.Viewing.i18n.translate(Autodesk.Viewing.Private.displayUnits[Autodesk.Viewing.Private.displayUnitsEnum.indexOf(units)]);\n    _this.focalPlane.caption.textContent = \"\".concat(Autodesk.Viewing.i18n.translate(\"Focal Plane\"), \" (\").concat(unitsString, \")\");\n\n    var minInMeters;\n    var maxInMeters;\n    var step;\n\n    switch (units) {\n      case 'mm':\n      case 'pt':\n        minInMeters = 0.001;\n        maxInMeters = 10;\n        step = 1;\n        break;\n      case 'cm':\n      case 'in':\n      case 'fractional-in':\n      case 'decimal-in':\n        minInMeters = 0.01;\n        maxInMeters = 50;\n        step = 0.1;\n        break;\n      case 'm':\n      case 'm-and-cm':\n      case 'ft-and-decimal-in':\n      case 'ft':\n      case 'ft-and-fractional-in':\n      case 'decimal-ft':\n      default:\n        minInMeters = 0.05;\n        maxInMeters = 100;\n        step = 0.01;\n        break;}\n\n\n    var bounds = _this.viewer.impl.getVisibleBounds(true);\n    var toMeters = _this.viewer.impl.renderer().getUnitScale();\n    var size = bounds.size();\n\n    // Set the max range to be 5 times of the visible bounds size.\n    var maxModelBounds = 5 * Math.max(size.x, size.y, size.z) * toMeters;\n    maxInMeters = Math.min(maxModelBounds, maxInMeters);\n\n    _this.unitsToMeters = Autodesk.Viewing.Private.convertUnits(units, 'm', 1, 1);\n\n    var min = parseFloat((minInMeters / _this.unitsToMeters).toFixed(3));\n    var max = parseFloat((maxInMeters / _this.unitsToMeters).toFixed(3));\n\n\n    _this.focalPlane.sliderElement.min = min;\n    _this.focalPlane.stepperElement.min = min;\n    _this.focalPlane.sliderElement.max = max;\n    _this.focalPlane.stepperElement.max = max;\n    _this.focalPlane.sliderElement.step = step;\n\n    // Update values according to the new units.\n    dofExtension.setFocalPlane(dofExtension.getFocalPlane());\n  };\n\n  updateFocalPlaneRange();\n\n  this.setFocalPlane = function (value) {\n    _this.focalPlane.setValue(parseFloat((value / _this.unitsToMeters).toFixed(3)));\n  };\n\n  // Checkbox \"Debug\"\n  var debug = this.addCheckbox(TAB_ID, 'Debug DOF', false, function (checked) {\n    dofExtension.setDebug(checked);\n  });\n  this.debug = this.getControl(debug);\n\n  this.viewer.addEventListener(Autodesk.Viewing.MODEL_ROOT_LOADED_EVENT, updateFocalPlaneRange);\n  this.viewer.addEventListener(Autodesk.Viewing.MeasureCommon.Events.DISPLAY_UNITS_CHANGED, updateFocalPlaneRange);\n\n  this.destroy = function () {\n    _this.viewer.removeEventListener(Autodesk.Viewing.MODEL_ROOT_LOADED_EVENT, updateFocalPlaneRange);\n    _this.viewer.removeEventListener(Autodesk.Viewing.MeasureCommon.Events.DISPLAY_UNITS_CHANGED, updateFocalPlaneRange);\n  };\n};\n\nDOFRenderOptionsPanel.prototype = Object.create(Autodesk.Viewing.UI.SettingsPanel.prototype);\nDOFRenderOptionsPanel.prototype.constructor = DOFRenderOptionsPanel;\n\nexport { DOFRenderOptionsPanel };","import * as THREE from \"three\";\nimport { ShaderChunks as chunks } from \"../../src/wgs/render/ShaderChunks\";\nimport screen_quad_uv_vert from \"../../src/wgs/render/shaders/screen_quad_uv_vert.glsl\";\nimport dofFrag from \"./Shader/dof_frag.glsl\";\n\nexport var DOFShader = {\n  uniforms: THREE.UniformsUtils.merge([\n  chunks.DepthTextureUniforms,\n\n  {\n    tDiffuse: { type: \"t\", value: null },\n    resolution: { type: \"v2\", value: new THREE.Vector2(1 / 1024, 1 / 512) },\n    cameraNear: { type: \"f\", value: 1 },\n    cameraFar: { type: \"f\", value: 100 },\n    fStop: { type: \"f\", value: 22.0 },\n    focalLength: { type: \"f\", value: 100.0 }, // in mm.\n    focalPlane: { type: \"f\", value: 5.0 }, // in meters.\n    unitScale: { type: \"f\", value: 1.0 }, // conversion from model units to meters.\n    maxBlur: { type: \"f\", value: 2.0 }, // max blur multiplier.\n    cameraPos: { type: \"v3\", value: new THREE.Vector3() } }]),\n\n\n\n  vertexShader: screen_quad_uv_vert,\n  fragmentShader: dofFrag };","function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError(\"Cannot call a class as a function\");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}var throttle = require(\"lodash/throttle\");\n\nvar GlobalManagerMixin = Autodesk.Viewing.GlobalManagerMixin;\n\nvar AnimDuration = 0.25; // s\nvar ThrottleDuration = 100; // ms\n\n/**\n * Provides functionality for changing focal plane according to the cursor position.\n **/var\nDOFTool = /*#__PURE__*/function () {\n  function DOFTool(viewer, dofExtension) {var _this = this;_classCallCheck(this, DOFTool);\n    this.viewer = viewer;\n    this.dofExtension = dofExtension;\n\n    // Is tool active.\n    this.active = false;\n\n    // Tool name.\n    this.names = [\"dof-tool\"];\n\n    this.lastMousePos = new THREE.Vector2();\n\n    this.onCameraChange = this.onCameraChange.bind(this);\n\n    this.updateFocalPlaneThrottled = throttle(function (targetFocalPlane) {\n      if (_this.anim) {\n        _this.anim.stop();\n        _this.anim = null;\n      }\n\n      var startValue = _this.dofExtension.getFocalPlane();\n\n      _this.anim = Autodesk.Viewing.Private.fadeValue(startValue, targetFocalPlane, AnimDuration, function (value) {\n        _this.dofExtension.setFocalPlane(value);\n      }, function () {\n        _this.anim = null;\n      });\n    }, ThrottleDuration);\n  }_createClass(DOFTool, [{ key: \"getNames\", value: function getNames()\n\n    {\n      return this.names;\n    } }, { key: \"getName\", value: function getName()\n\n    {\n      return this.names[0];\n    } }, { key: \"getPriority\", value: function getPriority()\n\n    {\n      return 1000;\n    } }, { key: \"isActive\", value: function isActive()\n\n    {\n      return this.active;\n    } }, { key: \"activate\", value: function activate()\n\n    {\n      if (this.isActive()) {\n        return;\n      }\n\n      this.viewer.addEventListener(Autodesk.Viewing.CAMERA_CHANGE_EVENT, this.onCameraChange);\n\n      this.active = true;\n    } }, { key: \"deactivate\", value: function deactivate()\n\n    {\n      if (!this.isActive()) {\n        return;\n      }\n\n      this.viewer.removeEventListener(Autodesk.Viewing.CAMERA_CHANGE_EVENT, this.onCameraChange);\n\n      if (this.anim) {\n        this.anim.stop();\n        this.anim = null;\n      }\n\n      this.active = false;\n    }\n\n    // In case that the camera moved and the mouse didn't (bimwalk / wheel) - update.\n  }, { key: \"onCameraChange\", value: function onCameraChange() {\n      return this.handleMouseMove({ canvasX: this.lastMousePos.x, canvasY: this.lastMousePos.y });\n    } }, { key: \"handleMouseMove\", value: function handleMouseMove(\n\n    event) {\n      this.lastMousePos.set(event.canvasX, event.canvasY);\n\n      var result = this.viewer.impl.snappingHitTest(event.canvasX, event.canvasY);\n      var cameraPos = this.viewer.getCamera().position;\n\n      var target = result === null || result === void 0 ? void 0 : result.intersectPoint;\n\n      if (!target) {\n        return false;\n      }\n\n      var targetFocalPlane = cameraPos.distanceTo(target) * this.viewer.impl.renderer().getUnitScale();\n\n      this.updateFocalPlaneThrottled(targetFocalPlane);\n\n      // don't consume event\n      return false;\n    } }]);return DOFTool;}();export { DOFTool as default };\n\n\nGlobalManagerMixin.call(DOFTool.prototype);","module.exports = \"\\nuniform sampler2D tDiffuse;\\nvarying vec2 vUv;\\nuniform vec2 resolution;\\nuniform float fStop;\\nuniform float focalLength;\\nuniform vec3 cameraPos;\\nuniform float unitScale;\\nuniform float focalPlane;\\nuniform float maxBlur;\\n#include<depth_texture>\\n#define TAU 6.28318530718\\n#define DIRECTIONS 16.\\nfloat COC = 0.03;\\nvec4 debugFocus(float blur){    \\n    vec4 color = texture2D(tDiffuse,vUv);\\n    color = mix(color, vec4(0.,0.,0.,1.), min(0.95, blur));\\n    return color;\\n}\\nfloat calculateBlur() {\\n    float subjectDistance = focalPlane*1000.;\\n    vec3 worldPos = reconstructWorldPosition(gl_FragCoord.xy, vUv);\\n    float unitScaleMM = unitScale * 1000.;\\n    worldPos *= unitScaleMM;\\n    vec3 cameraPosMM = vec3(cameraPos) * unitScaleMM;\\n    float pixelDistance = distance(worldPos, cameraPosMM);\\n    float hyperfocalDistance = (focalLength * focalLength) / (fStop * COC);\\n    float DOFNear = (hyperfocalDistance * subjectDistance) / (hyperfocalDistance + (subjectDistance - focalLength));\\n    float DOFFar = (hyperfocalDistance * subjectDistance) / (hyperfocalDistance - (subjectDistance - focalLength));\\n    float dist = subjectDistance - pixelDistance;\\n    float blur;\\n    if (dist > 0.) {\\n        if (DOFNear < 0.) {\\n            blur = 0.;\\n        } else {\\n            blur = dist / (subjectDistance - DOFNear);    \\n        }\\n    } else {\\n        if (DOFFar < 0.) {\\n            blur = 0.;\\n        } else {\\n            blur = -dist / (DOFFar - subjectDistance);\\n        }\\n    }\\n    float logScale = log(blur+1.) / log(2.);\\n    blur = clamp(0., maxBlur, logScale);\\n    return blur;\\n}\\nvec4 gaussianBlur(float blurAmount) {\\n    vec4 color=texture2D(tDiffuse,vUv);\\n    float quality = float(BLUR_QUALITY);\\n    float radius = 8. * blurAmount;\\n    for(float d = 0.; d < DIRECTIONS; d++)\\n    {\\n        float angle= d * TAU / DIRECTIONS;\\n        vec2 angleVec = vec2(cos(angle),sin(angle));\\n        for(int i = 1; i <= BLUR_QUALITY; i++)\\n        {\\n            float distance = radius * (float(i) / quality);\\n            color += texture2D(tDiffuse, vUv.xy + angleVec * resolution * distance );\\n        }\\n    }\\n    \\n    color /= quality * DIRECTIONS;\\n    return color;\\n}\\nvoid main() {\\n    float blur = calculateBlur();\\n    #ifdef DEBUG\\n    vec4 color = debugFocus(blur);\\n    #else\\n    vec4 color = gaussianBlur(blur);\\n    #endif\\n    gl_FragColor = color;\\n}\\n\";","var root = require('./_root');\n\n/** Built-in value references. */\nvar Symbol = root.Symbol;\n\nmodule.exports = Symbol;\n","var Symbol = require('./_Symbol'),\n    getRawTag = require('./_getRawTag'),\n    objectToString = require('./_objectToString');\n\n/** `Object#toString` result references. */\nvar nullTag = '[object Null]',\n    undefinedTag = '[object Undefined]';\n\n/** Built-in value references. */\nvar symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n/**\n * The base implementation of `getTag` without fallbacks for buggy environments.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nfunction baseGetTag(value) {\n  if (value == null) {\n    return value === undefined ? undefinedTag : nullTag;\n  }\n  return (symToStringTag && symToStringTag in Object(value))\n    ? getRawTag(value)\n    : objectToString(value);\n}\n\nmodule.exports = baseGetTag;\n","var trimmedEndIndex = require('./_trimmedEndIndex');\n\n/** Used to match leading whitespace. */\nvar reTrimStart = /^\\s+/;\n\n/**\n * The base implementation of `_.trim`.\n *\n * @private\n * @param {string} string The string to trim.\n * @returns {string} Returns the trimmed string.\n */\nfunction baseTrim(string) {\n  return string\n    ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, '')\n    : string;\n}\n\nmodule.exports = baseTrim;\n","/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\nmodule.exports = freeGlobal;\n","var Symbol = require('./_Symbol');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/** Built-in value references. */\nvar symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n/**\n * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the raw `toStringTag`.\n */\nfunction getRawTag(value) {\n  var isOwn = hasOwnProperty.call(value, symToStringTag),\n      tag = value[symToStringTag];\n\n  try {\n    value[symToStringTag] = undefined;\n    var unmasked = true;\n  } catch (e) {}\n\n  var result = nativeObjectToString.call(value);\n  if (unmasked) {\n    if (isOwn) {\n      value[symToStringTag] = tag;\n    } else {\n      delete value[symToStringTag];\n    }\n  }\n  return result;\n}\n\nmodule.exports = getRawTag;\n","/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/**\n * Converts `value` to a string using `Object.prototype.toString`.\n *\n * @private\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n */\nfunction objectToString(value) {\n  return nativeObjectToString.call(value);\n}\n\nmodule.exports = objectToString;\n","var freeGlobal = require('./_freeGlobal');\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\nmodule.exports = root;\n","/** Used to match a single whitespace character. */\nvar reWhitespace = /\\s/;\n\n/**\n * Used by `_.trim` and `_.trimEnd` to get the index of the last non-whitespace\n * character of `string`.\n *\n * @private\n * @param {string} string The string to inspect.\n * @returns {number} Returns the index of the last non-whitespace character.\n */\nfunction trimmedEndIndex(string) {\n  var index = string.length;\n\n  while (index-- && reWhitespace.test(string.charAt(index))) {}\n  return index;\n}\n\nmodule.exports = trimmedEndIndex;\n","var isObject = require('./isObject'),\n    now = require('./now'),\n    toNumber = require('./toNumber');\n\n/** Error message constants. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeMax = Math.max,\n    nativeMin = Math.min;\n\n/**\n * Creates a debounced function that delays invoking `func` until after `wait`\n * milliseconds have elapsed since the last time the debounced function was\n * invoked. The debounced function comes with a `cancel` method to cancel\n * delayed `func` invocations and a `flush` method to immediately invoke them.\n * Provide `options` to indicate whether `func` should be invoked on the\n * leading and/or trailing edge of the `wait` timeout. The `func` is invoked\n * with the last arguments provided to the debounced function. Subsequent\n * calls to the debounced function return the result of the last `func`\n * invocation.\n *\n * **Note:** If `leading` and `trailing` options are `true`, `func` is\n * invoked on the trailing edge of the timeout only if the debounced function\n * is invoked more than once during the `wait` timeout.\n *\n * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\n * until to the next tick, similar to `setTimeout` with a timeout of `0`.\n *\n * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\n * for details over the differences between `_.debounce` and `_.throttle`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to debounce.\n * @param {number} [wait=0] The number of milliseconds to delay.\n * @param {Object} [options={}] The options object.\n * @param {boolean} [options.leading=false]\n *  Specify invoking on the leading edge of the timeout.\n * @param {number} [options.maxWait]\n *  The maximum time `func` is allowed to be delayed before it's invoked.\n * @param {boolean} [options.trailing=true]\n *  Specify invoking on the trailing edge of the timeout.\n * @returns {Function} Returns the new debounced function.\n * @example\n *\n * // Avoid costly calculations while the window size is in flux.\n * jQuery(window).on('resize', _.debounce(calculateLayout, 150));\n *\n * // Invoke `sendMail` when clicked, debouncing subsequent calls.\n * jQuery(element).on('click', _.debounce(sendMail, 300, {\n *   'leading': true,\n *   'trailing': false\n * }));\n *\n * // Ensure `batchLog` is invoked once after 1 second of debounced calls.\n * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });\n * var source = new EventSource('/stream');\n * jQuery(source).on('message', debounced);\n *\n * // Cancel the trailing debounced invocation.\n * jQuery(window).on('popstate', debounced.cancel);\n */\nfunction debounce(func, wait, options) {\n  var lastArgs,\n      lastThis,\n      maxWait,\n      result,\n      timerId,\n      lastCallTime,\n      lastInvokeTime = 0,\n      leading = false,\n      maxing = false,\n      trailing = true;\n\n  if (typeof func != 'function') {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  wait = toNumber(wait) || 0;\n  if (isObject(options)) {\n    leading = !!options.leading;\n    maxing = 'maxWait' in options;\n    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;\n    trailing = 'trailing' in options ? !!options.trailing : trailing;\n  }\n\n  function invokeFunc(time) {\n    var args = lastArgs,\n        thisArg = lastThis;\n\n    lastArgs = lastThis = undefined;\n    lastInvokeTime = time;\n    result = func.apply(thisArg, args);\n    return result;\n  }\n\n  function leadingEdge(time) {\n    // Reset any `maxWait` timer.\n    lastInvokeTime = time;\n    // Start the timer for the trailing edge.\n    timerId = setTimeout(timerExpired, wait);\n    // Invoke the leading edge.\n    return leading ? invokeFunc(time) : result;\n  }\n\n  function remainingWait(time) {\n    var timeSinceLastCall = time - lastCallTime,\n        timeSinceLastInvoke = time - lastInvokeTime,\n        timeWaiting = wait - timeSinceLastCall;\n\n    return maxing\n      ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke)\n      : timeWaiting;\n  }\n\n  function shouldInvoke(time) {\n    var timeSinceLastCall = time - lastCallTime,\n        timeSinceLastInvoke = time - lastInvokeTime;\n\n    // Either this is the first call, activity has stopped and we're at the\n    // trailing edge, the system time has gone backwards and we're treating\n    // it as the trailing edge, or we've hit the `maxWait` limit.\n    return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||\n      (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));\n  }\n\n  function timerExpired() {\n    var time = now();\n    if (shouldInvoke(time)) {\n      return trailingEdge(time);\n    }\n    // Restart the timer.\n    timerId = setTimeout(timerExpired, remainingWait(time));\n  }\n\n  function trailingEdge(time) {\n    timerId = undefined;\n\n    // Only invoke if we have `lastArgs` which means `func` has been\n    // debounced at least once.\n    if (trailing && lastArgs) {\n      return invokeFunc(time);\n    }\n    lastArgs = lastThis = undefined;\n    return result;\n  }\n\n  function cancel() {\n    if (timerId !== undefined) {\n      clearTimeout(timerId);\n    }\n    lastInvokeTime = 0;\n    lastArgs = lastCallTime = lastThis = timerId = undefined;\n  }\n\n  function flush() {\n    return timerId === undefined ? result : trailingEdge(now());\n  }\n\n  function debounced() {\n    var time = now(),\n        isInvoking = shouldInvoke(time);\n\n    lastArgs = arguments;\n    lastThis = this;\n    lastCallTime = time;\n\n    if (isInvoking) {\n      if (timerId === undefined) {\n        return leadingEdge(lastCallTime);\n      }\n      if (maxing) {\n        // Handle invocations in a tight loop.\n        clearTimeout(timerId);\n        timerId = setTimeout(timerExpired, wait);\n        return invokeFunc(lastCallTime);\n      }\n    }\n    if (timerId === undefined) {\n      timerId = setTimeout(timerExpired, wait);\n    }\n    return result;\n  }\n  debounced.cancel = cancel;\n  debounced.flush = flush;\n  return debounced;\n}\n\nmodule.exports = debounce;\n","/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return value != null && (type == 'object' || type == 'function');\n}\n\nmodule.exports = isObject;\n","/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return value != null && typeof value == 'object';\n}\n\nmodule.exports = isObjectLike;\n","var baseGetTag = require('./_baseGetTag'),\n    isObjectLike = require('./isObjectLike');\n\n/** `Object#toString` result references. */\nvar symbolTag = '[object Symbol]';\n\n/**\n * Checks if `value` is classified as a `Symbol` primitive or object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n * @example\n *\n * _.isSymbol(Symbol.iterator);\n * // => true\n *\n * _.isSymbol('abc');\n * // => false\n */\nfunction isSymbol(value) {\n  return typeof value == 'symbol' ||\n    (isObjectLike(value) && baseGetTag(value) == symbolTag);\n}\n\nmodule.exports = isSymbol;\n","var root = require('./_root');\n\n/**\n * Gets the timestamp of the number of milliseconds that have elapsed since\n * the Unix epoch (1 January 1970 00:00:00 UTC).\n *\n * @static\n * @memberOf _\n * @since 2.4.0\n * @category Date\n * @returns {number} Returns the timestamp.\n * @example\n *\n * _.defer(function(stamp) {\n *   console.log(_.now() - stamp);\n * }, _.now());\n * // => Logs the number of milliseconds it took for the deferred invocation.\n */\nvar now = function() {\n  return root.Date.now();\n};\n\nmodule.exports = now;\n","var debounce = require('./debounce'),\n    isObject = require('./isObject');\n\n/** Error message constants. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/**\n * Creates a throttled function that only invokes `func` at most once per\n * every `wait` milliseconds. The throttled function comes with a `cancel`\n * method to cancel delayed `func` invocations and a `flush` method to\n * immediately invoke them. Provide `options` to indicate whether `func`\n * should be invoked on the leading and/or trailing edge of the `wait`\n * timeout. The `func` is invoked with the last arguments provided to the\n * throttled function. Subsequent calls to the throttled function return the\n * result of the last `func` invocation.\n *\n * **Note:** If `leading` and `trailing` options are `true`, `func` is\n * invoked on the trailing edge of the timeout only if the throttled function\n * is invoked more than once during the `wait` timeout.\n *\n * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\n * until to the next tick, similar to `setTimeout` with a timeout of `0`.\n *\n * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\n * for details over the differences between `_.throttle` and `_.debounce`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to throttle.\n * @param {number} [wait=0] The number of milliseconds to throttle invocations to.\n * @param {Object} [options={}] The options object.\n * @param {boolean} [options.leading=true]\n *  Specify invoking on the leading edge of the timeout.\n * @param {boolean} [options.trailing=true]\n *  Specify invoking on the trailing edge of the timeout.\n * @returns {Function} Returns the new throttled function.\n * @example\n *\n * // Avoid excessively updating the position while scrolling.\n * jQuery(window).on('scroll', _.throttle(updatePosition, 100));\n *\n * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.\n * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });\n * jQuery(element).on('click', throttled);\n *\n * // Cancel the trailing throttled invocation.\n * jQuery(window).on('popstate', throttled.cancel);\n */\nfunction throttle(func, wait, options) {\n  var leading = true,\n      trailing = true;\n\n  if (typeof func != 'function') {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  if (isObject(options)) {\n    leading = 'leading' in options ? !!options.leading : leading;\n    trailing = 'trailing' in options ? !!options.trailing : trailing;\n  }\n  return debounce(func, wait, {\n    'leading': leading,\n    'maxWait': wait,\n    'trailing': trailing\n  });\n}\n\nmodule.exports = throttle;\n","var baseTrim = require('./_baseTrim'),\n    isObject = require('./isObject'),\n    isSymbol = require('./isSymbol');\n\n/** Used as references for various `Number` constants. */\nvar NAN = 0 / 0;\n\n/** Used to detect bad signed hexadecimal string values. */\nvar reIsBadHex = /^[-+]0x[0-9a-f]+$/i;\n\n/** Used to detect binary string values. */\nvar reIsBinary = /^0b[01]+$/i;\n\n/** Used to detect octal string values. */\nvar reIsOctal = /^0o[0-7]+$/i;\n\n/** Built-in method references without a dependency on `root`. */\nvar freeParseInt = parseInt;\n\n/**\n * Converts `value` to a number.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to process.\n * @returns {number} Returns the number.\n * @example\n *\n * _.toNumber(3.2);\n * // => 3.2\n *\n * _.toNumber(Number.MIN_VALUE);\n * // => 5e-324\n *\n * _.toNumber(Infinity);\n * // => Infinity\n *\n * _.toNumber('3.2');\n * // => 3.2\n */\nfunction toNumber(value) {\n  if (typeof value == 'number') {\n    return value;\n  }\n  if (isSymbol(value)) {\n    return NAN;\n  }\n  if (isObject(value)) {\n    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;\n    value = isObject(other) ? (other + '') : other;\n  }\n  if (typeof value != 'string') {\n    return value === 0 ? value : +value;\n  }\n  value = baseTrim(value);\n  var isBinary = reIsBinary.test(value);\n  return (isBinary || reIsOctal.test(value))\n    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)\n    : (reIsBadHex.test(value) ? NAN : +value);\n}\n\nmodule.exports = toNumber;\n","var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n","/*\n * Reusable sets of uniforms that can be merged with other uniforms in specific shaders.\n */\n\nimport * as THREE from \"three\";\n\nexport var CutPlanesUniforms = {\n  \"cutplanes\": { type: \"v4v\", value: [] },\n  \"hatchParams\": { type: \"v2\", value: new THREE.Vector2(1.0, 10.0) },\n  \"hatchTintColor\": { type: \"c\", value: new THREE.Color(0xFFFFFF) },\n  \"hatchTintIntensity\": { type: \"f\", value: 1.0 } };\n\n\nexport var IdUniforms = {\n  \"dbId\": { type: \"v3\", value: new THREE.Vector3(0, 0, 0) },\n  \"modelId\": { type: \"v3\", value: new THREE.Vector3(0, 0, 0) } };\n\n\nexport var ThemingUniform = {\n  \"themingColor\": { type: \"v4\", value: new THREE.Vector4(0, 0, 0, 0) } };\n\n\n// Uniforms shared by material shader chunks and ShadowMapShader\n// Included by ShadowMapUniforms below.\nexport var ShadowMapCommonUniforms = {\n  \"shadowESMConstant\": { type: \"f\", value: 0.0 } };\n\n\n// Uniforms needed by material shaders to apply shadow mapping.\nexport var ShadowMapUniforms = THREE.UniformsUtils.merge([\n{\n  \"shadowMap\": { type: \"t\", value: null },\n  \"shadowMapSize\": { type: \"v2\", value: new THREE.Vector2(0, 0) },\n  \"shadowBias\": { type: \"f\", value: 0.0 },\n  \"shadowDarkness\": { type: \"f\", value: 0.0 },\n  \"shadowMatrix\": { type: \"m4\", value: new THREE.Matrix4() },\n  \"shadowLightDir\": { type: \"v3\", value: new THREE.Vector3() } },\n\nShadowMapCommonUniforms]);\n\n\n// Uniform for point-set point size\nexport var PointSizeUniforms = {\n  \"point_size\": { type: \"f\", value: 1.0 } };\n\n\n// Uniform for wide lines shader\nexport var WideLinesUniforms = {\n  \"view_size\": { type: \"v2\", value: new THREE.Vector2(640, 480) } };\n\n\n// Uniforms used for reconstructing positions from depth-texture in post-passes. (depth_texture.glsl)\nexport var DepthTextureUniforms = {\n  \"tDepth\": { type: \"t\", value: null },\n  \"projInfo\": { type: \"v4\", value: new THREE.Vector4() },\n  \"isOrtho\": { type: \"f\", value: 0.0 },\n  \"worldMatrix_mainPass\": { type: \"m4\", value: new THREE.Matrix4() } };\n\n\nexport var DepthTextureTestUniforms = {\n  \"tDepthTest\": { type: \"t\", value: null },\n  \"tDepthResolution\": { type: \"v2\", value: new THREE.Vector2(1 / 1024, 1 / 1024) } };\n\n\n\n/*\n                                                                                       * Chunks are code snippets that can be included in specific shaders\n                                                                                       * using the three.js-style include directive:\n                                                                                       *\n                                                                                       *      #include<name_of_chunk>\n                                                                                       *\n                                                                                       * During runtime this directive can be expanded into the corresponding\n                                                                                       * code snippet using the `resolve` method available below.\n                                                                                       */\nvar chunks = {};\n\n// We include default three.js chunks, too\nfor (var name in THREE.ShaderChunk) {\n  chunks[name] = THREE.ShaderChunk[name];\n}\n\nimport pack_depth from './chunks/pack_depth.glsl';\nimport depth_texture from './chunks/depth_texture.glsl';\nimport tonemap from './chunks/tonemap.glsl';\nimport ordered_dither from './chunks/ordered_dither.glsl';\nimport cutplanes from './chunks/cutplanes.glsl';\nimport pack_normals from './chunks/pack_normals.glsl';\nimport hatch_pattern from './chunks/hatch_pattern.glsl';\nimport env_sample from './chunks/env_sample.glsl';\nimport id_decl_vert from './chunks/id_decl_vert.glsl';\nimport id_vert from './chunks/id_vert.glsl';\nimport id_decl_frag from './chunks/id_decl_frag.glsl';\nimport id_frag from './chunks/id_frag.glsl';\nimport final_frag from './chunks/final_frag.glsl';\nimport theming_decl_frag from './chunks/theming_decl_frag.glsl';\nimport theming_frag from './chunks/theming_frag.glsl';\nimport instancing_decl_vert from './chunks/instancing_decl_vert.glsl';\nimport shadowmap_decl_common from './chunks/shadowmap_decl_common.glsl';\nimport shadowmap_decl_vert from './chunks/shadowmap_decl_vert.glsl';\nimport shadowmap_vert from './chunks/shadowmap_vert.glsl';\nimport shadowmap_decl_frag from './chunks/shadowmap_decl_frag.glsl';\nimport float3_average from './chunks/float3_average.glsl';\nimport line_decl_common from './chunks/line_decl_common.glsl';\nimport prism_wood from './chunks/prism_wood.glsl';\nimport prism_glazing from './chunks/prism_glazing.glsl';\nimport prism_transparency from './chunks/prism_transparency.glsl';\nimport normal_map from './chunks/normal_map.glsl';\nimport decl_point_size from './chunks/decl_point_size.glsl';\nimport point_size from './chunks/point_size.glsl';\nimport wide_lines_decl from './chunks/wide_lines_decl.glsl';\nimport wide_lines_vert from './chunks/wide_lines_vert.glsl';\nimport hsv from './chunks/hsv.glsl';\n\nchunks['pack_depth'] = pack_depth;\nchunks['depth_texture'] = depth_texture;\nchunks['tonemap'] = tonemap;\nchunks['ordered_dither'] = ordered_dither;\nchunks['cutplanes'] = cutplanes;\nchunks['pack_normals'] = pack_normals;\nchunks['hatch_pattern'] = hatch_pattern;\nchunks['env_sample'] = env_sample;\nchunks['id_decl_vert'] = id_decl_vert;\nchunks['id_vert'] = id_vert;\nchunks['id_decl_frag'] = id_decl_frag;\nchunks['id_frag'] = id_frag;\nchunks['final_frag'] = final_frag;\nchunks['theming_decl_frag'] = theming_decl_frag;\nchunks['theming_frag'] = theming_frag;\nchunks['instancing_decl_vert'] = instancing_decl_vert;\nchunks['shadowmap_decl_common'] = shadowmap_decl_common;\nchunks['shadowmap_decl_vert'] = shadowmap_decl_vert;\nchunks['shadowmap_vert'] = shadowmap_vert;\nchunks['shadowmap_decl_frag'] = shadowmap_decl_frag;\nchunks['float3_average'] = float3_average;\nchunks['line_decl_common'] = line_decl_common;\nchunks['prism_wood'] = prism_wood;\nchunks['prism_glazing'] = prism_glazing;\nchunks['prism_transparency'] = prism_transparency;\nchunks['normal_map'] = normal_map;\nchunks['decl_point_size'] = decl_point_size;\nchunks['point_size'] = point_size;\nchunks['wide_lines_decl'] = wide_lines_decl;\nchunks['wide_lines_vert'] = wide_lines_vert;\nchunks['hsv'] = hsv;\n\n/*\n                      * Macros are simple JavaScript functions that can be evaluated from\n                      * within the shader code using a similar syntax as the include directive:\n                      *\n                      *      #name_of_macro<first_param, second_param, third_param, ...>\n                      *\n                      * All parameters are simply passed to the JavaScript code as strings,\n                      * i.e., they are not parsed in any way.\n                      *\n                      * We use this as a way to call the various Prism helper methods (such as\n                      * GetPrismMapsDefinitionChunk below) without having to compose the shader\n                      * code from lists of strings.\n                      */\nvar macros = {};\n\n// If any map type is defined, then do whatever \"content\" is;\n// typically it's \"#define USE_MAP\". In other words, if any map\n// is defined, then USE_MAP will also be defined. This constant\n// is then checked and determines whether a UV variable is defined, etc.\nfunction GetPrismMapsDefinitionChunk(flag) {\n  var def = [\"#if defined( USE_SURFACE_ALBEDO_MAP )\" +\n  \" || defined( USE_SURFACE_ROUGHNESS_MAP )\" +\n  \" || defined( USE_SURFACE_CUTOUT_MAP )\" +\n  \" || defined( USE_SURFACE_ANISOTROPY_MAP )\" +\n  \" || defined( USE_SURFACE_ROTATION_MAP )\" +\n  \" || defined( USE_OPAQUE_ALBEDO_MAP )\" +\n  \" || defined( USE_OPAQUE_F0_MAP )\" +\n  \" || defined( USE_OPAQUE_LUMINANCE_MODIFIER_MAP )\" +\n  \" || defined( USE_LAYERED_BOTTOM_F0_MAP )\" +\n  \" || defined( USE_LAYERED_F0_MAP )\" +\n  \" || defined( USE_LAYERED_DIFFUSE_MAP )\" +\n  \" || defined( USE_LAYERED_FRACTION_MAP )\" +\n  \" || defined( USE_LAYERED_ROUGHNESS_MAP )\" +\n  \" || defined( USE_LAYERED_ANISOTROPY_MAP )\" +\n  \" || defined( USE_LAYERED_ROTATION_MAP )\" +\n  \" || defined( USE_METAL_F0_MAP )\" +\n  \" || defined( USE_SURFACE_NORMAL_MAP )\" +\n  \" || defined( USE_LAYERED_NORMAL_MAP )\",\n  \"#define \" + flag,\n  \"#endif\"].\n  join(\"\\n\");\n  return def;\n}\n\nmacros['prism_check'] = GetPrismMapsDefinitionChunk;\n\n// Set up code for texture access. If USE_SURFACE_ALBEDO_MAP is defined, for example, this texture access code gets executed.\n// If it's not defined, then a simply copy occurs, e.g. \"surfaceAlbedo = surface_albedo;\" from the variableName and mapType.\nexport function GetPrismMapSampleChunk(mapType, variableName, isFloat, linearize) {\n  var suffix = isFloat ? \"_v3\" : \"\";\n  var declare = isFloat ? \"vec3 \" : \"\";\n  var average = isFloat ? variableName + \" = average(\" + variableName + suffix + \");\" : \"\";\n  var colorLinearization = linearize ? variableName + suffix + \" = SRGBToLinear(\" + variableName + suffix + \");\" : \"\";\n  var shader = [\n  \"#if defined( USE_\" + mapType.toUpperCase() + \"_MAP )\",\n  // note: the tiling system needs to modify the uv of the texture per tile, so we use the modified \"uv\" here, not vUv.\n  \"vec2 uv_\" + mapType + \"_map = (\" + mapType + \"_map_texMatrix * vec3(uv, 1.0)).xy;\",\n  mapType.toUpperCase() + \"_CLAMP_TEST;\",\n  declare + variableName + suffix + \" = texture2D(\" + mapType + \"_map, uv_\" + mapType + \"_map).xyz;\",\n  colorLinearization,\n  \"if(\" + mapType + \"_map_invert) \" + variableName + suffix + \" = vec3(1.0) - \" + variableName + suffix + \";\",\n  average,\n  \"#else\",\n  variableName + \" = \" + mapType + \";\",\n  \"#endif\"].\n  join(\"\\n\");\n\n  return shader;\n}\n\nmacros['prism_sample_texture'] = function (mapType, varName, isFloat, linearize) {\n  return GetPrismMapSampleChunk(mapType, varName, isFloat === 'true', linearize === 'true');\n};\n\nexport function GetPrismMapUniformChunk(mapName) {\n\n  var mtxName = mapName + \"_texMatrix\";\n  var mapInvt = mapName + \"_invert\";\n  var macroName = \"USE_\" + mapName;\n\n  var uniforms = [\n  \"#if defined( \" + macroName.toUpperCase() + \" )\",\n  \"uniform sampler2D \" + mapName + \";\",\n  \"uniform mat3 \" + mtxName + \";\",\n  \"uniform bool \" + mapInvt + \";\",\n  \"#endif\"].\n  join(\"\\n\");\n\n  return uniforms;\n}\n\nmacros['prism_uniforms'] = GetPrismMapUniformChunk;\n\nfunction GetPrismBumpMapUniformChunk(mapName) {\n\n  var mtxName = mapName + \"_texMatrix\";\n  var mapScale = mapName + \"_bumpScale\";\n  var mapType = mapName + \"_bumpmapType\";\n  var macroName = \"USE_\" + mapName;\n\n  var uniforms = [\n  \"#if defined( \" + macroName.toUpperCase() + \" )\",\n  \"uniform sampler2D \" + mapName + \";\",\n  \"uniform mat3 \" + mtxName + \";\",\n  \"uniform vec2 \" + mapScale + \";\",\n  \"uniform int \" + mapType + \";\",\n  \"#endif\"].\n  join(\"\\n\");\n\n  return uniforms;\n}\n\nmacros['prism_bump_uniforms'] = GetPrismBumpMapUniformChunk;\n\n// Precompile regexes for the macros\nvar _regExCache = {};\nfor (name in macros) {\n  _regExCache[name] = new RegExp('#' + name + ' *<([\\\\w\\\\d., ]*)>', 'g');\n}\n\n/**\n   * Recursively resolves include directives and macros.\n   * @param {string} source Original shader code.\n   * @returns {string} Shader code with all includes resolved.\n   */\nexport var resolve = function resolve(source) {\n  for (var name in macros) {\n    var re = _regExCache[name];\n    source = source.replace(re, function (match, parens) {\n      var params = parens.split(',').map(function (param) {return param.trim();});\n      return macros[name].apply(null, params);\n    });\n  }\n\n  var pattern = /#include *<([\\w\\d.]+)>/g;\n  var func = function func(match, include) {\n    if (!chunks[include]) {\n      throw new Error('Cannot resolve #include<' + include + '>');\n    }\n    return resolve(chunks[include]);\n  };\n  return source.replace(pattern, func);\n};\n\n// The chunks don't have to be exported anymore, but we keep them\n// for backwards compatibility (they're still referenced in LegacyNamespace.js)\nexport var PackDepthShaderChunk = chunks['pack_depth'];\nexport var TonemapShaderChunk = chunks['tonemap'];\nexport var OrderedDitheringShaderChunk = chunks['ordered_dither'];\nexport var CutPlanesShaderChunk = chunks['cutplanes'];\nexport var PackNormalsShaderChunk = chunks['pack_normals'];\nexport var HatchPatternShaderChunk = chunks['hatch_pattern'];\nexport var EnvSamplingShaderChunk = chunks['env_sample'];\nexport var IdVertexDeclaration = chunks['id_decl_vert'];\nexport var IdVertexShaderChunk = chunks['id_vert'];\nexport var IdFragmentDeclaration = chunks['id_decl_frag'];\nexport var IdOutputShaderChunk = chunks['id_frag'];\nexport var FinalOutputShaderChunk = chunks['final_frag'];\nexport var ThemingFragmentDeclaration = chunks['theming_decl_frag'];\nexport var ThemingFragmentShaderChunk = chunks['theming_frag'];\nexport var InstancingVertexDeclaration = chunks['instancing_decl_vert'];\nexport var ShadowMapDeclareCommonUniforms = chunks['shadowmap_decl_common'];\nexport var ShadowMapVertexDeclaration = chunks['shadowmap_decl_vert'];\nexport var ShadowMapVertexShaderChunk = chunks['shadowmap_vert'];\nexport var ShadowMapFragmentDeclaration = chunks['shadowmap_decl_frag'];\nexport var PointSizeDeclaration = chunks['decl_point_size'];\nexport var PointSizeShaderChunk = chunks['point_size'];\n\nexport var ShaderChunks = {\n  IdUniforms: IdUniforms,\n  ThemingUniform: ThemingUniform,\n  CutPlanesUniforms: CutPlanesUniforms,\n  ShadowMapCommonUniforms: ShadowMapCommonUniforms,\n  ShadowMapUniforms: ShadowMapUniforms,\n  PointSizeUniforms: PointSizeUniforms,\n  WideLinesUniforms: WideLinesUniforms,\n  DepthTextureUniforms: DepthTextureUniforms,\n  DepthTextureTestUniforms: DepthTextureTestUniforms,\n\n  PackDepthShaderChunk: PackDepthShaderChunk,\n  TonemapShaderChunk: TonemapShaderChunk,\n  OrderedDitheringShaderChunk: OrderedDitheringShaderChunk,\n  CutPlanesShaderChunk: CutPlanesShaderChunk,\n  PackNormalsShaderChunk: PackNormalsShaderChunk,\n  HatchPatternShaderChunk: HatchPatternShaderChunk,\n  EnvSamplingShaderChunk: EnvSamplingShaderChunk,\n  IdVertexDeclaration: IdVertexDeclaration,\n  IdVertexShaderChunk: IdVertexShaderChunk,\n  IdFragmentDeclaration: IdFragmentDeclaration,\n  IdOutputShaderChunk: IdOutputShaderChunk,\n  FinalOutputShaderChunk: FinalOutputShaderChunk,\n  ThemingFragmentDeclaration: ThemingFragmentDeclaration,\n  ThemingFragmentShaderChunk: ThemingFragmentShaderChunk,\n  InstancingVertexDeclaration: InstancingVertexDeclaration,\n  ShadowMapDeclareCommonUniforms: ShadowMapDeclareCommonUniforms,\n  ShadowMapVertexDeclaration: ShadowMapVertexDeclaration,\n  ShadowMapVertexShaderChunk: ShadowMapVertexShaderChunk,\n  ShadowMapFragmentDeclaration: ShadowMapFragmentDeclaration,\n  PointSizeDeclaration: PointSizeDeclaration,\n  PointSizeShaderChunk: PointSizeShaderChunk,\n\n  GetPrismMapSampleChunk: GetPrismMapSampleChunk,\n  GetPrismMapUniformChunk: GetPrismMapUniformChunk,\n\n  resolve: resolve };","module.exports = \"#if NUM_CUTPLANES > 0\\nuniform vec4 cutplanes[NUM_CUTPLANES];\\nvoid checkCutPlanes(vec3 worldPosition) {\\n    for (int i=0; i<NUM_CUTPLANES; i++) {\\n        if (dot(vec4(worldPosition, 1.0), cutplanes[i]) > 0.0) {\\n            discard;\\n        }\\n    }\\n}\\n#endif\\n\";","module.exports = \"uniform float point_size;\";","module.exports = \"\\nuniform sampler2D tDepth;\\nuniform vec4 projInfo;\\nuniform float isOrtho;\\nuniform mat4 worldMatrix_mainPass;\\nvec3 reconstructCSPosition(vec2 fragCoords, float z) {\\n    return vec3((fragCoords * projInfo.xy + projInfo.zw) * mix(z, -1.0, isOrtho), z);\\n}\\nvec3 reconstructWorldPosition(vec2 fragCoords, vec2 screenUv) {\\n    float zCam = texture2D(tDepth, screenUv).z;\\n    vec3 csPos = reconstructCSPosition(fragCoords, zCam);\\n    return (worldMatrix_mainPass * vec4(csPos, 1.0)).xyz;\\n}\\n\";","module.exports = \"\\nuniform float envRotationSin;\\nuniform float envRotationCos;\\nvec3 adjustLookupVector(in vec3 lookup) {\\n    return vec3(\\n            envRotationCos * lookup.x - envRotationSin * lookup.z,\\n            lookup.y,\\n            envRotationSin * lookup.x + envRotationCos * lookup.z);\\n}\\nvec3 RGBMDecode(in vec4 vRGBM, in float exposure) {\\n    vec3 ret = vRGBM.rgb * (vRGBM.a * 16.0);\\n    ret *= ret;\\n    ret *= exposure;\\n    return ret;\\n}\\nvec3 GammaDecode(in vec4 vRGBA, in float exposure) {\\n    return vRGBA.xyz * vRGBA.xyz * exposure;\\n}\\nvec3 sampleIrradianceMap(vec3 dirWorld, samplerCube irrMap, float exposure) {\\n    vec4 cubeColor4 = textureCube(irrMap, adjustLookupVector(dirWorld));\\n#ifdef IRR_GAMMA\\n    vec3 indirectDiffuse = GammaDecode(cubeColor4, exposure);\\n#elif defined(IRR_RGBM)\\n    vec3 indirectDiffuse = RGBMDecode(cubeColor4, exposure);\\n#else\\n    vec3 indirectDiffuse = cubeColor4.xyz;\\n#ifdef GAMMA_INPUT\\n    indirectDiffuse.xyz *= indirectDiffuse.xyz;\\n#endif\\n#endif\\n    return indirectDiffuse;\\n}\\n\";","module.exports = \"#ifdef HATCH_PATTERN\\ngl_FragColor = calculateHatchPattern(hatchParams, gl_FragCoord.xy, gl_FragColor, hatchTintColor, hatchTintIntensity);\\n#endif\\n#ifdef MRT_NORMALS\\noutNormal = vec4(geomNormal.x, geomNormal.y, depth, gl_FragColor.a < 1.0 ? 0.0 : 1.0);\\n#endif\\n#include<id_frag>\\n\";","module.exports = \"float averageOfFloat3(in vec3 value) { \\n    const float oneThird = 1.0 / 3.0; \\n    return dot(value, vec3(oneThird, oneThird, oneThird)); \\n} \\n\";","module.exports = \"#ifdef HATCH_PATTERN\\nuniform vec2 hatchParams;\\nuniform vec3 hatchTintColor;\\nuniform float hatchTintIntensity;\\nfloat curveGaussian(float r, float invWidth) {\\n    float amt = clamp(r * invWidth, 0.0, 1.0);\\n    float exponent = amt * 3.5;\\n    return exp(-exponent*exponent);\\n}\\nvec4 calculateHatchPattern(vec2 hatchParams, vec2 coord, vec4 fragColor, vec3 hatchTintColor, float hatchTintIntensity ) {\\n    float hatchSlope = hatchParams.x;\\n    float hatchPeriod = hatchParams.y;\\n    if (abs(hatchSlope) <= 1.0) {\\n        float hatchPhase = coord.y - hatchSlope * coord.x;\\n        float dist = abs(mod((hatchPhase), (hatchPeriod)));\\n        if (dist < 1.0) {\\n            fragColor = vec4(0.0,0.0,0.0,1.0);\\n        } else {\\n            fragColor.xyz = mix(fragColor.xyz, hatchTintColor, hatchTintIntensity);\\n        }\\n    } else {\\n        float hatchPhase = - coord.y / hatchSlope + coord.x;\\n        float dist = abs(mod((hatchPhase), (hatchPeriod)));\\n        if (dist < 1.0) {\\n            fragColor = vec4(0.0,0.0,0.0,1.0);\\n        } else {\\n            fragColor.xyz = mix(fragColor.xyz, hatchTintColor, hatchTintIntensity);\\n        }\\n    }\\n    return fragColor;\\n}\\n#endif\\n\";","module.exports = \"vec3 rgb2hsv(vec3 color)\\n{\\n    float delta;\\n    float colorMax, colorMin;\\n    float h,s,v;\\n    vec3 hsv;\\n    colorMax = max(color.r,color.g);\\n    colorMax = max(colorMax,color.b);\\n    colorMin = min(color.r,color.g);\\n    colorMin = min(colorMin,color.b);\\n    v = colorMax;\\n    if(colorMax != 0.0)\\n    {\\n        s = (colorMax - colorMin)/colorMax;\\n    }\\n    else\\n    {\\n        s = 0.0;\\n    }\\n    if(s != 0.0)\\n    {\\n        delta = colorMax-colorMin;\\n        if (color.r == colorMax)\\n        {\\n            h = (color.g-color.b)/delta;\\n        }\\n        else if (color.g == colorMax)\\n        {\\n            h = 2.0 + (color.b-color.r) / delta;\\n        }\\n        else\\n        {\\n            h = 4.0 + (color.r-color.g)/delta;\\n        }\\n        h /= 6.0;\\n        if( h < 0.0)\\n        {\\n            h +=1.0;\\n        }\\n    }\\n    else\\n    {\\n        h = 0.0;\\n    }\\n    hsv = vec3(h,s,v);\\n    return hsv;\\n}\\nvec3 hsv2rgb(vec3 hsv)\\n{\\n    vec3 color;\\n    float f,p,q,t;\\n    float h,s,v;\\n    float i,hi;\\n    {\\n        h = hsv.x*6.0;\\n        s = hsv.y;\\n        v = hsv.z;\\n        i = floor(h);\\n        f = h-i;\\n        p = v * (1.0 - s);\\n        q = v * (1.0 - (s * f));\\n        t = v * (1.0 - (s * (1.0 - f)));\\n        float r,g,b;\\n        if (i == 0.0)\\n        {\\n            r = v;\\n            g = t;\\n            b = p;\\n        }\\n        else if (i == 1.0)\\n        {\\n            r = q;\\n            g = v;\\n            b = p;\\n        }\\n        else if (i == 2.0)\\n        {\\n            r = p;\\n            g = v;\\n            b = t;\\n        }\\n        else if (i == 3.0)\\n        {\\n            r = p;\\n            g = q;\\n            b = v;\\n        }\\n        else if (i == 4.0)\\n        {\\n            r = t;\\n            g = p;\\n            b = v;\\n        }\\n        else\\n        {\\n            r = v;\\n            g = p;\\n            b = q;\\n        }\\n        color = vec3(r,g,b);\\n    }\\n    return color;\\n}\";","module.exports = \"#if defined(MRT_NORMALS) || defined(MRT_ID_BUFFER)\\n    varying highp float depth;\\n#endif\\n#if defined(MRT_ID_BUFFER) || defined(ID_COLOR)\\n    #ifdef USE_VERTEX_ID\\n        varying vec3 vId;\\n    #elif defined(LINE_2D_SHADER)\\n        varying vec4 dbId;\\n    #else\\n        uniform vec3 dbId;\\n    #endif\\n#endif\\n#if defined(MRT_ID_BUFFER) || defined(MODEL_COLOR)\\n    uniform vec3 modelId;\\n#endif\\n#ifdef _LMVWEBGL2_\\n    #if defined(MRT_NORMALS)\\n        layout(location = 1) out vec4 outNormal;\\n        #if defined(MRT_ID_BUFFER)\\n            layout(location = 2) out vec4 outId;\\n            #if defined(MODEL_COLOR)\\n                layout(location = 3) out vec4 outModelId;\\n            #endif\\n        #endif\\n    #elif defined(MRT_ID_BUFFER)\\n        layout(location = 1) out vec4 outId;\\n        #if defined(MODEL_COLOR)\\n            layout(location = 2) out vec4 outModelId;\\n        #endif\\n    #endif\\n#else\\n    #define gl_FragColor gl_FragData[0]\\n    #if defined(MRT_NORMALS)\\n        #define outNormal gl_FragData[1]\\n        #if defined(MRT_ID_BUFFER)\\n            #define outId gl_FragData[2]\\n            #if defined(MODEL_COLOR)\\n                #define outModelId gl_FragData[3]\\n            #endif\\n        #endif\\n    #elif defined(MRT_ID_BUFFER)\\n        #define outId gl_FragData[1]\\n        #if defined(MODEL_COLOR)\\n            #define outModelId gl_FragData[2]\\n        #endif\\n    #endif\\n#endif\";","module.exports = \"#ifdef USE_VERTEX_ID\\nattribute vec3 id;\\nvarying   vec3 vId;\\n#endif\\n\";","module.exports = \"\\n#if defined(USE_VERTEX_ID) && (defined(MRT_ID_BUFFER) || defined(ID_COLOR))\\n    vec3 dbId = vId;\\n#endif\\n#ifdef MRT_ID_BUFFER\\n    #ifndef ENABLE_ID_DISCARD\\n        const float writeId = 1.0;\\n    #endif\\n    outId = vec4(dbId.rgb, writeId);\\n    #ifdef MODEL_COLOR\\n        outModelId = vec4(modelId.rgb, writeId);\\n    #endif\\n#elif defined(ID_COLOR)\\n    #ifdef ENABLE_ID_DISCARD\\n        if (writeId==0.0) {\\n            discard;\\n        }\\n    #endif\\n    gl_FragColor = vec4(dbId.rgb, 1.0);\\n#elif defined(MODEL_COLOR)\\n    #ifdef ENABLE_ID_DISCARD\\n        if (writeId==0.0) {\\n            discard;\\n        }\\n    #endif\\n    gl_FragColor = vec4(modelId.rgb, 1.0);\\n#endif\\n\";","module.exports = \"\\n#ifdef USE_VERTEX_ID\\nvId = id;\\n#endif\\n\";","module.exports = \"\\n#ifdef USE_INSTANCING\\nattribute vec3 instOffset;\\nattribute vec4 instRotation;\\nattribute vec3 instScaling;\\nvec3 applyQuaternion(vec3 p, vec4 q) {\\n    return p + 2.0 * cross(q.xyz, cross(q.xyz, p) + q.w * p);\\n}\\nvec3 getInstancePos(vec3 pos) {\\n    return instOffset + applyQuaternion(instScaling * pos, instRotation);\\n}\\nvec3 getInstanceNormal(vec3 normal) {\\n    return applyQuaternion(normal/instScaling, instRotation);\\n}\\n#else\\nvec3 getInstancePos(vec3 pos)       { return pos;    }\\nvec3 getInstanceNormal(vec3 normal) { return normal; }\\n#endif\\n\";","module.exports = \"\\n#define LINE_2D_SHADER 1\\n#define TAU     6.28318530718\\n#define PI      3.14159265358979\\n#define HALF_PI 1.57079632679\\n#define PI_0_5  HALF_PI\\n#define PI_1_5  4.71238898038\\n#define ENABLE_ID_DISCARD\\n#define VBB_GT_TRIANGLE_INDEXED  0.0\\n#define VBB_GT_LINE_SEGMENT      1.0\\n#define VBB_GT_ARC_CIRCULAR      2.0\\n#define VBB_GT_ARC_ELLIPTICAL    3.0\\n#define VBB_GT_TEX_QUAD          4.0\\n#define VBB_GT_ONE_TRIANGLE      5.0\\n#define VBB_GT_MSDF_TRIANGLE_INDEXED 6.0\\n#define VBB_INSTANCED_FLAG   0.0\\n#define VBB_SEG_START_RIGHT  0.0\\n#define VBB_SEG_START_LEFT   1.0\\n#define VBB_SEG_END_RIGHT    2.0\\n#define VBB_SEG_END_LEFT     3.0\\n#define LTSCALE 0.25\\nvarying vec4 fsColor;\\nvarying vec2 fsOffsetDirection;\\nvarying vec4 fsMultipurpose;\\nvarying float fsHalfWidth;\\nvarying vec2 fsVpTC;\\nvarying float fsGhosting;\\n#ifdef LOADING_ANIMATION\\nvarying float loadingProgress;\\n#endif\\n\";","module.exports = \"#if defined(USE_SURFACE_NORMAL_MAP) || defined( USE_LAYERED_NORMAL_MAP ) || defined( USE_TILING_NORMAL )\\nvoid heightMapTransform(\\n    sampler2D bumpTexture,\\n    vec2 uv,\\n    mat3 transform,\\n    vec2 bumpScale,\\n    inout vec3 T,\\n    inout vec3 B,\\n    inout vec3 N\\n) {\\n    vec2 st = (transform * vec3(uv, 1.0)).xy;\\n    mat3 mtxTangent = mat3(T, B, N);\\n    T = normalize(mtxTangent * (transform * vec3(1.0, 0.0, 0.0)));\\n    B = normalize(mtxTangent * (transform * vec3(0.0, 1.0, 0.0)));\\n    const float oneThird = 1.0 / 3.0;\\n    vec3 avg = vec3(oneThird, oneThird, oneThird);\\n    vec2 offset = fwidth(st);\\n    float h0 = dot(texture2D(bumpTexture, st).xyz, avg);\\n    float hx = dot(texture2D(bumpTexture, st + vec2(offset.x, 0.0)).xyz, avg);\\n    float hy = dot(texture2D(bumpTexture, st + vec2(0.0, offset.y)).xyz, avg);\\n    vec2 diff = vec2(h0 - hx, h0 - hy) / offset;\\n    N = normalize(\\n        N + (\\n            diff.x * T * bumpScale.x +\\n            diff.y * B * bumpScale.y\\n        )\\n    );\\n}\\nvoid normalMapTransform(\\n    sampler2D bumpTexture,\\n    vec2 uv,\\n    mat3 transform,\\n    vec2 bumpScale,\\n    inout vec3 T,\\n    inout vec3 B,\\n    inout vec3 N\\n) {\\n    vec2 st = (transform * vec3(uv, 1.0)).xy;\\n    vec3 mapN =  2.0 * texture2D(bumpTexture, st).xyz - 1.0;\\n    mapN.xy *= bumpScale.x;\\n    mapN.z *= bumpScale.y;\\n    vec3 v = vec3(mapN.y, -mapN.x, 0.0);\\n    float c = -mapN.z;\\n    mat3 skewV = mat3(\\n        0.0, v.z, -v.y,\\n        -v.z, 0.0, v.x,\\n        v.y, -v.x, 0.0\\n    );\\n    mat3 rot = mat3(1.0) + skewV + skewV*skewV * 1.0/(1.0-c);\\n    N *= rot;\\n    T *= rot;\\n    B *= rot;\\n}\\n#endif\\n\";","module.exports = \"vec3 orderedDithering(vec3 col) {\\n    const vec4 m0 = vec4( 1.0, 13.0,  4.0, 16.0);\\n    const vec4 m1 = vec4( 9.0,  5.0, 12.0,  8.0);\\n    const vec4 m2 = vec4( 3.0, 15.0,  2.0, 14.0);\\n    const vec4 m3 = vec4(11.0,  7.0, 10.0,  6.0);\\n    int i = int(mod(float(gl_FragCoord.x), 4.0));\\n    int j = int(mod(float(gl_FragCoord.y), 4.0));\\n    vec4 biasRow;\\n    if      (i==0) biasRow = m0;\\n    else if (i==1) biasRow = m1;\\n    else if (i==2) biasRow = m2;\\n    else           biasRow = m3;\\n    float bias;\\n    if      (j==0) bias = biasRow.x;\\n    else if (j==1) bias = biasRow.y;\\n    else if (j==2) bias = biasRow.z;\\n    else           bias = biasRow.w;\\n    return col + bias / 17.0 / 256.0;\\n}\\n\";","module.exports = \"\\nvec4 packDepth( const in float depth ) {\\n    vec4 enc = vec4(1.0, 255.0, 65025.0, 160581375.0) * depth;\\n    enc = fract(enc);\\n    enc -= enc.yzww * vec4(1.0/255.0,1.0/255.0,1.0/255.0,0.0);\\n    return enc;\\n}\\nfloat unpackDepth( const in vec4 rgba_depth ) {\\n    return dot( rgba_depth, vec4(1.0, 1.0/255.0, 1.0/65025.0, 1.0/160581375.0) );\\n}\\n\";","module.exports = \"\\n#define kPI 3.14159265358979\\nvec2 encodeNormal (vec3 n) {\\n    return (vec2(atan(n.y,n.x)/kPI, n.z)+1.0)*0.5;\\n}\\nvec3 decodeNormal (vec2 enc) {\\n    vec2 ang = enc * 2.0 - 1.0;\\n    vec2 scth = vec2(sin(ang.x * kPI), cos(ang.x * kPI));\\n    vec2 scphi = vec2(sqrt(1.0 - ang.y * ang.y), ang.y);\\n    return vec3(scth.y * scphi.x, scth.x * scphi.x, scphi.y);\\n}\\n\";","module.exports = \"gl_PointSize = point_size;\";","module.exports = \"\\nvec3 TransmitAdjust(vec3 transmission, vec3 f0) \\n{ \\n   vec3 limit = max(1.0 - f0, 0.00001); \\n   return clamp(transmission, vec3(0.0, 0.0, 0.0), limit) / limit; \\n} \\nfloat ColorToIlluminance(in vec3 color) \\n{ \\n   const vec3 rgb2grey = vec3(0.299, 0.587, 0.114); \\n   float illuminance = dot(rgb2grey, color); \\n   return illuminance; \\n} \\nvoid applyPrismGlazingOpacity(\\n    inout vec4 color,\\n    vec3 transmissionF,\\n    float transmissionAlpha,\\n    float NdotV,\\n    float glazingIlluminace) \\n{\\n    const float third = 1.0/3.0; \\n    float transSurface = exp(-(transmissionAlpha + (transmissionAlpha < 0.0025 ? 0.0 : 0.25)) * NdotV * PI); \\n    float opacity = 1.0- dot((1.0 - transmissionF), vec3(third,third,third)) * transSurface * glazingIlluminace; \\n    opacity = clamp(opacity, 0.01, 0.99);\\n    color.a *= opacity;\\n} \\n\";","module.exports = \"void applyPrismTransparency(\\n    inout vec4 color,\\n    vec3 transparentColor,\\n    float transparentIor\\n) {\\n    float fsLevel = max(max(color.r, color.g), color.b);\\n    color = vec4(color.rgb/fsLevel, fsLevel);\\n    float transLevel = min(min(transparentColor.r, transparentColor.g), transparentColor.b);\\n    transLevel = min( (1.0 - surface_roughness), transLevel );\\n    float transAlpha = (1.0 - transLevel) * 0.4 + surface_roughness * 0.55;\\n    vec3 tr_g_color = sqrt(transparentColor);\\n    vec4 transColor = vec4(0.5 * vec3(tr_g_color), transAlpha);\\n    float strength = 1.0 - (1.0 - fsLevel) * (1.0 - fsLevel);\\n    color = mix(transColor, color, strength);\\n    color.a = max(color.a, 0.05);\\n    if (transparentIor == 1.0 && tr_g_color == vec3(1.0)) {\\n        color.a = 0.0;\\n    }\\n}\";","module.exports = \"#if defined( PRISMWOOD )\\n#define ONE 0.00390625\\nfloat GetIndexedValue(vec4 array, int index)\\n{\\n    if (index == 0)\\n        return array[0];\\n    else if (index == 1)\\n        return array[1];\\n    else if (index == 2)\\n        return array[2];\\n    else if (index == 3)\\n        return array[3];\\n    else\\n        return 0.0;\\n}\\nint GetIndexedValue(ivec2 array, int index)\\n{\\n    if (index == 0)\\n        return array[0];\\n    else if (index == 1)\\n        return array[1];\\n    else\\n        return 0;\\n}\\n#if defined( USE_WOOD_CURLY_DISTORTION_MAP )\\nfloat SampleCurlyPattern(vec2 uv)\\n{\\n    vec2 uv_wood_curly_distortion_map = (wood_curly_distortion_map_texMatrix * vec3(uv, 1.0)).xy;\\n    WOOD_CURLY_DISTORTION_CLAMP_TEST;\\n    vec3 curlyDistortion = texture2D(wood_curly_distortion_map, uv_wood_curly_distortion_map).xyz;\\n    if(wood_curly_distortion_map_invert) curlyDistortion = vec3(1.0) - curlyDistortion;\\n    return curlyDistortion.r;\\n}\\nvec3 DistortCurly(vec3 p)\\n{\\n    if (!wood_curly_distortion_enable) return p;\\n    float r = length(p.xy);\\n    if (r < 0.00001) return p;\\n    const float INV_ANGLE_INTERVAL = 1.27323954;\\n    const float NUM_INTERVAL = 8.0;\\n    float theta = atan(p.y, p.x);\\n    if (theta < 0.0)\\n        theta += PI2;\\n    float intIdx = theta * INV_ANGLE_INTERVAL;\\n    int idx0 = int(mod(floor(intIdx), NUM_INTERVAL));\\n    int idx1 = int(mod(ceil(intIdx), NUM_INTERVAL));\\n    const vec4 HASH_TABLE1 = vec4(0.450572,0.114598, 0.886043, 0.315119);\\n    const vec4 HASH_TABLE2 = vec4(0.216133,0.306264, 0.685616, 0.317907);\\n    float offset0 = idx0 < 4 ? GetIndexedValue(HASH_TABLE1, idx0) : GetIndexedValue(HASH_TABLE2, idx0-4);\\n    float offset1 = idx1 < 4 ? GetIndexedValue(HASH_TABLE1, idx1) : GetIndexedValue(HASH_TABLE2, idx1-4);\\n    const float maxOffset = 100.0;\\n    offset0 = (offset0 - 0.5) * maxOffset;\\n    offset1 = (offset1 - 0.5) * maxOffset;\\n    vec2 uv0 = vec2(p.z + offset0, r);\\n    float shiftWeight0 =  SampleCurlyPattern(uv0);\\n    vec2 uv1 = vec2(p.z + offset1, r);\\n    float shiftWeight1 =  SampleCurlyPattern(uv1);\\n    float interpWeight = fract(intIdx);\\n    float shiftWeight = mix(shiftWeight0, shiftWeight1, interpWeight);\\n    const float INV_MIN_RADIUS = 2.0;\\n    float shiftWeightAdjust = smoothstep(0.0, 1.0, r * INV_MIN_RADIUS);\\n    r -= wood_curly_distortion_scale * (shiftWeight * shiftWeightAdjust);\\n    float thetaNew = atan(p.y, p.x);\\n    vec3 pNew = p;\\n    pNew.x = r * cos(thetaNew);\\n    pNew.y = r * sin(thetaNew);\\n    return pNew;\\n}\\n#endif\\nvec3 un2sn(vec3 range)\\n{\\n    return range * 2.0 - 1.0;\\n}\\nfloat inoise(vec3 p)\\n{\\n    vec3 modp = mod(floor(p), 256.0);\\n    modp.xy = modp.xy * ONE;\\n    vec4 AA = texture2D(perm2DMap, vec2(modp.x, modp.y), 0.0) * 255.0;\\n    AA = AA + modp.z;\\n    AA = mod(floor(AA), 256.0);\\n    AA *= ONE;\\n    vec3 gradx1 = un2sn(texture2D(permGradMap,vec2(AA.x,0.0),0.0).xyz);\\n    vec3 grady1 = un2sn(texture2D(permGradMap,vec2(AA.y,0.0),0.0).xyz);\\n    vec3 gradz1 = un2sn(texture2D(permGradMap,vec2(AA.z,0.0),0.0).xyz);\\n    vec3 gradw1 = un2sn(texture2D(permGradMap,vec2(AA.w,0.0),0.0).xyz);\\n    vec3 gradx2 = un2sn(texture2D(permGradMap,vec2(AA.x + ONE,0.0),0.0).xyz);\\n    vec3 grady2 = un2sn(texture2D(permGradMap,vec2(AA.y + ONE,0.0),0.0).xyz);\\n    vec3 gradz2 = un2sn(texture2D(permGradMap,vec2(AA.z + ONE,0.0),0.0).xyz);\\n    vec3 gradw2 = un2sn(texture2D(permGradMap,vec2(AA.w + ONE,0.0),0.0).xyz);\\n    p -= floor(p);\\n    vec3 fadep = p * p * p * (p * (p * 6.0 - 15.0) + 10.0);\\n    return mix( mix( mix( dot(gradx1, p ),\\n                          dot(gradz1, p + vec3(-1.0, 0.0, 0.0)), fadep.x),\\n                     mix( dot(grady1, p + vec3(0.0, -1.0, 0.0)),\\n                          dot(gradw1, p + vec3(-1.0, -1.0, 0.0)), fadep.x), fadep.y),\\n                mix( mix( dot(gradx2, p + vec3(0.0, 0.0, -1.0)),\\n                          dot(gradz2, p + vec3(-1.0, 0.0, -1.0)), fadep.x),\\n                     mix( dot(grady2, p + vec3(0.0, -1.0, -1.0)),\\n                          dot(gradw2, p + vec3(-1.0, -1.0, -1.0)), fadep.x), fadep.y), fadep.z);\\n}\\nfloat inoise(float p)\\n{\\n    float modp = mod(floor(p), 256.0);\\n    modp = (modp + 256.0) * ONE;\\n    float permx = texture2D(permutationMap, vec2(modp, 0.0), 0.0).r;\\n    float gradx = texture2D(gradientMap, vec2(permx, 0.0), 0.0).r*2.0-1.0;\\n    float permy = texture2D(permutationMap, vec2(modp + ONE, 0.0), 0.0).r;\\n    float grady = texture2D(gradientMap, vec2(permy, 0.0), 0.0).r*2.0-1.0;\\n    p -= floor(p);\\n    float fadep = p * p * p * (p * (p * 6.0 - 15.0) + 10.0);\\n    return mix(gradx * p, grady * (p - 1.0), fadep);\\n}\\nfloat multiband_inoise(vec3 p, int bands, vec4 w, vec4 f)\\n{\\n    float noise = 0.0;\\n    for(int i = 0; i < 4; ++i)\\n    {\\n        if (i >= bands) break;\\n        noise += GetIndexedValue(w, i) * inoise(p * GetIndexedValue(f, i));\\n    }\\n    return noise;\\n}\\nfloat multiband_inoise(float p, int bands, vec4 w, vec4 f)\\n{\\n    float noise = 0.0;\\n    for(int i = 0; i < 4; ++i)\\n    {\\n        if (i >= bands) break;\\n        noise += GetIndexedValue(w, i) * inoise(p * GetIndexedValue(f, i));\\n    }\\n    return noise;\\n}\\nvec3 Distort3DCosineRadialDir(vec3 p)\\n{\\n    float radius = length(p.xy);\\n    if (radius < 0.00001) return p;\\n    vec2 theta = p.xy / radius;\\n    float radiusShift = 0.0;\\n    for (int i = 0; i < 4; ++i)\\n    {\\n        if (i >= wood_fiber_cosine_bands) break;\\n        radiusShift += GetIndexedValue(wood_fiber_cosine_weights, i) * cos(p.z * RECIPROCAL_PI2 * GetIndexedValue(wood_fiber_cosine_frequencies, i));\\n    }\\n    const float MIN_RADIUS = 1.5;\\n    float weight = clamp(radius / MIN_RADIUS, 0.0, 1.0);\\n    if(weight >= 0.5)\\n        weight = weight * weight * (3.0 - (weight + weight));\\n    p.xy += theta * radiusShift * weight;\\n    return p;\\n}\\nvec3 Distort3DPerlin(vec3 p)\\n{\\n    vec3 pAniso = vec3(p.xy, p.z * wood_fiber_perlin_scale_z);\\n    p.xy += multiband_inoise(pAniso, wood_fiber_perlin_bands, wood_fiber_perlin_weights, wood_fiber_perlin_frequencies);\\n    return p;\\n}\\nvec3 Distort(vec3 p)\\n{\\n    if(wood_fiber_cosine_enable)\\n        p = Distort3DCosineRadialDir(p);\\n    if(wood_fiber_perlin_enable)\\n        p = Distort3DPerlin(p);\\n    return p;\\n}\\nfloat DistortRadiusLength(float radiusLength)\\n{\\n    radiusLength += multiband_inoise(radiusLength, wood_growth_perlin_bands, wood_growth_perlin_weights, wood_growth_perlin_frequencies);\\n    if (radiusLength < 0.0) radiusLength = 0.0;\\n    return radiusLength;\\n}\\nfloat ComputeEarlyWoodRatio(float radiusLength)\\n{\\n    float fraction = mod(radiusLength, wood_ring_thickness) / wood_ring_thickness;\\n    if (fraction <= wood_ring_fraction.y)\\n       return 1.0;\\n    else if(fraction <= wood_ring_fraction.x)\\n       return (1.0 - (fraction - wood_ring_fraction.y) / wood_fall_rise.x);\\n    else if(fraction <= wood_ring_fraction.w)\\n       return 0.0;\\n    else\\n       return ((fraction - wood_ring_fraction.w) / wood_fall_rise.y);\\n}\\nvec3 DistortEarlyColor(vec3 earlyColor, float radiusLength)\\n{\\n    float expValue = 1.0 + multiband_inoise(radiusLength,wood_earlycolor_perlin_bands,wood_earlycolor_perlin_weights,wood_earlycolor_perlin_frequencies);\\n    earlyColor = pow(abs(earlyColor), vec3(expValue));\\n    return earlyColor;\\n}\\nvec3 DistortLateColor(vec3 lateColor, float radiusLength)\\n{\\n    float expValue = 1.0 + multiband_inoise(radiusLength,wood_latecolor_perlin_bands,wood_latecolor_perlin_weights,wood_latecolor_perlin_frequencies);\\n    lateColor = pow(abs(lateColor), vec3(expValue));\\n    return lateColor;\\n}\\nvec3 DistortDiffuseColor(vec3 diffAlbedo, vec3 p)\\n{\\n    p.z *= wood_diffuse_perlin_scale_z;\\n    float expValue = 1.0 + multiband_inoise(p, wood_diffuse_perlin_bands, wood_diffuse_perlin_weights, wood_diffuse_perlin_frequencies);\\n    diffAlbedo = pow(abs(diffAlbedo), vec3(expValue));\\n    return diffAlbedo;\\n}\\nfloat LayerRoughnessVar(float roughness, float earlyWoodRatio)\\n{\\n    return earlyWoodRatio * wood_groove_roughness + (1.0 - earlyWoodRatio) * roughness;\\n}\\nfloat hashword(vec2 k)\\n{\\n    k = mod(k, vec2(256.0)) * ONE;\\n    float a = texture2D(permutationMap, vec2(k.x, 0.0)).x + k.y ;\\n    a = texture2D(permutationMap, vec2(a, 0.0)).x ;\\n    return a*255.0;\\n}\\nfloat wyvillsq(float rsq)\\n{\\n    if (rsq >= 1.0) return 0.0;\\n    float tmp = 1.0 - rsq;\\n    return tmp*tmp*tmp;\\n}\\nfloat Weight2DNeighborImpulses(vec3 p, float woodWeight)\\n{\\n    if(woodWeight <= 0.0) return 0.0;\\n    float poreRadius = wood_pore_radius * woodWeight;\\n    vec2 left = floor((p.xy - poreRadius) / wood_pore_cell_dim);\\n    vec2 right = floor((p.xy + poreRadius) / wood_pore_cell_dim);\\n    float weight = 0.0;\\n    float invRsq = 1.0 / (poreRadius * poreRadius);\\n    const float norm =  1.0 / 15.0;\\n    for (int j = 0; j <= 4; j++)\\n    {\\n        if (j > int(right.y - left.y)) continue;\\n        for (int i = 0; i <= 4; i++)\\n        {\\n            if (i > int(right.x - left.x)) continue;\\n            vec2 pij = vec2(float(i) + left.x,float(j) + left.y);\\n            float hRNum = hashword(pij);\\n            float impPosX = mod(hRNum, 16.0) * norm;\\n            float impPosY = floor(hRNum / 16.0) * norm;\\n            impPosX = (pij.x + impPosX)* wood_pore_cell_dim;\\n            impPosY = (pij.y + impPosY)* wood_pore_cell_dim;\\n            float dsq = (p.x - impPosX) * (p.x - impPosX) + (p.y - impPosY) * (p.y - impPosY);\\n            weight += wyvillsq(dsq * invRsq);\\n        }\\n    }\\n    return weight;\\n}\\nfloat Weight3DRayImpulses(vec3 p)\\n{\\n    int segIdx = int(floor(p.z / wood_ray_seg_length_z));\\n    float factor = p.z / wood_ray_seg_length_z - float(segIdx);\\n    int segIdx1 = segIdx - 1;\\n    if ( factor > 0.5 )\\n        segIdx1 = segIdx + 1;\\n    float theta = atan(p.y, p.x);\\n    float sliceIdx = floor(((theta + PI) * RECIPROCAL_PI2) * wood_ray_num_slices);\\n    if ( sliceIdx == wood_ray_num_slices)\\n        sliceIdx-=1.0;\\n    ivec2 arrSegs = ivec2(segIdx, segIdx1);\\n    float weight = 0.0;\\n    const float norm =  1.0 / 15.0;\\n    float radialOffset = 5.0;\\n    float radialLength = length(p.xy);\\n    for (int seg = 0; seg < 2; seg++)\\n    {\\n        float hRNum = hashword(vec2(sliceIdx, GetIndexedValue(arrSegs, seg)));\\n        float rn1 = mod(hRNum,16.0) * norm;\\n        if (radialLength < radialOffset * rn1)\\n            continue;\\n        float rayTheta = rn1;\\n        rayTheta = ( ( sliceIdx + rayTheta ) / wood_ray_num_slices ) * ( 2.0 * PI ) - PI;\\n        float rayPosZ = (hRNum/16.0)* norm;\\n        rayPosZ = ( float(GetIndexedValue(arrSegs, seg)) + rayPosZ ) * wood_ray_seg_length_z;\\n        vec3 pt1 = vec3(0.0);\\n        vec3 pt2 = vec3(cos(rayTheta), sin(rayTheta), 0.0);\\n        vec3 p1 = p;\\n        p1.z -= rayPosZ;\\n        p1.z /=  wood_ray_ellipse_z2x;\\n        vec3 v1 = pt2 - pt1;\\n        vec3 v2 = pt1 - p1;\\n        v2 = cross(v1, v2);\\n        float dist = length(v2) / length(v1);\\n        float invRsq = 1.0 / ( wood_ray_ellipse_radius_x * wood_ray_ellipse_radius_x);\\n        weight += wyvillsq( (dist * dist) * invRsq );\\n    }\\n    return weight;\\n}\\nvec3 DarkenColorWithPores(vec3 p, vec3 diffColor, float woodWeight)\\n{\\n    float poresWeight = Weight2DNeighborImpulses(p, woodWeight);\\n    float a = wood_pore_color_power - 1.0;\\n    float b = 1.0;\\n    float y = a * poresWeight + b;\\n    return pow(abs(diffColor), vec3(y));\\n}\\nvec3 DarkenColorWithRays(vec3 p, vec3 diffColor)\\n{\\n    float raysWeight = Weight3DRayImpulses(p);\\n    float a = wood_ray_color_power - 1.0;\\n    float b = 1.0;\\n    float y = a * raysWeight + b;\\n    return pow(abs(diffColor), vec3(y));\\n}\\nfloat ComputeWoodWeight(float earlyWoodRatio)\\n{\\n    float woodWeight = 0.0;\\n    if (wood_pore_type == 0)\\n        woodWeight = 1.0;\\n    else if (wood_pore_type == 1)\\n        woodWeight = earlyWoodRatio;\\n    else if (wood_pore_type == 2)\\n        woodWeight = 1.0 - earlyWoodRatio;\\n    else\\n        woodWeight = -1.0;\\n    return woodWeight;\\n}\\n#if defined( PRISMWOODBUMP )\\nfloat ComputeEarlyWoodRatioAA(float radiusLength, float invUnitExt)\\n{\\n    float transPixels = min(wood_fall_rise.x, wood_fall_rise.y) * wood_ring_thickness * invUnitExt;\\n    float samplesf = clamp(4.0 / transPixels, 1.0, 4.0);\\n    int samples = int(samplesf);\\n    float inverseSamples = 1.0 / float(samples);\\n    vec2 rdelta = vec2(dFdx(radiusLength), dFdy(radiusLength)) * inverseSamples;\\n    float earlywoodRatio = 0.0;\\n    for (int i = 0; i < 4; ++i)\\n    {\\n        if (i >= samples) break;\\n        for (int j = 0; j < 4; ++j)\\n        {\\n            if (j >= samples) break;\\n            float r = radiusLength + dot(vec2(i, j), rdelta);\\n            earlywoodRatio += ComputeEarlyWoodRatio(r);\\n        }\\n    }\\n    return earlywoodRatio * (inverseSamples * inverseSamples);\\n}\\nfloat LatewoodDepthVariation(float invUnitExt)\\n{\\n    float transPixels = min(wood_fall_rise.x, wood_fall_rise.y) * wood_ring_thickness * invUnitExt;\\n    return clamp(transPixels * 0.5, 0.0, 1.0);\\n}\\nfloat LatewoodHeightVariation(float earlyWoodRatio, float latewoodBumpDepth,\\n                              float depthVar)\\n{\\n    return ( 1.0 - earlyWoodRatio ) * latewoodBumpDepth * depthVar;\\n}\\nfloat PoreDepthVariation(float woodWeight, float invUnitExt)\\n{\\n    float porePixels = woodWeight * wood_pore_radius * invUnitExt;\\n    return clamp(porePixels, 0.0, 1.0);\\n}\\nfloat PoreHeightVariation(float earlyWoodRatio, float poresWeight, float poreDepth,\\n                          float depthVar)\\n{\\n    return poresWeight * (-1.0 * poreDepth) * depthVar;\\n}\\nvoid ComputeTangents(vec3 normal, out vec3 u, out vec3 v)\\n{\\n    float scale = normal.z < 0.0 ? -1.0 : 1.0;\\n    vec3 temp = scale * normal;\\n    float e    = temp.z;\\n    float h    = 1.0/(1.0 + e);\\n    float hvx  = h   *  temp.y;\\n    float hvxy = hvx * -temp.x;\\n    u = vec3(e + hvx * temp.y, hvxy,                -temp.x);\\n    v = vec3(hvxy,             e + h * temp.x * temp.x, -temp.y);\\n    u *= scale;\\n    v *= scale;\\n}\\nvec3 WoodBumpHeight(float heightLeft, float heightRight, float heightBack, float heightFront)\\n{\\n    const float epsilon = 0.001;\\n    float heightDeltaX = heightRight - heightLeft;\\n    vec3 Tu = vec3(2.0 * epsilon, 0.0, heightDeltaX);\\n    float heightDeltaY = heightFront - heightBack;\\n    vec3 Tv = vec3(0.0, 2.0 * epsilon, heightDeltaY);\\n    return cross(Tu, Tv);\\n}\\nvec3 SelectNormal(vec3 N, vec3 bumpN, vec3 V)\\n{\\n    float bumpNdotV = dot(bumpN, V);\\n    if(bumpNdotV > 0.0)\\n        return bumpN;\\n    else return N;\\n}\\nfloat MinInverseUnitExtent(vec3 p)\\n{\\n    return 1.0 / max(max(length(dFdx(p.xy)), length(dFdy(p.xy))), 0.000001);\\n}\\nfloat HeightVariation(vec3 pos)\\n{\\n    vec3 p = Distort(pos);\\n    float radiusLength = length(p.xy);\\n    if (wood_growth_perlin_enable)\\n        radiusLength = DistortRadiusLength(radiusLength);\\n    float invUnitExt = MinInverseUnitExtent(p);\\n    float earlyWoodRatio = ComputeEarlyWoodRatioAA(radiusLength, invUnitExt);\\n    float woodWeight = ComputeWoodWeight(earlyWoodRatio);\\n    float poresWeight = Weight2DNeighborImpulses(p, woodWeight);\\n    float depthVar = PoreDepthVariation(woodWeight, invUnitExt);\\n    float poreHeightVariation = -1.0 * poresWeight * wood_pore_depth * depthVar;\\n    float latewoodHeightVariation = 0.0;\\n    if (wood_use_latewood_bump)\\n    {\\n        float latewoodDepthVar = LatewoodDepthVariation(invUnitExt);\\n        latewoodHeightVariation = (1.0 - earlyWoodRatio) * wood_latewood_bump_depth * latewoodDepthVar;\\n    }\\n    float sumHeightVariation = poreHeightVariation + latewoodHeightVariation;\\n    return sumHeightVariation;\\n}\\n#endif\\nvec3 NoiseWood(vec3 p, inout float roughness)\\n{\\n    p = Distort(p);\\n    float radiusLength = length(p.xy);\\n    if(wood_growth_perlin_enable)\\n        radiusLength = DistortRadiusLength(radiusLength);\\n#if defined( PRISMWOODBUMP )\\n    float invUnitExt = MinInverseUnitExtent( p );\\n    float earlyWoodRatio = ComputeEarlyWoodRatioAA(radiusLength, invUnitExt);\\n#else\\n    float earlyWoodRatio = ComputeEarlyWoodRatio(radiusLength);\\n#endif\\n    vec3 earlyColor = wood_early_color;\\n    if (wood_earlycolor_perlin_enable)\\n        earlyColor = DistortEarlyColor(earlyColor, radiusLength);\\n    vec3 lateColor;\\n    if (wood_use_manual_late_color)\\n        lateColor = wood_manual_late_color;\\n    else\\n        lateColor = pow(abs(earlyColor), vec3(wood_late_color_power));\\n    if(wood_latecolor_perlin_enable)\\n        lateColor = DistortLateColor(lateColor, radiusLength);\\n    vec3 diffAlbedo = earlyWoodRatio * earlyColor + (1.0 - earlyWoodRatio) * lateColor;\\n    if(wood_diffuse_perlin_enable)\\n        diffAlbedo = DistortDiffuseColor(diffAlbedo, p);\\n    if (wood_use_pores)\\n    {\\n        float woodWeight = ComputeWoodWeight(earlyWoodRatio);\\n        diffAlbedo = DarkenColorWithPores(p, diffAlbedo, woodWeight);\\n    }\\n    if (wood_use_rays)\\n        diffAlbedo = DarkenColorWithRays(p, diffAlbedo);\\n    if(wood_use_groove_roughness)\\n        roughness = LayerRoughnessVar(roughness, earlyWoodRatio);\\n    return clamp(diffAlbedo, vec3(0.0), vec3(1.0));\\n}\\n#if defined(PRISMWOODBUMP)\\nvoid getFinalWoodContext(\\n    inout vec3 N, vec3 V, inout vec3 Tu, inout vec3 Tv, vec3 p,\\n    vec3 geoNormal, vec3 tNormal, mat3 normalMatrix\\n) {\\n    vec3 offsetTuLeft = p - 0.001 * Tu;\\n    vec3 offsetTuRight = p + 0.001 * Tu;\\n    vec3 offsetTvLeft = p - 0.001 * Tv;\\n    vec3 offsetTvRight = p + 0.001 * Tv;\\n    float heightVariationTuLeft = HeightVariation(offsetTuLeft);\\n    float heightVariationTuRight = HeightVariation(offsetTuRight);\\n    float heightVariationTvLeft = HeightVariation(offsetTvLeft);\\n    float heightVariationTvRight = HeightVariation(offsetTvRight);\\n    vec3 bumpHeight = WoodBumpHeight(heightVariationTuLeft, heightVariationTuRight, heightVariationTvLeft, heightVariationTvRight);\\n    vec3 newNormal = normalize(bumpHeight.x * Tu + bumpHeight.y * Tv + bumpHeight.z * vtNormal);\\n    vec3 newNormalView = normalize(vNormalMatrix * newNormal);\\n    vec3 selectedNormal = SelectNormal(geoNormal, newNormalView, V);\\n    ComputeTangents(selectedNormal, Tu, Tv);\\n    Tu = normalize(Tu);\\n    Tv = normalize(Tv);\\n    N = faceforward(selectedNormal, -V, selectedNormal);\\n}\\n#endif\\n#endif\\n\";","module.exports = \"\\nuniform float shadowESMConstant;\\nuniform float shadowMapRangeMin;\\nuniform float shadowMapRangeSize;\\n\";","module.exports = \"\\n#ifdef USE_SHADOWMAP\\nuniform sampler2D shadowMap;\\nuniform vec2      shadowMapSize;\\nuniform float     shadowDarkness;\\nuniform float     shadowBias;\\nuniform vec3      shadowLightDir;\\nvarying vec4 vShadowCoord;\\n#include<shadowmap_decl_common>\\nfloat getShadowValue() {\\n    float fDepth;\\n    vec3 shadowColor = vec3( 1.0 );\\n    vec3 shadowCoord = vShadowCoord.xyz / vShadowCoord.w;\\n    shadowCoord.xyz = 0.5 * (shadowCoord.xyz + vec3(1.0, 1.0, 1.0));\\n    bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\\n    bool inFrustum = all( inFrustumVec );\\n    float shadowValue = 1.0;\\n    if (inFrustum) {\\n        shadowCoord.z = min(0.999, shadowCoord.z);\\n        shadowCoord.z -= shadowBias;\\n#ifdef USE_HARD_SHADOWS\\n        vec4 rgbaDepth = texture2D( shadowMap, shadowCoord.xy );\\n        float fDepth = rgbaDepth.r;\\n        if ( fDepth < shadowCoord.z ) {\\n            shadowValue = 1.0 - shadowDarkness;\\n        }\\n#else\\n        vec4 rgbaDepth = texture2D( shadowMap, shadowCoord.xy );\\n        float shadowMapValue = rgbaDepth.r;\\n        shadowValue = exp(-shadowESMConstant * shadowCoord.z) * shadowMapValue;\\n        shadowValue = min(shadowValue, 1.0);\\n        shadowValue = mix(1.0 - shadowDarkness, 1.0, shadowValue);\\n#endif\\n    }\\n    return shadowValue;\\n}\\n#else\\nfloat getShadowValue() { return 1.0; }\\n#endif\\nvec3 applyEnvShadow(vec3 colorWithoutShadow, vec3 worldNormal) {\\n#if defined(USE_SHADOWMAP)\\n    float dp  = dot(shadowLightDir, worldNormal);\\n    float dpValue = (dp + 1.0) / 2.0;\\n    dpValue = min(1.0, dpValue * 1.5);\\n    float sv = getShadowValue();\\n    vec3 result = colorWithoutShadow * min(sv, dpValue);\\n    return result;\\n#else\\n    return colorWithoutShadow;\\n#endif\\n}\\n\";","module.exports = \"\\n#ifdef USE_SHADOWMAP\\nvarying vec4 vShadowCoord;\\nuniform mat4 shadowMatrix;\\n#endif\\n\";","module.exports = \"\\n#ifdef USE_SHADOWMAP\\n{\\n    vec4 worldPosition = modelMatrix * vec4( position, 1.0 );\\n    vShadowCoord = shadowMatrix * worldPosition;\\n}\\n#endif\\n\";","module.exports = \"uniform vec4 themingColor;\\n\";","module.exports = \"gl_FragColor.rgb = mix(gl_FragColor.rgb, themingColor.rgb, themingColor.a);\\n\";","module.exports = \"\\nfloat luminance_post(vec3 rgb) {\\n    return dot(rgb, vec3(0.299, 0.587, 0.114));\\n}\\nfloat luminance_pre(vec3 rgb) {\\n    return dot(rgb, vec3(0.212671, 0.715160, 0.072169));\\n}\\nvec3 xyz2rgb(vec3 xyz) {\\n    vec3 R = vec3( 3.240479, -1.537150, -0.498535);\\n    vec3 G = vec3(-0.969256,  1.875992,  0.041556);\\n    vec3 B = vec3( 0.055648, -0.204043,  1.057311);\\n    vec3 rgb;\\n    rgb.b = dot(xyz, B);\\n    rgb.g = dot(xyz, G);\\n    rgb.r = dot(xyz, R);\\n    return rgb;\\n}\\nvec3 rgb2xyz(vec3 rgb) {\\n    vec3 X = vec3(0.412453, 0.35758, 0.180423);\\n    vec3 Y = vec3(0.212671, 0.71516, 0.0721688);\\n    vec3 Z = vec3(0.0193338, 0.119194, 0.950227);\\n    vec3 xyz;\\n    xyz.x = dot(rgb, X);\\n    xyz.y = dot(rgb, Y);\\n    xyz.z = dot(rgb, Z);\\n    return xyz;\\n}\\nvec3 xyz2xyY(vec3 xyz) {\\n    float sum = xyz.x + xyz.y + xyz.z;\\n    sum = 1.0 / sum;\\n    vec3 xyY;\\n    xyY.z = xyz.y;\\n    xyY.x = xyz.x * sum;\\n    xyY.y = xyz.y * sum;\\n    return xyY;\\n}\\nvec3 xyY2xyz(vec3 xyY) {\\n    float x = xyY.x;\\n    float y = xyY.y;\\n    float Y = xyY.z;\\n    vec3 xyz;\\n    xyz.y = Y;\\n    xyz.x = x * (Y / y);\\n    xyz.z = (1.0 - x - y) * (Y / y);\\n    return xyz;\\n}\\nfloat toneMapCanon_T(float x)\\n{\\n    float xpow = pow(x, 1.60525727);\\n    float tmp = ((1.05542877*4.68037409)*xpow) / (4.68037409*xpow + 1.0);\\n    return clamp(tmp, 0.0, 1.0);\\n}\\nconst float Shift = 1.0 / 0.18;\\nfloat toneMapCanonFilmic_NoGamma(float x) {\\n    x *= Shift;\\n    const float A = 0.2;\\n    const float B = 0.34;\\n    const float C = 0.002;\\n    const float D = 1.68;\\n    const float E = 0.0005;\\n    const float F = 0.252;\\n    const float scale = 1.0/0.833837;\\n    return (((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F))-E/F) * scale;\\n}\\nvec3 toneMapCanonFilmic_WithGamma(vec3 x) {\\n    x *= Shift;\\n    const float A = 0.27;\\n    const float B = 0.29;\\n    const float C = 0.052;\\n    const float D = 0.2;\\n    const float F = 0.18;\\n    const float scale = 1.0/0.897105;\\n    return (((x*(A*x+C*B))/(x*(A*x+B)+D*F))) * scale;\\n}\\nvec3 toneMapCanonOGS_WithGamma_WithColorPerserving(vec3 x) {\\n    vec3 outColor = x.rgb;\\n    outColor = min(outColor, vec3(3.0));\\n    float inLum = luminance_pre(outColor);\\n    if (inLum > 0.0) {\\n        float outLum = toneMapCanon_T(inLum);\\n        outColor = outColor * (outLum / inLum);\\n        outColor = clamp(outColor, vec3(0.0), vec3(1.0));\\n    }\\n    float gamma = 1.0/2.2;\\n    outColor = pow(outColor, vec3(gamma));\\n    return outColor;\\n}\\n\";","module.exports = \"\\n#ifdef WIDE_LINES\\nattribute vec3 prev;\\nattribute vec3 next;\\nattribute float side;\\nuniform vec2 view_size;\\nvec2 to2d(vec4 i) {\\n  return i.xy / i.w;\\n}\\n#endif\\n\";","module.exports = \"\\n#ifdef WIDE_LINES\\nvec4 mvpPosition = projectionMatrix * mvPosition; \\nmat3 vectorMatrix = mat3(modelViewMatrix);\\nvec2 _pos = to2d(mvpPosition) * view_size;\\nvec2 _prev = to2d(projectionMatrix * vec4(mvPosition.xyz + vectorMatrix * (prev * 0.01), 1.0)) * view_size;\\nvec2 _next = to2d(projectionMatrix * vec4(mvPosition.xyz - vectorMatrix * (next * 0.01), 1.0)) * view_size;\\nvec2 dir1 = _pos - _next;\\nvec2 dir2 = _prev - _pos;\\ndir2 = (length(dir2) > 0.0000001) ? normalize(dir2) : vec2(0.0, 0.0);\\ndir1 = (length(dir1) > 0.0000001) ? normalize(dir1) : dir2;\\nvec2 dir_sharp = normalize(dir1 + dir2);\\nvec2 dir = normalize(dir1 + dir_sharp);\\nvec2 offset = vec2(-dir.y, dir.x);\\nfloat len = 1.0 / cross(vec3(offset, 0), vec3(dir1, 0)).z;\\noffset *= len;\\noffset /= view_size;\\noffset *= side;\\noffset *= mvpPosition.w;\\nmvpPosition.xy += offset;\\ngl_Position = mvpPosition;\\n#endif\\n\";","module.exports = \"varying vec2 vUv;\\nvoid main() {\\n    vUv = uv;\\n    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n}\\n\";"],"mappings":";;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AClFA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC5PA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACRA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC7BA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACpMA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACxBA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AC5GA;;;;;;;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC3BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AClBA;AACA;AACA;AACA;;;;;;;;;;;;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC7CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AClBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC9LA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC9BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC5BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC5BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACpEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC/DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;ACnBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AC7VA;;;;;;;;;;;ACAA;;;;;;;;;;;ACAA;;;;;;;;;;;ACAA;;;;;;;;;;;ACAA;;;;;;;;;;;ACAA;;;;;;;;;;;ACAA;;;;;;;;;;;ACAA;;;;;;;;;;;ACAA;;;;;;;;;;;ACAA;;;;;;;;;;;ACAA;;;;;;;;;;;ACAA;;;;;;;;;;;ACAA;;;;;;;;;;;ACAA;;;;;;;;;;;ACAA;;;;;;;;;;;ACAA;;;;;;;;;;;ACAA;;;;;;;;;;;ACAA;;;;;;;;;;;ACAA;;;;;;;;;;;ACAA;;;;;;;;;;;ACAA;;;;;;;;;;;ACAA;;;;;;;;;;;ACAA;;;;;;;;;;;ACAA;;;;;;;;;;;ACAA;;;;;;;;;;;ACAA;;;;;;;;;;;ACAA;;;;;;;;;;;ACAA;;;;;;;;;;;ACAA;;;;;;;;;;;ACAA;;;;;;;;;;;ACAA;;;;;;;;;;;ACAA;;;;;;;;;;;;;;;A","sourceRoot":""}