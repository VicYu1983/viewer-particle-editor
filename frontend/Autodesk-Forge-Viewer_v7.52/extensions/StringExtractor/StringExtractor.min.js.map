{"version":3,"sources":["webpack://Autodesk.Extensions.[name]/webpack/bootstrap","webpack://Autodesk.Extensions.[name]/./src/file-loaders/lmvtk/common/StringUtils.js","webpack://Autodesk.Extensions.[name]/./extensions/StringExtractor/StringHelpers.js","webpack://Autodesk.Extensions.[name]/./extensions/StringExtractor/StringExtractor.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","utf8BlobToStr","array","start","length","out","len","char2","char3","String","fromCharCode","StringHelpers","loadLeafletStrings","model","role","bubble","getData","loadOptions","bubbleNode","doc","getDocumentNode","getRootNode","getDocument","nodes","search","urn","guid","av","Autodesk","Viewing","avp","Private","Promise","resolve","reject","getFullPath","acmSessionId","getAcmSessionId","getItemOptions","responseType","skipAssetCallback","encodeURIComponent","acmsession","msg","queryParams","isOffline","window","location","origin","ViewingService","getItem","initLoadContext","response","error","fetchLeafletStrings","then","data","strings","JSON","parse","catch","loadStringsFromModel","formattedStrings","anglesExist","stringAngles","tempStringBox","stringBoxes","slice","min","THREE","Vector2","max","bBox","Box2","stringData","string","boundingBox","stringCharWidths","stringPosition","stringPositions","stringHeight","stringHeights","stringWidths","stringWidth","angle","push","formatleafletStrings","leafletStrings","modelBBox","getBoundingBox","size","items","text","frame","p1X","x","p2X","p1Y","p2Y","isPageCoordinates","y","p1","p2","setFromPoints","xUnit","yUnit","tempString","words","j","top","bbox","height","width","left","minX","minY","maxX","maxY","StringExtractor","viewer","options","documentStrings","extractStringsFromModels","this","addEventListener","MODEL_ROOT_LOADED_EVENT","GEOMETRY_LOADED_EVENT","removeEventListener","result","models","getVisibleModels","promisesArray","extractStringsFromModel","all","isLoadDone","is2d","id","underlayRaster","isPdf","vectorStrings","isLeaflet","f2dStrings","Extension","theExtensionManager","registerExtension"],"mappings":"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","file":"StringExtractor/StringExtractor.min.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 870);\n","\"use strict\";\n\n// http://www.onicos.com/staff/iz/amuse/javascript/expert/utf.txt\n/* utf.js - UTF-8 <=> UTF-16 convertion\n *\n * Copyright (C) 1999 Masanao Izumo <iz@onicos.co.jp>\n * Version: 1.0\n * LastModified: Dec 25 1999\n * This library is free.  You can redistribute it and/or modify it.\n */\nexport function utf8BlobToStr(array, start, length) {\n    var out, i, len, c;\n    var char2, char3;\n\n    out = '';\n    len = length;\n    i = 0;\n    while(i < len) {\n        c = array[start + i++];\n        switch(c >> 4)\n        {\n          case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7:\n            // 0xxxxxxx\n            out += String.fromCharCode(c);\n            break;\n          case 12: case 13:\n            // 110x xxxx   10xx xxxx\n            char2 = array[start + i++];\n            out += String.fromCharCode(((c & 0x1F) << 6) | (char2 & 0x3F));\n            break;\n          case 14:\n            // 1110 xxxx  10xx xxxx  10xx xxxx\n            char2 = array[start + i++];\n            char3 = array[start + i++];\n            out += String.fromCharCode(((c & 0x0F) << 12) |\n                                       ((char2 & 0x3F) << 6) |\n                                       ((char3 & 0x3F) << 0));\n            break;\n        }\n    }\n\n    return out;\n}\n\n/**\n * Safe version of utf8BlobToStr(), where Arrays are used to concatenate chars via join().\n * This function exists because string::operator += crashes on Chrome with large inputs.\n */\nexport function safeUtf8BlobToStr(array, start, length) {\n    var out, i, len, c, outArray, count;\n    var char2, char3;\n\n    var STR_CVT_LIMIT = 32 * 1024;\n    out = '';\n    outArray = [];\n    len = length;\n    count = 0;\n    i = 0;\n    while(i < len) {\n        c = array[start + i++];\n        switch(c >> 4)\n        {\n          case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7:\n            // 0xxxxxxx\n            outArray.push(String.fromCharCode(c));\n            break;\n          case 12: case 13:\n            // 110x xxxx   10xx xxxx\n            char2 = array[start + i++];\n            outArray.push(String.fromCharCode(((c & 0x1F) << 6) | (char2 & 0x3F)));\n            break;\n          case 14:\n            // 1110 xxxx  10xx xxxx  10xx xxxx\n            char2 = array[start + i++];\n            char3 = array[start + i++];\n            outArray.push(String.fromCharCode(((c & 0x0F) << 12) |\n                                              ((char2 & 0x3F) << 6) |\n                                              ((char3 & 0x3F) << 0)));\n            break;\n        }\n        if (++count >= STR_CVT_LIMIT || i >= len) {\n            out += outArray.join(\"\");\n            outArray.length = 0;\n            count = 0;\n        }\n    }\n\n    return out;\n}\n\n\nexport function utf16to8(str, array, start) {\n    var i, len, c;\n\n    var j = start || 0;\n    len = str.length;\n\n    if (array) {\n        for(i = 0; i < len; i++) {\n            c = str.charCodeAt(i);\n            if ((c >= 0x0001) && (c <= 0x007F)) {\n                array[j++] = c;\n            } else if (c > 0x07FF) {\n                array[j++] = 0xE0 | ((c >> 12) & 0x0F);\n                array[j++] = 0x80 | ((c >>  6) & 0x3F);\n                array[j++] = 0x80 | ((c >>  0) & 0x3F);\n            } else {\n                array[j++] = 0xC0 | ((c >>  6) & 0x1F);\n                array[j++] = 0x80 | ((c >>  0) & 0x3F);\n            }\n        }\n    } else {\n        //If no output buffer is passed in, estimate the required\n        //buffer size and return that.\n        for(i = 0; i < len; i++) {\n            c = str.charCodeAt(i);\n            if ((c >= 0x0001) && (c <= 0x007F)) {\n                j++;\n            } else if (c > 0x07FF) {\n                j+=3;\n            } else {\n                j+=2;\n            }\n        }\n    }\n\n    return j - (start || 0);\n}\n\n\nvar USE_MANUAL_UTF8 = true;\nvar SAFE_UTF_LENGTH = 1024 * 1024;\n\nexport function utf8ArrayToString(array, start, length) {\n\n    if (start === undefined)\n        start = 0;\n    if (length === undefined)\n        length = array.length;\n\n    if (USE_MANUAL_UTF8) {\n        if (length > SAFE_UTF_LENGTH) {\n            return safeUtf8BlobToStr(array, start, length);\n        }\n        return utf8BlobToStr(array, start, length);\n    } else {\n        var encodedString = \"\";\n        for (var i=start, iEnd=start+length; i<iEnd; i++)\n            encodedString += String.fromCharCode(array[i]);\n\n        return decodeURIComponent(escape(encodedString));\n    }\n}\n\nexport function blobToJson(blob) {\n\n    var decodedString = utf8ArrayToString(blob, 0, blob.length);\n\n    const regex = /\\u000e/gi;\n    // LMV-6005 Some blobs contained a Shift Out unicode character that could not be parsed by JSON.parse\n    // This caused the property data base to not load.\n    decodedString = decodedString.replace(regex, '');\n\n    return JSON.parse(decodedString);\n}\n\n//parses a piece of json from a given blob (representing an array of json values)\n//up to the next comma+newline combo (i.e. array delimiter).\nexport function subBlobToJson(blob, startIndex) {\n    if (startIndex === undefined) {\n        return '';\n    }\n\n    var i = startIndex;\n\n    while (i<blob.length-1) {\n        var c = blob[i];\n        if (c == 44 && (blob[i+1] == 10 || blob[i+1] == 13)) //comma followed by newline?\n            break;\n        if (c == 10 || c == 13) //detect newline or line feed\n            break;\n        i++;\n    }\n\n    var decodedString = utf8ArrayToString(blob, startIndex, i-startIndex);\n    try {\n        return JSON.parse(decodedString);\n    } catch (e) {\n        console.error(\"Error parsing property blob to JSON : \" + decodedString);\n        return decodedString;\n    }\n}\n\nexport function subBlobToJsonInt(blob, startIndex) {\n    var val = 0;\n    var i = startIndex;\n\n    //Check for integers that were serialized as strings.\n    //This should not happen, ever, but hey, it does.\n    if (blob[i] == 34)\n        i++;\n\n    while (i<blob.length-1) {\n        var c = blob[i];\n        if (c == 44 && (blob[i+1] == 10 || blob[i+1] == 13))\n            break;\n        if (c == 10 || c == 13 || c == 34)\n            break;\n        if (c >= 48 && c <= 57)\n            val = val * 10 + (c - 48);\n\n        i++;\n    }\n\n    return val;\n}\n\n//Simple integer array parse -- expects the array in property database\n//format, where the array is packed with possibly newline separator,\n//but no other white space. Does not do extensive error checking\nexport function parseIntArray(blob, wantSentinel) {\n\n    //find out how many items we have\n    var count = 0;\n    for (var i= 0, iEnd=blob.length; i<iEnd; i++)\n        if (blob[i] == 44) //44 = ','\n            count++;\n\n    count++; //last item has no comma after it\n\n    var items = new Uint32Array(count + (wantSentinel ? 1 : 0));\n\n    i=0;\n    var end = blob.length;\n\n    while (blob[i] != 91 && i<end) //91 = '['\n        i++;\n\n    if (i == blob.length)\n        return null;\n\n    i++;\n\n    var seenDigit = false;\n    count = 0;\n    var curInt = 0;\n    while (i<end) {\n        var c = blob[i];\n        if (c >= 48 && c <= 57) { //digit\n            curInt = 10 * curInt + (c - 48);\n            seenDigit = true;\n        }\n        else if (c == 44 || c == 93) { //',' or ']'\n            if (seenDigit) {\n                items[count++] = curInt;\n                seenDigit = false;\n                curInt = 0;\n            }\n        } else {\n            seenDigit = false; //most likely a newline (the only other thing we have in our arrays\n            curInt = 0;\n        }\n        i++;\n    }\n\n    return items;\n}\n\n//Scans an array of json values (strings, integers, doubles) and finds the\n//offset of each value in the array, so that we can later pick off that\n//specific value, without parsing the whole (potentially huge) json array up front.\n//This expects the input blob to be in the form serialized by the property database\n//C++ component -- one value per line. A more sophisticated parser would be needed\n//in case the format changes and this assumption is not true anymore.\nexport function findValueOffsets(blob) {\n\n    //first, count how many items we have\n    var count = 0;\n    var end = blob.length-1;\n\n    for (var i= 0; i<end; i++) {\n        if ( blob[i] == 44 && (blob[i+1] == 10 || blob[i+1] == 13)) // ',' + newline is the item delimiter\n            count++;\n    }\n\n    if (!count)\n        return null;\n\n    count++; //one for the last item\n\n    var items = new Uint32Array(count);\n\n    i=0;\n    count = 0;\n\n    //find opening [\n    while (blob[i] != 91 && i<end) //91 = '['\n        i++;\n\n    i++;\n\n    items[count++] = i;\n    var seenEol = false;\n    while (i<end) {\n        if (blob[i] == 10 || blob[i] == 13)\n            seenEol = true;\n        else if (seenEol) {\n            seenEol = false;\n            items[count++] = i;\n        }\n\n        i++;\n    }\n\n    return items;\n}\n","import { utf8BlobToStr } from \"../../src/file-loaders/lmvtk/common/StringUtils\";\n\n/**\n * Format output from F2D myData object\n * @param {Object} data - myData object that contains strings and relevant bounding boxes\n * @returns {Array} strings - Array with String ojects. Each object contains text and bounding box as THREE.Box2.\n */\nfunction loadStringsFromModel(data) {\n    let formattedStrings = [];\n    const anglesExist = data.stringAngles ? true : false;\n    \n    for (let i = 0; i < data.strings.length; i++) {\n        const tempStringBox = data.stringBoxes.slice(i * 4, i * 4 + 4);\n        const min = new THREE.Vector2( tempStringBox[0], tempStringBox[1]);\n        const max = new THREE.Vector2( tempStringBox[2], tempStringBox[3]);\n        const bBox = new THREE.Box2(min, max);\n        const stringData = {\n            string: data.strings[i],\n            boundingBox: bBox,\n            stringCharWidths: data.stringCharWidths[i],\n            stringPosition: data.stringPositions[i],\n            stringHeight: data.stringHeights[i],\n            ... (data.stringWidths && {stringWidth: data.stringWidths[i]}),\n        };\n\n        // Add angle for text rotation if available\n        if (anglesExist) {\n            stringData.angle = data.stringAngles[i];\n        }\n        formattedStrings.push(stringData);  \n    }\n    return formattedStrings;\n};\n\n/**\n * Performs string extraction from Leaflet PDF file\n * @returns {Object} return JSON object with all strings in Leaflet document.\n */\nfunction loadLeafletStrings(model) {\n    const role = 'pdf-strings';   \n    const bubble = model.getData().loadOptions.bubbleNode;\n    const doc = model.getDocumentNode().getRootNode().getDocument();\n    const nodes = bubble ? bubble.search({ role }) : null;\n\n    if (!nodes || !nodes[0]) {\n        return Promise.reject(`Node for ${role} not found`);\n    }\n\n    return fetchLeafletStrings(nodes[0].urn(), nodes[0].guid(), doc)\n        .then((data) => {\n            const strings = data ? utf8BlobToStr(data, 0, data.length) : null;\n            return Promise.resolve(strings ? JSON.parse(strings) : null);\n        })\n        .catch(function(error) {\n            return Promise.reject(`No data in ${role}`);\n        });\n}\n\n/**\n * Format output from loadLeafletStrings, remove duplicated data from JSON as \"text\" item\n * @param {Object} model - model of loaded document\n * @param {Object} pdfStrings - JSON with all strings from Leaflet.\n * @returns {Array} formattedStrings - Array with String objects. Each object contains text and bounding box as THREE.Box2.\n */\nfunction formatleafletStrings(model, leafletStrings) {\n    let formattedStrings = [];\n    const modelBBox = model.getBoundingBox(true);\n    const size = modelBBox.size();\n    // 10000 values are related Extractor where stringâ€™s bounding box is in a normalized space defined by 10000*10000\n    // Relevant code in extractor repo: https://git.autodesk.com/BIM360/PDFExtractor/blob/3cdaa75fbc9fb80419b65073b17d2e7fb1357541/PDFExtractor/RasterExtractor/StringExtractor.cpp#L46\n    const extractorScaleFactor = 10000;\n\n    /**\n     * Since there 2 sources of strings, ACC Build and BIM360,\n     * A different formatting needed for those cases.\n     */\n    \n    // Page dimension retrieval for ACC Build based strings\n    if (leafletStrings.items) {\n        leafletStrings = leafletStrings.items;\n        for (let i = 0; i < leafletStrings.length; i++) {\n            if (leafletStrings[i].text && leafletStrings[i].frame) {\n                const p1X = leafletStrings[i].frame[0] * size.x;\n                const p2X = leafletStrings[i].frame[2] * size.x;\n                let p1Y;\n                let p2Y;\n    \n                // Different calculation needed if fitPaperSize provided\n                if (model.isPageCoordinates()) {\n                    p1Y = (1 - leafletStrings[i].frame[1]) * size.y;\n                    p2Y = (1 - leafletStrings[i].frame[3]) * size.y;\n                } else {\n                    p1Y = 1 - leafletStrings[i].frame[1] * size.y;\n                    p2Y = 1 - leafletStrings[i].frame[3] * size.y;\n                }\n    \n                const p1 = new THREE.Vector2(p1X, p1Y);\n                const p2 = new THREE.Vector2(p2X, p2Y);\n                const bBox = new THREE.Box2().setFromPoints([p1, p2]);\n                \n                formattedStrings.push({\n                    string: leafletStrings[i].text,\n                    boundingBox: bBox\n                });\n            }\n        }\n    } else {\n        // Page dimension retrieval for BIM360-like OCR extraction\n        const xUnit = size.x / extractorScaleFactor;\n        const yUnit = size.y / extractorScaleFactor;\n\n        for (let i = 0; i < leafletStrings.length; i++) {\n            const tempString = leafletStrings[i];\n\n            if (tempString.words) {\n                for (let j = 0; j < tempString.words.length; j++) {\n                    const top = tempString.words[j].bbox.top;\n                    const height = tempString.words[j].bbox.height;\n                    const width = tempString.words[j].bbox.width;\n                    const left = tempString.words[j].bbox.left;\n    \n                    const minX = modelBBox.min.x + left * xUnit;\n                    const minY = modelBBox.min.y + (extractorScaleFactor - top - height) * yUnit;\n                    const maxX = modelBBox.min.x + (left + width) * xUnit;\n                    const maxY = modelBBox.min.y + (extractorScaleFactor - top) * yUnit;\n    \n                    const min = new THREE.Vector2(minX, minY);\n                    const max = new THREE.Vector2(maxX, maxY);\n                    const bBox = new THREE.Box2(min, max);\n    \n                    formattedStrings.push({\n                        string: tempString.words[j].text,\n                        boundingBox: bBox\n                    });\n                }\n            }\n        }\n    }\n    \n    return formattedStrings;\n}\n\n/**\n * Intiate HTTP request to get strings from Leaflet file\n * @param {*} urn URN for Leaflet PDF document\n * @param {*} guid Sheet ID of Leaflet document\n * @param {*} doc document from rootNode\n */\nfunction fetchLeafletStrings(urn, guid, doc) {\n    const av = Autodesk.Viewing;\n    const avp = av.Private;\n    return new Promise((resolve, reject) => {\n        urn = doc.getFullPath(urn);\n        const onSuccess = function(response) {\n            resolve(response);\n        };\n\n        const onFailure = function(error) {\n            reject(error);\n        };\n\n        const acmSessionId = doc.getAcmSessionId(urn);\n\n        const getItemOptions = {\n            responseType: 'arraybuffer',\n            skipAssetCallback: true,\n            guid: encodeURIComponent(guid),\n            acmsession: acmSessionId,\n        };\n\n        const msg = {\n            queryParams: acmSessionId ? 'acmsession=' + acmSessionId : '',\n        };\n\n        if (av.isOffline()) {\n            urn = window.location.origin + '/' + urn;\n        };\n        avp.ViewingService.getItem(av.initLoadContext(msg), urn, onSuccess, onFailure, getItemOptions);\n    });\n}\n\nconst StringHelpers = {\n    loadLeafletStrings,\n    loadStringsFromModel,\n    formatleafletStrings,\n};\n\nexport default StringHelpers;","import StringHelpers from './StringHelpers';\n'use strict';\n\nconst av = Autodesk.Viewing;\nconst myExtensionName = 'Autodesk.StringExtractor';\n\nexport default class StringExtractor extends av.Extension {\n    constructor(viewer, options) {\n        super(viewer, options);\n        this.documentStrings = {};\n        this.extractStringsFromModels = this.extractStringsFromModels.bind(this);\n    }\n\n    async load() {\n        // Since content of Viewer might change, as while switching sheets, string extraction repeated on every model load.\n        this.viewer.addEventListener(av.MODEL_ROOT_LOADED_EVENT, this.extractStringsFromModels);\n        this.viewer.addEventListener(av.GEOMETRY_LOADED_EVENT, this.extractStringsFromModels);\n        return true;\n    }\n\n    unload() {\n        this.viewer.removeEventListener(av.MODEL_ROOT_LOADED_EVENT, this.extractStringsFromModels);\n        this.viewer.removeEventListener(av.GEOMETRY_LOADED_EVENT, this.extractStringsFromModels);\n        return true;\n    }\n\n    /**\n     * Performs string extraction from all models in scene\n     * @returns {Promise} Function returns a Promise with array of results all models in scene.\n     */\n    extractStringsFromModels() {\n        const models = this.viewer.getVisibleModels();\n        const promisesArray = [];\n        let result;\n\n        for (let i = 0; i < models.length; i++) {\n            const model = models[i];\n\n            result = this.extractStringsFromModel(model);\n            promisesArray.push(result);\n        }\n        // promisesArray for all request for string extraction.\n        return Promise.all(promisesArray);\n    }\n\n    /**\n     * Performs string extraction from specific model\n     * @param {Object} model - model within which string extraction performed.\n     * @returns {Promise} Promise which is resolved when the data from F2D/Leaflet/PDF document by model type is fetched.\n     */\n    extractStringsFromModel(model) {\n        // Do not extract strings if already cached\n        // Do not fetch temporary leaflet data since vector will load \n        if (!model.isLoadDone() || !model.is2d() || this.documentStrings[model.id] || model.getData().underlayRaster) {\n            return Promise.resolve();\n        }\n\n        if (model.isPdf()) {   \n\n            const vectorStrings = StringHelpers.loadStringsFromModel(model.getData());\n            this.documentStrings[model.id] = {\n                model,\n                strings: vectorStrings,\n            };\n            return Promise.resolve();\n        }\n        else if (model.isLeaflet()) {\n            return StringHelpers.loadLeafletStrings(model).then((result) => {\n                this.documentStrings[model.id] = {\n                    model,\n                    strings: StringHelpers.formatleafletStrings(model, result),\n                };\n            });\n        }\n        else {\n            const f2dStrings = StringHelpers.loadStringsFromModel(model.getData());\n            this.documentStrings[model.id] = {\n                model,\n                strings: f2dStrings,\n            };\n            return Promise.resolve();\n        }\n    }\n\n    /**\n     * @returns {Array} with all strings within scene by initiating String Extraction\n     */\n    getDocumentStrings() {\n        return this.extractStringsFromModels().then(() => {\n            return Promise.resolve(this.documentStrings);\n        });\n    };\n};\n\nav.theExtensionManager.registerExtension(myExtensionName, StringExtractor);\n"],"sourceRoot":""}