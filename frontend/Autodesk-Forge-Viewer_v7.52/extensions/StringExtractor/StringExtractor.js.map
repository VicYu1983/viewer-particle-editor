{"version":3,"file":"StringExtractor/StringExtractor.js","sources":["webpack://Autodesk.Extensions.[name]/webpack/bootstrap","webpack://Autodesk.Extensions.[name]/./extensions/StringExtractor/StringExtractor.js","webpack://Autodesk.Extensions.[name]/./extensions/StringExtractor/StringHelpers.js","webpack://Autodesk.Extensions.[name]/./src/file-loaders/lmvtk/common/StringUtils.js"],"sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./extensions/StringExtractor/StringExtractor.js\");\n","function _typeof(obj) {\"@babel/helpers - typeof\";if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;};}return _typeof(obj);}function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {try {var info = gen[key](arg);var value = info.value;} catch (error) {reject(error);return;}if (info.done) {resolve(value);} else {Promise.resolve(value).then(_next, _throw);}}function _asyncToGenerator(fn) {return function () {var self = this,args = arguments;return new Promise(function (resolve, reject) {var gen = fn.apply(self, args);function _next(value) {asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);}function _throw(err) {asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);}_next(undefined);});};}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError(\"Cannot call a class as a function\");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}function _inherits(subClass, superClass) {if (typeof superClass !== \"function\" && superClass !== null) {throw new TypeError(\"Super expression must either be null or a function\");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}function _createSuper(Derived) {var hasNativeReflectConstruct = _isNativeReflectConstruct();return function _createSuperInternal() {var Super = _getPrototypeOf(Derived),result;if (hasNativeReflectConstruct) {var NewTarget = _getPrototypeOf(this).constructor;result = Reflect.construct(Super, arguments, NewTarget);} else {result = Super.apply(this, arguments);}return _possibleConstructorReturn(this, result);};}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");}return self;}function _isNativeReflectConstruct() {if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;if (Reflect.construct.sham) return false;if (typeof Proxy === \"function\") return true;try {Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));return true;} catch (e) {return false;}}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}import StringHelpers from './StringHelpers';\n'use strict';\n\nvar av = Autodesk.Viewing;\nvar myExtensionName = 'Autodesk.StringExtractor';var\n\nStringExtractor = /*#__PURE__*/function (_av$Extension) {_inherits(StringExtractor, _av$Extension);var _super = _createSuper(StringExtractor);\n  function StringExtractor(viewer, options) {var _this;_classCallCheck(this, StringExtractor);\n    _this = _super.call(this, viewer, options);\n    _this.documentStrings = {};\n    _this.extractStringsFromModels = _this.extractStringsFromModels.bind(_assertThisInitialized(_this));return _this;\n  }_createClass(StringExtractor, [{ key: \"load\", value: function () {var _load = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {return regeneratorRuntime.wrap(function _callee$(_context) {while (1) {switch (_context.prev = _context.next) {case 0:\n\n\n                // Since content of Viewer might change, as while switching sheets, string extraction repeated on every model load.\n                this.viewer.addEventListener(av.MODEL_ROOT_LOADED_EVENT, this.extractStringsFromModels);\n                this.viewer.addEventListener(av.GEOMETRY_LOADED_EVENT, this.extractStringsFromModels);return _context.abrupt(\"return\",\n                true);case 3:case \"end\":return _context.stop();}}}, _callee, this);}));function load() {return _load.apply(this, arguments);}return load;}() }, { key: \"unload\", value: function unload()\n\n\n    {\n      this.viewer.removeEventListener(av.MODEL_ROOT_LOADED_EVENT, this.extractStringsFromModels);\n      this.viewer.removeEventListener(av.GEOMETRY_LOADED_EVENT, this.extractStringsFromModels);\n      return true;\n    }\n\n    /**\n       * Performs string extraction from all models in scene\n       * @returns {Promise} Function returns a Promise with array of results all models in scene.\n       */ }, { key: \"extractStringsFromModels\", value: function extractStringsFromModels()\n    {\n      var models = this.viewer.getVisibleModels();\n      var promisesArray = [];\n      var result;\n\n      for (var i = 0; i < models.length; i++) {\n        var model = models[i];\n\n        result = this.extractStringsFromModel(model);\n        promisesArray.push(result);\n      }\n      // promisesArray for all request for string extraction.\n      return Promise.all(promisesArray);\n    }\n\n    /**\n       * Performs string extraction from specific model\n       * @param {Object} model - model within which string extraction performed.\n       * @returns {Promise} Promise which is resolved when the data from F2D/Leaflet/PDF document by model type is fetched.\n       */ }, { key: \"extractStringsFromModel\", value: function extractStringsFromModel(\n    model) {var _this2 = this;\n      // Do not extract strings if already cached\n      // Do not fetch temporary leaflet data since vector will load \n      if (!model.isLoadDone() || !model.is2d() || this.documentStrings[model.id] || model.getData().underlayRaster) {\n        return Promise.resolve();\n      }\n\n      if (model.isPdf()) {\n\n        var vectorStrings = StringHelpers.loadStringsFromModel(model.getData());\n        this.documentStrings[model.id] = {\n          model: model,\n          strings: vectorStrings };\n\n        return Promise.resolve();\n      } else\n      if (model.isLeaflet()) {\n        return StringHelpers.loadLeafletStrings(model).then(function (result) {\n          _this2.documentStrings[model.id] = {\n            model: model,\n            strings: StringHelpers.formatleafletStrings(model, result) };\n\n        });\n      } else\n      {\n        var f2dStrings = StringHelpers.loadStringsFromModel(model.getData());\n        this.documentStrings[model.id] = {\n          model: model,\n          strings: f2dStrings };\n\n        return Promise.resolve();\n      }\n    }\n\n    /**\n       * @returns {Array} with all strings within scene by initiating String Extraction\n       */ }, { key: \"getDocumentStrings\", value: function getDocumentStrings()\n    {var _this3 = this;\n      return this.extractStringsFromModels().then(function () {\n        return Promise.resolve(_this3.documentStrings);\n      });\n    } }]);return StringExtractor;}(av.Extension);export { StringExtractor as default };\n;\n\nav.theExtensionManager.registerExtension(myExtensionName, StringExtractor);","function ownKeys(object, enumerableOnly) {var keys = Object.keys(object);if (Object.getOwnPropertySymbols) {var symbols = Object.getOwnPropertySymbols(object);if (enumerableOnly) symbols = symbols.filter(function (sym) {return Object.getOwnPropertyDescriptor(object, sym).enumerable;});keys.push.apply(keys, symbols);}return keys;}function _objectSpread(target) {for (var i = 1; i < arguments.length; i++) {var source = arguments[i] != null ? arguments[i] : {};if (i % 2) {ownKeys(Object(source), true).forEach(function (key) {_defineProperty(target, key, source[key]);});} else if (Object.getOwnPropertyDescriptors) {Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));} else {ownKeys(Object(source)).forEach(function (key) {Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));});}}return target;}function _defineProperty(obj, key, value) {if (key in obj) {Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true });} else {obj[key] = value;}return obj;}import { utf8BlobToStr } from \"../../src/file-loaders/lmvtk/common/StringUtils\";\n\n/**\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             * Format output from F2D myData object\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             * @param {Object} data - myData object that contains strings and relevant bounding boxes\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             * @returns {Array} strings - Array with String ojects. Each object contains text and bounding box as THREE.Box2.\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             */\nfunction loadStringsFromModel(data) {\n  var formattedStrings = [];\n  var anglesExist = data.stringAngles ? true : false;\n\n  for (var i = 0; i < data.strings.length; i++) {\n    var tempStringBox = data.stringBoxes.slice(i * 4, i * 4 + 4);\n    var min = new THREE.Vector2(tempStringBox[0], tempStringBox[1]);\n    var max = new THREE.Vector2(tempStringBox[2], tempStringBox[3]);\n    var bBox = new THREE.Box2(min, max);\n    var stringData = _objectSpread({\n      string: data.strings[i],\n      boundingBox: bBox,\n      stringCharWidths: data.stringCharWidths[i],\n      stringPosition: data.stringPositions[i],\n      stringHeight: data.stringHeights[i] },\n    data.stringWidths && { stringWidth: data.stringWidths[i] });\n\n\n    // Add angle for text rotation if available\n    if (anglesExist) {\n      stringData.angle = data.stringAngles[i];\n    }\n    formattedStrings.push(stringData);\n  }\n  return formattedStrings;\n};\n\n/**\n    * Performs string extraction from Leaflet PDF file\n    * @returns {Object} return JSON object with all strings in Leaflet document.\n    */\nfunction loadLeafletStrings(model) {\n  var role = 'pdf-strings';\n  var bubble = model.getData().loadOptions.bubbleNode;\n  var doc = model.getDocumentNode().getRootNode().getDocument();\n  var nodes = bubble ? bubble.search({ role: role }) : null;\n\n  if (!nodes || !nodes[0]) {\n    return Promise.reject(\"Node for \".concat(role, \" not found\"));\n  }\n\n  return fetchLeafletStrings(nodes[0].urn(), nodes[0].guid(), doc).\n  then(function (data) {\n    var strings = data ? utf8BlobToStr(data, 0, data.length) : null;\n    return Promise.resolve(strings ? JSON.parse(strings) : null);\n  }).\n  catch(function (error) {\n    return Promise.reject(\"No data in \".concat(role));\n  });\n}\n\n/**\n   * Format output from loadLeafletStrings, remove duplicated data from JSON as \"text\" item\n   * @param {Object} model - model of loaded document\n   * @param {Object} pdfStrings - JSON with all strings from Leaflet.\n   * @returns {Array} formattedStrings - Array with String objects. Each object contains text and bounding box as THREE.Box2.\n   */\nfunction formatleafletStrings(model, leafletStrings) {\n  var formattedStrings = [];\n  var modelBBox = model.getBoundingBox(true);\n  var size = modelBBox.size();\n  // 10000 values are related Extractor where stringâ€™s bounding box is in a normalized space defined by 10000*10000\n  // Relevant code in extractor repo: https://git.autodesk.com/BIM360/PDFExtractor/blob/3cdaa75fbc9fb80419b65073b17d2e7fb1357541/PDFExtractor/RasterExtractor/StringExtractor.cpp#L46\n  var extractorScaleFactor = 10000;\n\n  /**\n                                     * Since there 2 sources of strings, ACC Build and BIM360,\n                                     * A different formatting needed for those cases.\n                                     */\n\n  // Page dimension retrieval for ACC Build based strings\n  if (leafletStrings.items) {\n    leafletStrings = leafletStrings.items;\n    for (var i = 0; i < leafletStrings.length; i++) {\n      if (leafletStrings[i].text && leafletStrings[i].frame) {\n        var p1X = leafletStrings[i].frame[0] * size.x;\n        var p2X = leafletStrings[i].frame[2] * size.x;\n        var p1Y = void 0;\n        var p2Y = void 0;\n\n        // Different calculation needed if fitPaperSize provided\n        if (model.isPageCoordinates()) {\n          p1Y = (1 - leafletStrings[i].frame[1]) * size.y;\n          p2Y = (1 - leafletStrings[i].frame[3]) * size.y;\n        } else {\n          p1Y = 1 - leafletStrings[i].frame[1] * size.y;\n          p2Y = 1 - leafletStrings[i].frame[3] * size.y;\n        }\n\n        var p1 = new THREE.Vector2(p1X, p1Y);\n        var p2 = new THREE.Vector2(p2X, p2Y);\n        var bBox = new THREE.Box2().setFromPoints([p1, p2]);\n\n        formattedStrings.push({\n          string: leafletStrings[i].text,\n          boundingBox: bBox });\n\n      }\n    }\n  } else {\n    // Page dimension retrieval for BIM360-like OCR extraction\n    var xUnit = size.x / extractorScaleFactor;\n    var yUnit = size.y / extractorScaleFactor;\n\n    for (var _i = 0; _i < leafletStrings.length; _i++) {\n      var tempString = leafletStrings[_i];\n\n      if (tempString.words) {\n        for (var j = 0; j < tempString.words.length; j++) {\n          var top = tempString.words[j].bbox.top;\n          var height = tempString.words[j].bbox.height;\n          var width = tempString.words[j].bbox.width;\n          var left = tempString.words[j].bbox.left;\n\n          var minX = modelBBox.min.x + left * xUnit;\n          var minY = modelBBox.min.y + (extractorScaleFactor - top - height) * yUnit;\n          var maxX = modelBBox.min.x + (left + width) * xUnit;\n          var maxY = modelBBox.min.y + (extractorScaleFactor - top) * yUnit;\n\n          var min = new THREE.Vector2(minX, minY);\n          var max = new THREE.Vector2(maxX, maxY);\n          var _bBox = new THREE.Box2(min, max);\n\n          formattedStrings.push({\n            string: tempString.words[j].text,\n            boundingBox: _bBox });\n\n        }\n      }\n    }\n  }\n\n  return formattedStrings;\n}\n\n/**\n   * Intiate HTTP request to get strings from Leaflet file\n   * @param {*} urn URN for Leaflet PDF document\n   * @param {*} guid Sheet ID of Leaflet document\n   * @param {*} doc document from rootNode\n   */\nfunction fetchLeafletStrings(urn, guid, doc) {\n  var av = Autodesk.Viewing;\n  var avp = av.Private;\n  return new Promise(function (resolve, reject) {\n    urn = doc.getFullPath(urn);\n    var onSuccess = function onSuccess(response) {\n      resolve(response);\n    };\n\n    var onFailure = function onFailure(error) {\n      reject(error);\n    };\n\n    var acmSessionId = doc.getAcmSessionId(urn);\n\n    var getItemOptions = {\n      responseType: 'arraybuffer',\n      skipAssetCallback: true,\n      guid: encodeURIComponent(guid),\n      acmsession: acmSessionId };\n\n\n    var msg = {\n      queryParams: acmSessionId ? 'acmsession=' + acmSessionId : '' };\n\n\n    if (av.isOffline()) {\n      urn = window.location.origin + '/' + urn;\n    };\n    avp.ViewingService.getItem(av.initLoadContext(msg), urn, onSuccess, onFailure, getItemOptions);\n  });\n}\n\nvar StringHelpers = {\n  loadLeafletStrings: loadLeafletStrings,\n  loadStringsFromModel: loadStringsFromModel,\n  formatleafletStrings: formatleafletStrings };\n\n\nexport default StringHelpers;","\"use strict\";\n\n// http://www.onicos.com/staff/iz/amuse/javascript/expert/utf.txt\n/* utf.js - UTF-8 <=> UTF-16 convertion\n *\n * Copyright (C) 1999 Masanao Izumo <iz@onicos.co.jp>\n * Version: 1.0\n * LastModified: Dec 25 1999\n * This library is free.  You can redistribute it and/or modify it.\n */\nexport function utf8BlobToStr(array, start, length) {\n  var out, i, len, c;\n  var char2, char3;\n\n  out = '';\n  len = length;\n  i = 0;\n  while (i < len) {\n    c = array[start + i++];\n    switch (c >> 4) {\n\n      case 0:case 1:case 2:case 3:case 4:case 5:case 6:case 7:\n        // 0xxxxxxx\n        out += String.fromCharCode(c);\n        break;\n      case 12:case 13:\n        // 110x xxxx   10xx xxxx\n        char2 = array[start + i++];\n        out += String.fromCharCode((c & 0x1F) << 6 | char2 & 0x3F);\n        break;\n      case 14:\n        // 1110 xxxx  10xx xxxx  10xx xxxx\n        char2 = array[start + i++];\n        char3 = array[start + i++];\n        out += String.fromCharCode((c & 0x0F) << 12 |\n        (char2 & 0x3F) << 6 |\n        (char3 & 0x3F) << 0);\n        break;}\n\n  }\n\n  return out;\n}\n\n/**\n   * Safe version of utf8BlobToStr(), where Arrays are used to concatenate chars via join().\n   * This function exists because string::operator += crashes on Chrome with large inputs.\n   */\nexport function safeUtf8BlobToStr(array, start, length) {\n  var out, i, len, c, outArray, count;\n  var char2, char3;\n\n  var STR_CVT_LIMIT = 32 * 1024;\n  out = '';\n  outArray = [];\n  len = length;\n  count = 0;\n  i = 0;\n  while (i < len) {\n    c = array[start + i++];\n    switch (c >> 4) {\n\n      case 0:case 1:case 2:case 3:case 4:case 5:case 6:case 7:\n        // 0xxxxxxx\n        outArray.push(String.fromCharCode(c));\n        break;\n      case 12:case 13:\n        // 110x xxxx   10xx xxxx\n        char2 = array[start + i++];\n        outArray.push(String.fromCharCode((c & 0x1F) << 6 | char2 & 0x3F));\n        break;\n      case 14:\n        // 1110 xxxx  10xx xxxx  10xx xxxx\n        char2 = array[start + i++];\n        char3 = array[start + i++];\n        outArray.push(String.fromCharCode((c & 0x0F) << 12 |\n        (char2 & 0x3F) << 6 |\n        (char3 & 0x3F) << 0));\n        break;}\n\n    if (++count >= STR_CVT_LIMIT || i >= len) {\n      out += outArray.join(\"\");\n      outArray.length = 0;\n      count = 0;\n    }\n  }\n\n  return out;\n}\n\n\nexport function utf16to8(str, array, start) {\n  var i, len, c;\n\n  var j = start || 0;\n  len = str.length;\n\n  if (array) {\n    for (i = 0; i < len; i++) {\n      c = str.charCodeAt(i);\n      if (c >= 0x0001 && c <= 0x007F) {\n        array[j++] = c;\n      } else if (c > 0x07FF) {\n        array[j++] = 0xE0 | c >> 12 & 0x0F;\n        array[j++] = 0x80 | c >> 6 & 0x3F;\n        array[j++] = 0x80 | c >> 0 & 0x3F;\n      } else {\n        array[j++] = 0xC0 | c >> 6 & 0x1F;\n        array[j++] = 0x80 | c >> 0 & 0x3F;\n      }\n    }\n  } else {\n    //If no output buffer is passed in, estimate the required\n    //buffer size and return that.\n    for (i = 0; i < len; i++) {\n      c = str.charCodeAt(i);\n      if (c >= 0x0001 && c <= 0x007F) {\n        j++;\n      } else if (c > 0x07FF) {\n        j += 3;\n      } else {\n        j += 2;\n      }\n    }\n  }\n\n  return j - (start || 0);\n}\n\n\nvar USE_MANUAL_UTF8 = true;\nvar SAFE_UTF_LENGTH = 1024 * 1024;\n\nexport function utf8ArrayToString(array, start, length) {\n\n  if (start === undefined)\n  start = 0;\n  if (length === undefined)\n  length = array.length;\n\n  if (USE_MANUAL_UTF8) {\n    if (length > SAFE_UTF_LENGTH) {\n      return safeUtf8BlobToStr(array, start, length);\n    }\n    return utf8BlobToStr(array, start, length);\n  } else {\n    var encodedString = \"\";\n    for (var i = start, iEnd = start + length; i < iEnd; i++) {\n      encodedString += String.fromCharCode(array[i]);}\n\n    return decodeURIComponent(escape(encodedString));\n  }\n}\n\nexport function blobToJson(blob) {\n\n  var decodedString = utf8ArrayToString(blob, 0, blob.length);\n\n  var regex = /\\u000e/gi;\n  // LMV-6005 Some blobs contained a Shift Out unicode character that could not be parsed by JSON.parse\n  // This caused the property data base to not load.\n  decodedString = decodedString.replace(regex, '');\n\n  return JSON.parse(decodedString);\n}\n\n//parses a piece of json from a given blob (representing an array of json values)\n//up to the next comma+newline combo (i.e. array delimiter).\nexport function subBlobToJson(blob, startIndex) {\n  if (startIndex === undefined) {\n    return '';\n  }\n\n  var i = startIndex;\n\n  while (i < blob.length - 1) {\n    var c = blob[i];\n    if (c == 44 && (blob[i + 1] == 10 || blob[i + 1] == 13)) //comma followed by newline?\n      break;\n    if (c == 10 || c == 13) //detect newline or line feed\n      break;\n    i++;\n  }\n\n  var decodedString = utf8ArrayToString(blob, startIndex, i - startIndex);\n  try {\n    return JSON.parse(decodedString);\n  } catch (e) {\n    console.error(\"Error parsing property blob to JSON : \" + decodedString);\n    return decodedString;\n  }\n}\n\nexport function subBlobToJsonInt(blob, startIndex) {\n  var val = 0;\n  var i = startIndex;\n\n  //Check for integers that were serialized as strings.\n  //This should not happen, ever, but hey, it does.\n  if (blob[i] == 34)\n  i++;\n\n  while (i < blob.length - 1) {\n    var c = blob[i];\n    if (c == 44 && (blob[i + 1] == 10 || blob[i + 1] == 13))\n    break;\n    if (c == 10 || c == 13 || c == 34)\n    break;\n    if (c >= 48 && c <= 57)\n    val = val * 10 + (c - 48);\n\n    i++;\n  }\n\n  return val;\n}\n\n//Simple integer array parse -- expects the array in property database\n//format, where the array is packed with possibly newline separator,\n//but no other white space. Does not do extensive error checking\nexport function parseIntArray(blob, wantSentinel) {\n\n  //find out how many items we have\n  var count = 0;\n  for (var i = 0, iEnd = blob.length; i < iEnd; i++) {\n    if (blob[i] == 44) //44 = ','\n      count++;}\n\n  count++; //last item has no comma after it\n\n  var items = new Uint32Array(count + (wantSentinel ? 1 : 0));\n\n  i = 0;\n  var end = blob.length;\n\n  while (blob[i] != 91 && i < end) {//91 = '['\n    i++;}\n\n  if (i == blob.length)\n  return null;\n\n  i++;\n\n  var seenDigit = false;\n  count = 0;\n  var curInt = 0;\n  while (i < end) {\n    var c = blob[i];\n    if (c >= 48 && c <= 57) {//digit\n      curInt = 10 * curInt + (c - 48);\n      seenDigit = true;\n    } else\n    if (c == 44 || c == 93) {//',' or ']'\n      if (seenDigit) {\n        items[count++] = curInt;\n        seenDigit = false;\n        curInt = 0;\n      }\n    } else {\n      seenDigit = false; //most likely a newline (the only other thing we have in our arrays\n      curInt = 0;\n    }\n    i++;\n  }\n\n  return items;\n}\n\n//Scans an array of json values (strings, integers, doubles) and finds the\n//offset of each value in the array, so that we can later pick off that\n//specific value, without parsing the whole (potentially huge) json array up front.\n//This expects the input blob to be in the form serialized by the property database\n//C++ component -- one value per line. A more sophisticated parser would be needed\n//in case the format changes and this assumption is not true anymore.\nexport function findValueOffsets(blob) {\n\n  //first, count how many items we have\n  var count = 0;\n  var end = blob.length - 1;\n\n  for (var i = 0; i < end; i++) {\n    if (blob[i] == 44 && (blob[i + 1] == 10 || blob[i + 1] == 13)) // ',' + newline is the item delimiter\n      count++;\n  }\n\n  if (!count)\n  return null;\n\n  count++; //one for the last item\n\n  var items = new Uint32Array(count);\n\n  i = 0;\n  count = 0;\n\n  //find opening [\n  while (blob[i] != 91 && i < end) {//91 = '['\n    i++;}\n\n  i++;\n\n  items[count++] = i;\n  var seenEol = false;\n  while (i < end) {\n    if (blob[i] == 10 || blob[i] == 13)\n    seenEol = true;else\n    if (seenEol) {\n      seenEol = false;\n      items[count++] = i;\n    }\n\n    i++;\n  }\n\n  return items;\n}"],"mappings":";;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AClFA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC9FA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC3LA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;A","sourceRoot":""}