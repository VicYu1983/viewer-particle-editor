{"version":3,"file":"Edit2D/Edit2D.js","sources":["webpack://Autodesk.Extensions.[name]/webpack/bootstrap","webpack://Autodesk.Extensions.[name]/./extensions/Edit2D/Actions.js","webpack://Autodesk.Extensions.[name]/./extensions/Edit2D/AngleGizmo.js","webpack://Autodesk.Extensions.[name]/./extensions/Edit2D/AngleGizmo3d.js","webpack://Autodesk.Extensions.[name]/./extensions/Edit2D/AngleSnapper.js","webpack://Autodesk.Extensions.[name]/./extensions/Edit2D/Arrow.js","webpack://Autodesk.Extensions.[name]/./extensions/Edit2D/BooleanOps.js","webpack://Autodesk.Extensions.[name]/./extensions/Edit2D/CanvasGizmo.js","webpack://Autodesk.Extensions.[name]/./extensions/Edit2D/Clipboard.js","webpack://Autodesk.Extensions.[name]/./extensions/Edit2D/Edit2D.css?538a","webpack://Autodesk.Extensions.[name]/./extensions/Edit2D/Edit2D.js","webpack://Autodesk.Extensions.[name]/./extensions/Edit2D/Edit2DContextMenu.js","webpack://Autodesk.Extensions.[name]/./extensions/Edit2D/Edit2DSnapper.js","webpack://Autodesk.Extensions.[name]/./extensions/Edit2D/EditLayer.js","webpack://Autodesk.Extensions.[name]/./extensions/Edit2D/EditShapes.js","webpack://Autodesk.Extensions.[name]/./extensions/Edit2D/EllipseArcGizmo.js","webpack://Autodesk.Extensions.[name]/./extensions/Edit2D/LoopContainment.js","webpack://Autodesk.Extensions.[name]/./extensions/Edit2D/Math2D.js","webpack://Autodesk.Extensions.[name]/./extensions/Edit2D/MeasureTransform.js","webpack://Autodesk.Extensions.[name]/./extensions/Edit2D/ModifierMask.js","webpack://Autodesk.Extensions.[name]/./extensions/Edit2D/ScreenOverlay.js","webpack://Autodesk.Extensions.[name]/./extensions/Edit2D/SegmentTree.js","webpack://Autodesk.Extensions.[name]/./extensions/Edit2D/Selection.js","webpack://Autodesk.Extensions.[name]/./extensions/Edit2D/SolidDefConvert.js","webpack://Autodesk.Extensions.[name]/./extensions/Edit2D/Svg.js","webpack://Autodesk.Extensions.[name]/./extensions/Edit2D/TangentGizmo.js","webpack://Autodesk.Extensions.[name]/./extensions/Edit2D/Trackings.js","webpack://Autodesk.Extensions.[name]/./extensions/Edit2D/UndoStack.js","webpack://Autodesk.Extensions.[name]/./extensions/Edit2D/UnitHandler.js","webpack://Autodesk.Extensions.[name]/./extensions/Edit2D/locales.js","webpack://Autodesk.Extensions.[name]/./extensions/Edit2D/tools/CopyTool.js","webpack://Autodesk.Extensions.[name]/./extensions/Edit2D/tools/EdgeMoveTool.js","webpack://Autodesk.Extensions.[name]/./extensions/Edit2D/tools/EditToolBase.js","webpack://Autodesk.Extensions.[name]/./extensions/Edit2D/tools/InsertSymbolTool.js","webpack://Autodesk.Extensions.[name]/./extensions/Edit2D/tools/LineTool.js","webpack://Autodesk.Extensions.[name]/./extensions/Edit2D/tools/MoveTool.js","webpack://Autodesk.Extensions.[name]/./extensions/Edit2D/tools/PolygonEditTool.js","webpack://Autodesk.Extensions.[name]/./extensions/Edit2D/tools/PolygonTool.js","webpack://Autodesk.Extensions.[name]/./extensions/Edit2D/tools/RectangleTool.js","webpack://Autodesk.Extensions.[name]/./extensions/Edit2D/tools/UndoTool.js","webpack://Autodesk.Extensions.[name]/./extensions/Edit2D/tools/VertexMoveTool.js","webpack://Autodesk.Extensions.[name]/./node_modules/@adsk/solid-definition/dist/solid-definition.min.js","webpack://Autodesk.Extensions.[name]/./extensions/Edit2D/Edit2D.css","webpack://Autodesk.Extensions.[name]/./node_modules/css-loader/lib/css-base.js","webpack://Autodesk.Extensions.[name]/./node_modules/style-loader/lib/addStyles.js","webpack://Autodesk.Extensions.[name]/./node_modules/style-loader/lib/urls.js","webpack://Autodesk.Extensions.[name]/./extensions/Edit2D/SegmentTreeWorker.js","webpack://Autodesk.Extensions.[name]/./node_modules/worker-loader/dist/workers/InlineWorker.js"],"sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./extensions/Edit2D/Edit2D.js\");\n","function _typeof(obj) {\"@babel/helpers - typeof\";if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;};}return _typeof(obj);}function _inherits(subClass, superClass) {if (typeof superClass !== \"function\" && superClass !== null) {throw new TypeError(\"Super expression must either be null or a function\");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}function _createSuper(Derived) {var hasNativeReflectConstruct = _isNativeReflectConstruct();return function _createSuperInternal() {var Super = _getPrototypeOf(Derived),result;if (hasNativeReflectConstruct) {var NewTarget = _getPrototypeOf(this).constructor;result = Reflect.construct(Super, arguments, NewTarget);} else {result = Super.apply(this, arguments);}return _possibleConstructorReturn(this, result);};}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");}return self;}function _isNativeReflectConstruct() {if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;if (Reflect.construct.sham) return false;if (typeof Proxy === \"function\") return true;try {Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));return true;} catch (e) {return false;}}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError(\"Cannot call a class as a function\");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;} // Collection of basic edit actions that support undo/redo.\n//\n// Each action provides undo() and redo() functions. UndoStack takes care that actions are always called in consistent order. \n// I.e., an individual action can assume that undo/redo is only called if the state allows it. (e.g. target shape exists and has expected number of vertices etc.)\n\nimport { EdgeType, EllipseArcParams, PolyBase, PolyIndex } from './EditShapes.js';\nimport { BooleanOps } from './BooleanOps.js';var\n\nAction = /*#__PURE__*/function () {\n  function Action(layer) {_classCallCheck(this, Action);\n    this.layer = layer;\n  }_createClass(Action, [{ key: \"undo\", value: function undo()\n\n    {\n      throw new Error('Abstract method invoked');\n    } }, { key: \"redo\", value: function redo()\n\n    {\n      throw new Error('Abstract method invoked');\n    }\n\n    // Optional: Can be be implemented to guide what should be selected before/after change.\n    // @param {bool} afterUndo - If true, return recommended selection state after undo, otherwise after redo.    \n    // @returns {SelectionHint|null}     \n  }, { key: \"getSelectionHint\", value: function getSelectionHint(afterUndo) {\n      return null;\n    } }]);return Action;}();\n\n\n// Struct for possible return values of getSelectionHint\nvar SelectioHint =\nfunction SelectioHint() {_classCallCheck(this, SelectioHint);\n  // {Shape}\n  this.shape = null;\n\n  // {Shape[]} - only needed for multiselect operations\n  this.shapes = null;\n\n  // {PolyIndex} - selected vertex\n  this.vertex = null;\n\n  // {PolyIndex} - selected edge\n  this.edge = null;\n};var\n\n\nAddShape = /*#__PURE__*/function (_Action) {_inherits(AddShape, _Action);var _super = _createSuper(AddShape);\n  function AddShape(layer, shape) {var _this;_classCallCheck(this, AddShape);\n    _this = _super.call(this, layer);\n    _this.shape = shape;return _this;\n  }_createClass(AddShape, [{ key: \"undo\", value: function undo()\n\n    {\n      this.layer.removeShape(this.shape);\n    } }, { key: \"redo\", value: function redo()\n\n    {\n      this.layer.addShape(this.shape);\n    }\n\n    // After redo, new shape should be selected\n  }, { key: \"getSelectionHint\", value: function getSelectionHint(afterUndo) {\n      return afterUndo ? null : { shape: this.shape };\n    } }]);return AddShape;}(Action);var\n\n\nAddShapes = /*#__PURE__*/function (_Action2) {_inherits(AddShapes, _Action2);var _super2 = _createSuper(AddShapes);\n\n  // @param {Shape[]} shapes\n  function AddShapes(layer, shapes) {var _this2;_classCallCheck(this, AddShapes);\n    _this2 = _super2.call(this, layer);\n    _this2.shapes = shapes;return _this2;\n  }_createClass(AddShapes, [{ key: \"undo\", value: function undo()\n\n    {var _this3 = this;\n      this.shapes.forEach(function (s) {return _this3.layer.removeShape(s);});\n    } }, { key: \"redo\", value: function redo()\n\n    {var _this4 = this;\n      this.shapes.forEach(function (s) {return _this4.layer.addShape(s);});\n    }\n\n    // After redo, new shape should be selected\n  }, { key: \"getSelectionHint\", value: function getSelectionHint(afterUndo) {\n      return afterUndo ? null : { shapes: this.shapes };\n    } }]);return AddShapes;}(Action);var\n\n\nMoveShapes = /*#__PURE__*/function (_Action3) {_inherits(MoveShapes, _Action3);var _super3 = _createSuper(MoveShapes);\n  function MoveShapes(layer, shapes, dx, dy) {var _this5;_classCallCheck(this, MoveShapes);\n    _this5 = _super3.call(this, layer);\n    _this5.shapes = shapes;\n    _this5.delta = { x: dx, y: dy };\n\n    // Note that transforming back and forth is not always exactly 1:1. \n    _this5.beforeState = _this5.shapes.map(function (s) {return s.clone();});\n    _this5.afterState = _this5.shapes.map(function (s) {return s.clone();});\n\n    _this5.afterState.forEach(function (s) {return s.move(dx, dy);});return _this5;\n  }_createClass(MoveShapes, [{ key: \"undo\", value: function undo()\n\n    {var _this6 = this;\n      this.shapes.forEach(function (s, i) {return s.copy(_this6.beforeState[i]);});\n    } }, { key: \"redo\", value: function redo()\n\n    {var _this7 = this;\n      this.shapes.forEach(function (s, i) {return s.copy(_this7.afterState[i]);});\n    }\n\n    // After undo/redo, moved shapes should be selected\n  }, { key: \"getSelectionHint\", value: function getSelectionHint(afterUndo) {\n      return { shapes: this.shapes };\n    } }]);return MoveShapes;}(Action);var\n\n\nRemoveShape = /*#__PURE__*/function (_Action4) {_inherits(RemoveShape, _Action4);var _super4 = _createSuper(RemoveShape);\n  function RemoveShape(layer, shape) {var _this8;_classCallCheck(this, RemoveShape);\n    _this8 = _super4.call(this, layer);\n    _this8.shape = shape;return _this8;\n  }_createClass(RemoveShape, [{ key: \"undo\", value: function undo()\n\n    {\n      this.layer.addShape(this.shape);\n    } }, { key: \"redo\", value: function redo()\n\n    {\n      this.layer.removeShape(this.shape);\n    }\n\n    // After undo, recovered shape should be selected\n  }, { key: \"getSelectionHint\", value: function getSelectionHint(afterUndo) {\n      return afterUndo ? { shape: this.shape } : null;\n    } }]);return RemoveShape;}(Action);var\n\n\nRemoveShapes = /*#__PURE__*/function (_Action5) {_inherits(RemoveShapes, _Action5);var _super5 = _createSuper(RemoveShapes);\n  function RemoveShapes(layer, shapes) {var _this9;_classCallCheck(this, RemoveShapes);\n    _this9 = _super5.call(this, layer);\n    _this9.shapes = shapes.slice();return _this9;\n  }_createClass(RemoveShapes, [{ key: \"undo\", value: function undo()\n\n    {var _this10 = this;\n      this.shapes.forEach(function (s) {return _this10.layer.addShape(s);});\n    } }, { key: \"redo\", value: function redo()\n\n    {var _this11 = this;\n      this.shapes.forEach(function (s) {return _this11.layer.removeShape(s);});\n    }\n\n    // After undo, recovered shapes should be selected\n  }, { key: \"getSelectionHint\", value: function getSelectionHint(afterUndo) {\n      return afterUndo ? { shapes: this.shapes } : null;\n    } }]);return RemoveShapes;}(Action);var\n\n\nAddVertex = /*#__PURE__*/function (_Action6) {_inherits(AddVertex, _Action6);var _super6 = _createSuper(AddVertex);\n  function AddVertex(layer, poly, polyIndex, p) {var _this12;_classCallCheck(this, AddVertex);\n    _this12 = _super6.call(this, layer);\n    _this12.poly = poly;\n    _this12.polyIndex = polyIndex;\n    _this12.point = p.clone();return _this12;\n  }_createClass(AddVertex, [{ key: \"undo\", value: function undo()\n\n    {\n      this.poly.removePoint(this.polyIndex.vertex, this.polyIndex.loop);\n    } }, { key: \"redo\", value: function redo()\n\n    {\n      this.poly.insertPoint(this.polyIndex.vertex, this.point, this.polyIndex.loop);\n    }\n\n    // After redo, select the new vertex\n  }, { key: \"getSelectionHint\", value: function getSelectionHint(afterUndo) {\n      return {\n        shape: this.poly,\n        vertex: afterUndo ? null : this.polyIndex };\n\n    } }]);return AddVertex;}(Action);\n\n\n// Only for polygons and polylines\nvar MoveVertex = /*#__PURE__*/function (_Action7) {_inherits(MoveVertex, _Action7);var _super7 = _createSuper(MoveVertex);\n  function MoveVertex(layer, poly, polyIndex, newPos) {var _this13;_classCallCheck(this, MoveVertex);\n    _this13 = _super7.call(this, layer);\n    _this13.poly = poly;\n    _this13.polyIndex = polyIndex;\n    _this13.posBefore = poly.getPoint(polyIndex.vertex, polyIndex.loop);\n    _this13.posAfter = newPos.clone();return _this13;\n  }_createClass(MoveVertex, [{ key: \"undo\", value: function undo()\n\n    {\n      this.poly.updatePoint(this.polyIndex.vertex, this.posBefore.x, this.posBefore.y, this.polyIndex.loop);\n    } }, { key: \"redo\", value: function redo()\n    {\n      this.poly.updatePoint(this.polyIndex.vertex, this.posAfter.x, this.posAfter.y, this.polyIndex.loop);\n    }\n\n    // After undo/redo, select moved vertex\n  }, { key: \"getSelectionHint\", value: function getSelectionHint(afterUndo) {\n      return {\n        shape: this.poly,\n        vertex: this.polyIndex };\n\n    } }]);return MoveVertex;}(Action);\n\n\n// Returns an object that allows for recovering all arc params assoicated with a vertex\nvar copyArcParams = function copyArcParams(poly, index, loop) {\n  if (!poly.isPath() || !poly.edgeIndexValid(index, loop)) {\n    return null;\n  }\n\n  var type = poly.getEdgeType(index, loop);\n  switch (type) {\n    // Note that the getter already returns a copy\n    case EdgeType.Ellipse:return poly.getEllipseArcParams(index, loop);\n    case EdgeType.Bezier:return {\n        cp1: poly.getControlPoint(index, 1, loop),\n        cp2: poly.getControlPoint(index, 2, loop) };\n\n    case EdgeType.Line:return null;\n    default:console.warn('unexpected edge type');}\n\n};\n\n// Recover an arc based on the result returned by copyArcParam\nvar restoreArc = function restoreArc(poly, index, loop, arcParams) {\n  if (!arcParams) {\n    // nothing to restore\n    return;\n  }\n\n  if (arcParams instanceof EllipseArcParams) {\n    // recover ellipse arc\n    poly.setEllipseArc(index, arcParams);\n  } else if (arcParams.cp1) {\n    // recover bezier arc\n    var cp1 = arcParams.cp1;\n    var cp2 = arcParams.cp2;\n    poly.setBezierArc(index, cp1.x, cp1.y, cp2.x, cp2.y);\n  }\n};var\n\nRemoveVertex = /*#__PURE__*/function (_Action8) {_inherits(RemoveVertex, _Action8);var _super8 = _createSuper(RemoveVertex);\n  function RemoveVertex(layer, poly, polyIndex) {var _this14;_classCallCheck(this, RemoveVertex);\n    _this14 = _super8.call(this, layer);\n    _this14.poly = poly;\n    _this14.vertex = polyIndex.vertex;\n    _this14.loop = polyIndex.loop;\n    _this14.point = poly.getPoint(_this14.vertex, _this14.loop);\n\n    // For consistency and simplicity, we remove arcs if start or end vertex is removed.\n    _this14.arcBefore = copyArcParams(poly, poly.edgeBeforeVertex(_this14.vertex, _this14.loop), _this14.loop);\n    _this14.arcAfter = copyArcParams(poly, poly.edgeAfterVertex(_this14.vertex, _this14.loop), _this14.loop);return _this14;\n  }_createClass(RemoveVertex, [{ key: \"undo\", value: function undo()\n\n    {\n      this.poly.insertPoint(this.vertex, this.point, this.loop);\n\n      // recover arc params\n      if (this.poly.prevEdgeExists(this.vertex, this.loop)) {\n        restoreArc(this.poly, this.poly.edgeBeforeVertex(this.vertex, this.loop), this.loop, this.arcBefore);\n      }\n      if (this.poly.nextEdgeExists(this.vertex, this.loop)) {\n        restoreArc(this.poly, this.poly.edgeAfterVertex(this.vertex, this.loop), this.loop, this.arcAfter);\n      }\n    } }, { key: \"redo\", value: function redo()\n\n    {\n      // remove arcs at edges starting/ending at the vertex\n      if (this.poly.isPath()) {\n        if (this.poly.prevEdgeExists(this.vertex, this.loop)) {\n          this.poly.removeArc(this.poly.edgeBeforeVertex(this.vertex, this.loop), this.loop);\n        }\n        if (this.poly.nextEdgeExists(this.vertex, this.loop)) {\n          this.poly.removeArc(this.poly.edgeAfterVertex(this.vertex, this.loop), this.loop);\n        }\n      }\n\n      this.poly.removePoint(this.vertex, this.loop);\n    }\n\n    // After undo, select recovered vertex\n  }, { key: \"getSelectionHint\", value: function getSelectionHint(afterUndo) {\n      return {\n        shape: this.poly,\n        vertex: afterUndo ? this.polyIndex : null };\n\n    } }]);return RemoveVertex;}(Action);\n\n\n\n// Moves an edge to a new position specified by new positions for start and end vertex.\n// Optionally, start and end vertex may be duplicated before moving the edge. In this case, the neighbar edges keep unchanged and\n// we introduce new intermediate edges to connect the old start/end position with the new one.\nvar MoveEdge = /*#__PURE__*/function (_Action9) {_inherits(MoveEdge, _Action9);var _super9 = _createSuper(MoveEdge);\n\n  // @param {EditLayer} layer\n  // @param {Polybase}  poly      - must be at start before the change\n  // @param {PolyIndex} polyIndex - edge to be modified    \n  // @param {Vector3}   newPosA, newPosB\n  // @param {bool}      duplicateStartVertex, duplicateEndVertex - Optional, start and end vertex of the edge may be duplicated.\n  function MoveEdge(layer, poly, polyIndex, newPosA, newPosB, duplicateStartVertex, duplicateEndVertex) {var _this15;_classCallCheck(this, MoveEdge);\n    _this15 = _super9.call(this, layer);\n    _this15.poly = poly;\n\n    // store edge index\n    _this15.edgeIndex = polyIndex.vertex;\n    _this15.loopIndex = polyIndex.loop;\n\n    // store duplicate flags\n    _this15.duplicateStartVertex = duplicateStartVertex;\n    _this15.duplicateEndVertex = duplicateEndVertex;\n\n    var ia = _this15.edgeIndex;\n    var ib = poly.nextIndex(ia, _this15.loopIndex);\n\n    // get edge \n    var a = poly.getPoint(ia, _this15.loopIndex);\n    var b = poly.getPoint(ib, _this15.loopIndex);\n\n    _this15.edgeBefore = {\n      a: a,\n      b: b };\n\n    _this15.edgeAfter = {\n      a: newPosA.clone(),\n      b: newPosB.clone() };return _this15;\n\n  }_createClass(MoveEdge, [{ key: \"undo\", value: function undo()\n\n    {\n      // get current edgeIndex (after duplicating vertices)\n      var newEdgeIndex = MoveEdge.getNewEdgeIndex(this.poly, this.edgeIndex, this.loopIndex, this.duplicateStartVertex, this.duplicateEndVertex);\n\n      // get indices of the two edge vertices\n      var ia = newEdgeIndex;\n      var ib = this.poly.nextIndex(ia, this.loopIndex);\n\n      // Restore original edge positions\n      this.poly.updatePoint(ia, this.edgeBefore.a.x, this.edgeBefore.a.y, this.loopIndex);\n      this.poly.updatePoint(ib, this.edgeBefore.b.x, this.edgeBefore.b.y, this.loopIndex);\n\n      // Remove extra vertices\n      MoveEdge.revertDuplicateVertices(this.poly, this.edgeIndex, this.loopIndex, this.duplicateStartVertex, this.duplicateEndVertex);\n    } }, { key: \"redo\", value: function redo()\n\n    {\n      // Duplicate start/end vertex if wanted\n      MoveEdge.duplicateVertices(this.poly, this.edgeIndex, this.loopIndex, this.duplicateStartVertex, this.duplicateEndVertex);\n\n      // get edgeIndex after duplicating vertices\n      var newEdgeIndex = MoveEdge.getNewEdgeIndex(this.poly, this.edgeIndex, this.loopIndex, this.duplicateStartVertex, this.duplicateEndVertex);\n\n      // get indices of the two edge vertices\n      var ia = newEdgeIndex;\n      var ib = this.poly.nextIndex(ia, this.loopIndex);\n\n      // apply new positions\n      this.poly.updatePoint(ia, this.edgeAfter.a.x, this.edgeAfter.a.y, this.loopIndex);\n      this.poly.updatePoint(ib, this.edgeAfter.b.x, this.edgeAfter.b.y, this.loopIndex);\n    }\n\n    // Insert a duplicate of vertex i to position i+1. Note that vertex i only copies\n    // the position. If vertex i contained arc params, these will be at vertex i+1.\n  }, { key: \"getSelectionHint\",\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    // After undo/redo, select the moved edge. Note that its index may change due to vertex duplication.\n    value: function getSelectionHint(afterUndo) {\n      var edgeIndex = afterUndo ? this.edgeIndex : MoveEdge.getNewEdgeIndex(this.poly, this.edgeIndex, this.loopIndex, this.duplicateStartVertex, this.duplicateEndVertex);\n      return {\n        shape: this.poly,\n        edge: new PolyIndex({ vertex: edgeIndex, loop: this.loopIndex }) };\n\n    } }], [{ key: \"duplicateVertex\", value: function duplicateVertex(poly, index) {var loopIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;var p = poly.getPoint(index, loopIndex);poly.insertPoint(index, { x: p.x, y: p.y }, loopIndex);} // Duplicates start and/or end vertex of a given edge in a polyline/polygon.\n  }, { key: \"duplicateVertices\", value: function duplicateVertices(poly, edgeIndex, loopIndex, duplicateStartVertex, duplicateEndVertex) {var startVertex = edgeIndex;if (duplicateStartVertex) {MoveEdge.duplicateVertex(poly, startVertex, loopIndex); // After duplicating, the actual edge start vertex has shifted by 1.\n        startVertex++;}if (duplicateEndVertex) {var vNext = poly.nextIndex(startVertex, loopIndex);MoveEdge.duplicateVertex(poly, vNext, loopIndex);}} }, { key: \"revertDuplicateVertices\", // Reverts the extra vertices inserted by duplicateVertices. Note that edgeIndex refers\n    // to the polygon before duplicating the vertices, i.e., should be identical with \n    // the one used in the duplicateVertices(..) to be reverted.\n    value: function revertDuplicateVertices(poly, edgeIndex, loopIndex, duplicateStartVertex, duplicateEndVertex) {// get edge index after considering vertex duplication\n      var curEdgeIndex = MoveEdge.getNewEdgeIndex(poly, edgeIndex, loopIndex, duplicateStartVertex, duplicateEndVertex); // If the end vertex was duplicated, revert that now\n      if (duplicateStartVertex) {// Note that it is important to remove the vertex BEFORE edge start instead of the edge start itself.\n        // Although both have identical positions, the edge start vertex may contain additional arc params.\n        var iPrev = curEdgeIndex - 1;poly.removePoint(iPrev, loopIndex); // This shifts the edgeIndex back by 1\n        curEdgeIndex--;}if (duplicateEndVertex) {// Always remove the first of the two duplicate vertices. The first one is the copy that just contains\n        // the position, while the second (=original) one may contain additional arc params.\n        var iNext = poly.nextIndex(curEdgeIndex, loopIndex);poly.removePoint(iNext, loopIndex);}} }, { key: \"getNewEdgeIndex\", // If we duplicate start/end vertex of an edge, the index of that edge may change.\n    // This function returns the new index of the edge after duplicating start/end vertex.\n    //\n    // Note: poly is assumed to contain the duplicated vertices.\n    value: function getNewEdgeIndex(poly, edgeIndex, loopIndex, duplicateStartVertex, duplicateEndVertex) {var newIndex = edgeIndex; // Duplicating the start vertex always shift the edgeIndex by 1\n      if (duplicateStartVertex) {newIndex++;} // get vertexCount of the polygon before insertion of duplicated vertices.\n      var vertexCountBefore = poly.getVertexCount(loopIndex) - (duplicateStartVertex ? 1 : 0) - (duplicateEndVertex ? 1 : 0); // Check if edge was the 'closing edge' of the original polygon, i.e., the edge that \n      // connects the last vertex with vertex 0\n      var isClosingEdge = edgeIndex === vertexCountBefore - 1; // Duplicating the end vertex may also shift the edgeIndex. This happens if the edge start\n      // vertex is the last one in a polygon.\n      if (duplicateEndVertex && isClosingEdge) {newIndex++;}return newIndex;} }]);return MoveEdge;}(Action); // Change arc type of a Path edge. It can also be used to change arc params without changing the actual type.\nvar ChangeEdgeType = /*#__PURE__*/function (_Action10) {_inherits(ChangeEdgeType, _Action10);var _super10 = _createSuper(ChangeEdgeType); // @param {EditLayer} layer\n  // @param {Path}      path  - must be in \"before\" state of the action\n  // @param {PolyIndex} polyIndex\n  // @param {EdgeType}  edgeType\n  // @param {Vector2}   [cp1] - Control points. Only needed when changing to Bezier\n  // @param {Vector2}   [cp2]\n  // @param {EllipseArcParams} [arcParams] - only needed when changing to EllipseArc\n  function ChangeEdgeType(layer, path, polyIndex, edgeType, cp1, cp2, arcParams) {var _this16;_classCallCheck(this, ChangeEdgeType);_this16 = _super10.call(this, layer);_this16.path = path;_this16.edgeIndex = polyIndex.vertex;_this16.loopIndex = polyIndex.loop; // Store previous edge props\n    var isBezier = path.isBezierArc(_this16.edgeIndex, _this16.loopIndex);_this16.oldEdgeType = path.getEdgeType(_this16.edgeIndex, _this16.loopIndex);_this16.oldCp1 = isBezier && path.getControlPoint(_this16.edgeIndex, 1, _this16.loopIndex);_this16.oldCp2 = isBezier && path.getControlPoint(_this16.edgeIndex, 2, _this16.loopIndex);_this16.oldEllipseArcParams = path.getEllipseArcParams(_this16.edgeIndex, _this16.loopIndex); // Store new control points (if any)\n    _this16.newEdgeType = edgeType;_this16.newCp1 = cp1;_this16.newCp2 = cp2;_this16.newEllipseArcParams = arcParams;return _this16;}_createClass(ChangeEdgeType, [{ key: \"redo\", value: function redo()\n\n    {\n      switch (this.newEdgeType) {\n        case EdgeType.Line:this.path.removeArc(this.edgeIndex, this.loopIndex);break;\n        case EdgeType.Ellipse:this.path.setEllipseArc(this.edgeIndex, this.newEllipseArcParams, this.loopIndex);break;\n        case EdgeType.Bezier:this.path.setBezierArc(this.edgeIndex, this.newCp1.x, this.newCp1.y, this.newCp2.x, this.newCp2.y, this.loopIndex);break;}\n\n    } }, { key: \"undo\", value: function undo()\n\n    {\n      switch (this.oldEdgeType) {\n        case EdgeType.Line:this.path.removeArc(this.edgeIndex, this.loopIndex);break;\n        case EdgeType.Bezier:this.path.setBezierArc(this.edgeIndex, this.oldCp1.x, this.oldCp1.y, this.oldCp2.x, this.oldCp2.y, this.loopIndex);break;\n        case EdgeType.Ellipse:this.path.setEllipseArc(this.edgeIndex, this.oldEllipseArcParams, this.loopIndex);break;}\n\n    }\n\n    // After undo/redo, select changed edge\n  }, { key: \"getSelectionHint\", value: function getSelectionHint(afterUndo) {\n      return {\n        shape: this.path,\n        edge: new PolyIndex({ vertex: this.edgeIndex, loop: this.loopIndex }) };\n\n    } }]);return ChangeEdgeType;}(Action);var\n\n\nApplyCutOut = /*#__PURE__*/function (_Action11) {_inherits(ApplyCutOut, _Action11);var _super11 = _createSuper(ApplyCutOut);\n\n  function ApplyCutOut(layer, cutPath) {var _this17;_classCallCheck(this, ApplyCutOut);\n    _this17 = _super11.call(this, layer);\n\n    // collect all other polygons and closed paths in the layer that overlap the cutPath bbox\n    var cutBox = cutPath.getBBox();\n    _this17.paths = layer.shapes.filter(function (s) {\n\n      if (s === cutPath) {\n        return false;\n      }\n\n      // cutout is only be applied on Polygons and closed Paths\n      var isClosed = s instanceof PolyBase && s.isClosed;\n      if (!isClosed) {\n        return false;\n      }\n\n      var box = s.getBBox();\n      return cutBox.isIntersectionBox(box);\n    });\n\n    // subtract cutPath from all overlapping shapes\n    _this17.clippedPaths = _this17.paths.map(function (p) {\n      return BooleanOps.apply(p, cutPath, BooleanOps.Operator.Difference);\n    });\n\n    // create backups of original paths before cutout\n    _this17.originalShapes = _this17.paths.map(function (p) {return p.clone();});\n\n    _this17.cutPath = cutPath;return _this17;\n  }_createClass(ApplyCutOut, [{ key: \"redo\", value: function redo()\n\n    {var _this18 = this;\n      // replace geometry of all shapes by clipped versions\n      this.paths.forEach(function (p, i) {return p.copyGeometry(_this18.clippedPaths[i]);});\n      this.layer.update();\n    } }, { key: \"undo\", value: function undo()\n\n    {var _this19 = this;\n      // replace all shapes by original versions\n      this.paths.forEach(function (p, i) {return p.copyGeometry(_this19.originalShapes[i]);});\n    }\n\n    // After undo/redo, select shape that was used for cutout\n  }, { key: \"getSelectionHint\", value: function getSelectionHint(afterUndo) {\n      return {\n        shape: this.cutPath };\n\n    } }]);return ApplyCutOut;}(Action);var\n\n\nRemoveLoops = /*#__PURE__*/function (_Action12) {_inherits(RemoveLoops, _Action12);var _super12 = _createSuper(RemoveLoops);\n\n  function RemoveLoops(layer, poly, loops) {var _this20;_classCallCheck(this, RemoveLoops);\n    _this20 = _super12.call(this, layer);\n\n    _this20.poly = poly;\n    _this20.loops = loops;\n\n    // create a backup of the shape before change\n    _this20.before = _this20.poly.clone();return _this20;\n  }_createClass(RemoveLoops, [{ key: \"redo\", value: function redo()\n\n    {\n      this.poly.removeLoops(this.loops);\n    } }, { key: \"undo\", value: function undo()\n\n    {\n      this.poly.copy(this.before);\n    }\n\n    // After undo/redo, select modified shape\n  }, { key: \"getSelectionHint\", value: function getSelectionHint(afterUndo) {\n      return {\n        shape: this.poly };\n\n    } }]);return RemoveLoops;}(Action);var\n\n\nMoveLoop = /*#__PURE__*/function (_Action13) {_inherits(MoveLoop, _Action13);var _super13 = _createSuper(MoveLoop);\n\n  function MoveLoop(layer, poly, loopIndex, dx, dy) {var _this21;_classCallCheck(this, MoveLoop);\n    _this21 = _super13.call(this, layer);\n\n    _this21.poly = poly;\n    _this21.loopIndex = loopIndex;\n    _this21.before = _this21.poly.clone();\n\n    _this21.dx = dx;\n    _this21.dy = dy;return _this21;\n  }_createClass(MoveLoop, [{ key: \"redo\", value: function redo()\n\n    {\n      this.poly.moveLoop(this.dx, this.dy, this.loopIndex);\n    } }, { key: \"undo\", value: function undo()\n\n    {\n      this.poly.copy(this.before);\n    }\n\n    // After undo/redo, select modified shape\n  }, { key: \"getSelectionHint\", value: function getSelectionHint(afterUndo) {\n      return {\n        shape: this.poly };\n\n    } }]);return MoveLoop;}(Action);\n\n\n// Merges all shapes into the first one\nvar UnifyShapes = /*#__PURE__*/function (_Action14) {_inherits(UnifyShapes, _Action14);var _super14 = _createSuper(UnifyShapes);\n\n  // @param {EditLayer}  layer \n  // @param {PolyBase[]} shapes     - shapes to merge\n  // @param {number}     shapeIndex - index within shapes array. All other shapes will be merged into this one.\n  function UnifyShapes(layer, shapes, shapeIndex) {var _this22;_classCallCheck(this, UnifyShapes);\n    _this22 = _super14.call(this, layer);\n\n    _this22.merged = BooleanOps.apply(shapes[0], shapes[1], BooleanOps.Operator.Union, shapes.slice(2));\n    _this22.before = shapes[shapeIndex].clone();\n\n    _this22.mainShape = shapes[shapeIndex];\n    _this22.otherShapes = shapes.filter(function (s) {return s !== _this22.mainShape;});return _this22;\n  }_createClass(UnifyShapes, [{ key: \"redo\", value: function redo()\n\n    {\n\n      // Merge other shapes into main shape\n      this.mainShape.copyGeometry(this.merged);\n\n      // Remove all other shapes\n      this.layer.removeShapes(this.otherShapes);\n    } }, { key: \"undo\", value: function undo()\n\n    {\n      // Recover original main shape\n      this.mainShape.copyGeometry(this.before);\n\n      // Add other shapes back to layer\n      this.layer.addShapes(this.otherShapes);\n    }\n\n    // After undo/redo, select mainShape\n  }, { key: \"getSelectionHint\", value: function getSelectionHint(afterUndo) {\n      return {\n        shape: this.mainShape };\n\n    } }]);return UnifyShapes;}(Action);\n\n\n// Changes Bezier arc tangent at a vertex v. This may affect up to two edge adjacent to v.\nvar ChangeBezierTangent = /*#__PURE__*/function () {\n\n  // @param {EditLayer} layer\n  // @param {Path}      path\n  // @param {number}    vertex     - index of the vertex to be changed\n  // @param {number}    loopIndex\n  // @param {Vector2}   pStart     - tangent start. This is cp2 of the previous bezier segment (if any)\n  // @param {Vector2}   pEnd       - tangent end    \n  function ChangeBezierTangent(layer, path, index, loopIndex, pStart, pEnd) {_classCallCheck(this, ChangeBezierTangent);\n    this.layer = layer;\n    this.path = path;\n    this.index = index;\n    this.loopIndex = loopIndex;\n    this.pStart = pStart;\n    this.pEnd = pEnd;\n\n    // Backup of original shape\n    this.before = path.clone();\n  }\n\n  // Set the two control points that define the bezier tangent. Usually, pEnd is just pStart mirrored at the vertex\n  _createClass(ChangeBezierTangent, [{ key: \"setTangent\", value: function setTangent(pStart, pEnd) {\n      this.pStart = pStart;\n      this.pEnd = pEnd;\n    }\n\n    // Apply modified tangent endpoints after dragging on of the tangent vertices.\n    //\n    // @param {Vector2} pStart, pEnd - Tangent start/end point in layer coords.\n  }, { key: \"redo\", value: function redo() {\n\n      // Set start point: This is cp2 of previous arc segment (if any)\n      var prevEdgeIndex = this.path.edgeBeforeVertex(this.index, this.loopIndex);\n      var prevExists = prevEdgeIndex !== -1;\n      if (prevExists && this.path.isBezierArc(prevEdgeIndex, this.loopIndex)) {\n        this.path.updateControlPoint(prevEdgeIndex, 2, this.pStart.x, this.pStart.y, this.loopIndex);\n      }\n\n      // Set end point: This is cp1 of current segment\n      var nextEdgeIndex = this.path.edgeAfterVertex(this.index, this.loopIndex);\n      var nextExists = nextEdgeIndex !== -1;\n      if (nextExists && this.path.isBezierArc(nextEdgeIndex, this.loopIndex)) {\n        this.path.updateControlPoint(this.index, 1, this.pEnd.x, this.pEnd.y, this.loopIndex);\n      }\n    } }, { key: \"undo\", value: function undo()\n\n    {\n      this.path.copyGeometry(this.before);\n    }\n\n    // ChangeBezierTangent may happen if a vertex or an edge is selected. So, the hint must be set from\n    // outside when the information is available.\n    //   @param {PolyIndex} vertex\n    //   @param {PolyIndex} edge\n  }, { key: \"setSelectionItem\", value: function setSelectionItem(vertex, edge) {\n      this.selectionHint = {\n        shape: this.path,\n        vertex: vertex,\n        edge: edge };\n\n    }\n\n    // After undo/redo, select the edge that was modified\n  }, { key: \"getSelectionHint\", value: function getSelectionHint(afterUndo) {\n      return this.selectionHint;\n    } }]);return ChangeBezierTangent;}();\n\n\nexport var Actions = {\n  Action: Action,\n  AddShape: AddShape,\n  AddShapes: AddShapes,\n  MoveShapes: MoveShapes,\n  RemoveShape: RemoveShape,\n  RemoveShapes: RemoveShapes,\n  AddVertex: AddVertex,\n  MoveVertex: MoveVertex,\n  RemoveVertex: RemoveVertex,\n  MoveEdge: MoveEdge,\n  ChangeEdgeType: ChangeEdgeType,\n  ApplyCutOut: ApplyCutOut,\n  RemoveLoops: RemoveLoops,\n  UnifyShapes: UnifyShapes,\n  MoveLoop: MoveLoop,\n  ChangeBezierTangent: ChangeBezierTangent };","function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError(\"Cannot call a class as a function\");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}\nimport Arrow from './Arrow.js';\nimport { Math2D } from './Math2D.js';\nimport { Polyline, Path, EllipseArcParams } from './EditShapes.js';\nimport { TextLabel } from './CanvasGizmo.js';\n\nvar Colors = {\n  Black: 'rgb(0,0,0)' };\n\n\n// An angle gizmo indicates a rotation angle using two arrows (start/end direction) and a connecting arc.\n// The arc is drawn along the shortest connection, either cw or ccw.\nvar AngleGizmo = /*#__PURE__*/function () {\n\n  function AngleGizmo(layer) {var _this = this;var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};_classCallCheck(this, AngleGizmo);\n    this.layer = layer;\n    this.options = options;\n\n    // --- Configuration params ---\n\n    // Corner points encloding the angle\n    this.center = new THREE.Vector2(); // center of the arc\n    this.pStart = new THREE.Vector2(); // center->pStart indicates direction before rotation\n    this.pEnd = new THREE.Vector2(); // center->pEnd indicates direction after rotation\n\n    // sizes in pixels\n    this.arrowLength = 150;\n    this.arrowHeadLength = 18;\n    this.arcRadius = 100;\n\n    // Indicate which points are properly set. If only center and one point are valid, we show just an arrow.\n    this.centerValid = false;\n    this.pStartValid = false;\n    this.pEndValid = false;\n\n    // Optional: Show dotted line that connects the arrow with the points that define the direction.\n    this.showExtendLines = true;\n\n    // Specifies how far we shift the labelPosition away from the center. An offset of 0 would mean to center the label\n    // on the center point of the angle arc line. \n    this.labelPosOffset = 30;\n\n    // Angle text label\n    this.enableLabel = true;\n\n    // --- Maintained by the gizmo ---\n\n    // Arrow shapes. Auto-updated based on settings\n    this.arrowStart = new Arrow();\n    this.arrowEnd = new Arrow();\n\n    // Sharpness of arrow peaks\n    this.arrowStart.headAngle = 45;\n    this.arrowEnd.headAngle = 45;\n\n\n    // Arc line connecting the two arrows\n    this.arcLine = new Path().allocPoints(2);\n    this.arcArrow = new Arrow();\n    this.arcFill = new Path().allocPoints(3);\n    this.arcFill.isClosed = true;\n\n    // Used and auto-updated in upadte() \n    this.arcParams = new EllipseArcParams();\n\n    // Update shapes on camera updates\n    this.onCameraChange = this.onCameraChange.bind(this);\n    this.layer.viewer.addEventListener(Autodesk.Viewing.CAMERA_CHANGE_EVENT, this.onCameraChange);\n\n    // arc style\n    this.arcFillOpacity = 0.2;\n    this.arcFill.style.lineAlpha = 0;\n    this.arcFill.style.fillAlpha = this.arcFillOpacity;\n    this.arcLine.style.lineWidth = 2.0;\n    this.arcLine.style.lineColor = this.options.arcColor || Colors.Black;\n\n    this.arcArrow.line.style.lineColor = this.options.arcColor || Colors.Black;\n    this.arcArrow.line.style.lineWidth = 2.0;\n    this.arcArrow.head.style.lineAlpha = 0;\n    this.arcArrow.head.style.fillColor = this.options.arcColor || Colors.Black;\n    this.arcArrow.head.style.fillAlpha = 1;\n    this.arcArrowMaxHeadLength = 0.3; // If the arc arrow is very short (small angles), we restrict the headSize to a percentage of the arrow length\n\n    // start arrow line style\n    this.arrowStart.line.style.lineColor = this.options.startColor || Colors.Black;\n    this.arrowStart.line.style.lineWidth = 1.5;\n\n    // end arrow line style \n    this.arrowEnd.line.style.lineColor = this.options.endColor || Colors.Black;\n    this.arrowEnd.line.style.lineWidth = 1.5;\n\n    // start arrow head style\n    this.arrowStart.head.style.lineAlpha = 0;\n    this.arrowStart.head.style.fillColor = this.options.startColor || Colors.Black;\n    this.arrowStart.head.style.fillAlpha = 1;\n\n    // end arrow head style\n    this.arrowEnd.head.style.lineAlpha = 0;\n    this.arrowEnd.head.style.fillColor = this.options.endColor || Colors.Black;\n    this.arrowEnd.head.style.fillAlpha = 1;\n\n    this.label = new TextLabel(this.layer, '', this.options.labelClassName);\n\n    // reused values for label position computation \n    this.labelPos = new THREE.Vector2(); // in layer-coords\n    this.arcCurve = new Autodesk.Extensions.CompGeom.EllipseArc();\n    this.visible = false;\n\n    // For fadeIn/Out effects\n    var setOpacity = function setOpacity(opacity) {\n      _this.arrowStart.line.style.lineAlpha = opacity;\n      _this.arrowStart.head.style.fillAlpha = _this.options.hideArrowHead ? 0 : opacity;\n      _this.arrowEnd.line.style.lineAlpha = opacity;\n      _this.arrowEnd.head.style.fillAlpha = _this.options.hideArrowHead ? 0 : opacity;\n      _this.arcLine.style.lineAlpha = opacity;\n      _this.arcArrow.line.style.lineAlpha = opacity;\n      _this.arcArrow.head.style.fillAlpha = opacity;\n      _this.arcFill.style.fillAlpha = opacity * _this.arcFillOpacity;\n      _this.opacity = opacity;\n      _this.layer.update();\n    };\n\n    this.opacityParam = new Autodesk.Viewing.Private.AnimatedParam(1.0, setOpacity, 0.5);\n\n    // reflects current fadeIn/fadeOut state\n    this.opacity = 1.0;\n  }_createClass(AngleGizmo, [{ key: \"setCenter\", value: function setCenter(\n\n    center) {\n      if (center) {\n        this.center.copy(center);\n        this.centerValid = true;\n      } else {\n        this.centerValid = false;\n      }\n    } }, { key: \"setStart\", value: function setStart(\n\n    pStart) {\n      if (pStart) {\n        this.pStart.copy(pStart);\n        this.pStartValid = isFinite(pStart.x) && isFinite(pStart.y);\n\n        // Warn on NaN/Inf values\n        if (!this.pStartValid) {\n          console.warn(\"AngleGizmo: Invalid start point\");\n        }\n\n      } else {\n        this.pStartValid = false;\n      }\n    } }, { key: \"setEnd\", value: function setEnd(\n\n    pEnd) {\n      if (pEnd) {\n        this.pEnd.copy(pEnd);\n        this.pEndValid = isFinite(pEnd.x) && isFinite(pEnd.y);\n\n        // Warn on NaN/Inf values\n        if (!this.pEndValid) {\n          console.warn(\"AngleGizmo: Invalid end point\");\n        }\n      } else {\n        this.pEndValid = false;\n      }\n    } }, { key: \"dtor\", value: function dtor()\n\n    {\n      this.layer.viewer.removeEventListener(Autodesk.Viewing.CAMERA_CHANGE_EVENT, this.onCameraChange);\n    } }, { key: \"setVisible\", value: function setVisible(\n\n    visible) {\n      if (this.visible == visible) {\n        return;\n      }\n\n      this.visible = visible;\n      if (visible) {\n        this.layer.addShape(this.arrowStart);\n        this.layer.addShape(this.arrowEnd);\n        this.layer.addShape(this.arcLine);\n        this.layer.addShape(this.arcArrow);\n        this.layer.addShape(this.arcFill);\n      } else {\n        this.layer.removeShape(this.arrowStart);\n        this.layer.removeShape(this.arrowEnd);\n        this.layer.removeShape(this.arcLine);\n        this.layer.removeShape(this.arcArrow);\n        this.layer.removeShape(this.arcFill);\n      }\n    } }, { key: \"setOpacity\", value: function setOpacity(\n\n    opacity) {\n      this.opacityParam.setValue(opacity);\n    } }, { key: \"skipFade\", value: function skipFade()\n\n    {\n      this.opacityParam.skipAnim();\n    }\n\n    // Fade in/out. This also sets the visibility, i.e. shapes are hidden when opacity reaches zero.\n  }, { key: \"fadeTo\", value: function fadeTo(value) {\n      this.opacityParam.fadeTo(value);\n    }\n\n    // Update arc label position based on center point of the arc. Note that this.arcLine must be up to \n  }, { key: \"updateLabel\", value: function updateLabel(pixelsPerUnit, arcRadius) {\n\n      var arc = this.arcLine.exportEllipseArc(0, 0, this.arcCurve);\n      var labelPos;\n\n      if (this.options.centerLabel) {\n        labelPos = this.center;\n      } else {\n        // get point at center of the angle arc\n        labelPos = arc.getPoint(0.5, this.labelPos);\n\n        // Shift label position more \"outside\", i.e. away from the center\n        var labelPosOffset = this.labelPosOffset / pixelsPerUnit;\n        labelPos.sub(this.center);\n        labelPos.normalize();\n        labelPos.multiplyScalar(arcRadius + labelPosOffset);\n        labelPos.add(this.center);\n      }\n\n      this.label.setPosition(labelPos.x, labelPos.y);\n\n      // update label text\n      var angle = THREE.Math.radToDeg(arc.getAngleDelta());\n\n      if (!isNaN(angle)) {\n        var text = angle.toFixed(1) + \"Â°\";\n        this.label.setText(text);\n      }\n    } }, { key: \"update\", value: function update()\n\n    {\n\n      // Note: When using the gizmo on a plane in 3D, pixelsPerUnit may vary per point.\n      // Todo: Add general support for this case to Edit2D layers.\n      var pixelsPerUnit = 1;\n\n      // In case ignoreCameraDistance is set, the size of the arc won't change depending on the camera distance.\n      // In fact, the gizmo will behave more like an overlay.\n      if (!this.options.ignoreCameraDistance) {\n        var pWorld = new THREE.Vector3(this.center.x, this.center.y, 0).applyMatrix4(this.layer.layerToWorld);\n        pixelsPerUnit = this.layer.viewer.impl.camera.pixelsPerUnitAtPoint(pWorld);\n      }\n\n      // convert all sizes to layer-space\n      var arrowHeadLength = this.arrowHeadLength / pixelsPerUnit;\n      var arcRadius = this.arcRadius / pixelsPerUnit;\n\n      // Check if all directions are valid\n      var showGizmo = this.centerValid && this.pStartValid && this.pEndValid;\n\n      // Update gizmo visibility\n      this.arrowStart.setVisible(showGizmo);\n      this.arrowEnd.setVisible(showGizmo);\n      this.arcLine.setVisible(showGizmo);\n      this.arcArrow.setVisible(showGizmo);\n      this.arcFill.setVisible(showGizmo);\n\n      // Update label visibility\n      var showLabel = showGizmo && this.enableLabel;\n      this.label.setOpacity(showLabel ? 1.0 : 0.0, true); // label fades smoothly\n\n      // If everything is hidden now anyway, we are done here\n      if (!showGizmo) {\n        // Note that we still have to update in case some shapes just changed from visible to hidden.\n        this.layer.update();\n        return;\n      }\n\n      // arrows start at the angle center\n      this.arrowStart.setFrom(this.center);\n      this.arrowEnd.setFrom(this.center);\n\n      // arrows point toward pStart/pEnd\n      this.arrowStart.setTo(this.pStart);\n      this.arrowEnd.setTo(this.pEnd);\n\n      // scale arrow-head sizes for constant screen-size\n      if (!this.options.hideArrowHead) {\n        this.arrowStart.setHeadLength(arrowHeadLength);\n        this.arrowEnd.setHeadLength(arrowHeadLength);\n      }\n\n      // Compute angle\n      var startDir = this.pStart.clone().sub(this.center).normalize();\n      var endDir = this.pEnd.clone().sub(this.center).normalize();\n      var angle = Math2D.angleBetweenDirections(startDir, endDir);\n\n      // Prevent arc from being longer than the arrows\n      arcRadius = Math.min(arcRadius, this.pStart.distanceTo(this.center), this.pEnd.distanceTo(this.center));\n\n      // Configure ellpse arc\n      this.arcParams.rx = arcRadius;\n      this.arcParams.ry = arcRadius;\n      this.arcParams.sweepFlag = angle > Math.PI;\n      this.arcParams.largeArcFlag = false; // always display the shorter connection\n\n      // Compute arc start/end\n      var arcStart = startDir.clone().multiplyScalar(arcRadius).add(this.center);\n      var arcEnd = endDir.clone().multiplyScalar(arcRadius).add(this.center);\n\n      // Configure arc line\n      this.arcLine.updatePoint(0, arcStart.x, arcStart.y);\n      this.arcLine.updatePoint(1, arcEnd.x, arcEnd.y);\n      this.arcLine.setEllipseArc(0, this.arcParams);\n\n      // Configure arc arrow\n      var poly = this.arcLine.toPoly();\n      var from = poly.getPoint(poly.getVertexCount() - 2);\n      this.arcArrow.setFrom(from);\n      this.arcArrow.setTo(this.pEnd);\n\n      // Prevent the arrow from being larger than the arc itself\n      var arcArrowLenght = Math.min(arrowHeadLength, this.arcArrowMaxHeadLength * this.pEnd.distanceTo(this.pStart));\n      this.arcArrow.setHeadLength(arcArrowLenght);\n\n      // Configure arc fill\n      this.arcFill.updatePoint(0, this.center.x, this.center.y);\n      this.arcFill.updatePoint(1, arcStart.x, arcStart.y);\n      this.arcFill.updatePoint(2, arcEnd.x, arcEnd.y);\n      this.arcFill.setEllipseArc(1, this.arcParams);\n\n      this.updateLabel(pixelsPerUnit, arcRadius);\n\n      this.layer.update();\n    } }, { key: \"onCameraChange\", value: function onCameraChange()\n\n    {\n      this.update();\n    }\n\n    // If true, the angle label is frozen at its current state\n  }, { key: \"setLabelEnabled\", value: function setLabelEnabled(enabled) {\n      this.enableLabel = enabled;\n    } }]);return AngleGizmo;}();export { AngleGizmo as default };","function _typeof(obj) {\"@babel/helpers - typeof\";if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;};}return _typeof(obj);}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError(\"Cannot call a class as a function\");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}function _inherits(subClass, superClass) {if (typeof superClass !== \"function\" && superClass !== null) {throw new TypeError(\"Super expression must either be null or a function\");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}function _createSuper(Derived) {var hasNativeReflectConstruct = _isNativeReflectConstruct();return function _createSuperInternal() {var Super = _getPrototypeOf(Derived),result;if (hasNativeReflectConstruct) {var NewTarget = _getPrototypeOf(this).constructor;result = Reflect.construct(Super, arguments, NewTarget);} else {result = Super.apply(this, arguments);}return _possibleConstructorReturn(this, result);};}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");}return self;}function _isNativeReflectConstruct() {if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;if (Reflect.construct.sham) return false;if (typeof Proxy === \"function\") return true;try {Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));return true;} catch (e) {return false;}}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}\nimport AngleGizmo from './AngleGizmo.js';\nimport EditLayer from './EditLayer.js';\n\nvar nextId = 1;\n\n// Extends the AngleGizmo class by the ability to be used within a 3D scene.\n//\n// For this, AngleGizmo3d maintains an own layer that is placed within the current 3d view.\n// The layer is placed in a plane that is chosen based on selected location center and rotation axis.\nvar AngleGizmo3d = /*#__PURE__*/function (_AngleGizmo) {_inherits(AngleGizmo3d, _AngleGizmo);var _super = _createSuper(AngleGizmo3d);\n\n  // @param {Viewer3d} viewer\n  // @param {string}   [overlayName] - Must be the name of an existing viewer overlay. If not set, the gizmo creates its own\n  function AngleGizmo3d(viewer, options) {var _this;var overlayName = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;_classCallCheck(this, AngleGizmo3d);\n    _this = _super.call(this, new EditLayer(viewer), options); // init own layer\n\n    _this.viewer = viewer;\n\n    // Rotation center in world-coords. Serves as anchor point to place the EditLayer within 3d.\n    _this.center3d = new THREE.Vector3();\n    _this.pStart3d = new THREE.Vector3();\n    _this.pEnd3d = new THREE.Vector3();\n\n    _this.id = nextId++;\n\n    _this.overlayName = overlayName;\n    _this.overlayOwned = false;\n\n    // Create an own overlay if none is provided\n    if (!overlayName) {\n      // Create own overlay.\n      _this.overlayName = 'Autodesk.Edit2d.AngleGizmo3d.' + _this.id;\n      _this.viewer.impl.createOverlayScene(_this.overlayName);\n\n      // Remember that we have to clear it later\n      _this.overlayOwned = true;\n    }\n\n    // Display layer in the given overlay\n    _this.viewer.impl.addOverlay(_this.overlayName, _this.layer.scene);\n\n    // Reused for computing the layer placement\n    _this.layerMatrix = new THREE.Matrix4();return _this;\n  }_createClass(AngleGizmo3d, [{ key: \"dtor\", value: function dtor()\n\n    {\n      // Remove layer from overlay\n      this.viewer.impl.removeOverlay(this.overlayName, this.layer.scene);\n\n      // Remove overlay if own it\n      if (this.overlayOwned) {\n        this.viewer.impl.removeOverlayScene(this.overlayName);\n      }\n    }\n\n    // Return layer coords from given 3d world position\n  }, { key: \"toLayer\", value: function toLayer(p3d) {\n      return p3d && p3d.clone().applyMatrix4(this.layer.worldToLayer);\n    }\n\n    // Set EditLayer transform so that the layer is on the same\n    // plane as center.\n  }, { key: \"updateLayerTransform\", value: function updateLayerTransform() {\n      // Todo: Generalize to different axes\n      this.layerMatrix.makeTranslation(0, 0, this.center3d.z);\n      this.layer.setMatrix(this.layerMatrix);\n    } }, { key: \"setCenter3d\", value: function setCenter3d(\n\n    center3d) {\n\n      // If not set, just clear 2d center as well. This will hide the gizmo until a proper center is set. \n      if (!center3d) {\n        this.setCenter(null);\n        return;\n      }\n\n      // move layer to the plane containing center3d\n      this.center3d.copy(center3d);\n      this.updateLayerTransform();\n\n      // Make sure that any previously valid 2d start/end positions keep correct.\n      // Note that a new center was just chosen anyway, \n      this.pStartValid && this.setStart(this.toLayer(this.pStart3d));\n      this.pEndValid && this.setEnd(this.toLayer(this.pEnd3d));\n\n      // set center in layer-coords\n      this.setCenter(this.toLayer(this.center3d));\n    } }, { key: \"setStart3d\", value: function setStart3d(\n\n    start3d) {\n      if (start3d) {\n        this.pStart3d.copy(start3d);\n      }\n      this.setStart(this.toLayer(start3d));\n    } }, { key: \"setEnd3d\", value: function setEnd3d(\n\n    end3d) {\n      if (end3d) {\n        this.pEnd3d.copy(end3d);\n      }\n      this.setEnd(this.toLayer(end3d));\n    } }]);return AngleGizmo3d;}(AngleGizmo);export { AngleGizmo3d as default };","function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError(\"Cannot call a class as a function\");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}\nimport { Polyline, Style } from './EditShapes.js';\nimport { Math2D } from './Math2D.js';\n\n// AngleSnapper is responsible for snapping based on angles and alignment on hover while choosing the position of a vertex. \n//\n// If pMov is the vertex being moved, the snapping behavior includes:\n//\n//  1. Angle to previous edge: Snap if edge ending at pMov forms a snapAngle (0, 45, 90,...) with its predecessor edge.\n//\n//  2. Angle to next edge: Snap if the edge starting at pMov forms a snapAngle with its successor edge.\n//\n//  3. Collinear Align: Snap if for pMov is collinear with any (non-adjacent) edge.\n//\n//  4. Vertical Align: Snap if pMov is collinear with the edge normal at start/center/end of any non-adjacent edge.\n//\n\n// A SnapLine is a line that we consider for snapping. \nvar SnapLine = /*#__PURE__*/function () {\n\n  function SnapLine(a, b) {_classCallCheck(this, SnapLine);\n\n    // start and end point\n    this.a = a.clone();\n    this.b = b.clone();\n\n    // normalized edge direction\n    this.dir = Math2D.getEdgeDirection(a, b);\n  }\n\n  // Check for intersection with another SnapLine. If found, intersection point is written to outPoint.\n  // @returns {bool} true on success\n  _createClass(SnapLine, [{ key: \"intersect\", value: function intersect(line, outPoint) {\n      return Math2D.intersectLines(this.a, this.dir, line.a, line.dir, outPoint);\n    }\n\n    // project point to SnapLine\n  }, { key: \"snapToLine\", value: function snapToLine(p) {\n      Math2D.projectToLine(p, this.a, this.dir);\n    }\n\n    // Checks if SnapLine is close enough to p to allow snapping. snapRadius is in layer-coords.\n  }, { key: \"isUsable\", value: function isUsable(p, snapRadius) {\n      return Math2D.pointLineDistance(p, this.a, this.dir) < snapRadius;\n    }\n\n    // Checks if a SnapLine is (approx.) identical with another one\n  }, { key: \"isEqual\", value: function isEqual(snapLine, precision) {\n      return Math2D.collinear(this.a, this.dir, snapLine.a, snapLine.dir, precision);\n    } }]);return SnapLine;}();\n;\n\n// Snap position based on 1 or 2 SnapLines.\n//  @param {Vector2}  pos         - Initial position in layer coords. Modified in-place\n//  @param {SnapLine} snapLine1   - First line to snap to\n//  @param {SnapLine} [snapLine2] - If there are 2 SnapLines, we snap to the intersection of both lines.\n// Preconditions:\n//  - SnapLine1: Is close to pos (wrt. to snap tolerance)\n//  - SnapLine2: If existing, its intersection with SnapLine1 is close to the position  \nvar snapToLines = function snapToLines(pos, snapLine1, snapLine2) {\n\n  // No snaplines => keep original pos\n  if (!snapLine1 && !snapLine2) {\n    return;\n  }\n\n  // If only SnapLine1 exists\n  if (!snapLine2) {\n    // project pos to snapLine1\n    snapLine1.snapToLine(pos);\n    return;\n  }\n\n  // If only snapLine2 exists\n  if (!snapLine1) {\n    // project pos to snapLine2\n    snapLine2.snapToLine(pos);\n    return;\n  }\n\n  // Snap pos to line intersection.\n  snapLine1.intersect(snapLine2, pos);\n};\n\n// Get point i within a polygon, whereby indices outside [0, ..., this.poly.length-1] are auto-corrected using modulo.\n// Accepts negative indices up to -this.poly.length.\nvar getPointMod = function getPointMod(poly, index, loopIndex) {\n  var vertexCount = poly.getVertexCount(loopIndex);\n  index = (index + vertexCount) % vertexCount;\n  return poly.getPoint(index, loopIndex);\n};\n\n// Returns an array of SnapLines used to align with each edge of the given polygon.\n//  @param {Polygon}   poly\n//  @param {vIndex}    vIndex - index of the vertex being moved. We exclude edges directly adjacent to this vertex, because they are not fixed.\n//  @param {loopIndex} loopIndex\nvar findSnapLines = function findSnapLines(poly, vIndex, loopIndex) {\n\n  // tmp vectors\n  var normal = new THREE.Vector2();\n  var center = new THREE.Vector2();\n  var pEnd = new THREE.Vector2();\n\n  var snapLines = [];\n\n  // Given an edge of a polygon/polyline, this function collects snapping lines for alignment with this this edge.\n  // and adds it to snapLines.\n  // Generated snapLines are:\n  //  - Line spanned by the edge\n  //  - Orthogonal lines at start, center, and end point.\n  var addEdgeSnapLines = function addEdgeSnapLines(a, b) {\n\n    // add line spanned by the edge\n    snapLines.push(new SnapLine(a, b));\n\n    // get edge normal and center point\n    normal = Math2D.turnLeft(Math2D.getEdgeDirection(a, b, normal));\n    center = Math2D.getEdgeCenter(a, b, center);\n\n    // add orthogonal line add edge start\n    pEnd.copy(a).add(normal); // pEnd = p1 + normal\n    snapLines.push(new SnapLine(a, pEnd));\n\n    // add orthogonal line at edge center\n    pEnd.copy(center).add(normal); // pEnd = center + normal\n    snapLines.push(new SnapLine(center, pEnd));\n\n    // add orthogonal line at edge end\n    pEnd.copy(b).add(normal); // pEnd = p2 + normal\n    snapLines.push(new SnapLine(b, pEnd));\n  };var _loop = function _loop(\n\n  l) {\n    poly.enumEdges(function (a, b, ia, ib) {\n\n      // Exclude edges containing the moved vertex: These edges are not fixed yet and should not\n      // be used for alignment.\n      if (l === loopIndex && (ia === vIndex || ib === vIndex)) {\n        return;\n      }\n\n      // skip edge if degenerate\n      if (Math2D.edgeIsDegenerated(a, b)) {\n        return;\n      }\n\n      addEdgeSnapLines(a, b);\n    }, l);};for (var l = 0; l < poly.loopCount; l++) {_loop(l);\n  }\n  return snapLines;\n};\n\n// Checks if the given SnapLine candidate is suitable to be used - assuming that another snapLine1 was already chosen.\n// A candidate is only suitable if...\n//  1. The intersection with snapLine1 is within snapping tolerance\n//  2. The angle formed with snapLine1 is as closer to 90Â° than all other candidates. This makes sure that we rather \n//     snap to orthogonal SnapLines than trying to snap to two nearly parallel ones.\n// \n//  @param {SnapLine} candidate       - SnapLine candidates to be compared    \n//  @param {SnapLine} [bestCandidate] - Best candidate found so far (may be null)\n//  @param {SnapLine} snapLine1       - First SnapLine that has already been chosen to snap to.\n//  @param {Vector2}  pos             - position to be snapped\n//  @param {number}   snapRadius      - in layer coords\n//  @returns {SnapLine} Returns the best candidate - either bestCandidate or snapLineCandidate\nvar checkSecondSnapCandidate = function checkSecondSnapCandidate(candidate, bestCandidate, snapLine1, pos, snapRadius) {\n\n  // If candidate does not intersect snapLine1, we cannot use it.\n  var pIntersect = new THREE.Vector2();\n  if (!snapLine1.intersect(candidate, pIntersect)) {\n    return bestCandidate;\n  }\n\n  // If intersection point is outside snapRadius, discard candidate\n  if (pIntersect.distanceTo(pos) > snapRadius) {\n    return bestCandidate;\n  }\n\n  // If there is no competitor, the candidate made it.\n  if (!bestCandidate) {\n    return candidate;\n  }\n\n  // Check which of the candidates is \"less parallel\" to snapLine1\n  var dp1 = Math.abs(snapLine1.dir.dot(candidate.dir));\n  var dp2 = Math.abs(snapLine1.dir.dot(bestCandidate.dir));\n  return dp1 > dp2 ? candidate : bestCandidate;\n};\n\nvar xAxis = new THREE.Vector2(1, 0);\n\nvar av = Autodesk.Viewing;\n// AngleSnapper helps to draw right angles, parallel lines etc.\nvar AngleSnapper = /*#__PURE__*/function () {\n\n  function AngleSnapper(gizmoLayer) {_classCallCheck(this, AngleSnapper);\n    // Polygon/Polyline being edited. We assume that it includes the vertex being moved.\n    this.poly = null;\n\n    // Index of the vertex in this.poly that is beging moved.\n    this.vIndex = -1;\n    this.loopIndex = -1;\n\n    // If an edge forms one of these angles with the previous one, we display the helper line and snap to the angle\n    this.snapAngles = [0, 45, 90, 135, 180, 225, 270, 315, 360];\n\n    // We consider an angle \"close to\" another one if they differ by this value or less.\n    this.snapAngleTolerance = 2; // in degrees\n\n    // Allow snapping to lines within x pixels.\n    this.snapRadius = 10;\n\n    this.gizmoLayer = gizmoLayer;\n    this.setGlobalManager(gizmoLayer.globalManager);\n\n    // reused tmp points\n    this.movedPoint = new THREE.Vector2(); // the vertex being moved\n    this.prevPoint = new THREE.Vector2(); // the vertex before movedPoint\n    this.prevPoint2 = new THREE.Vector2(); // the vertex before prevPoint\n\n    this.edgeDir = new THREE.Vector2(); // direction of new edge ending at movedPoint\n    this.alignAxis = new THREE.Vector2(); // direction that we align to: Either the direction of the previous edge or the x-axis\n\n    // Array of snapLines to align a vertex position with other edges\n    this.edgeSnapLines = [];\n\n    // SnapLines that contributed to last snapping call. Used to update the SnapLine gizmos.\n    this.snapLine1 = null;\n    this.snapLine2 = null;\n\n    // Optional: External line constraint. This is used if we already snapped to a line geometry and\n    //           want to combine the snap with angle snapping.\n    this.snapLineExt = null;\n\n    // Gizmos to display the lines considered for snapping\n    this.snapLineStyle = new Style({\n      lineColor: 'rgb(255, 0, 0)',\n      lineWidth: 1.0,\n      lineStyle: 10 });\n\n    this.snapLineGizmos = [];\n    this.snapLineGizmosUsed = 0;\n  }_createClass(AngleSnapper, [{ key: \"onSetGlobalManager\", value: function onSetGlobalManager(\n\n    globalManager) {\n      this.globalManager = globalManager;\n      this.snapLineGizmos.forEach(function (g) {return g.setGloblaManager(globalManager);});\n    } }, { key: \"acquireSnapLineGizmo\", value: function acquireSnapLineGizmo()\n\n    {\n      var gizmo = this.snapLineGizmos[this.snapLineGizmosUsed];\n      if (!gizmo) {\n        // Create new line gizmo\n        gizmo = new Polyline([], this.snapLineStyle);\n        gizmo.setGlobalManager(this.globalManager);\n        this.snapLineGizmos[this.snapLineGizmosUsed] = gizmo;\n      }\n      this.snapLineGizmosUsed++;\n      return gizmo;\n    } }, { key: \"clearSnappingGizmos\", value: function clearSnappingGizmos()\n\n    {var _this = this;\n      var removeGizmo = function removeGizmo(g) {return _this.gizmoLayer.removeShape(g);};\n      this.snapLineGizmos.forEach(removeGizmo);\n      this.snapLineGizmosUsed = 0;\n    }\n\n    // Configures snapping to align to edges of the given polygon/polyline\n    //  @param {Polygon|Polyline} poly   - shape being edited. Expected to include the vertex being moved.\n    //  @param {number}           vIndex - index into poly that marks the vertex that is moved and to which snapping should be applied.\n    //  @param {number}           loopIndex\n  }, { key: \"startSnapping\", value: function startSnapping(poly, vIndex, loopIndex) {\n      this.poly = poly;\n      this.vIndex = vIndex;\n      this.loopIndex = loopIndex;\n\n      // precompute snapLines for alignment. These don't change while moving a vertex.\n      this.edgeSnapLines = findSnapLines(poly, vIndex, this.loopIndex);\n    } }, { key: \"stopSnapping\", value: function stopSnapping()\n\n    {\n\n      this.poly = null;\n      this.vIndex = -1;\n      this.loopIndex = -1;\n\n      // Discard any outdated results and hide gizmos\n      this.snapLine1 = null;\n      this.snapLine2 = null;\n      this.clearSnappingGizmos();\n    }\n\n    // Discard latest snapping results, but polygon, vIndex, and edge snapLines. This is used when temporarily hiding the SnapLines when\n    // snapping while snapping is bypassed.\n  }, { key: \"clearSnappingResult\", value: function clearSnappingResult() {\n      this.snapLine1 = null;\n      this.snapLine2 = null;\n    } }, { key: \"getPrevSnapLine\",\n\n\n\n\n\n    // Snap angles relative to previous edge: Return a snapLine if the edge being modified forms a snapAngle (e.g. 90 degrees) with the previous edge.\n    //  @param {Vector2} pMov - point to be snapped\n    //  @returns {null|SnapLine} Returns null if no SnapLine is within this.angleTolerance.\n    value: function getPrevSnapLine(pMov) {\n\n      // Get vertices one and two indices before the moved one.\n      var pPrev = getPointMod(this.poly, this.vIndex - 1, this.loopIndex);\n      var pPrev2 = getPointMod(this.poly, this.vIndex - 2, this.loopIndex);\n\n      // Check angle between (pPrev, pMov) and its predecessor edge (pPrev2, pPrev)\n      var alignAxis = Math2D.getEdgeDirection(pPrev2, pPrev);\n      return this.computeAngleSnapLine(pMov, pPrev, alignAxis);\n    }\n\n    // Snap angles relative to previous edge: Return a snapLine if the edge being modified forms a snapAngle (e.g. 90 degrees) with the next edge.\n    //  @param {Vector2} pMov - point to be snapped\n    //  @returns {null|SnapLine} Returns null if no SnapLine is within this.angleTolerance.\n  }, { key: \"getNextSnapLine\", value: function getNextSnapLine(pMov) {\n\n      // When moving one of the last two vertices of a polyline, there is actually no \"next edge\", because start and end\n      // vertex are not connected. Therefore, we skip snapping to \"next edge\" for this case.\n      var ignoreNextEdge = this.poly.isPolyline() && this.vIndex >= this.poly.getVertexCount(this.loopIndex) - 2;\n      if (ignoreNextEdge) {\n        return null;\n      }\n\n      var pNext = getPointMod(this.poly, this.vIndex + 1, this.loopIndex);\n      var pNext2 = getPointMod(this.poly, this.vIndex + 2, this.loopIndex);\n\n      // Snap to angle wrt. to next edge: (only for polygons)\n      //   Check angle between (pNext, pMov) and its successor edge (pNext, pNext2);\n      var alignAxis = Math2D.getEdgeDirection(pNext, pNext2);\n      return this.computeAngleSnapLine(pMov, pNext, alignAxis);\n    }\n\n    // Given a new position in layer-coords to be assigned to the moved vertex, this function checks if the adjacent edges of the moved\n    // vertex are close to a snap angle. If so, the movedPoint is corrected to match the snap angle exactly.\n    //  @param {Vector2} pMov - Position to be snapped\n    //  @param {Object}  [lineConstraint] - Optional: External line-constraint {a,b}. If specified, we only allow snapping to\n    //                                                intersections with angle snapLines and the line (lineConstraint.a, lineConstraint.b).\n  }, { key: \"snapToAngle\", value: function snapToAngle(pMov, lineConstraint) {var _this2 = this;\n\n      // Reset the two lines that we consider for snapping.\n      this.snapLine1 = null;\n      this.snapLine2 = null;\n\n      // Create snapLine from external line constraint (if specified)\n      this.snapLineExt = lineConstraint && new SnapLine(lineConstraint.a, lineConstraint.b);\n\n      if (!this.active || this.poly.vertexCount <= 1) {\n        return;\n      }\n\n      // Get point before the moved one.\n      var pPrev = getPointMod(this.poly, this.vIndex - 1, this.loopIndex);\n\n      // get snapRadius in layer-coords. This is the maximum distance that we allow\n      // between mouse pos and the final snap position that we obtain by projecting\n      // to a SnapLine or by intersecting two SnapLines.\n      var snapRadiusLC = this.snapRadius * this.gizmoLayer.getUnitsPerPixel();\n\n      // If we just have a single edge, we can only snap to angles relative to x-axis\n      var isFirstEdge = this.poly.vertexCount == 2;\n      if (isFirstEdge) {\n        // Get closest angle-snap line relative to mainAxis (or null if no snapAngle is close enough)\n        var snapAxis = this.computeAngleSnapLine(pMov, pPrev, xAxis);\n\n        if (snapAxis && this.snapLineExt) {\n          // If an external line constraint is set, snapAxis can only be considered as a secondary snap.\n          // This means, we can only consider if it intersects with the costraint line and the intersection is close to pMov\n          this.snapLine1 = checkSecondSnapCandidate(snapAxis, null, this.snapLineExt, pMov, snapRadiusLC);\n        } else {\n          // No other constraints. Just use the snapAxis (or no axis at all if snapAxis is null)\n          this.snapLine1 = snapAxis;\n        }\n\n        snapToLines(pMov, this.snapLine1, this.snapLineExt);\n        return;\n      }\n\n      var prevSnapLine = this.getPrevSnapLine(pMov);\n      var nextSnapLine = this.getNextSnapLine(pMov);\n\n      // Filter to lines that are close enough to pMov\n      var snapLineUsable = function snapLineUsable(snapLine) {\n\n        if (!snapLine) {\n          return false;\n        }\n\n        if (_this2.snapLineExt) {\n          // Consider line-constraint: Only accept snapLine if...\n          //  1. ...it intersects constraint line\n          //  2. ...intersection point is within snapRadius.\n          return Boolean(checkSecondSnapCandidate(snapLine, null, _this2.snapLineExt, pMov, snapRadiusLC));\n        }\n\n        // No constraint: Accept any snapLines within snapRadius\n        return snapLine.isUsable(pMov, snapRadiusLC);\n      };\n\n      var candidates = this.edgeSnapLines.filter(snapLineUsable);\n\n      // Reject prevSnapLine/nextSnapLine if they are not usable\n      prevSnapLine = snapLineUsable(prevSnapLine) && prevSnapLine;\n      nextSnapLine = snapLineUsable(nextSnapLine) && nextSnapLine;\n\n      // choose first snapLine\n      this.snapLine1 = prevSnapLine || nextSnapLine || candidates[0];\n\n      // Stop here if there is no snapping candidate at all\n      if (!this.snapLine1) {\n        return;\n      }\n\n      // If we have an external line constraint, we can only choose a single snapLine, because we already\n      // have to intersect it with the external constraint line.\n      if (this.snapLineExt) {\n        return snapToLines(pMov, this.snapLine1, this.snapLineExt);\n      }\n\n      // If prev and next edge allow angle snapping, check if we can snap to both\n      if (prevSnapLine && nextSnapLine) {\n        this.snapLine2 = checkSecondSnapCandidate(nextSnapLine, null, this.snapLine1, pMov, snapRadiusLC);\n      }\n\n      // If prevEdge and nextEdge already gave us 2 SnapLines, give these two preference. Otherwise,\n      // check if we can snap to another edge to be aligned with other edges.\n      if (!this.snapLine2) {\n        for (var i = 0; i < candidates.length; i++) {\n          var c = candidates[i];\n          this.snapLine2 = checkSecondSnapCandidate(c, this.snapLine2, this.snapLine1, pMov, snapRadiusLC);\n        }\n      }\n\n      // We selected one or two SnapLines. Now, use them to decide snapped position\n      return snapToLines(pMov, this.snapLine1, this.snapLine2);\n    } }, { key: \"isSnapped\", value: function isSnapped()\n\n    {\n      return Boolean(this.snapLine1 || this.snapLine2);\n    } }, { key: \"updateSnapLineGizmos\", value: function updateSnapLineGizmos(\n\n    snappedPos) {var _this3 = this;\n\n      // First, clear any outdated gizmos\n      this.clearSnappingGizmos();\n\n      if (!this.poly) {\n        return;\n      }\n\n      // Collect all snapLines that we want to display\n      //\n      // Note that we don't just want to indicate SnapLines that actively affected the position,\n      // but also the \"accidentally\" matched ones. E.g., if we snapped to a geometry intersection,\n      // the actual snapping was not affected by angle snapping, but the resulting position may still\n      // match with angle snapLines as well.\n      var snapLinesToShow = [];\n\n      // We consider the snapped position p to be \"on a snapLine L\" if the distance d(p,L) is within the tolerance below.\n      var tolerance = 0.0001;\n      var shouldBeShown = function shouldBeShown(sl) {return sl && sl.isUsable(snappedPos, tolerance);}; // Decides whether a SnapLine should be displayed\n\n      // If we only have a single edge, angle snapping is only possible wrt. to main axes\n      var isFirstEdge = this.poly.vertexCount == 2;\n\n      // Collect SnapLines to display\n      if (isFirstEdge) {\n        // Just a single edge: Only snap if this first edge forms a snapping angle with x- or y-axis.\n        var pPrev = getPointMod(this.poly, this.vIndex - 1, this.loopIndex);\n        var snapAxis = this.computeAngleSnapLine(snappedPos, pPrev, xAxis);\n\n        // Display snapAxis if the p is on this line\n        if (snapAxis && shouldBeShown(snapAxis)) {\n          snapLinesToShow.push(snapAxis);\n        }\n      } else {\n        // Consider all edge snaplines that contain pSnappedPos\n        snapLinesToShow = this.edgeSnapLines.filter(shouldBeShown);\n\n        // Consider angles to previous and next edge\n        var prevSnapLine = this.getPrevSnapLine(snappedPos);\n        var nextSnapLine = this.getNextSnapLine(snappedPos);\n        shouldBeShown(prevSnapLine) && snapLinesToShow.push(prevSnapLine);\n        shouldBeShown(nextSnapLine) && snapLinesToShow.push(nextSnapLine);\n      }\n\n      // Eliminate duplicates: If a SnapLine is collinear with another one, displaying it would just cause artifacts.\n      // Note: This is a brute-force n^2 loop. The number of SnapLines to display is usually small, so that this shouldn't be a problem.\n      var isRelevant = function isRelevant(sl, index) {\n        // Check if sl is a duplicate of any previous SnapLine\n        var isDuplicate = false;\n        for (var i = 0; i < index; i++) {\n          var sl2 = snapLinesToShow[i];\n          if (sl.isEqual(sl2, tolerance)) {\n            isDuplicate = true;\n            break;\n          }\n        }\n        return !isDuplicate;\n      };\n      snapLinesToShow = snapLinesToShow.filter(isRelevant);\n\n      // Choose SnapLineLength large enough to fill whole canvas\n      var canvas = this.gizmoLayer.viewer.canvas;\n      var diag = Math.sqrt(canvas.width * canvas.width + canvas.height * canvas.height);\n      var snapLineLength = this.gizmoLayer.getUnitsPerPixel() * diag;\n\n      // A SnapLine indicator is constructed as follows:\n      //  - It starts at the snapLine start point, which \"explains where the SnapLine comes from\". \n      //    This may be start/center/end of another edge.\n      //  - It should always point towards the moved vertex (note that an original edge normal may point away from the moved vertex)\n      //  - It is enlarged to overshoot pMov \n      var showSnapLine = function showSnapLine(line, gizmo) {\n        if (!line) {\n          return;\n        }\n\n        var a = line.a;\n\n        // Let line start at a, point towards dir, and be long enough to leave screen\n        gizmo.makeLine(\n        a.x - snapLineLength * line.dir.x,\n        a.y - snapLineLength * line.dir.y,\n        a.x + snapLineLength * line.dir.x,\n        a.y + snapLineLength * line.dir.y);\n\n        _this3.gizmoLayer.addShape(gizmo);\n      };\n\n      // Add lineGizmo for each SnapLine to be displayed\n      for (var i = 0; i < snapLinesToShow.length; i++) {\n        var snapLine = snapLinesToShow[i];\n        var gizmo = this.acquireSnapLineGizmo();\n        showSnapLine(snapLine, gizmo);\n      }\n    } }, { key: \"dtor\", value: function dtor()\n\n    {\n      this.clearSnapping();\n    }\n\n    // Checks if the angle between edge (pPrev, p) and alignment direction is close to a snapping angle.\n    // If so, it returns a SnapLine from pPrev towards the snapped direction, otherwise null.\n    //  @param {Vector2} p              - vertex being moved\n    //  @param {Vector2} pPrev          - vertex connected to p\n    //  @param {Vector2} alignAxis      - direction that we align to. Must be normalized.\n  }, { key: \"computeAngleSnapLine\", value: function computeAngleSnapLine(p, pPrev, alignAxis) {\n\n      // Don't try angle snapping with degenerated edges\n      if (Math2D.edgeIsDegenerated(pPrev, p)) {\n        return null;\n      }\n\n      // get direction of new edge (ending at pMov)\n      var edgeDir = p.clone().sub(pPrev);\n\n      // Compute angle between new edge and alignment direction\n      var angle = THREE.Math.radToDeg(Math2D.angleBetweenDirections(edgeDir, alignAxis));\n\n      // Check if angle matches with any index in snapAngles array\n      var snapIndex = -1;\n      for (var i = 0; i < this.snapAngles.length; i++) {\n        var _snapAngle = this.snapAngles[i];\n\n        var dif = Math.abs(_snapAngle - angle);\n        if (dif < this.snapAngleTolerance) {\n          snapIndex = i;\n          break;\n        }\n      }\n\n      // Stop here if no snapAngle is found\n      if (snapIndex == -1) {\n        return null;\n      }\n\n      // Rotate alignment axis by selected snapAngle\n      var snapAngle = THREE.Math.degToRad(this.snapAngles[snapIndex]);\n      var snapDir = Math2D.rotateAround(alignAxis.clone(), snapAngle);\n\n      // scale snapLine direction to the same length as (pPrev, p)\n      var dist = pPrev.distanceTo(p);\n      var snapLineEnd = snapDir.multiplyScalar(dist).add(pPrev);\n\n      // Return snapline from pPrev pointing towards snapped direction\n      return new SnapLine(pPrev, snapLineEnd);\n    } }, { key: \"active\", get: function get() {return this.poly;} }]);return AngleSnapper;}();export { AngleSnapper as default };\n\n\nav.GlobalManagerMixin.call(AngleSnapper.prototype);","function _typeof(obj) {\"@babel/helpers - typeof\";if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;};}return _typeof(obj);}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError(\"Cannot call a class as a function\");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}function _get(target, property, receiver) {if (typeof Reflect !== \"undefined\" && Reflect.get) {_get = Reflect.get;} else {_get = function _get(target, property, receiver) {var base = _superPropBase(target, property);if (!base) return;var desc = Object.getOwnPropertyDescriptor(base, property);if (desc.get) {return desc.get.call(receiver);}return desc.value;};}return _get(target, property, receiver || target);}function _superPropBase(object, property) {while (!Object.prototype.hasOwnProperty.call(object, property)) {object = _getPrototypeOf(object);if (object === null) break;}return object;}function _inherits(subClass, superClass) {if (typeof superClass !== \"function\" && superClass !== null) {throw new TypeError(\"Super expression must either be null or a function\");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}function _createSuper(Derived) {var hasNativeReflectConstruct = _isNativeReflectConstruct();return function _createSuperInternal() {var Super = _getPrototypeOf(Derived),result;if (hasNativeReflectConstruct) {var NewTarget = _getPrototypeOf(this).constructor;result = Reflect.construct(Super, arguments, NewTarget);} else {result = Super.apply(this, arguments);}return _possibleConstructorReturn(this, result);};}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");}return self;}function _isNativeReflectConstruct() {if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;if (Reflect.construct.sham) return false;if (typeof Proxy === \"function\") return true;try {Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));return true;} catch (e) {return false;}}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}import { Shape, Polyline, Polygon } from './EditShapes.js';\nimport { Math2D } from './Math2D.js';\n\n// Vector-shape for displaying simple arrows.\nvar Arrow = /*#__PURE__*/function (_Shape) {_inherits(Arrow, _Shape);var _super = _createSuper(Arrow);\n\n  function Arrow() {var _this;_classCallCheck(this, Arrow);\n    _this = _super.call(this);\n\n    // in layer coords\n    _this.from = new THREE.Vector2();\n    _this.to = new THREE.Vector2();\n\n    // extends of the arrow head in layer coords\n    _this.headLength = 2; // along arrow direction\n    _this.headAngle = 60; // in degrees. Angle at the tip of the arrow head.\n\n    _this.line = new Polyline();\n    _this.head = new Polygon();\n\n    // If true, head is a filled triangle, otherwise just two lines joining at the tip.\n    _this.headFilled = true;\n    _this.head.style.lineAlpha = 0.0;\n\n    // Add points for triangular head. We only update point positions afterwards.\n    _this.head.addPoint(0, 0);\n    _this.head.addPoint(0, 0);\n    _this.head.addPoint(0, 0);\n\n    // normalized arrow directiom. Auto-updated based on from/to\n    _this.dir = new THREE.Vector2();\n\n    // tmp vectors\n    _this.tmpVec1 = new THREE.Vector2();\n    _this.tmpVec2 = new THREE.Vector2();\n    _this.tmpVec3 = new THREE.Vector2();return _this;\n  }_createClass(Arrow, [{ key: \"modified\", value: function modified()\n\n    {\n      _get(_getPrototypeOf(Arrow.prototype), \"modified\", this).call(this);\n      this.needsUpdate = true;\n    } }, { key: \"draw\", value: function draw(\n\n    ctx) {\n      this.update();\n\n      // Todo: Concept to clarify style override for shapes with child shapes with different styles.\n      this.line.draw(ctx, this.line.style);\n      this.head.draw(ctx, this.head.style);\n    } }, { key: \"move\", value: function move(\n\n    dx, dy) {\n      this.from.x += dx;\n      this.from.y += dy;\n      this.to.x += dx;\n      this.to.y += dy;\n      this.modified();\n      return this;\n    } }, { key: \"hitTest\", value: function hitTest(\n\n    x, y) {\n      this.update();\n      return this.line.hitTest(x, y) || this.head.hitTest(x, y);\n    } }, { key: \"clone\", value: function clone()\n\n    {\n      return new Arrow().copy(this);\n    } }, { key: \"setFrom\", value: function setFrom(\n\n    x, y, z) {\n      if (_typeof(x) === 'object') {\n        this.from.copy(x);\n      } else {\n        this.from.set(x, y, z);\n      }\n      this.modified();\n    } }, { key: \"setTo\", value: function setTo(\n\n    x, y, z) {\n      if (_typeof(x) === 'object') {\n        this.to.copy(x);\n      } else {\n        this.to.set(x, y, z);\n      }\n    }\n\n    // Length of the arrow head. Should always be smaller than the full length of the arrow.\n  }, { key: \"setHeadLength\", value: function setHeadLength(len) {\n      this.headLength = len;\n      this.modified();\n    }\n\n    // Angle at the tip of the arrow head. In degrees.\n  }, { key: \"setHeadAngle\", value: function setHeadAngle(angle) {\n      this.headAngle = angle;\n      this.modified();\n    } }, { key: \"copy\", value: function copy(\n\n    from) {\n      _get(_getPrototypeOf(Arrow.prototype), \"copy\", this).call(this, from);\n      this.from = from.from.clone();\n      this.to = from.to.clone();\n      this.headLength = from.headLength;\n      this.headAngle = from.headAngle;\n      this.headFilled = from.headFilled;\n      this.modified();\n      return this;\n    } }, { key: \"computeBBox\", value: function computeBBox()\n\n    {\n      this.line.computeBBox();\n      this.head.computeBBox();\n\n      this.bbox.makeEmpty();\n      this.bbox.union(this.line.bbox);\n      this.bbox.union(this.head.bbox);\n    } }, { key: \"getLength\", value: function getLength()\n\n\n\n\n\n\n    {\n      return this.to.distanceTo(this.from);\n    }\n\n    // Change arrow lenght by changing one of the points. \n    //  @param {number} l - new length\n    //  @param {bool}   [changeFrom] - By default (false), we change the toPoint and keep fromPoint constant.\n    //                                 If true, we keep toPoint and change fromPoint instead.\n  }, { key: \"setLength\", value: function setLength(l, changeFrom) {\n\n      // Scale direction by new length\n      var dir = this.direction;\n      var dx = dir.x * l;\n      var dy = dir.y * l;\n\n      // Reset fromPoint or toPoint\n      if (changeFrom) {\n        this.setFrom(this.to.x - dx, this.to.y - dy);\n      } else {\n        this.setTo(this.from.x + dx, this.from.y + dy);\n      }\n    } }, { key: \"update\", value: function update()\n\n    {\n\n      if (!this.needsUpdate) {\n        return;\n      }\n\n      var dir = this.direction;\n\n      // compute line endpoint. If the head is filled, the line ends at the\n      // center of the head hypothenuse, otherwise at the to-point.\n      var ex = this.to.x - (this.headFilled ? dir.x * this.headLength : 0);\n      var ey = this.to.y - (this.headFilled ? dir.y * this.headLength : 0);\n\n      // draw arrow tail\n      this.line.makeLine(this.from.x, this.from.y, ex, ey);\n\n      // compute vector perpendicular to arrow directrion\n      var leftNormal = this.tmpVec2.copy(dir);\n      Math2D.turnLeft(leftNormal);\n\n      // compute distance between arrow line and left vertex of arrow head\n      var halfAngle = 0.5 * THREE.Math.degToRad(this.headAngle);\n      var dist = Math.tan(halfAngle) * this.headLength;\n\n      // compute left head vertex\n      var leftX = this.to.x - dir.x * this.headLength + leftNormal.x * dist;\n      var leftY = this.to.y - dir.y * this.headLength + leftNormal.y * dist;\n\n      // compute right head vertex\n      var rightX = this.to.x - dir.x * this.headLength - leftNormal.x * dist;\n      var rightY = this.to.y - dir.y * this.headLength - leftNormal.y * dist;\n\n      // update the 3 head vertices\n      this.head.updatePoint(0, leftX, leftY); // left vertex\n      this.head.updatePoint(1, this.to.x, this.to.y); // tip of the arrow\n      this.head.updatePoint(2, rightX, rightY); // right vertex\n\n      this.needsUpdate = false;\n    } }, { key: \"direction\", get: function get() {// Normalized arrow direction\n      return this.dir.copy(this.to).sub(this.from).normalize();} }]);return Arrow;}(Shape);export { Arrow as default };","function _toConsumableArray(arr) {return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();}function _nonIterableSpread() {throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");}function _unsupportedIterableToArray(o, minLen) {if (!o) return;if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);var n = Object.prototype.toString.call(o).slice(8, -1);if (n === \"Object\" && o.constructor) n = o.constructor.name;if (n === \"Map\" || n === \"Set\") return Array.from(o);if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);}function _iterableToArray(iter) {if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);}function _arrayWithoutHoles(arr) {if (Array.isArray(arr)) return _arrayLikeToArray(arr);}function _arrayLikeToArray(arr, len) {if (len == null || len > arr.length) len = arr.length;for (var i = 0, arr2 = new Array(len); i < len; i++) {arr2[i] = arr[i];}return arr2;}\n\nimport { SolidDefConvert } from './SolidDefConvert.js';\nimport { SketchRegionSolver, mergeConnectedFaces } from '@adsk/solid-definition';\nimport { getFacesInsideLoop } from './LoopContainment.js';\n\nvar Operator = {\n  Intersect: 1, // only keep regions where path1 and path2 are overlapping\n  Union: 2, // unify both shapes\n  Difference: 3, // path1 after removing all regions that are overlapped by path2\n  Xor: 4 // only keep regions that are either covered by path1 or path2, but not both\n};\n\n// Returns all faces that are \"inside the given wireBody\", whereby:\n//  - All wires in wireBody must be closed loops without branching\n//  - A face is considered as \"inside\" if it is enclosed by an odd number of wires (\"Even-Odd-Rule\")\n//\n// @param {SketchRegionSolver} solver   - initialized with all edges of subject and cutLoop\n// @param {SolidDef.WireBody}  wireBody - must contain closed loops.\n// Returns the subset of region faces that is inside the given wireBody. \nvar getFacesInside = function getFacesInside(solver, wireBody) {\n\n  // Mark all faces as rank 0, indicating that we did not find an enclosing loop yet\n  // Note: It's not perfectly clean to add extra attributes, but...\n  //  a) Since faces don't have unique ids, we don't have proper way to index them without modifying\n  //  b) All faces here are only temporary.\n  var regionFaces = solver.getFaces();\n  regionFaces.forEach(function (f) {return f.rank = 0;});\n\n  // for each wire\n  var wires = wireBody.getWires();\n  wires.forEach(function (w) {\n\n    // get faces inside this loop\n    var loopEdges = w.getEdges();\n    var facesInside = getFacesInsideLoop(solver, loopEdges);\n\n    // increase rank for all faces inside this loop\n    facesInside.forEach(function (f) {return f.rank++;});\n  });\n\n  // Return all faces whose rank is not a multiple of 2\n  var hasOddRank = function hasOddRank(f) {return Boolean(f.rank & 1);};\n  return regionFaces.filter(hasOddRank);\n};\n\n// Apply boolean operation on two SolidDef paths (must be closed).\n//\n// @param {SolidDef.Path2D}   path1           - the path to be clipped.\n// @param {SolidDef.Path2D}   path2           - to be cut away. Must be a single loop.\n// @param {Operator}          operator\n// @param {SolidDef.Path2D[]} [extraOperands] - Unify supports more than 2 operands.\n// @returns {SolidDef.Face[]} \nvar applyOperation = function applyOperation(path1, path2, operator, extraOperands) {\n\n  // get paths as wires\n  var wireBody1 = path1.getWireBody();\n  var wireBody2 = path2.getWireBody();\n\n  // get both paths as edge arrays\n  var edges1 = wireBody1.getEdges();\n  var edges2 = wireBody2.getEdges();\n\n  // get unified array with edges of both parts \n  var allEdges = edges1.concat(edges2);\n\n  // add edges of additional operands\n  extraOperands && extraOperands.forEach(function (p) {\n    var wb = p.getWireBody();\n    var edges = wb.getEdges();\n    allEdges.push.apply(allEdges, _toConsumableArray(edges));\n  });\n\n  // Feed them into solver to intersect them against each other and extract the resulting region faces.\n  var solver = new SketchRegionSolver();\n  solver.compute(allEdges);\n  var allFaces = solver.getFaces();\n\n  // check which of the faces are within path and cutPath        \n  var facesInPath1 = getFacesInside(solver, wireBody1);\n  var facesInPath2 = getFacesInside(solver, wireBody2);\n\n  // check which faces are in any of the extra operands\n  var facesInExtraPaths = extraOperands && extraOperands.map(function (p) {\n    var wb = p.getWireBody();\n    return getFacesInside(solver, wb);\n  });\n\n  // Filter faces based on operation type.\n  // Note: We have a O(numEdges^2) runtime here, which might be an issue for number of faces. \n  //       If needed, this could be optimized by tagging the edges with unique IDs in advance and indexing\n  //       the faces by id.\n  var filter = function filter(f) {\n    var inPath1 = facesInPath1.includes(f);\n    var inPath2 = facesInPath2.includes(f);\n\n    // Check if face is contained in any of the extra paths\n    var inExtraPath = facesInExtraPaths && facesInExtraPaths.some(function (faceSet) {return faceSet.includes(f);});\n\n    switch (operator) {\n      case Operator.Union:return inPath1 || inPath2 || inExtraPath;\n      case Operator.Intersect:return inPath1 && inPath2;\n      case Operator.Difference:return inPath1 && !inPath2;\n      case Operator.Xor:return inPath1 !== inPath2;}\n\n  };\n  var selectedFaces = allFaces.filter(filter);\n\n  // Finally, merge these faces to obtain result\n  return mergeConnectedFaces(selectedFaces);\n};\n\n//  @param {PolyBase[]} [extraOperands] - For unify, we allow moore than 2 operands.\nvar apply = function apply(path1, path2, operator, extraOperands) {\n  // Convert to SolidDef\n  var path1Sd = SolidDefConvert.toSolidDefPath(path1);\n  var path2Sd = SolidDefConvert.toSolidDefPath(path2);\n\n  var extraOperandsSD = extraOperands && extraOperands.map(function (p) {return SolidDefConvert.toSolidDefPath(p);});\n\n  // Run operation\n  var faces = applyOperation(path1Sd, path2Sd, operator, extraOperandsSD);\n\n  // Convert SolidDef faces back to Edit2D paths\n  var result = SolidDefConvert.facesToShape(faces);\n\n  // Let result inherit style of path1\n  result.style.copy(path1.style);\n\n  return result;\n};\n\nexport var BooleanOps = {\n  Operator: Operator,\n  apply: apply };","function _typeof(obj) {\"@babel/helpers - typeof\";if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;};}return _typeof(obj);}function _get(target, property, receiver) {if (typeof Reflect !== \"undefined\" && Reflect.get) {_get = Reflect.get;} else {_get = function _get(target, property, receiver) {var base = _superPropBase(target, property);if (!base) return;var desc = Object.getOwnPropertyDescriptor(base, property);if (desc.get) {return desc.get.call(receiver);}return desc.value;};}return _get(target, property, receiver || target);}function _superPropBase(object, property) {while (!Object.prototype.hasOwnProperty.call(object, property)) {object = _getPrototypeOf(object);if (object === null) break;}return object;}function _inherits(subClass, superClass) {if (typeof superClass !== \"function\" && superClass !== null) {throw new TypeError(\"Super expression must either be null or a function\");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}function _createSuper(Derived) {var hasNativeReflectConstruct = _isNativeReflectConstruct();return function _createSuperInternal() {var Super = _getPrototypeOf(Derived),result;if (hasNativeReflectConstruct) {var NewTarget = _getPrototypeOf(this).constructor;result = Reflect.construct(Super, arguments, NewTarget);} else {result = Super.apply(this, arguments);}return _possibleConstructorReturn(this, result);};}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");}return self;}function _isNativeReflectConstruct() {if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;if (Reflect.construct.sham) return false;if (typeof Proxy === \"function\") return true;try {Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));return true;} catch (e) {return false;}}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError(\"Cannot call a class as a function\");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}\nimport { Math2D } from './Math2D.js';\nimport { Polyline, PolyBase } from './EditShapes.js';\n\n// int value to string, e.g. 50 => \"50px\" - to used for style assignments.\nvar toPixels = function toPixels(val) {\n  return val.toString() + 'px';\n};\n\nexport var AlignX = {\n  Left: 1,\n  Center: 2,\n  Right: 3 };\n\n\nexport var AlignY = {\n  Top: 1,\n  Center: 2,\n  Bottom: 3 };\n\n\nvar av = Autodesk.Viewing;\n\n// Base class for any gizmo that needs to be synchronized with the shapes of an EditLayer.\nexport var CanvasGizmoBase = /*#__PURE__*/function () {\n  function CanvasGizmoBase() {_classCallCheck(this, CanvasGizmoBase);}\n\n  // Called whenever the layer or camera changes.\n  _createClass(CanvasGizmoBase, [{ key: \"update\", value: function update() {} }]);return CanvasGizmoBase;}();\n\n\nav.GlobalManagerMixin.call(CanvasGizmoBase.prototype);\n\n// A CanvasGizmo is an html div anchored at a position in layer-coords\nexport var CanvasGizmo = /*#__PURE__*/function (_CanvasGizmoBase) {_inherits(CanvasGizmo, _CanvasGizmoBase);var _super = _createSuper(CanvasGizmo);\n  function CanvasGizmo(layer) {var _this;var visible = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;var className = arguments.length > 2 ? arguments[2] : undefined;_classCallCheck(this, CanvasGizmo);\n    _this = _super.call(this);\n\n    _this.layer = layer;\n    _this.setGlobalManager(layer.globalManager);\n\n    // position in layer-coords. The transform origin of the div will appear at this position.\n    _this.layerPos = new THREE.Vector2();\n\n    // position in canvas-coords (updated based on this.layerPos and camera)\n    _this.canvasPos = new THREE.Vector2();\n\n    // html content to be shown\n    var _document = _this.getDocument();\n    _this.container = _document.createElement('div');\n\n    // Make sure that label is displayed on top of the canvas and not \"pushed away\" by it.\n    _this.container.style.position = 'absolute';\n\n    // Rotate around gizmo center\n    _this.container.style.transformOrigin = '50% 50%';\n    _this.container.style.top = '0px';\n    _this.container.style.left = \"0px\";\n\n    if (className) {\n      _this.container.classList.add(className);\n    }\n\n    // Show immediately if wanted\n    _this.visible = false;\n\n    _this.alignX = AlignX.Center;\n    _this.alignY = AlignY.Center;\n\n    // Clockwise rotation angle in degrees. Rotates around center.\n    _this.angle = 0;\n\n    if (visible) {\n      _this.setVisible(true, false);\n    }\n\n    // For fadeIn/Out effects\n    var setOpacity = function setOpacity(t) {\n      _this.container.style.opacity = t;\n    };\n    _this.opacityParam = new Autodesk.Viewing.Private.AnimatedParam(1.0, setOpacity, 0.5);\n\n    // By default, just delegate to viewer context menu. Edit2DContextMenu will take care\n    // that it is properly configured.\n    _this.container.addEventListener('contextmenu', function (e) {\n\n      // Workaround for Mac: By default, LMV's context menu is responds to right mouse-button.\n      // On Mac, Ctrl + Left also triggers context menu events. These must be ignored here, because:\n      //    a) Consistency: LMV ignores them as well.\n      //    b) Conflicts:   When inserting a vertex, we don't want the ContextMenu to show up.\n      var isLeftButton = e.buttons == 1;\n      if (!isLeftButton) {\n        _this.layer.viewer.triggerContextMenu(e);\n      }\n    });return _this;\n  }_createClass(CanvasGizmo, [{ key: \"dtor\", value: function dtor()\n\n    {\n      this.setVisible(false);\n    } }, { key: \"setVisible\", value: function setVisible(\n\n    visible) {var autoUpdate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      if (visible == this.visible) {\n        return;\n      }\n\n      if (visible) {\n        this.addToCanvas(autoUpdate);\n      } else {\n        this.removeFromCanvas();\n      }\n\n      this.visible = visible;\n    } }, { key: \"addToCanvas\", value: function addToCanvas()\n\n    {var autoUpdate = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n      // Note: It's essential that we add it to viewer.canvasWrap instead of viewer.container:\n      //       ToolController listens to events on canvasWrap. Therefore, if we would add\n      //       it to viewer.container, all mouse events captured would never reach the ToolController\n      //       no matter whether the gizmo handles them or not.\n      this.layer.viewer.canvasWrap.appendChild(this.container);\n      this.layer.addCanvasGizmo(this);\n\n      // Make sure that position is correct\n      if (autoUpdate) {\n        this.update();\n      }\n    } }, { key: \"removeFromCanvas\", value: function removeFromCanvas()\n\n    {\n      this.layer.viewer.canvasWrap.removeChild(this.container);\n      this.layer.removeCanvasGizmo(this);\n    } }, { key: \"setAlignX\", value: function setAlignX(\n\n    alignX) {\n      this.alignX = alignX;\n      this.update();\n    } }, { key: \"setAlignY\", value: function setAlignY(\n\n    alignY) {\n      this.alignY = alignY;\n      this.update();\n    }\n\n    // @param {number} angle - Clockwise angle in degrees\n    //\n    // Note: Do not use 'position:absolute' in child html elements.\n    //       Otherwise, the content box will be empty and it will not rotate around anymore.\n  }, { key: \"setRotation\", value: function setRotation(angle) {\n      this.angle = angle;\n      this.update();\n    } }, { key: \"update\", value: function update()\n\n    {\n      this.canvasPos.copy(this.layer.layerToCanvas(this.layerPos.x, this.layerPos.y));\n\n      var p = this.canvasPos;\n      var style = this.container.style;\n\n      // set left/top to gizmo position\n      var left = toPixels(p.x);\n      var top = toPixels(p.y);\n\n      // Choose translation offset in % based on X-alignment\n      var tx;\n      switch (this.alignX) {\n        case AlignX.Left:tx = '0%';break;\n        case AlignX.Center:tx = '-50%';break;\n        case AlignX.Right:tx = '-100%';break;}\n\n\n      var ty;\n      switch (this.alignY) {\n        case AlignY.Top:ty = '0%';break;\n        case AlignY.Center:ty = '-50%';break;\n        case AlignY.Bottom:ty = '-100%';break;}\n\n\n      // Update transform based on rotation angle and alignment\n      style.transform = \"translate(\".concat(left, \", \").concat(top, \") translate(\").concat(tx, \", \").concat(ty, \") rotate(\").concat(this.angle, \"deg)\");\n    }\n\n    // Set position in layer coords\n  }, { key: \"setPosition\", value: function setPosition(x, y) {\n      this.layerPos.set(x, y);\n      this.update();\n    } }, { key: \"setClassEnabled\", value: function setClassEnabled(\n\n    className, enabled) {\n      if (enabled) {\n        this.container.classList.add(className);\n      } else {\n        this.container.classList.remove(className);\n      }\n    }\n\n    // Selection state is managed using a css-class 'selected'.\n    // Note that this only has an effect if the css style used for the gizmo supports it.\n  }, { key: \"setSelected\", value: function setSelected(selected) {\n      this.setClassEnabled('selected', selected);\n    } }, { key: \"isSelected\", value: function isSelected()\n\n    {\n      return this.container.classList.contains('selected');\n    }\n\n    // Optional: Hover-effect for gizmos that can be clicked or dragged.\n  }, { key: \"setHoverEnabled\", value: function setHoverEnabled(enabled) {\n      this.setClassEnabled('enable-hover', enabled);\n    }\n\n    // Optional: Assign a name to gizmo and div element to facilitate debugging and testing.\n  }, { key: \"setName\", value: function setName(name) {\n      this.name = name;\n      this.container.id = name ? name : '';\n    }\n\n    // Change css opacity. If wanted, the change can be smoothly faded.\n  }, { key: \"setOpacity\", value: function setOpacity(value, animate) {\n      if (animate) {\n        this.opacityParam.fadeTo(value);\n      } else {\n        this.opacityParam.setValue(value);\n      }\n    } }]);return CanvasGizmo;}(CanvasGizmoBase);\n\n\n// Configure CanvasGizmo as a text label.\nvar initTextLabel = function initTextLabel(gizmo) {\n\n  // Use measure-tool styles by default\n  gizmo.container.classList.add('edit2d-label');\n  gizmo.container.classList.add('visible');\n\n  // Create textDiv child div\n  var _document = gizmo.getDocument();\n  gizmo.textDiv = _document.createElement('div');\n  gizmo.textDiv.classList.add('edit2d-label-text');\n  gizmo.container.appendChild(gizmo.textDiv);\n\n  // Add setText convenience function\n  gizmo.setText = function (str) {\n    this.textDiv.textContent = str;\n  }.bind(gizmo);\n};\n\n// Simple TextLabel bound to a fixed position in layer coords\nexport var TextLabel = /*#__PURE__*/function (_CanvasGizmo) {_inherits(TextLabel, _CanvasGizmo);var _super2 = _createSuper(TextLabel);\n\n  function TextLabel(layer, text, className) {var _this2;_classCallCheck(this, TextLabel);\n    _this2 = _super2.call(this, layer, true, className);\n    initTextLabel(_assertThisInitialized(_this2));return _this2;\n  }return TextLabel;}(CanvasGizmo);\n\n;\n\n// A ShapeLabel is a text label whose anchor position is synchronized with the bbox center of a shape in a layer.\nexport var ShapeLabel = /*#__PURE__*/function (_CanvasGizmo2) {_inherits(ShapeLabel, _CanvasGizmo2);var _super3 = _createSuper(ShapeLabel);\n\n  function ShapeLabel(shape, layer) {var _this3;var visible = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;var className = arguments.length > 3 ? arguments[3] : undefined;_classCallCheck(this, ShapeLabel);\n    _this3 = _super3.call(this, layer, visible, className);\n\n    initTextLabel(_assertThisInitialized(_this3));\n\n    _this3.shape = shape;\n\n    // Can be set to hidden to temporarily hide the label\n    _this3.valueValid = true;\n\n    // Optional: Shift label by a couple of pixels.\n    _this3.pixelOffset = new THREE.Vector2();\n\n    _this3.update();return _this3;\n  }_createClass(ShapeLabel, [{ key: \"update\", value: function update()\n\n    {\n      if (this.shape && this.valueValid) {\n        // Set it to visible (in case polygon was null before)\n        this.container.style.visibility = 'visible';\n\n        if (this.shape.isPolyline()) {\n          var edgeCount = this.shape.getEdgeCount(0);\n          // For a start, simply position the label on the segment roughly in the middle of the polyline\n          var edgeToLabel = Math.floor(edgeCount / 2);\n          if (this.shape.edgeIndexValid(edgeToLabel)) {\n            // Set layer position to center point of the segment.\n            this.shape.getPointOnEdge(edgeToLabel, 0.5, 0, this.layerPos);\n          }\n        } else\n        {\n          // For a start, simply use the bbox center of the polygon. In some cases, this might end up outside the\n          // polygon, so we may consider something smarter later.\n          this.shape.computeBBox();\n          this.shape.bbox.getCenter(this.layerPos);\n        }\n\n        // Optional: Shift by a few pixels\n        if (this.pixelOffset) {\n          var toUnits = this.layer.getUnitsPerPixel();\n          var shiftX = this.pixelOffset.x * toUnits;\n          var shiftY = this.pixelOffset.y * toUnits;\n          this.layerPos.x += shiftX;\n          this.layerPos.y += shiftY;\n        }\n\n        _get(_getPrototypeOf(ShapeLabel.prototype), \"update\", this).call(this);\n      } else {\n        this.container.style.visibility = 'hidden';\n      }\n    } }, { key: \"setShape\", value: function setShape(\n\n    shape) {\n      this.shape = shape;\n      this.update();\n    } }]);return ShapeLabel;}(CanvasGizmo);\n\n\n// Only works for shapes with getLength() function\nexport var LengthLabel = /*#__PURE__*/function (_ShapeLabel) {_inherits(LengthLabel, _ShapeLabel);var _super4 = _createSuper(LengthLabel);\n\n  // @param {Polyline}    polyline\n  // @param {EditLayer}   layer\n  // @param {UnitHandler} unitHandler - unitHandler.areaToString() is required to define how to display area values as string.\n  // @param {bool}        [visible]\n  function LengthLabel(polyline, layer, unitHandler) {var _this4;var visible = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;_classCallCheck(this, LengthLabel);\n    _this4 = _super4.call(this, polyline, layer, visible);\n    _this4.unitHandler = unitHandler;return _this4;\n  }_createClass(LengthLabel, [{ key: \"update\", value: function update()\n\n    {\n      // Get shape length (if shape supports it)\n      var hasLength = this.shape && this.shape.getLength;\n      var length = hasLength && this.shape.getLength(this.unitHandler.measureTransform);\n\n      // Hide label if we don't have a well-defined length.\n      // We also hide it if length is 0.0, because the shape cannot be visible anyway.\n      this.valueValid = Boolean(length);\n\n      if (this.valueValid) {\n        var text = this.unitHandler.lengthToString(length);\n        this.setText(text);\n      }\n\n      // Let base class update position\n      _get(_getPrototypeOf(LengthLabel.prototype), \"update\", this).call(this);\n    } }]);return LengthLabel;}(ShapeLabel);\n\n\n// Only works for shapes with getArea() function\nexport var AreaLabel = /*#__PURE__*/function (_ShapeLabel2) {_inherits(AreaLabel, _ShapeLabel2);var _super5 = _createSuper(AreaLabel);\n\n  // @param {Polygon}     polygon\n  // @param {EditLayer}   layer\n  // @param {UnitHandler} unitHandler - unitHandler.areaToString() is required to define how to display area values as string.\n  // @param {bool}        [visible]\n  function AreaLabel(polygon, layer, unitHandler) {var _this5;var visible = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;_classCallCheck(this, AreaLabel);\n    _this5 = _super5.call(this, polygon, layer, visible);\n    _this5.unitHandler = unitHandler;\n    _this5.update(); // update with proper unitHandler\n    return _this5;}_createClass(AreaLabel, [{ key: \"update\", value: function update()\n\n    {\n      // Don't display until a unitHandler is set\n      if (!this.unitHandler) {\n        return;\n      }\n\n      // Handle PolyBase with self-intersections: Display an error indicator in this case.\n      if (this.shape && this.shape.isSelfIntersecting && this.shape.isSelfIntersecting()) {\n\n        // Show an error indicator instead\n        this.setText(av.i18n.t('Invalid shape'));\n\n        // Mark area label as error\n        this.container.classList.add('error-indicator');\n\n        // Mark sure error indicator is displayed\n        this.valueValid = true;\n        _get(_getPrototypeOf(AreaLabel.prototype), \"update\", this).call(this);\n\n        return;\n      } else {\n        // Make sure that error indicator is toggled off\n        this.container.classList.remove('error-indicator');\n      }\n\n      // Get shape area (if shape supports it)\n      var hasArea = this.shape && this.shape.getArea;\n      var area = hasArea && this.shape.getArea(this.unitHandler.measureTransform);\n\n      // Hide label if we don't have a well-defined area.\n      // We also hide it if area is 0.0, because the shape cannot be visible anyway.\n      this.valueValid = Boolean(area);\n\n      if (this.valueValid) {\n        var text = this.unitHandler.areaToString(area);\n        this.setText(text);\n      }\n\n      // Let base class update position\n      _get(_getPrototypeOf(AreaLabel.prototype), \"update\", this).call(this);\n    } }]);return AreaLabel;}(ShapeLabel);\n\n\n// A html element for which position and rotation is aligned with an edge\nexport var EdgeGizmo = /*#__PURE__*/function (_CanvasGizmo3) {_inherits(EdgeGizmo, _CanvasGizmo3);var _super6 = _createSuper(EdgeGizmo);\n\n  // @param {EditLayer} layer\n  // @param {bool} visible\n  function EdgeGizmo(layer) {var _this6;var visible = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;var className = arguments.length > 2 ? arguments[2] : undefined;_classCallCheck(this, EdgeGizmo);\n    _this6 = _super6.call(this, layer, visible, className);\n\n    _this6.posA = new THREE.Vector2();\n    _this6.posB = new THREE.Vector2();\n\n    // Indicates if a position has been set. If not, we temporarily hide the gizmo. If the gizmo is\n    // attached to an edge, this flag is set automatically.\n    _this6.posValid = false;\n\n    // Temp vectors used in update\n    _this6.edgeDir = new THREE.Vector2();\n\n    // Optional: Positions can be synchronized with an edge of a polygon or polyline\n    _this6.poly = null;\n    _this6.loopIndex = 0;\n    _this6.edgeIndex = 0;\n\n    // Use measure-length css style by default\n    _this6.container.classList.add('edge-gizmo');\n\n    // Optional: By default, an EdgeGizmo is always placed on a segment, i.e., the gizmo will follow a curve for arc segments.\n    //           If this flag is true, the gizmo is always placed on the direct line connection.\n    _this6.ignoreArcs = false;\n\n    // Optional: If specified, this limits the size of the gizmo relative to the edge length on screen:\n    // We hide the gizmo if it exceeds x * edgeLength on screen.\n    _this6.maxRelativeLength = undefined; // in [0,1]\n    return _this6;}\n\n  // If a poly is set, the gizmo is automatically synchronized with the edge.\n  // As long as the poly is visible in the same layer, the edge is automatically kept in sync with the edge.\n  //\n  //  @param {PolyBase} poly      - polygon or polyline containing the edge that we want to attach to. If null, positions can be set manually.\n  //  @param {number} edgeIndex   - edgeIndex in poly. If not valid, gizmo is hidden.\n  //  @param {number} [loopIndex] - loopIndex in poly. 0 by default\n  _createClass(EdgeGizmo, [{ key: \"attachToEdge\", value: function attachToEdge(poly, edgeIndex) {var loopIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n      this.poly = poly;\n      this.edgeIndex = edgeIndex;\n      this.loopIndex = loopIndex;\n      this.update();\n    } }, { key: \"detachFromEdge\", value: function detachFromEdge()\n\n    {\n      this.poly = null;\n      this.edgeIndex = -1;\n      this.loopIndex = -1;\n      this.posValid = false; // hide unless a position is explicitly set\n      this.update();\n    } }, { key: \"edgeValid\", value: function edgeValid()\n\n    {\n      return this.poly && this.poly.edgeIndexValid(this.edgeIndex, this.loopIndex);\n    } }, { key: \"update\", value: function update()\n\n    {\n\n      // If a polygon is set, obtain positions automatically from it - or hide gizmo if edge does not exist anymore\n      if (this.poly && this.poly.edgeIndexValid(this.edgeIndex, this.loopIndex)) {\n        this.poly.getEdge(this.edgeIndex, this.posA, this.posB, this.loopIndex);\n        this.posValid = true;\n      } else {\n        // This may happen if host polygon was modified and the edge does not exist anymore.\n        this.posValid = false;\n      }\n\n      // If edge is invalid or too small on screen, just hide the gizmo\n      var show = this._shouldBeShown();\n      this.container.style.visibility = show ? 'visible' : 'hidden';\n      if (!show) {\n        return;\n      }\n\n      // Center gizmo at edge center\n      if (this.ignoreArcs) {\n        // Place on the line segment\n        PolyBase.prototype.getPointOnEdge.call(this.poly, this.edgeIndex, 0.5, this.loopIndex, this.layerPos);\n      } else {\n        // Place on line segment or arc - depending on actual edge type\n        this.poly.getPointOnEdge(this.edgeIndex, 0.5, this.loopIndex, this.layerPos);\n      }\n\n      // Set rotation angle\n      this._updateRotation();\n\n      _get(_getPrototypeOf(EdgeGizmo.prototype), \"update\", this).call(this);\n    }\n\n    // Check if the gizmo should be shown: We hide it if the edge is too small or if the edge does not exist at all.\n  }, { key: \"_shouldBeShown\", value: function _shouldBeShown() {\n\n      // Positions must be properly set - either automatically from an attached edge or manually using setEdge()\n      if (!this.posValid) {\n        return false;\n      }\n\n      // Show/Hide gizmo depending on zoom:\n      // Gizmo has constant screen-size. So, we hide it if the screen-size of the edge becomes too small.\n      if (this.maxRelativeLength) {\n        var aScreen = this.layer.layerToCanvas(this.posA.x, this.posA.y);\n        var bScreen = this.layer.layerToCanvas(this.posB.x, this.posB.y);\n        var edgeLengthScreen = aScreen.distanceTo(bScreen);\n        var maxAllowedPixels = edgeLengthScreen * this.maxRelativeLength;\n        var _window = this.getWindow();\n        var width = parseFloat(_window.getComputedStyle(this.container).width);\n        return width < maxAllowedPixels;\n      }\n      return true;\n    }\n\n    // Set style rotation to align gizmo along edge direction, so that 'width' is along the edge\n  }, { key: \"_updateRotation\", value: function _updateRotation() {\n\n      // Compute counterClockwise angle in radians that rotates the positive x-axis to the edge direction a->b\n      // It's important to compute the angle in canvas space here. If we would compute it in layer space,\n      // the angle orientation of the result may be inverted if the layerToCanvas() transform inverts orientation (e.g. by flipped y-axis)\n      var aScreen = this.layer.layerToCanvas(this.posA.x, this.posA.y);\n      var bScreen = this.layer.layerToCanvas(this.posB.x, this.posB.y);\n\n      var dir = Math2D.getEdgeDirection(aScreen, bScreen, this.edgeDir);\n      var angle = Math.atan2(dir.y, dir.x);\n\n      // Avoid upside-down rotation: Flip by 180 degrees if b is left of a. This is import if gizmo contains text.\n      if (dir.x < 0) {\n        angle += Math.PI;\n      }\n\n      // Convert angle to clockwise degrees and apply it to style\n      // Just set the angle here, but don't call setAngle, becaue we don't want to trigger auto-update.\n      this.angle = THREE.Math.radToDeg(angle);\n    } }]);return EdgeGizmo;}(CanvasGizmo);\n\n\nexport var EdgeMoveGizmo = /*#__PURE__*/function (_EdgeGizmo) {_inherits(EdgeMoveGizmo, _EdgeGizmo);var _super7 = _createSuper(EdgeMoveGizmo);\n\n  function EdgeMoveGizmo(layer, name) {var _this7;var visible = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;var className = arguments.length > 3 ? arguments[3] : undefined;_classCallCheck(this, EdgeMoveGizmo);\n    _this7 = _super7.call(this, layer, visible, className);\n\n    _this7.setName(name);\n    _this7.container.classList.add('edge-move-gizmo');\n\n    // We place EdgeMoveGizmos always directly on the straight lines. In this way, edge moving\n    // will work in the same way - no matter whether a segment is an arc or not.\n    _this7.ignoreArcs = true;\n\n    // Hide gizmo if its screenWidth exceeds 0.3 * edgeLength\n    _this7.maxRelativeLength = 0.3; // in [0,1]\n    return _this7;}return EdgeMoveGizmo;}(EdgeGizmo);\n\n\n// An EdgeGizmo to display text\nexport var EdgeLabel = /*#__PURE__*/function (_EdgeGizmo2) {_inherits(EdgeLabel, _EdgeGizmo2);var _super8 = _createSuper(EdgeLabel);\n\n  function EdgeLabel(layer) {var _this8;var visible = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;_classCallCheck(this, EdgeLabel);\n    _this8 = _super8.call(this, layer, visible);\n    initTextLabel(_assertThisInitialized(_this8));\n\n    // Hide label if it would exceed the edge length\n    _this8.maxRelativeLength = 1.0;return _this8;\n  }return EdgeLabel;}(EdgeGizmo);\n\n\nexport var VertexGizmo = /*#__PURE__*/function (_CanvasGizmo4) {_inherits(VertexGizmo, _CanvasGizmo4);var _super9 = _createSuper(VertexGizmo);\n\n  // @param {number}  x,y       - Position in layer coords\n  // @param {string}  id        - id string used to tag shapes that represent this gizmo\n  function VertexGizmo(layer, x, y, name, className) {var _this9;_classCallCheck(this, VertexGizmo);\n    _this9 = _super9.call(this, layer, true, className);\n    _this9.setPosition(x, y);\n    _this9.setName(name);\n\n    _this9.pos = new THREE.Vector2();\n\n    // Optional: Positions can be synchronized with a vertex of a polygon or polyline\n    _this9.poly = null;\n    _this9.loopIndex = -1;\n    _this9.vertexIndex = -1;\n\n    _this9.container.classList.add('vertex-gizmo');return _this9;\n  }\n\n  // If a poly is set, the gizmo is automatically synchronized with the vertex.\n  // As long as the poly is visible in the same layer, the vertex gizmo is automatically kept in sync with the vertex.\n  //\n  //  @param {PolyBase} poly      - polygon or polyline containing the vertex that we want to attach to. If null, positions can be set manually.\n  //  @param {number} vertexIndex   - vertexIndex in poly. If not valid, gizmo is hidden.\n  //  @param {number} [loopIndex] - loopIndex in poly. 0 by default\n  _createClass(VertexGizmo, [{ key: \"attachToVertex\", value: function attachToVertex(poly, vertexIndex) {var loopIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n      this.poly = poly;\n      this.vertexIndex = vertexIndex;\n      this.loopIndex = loopIndex;\n      this.update();\n    } }, { key: \"detachFromVertex\", value: function detachFromVertex()\n\n    {\n      this.poly = null;\n      this.vertexIndex = -1;\n      this.loopIndex = -1;\n      this.posValid = false; // hide unless a position is explicitly set\n      this.update();\n    } }, { key: \"update\", value: function update()\n\n    {\n      // Gizmo is not attached to a polygon. Just update according to the initial position.\n      if (!this.poly) {\n        _get(_getPrototypeOf(VertexGizmo.prototype), \"update\", this).call(this);\n        return;\n      }\n\n      // If a polygon is set, obtain positions automatically from it - or hide gizmo if vertex does not exist anymore\n      if (this.poly.indexValid(this.vertexIndex, this.loopIndex)) {\n        this.poly.getPoint(this.vertexIndex, this.loopIndex, this.pos);\n        this.posValid = true;\n      } else {\n        // This may happen if host polygon was modified and the vertex does not exist anymore.\n        this.posValid = false;\n      }\n\n      // If edge is invalid, just hide the gizmo\n      var show = this.posValid;\n\n      this.container.style.visibility = show ? 'visible' : 'hidden';\n\n      if (!show) {\n        return;\n      }\n\n      this.layerPos.set(this.pos.x, this.pos.y);\n\n      _get(_getPrototypeOf(VertexGizmo.prototype), \"update\", this).call(this);\n    } }]);return VertexGizmo;}(CanvasGizmo);\n\n\n// A Label filter decides for which shapes we display a label\nexport var LabelFilter = /*#__PURE__*/function () {\n\n  function LabelFilter() {_classCallCheck(this, LabelFilter);}\n\n  // If false, we don't need to acquire a label at all.\n  _createClass(LabelFilter, [{ key: \"accepts\", value: function accepts(shape, text) {\n      return true;\n    } }]);return LabelFilter;}();\n;\n\n// Get shape width in screen-pixels\nvar getShapeWidth = function getShapeWidth(shape, layer) {\n  // get shape size in screen-pixels\n  shape.updateBBox();\n  var bbox = shape.bbox;\n  var shapeWidth = bbox.max.x - bbox.min.x;\n  return shapeWidth * layer.getPixelsPerUnit() * shapeWidth;\n};\n\n// By default, we hide labels if text is empty or if the shape size on screen falls beyond a pixel threshold\nexport var DefaultLabelFilter = /*#__PURE__*/function (_LabelFilter) {_inherits(DefaultLabelFilter, _LabelFilter);var _super10 = _createSuper(DefaultLabelFilter);\n\n  // @param {number} minWidth - minimum pixel width a shape must have to receive a label\n  function DefaultLabelFilter() {var _this10;var minWidth = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 5;_classCallCheck(this, DefaultLabelFilter);\n    _this10 = _super10.call(this);\n    _this10.minWidth = minWidth;return _this10;\n  }\n\n  // Accept shape if text is not empty and its screen-width is big enough.\n  _createClass(DefaultLabelFilter, [{ key: \"accepts\", value: function accepts(shape, text, layer) {\n      var width = getShapeWidth(shape, layer);\n      return Boolean(text) && width >= this.minWidth;\n    } }]);return DefaultLabelFilter;}(LabelFilter);\n\n\n// A LabelStyle rule allows to apply css style modifications on a label, e.g., depending on screen size\nexport var LabelStyleRule = /*#__PURE__*/function () {\n\n  function LabelStyleRule() {_classCallCheck(this, LabelStyleRule);}\n\n  // Note: Labels may be reused for different shapes. So, make sure that the style parameters are\n  //       not just modified for some subset of shapes, but reset for others.\n  _createClass(LabelStyleRule, [{ key: \"apply\", value: function apply(label, shape, layer) {} }]);return LabelStyleRule;}();\n;\n\n// Fades out based on label size\nexport var FadeOutStyleRule = /*#__PURE__*/function (_LabelStyleRule) {_inherits(FadeOutStyleRule, _LabelStyleRule);var _super11 = _createSuper(FadeOutStyleRule);\n\n  // @param {number} rangeStart - shape width in screen-pixels at which the label starts to fade-in\n  // @param {number} rangeEnd   - shape width in screen-pixels at which the label is fully opaque.\n  function FadeOutStyleRule() {var _this11;var rangeStart = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 10;var rangeEnd = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 14;_classCallCheck(this, FadeOutStyleRule);\n    _this11 = _super11.call(this);\n    _this11.rangeStart = rangeStart;\n    _this11.rangeEnd = rangeEnd;return _this11;\n  }_createClass(FadeOutStyleRule, [{ key: \"apply\", value: function apply(\n\n    label, shape, layer) {\n\n      // compute opacity from shape screen-width\n      var width = getShapeWidth(shape, layer);\n      var t = (width - this.rangeStart) / (this.rangeEnd - this.rangeStart);\n      var opacity = THREE.Math.clamp(t, 0, 1);\n\n      label.container.style.opacity = opacity;\n    } }]);return FadeOutStyleRule;}(LabelStyleRule);\n;\n\n// A ShapeLabelRule maintains a set of labels that is automatically synced with the shapes in a layer.\n// It implements the CanvasGizmoBase to update the set of maintained labels.\nexport var ShapeLabelRule = /*#__PURE__*/function () {\n\n  // @param {EditLayer}               layer            - Labels are shown (and synchronized) with the content of this layer.\n  // @param {function(Shape)=>string} shapeToLabelText - A mapping that defines which text to display for a shape. If null, no label is created.\n  // @param {LabelFilter}             [filter]         - Defines which labels to show. See DefaultLabelFilter for default behavior.\n  // @param {LabelStyleRule}          [styleRule]      - Defines how label style is modified dynamically. (By default, we fade-out based on label size)\n  function ShapeLabelRule(layer, shapeToLabelText) {var labelFilter = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new DefaultLabelFilter();var styleRule = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : new FadeOutStyleRule();_classCallCheck(this, ShapeLabelRule);\n    this.layer = layer;\n    this.shapeToLabelText = shapeToLabelText;\n\n    // All labels that we created.\n    this.labels = {}; // {shapeId: ShapeLabel}\n\n    this.layer.addCanvasGizmo(this);\n    this.visible = true;\n    this.layer.update();\n\n    this.filter = labelFilter;\n    this.styleRule = styleRule;\n  }\n\n  // Replace the rule to define label texts.\n  //   @param {function(Shape)=>string} shapeToLabelText - A mapping that defines which text to display for a shape. If null, no label is created.\n  _createClass(ShapeLabelRule, [{ key: \"setTextRule\", value: function setTextRule(shapeToLabelText) {\n      this.shapeToLabelText = shapeToLabelText;\n      this.update();\n    } }, { key: \"setVisible\", value: function setVisible(\n\n    visible) {\n      if (visible === this.visible) {\n        return;\n      }\n\n      if (visible) {\n        // Note: It's essential that we add 'this' first and all maintained labels behind. In this way, this gizmo is updated first to\n        //       configure all labels - followed by the update calls for all active labels in use.\n        this.layer.addCanvasGizmo(this);\n        this.update();\n      } else {\n        this.clearLabels();\n        this.layer.removeCanvasGizmo(this);\n      }\n      this.visible = visible;\n    } }, { key: \"dtor\", value: function dtor()\n\n    {\n      // Make sure that we don't leave any of our labels in the layer\n      this.setVisible(false);\n    } }, { key: \"removeLabelFromShape\", value: function removeLabelFromShape(\n\n    shape) {\n      if (this.labels[shape.id]) {\n        this.clearLabel(this.labels[shape.id]);\n        delete this.labels[shape.id];\n      }\n    } }, { key: \"clearLabel\", value: function clearLabel(\n\n    label) {\n      label.setShape(null);\n      label.setVisible(false);\n    }\n\n    // Hide + release all current labels, so that we can re-acquire them based on latest Layer state.\n  }, { key: \"clearLabels\", value: function clearLabels() {var _this12 = this;\n      Object.values(this.labels).forEach(function (label) {\n        _this12.clearLabel(label);\n      });\n\n      this.labels = {};\n    }\n\n    // Create new label or get it from cache\n  }, { key: \"acquireLabel\", value: function acquireLabel(shape) {\n      var label = this.labels[shape.id];\n\n      if (label) {\n        return label;\n      }\n\n      label = new ShapeLabel(null, this.layer);\n      label.setShape(shape);\n\n      this.labels[shape.id] = label;\n\n      return label;\n    } }, { key: \"update\", value: function update()\n\n    {var _this13 = this;\n      var shapes = this.layer.shapes;\n      for (var i = 0; i < shapes.length; i++) {\n\n        var shape = shapes[i];\n\n        // Get label text\n        var text = this.shapeToLabelText(shape);\n\n        // Check if we want to display a label for this shape\n        if (this.filter && !this.filter.accepts(shape, text, this.layer)) {\n          this.removeLabelFromShape(shape);\n          continue;\n        }\n\n        // Configure label\n        var label = this.acquireLabel(shape);\n        label.setText(text);\n        label.setVisible(true);\n\n        // Apply optional custom style rule\n        this.styleRule && this.styleRule.apply(label, shape, this.layer);\n      }\n\n      // Clear labels that their shapes were removed.\n      // Needed when autoUpdate is disabled.\n      Object.values(this.labels).forEach(function (label) {\n        // Shape no longer exists\n        if (shapes.indexOf(label.shape) === -1) {\n          _this13.removeLabelFromShape(label.shape);\n        }\n      });\n    } }]);return ShapeLabelRule;}();\n\n\n// A ShapeToolTip is a label that shows up when hovering a shape.\n// By default, it appears a few pixels above the top-right corner of a shape's bbox.\nexport var ShapeToolTip = /*#__PURE__*/function (_CanvasGizmoBase2) {_inherits(ShapeToolTip, _CanvasGizmoBase2);var _super12 = _createSuper(ShapeToolTip);\n\n  // @param {EditLayer}               layer - Tooltip will appear for all shapes in the given layer.\n  // @param {function(shape)=>string} getText - Function to define the text for a given shape\n  function ShapeToolTip(layer) {var _this14;var getText = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;_classCallCheck(this, ShapeToolTip);\n    _this14 = _super12.call(this);\n\n    _this14.layer = layer;\n    _this14.textCb = getText;\n    _this14.viewer = _this14.layer.viewer;\n\n    // track latest mouse position in layer coords (init on first mouse move)\n    _this14.mousePos = null;\n\n    // distance between tooltip and shape bbox\n    _this14.distanceToBox = 5; // in pixels\n\n    // Create tooltip div\n    _this14.container = _this14.getDocument().createElement('div');\n    _this14.container.classList.add('adsk-control-tooltip');\n\n    // Add div to viewer canvas container and layer\n    _this14.viewer.canvasWrap.appendChild(_this14.container);\n\n    // Update if layer changed\n    _this14.layer.addCanvasGizmo(_assertThisInitialized(_this14));\n\n    // Update if mouse moved\n    _this14.onMouseMoved = _this14.onMouseMoved.bind(_assertThisInitialized(_this14));\n    _this14.viewer.canvasWrap.addEventListener('mousemove', _this14.onMouseMoved);\n\n    _this14.layer.updateCanvasGizmos();return _this14;\n  }_createClass(ShapeToolTip, [{ key: \"dtor\", value: function dtor()\n\n    {\n      this.layer.removeCanvasGizmo();\n      this.viewer.canvasWrap.removeEventListener('mousemove', this.onMouseMoved);\n      this.viewer.canvasWrap.removeChild(this.container);\n    }\n\n    // Set callback that defines which text to display for each shape. Returning '' or null will hide the tooltip.\n    // @param {function(shape)=>string} getText - Function to define the text for a given shape\n  }, { key: \"setTextCallback\", value: function setTextCallback(getText) {\n      this.textCb = getText;\n      this.update();\n    } }, { key: \"onMouseMoved\", value: function onMouseMoved(\n\n    event) {\n\n      // Add canvas coords to event\n      this.viewer.toolController.__clientToCanvasCoords(event);\n\n      // Track mouse position\n      this.mousePos = this.layer.canvasToLayer(event.canvasX, event.canvasY);\n\n      this.update();\n    } }, { key: \"update\", value: function update()\n\n    {\n\n      // If a textCb is set, check shape under mouse\n      var shape = this.mousePos && this.textCb && this.layer.hitTest(this.mousePos.x, this.mousePos.y);\n\n      // Choose label text\n      var text = shape && this.textCb(shape);\n\n      // Apply text\n      this.container.textContent = text || '';\n\n      // Stop here if nothing to display\n      if (!text) {\n        this.container.style.visibility = 'hidden';\n        return;\n      }\n\n      // Show label\n      this.container.style.visibility = 'visible';\n\n      // Get top-right corner of bbox\n      shape.updateBBox(); // Make sure bbox is up-to-date\n      var corner = shape.bbox.max;\n\n      // Get anchor in canvas coords\n      var anchor = this.layer.layerToCanvas(corner.x, corner.y);\n\n      // Add some pixels y-offset\n      anchor.y -= this.distanceToBox;\n\n      // get canvas size\n      var width = this.viewer.canvas.width;\n      var height = this.viewer.canvas.height;\n\n      // Update tooltip position\n      this.container.style.right = width - anchor.x + 'px';\n      this.container.style.bottom = height - anchor.y + 'px';\n\n      this.container.style.left = 'auto';\n      this.container.style.top = 'auto';\n    } }]);return ShapeToolTip;}(CanvasGizmoBase);\n\n\n// Purpose:\n// There is no efficient and simple way to ask a div whether it is under mouse or not.\n// The most reliable way is document.elementFromPoint(), but it is rather expensive.\n// Therefore, we don't want to do it for each and every gizmo. Instead, GizmoManager tracks\n// which object is under mouse and is generally used to check which gizmo is at mouse position.\nexport var GizmoManager = /*#__PURE__*/function () {\n\n  function GizmoManager() {_classCallCheck(this, GizmoManager);\n    // div element at mouse position\n    this.elemUnderMouse = null;\n  }\n\n  // Must be triggered on mouse events.\n  // @param {MouseEvent}\n  _createClass(GizmoManager, [{ key: \"update\", value: function update(e) {\n      this.elemUnderMouse = document.elementFromPoint(e.clientX, e.clientY);\n    }\n\n    // @param {CanvasGizmo}\n  }, { key: \"isUnderMouse\", value: function isUnderMouse(gizmo) {\n      return gizmo.container && gizmo.container === this.elemUnderMouse;\n    }\n\n    // Returns the index of the gizmo that matches with the element under mouse.\n    // Result is -1 if none of the gizmos matches.\n    //  @param {CanvasGizmo[]} gizmo\n  }, { key: \"getGizmoIndex\", value: function getGizmoIndex(gizmos) {var _this15 = this;\n      return gizmos.findIndex(function (g) {return _this15.isUnderMouse(g);});\n    } }]);return GizmoManager;}();\n\n\n// Display dashed lines to connect start/end of arc segments. Used by PolygonEditTool.\n// It updates itself automatically whenever the shape changed.\nexport var ArcEdgeGizmo = /*#__PURE__*/function () {\n  function ArcEdgeGizmo(layer, gizmoLayer) {_classCallCheck(this, ArcEdgeGizmo);\n\n    this.layer = layer;\n    this.gizmoLayer = gizmoLayer;\n\n    // One Line shape per arc segment in the host shape\n    this.shapes = [];\n\n    this.visibility = false;\n    this.setVisible(true);\n\n    // Optional: Display one edge in another color\n    this.highlightColor = undefined;\n    this.highlightIndex = -1; // must be a valid edge index in this.poly\n    this.highlightLoopIndex = -1; // must be a valid loop index in this.poly\n  }_createClass(ArcEdgeGizmo, [{ key: \"dtor\", value: function dtor()\n\n    {\n      // Just make sure it is invisible, so that shapes are cleared and\n      // gizmo is removed from GizmoLayer.\n      this.setVisible(false);\n    }\n\n    // Set the shape for which we display lines\n  }, { key: \"setPoly\", value: function setPoly(poly) {\n      if (poly !== this.poly) {\n        this.poly = poly;\n        this.clearEdgeHighlighting();\n        this.update();\n      }\n    } }, { key: \"setVisible\", value: function setVisible(\n\n    visible) {\n\n      // Do nothing if there's no change\n      if (this.visible === visible) {\n        return;\n      }\n      this.visible = visible;\n\n      // add/remove from layer\n      if (visible) {\n        this.layer.addCanvasGizmo(this);\n      } else {\n        this.layer.removeCanvasGizmo(this);\n      }\n      this.update();\n    } }, { key: \"clearShapes\", value: function clearShapes()\n\n    {var _this16 = this;\n      this.shapes.forEach(function (s) {return _this16.gizmoLayer.removeShape(s);});\n      this.shapes = [];\n    } }, { key: \"edgeShapeName\", value: function edgeShapeName(\n\n    index, loopIndex) {\n      return 'ArcEdgeGizmo_' + loopIndex + '_' + index;\n    }\n\n    // Create a line shape that connects start/end vertex of segment i in poly.\n  }, { key: \"_addEdge\", value: function _addEdge(index, loopIndex) {\n\n      // get edge\n      var a = new THREE.Vector2();\n      var b = new THREE.Vector2();\n      this.poly.getEdge(index, a, b, loopIndex);\n\n      // Create a line from it\n      var line = new Polyline([a, b]);\n      line.name = this.edgeShapeName(index, loopIndex);\n\n      // Configure line style\n      line.style.lineStyle = 11; // short dashes\n      line.style.lineWidth = this.poly.style.lineWidth / 2.0;\n      line.style.lineAlpha = this.poly.style.lineAlha / 2.0;\n\n      // Apply optional edge highlighting color\n      if (index == this.highlightIndex && this.highlightColor) {\n        line.style.lineColor = this.highlightColor;\n      }\n\n      this.gizmoLayer.addShape(line);\n      this.shapes.push(line);\n    } }, { key: \"clearEdgeHighlighting\", value: function clearEdgeHighlighting()\n\n    {\n\n      if (this.highlightIndex === -1) {\n        return;\n      }\n\n      this.highlightColor = null;\n      this.highlightIndex = -1;\n      this.highlight;\n      this.update();\n    }\n\n    // Assign different\n  }, { key: \"setEdgeHighlighted\", value: function setEdgeHighlighted(index, loopIndex, color) {\n\n      // Only do work if needed\n      if (index === this.highlightIndex && color === this.highlightColor) {\n        return;\n      }\n\n      this.highlightColor = color;\n      this.highlightIndex = index;\n      this.highlightLoopIndex = loopIndex;\n      this.update();\n    }\n\n    // Updates the edges for the given Path shape\n  }, { key: \"update\", value: function update() {\n\n      this.clearShapes();\n\n      // Stop if there are no arcs\n      if (!this.visible || !this.poly || !this.poly.isPath()) {\n        return;\n      }\n\n      // For each loop...\n      for (var l = 0; l < this.poly.loopCount; l++) {\n\n        // For each edge...\n        var edgeCount = this.poly.getEdgeCount(l);\n        for (var i = 0; i < edgeCount; i++) {\n\n          // Add line if it is an arc\n          var isArc = this.poly.isArc(i, l);\n          if (isArc) {\n            this._addEdge(i, l);\n          }\n        }\n      }\n    } }]);return ArcEdgeGizmo;}();","function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError(\"Cannot call a class as a function\");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}var Clipboard = /*#__PURE__*/function () {\n  function Clipboard() {_classCallCheck(this, Clipboard);\n    Autodesk.Viewing.EventDispatcher.prototype.apply(this);\n\n    this.shapes = [];\n  }\n\n  /**\n     * Clear the contents of the clipboard\n     */_createClass(Clipboard, [{ key: \"clear\", value: function clear()\n    {\n      this.shapes = [];\n      this._dispatchContentChangedEvent(this.shapes);\n    }\n\n    /**\n       * Check if the clipboard contains shapes\n       *\n       * @returns {boolean} True if there are shapes on the clipboard, false otherwise\n       */ }, { key: \"hasShapes\", value: function hasShapes()\n    {\n      return this.shapes.length !== 0;\n    }\n\n    /**\n       * Post shapes to the clipboard.\n       *\n       * The shapes will be cloned and then posted to the clipboard.\n       *\n       * @param {Shape[]} shapes The shapes to post to the clipboard\n       */ }, { key: \"postShapes\", value: function postShapes(\n    shapes) {\n      this.shapes = shapes.map(function (s) {return s.clone();});\n      this._dispatchContentChangedEvent(shapes);\n    }\n\n    /**\n       * Clone the shapes on to the clipboard.\n       *\n       * @returns {Shape[]} Clones of shapes on the clipboard. May be empty if no shapes are on the clipboard.\n       */ }, { key: \"cloneShapes\", value: function cloneShapes()\n    {\n      return this.shapes.map(function (s) {return s.clone();});\n    } }, { key: \"_dispatchContentChangedEvent\", value: function _dispatchContentChangedEvent(\n\n    shapes) {\n      this.dispatchEvent({\n        type: Clipboard.CONTENT_CHANGED,\n        shapes: shapes });\n\n    } }]);return Clipboard;}();export { Clipboard as default };\n\n\nClipboard.CONTENT_CHANGED = \"CONTENT_CHANGED\";","\nvar content = require(\"!!../../node_modules/css-loader/index.js!../../node_modules/sass-loader/dist/cjs.js!./Edit2D.css\");\n\nif(typeof content === 'string') content = [[module.id, content, '']];\n\nvar transform;\nvar insertInto;\n\n\n\nvar options = {\"hmr\":true}\n\noptions.transform = transform\noptions.insertInto = undefined;\n\nvar update = require(\"!../../node_modules/style-loader/lib/addStyles.js\")(content, options);\n\nif(content.locals) module.exports = content.locals;\n\nif(module.hot) {\n\tmodule.hot.accept(\"!!../../node_modules/css-loader/index.js!../../node_modules/sass-loader/dist/cjs.js!./Edit2D.css\", function() {\n\t\tvar newContent = require(\"!!../../node_modules/css-loader/index.js!../../node_modules/sass-loader/dist/cjs.js!./Edit2D.css\");\n\n\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\n\t\tvar locals = (function(a, b) {\n\t\t\tvar key, idx = 0;\n\n\t\t\tfor(key in a) {\n\t\t\t\tif(!b || a[key] !== b[key]) return false;\n\t\t\t\tidx++;\n\t\t\t}\n\n\t\t\tfor(key in b) idx--;\n\n\t\t\treturn idx === 0;\n\t\t}(content.locals, newContent.locals));\n\n\t\tif(!locals) throw new Error('Aborting CSS HMR due to changed css-modules locals.');\n\n\t\tupdate(newContent);\n\t});\n\n\tmodule.hot.dispose(function() { update(); });\n}","function _typeof(obj) {\"@babel/helpers - typeof\";if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;};}return _typeof(obj);}function _createForOfIteratorHelper(o, allowArrayLike) {var it;if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {if (it) o = it;var i = 0;var F = function F() {};return { s: F, n: function n() {if (i >= o.length) return { done: true };return { done: false, value: o[i++] };}, e: function e(_e) {throw _e;}, f: F };}throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");}var normalCompletion = true,didErr = false,err;return { s: function s() {it = o[Symbol.iterator]();}, n: function n() {var step = it.next();normalCompletion = step.done;return step;}, e: function e(_e2) {didErr = true;err = _e2;}, f: function f() {try {if (!normalCompletion && it.return != null) it.return();} finally {if (didErr) throw err;}} };}function _unsupportedIterableToArray(o, minLen) {if (!o) return;if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);var n = Object.prototype.toString.call(o).slice(8, -1);if (n === \"Object\" && o.constructor) n = o.constructor.name;if (n === \"Map\" || n === \"Set\") return Array.from(o);if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);}function _arrayLikeToArray(arr, len) {if (len == null || len > arr.length) len = arr.length;for (var i = 0, arr2 = new Array(len); i < len; i++) {arr2[i] = arr[i];}return arr2;}function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {try {var info = gen[key](arg);var value = info.value;} catch (error) {reject(error);return;}if (info.done) {resolve(value);} else {Promise.resolve(value).then(_next, _throw);}}function _asyncToGenerator(fn) {return function () {var self = this,args = arguments;return new Promise(function (resolve, reject) {var gen = fn.apply(self, args);function _next(value) {asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);}function _throw(err) {asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);}_next(undefined);});};}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}function _inherits(subClass, superClass) {if (typeof superClass !== \"function\" && superClass !== null) {throw new TypeError(\"Super expression must either be null or a function\");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}function _createSuper(Derived) {var hasNativeReflectConstruct = _isNativeReflectConstruct();return function _createSuperInternal() {var Super = _getPrototypeOf(Derived),result;if (hasNativeReflectConstruct) {var NewTarget = _getPrototypeOf(this).constructor;result = Reflect.construct(Super, arguments, NewTarget);} else {result = Super.apply(this, arguments);}return _possibleConstructorReturn(this, result);};}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");}return self;}function _isNativeReflectConstruct() {if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;if (Reflect.construct.sham) return false;if (typeof Proxy === \"function\") return true;try {Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));return true;} catch (e) {return false;}}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError(\"Cannot call a class as a function\");}}import EditLayer from './EditLayer.js';\nimport Clipboard from './Clipboard.js';\nimport { Shape, Style, Polygon, Polyline, PolyBase, Path, PolylinePath, PolygonPath, Circle, ShapeWrapper, EllipseArcParams, LoopType, EdgeType } from './EditShapes.js';\nimport Arrow from './Arrow.js';\nimport Selection from './Selection.js';\nimport { Math2D } from './Math2D.js';\nimport { Svg } from './Svg.js';\nimport { Actions } from './Actions.js';\nimport { Trackings } from './Trackings.js';\nimport UndoStack from './UndoStack.js';\nimport Edit2DSnapper from './Edit2DSnapper.js';\nimport Edit2DContextMenu from './Edit2DContextMenu.js';\nimport { UnitHandler, DefaultUnitHandler, SimpleUnitHandler } from './UnitHandler.js';\nimport { CanvasGizmoBase, CanvasGizmo, EdgeLabel, ShapeLabel, AreaLabel, AlignX, AlignY, VertexGizmo, ShapeLabelRule, ShapeToolTip, FadeOutStyleRule, TextLabel } from './CanvasGizmo.js';\nimport TangentGizmo from './TangentGizmo.js';\nimport SegmentTree from './SegmentTree.js';\nimport ScreenOverlay from './ScreenOverlay.js';\nimport AngleGizmo from './AngleGizmo.js';\nimport AngleGizmo3d from './AngleGizmo3d.js';\n\nimport MoveTool from './tools/MoveTool.js';\nimport PolygonTool from './tools/PolygonTool.js';\nimport PolygonEditTool from './tools/PolygonEditTool.js';\nimport InsertSymbolTool from './tools/InsertSymbolTool.js';\nimport RectangleTool from './tools/RectangleTool.js';\nimport UndoTool from './tools/UndoTool.js';\nimport CopyTool from './tools/CopyTool.js';\nimport LineTool from './tools/LineTool.js';\nimport VertexMoveTool from \"./tools/VertexMoveTool.js\";\nimport EdgeMoveTool from \"./tools/EdgeMoveTool.js\";\nimport { MeasureTransform, DefaultMeasureTransform } from './MeasureTransform.js';\n\nimport { SolidDefConvert } from './SolidDefConvert.js';\nimport { BooleanOps } from './BooleanOps.js';\nimport { locales } from './locales';\n\nimport './Edit2D.css'; // IMPORTANT!!\n\nvar myExtensionName = 'Autodesk.Edit2D';\nvar namespace = AutodeskNamespace('Autodesk.Edit2D');\nvar av = Autodesk.Viewing;\n\nvar OverlayName = 'Edit2D';var\n\nToolSet =\nfunction ToolSet(name, autoReactivate) {_classCallCheck(this, ToolSet);\n  this.name = name;\n  this.autoReactivate = autoReactivate;\n  this.context = null;\n  this.tools = {};\n};\n\n\n/** \n    * Edit2D extension provides API for implementing 2D vector editing. \n    * Loading the extension does not add UI or changes behavior in the viewer. Its purpose is only\n    * to provide a basis for other extensions and client applications.\n    * \n    * The extension id is: `Autodesk.Edit2D`\n    * \n    * @example\n    *   viewer.loadExtension('Autodesk.Edit2D')\n    *\n    * @memberof Autodesk.Viewing.Extensions\n    * @see {@link Autodesk.Viewing.Extension} for common inherited methods.\n    * @alias Autodesk.Viewing.Extensions.Edit2DExtension\n    * @class\n    */var\nEdit2DExtension = /*#__PURE__*/function (_av$Extension) {_inherits(Edit2DExtension, _av$Extension);var _super = _createSuper(Edit2DExtension);\n  function Edit2DExtension(viewer, options) {var _this;_classCallCheck(this, Edit2DExtension);\n    _this = _super.call(this, viewer, options);\n\n    _this.extendLocalization(locales);\n\n    _this.undoStack = new UndoStack();\n\n    // A map containing all registered Edit 3D tools (value as ToolSet) for a specific tool set name (key)\n    _this._registeredTools = new Map();\n    _this._boundOnModelAdded = _this._onModelAdded.bind(_assertThisInitialized(_this));\n    _this._boundOnModelRemoved = _this._onModelRemoved.bind(_assertThisInitialized(_this));\n    _this._boundOnSelectionChanged = _this._onSelectionChanged.bind(_assertThisInitialized(_this));return _this;\n  }_createClass(Edit2DExtension, [{ key: \"load\", value: function () {var _load = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {return regeneratorRuntime.wrap(function _callee$(_context) {while (1) {switch (_context.prev = _context.next) {case 0:\n\n\n\n                // The overlay \"Edit2D\" contains subscenes for each edit layer.\n                this.viewer.impl.createOverlayScene(OverlayName);\n\n                // We require Snapping and Autodesk.CompGeom (already a dependency of Autodesk.Snapping)\n                _context.next = 3;return this.viewer.loadExtension('Autodesk.Snapping');case 3:\n\n                this.viewer.addEventListener(av.MODEL_ADDED_EVENT, this._boundOnModelAdded);\n                this.viewer.addEventListener(av.MODEL_REMOVED_EVENT, this._boundOnModelRemoved);\n\n                // activate UndoTool immediately, because it runs in parallel to other tools and for all tools\n                this.undoTool = new UndoTool(this.undoStack);\n                this.viewer.toolController.registerTool(this.undoTool);\n                this.viewer.toolController.activateTool(this.undoTool.getName());case 8:case \"end\":return _context.stop();}}}, _callee, this);}));function load() {return _load.apply(this, arguments);}return load;}() }, { key: \"unload\", value: function unload()\n\n\n    {var _iterator = _createForOfIteratorHelper(\n      this._registeredTools.keys()),_step;try {for (_iterator.s(); !(_step = _iterator.n()).done;) {var toolSetName = _step.value;\n          this.unregisterTools(toolSetName);\n        }} catch (err) {_iterator.e(err);} finally {_iterator.f();}\n\n      this.viewer.toolController.deregisterTool(this.undoTool);\n      this.undoTool = null;\n\n      this.viewer.removeEventListener(av.MODEL_ADDED_EVENT, this._boundOnModelAdded);\n      this.viewer.removeEventListener(av.MODEL_REMOVED_EVENT, this._boundOnModelRemoved);\n\n      return true;\n    } }, { key: \"_onModelAdded\", value: function _onModelAdded()\n\n    {var _this2 = this;\n      if (this.viewer.getVisibleModels().length !== 1) {\n        // Do the reactivation only when the first model got loaded.\n        return;\n      }var _iterator2 = _createForOfIteratorHelper(\n\n      this._registeredTools.values()),_step2;try {for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {var toolSet = _step2.value;\n          if (toolSet.autoReactivate) {var _toolSet$toolsToReact;\n            (_toolSet$toolsToReact = toolSet.toolsToReactivate) === null || _toolSet$toolsToReact === void 0 ? void 0 : _toolSet$toolsToReact.forEach(function (name) {return _this2.viewer.toolController.activateTool(name);});\n          }\n        }} catch (err) {_iterator2.e(err);} finally {_iterator2.f();}\n    } }, { key: \"_onModelRemoved\", value: function _onModelRemoved()\n\n    {\n      if (this.viewer.getVisibleModels().length !== 0) {\n        // Only deactivate tools when no model is active anymore.\n        return;\n      }\n\n      var controller = this.viewer.toolController;var _iterator3 = _createForOfIteratorHelper(\n      this._registeredTools.values()),_step3;try {for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {var toolSet = _step3.value;\n          if (toolSet.autoReactivate) {\n            // The next statement gets all possible names of all tools of a toolSet,\n            // flatten the resulting array\n            // and returns a list tool names that are active.\n            toolSet.toolsToReactivate = Object.values(toolSet.tools).\n            map(function (t) {return t.getNames();}).\n            reduce(function (res, names) {return res.concat(names);}, []) // flatten\n            .filter(function (name) {return controller.isToolActivated(name);});\n\n            toolSet.toolsToReactivate.forEach(function (name) {return controller.deactivateTool(name);});\n          }\n        }} catch (err) {_iterator3.e(err);} finally {_iterator3.f();}\n    }\n\n    // If multiple tools are registered, we have to clear the other selections as the mouse events are handled on the first one.\n  }, { key: \"_onSelectionChanged\", value: function _onSelectionChanged(_ref) {var selectionSource = _ref.target;var _iterator4 = _createForOfIteratorHelper(\n      this._registeredTools.values()),_step4;try {for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {var toolSet = _step4.value;\n          if (selectionSource !== toolSet.context.selection && !selectionSource.empty()) {\n            toolSet.context.selection.clear();\n          }\n        }} catch (err) {_iterator4.e(err);} finally {_iterator4.f();}\n    } }, { key: \"registerDefaultTools\", value: function registerDefaultTools()\n\n    {\n      this.defaultContext = this.registerTools('default');\n    }\n\n    // Get default tools. registerDefaultTools() must be called first, otherwise it returns null.\n  }, { key: \"getToolSet\",\n\n\n\n\n    // returns a given toolset, or null if none with the given name have been registered.\n    value: function getToolSet(toolSetName) {\n      return this._registeredTools.get(toolSetName);\n    } }, { key: \"registerTools\", value: function registerTools(\n\n    toolSetName) {var autoReactivate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      var toolSet = this._registeredTools.get(toolSetName);\n      if (toolSet) {\n        console.warn(\"Edit 2D tools are already registered for tool set '\".concat(toolSetName, \"'\"));\n        return toolSet.context;\n      }\n\n      toolSet = new ToolSet(toolSetName, autoReactivate);\n      this._registeredTools.set(toolSetName, toolSet);\n\n      // create context\n      var context = toolSet.context = new Edit2DContext(this, toolSetName, options);\n      context.selection.addEventListener(Selection.Events.SELECTION_CHANGED, this._boundOnSelectionChanged);\n\n      // create tools\n      toolSet.tools.polygonTool = new PolygonTool(context, PolygonTool.Mode.Polygon);\n      toolSet.tools.polylineTool = new PolygonTool(context, PolygonTool.Mode.Polyline);\n      toolSet.tools.moveTool = new MoveTool(context);\n      toolSet.tools.polygonEditTool = new PolygonEditTool(context);\n      toolSet.tools.insertSymbolTool = new InsertSymbolTool(context);\n      toolSet.tools.copyTool = new CopyTool(context);\n\n      // Enable all new shapes to be Paths, so that you can turn line segments into arc segments\n      var enableArcs = Boolean(this.options.enableArcs);\n      toolSet.tools.polygonTool.setArcsEnabled(enableArcs);\n      toolSet.tools.polylineTool.setArcsEnabled(enableArcs);\n\n      // Allow converting segments to ellipse arcs if wanted\n      if (this.options.enableEllipseArcs) {\n        toolSet.tools.polygonEditTool.enableEllipseArcs = true;\n      }\n\n      // register them\n      var controller = this.viewer.toolController;\n      controller.registerTool(toolSet.tools.polygonTool);\n      controller.registerTool(toolSet.tools.polylineTool);\n      controller.registerTool(toolSet.tools.moveTool);\n      controller.registerTool(toolSet.tools.polygonEditTool);\n      controller.registerTool(toolSet.tools.insertSymbolTool);\n      controller.registerTool(toolSet.tools.copyTool);\n\n      // activate CopyTool immediately, because they run parallel to other tools\n      controller.activateTool(toolSet.tools.copyTool.getName());\n\n      // create and register context menu\n      toolSet.contextMenu = new Edit2DContextMenu(this.viewer, toolSet);\n      toolSet.contextMenu.register();\n\n      return context;\n    } }, { key: \"unregisterDefaultTools\", value: function unregisterDefaultTools()\n\n    {\n      this.unregisterTools('default');\n      this.defaultContext = null;\n    } }, { key: \"unregisterTools\", value: function unregisterTools(\n\n    toolSetName) {\n      var toolSet = this._registeredTools.get(toolSetName);\n      if (!toolSet) {\n        return;\n      }\n\n      var controller = this.viewer.toolController;\n      controller.deregisterTool(toolSet.tools.polygonTool);\n      controller.deregisterTool(toolSet.tools.polylineTool);\n      controller.deregisterTool(toolSet.tools.moveTool);\n      controller.deregisterTool(toolSet.tools.polygonEditTool);\n      controller.deregisterTool(toolSet.tools.insertSymbolTool);\n      controller.deregisterTool(toolSet.tools.copyTool);\n\n      toolSet.context.selection.removeEventListener(Selection.Events.SELECTION_CHANGED, this._boundOnSelectionChanged);\n\n      // Unregister and delete context menu\n      toolSet.contextMenu.unregister();\n      toolSet.contextMenu = null;\n\n      this._registeredTools.delete(toolSetName);\n    } }, { key: \"createLayer\", value: function createLayer(\n\n    options) {\n\n      var model = this.viewer.model;\n      if (!model) {\n        console.error(\"A 2D model is needed to adjust viewport\");\n      }\n\n      // create new overlay scene to show\n      var layer = new EditLayer(this.viewer, options);\n\n      if (!options.useSceneAfter) {\n        // add layer scene to our overlay scene\n        this.viewer.impl.overlayScenes[OverlayName].scene.add(layer.scene);\n      }\n\n      return layer;\n    } }, { key: \"defaultTools\", get: function get() {var toolSet = this._registeredTools.get('default');return toolSet && toolSet.tools;} }]);return Edit2DExtension;}(av.Extension);\n\n\n// Common set of objects usually needed by tools\nexport { Edit2DExtension as default };var Edit2DContext = /*#__PURE__*/function () {\n\n  // @param {Edit2D} ext - Edit2d extension\n  function Edit2DContext(ext, toolSetName) {var _this3 = this;var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};_classCallCheck(this, Edit2DContext);\n    this.toolSetName = toolSetName;\n    this.ext = ext;\n    this.viewer = ext.viewer;\n    this.layer = ext.createLayer(options);\n    this.gizmoLayer = ext.createLayer(options);\n    this.undoStack = ext.undoStack;\n    this.clipboard = new Clipboard();\n    this.selection = new Selection(this.layer, this.undoStack);\n    this.snapper = new Edit2DSnapper(this.viewer, this.layer, this.gizmoLayer);\n    this.unitHandler = new DefaultUnitHandler(this.viewer);\n\n    // track mouse in Edit2D\n    this.mouseTracker = ext.options.mouseTracker;\n\n    // Update all visible labels if display units are changed\n    var onUnitChange = function onUnitChange() {\n      _this3.layer.updateCanvasGizmos();\n      _this3.gizmoLayer.updateCanvasGizmos();\n    };\n    this.viewer.addEventListener(Autodesk.Viewing.MeasureCommon.Events.DISPLAY_UNITS_CHANGED, onUnitChange);\n  }_createClass(Edit2DContext, [{ key: \"setAllGizmosEnabled\", value: function setAllGizmosEnabled(\n\n    enabled) {\n      var toolSet = this.ext.getToolSet(this.toolSetName);\n      toolSet.tools.polygonEditTool.setAllGizmosEnabled(enabled);\n    }\n\n    // Set matrix that is applied to all displayed geometry\n  }, { key: \"setMatrix\", value: function setMatrix(matrix) {\n      this.layer.setMatrix(matrix);\n      this.gizmoLayer.setMatrix(matrix);\n      this.layer.update();\n      this.gizmoLayer.update();\n    }\n\n    // Clears current layer in a way that undo-stack keeps consistent.\n    // \n    //  @param {boolean} enableUndo - If false, the undoStack is cleared.\n  }, { key: \"clearLayer\", value: function clearLayer() {var enableUndo = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n      if (enableUndo) {\n        var action = new Actions.RemoveShapes(this.layer, this.layer.shapes);\n        this.undoStack.run(action);\n      } else {\n        this.layer.clear();\n        this.undoStack.clear();\n      }\n    } }, { key: \"addShape\", value: function addShape(\n\n    shape) {\n      var action = new Actions.AddShape(this.layer, shape);\n      this.undoStack.run(action);\n    } }, { key: \"removeShape\", value: function removeShape(\n\n    shape) {\n      var action = new Actions.RemoveShape(this.layer, shape);\n      this.undoStack.run(action);\n    } }]);return Edit2DContext;}();\n\n\n// Register the extension with the extension manager.\nAutodesk.Viewing.theExtensionManager.registerExtension(myExtensionName, Edit2DExtension);\n\nnamespace.Shape = Shape;\nnamespace.Polygon = Polygon;\nnamespace.Polyline = Polyline;\nnamespace.PolyBase = PolyBase;\nnamespace.Path = Path;\nnamespace.PolygonPath = PolygonPath;\nnamespace.PolylinePath = PolylinePath;\nnamespace.Circle = Circle;\nnamespace.Style = Style;\nnamespace.EllipseArcParams = EllipseArcParams;\nnamespace.PolygonTool = PolygonTool;\nnamespace.Selection = Selection;\nnamespace.MoveTool = MoveTool;\nnamespace.PolygonEditTool = PolygonEditTool;\nnamespace.VertexMoveTool = VertexMoveTool;\nnamespace.EdgeMoveTool = EdgeMoveTool;\nnamespace.InsertSymbolTool = InsertSymbolTool;\nnamespace.Math2D = Math2D;\nnamespace.VertexGizmo = VertexGizmo;\nnamespace.RectangleTool = RectangleTool;\nnamespace.LineTool = LineTool;\nnamespace.CopyTool = CopyTool;\nnamespace.Actions = Actions;\nnamespace.UndoStack = UndoStack;\nnamespace.Clipboard = Clipboard;\nnamespace.UndoTool = UndoTool;\nnamespace.Edit2DContext = Edit2DContext;\nnamespace.CanvasGizmo = CanvasGizmo;\nnamespace.CanvasGizmoBase = CanvasGizmoBase;\nnamespace.ShapeLabel = ShapeLabel;\nnamespace.AlignX = AlignX;\nnamespace.AlignY = AlignY;\nnamespace.AreaLabel = AreaLabel;\nnamespace.EdgeLabel = EdgeLabel;\nnamespace.UnitHandler = UnitHandler;\nnamespace.SimpleUnitHandler = SimpleUnitHandler;\nnamespace.DefaultUnitHandler = DefaultUnitHandler;\nnamespace.ShapeLabelRule = ShapeLabelRule;\nnamespace.ShapeWrapper = ShapeWrapper;\nnamespace.SegmentTree = SegmentTree;\nnamespace.TangentGizmo = TangentGizmo;\nnamespace.MeasureTransform = MeasureTransform;\nnamespace.DefaultMeasureTransform = DefaultMeasureTransform;\nnamespace.ShapeToolTip = ShapeToolTip;\nnamespace.Svg = Svg;\nnamespace.SolidDefConvert = SolidDefConvert;\nnamespace.BooleanOps = BooleanOps;\nnamespace.LoopType = LoopType;\nnamespace.EdgeType = EdgeType;\nnamespace.FadeOutStyleRule = FadeOutStyleRule;\nnamespace.EditLayer = EditLayer;\nnamespace.ScreenOverlay = ScreenOverlay;\nnamespace.Arrow = Arrow;\nnamespace.AngleGizmo = AngleGizmo;\nnamespace.AngleGizmo3d = AngleGizmo3d;\nnamespace.TextLabel = TextLabel;\nnamespace.Trackings = Trackings;","function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError(\"Cannot call a class as a function\");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}import { Path, EdgeType, PolyBase, PolyIndex, LoopType } from './EditShapes.js';\nimport { Actions } from './Actions.js';\n\nvar av = Autodesk.Viewing;var\n\nEdit2DContextMenu = /*#__PURE__*/function () {\n\n  // @param {ToolSet} toolSet (see Edit2D.js)\n  function Edit2DContextMenu(viewer, toolSet) {_classCallCheck(this, Edit2DContextMenu);\n\n    this.viewer = viewer;\n    this.toolSet = toolSet;\n\n    // Define ContextMenu callback\n    this.callbackId = \"Edit2D_\".concat(toolSet.name);\n    this.callback = this.onContextMenu.bind(this);\n  }_createClass(Edit2DContextMenu, [{ key: \"register\", value: function register()\n\n    {\n      this.viewer.registerContextMenuCallback(this.callbackId, this.callback);\n    } }, { key: \"unregister\", value: function unregister()\n\n    {\n      this.viewer.unregisterContextMenuCallback(this.callbackId);\n    }\n\n    //  @param {CanvasGizmo[][]} Array of CanvasGizmo arrays per loop\n    // Returns {PolyIndex} - Returns the PolyIndex of the vertex gizmo under mouse\n  }, { key: \"findGizmoUnderMouse\", value: function findGizmoUnderMouse(gizmos, clientX, clientY) {\n      // Check element under mouse\n      var elem = document.elementFromPoint(clientX, clientY);\n\n      // Check if it matches with any vertex gizmo\n      for (var l = 0; l < gizmos.length; l++) {\n        var index = gizmos[l].findIndex(function (g) {return g.container === elem;});\n        if (index !== -1) {\n          return new PolyIndex({ vertex: index, loop: l });\n        }\n      }\n      return null;\n    }\n\n    // Note that editTool.getVertexIndex() does not work if a context menu is already open.\n    // Reason is that the evens are all consumed by an invisible full-screen-div, so that a\n    // gizmos cannot detect anymore if the mouse is on it.\n  }, { key: \"vertexGizmoUnderMouse\", value: function vertexGizmoUnderMouse(clientX, clientY) {\n      // get vertex gizmos from EditTool\n      var editTool = this.toolSet.tools.polygonEditTool;\n      var gizmos = editTool.vertexMoveTool.vertexGizmos;\n      return this.findGizmoUnderMouse(gizmos, clientX, clientY);\n    } }, { key: \"edgeGizmoUnderMouse\", value: function edgeGizmoUnderMouse(\n\n    clientX, clientY) {\n      // get vertex gizmos from EditTool\n      var editTool = this.toolSet.tools.polygonEditTool;\n      var gizmos = editTool.edgeMoveTool.edgeGizmos;\n      var polyIndex = this.findGizmoUnderMouse([gizmos], clientX, clientY);\n      return polyIndex ? polyIndex.vertex : -1;\n    }\n\n    // Define callback to modify the viewer context menu\n    //  @param {Object[]} menuItems - items to be modified\n    //  @param {Object}   status    - ObjectContextMenu.js\n  }, { key: \"onContextMenu\", value: function onContextMenu(menu, status) {var _this = this;\n\n      var editTool = this.toolSet.tools.polygonEditTool;\n      var layer = this.toolSet.context.layer;\n      var event = status.event;\n      var selection = this.toolSet.context.selection;\n      var undoStack = this.toolSet.context.undoStack;\n\n      // get mouse pos in layer coords\n      var mousePos = layer.canvasToLayer(status.canvasX, status.canvasY);\n\n      // Check if mouse is close to an edge of the current edit polygon\n      var edgePolyIndex = editTool.findEdgeUnderMouse(mousePos);\n\n      // Check shape under mouse. If we are close to a current edge of the editPoly, \n      // consider it as under mouse as well.\n      var shapeUnderMouse = edgePolyIndex ? editTool.poly : layer.hitTest(mousePos.x, mousePos.y);\n\n      // When right-clicking outside current selection, we select the shape under mouse or clear selection of there is none.\n      // This avoids ambiguities about which shape we are modifying (selected vs. under mouse)\n      var selectedShapes = selection.getSelectedShapes();\n      var mouseOnSelection = selectedShapes.includes(shapeUnderMouse);\n      if (!mouseOnSelection && editTool.active) {\n        selection.selectOnly(shapeUnderMouse);\n      }\n\n      // Multi-select operations are allowed when right-clicking on one of the selected shapes\n      var multiSelect = mouseOnSelection && selectedShapes.length > 1;\n      if (multiSelect) {\n\n        // Remove shapes\n        menu.push({\n          title: 'Remove Shapes',\n          target: function target() {\n            undoStack.run(new Actions.RemoveShapes(layer, selectedShapes));\n          } });\n\n\n        // Unify shapes\n        if (editTool.enableUnify) {\n\n          // To allow unify, all shapes must be closed and PolyBase instances\n          var canBeUnified = !selectedShapes.find(function (s) {return !s instanceof PolyBase || !s.isClosed;});\n          if (canBeUnified) {\n            menu.push({\n              title: 'Unify Shapes',\n              target: function target() {\n                // get index of the shape under mouse within selected shapes\n                var shapeIndex = selectedShapes.indexOf(shapeUnderMouse);\n                undoStack.run(new Actions.UnifyShapes(layer, selectedShapes, shapeIndex));\n              } });\n\n          }\n        }\n      }\n\n      // Check if a shape is selected for editing\n      var shapeSelected = Boolean(editTool.poly);\n      if (!shapeSelected) {\n        // If not, keep original viewer context menu\n        return;\n      }\n\n      // Check if we hit a vertex gizmo. Note that a VertexGizmo exceeds the actual shape.\n      var vertex = this.vertexGizmoUnderMouse(event.clientX, event.clientY);\n      var mouseOnVertexGizmo = Boolean(vertex);\n\n      // Check if we hit an edge gizmo.\n      var edgeGizmoIndex = this.edgeGizmoUnderMouse(event.clientX, event.clientY);\n      var mouseOnEdgeGizmo = edgeGizmoIndex !== -1;\n\n      // Check if \"insert vertex\" is possible at the current position        \n      var edgeIndex = edgePolyIndex && edgePolyIndex.vertex;\n      var newVertexPos = edgePolyIndex && editTool.getNewVertexPosition(mousePos, edgePolyIndex);\n      var mouseCloseToEdge = Boolean(newVertexPos);\n\n      // If the mouse is neither on a shape nor on a vertex gizmo, exist here.\n      // Note that the gizmos exceed the actual shape by a few pixels, so we may hit one without hitting the shape.        \n      if (!shapeUnderMouse && !mouseOnVertexGizmo && !mouseCloseToEdge) {\n        // When clicking somewhere else, leave default context menu\n        return;\n      }\n\n      // If a polygon is selected for editing, we hijack the menu completely and remove the \n      // viewer default stuff (Show all layers etc.) - assuming that the user is focusing on 2D editing.\n      menu.length = 0;\n\n      if (editTool.enableCutout) {\n        // add cutout menu item\n        var selected = editTool.poly;\n        var isClosed = selected instanceof PolyBase && selected.isClosed;\n        if (isClosed) {\n          menu.push({\n            title: 'Apply as Cutout',\n            target: function target() {\n              var action = new Actions.ApplyCutOut(layer, selected);\n              _this.toolSet.context.undoStack.run(action);\n            } });\n\n        }\n      }\n\n      // If so, add RemoveVertex item\n      if (mouseOnVertexGizmo) {\n        menu.push({\n          title: 'Remove Vertex',\n          target: function target() {\n            editTool.removePoint(vertex);\n          } });\n\n      } else if (edgePolyIndex && newVertexPos) {\n        // Add \"Insert Vertex\" menu item\n        menu.push({\n          title: 'Insert Vertex',\n          target: function target() {\n            // insert new vertex after edge starting point\n            var newVertex = new PolyIndex({ vertex: edgePolyIndex.vertex + 1, loop: edgePolyIndex.loop });\n            editTool.insertPoint(newVertex, newVertexPos);\n          } });\n\n      }\n\n      // Consider mouse as \"onEdge\" if it is hovering the edge gizmo or close to the edge itself.\n      var onEdge = mouseOnEdgeGizmo || mouseCloseToEdge;\n\n      // Check if Create/Remove arc is possible\n      var enableArc = editTool.poly instanceof Path;\n\n      // If mouse is close to an edge or on an edge gizmo, add edge operations\n      if (!mouseOnVertexGizmo && onEdge && enableArc) {\n\n        var currentType = editTool.poly.getEdgeType(edgeIndex, edgePolyIndex.loop);\n\n        // Add \"Change-To\" operations for all edge types except the current...\n\n        // Change-to-Line\n        if (currentType !== EdgeType.Line) {\n          menu.push({\n            title: 'Change to Line Segment',\n            target: function target() {\n              editTool.changeEdgeToLine(edgePolyIndex);\n            } });\n\n        }\n\n        // Change-to-Bezier\n        if (currentType !== EdgeType.Bezier) {\n          menu.push({\n            title: 'Change to Arc Segment',\n            target: function target() {\n              editTool.changeEdgeToBezier(edgePolyIndex);\n            } });\n\n        }\n\n        // Change-to-Ellipse\n        if (currentType !== EdgeType.Ellipse && editTool.enableEllipseArcs) {\n          menu.push({\n            title: 'Change to Ellipse Segment',\n            target: function target() {\n              editTool.changeEdgeToEllipse(edgePolyIndex);\n            } });\n\n        }\n      }\n\n      // Check if there are loops any loops left if we remove this one\n      if (edgePolyIndex && editTool.poly.isClosed) {\n\n        // If the loop under mouse is the (only) outer loop, don't show \"removeLoop\", because it makes more sense to just remove the shape instead.\n        var mainLoops = editTool.poly.getMainLoops();\n        var isOnlyMainLoop = mainLoops.length === 1 && mainLoops[0] === edgePolyIndex.loop;\n\n        // Check loop type\n        var type = editTool.poly.getLoopType(edgePolyIndex.loop);\n        var itemName;\n        switch (type) {\n          case LoopType.Outer:itemName = 'Remove Shape Part';break;\n          case LoopType.Inner:itemName = 'Remove Hole';break;\n          default:itemName = 'Remove Loop';}\n        ;\n\n        if (!isOnlyMainLoop) {\n          menu.push({\n            title: itemName,\n            target: function target() {\n              editTool.removeLoop(edgePolyIndex.loop);\n            } });\n\n        }\n      }\n\n      if (shapeUnderMouse) {\n        menu.push({\n          title: 'Remove Shape',\n          target: function target() {\n            undoStack.run(new Actions.RemoveShape(layer, shapeUnderMouse));\n          } });\n\n      }\n    } }]);return Edit2DContextMenu;}();export { Edit2DContextMenu as default };","function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError(\"Cannot call a class as a function\");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}\nimport AngleSnapper from './AngleSnapper.js';\nimport SegmentTree from './SegmentTree.js';\n\nvar SnapType = Autodesk.Viewing.MeasureCommon.SnapType;\n\n// Edit2DSnapper combines 3 different types of snapping:\n//  1. Snapping to sheet geometry\n//  2. Snapping to other geometry in the same layer\n//  3. Snapping to angles and alignments\n\nvar av = Autodesk.Viewing;var\n\nEdit2DSnapper = /*#__PURE__*/function () {\n\n  // @param {Viewer3D} viewer\n  // @param {Layer} layer\n  // @param {EditLayer} gizmoLayer - used to add temporary snapping indicators (e.g., dashed lines for angle snapping)\n  function Edit2DSnapper(viewer, layer, gizmoLayer) {_classCallCheck(this, Edit2DSnapper);\n\n    this.viewer = viewer;\n    this.setGlobalManager(viewer.globalManager);\n    this.layer = layer;\n    this.gizmoLayer = gizmoLayer;\n\n    // Snapper for sheet geometry and layer geometry.\n    // Note: SnapResults are always stored in LMV world-coords (!=layer coords). Otherwise, SnapperIndicator would not display correctly.\n    this.sheetSnapper = new Autodesk.Viewing.Extensions.Snapping.Snapper(viewer);\n    this.layerSnapper = new Autodesk.Viewing.Extensions.Snapping.Snapper(viewer);\n\n    // Used for snapping to angles and alignments\n    this.angleSnapper = new AngleSnapper(gizmoLayer);\n\n    // tmp box reused for snapping\n    this.snapBox = new THREE.Box2();\n\n    // make sure SnapperIndicator exists. Note that angleSnapper does not need this - only the standard LMV snapper.\n    this.sheetSnapper.activate();\n    this.layerSnapper.activate();\n\n    // update Snapper indicator on camera changes (otherwise, it grows/shrinks on camera zoom)\n    this.onCameraChangeCb = this.onCameraChange.bind(this);\n    this.viewer.addEventListener(Autodesk.Viewing.CAMERA_CHANGE_EVENT, this.onCameraChangeCb);\n\n    // If there is a model already, compute SegmentTree right now\n    this.initSegmentTrees();\n\n    // Reused tmp vector\n    this.tmpVec = new THREE.Vector3();\n    // Raycaster for snapping\n    this.raycaster = new THREE.Raycaster();\n    this.ray = new THREE.Ray();\n\n    // If we snapped to a line segment, this member contains\n    // this line segment in layer coords. See _getGeomSnapLine().\n    this.geomSnapLine = {\n      a: new THREE.Vector3(),\n      b: new THREE.Vector3() };\n\n  }_createClass(Edit2DSnapper, [{ key: \"dtor\", value: function dtor()\n\n    {\n      this.sheetSnapper.deactivate();\n      this.layerSnapper.deactivate();\n      this.viewer.removeEventListener(Autodesk.Viewing.CAMERA_CHANGE_EVENT, this.onCameraChangeCb);\n    } }, { key: \"onCameraChange\", value: function onCameraChange()\n\n    {\n      this.updateSnapperIndicators();\n    }\n\n    // Make sure that all visible models have a SegmentTree\n  }, { key: \"initSegmentTrees\", value: function initSegmentTrees() {\n      var models = this.viewer.getVisibleModels();\n      models.forEach(function (model) {\n        // Note: We have to wait until the model finished loading. Otherwise, we may end up with a segmentTree that only\n        //       contains a subset of the segments.\n        //       In addition, make sure to skip the segment building in case it's a leaflet (e.g. a raster PDF).\n        var isLeaflet = model.isLeaflet();\n        if (model.is2d() && !isLeaflet && !model.segmentTree && model.isLoadDone()) {\n          model.segmentTree = new SegmentTree();\n          model.segmentTree.buildFromModel(model);\n        }\n      });\n    } }, { key: \"updateSnapperIndicators\", value: function updateSnapperIndicators()\n\n    {\n      // Note: All LMV snappers use (and clear) the same overlay scene. Therefore, we can call render() only on one of the Snapper\n      // indicators. Otherwise, when snapping to sheet geometry, calling layerSnapper.indicator.render() afterwards would clear \n      // the sheet-snapping indicator again.\n      if (this.sheetSnapper.isSnapped()) {\n        this.sheetSnapper.indicator.render();\n      } else {\n        // If none is snapped, it doesn't matter which indicator we call: Both will just clear the overlay.\n        this.layerSnapper.indicator.render();\n      }\n    }\n\n    // Returns snapPosition as Vector2 in layer-coords. If no snapping happens, it just maps the position directly.\n    //  @param {function(shape)} [snappingFilter] - Option filter to restrict EditLayer snapping to certain EditLayer shapes.\n  }, { key: \"getSnapPosition\", value: function getSnapPosition(canvasX, canvasY, snappingFilter) {\n\n      var p = this._getSnapPosition(canvasX, canvasY, snappingFilter);\n\n      // keep snapping gizmos up to date\n      this.angleSnapper.updateSnapLineGizmos(p);\n\n      this.updateSnapperIndicators();\n\n      return p;\n    } }, { key: \"clearSnappingGizmos\", value: function clearSnappingGizmos()\n\n    {\n      this.angleSnapper.clearSnappingGizmos();\n      this.sheetSnapper.clearSnapped();\n      this.sheetSnapper.indicator && this.sheetSnapper.indicator.clearOverlays();\n      this.layerSnapper.clearSnapped();\n      this.layerSnapper.indicator && this.layerSnapper.indicator.clearOverlays();\n    }\n\n    // Angle and Alignment snapping can only be used when explicitly activated for a given polygon.\n    // Otherwise, it has no effect.\n  }, { key: \"startAngleSnapping\", value: function startAngleSnapping(poly, draggedVertex, loopIndex) {\n      this.angleSnapper.startSnapping(poly, draggedVertex, loopIndex);\n    }\n\n    // Stop snapping to angles. (No effect if angleSnapping is already off).\n  }, { key: \"stopAngleSnapping\", value: function stopAngleSnapping() {\n      this.angleSnapper.stopSnapping();\n    }\n\n    // Like getSnapPosition, but excluding Snapping gizmo updates.\n  }, { key: \"_getSnapPosition\", value: function _getSnapPosition(canvasX, canvasY, snappingFilter) {\n\n      // Discard any outdated snapping results\n      this.angleSnapper.clearSnappingResult();\n      this.sheetSnapper.clearSnapped();\n      this.layerSnapper.clearSnapped();\n\n      var p = this.layer.canvasToLayer(canvasX, canvasY);\n\n      // Check if geom-snapping is possible (pGeom is in layer-coords)\n      var pGeom = this._getGeomSnapPosition(canvasX, canvasY, snappingFilter);\n\n      // Check if we snapped to line geometry. If so, we can still allow angle-snapping - as long as we constrain it to the geometry snapLine.\n      var geomSnapLine = this._getGeomSnapLine();\n\n      if (pGeom && !geomSnapLine) {\n        // We snapped to geometry and the snapType does not allow us to combine it with angle snapping\n        // => Just return result of geometry snapping\n        return pGeom;\n      }\n\n      // Apply angle-snapping. If we snapped to line geometry already, constrain angleSnapping to this line.\n      this.angleSnapper.snapToAngle(p, geomSnapLine);\n\n      // If there is no angle-snap, just apply the geometry snap\n      if (geomSnapLine && !this.angleSnapper.isSnapped()) {\n        return pGeom;\n      }\n\n      // By default, SnapperIndicator only considers the geometry snapping result. If we corrected the snap point and used the intersection with an\n      // angle snapLine, we have to update the SnapResult so that the snapPoint is correctly reflected by the SnapperIndicator.\n      if (geomSnapLine && this.angleSnapper.isSnapped()) {\n        var result = this._getGeomSnapResult();\n\n        // p is in 2D layer coords, but LMV Snapper snapResults are always stored in LMV world coords\n        var pWorld = new THREE.Vector3(p.x, p.y, 0.0).applyMatrix4(this.layer.layerToWorld);\n\n        result.geomType = SnapType.SNAP_INTERSECTION;\n        result.snapPoint = pWorld;\n        result.geomVertex = result.snapPoint; // Otherwise, snapResult.isEmpty() returns true\n      }\n\n      return p;\n    }\n\n    // Gets snap position from mouse event. \n    //  @returns {Vector2|null} Snapped position or null if not snapped.\n  }, { key: \"_getGeomSnapPosition\", value: function _getGeomSnapPosition(canvasX, canvasY, snappingFilter) {\n\n      var p = this.layer.canvasToLayer(canvasX, canvasY);\n\n      // Compute snap position for model geom and edit layer. \n      // Both may be undefined if there was nothing to snap to.\n      var pSheet = this._getSheetSnapPosition(canvasX, canvasY);\n      var pLayer = this._getEditLayerSnapPosition(canvasX, canvasY, snappingFilter);\n\n      // If nothing is snapped, don't snap\n      if (!pSheet && !pLayer) {\n        return null;\n      }\n\n      // If only one snap point was found, use it\n      if (!pLayer) {\n        return pSheet;\n      } else if (!pSheet) {\n        return pLayer;\n      }\n\n      // Get distances of snapPoints to accurate position\n      var distSheet = THREE.Vector2.prototype.distanceToSquared.call(pSheet, p);\n      var distLayer = THREE.Vector2.prototype.distanceToSquared.call(pLayer, p);\n\n      // Choose the closer snap. If equal, prefer edit layer snap.\n      // We discard unused snap results here, so that snapper indicator keeps correct\n      if (distSheet < distLayer) {\n        // Use sheet snap and discard the other snap result\n        this.layerSnapper.clearSnapped();\n        return pSheet;\n      } else {\n        // Use layer snap and discard the other snap result\n        this.sheetSnapper.clearSnapped();\n        return pLayer;\n      }\n    }\n\n    // Returns the SnapResult of sheetSnapper or layerSnapper if any of them is currently snapped. Returns null otherwise.\n    // Note that LMV snapResults contain values in lmv world coords.\n  }, { key: \"_getGeomSnapResult\", value: function _getGeomSnapResult() {\n\n      // Check which of the snappers has snapped\n      var sheetSnap = this.sheetSnapper.isSnapped();\n      var layerSnap = this.layerSnapper.isSnapped();\n      if (!sheetSnap && !layerSnap) {\n        return null;\n      }\n\n      // Get latest SnapResult\n      var geomSnapper = sheetSnap ? this.sheetSnapper : this.layerSnapper;\n      return geomSnapper.getSnapResult();\n    }\n\n    // If the last geometry snapping successfully snapped to a line segment, this function returns this line segment.\n    // Result is in layer-coords.\n    //  @returns {Object} - If we snapped to a line segment, we return r={a, b} where r.a and r.b are line start/end as Vector2.\n  }, { key: \"_getGeomSnapLine\", value: function _getGeomSnapLine() {\n\n      var result = this._getGeomSnapResult();\n      if (!result) {\n        return null;\n      }\n\n      // If we snapped to an edge, return this edge. Note that SnapType may be SNAP_EDGE, but may also be SNAP_VERTEX\n      var edgeGeom = result.geomEdge;\n      if (edgeGeom) {\n        var verts = result.geomEdge.vertices;\n\n        // Copy edge start/end to this.geomSnapLine\n        this.geomSnapLine.a.copy(verts[0]);\n        this.geomSnapLine.b.copy(verts[1]);\n\n        // SnapResults are in world coords. We want the geomSnapLine in layer coords.\n        this.geomSnapLine.a.applyMatrix4(this.layer.worldToLayer);\n        this.geomSnapLine.b.applyMatrix4(this.layer.worldToLayer);\n\n        return this.geomSnapLine;\n      }\n\n      // Another SnapType => No line constraint.\n      return null;\n    }\n\n    // Snaps to 2D edit layer geometry. Returns the snapped point in layer coordinates or undefined if not snapped.\n    //  @returns {Vector2} - snap position in layer coords.\n  }, { key: \"_getEditLayerSnapPosition\", value: function _getEditLayerSnapPosition(canvasX, canvasY, snappingFilter) {\n\n      // Note that snapper needs a Vector3 to work.\n      var point = this.layer.canvasToLayer(canvasX, canvasY, this.tmpVec);\n\n      // compute snap radius in layer coords\n      var radius = this.layerSnapper.detectRadiusInPixels * this.layer.getUnitsPerPixel();\n\n      // create bbox centered at the point and expanded by snapRadius in each direction\n      this.snapBox.min.set(point.x - radius, point.y - radius);\n      this.snapBox.max.set(point.x + radius, point.y + radius);\n\n      // Build dictionary of dbIds of all shapes intersecting the snapBox\n      var dbIds = {};\n      this.layer.enumShapes(this.snapBox, function (shape) {\n        // Collect dbId - unless shape is excluded from snapping\n        if (!snappingFilter || snappingFilter(shape)) {\n          dbIds[shape.id] = true;\n        }\n      });\n\n      // Collect all triangulated meshes intersecting the snapBox\n      var meshes = [];\n      this.layer.enumMeshes(this.snapBox, function (mesh) {return meshes.push(mesh);});\n\n      // Only consider edges/arcs/vertices within snapRadius\n      var filter = function filter(dbId) {return Boolean(dbIds[dbId]);};\n\n      // Run snapper on the given meshes/dbIds. Note that we run snapping in layer coords.\n      this.layerSnapper.clearSnapped();\n      this.layerSnapper.snapping2DOverlay(point, meshes, filter, radius);\n\n      // Stop here if nothing was snapped\n      if (!this.layerSnapper.isSnapped()) {\n        return undefined;\n      }\n\n      // get snapped position in layer-coords\n      var res = this.layerSnapper.getSnapResult();\n      var snapPos = Autodesk.Viewing.MeasureCommon.getSnapResultPosition(res, this.viewer);\n\n      // snapPos points to a vector inside snapResult. SnapResult will finally be converted to \n      // LMV world coords to make SnapperIndicator work. So, we copy it to a 2D vector first.\n      snapPos = new THREE.Vector2().copy(snapPos);\n\n      // SnapperIndicator requires world-coords in getSnapResult() to display correctly. \n      // Since we computed snapping in layer-coords, we finally convert it to LMV world coords.\n      res.applyMatrix4(this.layer.layerToWorld);\n\n      // Return snap position in layer coords\n      return snapPos;\n    }\n\n    // Snaps to sheet geometry. Returns the snapped point in layer coordinates or undefined if not snapped.\n  }, { key: \"_getSheetSnapPosition\", value: function _getSheetSnapPosition(canvasX, canvasY) {var _this = this;\n\n      // Make sure that SegmentTree exists for all visible 2D models\n      this.initSegmentTrees();\n\n      var viewerImpl = this.viewer.impl;\n      // Callback to enum segments of all visible models\n      var enumSegments = function enumSegments() {for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {args[_key] = arguments[_key];}\n        var models = viewerImpl.get2DModels();\n        models.forEach(function (model) {\n          // NOTE: SegmentTree may not be available yet if a model is still loading.\n          //       In this case, we exclude it from snapping until loading is done.\n          if (model.segmentTree) {var _model$segmentTree;\n            (_model$segmentTree = model.segmentTree).enumSegments.apply(_model$segmentTree, args);\n          }\n        });\n      };\n\n      var intersect2DModels = function intersect2DModels(canvasX, canvasY) {\n        var models = viewerImpl.get2DModels();\n        if (!models.length) {\n          return;\n        }\n\n        var vpVec = viewerImpl.clientToViewport(canvasX, canvasY);\n        viewerImpl.viewportToRay(vpVec, _this.ray);\n        _this.raycaster.set(_this.ray.origin, _this.ray.direction);\n\n        var results = [];\n        models.forEach(function (model) {\n          // Since we are not passing a getDbIdAtPointFor2D function, this will be a pure geometry comparison\n          // and even entities that are hidden due to cropping will be considered\n          results.push(model.rayIntersect2D(_this.raycaster));\n        });\n\n        // Get the closest hit\n        results.sort(function (a, b) {return a.distance - b.distance;});\n\n        return results[0];\n      };\n\n\n      // Note that we cannot use layer.canvasToLayer here, because snapper needs a Vector3 to work.\n      var result = intersect2DModels(canvasX, canvasY);\n      if (!result) {\n        return;\n      }\n      // We use enumSegments in order to get SNAP_INTERSECTION support, which is not provided by the default VertexBufferReader enumeration.\n      this.sheetSnapper.snapping2D(result, { enumSegments: enumSegments });\n\n      // If not snapped, just return current position\n      if (!this.sheetSnapper.isSnapped()) {\n        return undefined;\n      }\n\n      // get snapped position\n      var res = this.sheetSnapper.getSnapResult();\n      var p3D = Autodesk.Viewing.MeasureCommon.getSnapResultPosition(res, this.viewer); // returns Vector3\n\n      // convert result from LMV world coords to layer coords\n      // Note that we have to copy first, because p3D is a reference into the SnapResult. \n      // The SnapResult itself must remain in world coords to keep SnapperIndicator correct.\n      p3D = this.tmpVec.copy(p3D).applyMatrix4(this.layer.worldToLayer);\n\n      // Make sure that we consistently return 2D for all snapping types. Otherwise, we produce traps when using things like distanceTo()\n      return new THREE.Vector2().copy(p3D);\n    } }]);return Edit2DSnapper;}();export { Edit2DSnapper as default };\n\n\nav.GlobalManagerMixin.call(Edit2DSnapper.prototype);","function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError(\"Cannot call a class as a function\");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}\nvar nextLayerId = 1;\n\n// Radius in pixels used for hit-tests of thin lines. Hits within this distance are always considered, even if actual lineWidth is smaller.\nvar DefaultLineHitRadius = 10;\n\nvar av = Autodesk.Viewing;\n\n// A layer manages a set of 2D shapes like polygons, polylines etc. for editing and display.\nvar EditLayer = /*#__PURE__*/function () {\n\n  // @param {Viewer3D} viewer - Viewer instance needed to create materials\n  function EditLayer(viewer) {var _this = this;var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};_classCallCheck(this, EditLayer);\n\n    av.EventDispatcher.prototype.apply(this);\n\n    this.viewer = viewer;\n    this.options = options;\n    // Contains the triangulated geometry ready for rendering.\n    this.group = new THREE.Group();\n    if (options.useSceneAfter) {\n      this.viewer.sceneAfter.add(this.group);\n    } else {\n      this.scene = new THREE.Scene();\n      this.scene.add(this.group);\n    }\n\n    // @param {Shape[]}\n    this.shapes = [];\n\n    // @param {CanvasGizmoBase[]}\n    this.canvasGizmos = [];\n\n    this.id = nextLayerId++;\n\n    // We don't use font rendering so far\n    var fontEngine = null;\n\n    // Always use client coords for drawing\n    var toPageUnits = 1.0;\n\n    // LMVCanvasContext doesn't really need a viewport - unless it's used with Pdf.js\n    var dummyViewport = { width: 0, height: 0 };\n    this.context = new Autodesk.Extensions.CompGeom.LmvCanvasContext(dummyViewport, toPageUnits, this._processMesh.bind(this), fontEngine);\n\n    // When using LMVCanvasContext for PDF, this is not needed because PDF.js takes care that mozCurrentTransform exists.\n    // In our case, we must make LMVCanvasContext create it.\n    this.context.addContextCurrentTransform();\n\n    this.setGlobalManager(viewer.globalManager);\n\n    // By default, we always update on modification operations. But it can (and should) be temporarily disabled \n    // for batch operations. \n    this.autoUpdate = true;\n\n    this.toPageUnits = toPageUnits;\n\n    this.styleModifiers = [];\n\n    // Update gizmo positions on camera changes\n    this.onCameraChange = function () {return _this.updateCanvasGizmos();};\n    this.viewer.addEventListener(Autodesk.Viewing.CAMERA_CHANGE_EVENT, this.onCameraChange);\n    this.viewer.addEventListener(Autodesk.Viewing.VIEWER_RESIZE_EVENT, this.onCameraChange);\n\n    // Use custom tesselation accuracy for Bezier arcs. We use a bit finer values than PDF does right now.\n    this.context.setTessParams({\n      numIterations: 100,\n      minSegLenFraction: 0.01 });\n\n\n    // Optional transform between layer geometry and LMV world coords (default: identity)\n    this.layerToWorld = new THREE.Matrix4();\n    this.worldToLayer = new THREE.Matrix4();\n\n    // Reused tmp values\n    this.tmp_pWorld = new THREE.Vector3();\n    this.tmp_p0 = new THREE.Vector2();\n    this.tmp_p1 = new THREE.Vector2();\n    this.tmp_ray = new THREE.Ray();\n    this.tmp_box = new THREE.Box2();\n\n    // For editing on planes in 3D\n    this.is3d = false;\n    this.plane = new THREE.Plane();\n    this._updatePlane();\n\n    // By default, viewer cutplanes also apply to EditLayers. Optional, all cutplanes can be excluded from layer geometry.\n    this.enableCutplanes = true;\n\n    // Camera used to render overlays.\n    this.overlayCamera = undefined;\n  }_createClass(EditLayer, [{ key: \"dtor\", value: function dtor()\n\n    {\n      this._clearScene();\n      this.viewer.removeEventListener(Autodesk.Viewing.CAMERA_CHANGE_EVENT, this.onCameraChange);\n      this.viewer.removeEventListener(Autodesk.Viewing.VIEWER_RESIZE_EVENT, this.onCameraChange);\n    }\n\n    // @param {Shape} shape\n    // @returns {number} - The id of the shape. Used to access this shape later.\n  }, { key: \"addShape\", value: function addShape(shape) {\n      this.shapes.push(shape);\n\n      this.dispatchEvent({ type: EditLayer.SHAPE_ADDED, shape: shape });\n\n      this._onModified();\n    }\n\n    // @param {Shape[]} shapes\n  }, { key: \"addShapes\", value: function addShapes(shapes) {var _this2 = this;\n      shapes.forEach(function (s) {return _this2.addShape(s);});\n    }\n\n    // @param {Shape} shape\n    // @returns {bool} true if shape was found.\n  }, { key: \"hasShape\", value: function hasShape(shape) {\n      return this.shapes.indexOf(shape) !== -1;\n    }\n\n    // Removes the given shape. \n    //  @returns {bool} true if shape was found and removed, otherwise false.\n  }, { key: \"removeShape\", value: function removeShape(shape) {\n      var index = this.shapes.indexOf(shape);\n      if (index === -1) {\n        return false;\n      }\n      this.shapes.splice(index, 1);\n\n      this.dispatchEvent({ type: EditLayer.SHAPE_REMOVED, shape: shape });\n\n      this._onModified();\n      return true;\n    }\n\n    // @param {Shape[]} shapes\n  }, { key: \"removeShapes\", value: function removeShapes(shapes) {var _this3 = this;\n      shapes.forEach(function (s) {return _this3.removeShape(s);});\n    } }, { key: \"clear\", value: function clear()\n\n    {\n      this.shapes.length = 0;\n\n      this.dispatchEvent({ type: EditLayer.LAYER_CLEARED });\n\n      this._onModified();\n    }\n\n    // Must be called after modifications to update the scene.\n  }, { key: \"update\", value: function update() {\n\n      // clear scene\n      this._clearScene();\n\n      for (var i = 0; i < this.shapes.length; i++) {\n        var shape = this.shapes[i];\n\n        // Skip hidden shapes\n        if (!shape.visible) {\n          continue;\n        }\n\n        // apply override style if specified\n        var overrideStyle = this._getOverrideStyle(shape);\n\n        shape.draw(this.context, overrideStyle);\n      }\n\n      // Make sure that all shapes are processed\n      this.context.flushBuffer(0, true);\n\n      // Currently, we only draw to overlay scenes. We may generalize that if we use it for planes in 3D later.\n      // There's also the option to use sceneAfter (which is helpful if we need more control over the blending method)\n      // so in that case invalidating only the overlay is not enough for re-rendering.\n      this.viewer.impl.invalidate(this.options.useSceneAfter, false, !this.options.useSceneAfter);\n\n      // Update CanvasGizmos, e.g., to update polygon gizmo position if a polygon changed\n      this.updateCanvasGizmos();\n    } }, { key: \"updateCanvasGizmos\", value: function updateCanvasGizmos()\n\n    {\n      for (var i = 0; i < this.canvasGizmos.length; i++) {\n        this.canvasGizmos[i].update();\n      }\n    }\n\n    // @param {CanvasGizmoBase} gizmo - Must implement gizmo.update() to respond to changes.\n  }, { key: \"addCanvasGizmo\", value: function addCanvasGizmo(gizmo) {\n      this.canvasGizmos.push(gizmo);\n    }\n\n    // @param {CanvasGizmoBase} gizmo\n  }, { key: \"removeCanvasGizmo\", value: function removeCanvasGizmo(gizmo) {\n      var index = this.canvasGizmos.indexOf(gizmo);\n      if (index === -1) {\n        return false;\n      }\n      this.canvasGizmos.splice(index, 1);\n      return true;\n    } }, { key: \"getViewport\", value: function getViewport()\n\n    {\n      return this.viewport;\n    }\n\n    // Returns the topmost shape containing the point (x,y)\n    //  @param {number} hitRadius - Used for hit-test of thin line-features. Points within this radius around a line are considered as hits - even if the actual lineWidth is smaller.\n  }, { key: \"hitTest\", value: function hitTest(x, y) {var hitRadius = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : DefaultLineHitRadius;\n\n      // process shapes backwards to find topmost first\n      for (var i = this.shapes.length - 1; i >= 0; i--) {\n        var shape = this.shapes[i];\n\n        // Skip hidden shapes\n        if (!shape.visible) {\n          continue;\n        }\n\n        var radiusLC = this.getLineHitRadius(shape, hitRadius);\n\n        // Compute box centered at (x,y) with given hitRadius\n        var hitBox = this.tmp_box.makeEmpty();\n        hitBox.min.set(x - radiusLC, y - radiusLC);\n        hitBox.max.set(x + radiusLC, y + radiusLC);\n\n        // get (latest) shape bbox\n        shape.updateBBox();\n\n        // Skip if shape bounds and hitBounds don't intersect\n        if (!shape.bbox.isIntersectionBox(hitBox)) {\n          continue;\n        }\n\n        if (shape.hitTest(x, y, radiusLC)) {\n          return shape;\n        }\n      }\n    }\n\n    // Used for line-feature hit tests: \n    // We consider a point p to be \"on edge e\" if p is within a certain radius around e.\n    // This radius depends on style and a certain min-distance in pixels used for thin lines. Result is in layer-coords.\n  }, { key: \"getLineHitRadius\", value: function getLineHitRadius(shape) {var hitRadius = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DefaultLineHitRadius;\n\n      var unitsPerPixel = this.getUnitsPerPixel();\n\n      // Get line-width in layer coords\n      var lineWidth = (shape.style.isScreenSpace ? unitsPerPixel : 1) * shape.style.lineWidth;\n\n      // For thin lines, consider hits as long as they are within minPixels radius\n      return Math.max(lineWidth, hitRadius * unitsPerPixel);\n    }\n\n    // Optional: Sets a callback to override the style for either all or a subset of shapes.\n    //  @param {function(Shape, Style)} modifier - A callback that takes a shape as input and returns undefined (=no change) or a valid override style object.\n  }, { key: \"addStyleModifier\", value: function addStyleModifier(modifier) {\n      this.styleModifiers.push(modifier);\n      this._onModified();\n    } }, { key: \"removeStyleModifier\", value: function removeStyleModifier(\n\n    modifier) {\n      var index = this.styleModifiers.indexOf(modifier);\n      if (index == -1) {\n        return false;\n      }\n      this.styleModifiers.splice(index, 1);\n      this._onModified();\n      return true;\n    }\n\n    // Convert layer coordinates to canvas coords.\n    //  @param {Vector2|Vector3} [target]\n  }, { key: \"layerToCanvas\", value: function layerToCanvas(x, y) {var target = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new THREE.Vector2();\n\n      // get point in LMV world coords\n      var pWorld = this.tmp_pWorld.set(x, y, 0).applyMatrix4(this.layerToWorld);\n\n      // For now, worldCoords.xy is identical with layer coords. This will change once we extend it to planes that can be embedded into 3D.\n      var res = this.viewer.impl.worldToClient(pWorld, this.overlayCamera);\n      return target.set(res.x, res.y, 0.0); // Set z to 0 if target is Vector3. Otherwise, the param has no effect\n    }\n\n    // Note: This function currently assumes a uniform unitPerPixel ratio. This may change if we add support for projected\n    //       planes in 3D, where pixelRatio may vary across the layer and may require different values in x/y direction.\n  }, { key: \"getPixelsPerUnit\", value: function getPixelsPerUnit() {\n      var _window = this.getWindow();\n\n      // get screen projections of two points in layer-coords that have unit-distance\n      var p0 = this.layerToCanvas(0, 0, this.tmp_p0);\n      var p1 = this.layerToCanvas(1, 0, this.tmp_p1);\n      return p0.distanceTo(p1) / _window.devicePixelRatio;\n    } }, { key: \"getUnitsPerPixel\", value: function getUnitsPerPixel()\n\n    {\n      return 1.0 / this.getPixelsPerUnit();\n    }\n\n    // Convert canvas coordinates (from input events) to layer viewport coordinates\n    //  @param {Vector2|Vector3} [target]\n  }, { key: \"canvasToLayer\", value: function canvasToLayer(canvasX, canvasY)\n    {var target = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new THREE.Vector2();\n      // Compute \"ray through pixel\" in world-coords.\n      var vpVec = this.viewer.impl.clientToViewport(canvasX, canvasY);\n      var ray = this.viewer.impl.viewportToRay(vpVec, this.tmp_ray, this.overlayCamera);\n\n      // Intersect ray with plane that we edit on\n      var intersect = ray.intersectPlane(this.plane, this.tmp_pWorld);\n\n      if (!intersect) {\n        // TODO: For 3D scenarios, we must properly support the case that canvasToLayer fails.\n        return target.set(0, 0);\n      }\n\n      // Convert from world to layer coords\n      intersect.applyMatrix4(this.worldToLayer);\n\n      // Set 3rd-component to 0 for Vector3 targets. For 2D, the z param is ignored\n      return target.set(intersect.x, intersect.y, 0);\n    }\n\n    // Runs the callback for all shapes in the layer that overlap the given bbox\n    //  @param {Box2} bbox\n    //  @param {function(Shape)} cb\n  }, { key: \"enumShapes\", value: function enumShapes(bbox, cb) {\n      for (var i = 0; i < this.shapes.length; i++) {\n        var shape = this.shapes[i];\n\n        // Make sure that bbox is up-to-date\n        shape.updateBBox();\n\n        if (bbox.isIntersectionBox(shape.bbox)) {\n          cb(shape);\n        }\n      }\n    }\n\n    // Runs the callback for all triangulated 2D meshes created in the last update() call.\n  }, { key: \"enumMeshes\", value: function enumMeshes(bbox, cb) {\n      for (var i = 0; i < this.group.children.length; i++) {\n        var mesh = this.group.children[i];\n        var meshBox = mesh.geometry.boundingBox;\n\n        // Note: The worldMatrix is not used for triangulated Edit2D meshes, so it will always be identity. Otherwise,\n        //       we would need to compute a world-box using applyMatrixWorld() here.\n\n        // Note that meshes have a 3D box, but we are only interested in 2D check. Therefore,\n        // it's important to call intersectsBox on the input box and not on the mesh.\n        if (bbox.isIntersectionBox(meshBox)) {\n          cb(mesh);\n        }\n      }\n    } }, { key: \"findShapeById\", value: function findShapeById(\n\n    id) {\n      return this.shapes.find(function (s) {return s.id == id;});\n    } }, { key: \"setMatrix\", value: function setMatrix(\n\n    layerToWorld) {\n      this.layerToWorld.copy(layerToWorld);\n      this.worldToLayer.getInverse(layerToWorld);\n\n      // Update projection plane\n      this._updatePlane();\n    }\n\n    // By default, the viewer cutplanes are applied to EditLayers as well. This can be used, e.g., to crop them.\n    //  @param {bool} enabled - If false, cutplanes are ignored for all layer geometry. \n  }, { key: \"setCutPlanesEnabled\", value: function setCutPlanesEnabled() {var enabled = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n      if (enabled != this.enableCutplanes) {\n        this.enableCutplanes = enabled;\n        this.update();\n      }\n    }\n\n    // \n    // --- Internal functions ---\n    //\n\n    // process meshData produced by LmvCanvasContext\n  }, { key: \"_processMesh\", value: function _processMesh(meshData) {\n\n      // create GeometryBuffer\n      var mdata = { mesh: meshData, is2d: true, packId: \"0\", meshIndex: 0 };\n      Autodesk.Viewing.Private.BufferGeometryUtils.meshToGeometry(mdata);\n      var geom = mdata.geometry;\n\n      // create 2D material\n      // Note that it is essential not to associate the material witha model. Otherwise,\n      // the EditShapes will disappear if model layer 0 is switched off.\n      var matman = this.viewer.impl.getMaterials();\n      var matName = matman.create2DMaterial(null, meshData.material);\n      var material = matman.findMaterial(null, matName);\n\n      // Optional: Ignore cutplanes\n      if (!this.enableCutplanes) {\n        // Do not apply any cutplanes to the geometry\n        material.cutplanes = undefined;\n        material.doNotCut = true;\n      }\n\n      var mesh = new THREE.Mesh(geom, material);\n\n      // Set mesh matrix\n      mesh.matrix = this.layerToWorld;\n      mesh.matrixAutoUpdate = false; // make sure matrix is not overwritten within updateMatrixWorld() later\n\n      this.group.children.push(mesh);\n    } }, { key: \"_onModified\", value: function _onModified()\n\n    {\n      if (this.autoUpdate) {\n        this.update();\n      }\n    }\n\n    // Apply one or more style modifiers\n  }, { key: \"_getOverrideStyle\", value: function _getOverrideStyle(shape) {\n      var style = shape.style;\n      for (var i = 0; i < this.styleModifiers.length; i++) {\n        var mod = this.styleModifiers[i];\n        style = mod(shape, style) || style;\n      }\n      return style;\n    }\n\n    // Dispose all shapes generated by this layer.\n  }, { key: \"_clearScene\", value: function _clearScene() {\n\n      // Dispose any GPU resources for previous output geometry\n      // Note that we construct the scene as a flat list of meshes (see _processMesh). So, we don't need a generic traversal here.\n      var meshes = this.group.children;\n      for (var i = 0; i < meshes.length; i++) {\n        var mesh = meshes[i];\n        mesh.geometry.dispose();\n\n        // TODO: We have to take care to dispose materials here as well. However, just disposing materials here as well would produce a couple of issues:\n        //\n        //  1. MaterialManager caches materials based on properties. So, we cannot safely assume that the materials are solely used by ourselves.\n        //     => MaterialManager currently only allows models to own 2D materials. We have to generalize it to support \"ownerIDs\" so\n        //        that we can ensure that the materials are owned by this layer.\n        //  2. Recompiling shaders on each update would be a waste. So we will need some caching.\n      }\n      this.group.children.length = 0;\n    }\n\n    // Only needed for 3D scenes\n  }, { key: \"_updatePlane\", value: function _updatePlane() {\n      // The layer geometry itself is in the {z=0} plane\n      this.plane.normal.set(0, 0, 1);\n      this.plane.constant = 0.0;\n\n      // Transform plane to world-coords\n      this.plane.applyMatrix4(this.layerToWorld);\n    }\n\n    // Used for projecting / unprojecting overlay elements. \n  }, { key: \"setOverlayCamera\", value: function setOverlayCamera(camera) {\n      this.overlayCamera = camera;\n    } }]);return EditLayer;}();export { EditLayer as default };\n\n\nav.GlobalManagerMixin.call(EditLayer.prototype);\n\nEditLayer.SHAPE_ADDED = 'shapeAdded';\nEditLayer.SHAPE_REMOVED = 'shapeRemoved';\nEditLayer.LAYER_CLEARED = 'layerCleared';","function _typeof(obj) {\"@babel/helpers - typeof\";if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;};}return _typeof(obj);}function _get(target, property, receiver) {if (typeof Reflect !== \"undefined\" && Reflect.get) {_get = Reflect.get;} else {_get = function _get(target, property, receiver) {var base = _superPropBase(target, property);if (!base) return;var desc = Object.getOwnPropertyDescriptor(base, property);if (desc.get) {return desc.get.call(receiver);}return desc.value;};}return _get(target, property, receiver || target);}function _superPropBase(object, property) {while (!Object.prototype.hasOwnProperty.call(object, property)) {object = _getPrototypeOf(object);if (object === null) break;}return object;}function _inherits(subClass, superClass) {if (typeof superClass !== \"function\" && superClass !== null) {throw new TypeError(\"Super expression must either be null or a function\");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}function _createSuper(Derived) {var hasNativeReflectConstruct = _isNativeReflectConstruct();return function _createSuperInternal() {var Super = _getPrototypeOf(Derived),result;if (hasNativeReflectConstruct) {var NewTarget = _getPrototypeOf(this).constructor;result = Reflect.construct(Super, arguments, NewTarget);} else {result = Super.apply(this, arguments);}return _possibleConstructorReturn(this, result);};}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");}return self;}function _isNativeReflectConstruct() {if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;if (Reflect.construct.sham) return false;if (typeof Proxy === \"function\") return true;try {Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));return true;} catch (e) {return false;}}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError(\"Cannot call a class as a function\");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}\nimport { Math2D } from './Math2D.js';\nimport { Svg } from './Svg.js';\nimport { computeLoopContainment } from './LoopContainment.js';\n\nvar nextShapeId = 1;\n\nvar av = Autodesk.Viewing;\n\nvar toColor = function toColor(r, g, b) {\n  return \"rgb(\" + r + \",\" + g + \",\" + b + \")\";\n};\n\nvar cloneVectorArray = function cloneVectorArray(src) {\n  return src.map(function (p) {return { x: p.x, y: p.y };});\n};\n\n// Default arc tessellation params that we use for area computations. (see Bezier.js)\n// We use smaller min segment length than for drawing, because the DefaultTessParams would cause too inaccurate measurements.\n// TODO: Replace by more accurate and faster analytic computation to replace brute-force tesselation completely.\nvar AreaTessParam = {\n  numIterations: 100,\n  minSegLenFraction: 0.01 };\n\n\nvar tmpVec3 = new THREE.Vector3();\nvar tmpVec3_2 = new THREE.Vector3();\nvar tmpBox2 = new THREE.Box2();\nvar tmpVec2 = new THREE.Vector2();\n\nexport var Style = /*#__PURE__*/function () {\n\n  /**\n                                              * Creates a new Style for the Edit 2D tools.\n                                              * @param {object} [params]           - various style values to overwrite the default style.\n                                              * @param {string} [params.color]     - sets the color for the line and fill area\n                                              * @param {number} [params.alpha]     - sets the alpha value for the line and fill area\n                                              * @param {string} [params.lineColor] - sets the color for the line\n                                              * @param {number} [params.lineAlpha] - sets the alpha value for the line\n                                              * @param {number} [params.lineWidth] - sets the line width for the line.\n                                              * @param {number} [params.lineStyle] - sets the style of the line\n                                              * @param {string} [params.fillColor] - sets the color for the fill area\n                                              * @param {number} [params.fillAlpha] - sets the alpha value for the fill area\n                                              */\n  function Style() {var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};_classCallCheck(this, Style);\n    this.lineColor = params.lineColor || params.color || \"rgb(0,0,128)\";\n    this.lineAlpha = params.lineAlpha !== undefined ? params.lineAlpha : params.alpha !== undefined ? params.alpha : 1.0;\n    this.lineWidth = params.lineWidth !== undefined ? params.lineWidth : 3.0;\n\n    this.fillColor = params.fillColor || params.color || \"rgb(0,0,128)\";\n    this.fillAlpha = params.fillAlpha !== undefined ? params.fillAlpha : params.alpha !== undefined ? params.alpha : 0.2;\n\n    // lineStyle is an index into a list of dash/dot patterns defined in See LineStyleDef.js.\n    // Examples:\n    //   0:  Solid line:    ______________\n    //   10: Dashes long:   __ __ __ __ __\n    //   11: Dashes short:  _ _ _ _ _ _ _\n    //   12: Dashes longer: ___ ___ ___ ___\n    //   16: Dots:          . . . . . . .\n    //   17: Dots dense:    ..............\n    //   18: Dots sparse:   .  .  .  .  .\n    this.lineStyle = params.lineStyle || 0;\n\n    // By default, we interpret line widths in screen-space\n    this.isScreenSpace = params.isScreenSpace !== undefined ? params.isScreenSpace : true;\n    this.compositeOperation = 'source-over';\n  }\n\n  // Components r,b,g are in [0,255]\n  _createClass(Style, [{ key: \"setFillColor\", value: function setFillColor(r, g, b) {\n      this.fillColor = toColor(r, g, b);\n    } }, { key: \"setLineColor\", value: function setLineColor(\n\n    r, g, b) {\n      this.lineColor = toColor(r, g, b);\n    } }, { key: \"clone\", value: function clone()\n\n    {\n      return new Style().copy(this);\n    } }, { key: \"copy\", value: function copy(\n\n    from) {\n      this.lineColor = from.lineColor;\n      this.lineAlpha = from.lineAlpha;\n      this.lineWidth = from.lineWidth;\n      this.fillColor = from.fillColor;\n      this.fillAlpha = from.fillAlpha;\n      this.lineStyle = from.lineStyle;\n      this.isScreenSpace = from.isScreenSpace;\n      this.compositeOperation = from.compositeOperation;\n      return this;\n    } }]);return Style;}();\n\n\nStyle.toColor = toColor;\n\nvar DefaultStyle = new Style();\n\n// Add all points to given bbox.\nvar addPointsToBBox = function addPointsToBBox(points, dstBox) {\n  for (var i = 0; i < points.length; i++) {\n    dstBox.expandByPoint(points[i]);\n  }\n};\n\nexport var Shape = /*#__PURE__*/function (_av$EventDispatcher) {_inherits(Shape, _av$EventDispatcher);var _super = _createSuper(Shape);\n  function Shape() {var _this;var style = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : DefaultStyle.clone();_classCallCheck(this, Shape);\n    _this = _super.call(this);\n\n    _this.style = style;\n\n    // assign unique id\n    _this.id = nextShapeId++;\n\n    _this.bbox = new THREE.Box2();\n    _this.bboxDirty = true;\n\n    // If false, it is skipped by EditLayer traversals\n    _this.visible = true;\n\n    // whether users can move this shape by clicking and dragging.\n    _this.movable = true;\n\n    // whether users can select this shape. If false, clicks on this shape will not select it, and by consequence it\n    // won't be editable either.\n    _this.selectable = true;\n\n    // Should be set by creator by something more descriptive.\n    _this.name = _this.id.toString();return _this;\n  }\n\n  // Must be provided by derivaties\n  _createClass(Shape, [{ key: \"draw\", value: function draw() /*ctx, overrideStyle*/{} }, { key: \"hitTest\", value: function hitTest()\n    /*x, y, hitRadius*/{} // hitRadius is a distance in layer-coords used for line feature hit-tests.\n  }, { key: \"move\", value: function move()\n    /*dx, dy*/{return this;}\n\n    // Apply a transform to each point. (assuming z=0)\n    // @param {Matrix4}\n  }, { key: \"applyMatrix4\", value: function applyMatrix4(matrix) {return this;} }, { key: \"clone\", value: function clone()\n\n    {\n      return new Shape().copy(this);\n    } }, { key: \"copy\", value: function copy(\n\n    from) {\n      this.style = from.style.clone();\n      return this;\n    } }, { key: \"computeBBox\", value: function computeBBox()\n\n    {\n      console.error(\"Must be implemented by derived class.\");\n    } }, { key: \"modified\", value: function modified()\n\n    {\n      this.bboxDirty = true;\n      this.fireEvent({ type: Shape.Events.MODIFIED });\n    } }, { key: \"updateBBox\", value: function updateBBox()\n\n    {\n      if (this.bboxDirty) {\n        this.computeBBox();\n        this.bboxDirty = false;\n      }\n    }\n\n    // Return bbox while making sure that it's up-to-date.\n  }, { key: \"getBBox\", value: function getBBox() {\n      this.updateBBox();\n      return this.bbox;\n    }\n\n    // @param {string}  svg - e.g. '<path d=\"M 13,4 L 14,4\"/>'\n  }, { key: \"toSVG\",\n\n\n\n    // Convert to SVG style string, e.g., '<path d=\"M 13,4 L 14,4\"/>'\n    // See Svg.toSvg() comment for options.\n    //\n    // Note: The digits param is deprecated and only exists for legacy reasons. \n    //       Set digits via options.digits instead.\n    value: function toSVG(options, digits) {\n      return Svg.toSvg(this, options, digits);\n    }\n\n    // Converts shape into a DOM element (usually a <path>).\n    //  @param {Object} \n    //  @param {bool}   [options.exportStyle=true]\n  }, { key: \"createSvgShape\", value: function createSvgShape(options) {\n      return Svg.toSvgElement(this, options);\n    } }, { key: \"setVisible\", value: function setVisible(\n\n    visible) {\n      this.visible = visible;\n    } }], [{ key: \"fromSVG\", value: function fromSVG(svg) {return Svg.fromSvg(svg);} }]);return Shape;}(av.EventDispatcher);\n\n\nShape.Events = {\n  MODIFIED: 'modified' };\n\n\nav.GlobalManagerMixin.call(Shape.prototype);\n\nexport var LoopType = {\n  Empty: 0, // Loop is empty or does not exist\n  Inner: 1,\n  Outer: 2,\n  Overlapping: 3 // Loop is intersecting itself or other loops\n};\n\n// Common base class for Polygons and Polylines\nexport var PolyBase = /*#__PURE__*/function (_Shape) {_inherits(PolyBase, _Shape);var _super2 = _createSuper(PolyBase);\n\n  function PolyBase() {var _this2;var points = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;var style = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DefaultStyle.clone();_classCallCheck(this, PolyBase);\n    _this2 = _super2.call(this, style);\n\n    // Array of Array of points, each represented as an object {x, y}\n    // By default, we start with a single loop/chain\n    _this2._loops = points ? [points] : [];\n\n    // Set by derived classes\n    _this2.isClosed = undefined;\n\n    // Computed on-demand: Provides extra information about how loops are nested.\n    _this2._loopInfos = null;return _this2;\n  }\n\n  // For backward compatibility\n  _createClass(PolyBase, [{ key: \"allocPoints\",\n\n\n\n\n\n\n\n\n    // acquire a number of additional points in the given loop. Each has initial coords (0,0)\n    value: function allocPoints(numPoints) {var loopIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      for (var i = 0; i < numPoints; ++i) {\n        this.addPoint(0, 0, loopIndex);\n      }\n      return this;\n    } }, { key: \"isPolygon\", value: function isPolygon()\n\n    {return this.isClosed;} }, { key: \"isPolyline\", value: function isPolyline()\n    {return !this.isClosed;} }, { key: \"isPath\", value: function isPath()\n\n    {\n      return this instanceof Path;\n    } }, { key: \"addPoint\", value: function addPoint(\n\n    x, y) {var loopIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n      // get or create loop\n      var loop = this._loops[loopIndex] || (this._loops[loopIndex] = []);\n\n      // add point to loop\n      var point = { x: x, y: y };\n      loop.push(point);\n      this.modified();\n      return point;\n    } }, { key: \"getPoint\", value: function getPoint(\n\n    index) {var loopIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;var target = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new THREE.Vector2();\n\n      // Legacy fallback (deprecated): This can be removed as soon as no code\n      // is passing a target vector without a loop index\n      if (_typeof(loopIndex) === 'object') {\n        target = loopIndex;\n        loopIndex = 0;\n      }\n\n      return target.copy(this._loops[loopIndex][index]);\n    } }, { key: \"removePoint\", value: function removePoint(\n\n    index) {var loopIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      this._loops[loopIndex].splice(index, 1);\n    } }, { key: \"updatePoint\", value: function updatePoint(\n\n    index, x, y) {var loopIndex = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n      var p = this._loops[loopIndex][index];\n      p.x = x;\n      p.y = y;\n      this.modified();\n    } }, { key: \"insertPoint\", value: function insertPoint(\n\n    index, p) {var loopIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n      this._loops[loopIndex].splice(index, 0, p);\n    } }, { key: \"getVertexCount\",\n\n\n\n\n\n\n\n\n\n\n\n    // Returns 0 if a loop is empty or does not exist.\n    value: function getVertexCount() {var loopIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      // Array may not exist yet if no vertices were added to the loop yet.\n      var loop = this._loops[loopIndex];\n      return loop ? loop.length : 0;\n    }\n\n    // Reset back to a single empty loop\n  }, { key: \"clear\", value: function clear() {\n      this._loops = [];\n      this.modified();\n    }\n\n    // Enumerate all edges (a,b).\n    //  @param {function(a, b, ai, bi)} cb - For each edge, we trigger cb(a, b, ai, bi), where (a,b) are the points and (ai, bi) the indices of the edge.\n    //                                       If cb() returns true, the traversal stops.\n  }, { key: \"enumEdges\", value: function enumEdges(cb) {var loopIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\n      // get edge count\n      var edgeCount = this.getEdgeCount(loopIndex);\n\n      // check for each edge whether p is close to it.\n      for (var i = 0; i < edgeCount; i++) {\n        // get indices\n        var ai = i;\n        var bi = this.nextIndex(i, loopIndex);\n\n        // get points\n        var a = this.getPoint(ai, loopIndex);\n        var b = this.getPoint(bi, loopIndex);\n\n        // pass all to cb\n        var stop = cb(a, b, ai, bi);\n\n        // allow early out\n        if (stop) {\n          return;\n        }\n      }\n    }\n\n    // Given a polyline or polygon, it checks if the position is close to any edge of the shape.\n    // If so, it returns the index of that edge, otherwise -1.\n    // All values are in layer coords.\n  }, { key: \"findEdgeIndex\", value: function findEdgeIndex(p, precision) {var loopIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n\n      var edgeIndex = -1;\n\n      // Callback to find edge containing p\n      var findEdgeCb = function findEdgeCb(a, b, ai) {\n\n        // If edge contains p, store its edge index\n        var containsP = Math2D.isPointOnEdge(p, a, b, precision);\n        if (containsP) {\n          edgeIndex = ai;\n        }\n\n        // Stop on success\n        return containsP;\n      };\n      this.enumEdges(findEdgeCb, loopIndex);\n      return edgeIndex;\n    } }, { key: \"moveLoop\", value: function moveLoop(\n\n    dx, dy, loopIndex) {\n      var points = this._loops[loopIndex];\n      for (var i = 0; i < points.length; i++) {\n        points[i].x += dx;\n        points[i].y += dy;\n      }\n      this.modified();\n    } }, { key: \"move\", value: function move(\n\n    dx, dy) {\n      for (var l = 0; l < this.loopCount; l++) {\n        this.moveLoop(dx, dy, l);\n      }\n      return this;\n    }\n\n    // Note: Ellipse arcs only support simple transforms (translation, rotation, uniform scaling)\n    // @param {THREE.Matrix4}\n  }, { key: \"applyMatrix4\", value: function applyMatrix4(matrix) {\n\n      for (var l = 0; l < this.loopCount; l++) {\n        var points = this._loops[l];\n\n        for (var i = 0; i < points.length; i++) {\n          var p = points[i];\n\n          // set target to (x,y) * matrix\n          var transformPoint = function transformPoint(x, y, target) {\n            // convert to vec3, transform, and write back to target\n            var vec3 = tmpVec3.set(x, y, 0).applyMatrix4(matrix);\n            target.x = vec3.x;\n            target.y = vec3.y;\n            return target;\n          };\n\n          transformPoint(p.x, p.y, p);\n\n          // transform Bezier control points\n          if (this.isBezierArc(i, l)) {\n            var cp = transformPoint(p.cp1x, p.cp1y, tmpVec3);\n            p.cp1x = cp.x;\n            p.cp1y = cp.y;\n\n            cp = transformPoint(p.cp2x, p.cp2y, tmpVec3);\n            p.cp2x = cp.x;\n            p.cp2y = cp.y;\n          }\n\n          // Transform ellipse arcs\n          // Note: Currently, this only works for simple transforms (translate, rotate, uniform scale)\n          if (this.isEllipseArc(i, l)) {\n            p.ellipseArcParams.applyMatrix4(matrix);\n          }\n        }\n      }\n      this.modified();\n      return this;\n    }\n\n    // Copy a single loop from src poly and adds it to this one\n    //  @param {PolyBase} srcPoly\n    //  @param {number}   srcLoopIndex - must be a valid loopIndex of src\n    //  @param {number} [dstLoopIndex] Optional: index where to insert the new loop. By default, we use the first free loopIndex.\n  }, { key: \"addLoop\", value: function addLoop(srcPoly) {var srcLoopIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;var dstLoopIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : -1;\n      // copy loop points\n      var srcLoop = srcPoly._loops[srcLoopIndex];\n      var newLoop = cloneVectorArray(srcLoop);\n\n      // insert new loop\n      var newIndex;\n      if (dstLoopIndex === -1) {\n        // find a free loop index to store the new loop\n        newIndex = this.nextFreeLoop();\n        this._loops[newIndex] = newLoop;\n      } else {\n        // insert new loop at given index\n        newIndex = dstLoopIndex;\n        this._loops.splice(newIndex, 0, newLoop);\n      }\n      this.modified();\n\n      return newIndex;\n    } }, { key: \"copyGeometry\", value: function copyGeometry(\n\n    srcPoly) {\n      this.isClosed = srcPoly.isClosed;\n\n      // copy loops\n      this._loops = [];\n      for (var i = 0; i < srcPoly.loopCount; i++) {\n        this.addLoop(srcPoly, i);\n      }\n      return this;\n    } }, { key: \"copy\", value: function copy(\n\n    srcPoly) {\n      _get(_getPrototypeOf(PolyBase.prototype), \"copy\", this).call(this, srcPoly);\n      return this.copyGeometry(srcPoly);\n    } }, { key: \"computeBBox\", value: function computeBBox()\n\n    {\n      this.bbox.makeEmpty();\n      for (var i = 0; i < this.loopCount; i++) {\n        var loop = this._loops[i];\n        if (loop) {\n          addPointsToBBox(loop, this.bbox);\n        }\n      }\n      return this.bbox;\n    } }, { key: \"indexValid\", value: function indexValid(\n\n    index) {var loopIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      return index >= 0 && index < this.getVertexCount(loopIndex);\n    }\n\n    // Returns -1 if there is no next Index    \n  }, { key: \"nextIndex\", value: function nextIndex(index) {var loopIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      // Return -1 for invalid input\n      if (!this.indexValid(index, loopIndex)) {\n        return -1;\n      }\n\n      // Handle last vertex\n      var isLast = index === this.getVertexCount(loopIndex) - 1;\n      if (isLast) {\n        // If closed, restart. Otherwise, there is no next index.\n        return this.isClosed ? 0 : -1;\n      }\n\n      return index + 1;\n    }\n\n    // Returns -1 if there is no previous vertex index\n  }, { key: \"prevIndex\", value: function prevIndex(index) {var loopIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      // Return -1 for invalid input\n      if (!this.indexValid(index, loopIndex)) {\n        return -1;\n      }\n\n      // Handle first vertex\n      if (index === 0) {\n        // if closed, continue at end. Otherwise, there is no previous index.\n        var vertexCount = this.getVertexCount(loopIndex);\n        return this.isClosed ? vertexCount - 1 : -1;\n      }\n\n      return index - 1;\n    }\n\n    // Returns index of the edge ending at the given vertex or -1 if it does not exist.\n  }, { key: \"edgeBeforeVertex\", value: function edgeBeforeVertex(index) {var loopIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      return this.prevIndex(index, loopIndex);\n    }\n\n    // Returns index of the edge starting at the given vertex.\n    // Returns -1 if index is the end vertex of a polyline.\n  }, { key: \"edgeAfterVertex\", value: function edgeAfterVertex(index) {var loopIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      return this.edgeIndexValid(index, loopIndex) ? index : -1;\n    }\n\n    // Returns -1 if there is no previous edge.\n  }, { key: \"nextEdgeIndex\", value: function nextEdgeIndex(edgeIndex) {var loopIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      // Check edgeIndex validity\n      if (!this.edgeIndexValid(edgeIndex, loopIndex)) {\n        return -1;\n      }\n\n      // Return -1 for last polyline edge\n      if (!this.isClosed && edgeIndex === this.getEdgeCount(loopIndex) - 1) {\n        return -1;\n      }\n\n      return this.nextIndex(edgeIndex, loopIndex);\n    } }, { key: \"prevEdgeIndex\", value: function prevEdgeIndex(\n\n    edgeIndex) {var loopIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      // Check edgeindex validity\n      if (!this.edgeIndexValid(edgeIndex, loopIndex)) {\n        return -1;\n      }\n\n      // Return -1 for first polyline edge\n      if (!this.isClosed && edgeIndex === 0) {\n        return -1;\n      }\n\n      return this.prevIndex(edgeIndex, loopIndex);\n    } }, { key: \"edgeIndexValid\", value: function edgeIndexValid(\n\n    edgeIndex) {var loopIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var edgeCount = this.getEdgeCount(loopIndex);\n      return edgeIndex >= 0 && edgeIndex < edgeCount;\n    } }, { key: \"prevEdgeExists\", value: function prevEdgeExists(\n\n    edgeIndex) {var loopIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var vertexCount = this.getVertexCount(loopIndex);\n      return this.edgeIndexValid(edgeIndex, loopIndex) && vertexCount > 2 && (edgeIndex > 0 || this.isClosed);\n    } }, { key: \"nextEdgeExists\", value: function nextEdgeExists(\n\n    edgeIndex) {var loopIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var vertexCount = this.getVertexCount(loopIndex);\n      var isLastEdge = edgeIndex === vertexCount - 2;\n      return this.edgeIndexValid(edgeIndex, loopIndex) && vertexCount > 2 && (!isLastEdge || this.isClosed);\n    }\n\n    // Copy start/end of an edge into outA, outB out params (Vector2).\n    // edgeIndex must be valid.\n  }, { key: \"getEdge\", value: function getEdge(edgeIndex, outA, outB) {var loopIndex = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n      var ia = edgeIndex;\n      var ib = this.nextIndex(edgeIndex, loopIndex);\n      this.getPoint(ia, loopIndex, outA);\n      this.getPoint(ib, loopIndex, outB);\n    } }, { key: \"getEdgeDirection\", value: function getEdgeDirection(\n\n    edgeIndex) {var loopIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;var target = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new THREE.Vector2();\n      var ia = edgeIndex;\n      var ib = this.nextIndex(edgeIndex, loopIndex);\n      var loop = this._loops[loopIndex];\n      return Math2D.getEdgeDirection(loop[ia], loop[ib], target);\n    } }, { key: \"getEdgeLength\", value: function getEdgeLength(\n\n    edgeIndex) {var loopIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var ia = edgeIndex;\n      var ib = this.nextIndex(edgeIndex, loopIndex);\n      var loop = this._loops[loopIndex];\n      var a = loop[ia];\n      var b = loop[ib];\n      return Math2D.getEdgeLength(a, b);\n    } }, { key: \"getEdgeCount\", value: function getEdgeCount()\n\n    {var loopIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      var vertexCount = this.getVertexCount(loopIndex);\n      return this.isClosed ? vertexCount : vertexCount - 1;\n    }\n\n    // Return the summed edge length for Polygons and Polylines.\n    //\n    //  @param {MeasureTransform} [measureTransform] - Optional: To allow doing calculation in another coordinate space\n  }, { key: \"getLength\", value: function getLength(measureTransform) {var loopIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var a = new THREE.Vector2();\n      var b = new THREE.Vector2();\n      var sum = 0.0;\n      for (var i = 0; i < this.getEdgeCount(loopIndex); i++) {\n        this.getEdge(i, a, b, loopIndex);\n\n        // apply optional measure transform\n        if (measureTransform) {\n          measureTransform.apply(a);\n          measureTransform.apply(b);\n        }\n\n        sum += a.distanceTo(b);\n      }\n      return sum;\n    }\n\n    // Set vertices from THREE.Box2\n  }, { key: \"fromBox2\", value: function fromBox2(box) {\n      this.addPoint(box.min.x, box.min.y);\n      this.addPoint(box.max.x, box.min.y);\n      this.addPoint(box.max.x, box.max.y);\n      this.addPoint(box.min.x, box.max.y);\n      return this;\n    }\n\n    // Returns a point along an edge. Note that the edge may be an arc for Paths.\n    //  @param {number} edgeIndex   - A valid edgeIndex\n    //  @param {number} t           - in [0,1]. t=0: startPoint, t=1: endPoint\n    //  @param {number} [loopIndex]\n    //  @param {Vector2} [target]  \n  }, { key: \"getPointOnEdge\", value: function getPointOnEdge(edgeIndex, t) {var loopIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;var target = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : new THREE.Vector2();\n\n      var loop = this._loops[loopIndex];\n      var p0 = loop[edgeIndex];\n      var p1 = loop[this.nextIndex(edgeIndex, loopIndex)];\n      return target.lerpVectors(p0, p1, t);\n    }\n\n    // Checks if outer loop is counterclockwise. For polylines that doesn't form a loop, \n    // we assume an additional edge from end to start.\n    // @returns {bool}\n  }, { key: \"isCCW\", value: function isCCW() {var loopIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      return Autodesk.Extensions.CompGeom.polygonArea(this._loops[loopIndex]) > 0;\n    }\n\n    // Return 2D edge normal\n  }, { key: \"getLeftEdgeNormal\", value: function getLeftEdgeNormal(edgeIndex) {var loopIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;var target = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new THREE.Vector2();\n\n      var points = this._loops[loopIndex];\n\n      // get start/end point of the edge\n      var vi1 = edgeIndex;\n      var vi2 = (edgeIndex + 1) % points.length;\n      var v1 = points[vi1];\n      var v2 = points[vi2];\n\n      // get edge direction\n      target.subVectors(v2, v1).normalize();\n\n      // rotate by 90 degrees\n      var tmp = target.x;\n      target.x = -target.y;\n      target.y = tmp;\n\n      return target;\n    }\n\n    // Get edge normal facing outside wrt. to the loop containing the edge. If the contour is not closed, we\n    // assume an additional connection between endpoint and startpoint to defined \"outside\".\n  }, { key: \"getOuterNormal\", value: function getOuterNormal(edgeIndex) {var loopIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;var target = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new THREE.Vector2();\n      var normal = this.getLeftEdgeNormal(edgeIndex, loopIndex, target);\n      return this.isCCW(loopIndex) ? normal.multiplyScalar(-1) : normal;\n    }\n\n    // Returns the first loopIndex >=0 that doesn't contain any points yet.\n    //  @param {number}\n  }, { key: \"nextFreeLoop\", value: function nextFreeLoop() {\n      var isFree = function isFree(l) {return !l || !l.length;};\n      var index = this._loops.findIndex(isFree);\n      return index >= 0 ? index : this.loopCount;\n    }\n\n    // Seaches all loops to find a vertex for which cb(vertexIndex, loopIndex) returns true.    \n    //  @{function(vertexIndex, loopIndex)=>bool} searchFilter   \n    //  @returns {Object|null}                    A {vertexIndex, loopIndex} pair on success. Otherwise null.\n  }, { key: \"findVertex\", value: function findVertex(searchFilter) {\n      for (var l = 0; l < this.loopCount; l++) {\n        var len = this.getVertexCount(l);\n        for (var i = 0; i < len; i++) {\n          if (searchFilter(i, l)) {\n            return {\n              vertexIndex: i,\n              loopIndex: l };\n\n          }\n        }\n      }\n      return null;\n    }\n\n    // Returns true if poly does not contain any (non-empty loops)\n  }, { key: \"empty\", value: function empty() {\n      return !this._loops.some(function (loop) {return loop && loop.length > 0;});\n    } }, { key: \"modified\", value: function modified()\n\n    {\n      _get(_getPrototypeOf(PolyBase.prototype), \"modified\", this).call(this);\n\n      // Loop containment may have changed\n      this._loopInfos = null;\n    }\n\n    // Returns true if the shape has overlapping loops\n  }, { key: \"isSelfIntersecting\", value: function isSelfIntersecting() {\n\n      // Todo: Currently, we only detect overlaps between different loops. We also\n      //       have to track self-intersections within a single loop.\n\n\n      // Check if we have multiple overlapping loops\n      var loopInfos = this._getLoopInfos();\n      return loopInfos && loopInfos.some(function (l) {return l.error;});\n    } }, { key: \"_getLoopInfos\", value: function _getLoopInfos()\n\n    {\n      // Loop infos are only needed for closed paths with 2 or more loops\n      if (!this.isClosed || this.loopCount < 1) {\n        return undefined;\n      }\n\n      // Reuse if already available\n      if (!this._loopInfos) {\n        this._loopInfos = computeLoopContainment(this);\n      }\n      return this._loopInfos;\n    }\n\n    // Only works for closed loops.\n  }, { key: \"getLoopType\", value: function getLoopType(loopIndex) {\n\n      if (!this.isClosed) {\n        return undefined;\n      }\n\n      if (!this.getVertexCount(loopIndex)) {\n        return LoopType.Empty;\n      }\n\n      // LoopInfo should always exist for closed non-empty loops\n      var infos = this._getLoopInfos();\n      var info = infos[loopIndex];\n\n      if (info.error) {\n        return LoopType.Overlapping;\n      }\n\n      // Even-odd-rule: Loops with even rank are outer ones.\n      return info.rank & 1 ? LoopType.Inner : LoopType.Outer;\n    }\n\n    // Get all loops (directly or indirectly) enclosed by the given one\n  }, { key: \"getChildLoops\", value: function getChildLoops(loopIndex) {\n      var infos = this._getLoopInfos();\n      var info = infos && infos[loopIndex];\n      return info ? info.containedLoops.slice() : [];\n    }\n\n    // Eliminiate all empty loops, so that loopCount matches the number of non-empty loops\n  }, { key: \"cleanupLoops\", value: function cleanupLoops() {\n      this._loops = this._loops.filter(function (l) {return l && l.length >= 0;});\n    }\n\n    // Returns all loops that are not enclosed by any other one. Only for closed shapes.\n  }, { key: \"getMainLoops\", value: function getMainLoops() {\n      var infos = this._getLoopInfos();\n      if (!infos) {\n        return [];\n      }\n\n      // Collect all rank-0 loops\n      var loops = [];\n      for (var i = 0; i < infos.length; i++) {\n        var info = infos[i];\n\n        // Skip empty or invalid loops\n        var type = this.getLoopType(i);\n        if (type !== LoopType.Outer) {\n          continue;\n        }\n\n        if (info.rank === 0) {\n          loops.push(i);\n        }\n      }\n      return loops;\n    }\n\n    // Remove loop. Remaining loop indices are shifted back by one \n  }, { key: \"removeLoop\", value: function removeLoop(loopIndex) {\n      this._loops.splice(loopIndex, 1);\n      this.modified();\n      return this;\n    }\n\n    // Remove multiple loop indices\n    // @param {number[]}Â  \n  }, { key: \"removeLoops\", value: function removeLoops(loops) {\n      this._loops = this._loops.filter(function (l, i) {return !loops.includes(i);});\n    }\n\n    // Returns true if a point contains valid (i.e. finite) numbers.\n  }, { key: \"isPointFinite\", value: function isPointFinite(vertex) {var loopIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\n      if (!this.indexValid(vertex, loopIndex)) {\n        return false;\n      }\n\n      var points = this._loops[loopIndex];\n      var p = points[vertex];\n      return isFinite(p.x) && isFinite(p.y);\n    } }, { key: \"isLoopFinite\", value: function isLoopFinite(\n\n    loopIndex) {\n      var points = this._loops[loopIndex];\n      var count = points ? points.length : 0;\n      for (var i = 0; i < count; i++) {\n        if (!this.isPointFinite(i, loopIndex)) {\n          return false;\n        }\n      }\n      return true;\n    } }, { key: \"points\", get: function get() {// Create empty loop 0 if needed\n      return this._loops[0] || (this._loops[0] = []);} }, { key: \"loopCount\", get: function get() {return this._loops.length;} }, { key: \"length\", get: function get() {console.warn('poly.length is deprecated and will be removed. Please use poly.vertexCount property instead.');return this.points.length;} // for backwards compatibility\n  }, { key: \"vertexCount\", get: function get() {return this.points.length;} }]);return PolyBase;}(Shape);\n// Helper class to address a single vertex within a loop of a PolyBase.\n// Can also be used to address edges (by indexing its start vertex).\nexport var PolyIndex = /*#__PURE__*/function () {\n  function PolyIndex(_ref) {var _ref$vertex = _ref.vertex,vertex = _ref$vertex === void 0 ? 0 : _ref$vertex,_ref$loop = _ref.loop,loop = _ref$loop === void 0 ? 0 : _ref$loop;_classCallCheck(this, PolyIndex);\n    this.vertex = vertex;\n    this.loop = loop;\n  }_createClass(PolyIndex, [{ key: \"equals\", value: function equals(\n    v) {\n      return v && this.vertex === v.vertex && this.loop === v.loop;\n    } }]);return PolyIndex;}();\n\n\nexport var Polygon = /*#__PURE__*/function (_PolyBase) {_inherits(Polygon, _PolyBase);var _super3 = _createSuper(Polygon);\n\n  function Polygon() {var _this3;var points = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];var style = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DefaultStyle.clone();_classCallCheck(this, Polygon);\n    _this3 = _super3.call(this, points, style);\n    _this3.isClosed = true;return _this3;\n  }\n\n  // Draw Polygon into LmvCanvasContext\n  _createClass(Polygon, [{ key: \"draw\", value: function draw(ctx, overrideStyle) {\n      drawPath(ctx, this, overrideStyle);\n    }\n\n    // We use even-odd rule if a polygon has multiple loops: A point is considered inside if it\n    // is enclosed by an odd number of loops.\n  }, { key: \"hitTest\", value: function hitTest(x, y) {\n      if (!this.vertexCount) {\n        return false;\n      }\n\n      // Compute number of loops that enclose (x,y)\n      var rank = 0;\n      for (var l = 0; l < this.loopCount; l++) {\n        var loop = this._loops[l];\n        if (!loop) {\n          continue;\n        }\n\n        // set current loop as points\n        var cp = new Autodesk.Extensions.CompGeom.ComplexPolygon(loop);\n\n        // create dummy contour\n        // TODO: Consider generalizing pointInCountour() to make it usable for non-indexed polygons\n        var contour = [];\n        for (var i = 0; i < loop.length; i++) {\n          contour.push(i);\n        }\n\n        if (cp.pointInContour(x, y, contour)) {\n          rank++;\n        }\n      }\n\n      // Apply even-odd-rule\n      return Boolean(rank & 1);\n    } }, { key: \"clone\", value: function clone()\n\n    {\n      return new Polygon().copy(this);\n    }\n\n    //  @param {MeasureTransform} [measureTransform] - Optional: To allow doing calculation in another coordinate space\n  }, { key: \"getArea\", value: function getArea(measureTransform) {\n\n      if (!this.isClosed) {\n        return undefined;\n      }\n\n      // If there are multiple loops, we need loopInfos to distinguish inner and outer loops\n      var loopInfos = this._getLoopInfos();\n\n      var sumArea = 0;\n      for (var loopIndex = 0; loopIndex < this.loopCount; loopIndex++) {\n\n        // Skip degenerate loops\n        if (this.points.length < 3) {\n          continue;\n        }\n\n        // determine loop rank (number of other loops containing it)\n        // Note that loopInfos are null for single loops where we don't need them.\n        var loopInfo = loopInfos ? loopInfos[loopIndex] : null;\n        var rank = loopInfo ? loopInfo.rank : 0;\n\n        // Even-odd rule: Loops with odd rank are holes and contribute negatively\n        var sign = rank & 1 ? -1 : 1;\n\n        var loopArea = 0.0;\n        this.enumEdges(function (a, b) {\n          // apply optional transform\n          measureTransform && measureTransform.apply(a);\n          measureTransform && measureTransform.apply(b);\n\n          // sum up signed areas\n          loopArea += a.x * b.y - b.x * a.y;\n        }, loopIndex);\n        sumArea += sign * Math.abs(0.5 * loopArea);\n      }\n      return sumArea;\n    } }]);return Polygon;}(PolyBase);\n\n\nexport var Polyline = /*#__PURE__*/function (_PolyBase2) {_inherits(Polyline, _PolyBase2);var _super4 = _createSuper(Polyline);\n\n  function Polyline() {var _this4;var points = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];var style = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DefaultStyle.clone();_classCallCheck(this, Polyline);\n    _this4 = _super4.call(this, points, style);\n    _this4.isClosed = false;return _this4;\n  }_createClass(Polyline, [{ key: \"makeLine\", value: function makeLine()\n\n    {var x0 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;var y0 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;var x1 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;var y1 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n      if (this.vertexCount !== 2) {\n        this.clear();\n        this.addPoint(x0, y0);\n        this.addPoint(x1, y1);\n      } else {\n        this.updatePoint(0, x0, y0);\n        this.updatePoint(1, x1, y1);\n      }\n      return this;\n    }\n\n    // Draw Polyline into LmvCanvasContext\n  }, { key: \"draw\", value: function draw(ctx, overrideStyle) {\n      drawPath(ctx, this, overrideStyle);\n    } }, { key: \"clone\", value: function clone()\n\n    {\n      return new Polyline().copy(this);\n    }\n\n    // hitRadius is in layer-coords\n  }, { key: \"hitTest\", value: function hitTest(x, y, hitRadius) {\n      var edgeIndex = this.findEdgeIndex({ x: x, y: y }, hitRadius);\n      return edgeIndex !== -1;\n    } }]);return Polyline;}(PolyBase);\n\n\nexport var EdgeType = {\n  Line: 0, // Simple line segment\n  Bezier: 1, // Cubic Bezier Arc\n  Ellipse: 2 // Ellipse Arc\n};\n\n\n// Tmp objct for Ellipse Arcs. We need delayed initialization, \n// because Autodesk.Extensions.CompGeom might not be available yet at compile time.\nvar _tmpArc = null;\nvar getTmpArc = function getTmpArc() {\n  _tmpArc = _tmpArc || new Autodesk.Extensions.CompGeom.EllipseArc();\n  return _tmpArc;\n};\n\nvar tmpVec = new THREE.Vector2();\n\n// Helper function to run moveTo/lineTo/arcTo/closePath calls for a single loop of a path on a given context object.\n//  @param {Path2d|LmvCanvasContext|Object} ctx       - Receives the callback calls, i.e. moveTo, lineTo, bezierCurveTo, closePath etc. (see Path2D)\n//  @param {Polyline|Polygon|Path}          path\n//  @param {number}                         loopIndex - must be a valid loop index in path\nvar runLoop = function runLoop(ctx, path, loopIndex) {\n\n  var points = path._loops[loopIndex];\n  if (!points || !points.length) {\n    return;\n  }\n\n  // Trying to fill paths with NaN or infinite numbers may cause hangs in clipper. So, we prevent those here.\n  if (!path.isLoopFinite(loopIndex)) {\n    console.warn(\"Skipped loop, because it contains Inf or NaN values. Shape ID: \".concat(path.id, \". LoopIndex: \").concat(loopIndex));\n    return;\n  }\n\n  ctx.moveTo(points[0].x, points[0].y);\n\n  var processSegment = function processSegment(pStart, pEnd, edgeIndex) {\n    switch (pStart.arcType) {\n      case EdgeType.Line:break;\n\n      case EdgeType.Bezier:{\n          ctx.bezierCurveTo(pStart.cp1x, pStart.cp1y, pStart.cp2x, pStart.cp2y, pEnd.x, pEnd.y);\n          return;\n        }\n\n      case EdgeType.Ellipse:{\n          var params = pStart.ellipseArcParams;\n          var arc = path.exportEllipseArc(edgeIndex, loopIndex, getTmpArc());\n\n          // ignore arcs with NaN values\n          if (!arc.isValid()) {\n            break;\n          }\n\n          if (ctx.ellipseArcTo) {\n            // Support SolidDef Path2D\n            ctx.ellipseArcTo(params.rx, params.ry, THREE.Math.degToRad(params.rotation), params.largeArcFlag, params.sweepFlag, pEnd.x, pEnd.y);\n          } else {\n            // For Autodesk.CompGeom (Path2D and LmvCanvasContext). Also compatible to CanvasContext and Path2D in HTML5.\n            ctx.ellipse(arc.cx, arc.cy, arc.rx, arc.ry, arc.rotation, arc.startAngle, arc.endAngle, arc.ccw);\n          }\n\n          return;\n        }}\n\n    ctx.lineTo(pEnd.x, pEnd.y);\n  };\n\n  for (var i = 1; i < points.length; i += 1) {\n    // The segment start point defines the type (line or arc)\n    var prev = points[i - 1];\n    var p = points[i];\n\n    processSegment(prev, p, i - 1);\n  }\n\n  if (path.isClosed) {\n    // add closing segment\n    var pLast = points[points.length - 1];\n    var pFirst = points[0];\n    processSegment(pLast, pFirst, points.length - 1);\n\n    ctx.closePath();\n  }\n};\n\n// Helper function to run moveTo/lineTo/arcTo/closePath calls on a given context object.\n//  @param {Path2d|LmvCanvasContext|Object} ctx    - Receives the callback calls, i.e. moveTo, lineTo, bezierCurveTo, closePath etc. (see Path2D)\n//  @param {Polyline|Polygon|Path}          path\nexport var runPath = function runPath(ctx, path) {\n  for (var i = 0; i < path.loopCount; i++) {\n    runLoop(ctx, path, i);\n  }\n};\n\n// Draw Path to CanvasContext. Unified implementation for Path, Polyline, and Polygon\n//  @param {LmvCanvasContext}      ctx\n//  @param {Polyline|Polygon|Path} path\n//  @param {Style}                 [overrideStyle]\nvar drawPath = function drawPath(ctx, path, overrideStyle) {\n\n  if (!path.vertexCount) {\n    return;\n  }\n\n  var style = overrideStyle || path.style;\n  var c = ctx.canvasContext;\n  ctx.dbId = path.id;\n  ctx.lineStyle = style.lineStyle;\n  ctx.isScreenSpace = style.isScreenSpace;\n\n  var currentGlobalCompositeOp = c.globalCompositeOperation;\n  if (style.compositeOperation) {\n    c.globalCompositeOperation = style.compositeOperation;\n    // Make sure any previous shapes with a different blending are flushed first\n    ctx.flushBuffer(0, true);\n  }\n\n  ctx.beginPath();\n\n  // Run moveTo/lineTo/... commands on context\n  runPath(ctx, path);\n\n  // Draw fill for closed paths\n  if (path.isClosed) {\n    c.fillStyle = style.fillColor;\n    // Creates a gradient fill style.\n    if (style.fillColor.hasOwnProperty('colorStops')) {\n      var gradientData = ctx.createGradientData(style.fillColor);\n      var fillStyle = gradientData.getFillStyle(c);\n      c.fillStyle = fillStyle;\n    }\n    c.globalAlpha = style.fillAlpha;\n\n    ctx.fill();\n  }\n\n  // draw lines\n  c.strokeStyle = style.lineColor;\n  c.globalAlpha = style.lineAlpha;\n  c.lineWidth = style.lineWidth;\n\n  // Adjust lineWidth so that specified 1px widths will be drawn as 3px on screens with devicePixelRatio == 3.\n  // For human eyes the line width is then the same width.\n  if (style.isScreenSpace) c.lineWidth *= window.devicePixelRatio;\n\n  ctx.stroke();\n\n  // restore default values\n  ctx.dbId = -1;\n  ctx.lineStyle = 0;\n  ctx.isScreenSpace = false;\n  c.globalCompositeOperation = currentGlobalCompositeOp;\n};\n\n// Extra params for cubic Bezier arc edges.\nvar BezierArcParams = /*#__PURE__*/function () {\n  function BezierArcParams() {_classCallCheck(this, BezierArcParams);\n    // control point 1 that defines start tangent\n    this.cp1x = 0;\n    this.cp1y = 0;\n\n    // control point 2 that defines end tangent\n    this.cp2x = 0;\n    this.cp2y = 0;\n  }_createClass(BezierArcParams, [{ key: \"copy\", value: function copy(\n\n    src) {\n      this.cp1x = src.cp1x;\n      this.cp1y = src.cp1y;\n      this.cp2x = src.cp2x;\n      this.cp2y = src.cp2y;\n      return this;\n    } }, { key: \"clone\", value: function clone()\n\n    {\n      return new BezierArcParams().copy(this);\n    } }]);return BezierArcParams;}();\n\n\n// SVG compatible ellipse arc params\n// see https://www.w3.org/TR/svg-paths/#PathDataEllipticalArcCommands\nexport var EllipseArcParams = /*#__PURE__*/function () {\n\n  function EllipseArcParams() {_classCallCheck(this, EllipseArcParams);\n    // {number} Radius along x-axis\n    this.rx = 0;\n\n    // {number} Radius along y-axis\n    this.ry = 0;\n\n    // {number} ccw rotation of x/y-axes in degrees\n    this.rotation = 0;\n\n    // {bool} whether to use shorter or longer path around ellipse.\n    this.largeArcFlag = false;\n\n    // {bool} Whether to go ccw (true) or cw (false) from startAngle. See SVG docs link above for details.\n    this.sweepFlag = false;\n  }_createClass(EllipseArcParams, [{ key: \"copy\", value: function copy(\n\n    src) {\n      this.rx = src.rx;\n      this.ry = src.ry;\n      this.rotation = src.rotation;\n      this.largeArcFlag = src.largeArcFlag;\n      this.sweepFlag = src.sweepFlag;\n      return this;\n    } }, { key: \"clone\", value: function clone()\n    {\n      return new EllipseArcParams().copy(this);\n    }\n\n    // @param {number} angle - counterclockwise in degrees\n  }, { key: \"rotate\", value: function rotate(angle) {\n\n      this.rotation += angle;\n\n      // Normalize angle to keep within [0,360]\n      this.rotation -= Math.trunc(this.rotation / 360) * 360;\n    } }, { key: \"scale\", value: function scale(\n\n    factor) {\n      this.rx *= factor;\n      this.ry *= factor;\n    }\n\n    // updates arc params according to a given transform.\n    // Note: Transforming ellipse arcs is currently only supported for \n    //       simple transforms like translation, rotation, and uniform scaling.\n  }, { key: \"applyMatrix4\", value: function applyMatrix4(matrix) {\n\n      // apply transform to x-axis direction\n      tmpVec3.set(1, 0, 0).applyMatrix4(matrix);\n      tmpVec3_2.set(0, 0, 0).applyMatrix4(matrix);\n      var axis = tmpVec3.sub(tmpVec3_2);\n\n      // obtain rotation angle and scale (assuming uniform scaling)\n      var rotAngle = THREE.Math.radToDeg(Math.atan2(axis.y, axis.x));\n      var scale = axis.length();\n\n      // update ellipse params\n      this.rotate(rotAngle);\n      this.scale(scale);\n\n      // If a transform changes the orientation, we have to invert sweepFlag and rotation param\n      if (Math2D.changesOrientation(matrix)) {\n        this.sweepFlag = !this.sweepFlag;\n        this.rotation = 360.0 - this.rotation;\n      }\n    } }]);return EllipseArcParams;}();\n\n\nexport var Path = /*#__PURE__*/function (_PolyBase3) {_inherits(Path, _PolyBase3);var _super5 = _createSuper(Path);\n\n  function Path(points) {var _this5;var isClosed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;var style = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : DefaultStyle.clone();_classCallCheck(this, Path);\n    _this5 = _super5.call(this, points, style);\n\n    // If true, the path is automatically closed and can be filled.\n    _this5.isClosed = isClosed;return _this5;\n  }\n\n  // Updates ellipse arc of an edge if vertices of the edges are going to be modified   \n  // @param {number} edgeIndex   - must be valid. Edge vertices must be in state _before_ modification.\n  // @param {number} loopIndex   - must be valid. \n  // @param {Vector2} newA, newB - edge vertices after modification\n  _createClass(Path, [{ key: \"_updateEllipseArcParams\", value: function _updateEllipseArcParams(edgeIndex, loopIndex, newA, newB) {\n\n      var params = this._loops[loopIndex][edgeIndex].ellipseArcParams;\n\n      // compute angle by which the edge was rotated\n      var oldDir = this.getEdgeDirection(edgeIndex, loopIndex);\n      var newDir = Math2D.getEdgeDirection(newA, newB);\n      var dAngle = Math2D.angleBetweenDirections(newDir, oldDir);\n\n      params.rotate(THREE.Math.radToDeg(dAngle));\n\n      // get scale factor applied to the edge\n      var oldLength = this.getEdgeLength(edgeIndex, loopIndex);\n      var newLength = Math2D.distance2D(newA, newB); // also works for simple {x,y} pairs\n      var scale = newLength / oldLength;\n\n      // scale ellipse radii (if scaling is valid)\n      var scaleValid = isFinite(scale) && scale > 0; // zero-radii do not work\n      if (scaleValid) {\n        params.scale(scale);\n      }\n    } }, { key: \"updatePoint\", value: function updatePoint(\n\n    index, x, y) {var loopIndex = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n\n      var points = this._loops[loopIndex];\n      var p = points[index];\n\n      var pNew = tmpVec.set(x, y);\n\n      // If p is adjacent to a BezierArc segment, the tangent should keep the same after changing the position\n      // Therefore, we change the corresponding control points as well\n      var dx = x - p.x;\n      var dy = y - p.y;\n\n      // Control point for the start tangent of the arc segment starting at p\n      if (this.isBezierArc(index, loopIndex)) {\n        p.cp1x += dx;\n        p.cp1y += dy;\n      }\n\n      // Update ellipse arc starting at p\n      if (this.isEllipseArc(index, loopIndex)) {\n        // next point must exist if index is a valid ellipse-arc edge.\n        var nextIndex = this.nextIndex(index, loopIndex);\n        var pNext = points[nextIndex];\n        this._updateEllipseArcParams(index, loopIndex, pNew, pNext);\n      }\n\n      // Update arc params of segment ending at p\n      // Note: For polylines, this edge does not exist for index==0\n      var prevEdge = this.edgeBeforeVertex(index, loopIndex);\n      if (this.edgeIndexValid(prevEdge, loopIndex)) {\n\n        // get previous vertex\n        var pPrev = points[prevEdge];\n\n        // Update bezier control point\n        if (this.isBezierArc(prevEdge, loopIndex)) {\n          pPrev.cp2x += dx;\n          pPrev.cp2y += dy;\n        }\n\n        // Update ellipse arc\n        if (this.isEllipseArc(prevEdge, loopIndex)) {\n          this._updateEllipseArcParams(prevEdge, loopIndex, pPrev, pNew);\n        }\n      }\n\n      p.x = x;\n      p.y = y;\n      this.modified();\n    } }, { key: \"getEdgeType\", value: function getEdgeType(\n\n    segmentIndex) {var loopIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var type = this._loops[loopIndex][segmentIndex].arcType;\n      return type ? type : EdgeType.Line;\n    }\n\n    // Change segment into a cubic Bezier arc.\n    // First and last control point are already given by the vertex positions.    \n    //        \n    //  @param {number}             segmentIndex - must be in [0, this.getEdgeCount(loopIndex)]\n    //  @param {BezierArcParams}    params\n    //  @param {number} [loopIndex]\n  }, { key: \"setBezierArc\", value: function setBezierArc(segmentIndex, params) {var loopIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n\n      // Legacy support:\n      // If cp1x, cp2x etc. are enlisted individually, reshape params to expected form.\n      // It's a pain that JS doesn't have function overloads.\n      var isParamObj = _typeof(params) === 'object';\n      if (!isParamObj) {\n        params = {\n          cp1x: params,\n          cp1y: loopIndex,\n          cp2x: arguments.length <= 3 ? undefined : arguments[3],\n          cp2y: arguments.length <= 4 ? undefined : arguments[4] };\n\n        loopIndex = (arguments.length <= 5 ? undefined : arguments[5]) || 0;\n      }\n\n      var p = this._loops[loopIndex][segmentIndex];\n      p.arcType = EdgeType.Bezier;\n      BezierArcParams.prototype.copy.call(p, params);\n\n      this.modified();\n    } }, { key: \"getBezierArcParams\", value: function getBezierArcParams(\n\n    segmentIndex) {var loopIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;var target = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new BezierArcParams();\n      // Find params\n      var p = this._loops[loopIndex][segmentIndex];\n      var srcParams = p && p.arcType === EdgeType.Bezier && p;\n\n      // return a copy if found, otherwise undefined\n      return srcParams && target.copy(srcParams);\n    }\n\n    // Set ellipse arc segment. Parameters are the same as for SVG ellipse arcs.\n    // see https://www.w3.org/TR/svg-paths/#PathDataEllipticalArcCommands\n    //\n    //  @param {number}   segmentIndex - must be in [0, this.getEdgeCount()]\n    //  @param {EllipseArcParams} arcParams \n  }, { key: \"setEllipseArc\", value: function setEllipseArc(segmentIndex, arcParams) {var loopIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n\n      var p = this._loops[loopIndex][segmentIndex];\n\n      p.arcType = EdgeType.Ellipse;\n      p.ellipseArcParams = arcParams.clone();\n\n      this.modified();\n    }\n\n    // @param {number}           segmentIndex - must be a valid ellipse-arc edge\n    // @param {EllipseArcParams} target\n    // @returns {EllipseArcParams}\n  }, { key: \"getEllipseArcParams\", value: function getEllipseArcParams(segmentIndex) {var loopIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;var target = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new EllipseArcParams();\n\n      // Find params\n      var p = this._loops[loopIndex][segmentIndex];\n      var srcParams = p && p.arcType === EdgeType.Ellipse && p.ellipseArcParams;\n\n      // Return a copy if found, otherwise undefined.\n      return srcParams && target.copy(srcParams);\n    }\n\n    // Configures an EllipseArc curve to match with an ellipse-arc edge. This allows for sampling the arc.\n    //  @param {number}     edgeIndex     - must be an ellipse arc\n    //  @param {number}     [loopIndex=0] - loopIndex\n    //  @param {EllipseArc} [target]      - optional\n    //  @returns {EllipseArc}\n  }, { key: \"exportEllipseArc\", value: function exportEllipseArc(edgeIndex) {var loopIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;var target = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new EllipseArc();\n\n      var points = this._loops[loopIndex];\n\n      // get start/end points\n      var nextIndex = this.nextIndex(edgeIndex, loopIndex);\n      var pStart = points[edgeIndex];\n      var pEnd = points[nextIndex];\n      var params = pStart.ellipseArcParams;\n\n      target.setFromSvgArc(\n      params.rx,\n      params.ry,\n      params.rotation,\n      params.largeArcFlag,\n      params.sweepFlag,\n      pStart,\n      pEnd);\n\n      return target;\n    } }, { key: \"isBezierArc\", value: function isBezierArc(\n\n    segmentIndex) {var loopIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      return this.edgeIndexValid(segmentIndex, loopIndex) && this._loops[loopIndex][segmentIndex].arcType === EdgeType.Bezier;\n    } }, { key: \"isEllipseArc\", value: function isEllipseArc(\n\n    segmentIndex) {var loopIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      return this.edgeIndexValid(segmentIndex, loopIndex) && this._loops[loopIndex][segmentIndex].arcType === EdgeType.Ellipse;\n    } }, { key: \"isArc\", value: function isArc(\n\n    segmentIndex) {var loopIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      return this.isBezierArc(segmentIndex, loopIndex) || this.isEllipseArc(segmentIndex, loopIndex);\n    }\n\n    // Get tangent vector pointing from start vertex to control point 1 of an arc segment.\n    // Only allowed for Bezier arcs. Result is not normalized.\n    //  @param {number} segmentIndex - must be a valid index of an arc segment.\n    //  @returns {Vector2}\n  }, { key: \"getStartTangent\", value: function getStartTangent(segmentIndex) {var outTarget = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      var target = outTarget || new THREE.Vector2();\n      var p = this.points[segmentIndex];\n      target.x = p.cp1x - p.x;\n      target.y = p.cp1y - p.y;\n      return target;\n    }\n\n    // Get tangent vector pointing from end vertex to control point 2 of an arc segment.\n    //  @param {number} segmentIndex - must be a valid index of an arc segment.\n    //  @returns {Vector2}\n  }, { key: \"getEndTangent\", value: function getEndTangent(segmentIndex) {var outTarget = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n      var target = outTarget || new THREE.Vector2();\n      var endVertex = this.nextIndex(segmentIndex);\n\n      // get start/end point of the segment\n      var pStart = this.points[segmentIndex];\n      var pEnd = this.points[endVertex];\n      target.x = pStart.cp2x - pEnd.x;\n      target.y = pStart.cp2y - pEnd.y;\n      return target;\n    }\n\n    //  @param {number} segmentIndex - must be a valid index of an arc segment.\n    //  @param {Vector2} tangent\n  }, { key: \"setStartTangent\", value: function setStartTangent(segmentIndex, tangent) {\n      var p = this.points[segmentIndex];\n      p.cp1x = p.x + tangent.x;\n      p.cp1y = p.y + tangent.y;\n      this.modified();\n    }\n\n    //  @param {number} segmentIndex - must be a valid index of an arc segment.\n    //  @param {Vector2} tangent\n  }, { key: \"setEndTangent\", value: function setEndTangent(segmentIndex, tangent) {\n      var p = this.points[segmentIndex];\n      var pEnd = this.points[this.nextIndex(segmentIndex)];\n      p.cp2x = pEnd.x + tangent.x;\n      p.cp2y = pEnd.y + tangent.y;\n      this.modified();\n    }\n\n    // Change Bezier or Ellipse arc back to simple line segment\n  }, { key: \"removeArc\", value: function removeArc(segmentIndex) {var loopIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var p = this._loops[loopIndex][segmentIndex];\n\n      if (p.arcType === EdgeType.Bezier) {\n        p.cp1x = undefined;\n        p.cp1y = undefined;\n        p.cp2x = undefined;\n        p.cp2y = undefined;\n      }\n\n      if (p.ellipseArcParams) p.ellipseArcParams = undefined;\n\n      // reset type\n      p.arcType = EdgeType.Line;\n\n      this.modified();\n    }\n\n    // Return ctrl point of Bezier Arc. Only allowed if isBezierArc(segmentIndex) is true\n    // @param {number} segmentIndex\n    // @param {number} ctrlPointIndex - Must be 1 or 2. Note that ctrlPoints 0 and 3 are defined by\n    //                                  current vertex position\n    // @param {Vector2} [target]\n    // @param {number}  [loopIndex]\n  }, { key: \"getControlPoint\", value: function getControlPoint(segmentIndex, ctrlPointIndex) {var loopIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;var target = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : new THREE.Vector2();\n      var p = this._loops[loopIndex][segmentIndex];\n\n      if (ctrlPointIndex === 1) {\n        target.x = p.cp1x;\n        target.y = p.cp1y;\n      } else {\n        target.x = p.cp2x;\n        target.y = p.cp2y;\n      }\n      return target;\n    }\n\n    // Return ctrl point of Bezier Arc. Only allowed if isBezierArc(segmentIndex) is true\n    // @param {number} segmentIndex\n    // @param {number} ctrlPointIndex - Must be 1 or 2. Note that ctrlPoints 0 and 3 are defined by\n    //                                  current vertex position\n  }, { key: \"updateControlPoint\", value: function updateControlPoint(segmentIndex, ctrlPoint, x, y) {var loopIndex = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;\n      var p = this._loops[loopIndex][segmentIndex];\n      if (ctrlPoint === 1) {\n        p.cp1x = x;\n        p.cp1y = y;\n      } else {\n        p.cp2x = x;\n        p.cp2y = y;\n      }\n      this.modified();\n    }\n\n    // Draw Polygon into LmvCanvasContext\n  }, { key: \"draw\", value: function draw(ctx, overrideStyle) {\n      drawPath(ctx, this, overrideStyle);\n    }\n\n    // Sample path into a Polygon or Polyline.\n    //  @returns {Polygon|Polyline}\n  }, { key: \"toPoly\", value: function toPoly() {var _this6 = this;var tessParams = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Autodesk.Extensions.CompGeom.DefaultTessParams;\n\n      var poly = this.isClosed ? new Polygon() : new Polyline();var _loop = function _loop(\n      l) {\n\n        // Build up a polygon from path commands\n        var ctx = {\n          moveTo: function moveTo(x, y) {return poly.addPoint(x, y, l);},\n          lineTo: function lineTo(x, y) {return poly.addPoint(x, y, l);},\n          bezierCurveTo: function bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y) {\n\n            // get last added point. Note that it always exists, because runLoop() always starts with moveTo.\n            // so we know for sure that >=1 points were already added to this polygon loop.\n            var points = poly._loops[l];\n            var last = points[points.length - 1];\n\n            // compute bbox of the arc - which we use as an estimate for required accuracy\n            var arcBox = tmpBox2.makeEmpty();\n            arcBox.expandByPoint(last);\n            arcBox.expandByPoint(tmpVec2.set(x, y));\n            arcBox.expandByPoint(tmpVec2.set(cp1x, cp1y));\n            arcBox.expandByPoint(tmpVec2.set(cp2x, cp2y));\n            var sz = arcBox.size(tmpVec).length();\n\n            // sample arc into lineTo() segments\n            Autodesk.Extensions.CompGeom.TesselateCubic(ctx, last.x, last.y, cp1x, cp1y, cp2x, cp2y, x, y, sz, tessParams);\n          },\n          ellipse: function ellipse(cx, cy, rx, ry, rotation, startAngle, endAngle, ccw) {\n\n            // use ellipse maxRadius a reference for required accuracy\n            var sz = Math.max(rx, ry);\n\n            // determine tesselation params                    \n            var maxSegments = tessParams.numIterations;\n            var minSegmentLength = tessParams.minSegLenFraction * sz;\n\n            // tesselate arc\n            var arc = getTmpArc().set(cx, cy, rx, ry, rotation, startAngle, endAngle, ccw);\n            arc.tesselate(ctx, maxSegments, minSegmentLength);\n          },\n          closePath: function closePath() {} // Polygon is closed anyway.\n        };\n        runLoop(ctx, _this6, l);};for (var l = 0; l < this.loopCount; l++) {_loop(l);\n      }\n      return poly;\n    } }, { key: \"computeBBox\", value: function computeBBox()\n\n    {\n      // Compute bbox of all vertices\n      _get(_getPrototypeOf(Path.prototype), \"computeBBox\", this).call(this);\n\n      // Consider Bezier arcs: By definition, Bezier curves are always bounded by the convex hull of their control\n      // points. Therefore, we can simply add the control points to the bbox.\n      //\n      // Note: The bboxes obtained by this simple approach are only guaranteed to contain the curve. But, they are not guaranteed to be minimal.\n      //       This is not a big issue for most uses (hitTest, drawing etc.). In case it becomes a problem anywhere, we need a better solution here, e.g.\n      //       https://stackoverflow.com/questions/24809978/calculating-the-bounding-box-of-cubic-bezier-curve\n      var cp = new THREE.Vector2();\n      for (var l = 0; l < this.loopCount; l++) {\n        for (var i = 0; i < this.getVertexCount(l); i++) {\n\n          if (this.isBezierArc(i, l)) {\n            // add control point 1\n            this.getControlPoint(i, 1, l, cp);\n            this.bbox.expandByPoint(cp);\n\n            // add control point 2\n            this.getControlPoint(i, 2, l, cp);\n            this.bbox.expandByPoint(cp);\n          } else\n          if (this.isEllipseArc(i, l)) {\n            var arc = this.exportEllipseArc(i, l, getTmpArc());\n            this.bbox.union(arc.computeBBox(tmpBox2));\n          }\n        }\n      }\n    } }, { key: \"hitTest\", value: function hitTest(\n\n    x, y, hitRadius) {\n      var poly = this.toPoly();\n      return poly.hitTest(x, y, hitRadius);\n    } }, { key: \"clone\", value: function clone()\n\n    {\n      return new Path().copy(this);\n    }\n\n    // @param {Path} srcPath\n    // @param {number} srcLoopIndex loop in srcPath to copy\n    // @param {number} [dstLoopIndex] Optional: index where to insert the new loop. By default, we use the first free loopIndex.\n  }, { key: \"addLoop\", value: function addLoop(srcPath) {var srcLoopIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;var dstLoopIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : -1;\n\n      // If dstLoop is not set, it will be chosen by the super.addLoop().\n      dstLoopIndex = _get(_getPrototypeOf(Path.prototype), \"addLoop\", this).call(this, srcPath, srcLoopIndex, dstLoopIndex);\n\n      var srcPoints = srcPath._loops[srcLoopIndex];\n      var dstPoints = this._loops[dstLoopIndex];\n\n      // Copy extra information for arcs\n      for (var i = 0; i < srcPoints.length; i++) {\n        var type = srcPath.getEdgeType(i, srcLoopIndex);\n\n        // Line segments are fully handled by the base class already\n        if (type === EdgeType.Line) {\n          continue;\n        }\n\n        var src = srcPoints[i];\n        var dst = dstPoints[i];\n\n        dst.arcType = src.arcType;\n\n        switch (type) {\n          case EdgeType.Bezier:{\n              // copy control points\n              dst.cp1x = src.cp1x;\n              dst.cp1y = src.cp1y;\n              dst.cp2x = src.cp2x;\n              dst.cp2y = src.cp2y;\n              break;\n            }\n          case EdgeType.Ellipse:{\n              // copy arc params\n              dst.ellipseArcParams = src.ellipseArcParams && src.ellipseArcParams.clone();\n              break;\n            }}\n\n      }\n\n      this.modified();\n      return this;\n    } }, { key: \"moveLoop\", value: function moveLoop(\n\n    dx, dy, loopIndex) {\n      _get(_getPrototypeOf(Path.prototype), \"moveLoop\", this).call(this, dx, dy, loopIndex);\n\n      // Move affected control points as well\n      var points = this._loops[loopIndex];\n      for (var i = 0; i < points.length; i++) {\n        if (!this.isBezierArc(i, loopIndex)) {\n          continue;\n        }\n\n        var p = points[i];\n        p.cp1x += dx;\n        p.cp1y += dy;\n        p.cp2x += dx;\n        p.cp2y += dy;\n      }\n\n      // Note that for Ellipse arcs, it is sufficient to move start/end like for line segments.\n    } }, { key: \"getArea\", value: function getArea(\n\n    measureTransform) {\n      if (!this.isClosed) {\n        return undefined;\n      }\n\n      // Todo: If performance becomes an issue, this can be optimized by a less brute-force way.\n      var poly = this.toPoly(AreaTessParam);\n\n      // Since poly is just temporary, we can just share the loop infos to prevent poly.getArea()\n      // from computing them again.\n      poly._loopInfos = this._getLoopInfos();\n\n      return poly.getArea(measureTransform);\n    } }, { key: \"getLength\", value: function getLength(\n\n    measureTransform) {\n      var poly = this.toPoly();\n      return poly.getLength(measureTransform);\n    }\n\n    // Get point on segment. This refines the implementation \n    // of PolyBase by supporting arc segments.\n  }, { key: \"getPointOnEdge\", value: function getPointOnEdge(segmentIndex, t) {var loopIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;var target = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : new THREE.Vector2();\n\n      var points = this._loops[loopIndex];\n      var type = this.getEdgeType(segmentIndex, loopIndex);\n      switch (type) {\n        case EdgeType.Line:break;\n        case EdgeType.Bezier:{\n            // get segment start/end\n            var a = points[segmentIndex];\n            var b = points[this.nextIndex(segmentIndex)];\n\n            return Autodesk.Extensions.CompGeom.getCubeBezierPoint(t, a.x, a.y, a.cp1x, a.cp1y, a.cp2x, a.cp2y, b.x, b.y, target);\n          }\n        case EdgeType.Ellipse:{\n            var arc = this.exportEllipseArc(segmentIndex, loopIndex, getTmpArc());\n\n            // ignore arcs with NaN values\n            if (!arc.isValid()) {\n              break;\n            }\n            return arc.getPoint(t, target);\n          }\n        default:avp.logger.error('unexpected edge type');}\n\n\n      return _get(_getPrototypeOf(Path.prototype), \"getPointOnEdge\", this).call(this, segmentIndex, t, loopIndex, target);\n    }\n\n    // Run moveTo/lineTo/arcTo/closePath calls on a given context object.    \n    //  @param {Path2d|LmvCanvasContext|Object} ctx    - Receives the callback calls, i.e. moveTo, lineTo, bezierCurveTo, closePath etc. (see Path2D)\n  }, { key: \"runPathCommands\", value: function runPathCommands(ctx) {\n      runPath(ctx, this);\n    }\n\n    // Returns false if all edges of all loops are line segments.\n  }, { key: \"hasArcs\", value: function hasArcs() {var _this7 = this;\n      var filter = function filter(vertexIndex, loopIndex) {return _this7.isArc(vertexIndex, loopIndex);};\n      return Boolean(this.findVertex(filter));\n    } }]);return Path;}(PolyBase);\n\n\n// Alias that can be used for Polyline/Polygon paths. Use only if you don't intend to change the isClosed prop during lifetime.\nexport var PolygonPath = /*#__PURE__*/function (_Path) {_inherits(PolygonPath, _Path);var _super6 = _createSuper(PolygonPath);\n  function PolygonPath(points, style) {_classCallCheck(this, PolygonPath);return _super6.call(this,\n    points, true, style);\n  }return PolygonPath;}(Path);\n;\n\nexport var PolylinePath = /*#__PURE__*/function (_Path2) {_inherits(PolylinePath, _Path2);var _super7 = _createSuper(PolylinePath);\n  function PolylinePath(points, style) {_classCallCheck(this, PolylinePath);return _super7.call(this,\n    points, false, style);\n  }return PolylinePath;}(Path);\n;\n\nexport var Circle = /*#__PURE__*/function (_Shape2) {_inherits(Circle, _Shape2);var _super8 = _createSuper(Circle);\n\n  // Note: The tessSegments parameter will be removed later when the implementation uses arcs from LineShader directly.\n  function Circle() {var _this8;var centerX = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0.0;var centerY = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0.0;var radius = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1.0;var style = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : DefaultStyle.clone();var tessSegments = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 20;_classCallCheck(this, Circle);\n    _this8 = _super8.call(this, style);\n\n    _this8.polygon = new Polygon([], style);\n\n    // Force polygon.id to be the same, so that its geometry is associated with this Circle.\n    // This is a bit hacky, but can be removed as soon as we use native arcs for circle rendering.\n    _this8.polygon.id = _this8.id;\n\n    _this8.centerX = centerX;\n    _this8.centerY = centerY;\n    _this8.radius = radius;\n    _this8.tessSegments = tessSegments;\n\n    _this8.needsUpdate = true;return _this8;\n  }_createClass(Circle, [{ key: \"draw\", value: function draw(\n\n    ctx, overrideStyle) {\n\n      this.polygon.points.length = 0;\n\n      // angle delta in degrees\n      var stepSize = 360 / this.tessSegments;\n      for (var angle = 0; angle < 360; angle += stepSize) {\n\n        var a = angle * Math.PI / 180;\n        var x = this.radius * Math.cos(a);\n        var y = this.radius * Math.sin(a);\n\n        this.polygon.addPoint(this.centerX + x, this.centerY + y);\n      }\n\n      this.needsUpdate = false;\n\n      this.polygon.draw(ctx, overrideStyle);\n    } }, { key: \"setCenter\", value: function setCenter(\n\n    x, y) {\n      this.centerX = x;\n      this.centerY = y;\n      this.modified();\n    } }, { key: \"move\", value: function move(\n\n    dx, dy) {\n      this.centerX += dx;\n      this.centerY += dy;\n      this.modified();\n      return this;\n    } }, { key: \"hitTest\", value: function hitTest(\n\n    x, y) {\n      var dx = x - this.centerX;\n      var dy = y - this.centerY;\n      return dx * dx + dy * dy < this.radius * this.radius;\n    } }, { key: \"clone\", value: function clone()\n\n    {\n      return new Circle().copy(this);\n    } }, { key: \"copy\", value: function copy(\n\n    from) {\n      _get(_getPrototypeOf(Circle.prototype), \"copy\", this).call(this, from);\n      this.polygon = from.polygon.clone();\n      this.centerX = from.centerX;\n      this.centerY = from.centerY;\n      this.radius = from.radius;\n      this.tessSegments = from.tessSegments;\n      this.modified();\n      return this;\n    } }, { key: \"computeBBox\", value: function computeBBox()\n\n    {\n      this.bbox.min.set(this.centerX - this.radius, this.centerY - this.radius);\n      this.bbox.max.set(this.centerX + this.radius, this.centerY + this.radius);\n    } }]);return Circle;}(Shape);\n\n\nexport var ShapeWrapper = /*#__PURE__*/function (_Shape3) {_inherits(ShapeWrapper, _Shape3);var _super9 = _createSuper(ShapeWrapper);\n\n  // @param {Shape} shape - must not be null\n  function ShapeWrapper(shape) {var _this9;_classCallCheck(this, ShapeWrapper);\n    _this9 = _super9.call(this);\n    _this9.shape = shape;\n\n    Object.defineProperty(_assertThisInitialized(_this9), 'bbox', {\n      get: function get() {return _this9.shape.bbox;},\n      set: function set(bbox) {_this9.shape.bbox = bbox;} });\n\n\n    Object.defineProperty(_assertThisInitialized(_this9), 'id', {\n      get: function get() {return _this9.shape.id;},\n      set: function set(id) {_this9.shape.id = id;} });\n\n\n    Object.defineProperty(_assertThisInitialized(_this9), 'bboxDirty', {\n      get: function get() {return _this9.shape.bboxDirty;},\n      set: function set(dirty) {_this9.shape.bboxDirty = dirty;} });\n\n\n    Object.defineProperty(_assertThisInitialized(_this9), 'name', {\n      get: function get() {return _this9.shape.name;},\n      set: function set(name) {_this9.shape.name = name;} });return _this9;\n\n  }_createClass(ShapeWrapper, [{ key: \"draw\", value: function draw()\n\n    {var _this$shape;return (_this$shape = this.shape).draw.apply(_this$shape, arguments);} }, { key: \"hitTest\", value: function hitTest()\n    {var _this$shape2;return (_this$shape2 = this.shape).hitTest.apply(_this$shape2, arguments);} }, { key: \"move\", value: function move()\n    {var _this$shape3;return (_this$shape3 = this.shape).move.apply(_this$shape3, arguments);} }, { key: \"modified\", value: function modified()\n    {var _this$shape4;return (_this$shape4 = this.shape).modified.apply(_this$shape4, arguments);} }, { key: \"computeBBox\", value: function computeBBox()\n    {var _this$shape5;return (_this$shape5 = this.shape).computeBBox.apply(_this$shape5, arguments);} }, { key: \"updateBBox\", value: function updateBBox()\n    {var _this$shape6;return (_this$shape6 = this.shape).updateBBox.apply(_this$shape6, arguments);} }, { key: \"clone\", value: function clone()\n\n    {\n      return new ShapeWrapper(this.shape.clone());\n    } }, { key: \"copy\", value: function copy(\n\n    from) {\n      this.shape.copy(from.shape);\n    } }]);return ShapeWrapper;}(Shape);","function _typeof(obj) {\"@babel/helpers - typeof\";if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;};}return _typeof(obj);}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError(\"Cannot call a class as a function\");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}function _inherits(subClass, superClass) {if (typeof superClass !== \"function\" && superClass !== null) {throw new TypeError(\"Super expression must either be null or a function\");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}function _createSuper(Derived) {var hasNativeReflectConstruct = _isNativeReflectConstruct();return function _createSuperInternal() {var Super = _getPrototypeOf(Derived),result;if (hasNativeReflectConstruct) {var NewTarget = _getPrototypeOf(this).constructor;result = Reflect.construct(Super, arguments, NewTarget);} else {result = Super.apply(this, arguments);}return _possibleConstructorReturn(this, result);};}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");}return self;}function _isNativeReflectConstruct() {if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;if (Reflect.construct.sham) return false;if (typeof Proxy === \"function\") return true;try {Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));return true;} catch (e) {return false;}}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}\nimport { EllipseArcParams, EdgeType, PolyIndex } from './EditShapes.js';\nimport { EdgeGizmo } from './CanvasGizmo.js';\nimport { Actions } from './Actions.js';\n\nvar tmpVec2 = new THREE.Vector2();\n\n// Get ellipse arc params in a way that the edge is bended inside or outside wrt.\n// to the outer loop.\n//\n// @param {Path}   path       - not changed   \n// @param {number} edgeIndex  - edge for which we compute the arc params\n// @param {number} loopIndex\n// @param {number} bendRadius - Signed distance between line-segment center and arc center. \n//                                 Positive values for outside, negative for inside.   \n// @param {EllipseArcParams} [target]\n// @returns {EllipseArcParams}\nexport var getEllipseArcEdgeParams = function getEllipseArcEdgeParams(path, edgeIndex, loopIndex, bendRadius, target) {\n\n  var params = target || new EllipseArcParams();\n\n  // compute ellipse rotation, so that ellipse x-axis is parallel to the edge\n  var dir = path.getEdgeDirection(edgeIndex, loopIndex, tmpVec2);\n  var angle = Math.atan2(dir.y, dir.x);\n  params.rotation = THREE.Math.radToDeg(angle);\n\n  // Compute radius in a way that ellipse center matches with line-segment center\n  params.rx = 0.5 * path.getEdgeLength(edgeIndex, loopIndex);\n\n  // Apply bending by varying y-radius\n  params.ry = Math.abs(bendRadius);\n\n  // Always use shortest connection\n  params.largeArcFlag = false;\n\n  // Make sure that positive bendRadius bends outside, negative inside\n  params.sweepFlag = Boolean(path.isCCW(loopIndex) ^ bendRadius < 0);\n\n  return params;\n};\n\n// Gizmo class to pull ellipse arc centers. The gizmo implements the full interaction, but\n// the owner controls when startDrag(), moveDrag(), and endDrag() are called.\nexport var EllipseArcGizmo = /*#__PURE__*/function (_EdgeGizmo) {_inherits(EllipseArcGizmo, _EdgeGizmo);var _super = _createSuper(EllipseArcGizmo);\n\n  function EllipseArcGizmo(layer, gizmoManager, undoStack, visible) {var _this;_classCallCheck(this, EllipseArcGizmo);\n    _this = _super.call(this, layer, visible);\n\n    _this.container.classList.add('ellipse-arc-gizmo');\n\n    _this.dragging = false;\n\n    // arc params when drag had started\n    _this.dragStartParams = new EllipseArcParams();\n\n    // delta between exact dragStart position and gizmo-center at dragStart\n    _this.dragOffset = new THREE.Vector2();\n\n    // tmp values\n    _this.tmpVec = new THREE.Vector2();\n    _this.tmpVec2 = new THREE.Vector2();\n    _this.tmpVec3 = new THREE.Vector2();\n    _this.tmpParams = new EllipseArcParams();\n\n    _this.gizmoManager = gizmoManager;\n    _this.undoStack = undoStack;return _this;\n  }_createClass(EllipseArcGizmo, [{ key: \"isUnderMouse\", value: function isUnderMouse()\n\n    {\n      return this.visible && this.edgeValid() && this.gizmoManager.isUnderMouse(this);\n    } }, { key: \"startDrag\", value: function startDrag(\n\n    canvasX, canvasY) {\n\n      // Stop here if there is nothing to drag\n      if (!this.edgeValid() || !this.isUnderMouse()) {\n        return false;\n      }\n\n      // Usually, dragging will be false here unless in weird focus-change scenarios\n      if (this.dragging) {\n        return true;\n      }\n\n      this.dragging = true;\n\n      // Highlight in green while dragging\n      this.setSelected(true);\n\n      // Store offset between exact mouse pos and the vertex we are dragging\n      var pos = this.layerPos;\n      var posScreen = this.layer.layerToCanvas(pos.x, pos.y);\n      this.dragOffset.set(posScreen.x - canvasX, posScreen.y - canvasY);\n\n      // Backup initial arc params\n      this.poly.getEllipseArcParams(this.edgeIndex, this.loopIndex, this.dragStartParams);\n\n      return true;\n    } }, { key: \"moveDrag\", value: function moveDrag(\n\n    canvasX, canvasY) {\n\n      if (!this.dragging) {\n        return false;\n      }\n\n      // Compute layer position of the gizmo after drag\n      // Note that the vertex we are dragging does not always match exactly with the mouse position. \n      // E.g., we may have picked the bottom-left boundary of a vertex gizmo at drag-start.\n      var x = canvasX + this.dragOffset.x;\n      var y = canvasY + this.dragOffset.y;\n      var p = this.layer.canvasToLayer(x, y);\n\n      // Compute vector (a => p), where a is the edge start\n      var a = this.poly.getPoint(this.edgeIndex, this.loopIndex, this.tmpVec);\n      var diff = this.tmpVec2.copy(p).sub(a); // vector from edge start towards new gizmo position\n\n      // Compute distance of the new gizmo position from edge spanned by line segment (a,b)\n      var normal = this.poly.getOuterNormal(this.edgeIndex, this.loopIndex, this.tmpVec3);\n      var signedDistance = diff.dot(normal);\n\n      // Configure ellipse arc, so that the distance of the arc midpoint is the same\n      var params = getEllipseArcEdgeParams(this.poly, this.edgeIndex, this.loopIndex, signedDistance, this.tmpParams);\n\n      // Update polygon\n      this.poly.setEllipseArc(this.edgeIndex, params, this.loopIndex);\n      this.update();\n      this.layer.update();\n\n      return true;\n    } }, { key: \"endDrag\", value: function endDrag(\n\n    canvasX, canvasY) {\n      this.moveDrag(canvasX, canvasY);\n      this.dragging = false;\n\n      var newParams = this.poly.getEllipseArcParams(this.edgeIndex, this.loopIndex, this.tmpParams);\n\n      this.restoreArc();\n      var polyIndex = new PolyIndex({ vertex: this.edgeIndex, loop: this.loopIndex });\n      this.undoStack.run(new Actions.ChangeEdgeType(this.layer, this.poly, polyIndex, EdgeType.Ellipse, null, null, newParams));\n\n      // stop highlighting\n      this.setSelected(false);\n    } }, { key: \"cancelDrag\", value: function cancelDrag()\n\n    {\n      this.restoreArc();\n      this.dragging = false;\n      this.layer.update();\n    }\n\n    // Restore state of the arc before dragging it\n  }, { key: \"restoreArc\", value: function restoreArc() {\n      this.poly.setEllipseArc(this.edgeIndex, this.dragStartParams, this.loopIndex);\n    } }]);return EllipseArcGizmo;}(EdgeGizmo);","function _readOnlyError(name) {throw new Error(\"\\\"\" + name + \"\\\" is read-only\");}function _createForOfIteratorHelper(o, allowArrayLike) {var it;if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {if (it) o = it;var i = 0;var F = function F() {};return { s: F, n: function n() {if (i >= o.length) return { done: true };return { done: false, value: o[i++] };}, e: function e(_e) {throw _e;}, f: F };}throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");}var normalCompletion = true,didErr = false,err;return { s: function s() {it = o[Symbol.iterator]();}, n: function n() {var step = it.next();normalCompletion = step.done;return step;}, e: function e(_e2) {didErr = true;err = _e2;}, f: function f() {try {if (!normalCompletion && it.return != null) it.return();} finally {if (didErr) throw err;}} };}function _unsupportedIterableToArray(o, minLen) {if (!o) return;if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);var n = Object.prototype.toString.call(o).slice(8, -1);if (n === \"Object\" && o.constructor) n = o.constructor.name;if (n === \"Map\" || n === \"Set\") return Array.from(o);if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);}function _arrayLikeToArray(arr, len) {if (len == null || len > arr.length) len = arr.length;for (var i = 0, arr2 = new Array(len); i < len; i++) {arr2[i] = arr[i];}return arr2;}\nimport { SolidDefConvert } from './SolidDefConvert.js';\nimport { SketchRegionSolver, getRegionEdges, getBoundedRegionFaces, computeCurveCurveIntersections } from '@adsk/solid-definition';\n\n// Result values of classifySets\nvar SetContainment = {\n  Contains: 0, // A contains B (not vice versa)\n  IsContainedIn: 1, // B contains A (not vice versa)\n  Disjoint: 2, // No common elements\n  Overlapping: 3, // Intersecting, but not equal\n  Equal: 4 // Sets are identical\n};\n\n// @param {SketchRegionSolver} solver       - initialized with all edges of subject and cutLoop\n// @param {Edges[]}            loopEdges    - edges of the loop that we test against.\n// @returns {Face[]} subset of solver.getFaces(). All faces encludes by the loopEdges.\nexport var getFacesInsideLoop = function getFacesInsideLoop(solver, loopEdges) {\n\n  // Get all faces that we obtained by intersecting all edges against each other\n  var regionFaces = solver.getFaces();\n\n  // Get ordered array of loop edges within solver that correspond to the cutLoop\n  var cutRegionEdges = getRegionEdges(solver, loopEdges);\n\n  // Find all faces that are \n  return getBoundedRegionFaces(regionFaces, cutRegionEdges);\n};\n\n// Tolerance for self-intersection tests: If intersections are very close to a shared vertex, we ignore them.\n// Note that the tolerance is not in units but a fraction of an edge.\nvar Precision = 1.e-5;\n\n// Check whether a single loop has self-intersections\n// TODO: There is one edge case that we would not detect here: If a loop passes the same vertex multiple times.\nvar hasSelfIntersections = function hasSelfIntersections(loopEdges) {\n  for (var _i = 0; _i < loopEdges.length; _i++) {\n    var edge1 = loopEdges[_i];\n\n    // Check all subsequent edges.\n    for (var j = _i + 1; j < loopEdges.length; j++) {\n\n      // Check intersections of both edges\n      var edge2 = loopEdges[j];\n      var cuts = computeCurveCurveIntersections(edge1, edge2, false, true);\n\n      // Check if there are any intersections (except for shared vertices)\n      for (var _i2 = 0; _i2 < cuts.length; _i2++) {\n        var cut = cuts[_i2];\n\n        // Ignore intersections at a shared vertex\n        // Due to accuracy issues, the cut may also be just close to a vertex\n        var param1 = cut.cutInfo.param;\n        var param2 = cut.cutByInfo.param;\n\n        var range1 = edge1.getRange();\n        var range2 = edge2.getRange();\n\n        // Check if both parameters are very close to range start/end of an edge\n        var dist1 = Math.min(Math.abs(param1 - range1[0]), Math.abs(param1 - range1[1]));\n        var dist2 = Math.min(Math.abs(param2 - range2[0]), Math.abs(param2 - range2[1]));\n        var d = Math.max(dist1, dist2);\n\n        // If cut was not approximately equal to a shared vertex,\n        // consider it as a self-intersection.\n        if (d > Precision) {\n          return true;\n        }\n      }\n    }\n  }\n  return false;\n};\n\n// Given two sets of values, faces, each indexed by integer faceIds, this function checks how the sets are related.\nvar classifySets = function classifySets(A, B) {\n\n  // Track which kind of indices we found\n  var foundCommon = false; // >=0 elems are in both\n  var foundAOnly = false; // >=0 elems are only in set A\n  var foundBOnly = false; // >=0 elems are only in set B\n\n  var checkElems = function checkElems(elemIndex) {\n    var isInA = A.has(elemIndex);\n    var isInB = B.has(elemIndex);\n\n    if (isInA && isInB) foundCommon = true;else\n    if (isInA) foundAOnly = true;else\n    if (isInB) foundBOnly = true;\n  };var _iterator = _createForOfIteratorHelper(\n\n  A),_step;try {for (_iterator.s(); !(_step = _iterator.n()).done;) {var elem = _step.value;\n      checkElems(elem);\n    }} catch (err) {_iterator.e(err);} finally {_iterator.f();}var _iterator2 = _createForOfIteratorHelper(\n\n  B),_step2;try {for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {var _elem = _step2.value;\n      checkElems(_elem);\n    }} catch (err) {_iterator2.e(err);} finally {_iterator2.f();}\n\n  if (!foundCommon) {\n    return SetContainment.Disjoint;\n  }\n\n  if (foundAOnly && !foundBOnly) {\n    return SetContainment.Contains;\n  }\n\n  if (foundBOnly && !foundAOnly) {\n    return SetContainment.IsContainedIn;\n  }\n\n  if (!foundAOnly && !foundBOnly) {\n    return SetContainment.Equal;\n  }\n\n  return SetContainment.Overlapping;\n};\n\n// Contains loop containment for a path\nexport var computeLoopContainment = function computeLoopContainment(path) {\n\n  // Convert to SolidDef Path\n  var pathSd = SolidDefConvert.toSolidDefPath(path);\n\n  // get path as wires\n  var wireBody = pathSd.getWireBody();\n  var wires = wireBody.getWires();\n\n  // get path as edge array\n  var edges = wireBody.getEdges();\n\n  // Init empty loop infos\n  var loopInfos = [];\n  for (var l = 0; l < wires.length; l++) {\n\n    // Get loop edges\n    var w = wires[l];\n    var loopEdges = w.getEdges();\n\n    loopInfos[l] = {\n      containedLoops: [],\n      rank: 0,\n\n      // Indicates if loop containment could not properly computed. \n      // This happens if \n      //   a) The loop has self-intersections\n      //   b) The loop is overlapping with another one\n      //   c) The loop is exactly matching with another one\n      error: hasSelfIntersections(loopEdges) // Initially, we detect only a)\n    };\n  }\n\n  // For only a single loop or less, we are done here.\n  if (wires.length < 2) {\n    return loopInfos;\n  }\n\n  // Feed them into solver to intersect them against each other and extract the resulting region faces.\n  var solver = new SketchRegionSolver();\n  solver.compute(edges);\n\n  // check which of the faces are within path and cutPath\n  var faces = solver.getFaces();\n\n  // attach arrayIndex to each face\n  faces.forEach(function (f, index) {return f.arrayIndex = index;});\n\n  // for each loop l, collect a set facesPerLoop[l] that contains the array indices of all enclosed faces.     \n  var facesPerLoop = [];var _loop = function _loop(\n  _l) {\n\n    // get edges of loop i\n    var w = wires[_l];\n    var loopEdges = w.getEdges();\n\n    // If a loop has self-intersections, just mark it as invalid and skip it\n    if (hasSelfIntersections(loopEdges)) {\n      loopInfos[_l].error = true;\n      facesPerLoop[_l] = new Set();\n      return \"continue\";\n    }\n\n    // get all faces within this loop\n    var enclosedFaceIds = new Set();\n    var faces = getFacesInsideLoop(solver, loopEdges);\n    faces.forEach(function (f) {\n      enclosedFaceIds.add(f.arrayIndex);\n    });\n\n    facesPerLoop[_l] = enclosedFaceIds;};for (var _l = 0; _l < wires.length; _l++) {var _ret = _loop(_l);if (_ret === \"continue\") continue;\n  }\n\n  // Use the faceId sets to derive which loop is contained in which other    \n  for (var a = 0; a < facesPerLoop.length; a++) {\n\n    // indices of all faces enclosed by loop a\n    var A = facesPerLoop[a];\n\n    for (var b = a + 1; b < facesPerLoop.length; b++) {\n      // indices of all faces enclosed by loop i\n      var B = facesPerLoop[b];\n\n      // Check set relation between A and B\n      var cont = classifySets(A, B);\n      switch (cont) {\n        case SetContainment.Disjoint:\n          // No common faces at all. E.g., for two holes.\n          continue;\n        case SetContainment.Contains:\n          loopInfos[a].containedLoops.push(b);\n          loopInfos[b].rank++;\n          break;\n        case SetContainment.IsContainedIn:\n          loopInfos[b].containedLoops.push(b);\n          loopInfos[a].rank++;\n          break;\n        default:\n          loopInfos[a].error = true;\n          loopInfos[b].error = true;}\n\n    }\n  }\n\n  // If the original paths contained empty loops, we may have to reindex the loopInfos,\n  // because empty loops will not produce a corresponding wire in the SolidDef representation.\n  if (wires.length !== path.loopCount) {\n    var reindexed = [];\n    var srcIndex = 0;\n    for (var _l2 = 0; _l2 < path.loopCount; _l2++) {\n      // Only non-empty loops get loopInfos\n      if (path.getVertexCount(_l2)) {\n        reindexed[i] = loopInfos[(_readOnlyError(\"srcIndex\"), srcIndex++)];\n      }\n    }\n    loopInfos = (_readOnlyError(\"loopInfos\"), reindexed);\n  }\n\n  return loopInfos;\n};","var tmpVec2d = new THREE.Vector2();\nvar tmpVec2d2 = new THREE.Vector2();\n\n// Collection of simple helper functions for 2D math functions.\n\n// Return normalized edge direction vector (b-a).normalized\nvar getEdgeDirection = function getEdgeDirection(a, b, target) {\n  target = target || new THREE.Vector2();\n\n  return target.copy(b).sub(a).normalize();\n};\n\nvar getEdgeCenter = function getEdgeCenter(a, b, target) {\n  target = target || new THREE.Vector2();\n\n  return target.set(0.5 * (a.x + b.x), 0.5 * (a.y + b.y));\n};\n\n// Get edge length. (a, b) can just be {x, y} pairs, i.e., not required to be THREE.Vector2\nvar getEdgeLength = function getEdgeLength(a, b) {\n  var dx = b.x - a.x;\n  var dy = b.y - a.y;\n  return Math.sqrt(dx * dx + dy * dy);\n};\n\n// Rotates direction vector p 90 degrees to the left. (in-place)\nvar turnLeft = function turnLeft(p) {\n  var tmp = p.x;\n  p.x = -p.y;\n  p.y = tmp;\n  return p;\n};\n\n// Projects a point p to a line. Works in-place\n//  @param {Vector2} p\n//  @param {Vector2} linePoint - point on the line\n//  @param {Vector2} lineDir   - line direction. Must be normalized\nvar projectToLine = function projectToLine(p, linePoint, lineDir) {\n\n  // dp = dot(p-linePoint, lineDir)\n  var dp = (p.x - linePoint.x) * lineDir.x + (p.y - linePoint.y) * lineDir.y;\n\n  // return linePoint + lineDir * dp\n  p.set(\n  linePoint.x + dp * lineDir.x,\n  linePoint.y + dp * lineDir.y);\n\n};\n\n// Get distance between the point p and a line given by point and direction.\n//  @param {Vector2} p\n//  @param {Vector2} linePoint - point on the line\n//  @param {Vector2} lineDir   - line direction. Must be normalized\nvar pointLineDistance = function () {\n  var pProj = new THREE.Vector2();\n  return function (p, linePoint, lineDir) {\n    projectToLine(pProj.copy(p), linePoint, lineDir);\n    return p.distanceTo(pProj);\n  };\n}();\n\n// Calculates the intersection point of both given lines\n// assumes that the lines are not parallel\n// see: http://www.paulbourke.net/geometry/pointlineplane/\nvar intersectLines = function intersectLines(linePoint1, lineDir1, linePoint2, lineDir2, outPoint) {\n\n  var denom = lineDir2.y * lineDir1.x - lineDir2.x * lineDir1.y;\n  if (Math.abs(denom) < 1.0e-8) {return false;}\n\n  // diff = linePoint1 - linePoint2\n  var diffX = linePoint1.x - linePoint2.x;\n  var diffY = linePoint1.y - linePoint2.y;\n\n  var u = lineDir2.x * diffY - lineDir2.y * diffX;\n\n  if (outPoint) {\n    outPoint.x = linePoint1.x + u / denom * lineDir1.x;\n    outPoint.y = linePoint1.y + u / denom * lineDir1.y;\n  }\n  return true;\n};\n\n// Rotate a vector p around origin or a given center. Works in-place.\n//  @param {Vector2} p\n//  @param {number}  angle in radians\n//  @param [Vector2] center \nvar rotateAround = function rotateAround(p, angle, center) {\n\n  var c = Math.cos(angle);\n  var s = Math.sin(angle);\n\n  if (center) {\n    p.sub(center);\n  }\n\n  var x = p.x;\n  var y = p.y;\n\n  p.x = x * c - y * s;\n  p.y = x * s + y * c;\n\n  if (center) {\n    p.add(center);\n  }\n  return p;\n};\n\n//  @param {Vector2} dir1, dir2           - No normalization required.\n//  @returns {number} result in [0, 2*Pi] - clockwise angle in radians that you have to apply to rotate dir2 into dir1.\nvar angleBetweenDirections = function angleBetweenDirections(dir1, dir2) {\n\n  // get angle formed with positive x-axis. \n  // angle1/2 are in [-Pi, Pi]\n  var angle1 = Math.atan2(dir1.y, dir1.x);\n  var angle2 = Math.atan2(dir2.y, dir2.x);\n\n  // Difference is in [-2*Pi, 2*Pi]\n  var angle = angle1 - angle2;\n\n  // Map result to [0, 2*Pi] range\n  if (angle < 0) angle += 2 * Math.PI;\n\n  return angle;\n};\n\n// see isPointOnEdge\nvar isPointOnLine = function isPointOnLine(p, a, b, precision) {\n  return isPointOnEdge(p, a, b, precision, false);\n};\n\n// Returns true if p lies close to the edge (p1, p2). \nvar isPointOnEdge = function isPointOnEdge(p, a, b, precision) {var checkInsideSegment = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;\n\n  // Compute edge length\n  var dx = b.x - a.x;\n  var dy = b.y - a.y;\n  var length = Math.sqrt(dx * dx + dy * dy);\n\n  var e = {\n    v1: a,\n    dx: dx,\n    dy: dy,\n    length: length,\n    length2: length * length };\n\n  return Autodesk.Extensions.CompGeom.pointOnLine(p.x, p.y, e, checkInsideSegment, precision);\n};\n\nvar pointDelta = function pointDelta(a, b) {var digits = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  var delta = { x: b.x - a.x, y: b.y - a.y };\n  if (digits)\n  {\n    var exp = Math.pow(10, digits);\n    delta.x = Math.round(delta.x * exp) / exp;\n    delta.y = Math.round(delta.y * exp) / exp;\n  }\n  if (!delta.x && !delta.y) {\n    return;\n  }\n  return delta;\n};\n\nvar edgeIsDegenerated = function edgeIsDegenerated(a, b) {var eps2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1.0e-10;\n  return a.distanceToSquared(b) < eps2;\n};\n\n// Compute target point resulting from mirroring point p\n// on the given center point c.\nvar mirrorPointOnPoint = function mirrorPointOnPoint(p, c) {var target = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;\n  target = target || new THREE.Vector2();\n  target.x = c.x - (p.x - c.x);\n  target.y = c.y - (p.y - c.y);\n  return target;\n};\n\nvar fuzzyEqual = function fuzzyEqual(a, b, precision) {\n  return Math.abs(a - b) < precision;\n};\n\n// Checks if two lines are collinear.\n//  @param {Vector2} p1, dir1 - First line, given as point and normalized direction.\n//  @param {Vector2} p2, dir2 - Second line\n//  @param {number}  precision\n//  @returns {bool}\nvar collinear = function collinear(p1, dir1, p2, dir2, precision) {\n\n  // Directions must be either equal or opposite\n  var dirEqual = fuzzyEqual(dir1.x, dir2.x, precision) && fuzzyEqual(dir1.y, dir2.y, precision);\n  var dirOpposite = fuzzyEqual(dir1.x, -dir2.x, precision) && fuzzyEqual(dir1.y, -dir2.y, precision);\n  if (!dirEqual && !dirOpposite) {\n    return false;\n  }\n\n  // Directions are equal or opposite => Lines are collinear if and only if p2 is on line (p1, dir1).\n  var dx = p2.x - p1.x;\n  var dy = p2.y - p1.y;\n  var dot = dx * dir1.x + dy * dir1.y;\n  return Math.abs(dot) < precision;\n};\n\n// same as p1.distanceTo(p2), but working for any {x,y} object.\nvar distance2D = function distance2D(p1, p2) {\n  var dx = p2.x - p1.x;\n  var dy = p2.y - p1.y;\n  return Math.sqrt(dx * dx + dy * dy);\n};\n\n// Checks if a matrix changes the orientation.\n//  @param {Matrix4} matrix\nvar changesOrientation = function changesOrientation(matrix) {\n  return matrix.determinant() < 0;\n};\n\n// Compute a matrix that transforms fromBox into toBox.\n//\n//  @param {Box2}    fromBox\n//  @param {Box2}    toBox\n//  @param {Object}  [options]\n//  @param {bool}    [options.flipY]           - include y-axis flip\n//  @param {bool}    [options.preserveAspect]  - force uniform scaling (m * fromBox might be smaller than toBox in one axis)\n//  @param {Matrix4} [target]\nvar getFitToBoxTransform = function getFitToBoxTransform(fromBox, toBox) {var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};var target = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : new THREE.Matrix4();\n  var fromSize = fromBox.size(tmpVec2d);\n  var toSize = toBox.size(tmpVec2d2);\n\n  // compute scale   \n  var sx = toSize.x / fromSize.x;\n  var sy = toSize.y / fromSize.y;\n\n  // preserveAspect\n  if (options.preserveAspect) {\n    sx = Math.min(sx, sy);\n    sy = sx;\n  }\n\n  // anchor is the point of fromBox that will be mapped to toBox.min\n  var anchorX = fromBox.min.x;\n  var anchorY = fromBox.min.y;\n\n  // apply optional y-flip\n  if (options.flipY) {\n    sy *= -1;\n    anchorY = fromBox.max.y;\n  }\n\n  // compute translation: after scaling, anchor should move to toBox.min\n  var tx = -sx * anchorX + toBox.min.x;\n  var ty = -sy * anchorY + toBox.min.y;\n\n  // Create (scale + translate)-matrix.\n  var matrix = target.makeScale(sx, sy, 1.0);\n  matrix.elements[12] = tx;\n  matrix.elements[13] = ty;\n\n  return matrix;\n};\n\nexport var Math2D = {\n  getEdgeDirection: getEdgeDirection,\n  projectToLine: projectToLine,\n  pointLineDistance: pointLineDistance,\n  intersectLines: intersectLines,\n  rotateAround: rotateAround,\n  angleBetweenDirections: angleBetweenDirections,\n  getEdgeCenter: getEdgeCenter,\n  getEdgeLength: getEdgeLength,\n  turnLeft: turnLeft,\n  isPointOnEdge: isPointOnEdge,\n  isPointOnLine: isPointOnLine,\n  pointDelta: pointDelta,\n  edgeIsDegenerated: edgeIsDegenerated,\n  mirrorPointOnPoint: mirrorPointOnPoint,\n  fuzzyEqual: fuzzyEqual,\n  collinear: collinear,\n  distance2D: distance2D,\n  changesOrientation: changesOrientation,\n  getFitToBoxTransform: getFitToBoxTransform };","function _typeof(obj) {\"@babel/helpers - typeof\";if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;};}return _typeof(obj);}function _inherits(subClass, superClass) {if (typeof superClass !== \"function\" && superClass !== null) {throw new TypeError(\"Super expression must either be null or a function\");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}function _createSuper(Derived) {var hasNativeReflectConstruct = _isNativeReflectConstruct();return function _createSuperInternal() {var Super = _getPrototypeOf(Derived),result;if (hasNativeReflectConstruct) {var NewTarget = _getPrototypeOf(this).constructor;result = Reflect.construct(Super, arguments, NewTarget);} else {result = Super.apply(this, arguments);}return _possibleConstructorReturn(this, result);};}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");}return self;}function _isNativeReflectConstruct() {if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;if (Reflect.construct.sham) return false;if (typeof Proxy === \"function\") return true;try {Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));return true;} catch (e) {return false;}}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError(\"Cannot call a class as a function\");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}\n\n\n// Workaround to choose a viewport for a given 2d sheet.\n// \n// Actually, we should choose it based on 2d-position. But, F2D doesn't give us proper data to \n// do this. Also, even with proper viewport outlines, it wouldn't always unique as viewports may overlap.\n// Therefore, we have to use a workaround here to make it use for simple single-viewport sheets at least.\n//\n// @returns {number|-1} Either -1 or a valid viewportId.\nvar chooseViewportId = function chooseViewportId(model) {\n\n  var data = model.getData();\n  var viewports = data.viewports;\n  if (!viewports) {\n    return -1;\n  }\n\n  // find viewport with maximum number of dbIds    \n  var vpIndex = -1;\n  var maxDbIds = -1;\n  for (var i = 0; i < viewports.length; i++) {\n\n    // Skip viewports without transform\n    var vp = viewports[i];\n    if (!vp.transform) {\n      continue;\n    }\n\n    // Use current vp if it has most dbIds\n    var numDbIds = vp.geom_metrics.db_ids;\n    if (numDbIds > maxDbIds) {\n      vpIndex = i;\n      maxDbIds = numDbIds;\n    }\n  }\n\n  return vpIndex;\n};\n\n// A MeasureTransform allows for doing length/area measurements in another coordinate system than the actual shape geometry.\n// The transform is applied to all points before doing calculations.\nexport var MeasureTransform = /*#__PURE__*/function () {function MeasureTransform() {_classCallCheck(this, MeasureTransform);}_createClass(MeasureTransform, [{ key: \"apply\",\n\n    // @param {Vector2} p - Point to be transformed in-place.\n    value: function apply(p) {} }]);return MeasureTransform;}();\n;\n\n\n// Sets the pageToModel transform in LMV as MeasureTransform to make measurements consistent with Measure extension.\nexport var DefaultMeasureTransform = /*#__PURE__*/function (_MeasureTransform) {_inherits(DefaultMeasureTransform, _MeasureTransform);var _super = _createSuper(DefaultMeasureTransform);\n\n  function DefaultMeasureTransform(viewer) {var _this;_classCallCheck(this, DefaultMeasureTransform);\n    _this = _super.call(this);\n    _this.viewer = viewer;return _this;\n  }\n\n  // Transform geometry point to the coordinate system in which measurements should be computed and displayed.\n  //\n  // @param {vector2} p\n  //\n  // Note: Currently, we do some simplifying assumptions here that may need additional\n  //       work to support scenarios with multiple viewports or multiple 2d models.\n  _createClass(DefaultMeasureTransform, [{ key: \"apply\", value: function apply(p) {\n      // Get viewportId\n      var model = this.viewer.model;\n      if (!model) {\n        return;\n      }\n\n      var vpId = chooseViewportId(model);\n\n      // In case there are no viewports, there still might be a pageToModelTransform,\n      // which we need to take into account. This is the case for raster PDF.\n      model.pageToModel(p, null, vpId);\n    } }]);return DefaultMeasureTransform;}(MeasureTransform);","function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError(\"Cannot call a class as a function\");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;} // Helper to check whether certain modifiers are currently hold or not.\n// See https://developer.mozilla.org/de/docs/Web/API/KeyboardEvent/getModifierState for list of supported keys.\n// E.g.:\n//  \"Control\", \"Shift\", \"Alt\", ..\nvar ModifierMask = /*#__PURE__*/function () {\n\n  function ModifierMask() {_classCallCheck(this, ModifierMask);\n    // By default, don't check any modifers.\n    this.checkedModifiers = {};\n  }\n\n  // Add a modifier to be checked. E.g. addCondition(\"Control\", true).\n  _createClass(ModifierMask, [{ key: \"addCondition\", value: function addCondition(modifierName, expectedState) {\n      this.checkedModifiers[modifierName] = expectedState;\n    }\n\n    // Remove condition - accept any state of this modifier\n  }, { key: \"removeCondition\", value: function removeCondition(modifierName) {\n      delete this.checkedModifiers[modifierName];\n    }\n\n    // Check if current event meets all modifier conditions\n  }, { key: \"accepts\", value: function accepts(event) {\n      for (var key in this.checkedModifiers) {\n        var state = event.getModifierState(key);\n        var expected = this.checkedModifiers[key];\n        if (state !== expected) {\n          return false;\n        }\n      }\n      return true;\n    } }]);return ModifierMask;}();export { ModifierMask as default };\n;","function _typeof(obj) {\"@babel/helpers - typeof\";if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;};}return _typeof(obj);}function _get(target, property, receiver) {if (typeof Reflect !== \"undefined\" && Reflect.get) {_get = Reflect.get;} else {_get = function _get(target, property, receiver) {var base = _superPropBase(target, property);if (!base) return;var desc = Object.getOwnPropertyDescriptor(base, property);if (desc.get) {return desc.get.call(receiver);}return desc.value;};}return _get(target, property, receiver || target);}function _superPropBase(object, property) {while (!Object.prototype.hasOwnProperty.call(object, property)) {object = _getPrototypeOf(object);if (object === null) break;}return object;}function _inherits(subClass, superClass) {if (typeof superClass !== \"function\" && superClass !== null) {throw new TypeError(\"Super expression must either be null or a function\");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}function _createSuper(Derived) {var hasNativeReflectConstruct = _isNativeReflectConstruct();return function _createSuperInternal() {var Super = _getPrototypeOf(Derived),result;if (hasNativeReflectConstruct) {var NewTarget = _getPrototypeOf(this).constructor;result = Reflect.construct(Super, arguments, NewTarget);} else {result = Super.apply(this, arguments);}return _possibleConstructorReturn(this, result);};}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");}return self;}function _isNativeReflectConstruct() {if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;if (Reflect.construct.sham) return false;if (typeof Proxy === \"function\") return true;try {Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));return true;} catch (e) {return false;}}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError(\"Cannot call a class as a function\");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}import EditLayer from './EditLayer.js';\nimport { Polyline } from './EditShapes.js';\nimport Arrow from './Arrow.js';\n\nvar avp = Autodesk.Viewing.Private;\n\n//\n// Utility class for drawing vector overlays in canvas-pixel coords.\n//\n\n// Base class for line-based gizmos that can be used in screen overlays\nvar ScreenOverlayGizmo = /*#__PURE__*/function () {\n\n  function ScreenOverlayGizmo() {_classCallCheck(this, ScreenOverlayGizmo);\n    // current opacity value\n    this.opacity = 1.0;\n\n    // Fade-in/out transition params\n    this.fullOpacity = 1.0; // opacity after full fade-in\n    this.fadeTime = 0.5; // in seconds\n\n    // Used by parent ScreenOvelay for fade in/out\n    this.fadeAnim = null;\n  }\n\n  // Update layer (=screen) coords of the gizmo based latest camera \n  _createClass(ScreenOverlayGizmo, [{ key: \"update\", value: function update(viewer) {}\n\n    // Return shape representing this gizmo. Used by ScreenOverlay to add/remove shapes from/to layer.\n  }, { key: \"getShape\", value: function getShape() {}\n\n    // Opacity for fade-in/out\n  }, { key: \"setOpacity\", value: function setOpacity(opacity) {\n      this.opacity = opacity;\n    } }, { key: \"getOpacity\", value: function getOpacity()\n    {return this.opacity;} }, { key: \"stopFadeAnim\", value: function stopFadeAnim()\n\n    {\n      if (this.fadeAnim) {\n        this.fadeAnim.stop();\n        this.fadeAnim = null;\n      }\n    } }]);return ScreenOverlayGizmo;}();\n\n\n// A line that whose endpoints are attached to the screen-projections of 2 points in 3D.\nvar Line3DGizmo = /*#__PURE__*/function (_ScreenOverlayGizmo) {_inherits(Line3DGizmo, _ScreenOverlayGizmo);var _super = _createSuper(Line3DGizmo);\n\n  function Line3DGizmo(a, b) {var _this;_classCallCheck(this, Line3DGizmo);\n    _this = _super.call(this);\n\n    // 2D shape in pixel coords\n    _this.line2D = new Polyline().makeLine(0, 0, 0, 0);\n\n    // 3D world positions\n    _this.a = a || new THREE.Vector3();\n    _this.b = b || new THREE.Vector3();return _this;\n  }_createClass(Line3DGizmo, [{ key: \"update\", value: function update(\n\n    viewer) {\n      // project points to screen\n      var p1 = viewer.impl.worldToClient(this.a);\n      var p2 = viewer.impl.worldToClient(this.b);\n\n      // update line\n      this.line2D.updatePoint(0, p1.x, p1.y);\n      this.line2D.updatePoint(1, p2.x, p2.y);\n    } }, { key: \"setOpacity\", value: function setOpacity(\n\n    opacity) {\n      _get(_getPrototypeOf(Line3DGizmo.prototype), \"setOpacity\", this).call(this, opacity);\n      this.line2D.style.lineAlpha = opacity;\n    } }, { key: \"setLine\", value: function setLine(\n\n    a, b) {\n      this.a.copy(a);\n      this.b.copy(b);\n    } }, { key: \"getShape\", value: function getShape()\n\n    {\n      return this.line2D;\n    } }]);return Line3DGizmo;}(ScreenOverlayGizmo);\n;\n\n// A line that whose endpoints are attached to the screen-projections of 2 points in 3D.\nvar Arrow3DGizmo = /*#__PURE__*/function (_ScreenOverlayGizmo2) {_inherits(Arrow3DGizmo, _ScreenOverlayGizmo2);var _super2 = _createSuper(Arrow3DGizmo);\n\n  function Arrow3DGizmo(a, b) {var _this2;_classCallCheck(this, Arrow3DGizmo);\n    _this2 = _super2.call(this);\n\n    // 2D shape in pixel coords\n    _this2.arrow = new Arrow();\n\n    // 3D world positions\n    _this2.a = a || new THREE.Vector3();\n    _this2.b = b || new THREE.Vector3();return _this2;\n  }_createClass(Arrow3DGizmo, [{ key: \"update\", value: function update(\n\n    viewer) {\n      // project points to screen\n      var p1 = viewer.impl.worldToClient(this.a);\n      var p2 = viewer.impl.worldToClient(this.b);\n\n      // update line\n      this.arrow.setFrom(p1);\n      this.arrow.setTo(p2);\n    } }, { key: \"getOpacity\", value: function getOpacity()\n\n    {\n      return this.arrow.style.lineAlpha;\n    } }, { key: \"setOpacity\", value: function setOpacity(\n\n    opacity) {\n      this.arrow.line.style.lineAlpha = opacity;\n      this.arrow.head.style.fillAlpha = opacity;\n    } }, { key: \"stopFadeAnim\", value: function stopFadeAnim()\n\n    {\n      if (this.fadeAnim) {\n        this.fadeAnim.stop();\n        this.fadeAnim = null;\n      }\n    } }, { key: \"setFrom\", value: function setFrom(\n\n    a) {\n      this.a.copy(a);\n    } }, { key: \"setTo\", value: function setTo(\n\n    b) {\n      this.b.copy(b);\n    } }, { key: \"getShape\", value: function getShape()\n\n    {\n      return this.arrow;\n    } }]);return Arrow3DGizmo;}(ScreenOverlayGizmo);\n;var\n\nScreenOverlay = /*#__PURE__*/function () {\n\n  // @param {Viewer3D} viewer\n  // @param {string}   overlayName - Overlay that is created/owned by this EditLayer. Note that it is also destroyed in dtor, so it should not be shared.\n  function ScreenOverlay(viewer) {var overlayName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'Edit2D.ScreenOverlay';_classCallCheck(this, ScreenOverlay);\n    this.viewer = viewer;\n\n    this.overlayName = overlayName;\n    this.layer = new EditLayer(viewer);\n\n    // create overlay scene, with orthographic Camera\n    var canvas = viewer.canvas;\n    var canvasWidth = canvas.clientWidth;\n    var canvasHeight = canvas.clientHeight;\n    this.camera = new THREE.OrthographicCamera(0, canvasWidth, 0, canvasHeight, -1, 1);\n\n    // Create overlay with EditLayer geometry and ortho camera\n    this.viewer.impl.createOverlayScene(overlayName, null, null, this.camera);\n    this.viewer.impl.overlayScenes[overlayName].scene.add(this.layer.scene);\n\n    // Make sure that camera is updated on screen resize\n    this.onResize = this.onResize.bind(this);\n    this.viewer.addEventListener(Autodesk.Viewing.VIEWER_RESIZE_EVENT, this.onResize);\n\n    // Update line gizmos on camera changes\n    this.onCameraChange = this.onCameraChange.bind(this);\n    this.viewer.addEventListener(Autodesk.Viewing.CAMERA_CHANGE_EVENT, this.onCameraChange);\n\n    // Gizmos whose vertices are attached to 3D world positions\n    this.gizmos = [];\n\n    // Avoid default viewer cutplanes for screenspace gizmos\n    this.layer.setCutPlanesEnabled(false);\n\n    this.layer.setOverlayCamera(this.camera);\n  }_createClass(ScreenOverlay, [{ key: \"dtor\", value: function dtor()\n\n    {\n      this.viewer.removeEventListener(Autodesk.Viewing.VIEWER_RESIZE_EVENT, this.onResize);\n      this.viewer.removeEventListener(Autodesk.Viewing.CAMERA_CHANGE_EVENT, this.onCameraChange);\n      this.viewer.removeOverlayScene(this.overlayName);\n    } }, { key: \"onResize\", value: function onResize()\n\n    {\n      // adjust ortho-camera to modified canvas\n      this.camera.right = this.viewer.canvas.clientWidth;\n      this.camera.bottom = this.viewer.canvas.clientHeight;\n      this.camera.updateProjectionMatrix();\n      this.update();\n    }\n\n    // Checks if a gizmo is currently shown in this overlay\n  }, { key: \"gizmoVisible\", value: function gizmoVisible(gizmo) {\n      return this.gizmos.includes(gizmo);\n    }\n\n    // Add gizmo (if needed) and fade its opacity \n  }, { key: \"fadeInGizmo\", value: function fadeInGizmo(gizmo) {var _this3 = this;\n\n      // Choose start opacity\n      var startOpacity = this.gizmoVisible(gizmo) ? gizmo.getOpacity() : 0.0;\n      var endOpacity = gizmo.fullOpacity;\n\n      // Make sure gizmo is visible\n      this.setGizmoVisible(gizmo, true);\n\n      // Avoid overlapping animations\n      gizmo.stopFadeAnim();\n\n      // update gizmo opacity on timer\n      var onTimer = function onTimer(t) {\n\n        t = avp.smootherStep(t);\n\n        // blend opacity value\n        var val = avp.lerp(startOpacity, endOpacity, t);\n        gizmo.setOpacity(val);\n\n        _this3.layer.update();\n      };\n\n      gizmo.setOpacity(startOpacity);\n      gizmo.fadeAnim = avp.fadeValue(0, 1, gizmo.fadeTime, onTimer);\n    }\n\n    // Fade-out gizmo and sets it to invisible when done (unless interrupted by fade-In)\n  }, { key: \"fadeOutGizmo\", value: function fadeOutGizmo(gizmo) {var _this4 = this;\n\n      if (!this.gizmoVisible(gizmo)) {\n        return;\n      }\n\n      // Choose start opacity\n      var startOpacity = gizmo.getOpacity();\n\n      // Avoid overlapping animations\n      gizmo.stopFadeAnim();\n\n      // update gizmo opacity on timer\n      var onTimer = function onTimer(t) {\n\n        t = avp.smootherStep(t);\n\n        // blend opacity value\n        var val = avp.lerp(startOpacity, 0.0, t);\n        gizmo.setOpacity(val);\n\n        _this4.layer.update();\n      };\n\n      // If animation finished without interruptions, set gizmo to invisible\n      var onEnd = function onEnd() {\n        _this4.setGizmoVisible(gizmo, false);\n      };\n\n      gizmo.fadeAnim = avp.fadeValue(0, 1, gizmo.fadeTime, onTimer, onEnd);\n    } }, { key: \"setGizmoVisible\", value: function setGizmoVisible(\n\n    gizmo, visible) {\n\n      // If the gizmo was fading out or faded out before, make sure that the fade-out stops\n      // and the full opacity is recovered.\n      gizmo.stopFadeAnim();\n      gizmo.setOpacity(gizmo.fullOpacity);\n\n      // Check if gizmo is currently visible\n      var index = this.gizmos.indexOf(gizmo);\n      var wasVisible = index !== -1;\n\n      if (visible == wasVisible) {\n        return;\n      }\n\n      var shape = gizmo.getShape();\n      if (visible) {\n        // add gizmo\n        this.gizmos.push(gizmo);\n        this.layer.addShape(shape);\n      } else {\n        // remove gizmo\n        this.gizmos.splice(index, 1);\n        this.layer.removeShape(shape);\n      }\n      this.update();\n    } }, { key: \"onCameraChange\", value: function onCameraChange()\n\n    {\n      this.update();\n    } }, { key: \"update\", value: function update()\n\n    {var _this5 = this;\n      // reproject 3D gizmos\n      this.gizmos.forEach(function (g) {return g.update(_this5.viewer);});\n      this.layer.update();\n    } }]);return ScreenOverlay;}();export { ScreenOverlay as default };\n;\n\nScreenOverlay.Line3DGizmo = Line3DGizmo;\nScreenOverlay.Arrow3DGizmo = Arrow3DGizmo;","function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError(\"Cannot call a class as a function\");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}var Worker = require('worker-loader?inline!./SegmentTreeWorker');\n\n// \n// SegmentTree is a spatial datastructure that helps to quickly find all segments (lines, arcs) within a given 2d bbox.\n//\n\nvar SegmentType = {\n  Line: 1,\n  CircularArc: 2,\n  EllipticalArc: 3 };\n\n\n// A segment is an object that describes a single line or arc segment.\n// Properties depend on segment type (see functions below)\nvar createLineSegment = function createLineSegment(x1, y1, x2, y2, vpId) {return { type: SegmentType.Line, x1: x1, y1: y1, x2: x2, y2: y2, vpId: vpId };};\nvar createCircularArcSegment = function createCircularArcSegment(cx, cy, start, end, radius, vpId) {return { type: SegmentType.CirularArc, cx: cx, cy: cy, start: start, end: end, radius: radius, vpId: vpId };};\nvar createEllipticalArcSegment = function createEllipticalArcSegment(cx, cy, start, end, major, minor, tilt, vpId) {return { type: SegmentType.EllipticalArc, cx: cx, cy: cy, start: start, end: end, major: major, minor: minor, tilt: tilt, vpId: vpId };};\n\n// Triggers the corresponding callbacks (onLineSegment, onCircularArc...) from a given segment object.\n//  @param {Object} s             - Segment object whose data are sent to geomCb\n//  @param {Object} geomCallbacks - Provides handlers for different segments. Same as used by VertexBufferReader.\nvar processSegment = function processSegment(s, geomCallbacks) {\n  switch (s.type) {\n    case SegmentType.Line:geomCallbacks.onLineSegment(s.x1, s.y1, s.x2, s.y2, s.vpId);break;\n    case SegmentType.CirularArc:geomCallbacks.onCircularArc(s.cx, s.cy, s.start, s.end, s.radius, s.vpId);break;\n    case SegmentType.EllipticalArc:geomCallbacks.onEllipticalArc(s.cx, s.cy, s.tart, s.end, s.major, s.minor, s.tilt, s.vpId);break;}\n\n};\n\n// Implements required functions to allow organizing segments in a quadtree\nvar SegmentHandler = /*#__PURE__*/function () {\n\n  function SegmentHandler() {_classCallCheck(this, SegmentHandler);\n\n    // Used BoundsCallback to get segment bboxes\n    this.boundsCb = new Autodesk.Viewing.Private.BoundsCallback(new THREE.Box2());\n\n    // Reused tmp values\n    this.queryBox = new THREE.Box2();\n    this.tmpPoint = new THREE.Vector2();\n  }_createClass(SegmentHandler, [{ key: \"getSegmentBox\", value: function getSegmentBox(\n\n    segment) {\n      this.boundsCb.bounds.makeEmpty();\n      processSegment(segment, this.boundsCb);\n      return this.boundsCb.bounds;\n    } }, { key: \"getQueryBox\", value: function getQueryBox(\n\n    minx, miny, maxx, maxy) {\n      // get query box\n      this.queryBox.min.set(minx, miny);\n      this.queryBox.max.set(maxx, maxy);\n      return this.queryBox;\n    } }, { key: \"intersectsBox\", value: function intersectsBox(\n\n    segment, minx, miny, maxx, maxy) {\n      var queryBox = this.getQueryBox(minx, miny, maxx, maxy);\n      var segmentBox = this.getSegmentBox(segment);\n      return queryBox.isIntersectionBox(segmentBox);\n    }\n\n    // Note that outPoint is just an {x,y} pair, not a Vector2\n  }, { key: \"getPoint\", value: function getPoint(segment, outPoint) {\n      // Just use bbox center for all segment types\n      var center = this.getSegmentBox(segment).getCenter(this.tmpPoint);\n      outPoint.x = center.x;\n      outPoint.y = center.y;\n    } }]);return SegmentHandler;}();\n\n\nvar worker;var\nSegmentTree = /*#__PURE__*/function () {function SegmentTree() {_classCallCheck(this, SegmentTree);}_createClass(SegmentTree, [{ key: \"buildFromModel\",\n\n    // Build SegmentTree from 2D vector-data model (PDF or F2D).\n    // Note: Make sure that the model is fully loaded - otherwise, the tree will be incomplete.\n    value: function buildFromModel(model) {\n\n      // The quadtree must know the extents in advance.\n      var box = model.getBoundingBox(true);\n\n      // Init quadtree that manages segments\n      this.tree = new Autodesk.Extensions.CompGeom.QuadTree(box.min.x, box.min.y, box.max.x, box.max.y, 0.0, new SegmentHandler());\n\n      if (!worker) {\n        worker = new Worker();\n      }\n\n      // Add geomtry for all fragments\n      var frags = model.getFragmentList();\n      var count = frags.getCount();\n\n      this.numProcessed = 0;\n      this.totalGeoms = count;\n\n      // Notify the worker with the expected number of geometries\n      worker.postMessage({ totalGeoms: count });\n\n      for (var i = 0; i < count; i++) {\n        var geom = frags.getGeometry(i);\n        this.addGeometry(geom);\n      }\n    }\n\n    // Adds all segments from a given 2D LineShader geometry.\n    //  @param {BufferGeometry} geom\n    //\n    // Precondition: Can only be called if tree has been initialized and geom is within the bbox used to initialize the tree\n  }, { key: \"addGeometry\", value: function addGeometry(geom) {var _this = this;\n\n      // This is the required geometry data that is required by the VertexBufferReader.\n      // The real BufferGeometry instance cannot be serialized.\n      var geomData = {\n        vb: geom.vb,\n        ib: geom.ib,\n        vbstride: geom.vbstride,\n        numInstances: geom.numInstances,\n        unpackXform: geom.unpackXform,\n        tIdColor: geom.tIdColor,\n        attributes: geom.attributes };\n\n\n      worker.postMessage([geomData]);\n      worker.onmessage = function (e) {\n        var batch = e.data;\n        for (var i = 0; i < batch.length; i += 9) {\n          var type = batch[i];\n          switch (type) {\n            case 1: // Line Segment\n              _this.tree.addItem(createLineSegment(batch[i + 1], batch[i + 2], batch[i + 3], batch[i + 4], batch[i + 5]));\n              break;\n            case 2: // Circular Arc\n              _this.tree.addItem(createCircularArcSegment(batch[i + 1], batch[i + 2], batch[i + 3], batch[i + 4], batch[i + 5], batch[i + 6]));\n              break;\n            case 3: // Elliptical Arc\n              _this.tree.addItem(createEllipticalArcSegment(batch[i + 1], batch[i + 2], batch[i + 3], batch[i + 4], batch[i + 5], batch[i + 6], batch[i + 7], batch[i + 8]));\n              break;\n            case 9: // finished\n              _this.numProcessed++;\n              break;}\n\n        }\n      };\n    }\n\n    //  @param {Object} geomCallbacks - Visitor that provides callbacks to handle different segments. Same as used by VertexBufferReader.\n  }, { key: \"enumSegments\", value: function enumSegments(minx, miny, maxx, maxy, geomCallbacks) {\n\n      // Find all segments in the tree and invoke corresponding call on GeometryCallback\n      this.tree.enumInBox(minx, miny, maxx, maxy, function (s) {return processSegment(s, geomCallbacks);});\n    } }]);return SegmentTree;}();export { SegmentTree as default };","function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError(\"Cannot call a class as a function\");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}import { Style } from './EditShapes.js';\nimport UndoStack from './UndoStack.js';\nimport EditLayer from './EditLayer.js';\n\nvar av = Autodesk.Viewing;var\n\nSelection = /*#__PURE__*/function () {\n\n  function Selection(layer, undoStack) {var _this = this;_classCallCheck(this, Selection);\n\n    av.EventDispatcher.prototype.apply(this);\n\n    // Keys: shapeIds, Values: shapes\n    this.isSelected = {};\n\n    // For mouse-over highlighting. 0 = nothing highlighted (ShapeIds start at 1)\n    this.hoveredId = 0;\n\n    // Reused as temporary override style for shapes\n    this.tmpStyle = new Style();\n\n    // Callback function that controls how to modify the style on selected shapes\n    this.modifier = function (shape, style) {\n\n      // only modify style for selected or hovered shapes\n      var isSelected = _this.isSelected[shape.id];\n      var isHovered = shape.id === _this.hoveredId;\n      if (!isSelected && !isHovered) {\n        return undefined;\n      }\n\n      // Create a tmp copy of the initial shape style that is modified to indicate highlighting.\n      // Note that we can reuse tmpStyle for multiple shapes, because style modifiers are applied right before drawing.\n      _this.tmpStyle.copy(style);\n\n      if (isSelected) {\n        _this.tmpStyle.fillAlpha = Math.min(_this.tmpStyle.fillAlpha + 0.3, 1);\n        _this.tmpStyle.lineWidth *= 1.5;\n      } else {\n        // hovered\n        _this.tmpStyle.fillAlpha = Math.min(_this.tmpStyle.fillAlpha + 0.2, 1);\n        _this.tmpStyle.lineWidth *= 1.5;\n      }\n\n      return _this.tmpStyle;\n    };\n\n    this.layer = layer;\n    this.onShapeRemoved = this.onShapeRemoved.bind(this);\n    this.onLayerCleared = this.onLayerCleared.bind(this);\n    this.layer.addEventListener(EditLayer.SHAPE_REMOVED, this.onShapeRemoved);\n    this.layer.addEventListener(EditLayer.LAYER_CLEARED, this.onLayerCleared);\n\n    this.layer.addStyleModifier(this.modifier);\n\n    // Make sure that selection doesn't keep deleted objects, e.g., if creation has undone\n    // or a RemoveShape action happened.\n    this.undoStack = undoStack;\n    this.onActionCb = function (a) {return _this.onAction(a);};\n    this.undoStack.addEventListener(UndoStack.AFTER_ACTION, this.onActionCb);\n\n    this.selectionFilters = [this.defaultSelectionFilter];\n  }_createClass(Selection, [{ key: \"dtor\", value: function dtor()\n\n    {\n      this.layer.removeStyleModifier(this.modifier);\n      this.undoStack.removeEventListener(UndoStack.AFTER_ACTION, this.onActionCb);\n      this.undoStack.removeEventListener(EditLayer.SHAPE_REMOVED, this.onShapeRemoved);\n      this.undoStack.removeEventListener(EditLayer.LAYER_CLEARED, this.onLayerCleared);\n    } }, { key: \"addSelectionFilter\", value: function addSelectionFilter(\n\n    filter) {\n      this.selectionFilters.push(filter);\n    } }, { key: \"removeSelectionFilter\", value: function removeSelectionFilter(\n\n    filter) {\n      var index = this.selectionFilters.indexOf(filter);\n      if (index == -1) {\n        return false;\n      }\n      this.selectionFilters.splice(index, 1);\n      return true;\n    } }, { key: \"defaultSelectionFilter\", value: function defaultSelectionFilter(\n\n    shapes) {\n      return shapes.every(function (s) {return s.selectable;});\n    }\n\n    // @param {Shape[]) shapes\n  }, { key: \"setSelection\", value: function setSelection(shapes) {\n      // This works for null as well (unlike ES6 default params)\n      shapes = shapes || [];\n\n      // shapes must pass selection filters to get selected.\n      if (!this.selectionFilters.every(function (sf) {return sf(shapes);})) {\n        return;\n      }\n\n      var selected = this.getSelectedShapes();\n\n      // Check if the set of ids changed\n      var changed = false;\n      if (selected.length != shapes.length) {\n        changed = true;\n      } else {\n        // Check if any new shape was not selected before\n        for (var i = 0; i < shapes.length; i++) {\n          var shape = shapes[i];\n          if (!this.isSelected[shape.id]) {\n            changed = true;\n          }\n        }\n      }\n\n      if (!changed) {\n        return;\n      }\n\n      // Add all shapes to this.isSelected\n      this.isSelected = {};\n      for (var _i = 0; _i < shapes.length; _i++) {\n        var _shape = shapes[_i];\n        this.isSelected[_shape.id] = _shape;\n      }\n      this.modified();\n    } }, { key: \"empty\", value: function empty()\n\n    {\n      return !Object.keys(this.isSelected).length;\n    }\n\n    // Set selection to a single shape. Calling with null clears the selection.\n  }, { key: \"selectOnly\", value: function selectOnly(shape) {\n      this.setSelection(shape && [shape]);\n    } }, { key: \"shapeIsSelected\", value: function shapeIsSelected(\n\n    shape) {\n      return shape && Boolean(this.isSelected[shape.id]);\n    } }, { key: \"toggleSelection\", value: function toggleSelection(\n\n    shape) {\n      var wasSelected = Boolean(this.isSelected[shape.id]);\n      this.isSelected[shape.id] = wasSelected ? null : shape;\n\n      this.modified();\n    } }, { key: \"clear\", value: function clear()\n\n    {\n      this.setSelection([]);\n    }\n\n    // Passes all selected shapes to the callback\n  }, { key: \"getSelectedShapes\", value: function getSelectedShapes() {\n      return Object.values(this.isSelected).filter(Boolean);\n    } }, { key: \"getSelectedIds\", value: function getSelectedIds()\n\n    {\n      return this.getSelectedShapes().map(function (s) {return s.id;});\n    } }, { key: \"modified\", value: function modified()\n\n    {\n      this.layer.update();\n      this.dispatchEvent({ type: Selection.Events.SELECTION_CHANGED });\n    } }, { key: \"onAction\", value: function onAction()\n\n    {\n\n      if (this.empty()) {\n        return;\n      }\n\n      // Single-selection: Clear selection if selected shape has gone\n      var selected = this.getSelectedShapes();\n      if (selected.length == 1) {\n        var exists = this.layer.findShapeById(selected[0].id);\n        if (!exists) {\n          this.clear();\n        }\n        return;\n      }\n\n      // Multi-selection: Same principle, but avoiding n^2 runtime for large selections\n\n      // Create dictionary of all shapes in the layer\n      var shapeIdExists = {};\n      this.layer.shapes.forEach(function (s) {return shapeIdExists[s.id] = true;});\n\n      // Clear all shapes from selection that don't exist anymore\n      selected = selected.filter(function (s) {return shapeIdExists[s.id];});\n      this.setSelection(selected);\n    } }, { key: \"onShapeRemoved\", value: function onShapeRemoved(_ref)\n\n    {var shape = _ref.shape;\n      if (this.empty()) {\n        return;\n      }\n\n      // Remove the shape from the selection if found.\n      if (this.isSelected[shape.id]) {\n        delete this.isSelected[shape.id];\n        this.modified();\n      }\n    } }, { key: \"onLayerCleared\", value: function onLayerCleared()\n\n    {\n      if (this.empty()) {\n        return;\n      }\n\n      this.clear();\n    } }, { key: \"setHoveredId\", value: function setHoveredId(\n\n    id) {\n\n      if (id === this.hoveredId) {\n        return;\n      }\n\n      this.hoveredId = id;\n      this.layer.update();\n      this.dispatchEvent({ type: Selection.Events.SELECTION_HOVER_CHANGED });\n    }\n\n    // Result may be null if selection is empty\n    // @returns {Shape|null}\n  }, { key: \"getFirstSelected\", value: function getFirstSelected() {\n      var selected = this.getSelectedShapes();\n      return selected.length ? selected[0] : null;\n    } }]);return Selection;}();export { Selection as default };\n\n\nSelection.Events = {\n  SELECTION_CHANGED: 'selectionChanged',\n  SELECTION_HOVER_CHANGED: 'selectionHoverChanged' };","\nimport { EllipseArcParams, Path, PolygonPath, runPath } from './EditShapes.js';\n\nimport { Path2D, Coedge, GEOMETRY_TYPES } from '@adsk/solid-definition';\n\nvar tmpVec1 = new THREE.Vector3();\nvar tmpVec2 = new THREE.Vector3();\n\n// Convert SolidDef float-array to THREE-Vector3\nvar toVec3 = function toVec3(ar) {var target = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new THREE.Vector3();\n  return target.set(ar[0], ar[1], ar[2]);\n};\n\n// Add (directed) edge segment to an Edit2D path. If path is non-empty, it is\n// assumed that it already ends at the start point of the new edge\n//  @param {Path}                     path         - Edit2D path\n//  @param {SolidDef.Coedge|SolidDef} ce           - Directed edge from SolidDef \n//  @param {number}                   loopIndex    - index of the loop in target path where we add the edge to\n//  @param {bool}                     lastLoopEdge - For the last edge in a loop, we only copy the arc params, but don't add the end vertex.\n//                                                   This is because Edit2D shapes do not repeat the start vertex at the end.\nvar addCoedge = function addCoedge(path, ce, loopIndex) {var lastLoopEdge = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n\n  var vertexCount = path.getVertexCount(loopIndex);\n\n  // Add start vertex on first call\n  if (vertexCount == 0) {\n    var pStart = ce.getStartVertex().getPosition();\n    path.addPoint(pStart[0], pStart[1], loopIndex);\n  }\n\n  // Add end point - unless this is the last edge of a loop.\n  if (!lastLoopEdge) {\n    var pEnd = ce.getEndVertex().getPosition();\n    path.addPoint(pEnd[0], pEnd[1], loopIndex);\n  }\n\n  // This function works for Coedges as well as edges. If ce is already an edge, we just set e=ce.\n  var isCoedge = ce instanceof Coedge;\n  var e = isCoedge ? ce.getEdge() : ce;\n\n  // Determine whether the curve direction is flipped. For coedges, this may happen up to twice, because\n  // cedge as well as edge have their own isReversed flag.\n  var ceReversed = isCoedge ? ce.isReversed() : false;\n  var edgeReversed = e.isReversed();\n  var isReversed = ceReversed !== edgeReversed; // logical XOR (true if exactly one of both is reversed)\n\n  var type = e.getCurveType();\n\n  // For line segments, we are done\n  if (type === GEOMETRY_TYPES.LINE) {\n    return;\n  }\n\n  // convert curve parameters for new edge\n  var edgeIndex = Math.max(vertexCount - 1, 0);\n  var curve = e.getCurve();\n\n  // Bezier case\n  if (type === GEOMETRY_TYPES.BCURVE) {\n\n    // Note that we cannot simply copy the control points of the SolidDef bcurve. Reasons:\n    //  1. Coedge or edge may be reversed (which may invert the order of the control points)\n    //  2. The edge may not cover the whole curve, but only a part of it.\n    //\n    // Due to 2. we have to construct a new cubic Bezier here based start/end tangent of the edge.\n\n    // get params at edge start/end\n    var t0 = ce.t0();\n    var t1 = ce.t1();\n\n    // get start/end point\n    var _pStart = ce.evaluatePosition(t0);\n    var _pEnd = ce.evaluatePosition(t1);\n\n    // get start/end tangent\n    var tStart = ce.evaluateDt(t0);\n    var tEnd = ce.evaluateDt(t1);\n\n    // We are searching for a cubic Bezier B with the following properties:\n    //  - Its parameter domain is [0,1], i.e. B(0)=start vertex, B(1) is end vertex\n    //  - Tangents at start/end positions are the same as for the given edge.\n\n    // Note that changing from [t0, t1] to a larger parameter domain [0,1] scales down the tangent vectors accordingly.\n    var rangeScale = Math.abs(t1 - t0);\n    tStart[0] *= rangeScale;\n    tStart[1] *= rangeScale;\n    tEnd[0] *= rangeScale;\n    tEnd[1] *= rangeScale;\n\n    // The start tangent of a cubic bezier is 3 * (cp1-cp0). So, we can obtain cp1 from the start tangent.\n    // Same principle applies to cp2.\n    var cp1x = _pStart[0] + tStart[0] / 3;\n    var cp1y = _pStart[1] + tStart[1] / 3;\n    var cp2x = _pEnd[0] - tEnd[0] / 3;\n    var cp2y = _pEnd[1] - tEnd[1] / 3;\n\n    path.setBezierArc(edgeIndex, cp1x, cp1y, cp2x, cp2y, loopIndex);\n    return;\n  }\n\n  // Ellipse arcs\n  if (type === GEOMETRY_TYPES.ELLIPSE) {\n\n    var params = new EllipseArcParams();\n    params.rx = curve.getMajorRadius();\n    params.ry = curve.getMinorRadius();\n\n    // compute axis rotation\n    var xAxis = curve.getMajorAxis();\n    var angle = Math.atan2(xAxis[1], xAxis[0]);\n    params.rotation = THREE.Math.radToDeg(angle);\n\n    // determine largeArc flag\n    // Note that the edge may only use a subset of the curve. \n    // So, it's essential to get the range from the directed edge.\n    var range = ce.getRange();\n    var startAngle = range[0];\n    var endAngle = range[1];\n    params.largeArcFlag = endAngle - startAngle > Math.PI; // Note that endAngle is always >startAngle\n\n    // determine sweep flag: Ellipse curves in SolidDef always run ccw (sweepFlag = true).\n    // But it may be inverted if the edge direction is flipped.\n    params.sweepFlag = !isReversed;\n\n    // Note: In Edit2D, the unrotated y-axis always points up. I.e. rotation=0 means xAxis = (1,0) and yAxis = (-1,0).\n    //       In SolidDef, the axes are more flexible. As long as we don't transform the curves arbitrarily, the ellipse\n    //       axes still form a 90 degree angle. However, the ellipse coordinate system may have opposite orientation.\n    //       If this happens, we have to invert the ellipse orientation.\n    var yAxis = curve.getMinorAxis();\n    var xDir = toVec3(xAxis, tmpVec1);\n    var yDir = toVec3(yAxis, tmpVec2);\n    var needsExtraFlip = xDir.cross(yDir).z < 0;\n    if (needsExtraFlip) {\n      params.sweepFlag = !params.sweepFlag;\n    }\n\n    path.setEllipseArc(edgeIndex, params, loopIndex);\n    return;\n  }\n\n  console.error(\"Unexpected curve type\");\n};\n\n// Creates an Edit2D Path loop from a given SoliDef loop. The loop is added to the target path.\n//  @param {SolidDef.Loop} loop\n//  @param {Path}          [target]\n//  @returns {Path}\nvar loopToShape = function loopToShape(loop) {var target = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new PolygonPath();\n\n  // start new loop in target path\n  var loopIndex = target.nextFreeLoop();\n\n  // traverse coedges of the loop\n  var coedges = loop.getCoedges();\n  for (var i = 0; i < coedges.length; i++) {\n    var ce = coedges[i];\n\n    // for the last loopEdge, we only copy the arc param, but don't repeat the start vertex\n    var lastLoopEdge = i == coedges.length - 1;\n\n    // add next edge to target\n    addCoedge(target, ce, loopIndex, lastLoopEdge);\n  }\n\n  return target;\n};\n\n// Convert SolidDef face into one or more Edit2D Paths.\n// Todo: If we support multiple loops per Path, result will be a single Path\n//  @param {SolidDef.Face} face\n//  @param {Path}          [target]\n//  @returns {Path}\nvar faceToShape = function faceToShape(face) {var target = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new PolygonPath();\n\n  // convert loops and collect them into target path\n  face.getLoops().forEach(function (l) {\n    target = loopToShape(l, target);\n  });\n  return target;\n};\n\n// Convert array of faces to array of shapes\nvar facesToShape = function facesToShape(faces) {var target = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new PolygonPath();\n\n  faces.forEach(function (f) {\n    target = faceToShape(f, target);\n  });\n  return target;\n};\n\n// Convert SolidDef wire to an Edit2D Path.\n//\n// Note: This function only works for wires that don't branch and have already ordered edges.\n//       This is true for wires that we get from SolidDef.Path.\n//  @param {SolidDef.Wire} wire\nvar wireToShape = function wireToShape(wire) {\n\n  // create empty path\n  var path = new Path();\n  path.isClosed = wire.isClosed();\n\n  // add edges    \n  var edges = wire.getOrderedEdges().edges;\n  for (var i = 0; i < edges.length; i++) {\n    var edge = edges[i];\n    var lastLoopEdge = wire.isClosed() && i == edges.length - 1;\n    addCoedge(path, edge, 0, lastLoopEdge);\n  }\n  return path;\n};\n\n// Convert SolidDef path to an array of shapes\nvar pathToShape = function pathToShape(path) {\n  var body = path.getWireBody();\n  var wires = body.getWires();\n\n  if (wires.length == 0) {\n    return new Path();\n  }\n\n  var result = wireToShape(wires[0]);\n\n  // convert additional loops (if any)\n  for (var i = 1; i < wires.length; i++) {\n    var wire = wires[i];\n    var tmp = wireToShape(wire);\n    result.addLoop(tmp, 0);\n  }\n\n  return result;\n};\n\n// Convert Edit2D Path to SolidDef Path2D\nvar toSolidDefPath = function toSolidDefPath(path) {\n  var path2D = new Path2D();\n  runPath(path2D, path);\n  return path2D;\n};\n\nexport var SolidDefConvert = {\n  addCoedge: addCoedge,\n  loopToShape: loopToShape,\n  faceToShape: faceToShape,\n  facesToShape: facesToShape,\n  wireToShape: wireToShape,\n  pathToShape: pathToShape,\n  toSolidDefPath: toSolidDefPath };","function _typeof(obj) {\"@babel/helpers - typeof\";if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;};}return _typeof(obj);}import { Circle, PolyBase, Path, EdgeType, EllipseArcParams } from './EditShapes.js';\nimport { Math2D } from './Math2D.js';\n\nvar domParser = null;\n\n// SVG (de)serialization for EditShapes\n\n// Url of XML-Namespace for SVG\nvar SvgNs = \"http://www.w3.org/2000/svg\";\n\nvar exp4 = Math.pow(10, 4);\nvar limitDigits = function limitDigits(value) {var digits = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  if (!value || digits === null) {\n    return value;\n  }\n  // like value.toFixed(), but removing trailing zeros\n  var exp = digits === 4 ? exp4 : Math.pow(10, digits);\n  return Math.round(value * exp) / exp;\n};\n\nvar domToCircle = function domToCircle(circleNode) {\n\n  if (!circleNode.hasAttributes || !circleNode.hasAttributes()) {\n    throw 'No attributes available on the <circle/> node';\n  }\n  var circle = new Circle();\n  for (var i = circleNode.attributes.length - 1; i >= 0; i--) {\n    var attr = circleNode.attributes[i];\n    switch (attr.name) {\n      case 'cx':\n        circle.centerX = parseFloat(attr.value);\n        break;\n      case 'cy':\n        circle.centerY = parseFloat(attr.value);\n        break;\n      case 'r':\n        circle.radius = parseFloat(attr.value);\n        break;}\n\n  }\n  return circle;\n};\n\nvar circleToSvg = function circleToSvg(circle) {var digits = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;var stylePostFix = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n  return \"<circle cx=\\\"\".concat(limitDigits(circle.centerX, digits), \"\\\" cy=\\\"\").concat(limitDigits(circle.centerY, digits), \"\\\" r=\\\"\").concat(limitDigits(circle.radius, digits)).concat(stylePostFix, \"\\\"/>\");\n};\n\nvar domToPath = function domToPath(pathNode) {\n\n  var d = pathNode.getAttribute('d');\n  if (!d) {\n    return;\n  }\n\n  return parsePath(d);\n};\n\n// For closed paths, remove last point of each loop if it is just a repetition of the start vertex.\nvar removeDuplicateLoopEndPoints = function removeDuplicateLoopEndPoints(path) {\n\n  // Bezier applied to the last point will create an additional point which is equal to the endpoint to close the path\n  // see Path.toSVGPath(). Path is always closed, therefore we can remove the duplicate end point.\n  if (path.isClosed) {\n    var pStart = new THREE.Vector2();\n    var pEnd = new THREE.Vector2();\n    var loopCount = path.loopCount;\n    for (var l = 0; l < loopCount; l++) {\n\n      // skip invalid loops\n      var lastIndex = path.getVertexCount(l) - 1;\n      if (lastIndex < 1) {\n        continue;\n      }\n\n      // get start/end\n      pStart = path.getPoint(0, l, pStart);\n      pEnd = path.getPoint(lastIndex, l, pEnd);\n\n      var delta = Math2D.pointDelta(pStart, pEnd, 0);\n      if (!delta) {\n        path.removePoint(lastIndex, l);\n      }\n\n    }\n  }\n};\n\nvar parsePath = function parsePath(svgPath) {\n  // split at all chars but keep the char using positive look ahead\n  // sample payload for path d = M 13.882,4.8592 L 14.6757,4.738 L 13.9668,4.4896 L 14.005,4.4896 C 15.3211,5.4567,14.79,3.1599,14.6624,4.155 L 13.9189,3.8945 L 13.9189,3.8 L 14.6234,3.7516 Z\n  // results into list with glyph with position array:\n  // ['M 13.882,4.8592', 'L 14.6757,4.738', 'L 13.9668,4.4896', 'L 14.005,4.4896', 'C 15.3211,5.4567,14.79,3.1599,14.6624,4.155', 'L 13.9189,3.8945', 'L 13.9189,3.8', 'L 14.6234,3.7516', 'Z']\n  var pointStrings = svgPath.split(/ (?=[a-zA-Z])/gi);\n  var validChars = \"MLHVCZA\";\n\n  // Reused per cycle\n  var ellipseParams = new EllipseArcParams();\n  var nextPoint = new THREE.Vector2();\n\n  // the current loop that we are adding edges to\n  var loopIndex = 0;\n\n  var path = new Path();\n\n  for (var i = 0; i < pointStrings.length; i++) {\n\n    // Check for unexpected characters\n    var pointString = pointStrings[i];\n    if (validChars.indexOf(pointString[0]) === -1) {\n      throw \"\\\"\".concat(pointString[0], \"\\\" is not a supported or invalid glyph: \").concat(pointString);\n    }\n\n    var segmentIndex = path.getVertexCount(loopIndex) - 1;\n\n    // Determine edge type, position, and extra params for arcs\n    var value = pointString.substring(1);\n    switch (pointString[0]) {\n      case 'M':\n        // start new loop\n        loopIndex = path.nextFreeLoop();\n      case 'L':\n        var coords = value.split(',');\n        nextPoint.x = parseFloat(coords[0]);\n        nextPoint.y = parseFloat(coords[1]);\n        break;\n      case 'H':\n        nextPoint.x = parseFloat(value);\n        break;\n      case 'V':\n        nextPoint.y = parseFloat(value);\n        break;\n      case 'C':\n\n        // tokenize params\n        var bezierCoords = value.split(',');\n\n        // get position\n        nextPoint.x = parseFloat(bezierCoords[4]);\n        nextPoint.y = parseFloat(bezierCoords[5]);\n\n        // get bezier params                \n        var cp1x = parseFloat(bezierCoords[0]);\n        var cp1y = parseFloat(bezierCoords[1]);\n        var cp2x = parseFloat(bezierCoords[2]);\n        var cp2y = parseFloat(bezierCoords[3]);\n\n        if (segmentIndex >= 0) {\n          path.setBezierArc(segmentIndex, cp1x, cp1y, cp2x, cp2y, loopIndex);\n        } else {\n          console.error('SVG Parse error: Path is not expected to start with \"C\" command');\n        }\n        break;\n\n      case 'A':\n        // tokenize params\n        var src = value.split(',');\n\n        // get position\n        nextPoint.x = parseFloat(src[5]);\n        nextPoint.y = parseFloat(src[6]);\n\n        // read ellipse params.                \n        ellipseParams.rx = parseFloat(src[0]);\n        ellipseParams.ry = parseFloat(src[1]);\n        ellipseParams.rotation = parseFloat(src[2]);\n        ellipseParams.largeArcFlag = Boolean(parseFloat(src[3]));\n        ellipseParams.sweepFlag = Boolean(parseFloat(src[4]));\n\n        if (segmentIndex >= 0) {\n          path.setEllipseArc(segmentIndex, ellipseParams, loopIndex);\n        } else {\n          console.error('SVG Parse error: Path is not expected to start with \"A\" command');\n        }\n        break;\n      case 'Z':\n        // we are done\n        path.isClosed = true;\n        continue;}\n\n\n    // add next point\n    path.addPoint(nextPoint.x, nextPoint.y, loopIndex);\n  }\n\n  removeDuplicateLoopEndPoints(path);\n\n  return path;\n};\n\nvar pathToSvgPath = function pathToSvgPath(path) {var precision = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;var digits = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  if (!path.vertexCount) {\n    return [];\n  }\n\n  // Shortcut for restricting number of digits\n  var ld = function ld(num) {return limitDigits(num, digits);};\n\n  var svgPath = [];\n\n  // reused per loop cycle\n  var p = new THREE.Vector2();\n  var pPrev = new THREE.Vector2();\n  var params = new EllipseArcParams();\n  var cp1 = new THREE.Vector2();\n  var cp2 = new THREE.Vector2();\n\n  var loopCount = path.loopCount;\n  for (var l = 0; l < loopCount; l++) {\n\n    // Add M command for first vertex\n    var edgeCount = path.getEdgeCount(l);\n    if (edgeCount > 0) {\n      p = path.getPoint(0, l, p);\n      svgPath.push(\"M \".concat(ld(p.x), \",\").concat(ld(p.y)));\n    }\n\n    for (var i = 0; i < edgeCount; i++) {\n\n      // Vertex i is the end point of segment i-1, which defines edge type and arc params\n      var segmentIndex = i;\n      var edgeType = path.isPath() ? path.getEdgeType(segmentIndex, l) : EdgeType.Line;\n\n      // get next point. Note: If the path is closed, p will be the start vertex of the loop again.\n      var edgeEndVertex = path.nextIndex(segmentIndex, l);\n      p = path.getPoint(edgeEndVertex, l, p);\n\n      var value = '';\n      switch (edgeType) {\n\n        case EdgeType.Ellipse:\n          params = path.getEllipseArcParams(segmentIndex, l, params);\n\n          // Convert boolean flags to 1/0\n          var largeArc = params.largeArcFlag ? 1 : 0;\n          var sweep = params.sweepFlag ? 1 : 0;\n\n          value = \"A \".concat(params.rx, \",\").concat(params.ry, \",\").concat(params.rotation, \",\").concat(largeArc, \",\").concat(sweep, \",\").concat(p.x, \",\").concat(p.y);\n          break;\n\n        case EdgeType.Bezier:\n          cp1 = path.getControlPoint(segmentIndex, 1, l, cp1);\n          cp2 = path.getControlPoint(segmentIndex, 2, l, cp2);\n          value = \"C \".concat(ld(cp1.x, digits), \",\").concat(ld(cp1.y, digits), \",\").concat(ld(cp2.x, digits), \",\").concat(ld(cp2.y, digits), \",\").concat(ld(p.x, digits), \",\").concat(ld(p.y, digits));\n          break;\n\n        default:\n          {\n            // skip empty/duplicate points\n            pPrev = path.getPoint(i, l, pPrev);\n            var delta = Math2D.pointDelta(pPrev, p, digits);\n            if (!delta) {\n              continue;\n            }\n\n            if (Math.abs(delta.x) <= precision) {\n              value = \"V \".concat(ld(p.y));\n            } else if (Math.abs(delta.y) <= precision) {\n              value = \"H \".concat(ld(p.x));\n            } else {\n              value = \"L \".concat(ld(p.x), \",\").concat(ld(p.y));\n            }\n          }}\n\n\n      // For closed paths, the edge end vertex will be 0. Repeating the start vertex is only necessary if the\n      // last segment is an arc: Without repeating the start vertex at the loop end, we could not store the arc parameters in SVG.\n      var isRepeatedStartVertex = edgeEndVertex === 0;\n      if (isRepeatedStartVertex && edgeType === EdgeType.Line) {\n        // Last segment of the loop is a line. We don't need to repeat the start vertex in this case.\n        continue;\n      }\n\n      svgPath.push(value);\n    }\n\n    // For a closed path, repeat the end vertex. This is necessary to preserve arc params\n    if (path.isClosed) {\n      // close loop\n      svgPath.push('Z');\n    }\n  }\n\n  return svgPath;\n};\n\n// Extract dictionary of SVG style attributes from Edit2D style\n//  @param {Style} style\n//  @returns {Object}\nvar getSvgStyleAttributes = function getSvgStyleAttributes(style) {\n\n  var target = {};\n  target[\"stroke\"] = style.lineColor;\n  target[\"fill\"] = style.fillColor;\n  target[\"stroke-width\"] = style.lineWidth;\n\n  // omit opacities if they are 1 (default)\n  if (style.lineAlpha != 1) target[\"stroke-opacity\"] = style.lineAlpha;\n  if (style.fillAlpha != 1) target[\"fill-opacity\"] = style.fillAlpha;\n\n  return target;\n};\n\n// Converts the result of getSvgStyleAttributes to a string postfix. Since we append it\n// to other attributes, it contains a preceding space. \n// Example: ' stroke=\"rgb(0,0,0)\" fill=\"rgb(0,0,255)\" ... '\nvar getAttributePostFix = function getAttributePostFix(attribs) {\n  var str = '';\n  for (var key in attribs) {\n    str += \" \".concat(key, \"=\\\"\").concat(attribs[key], \"\\\"\");\n  }\n  return str;\n};\n\n// Apply all given attributes to a Dom Element\nvar applyAttributes = function applyAttributes(domElement, attribs) {\n  for (var key in attribs) {\n    domElement.setAttribute(key, attribs[key]);\n  }\n};\n\n// Converts a shape into a string describing an SVG path. Note that (for legacy reasons),\n// style attributes are only exported if specified in options.\n//\n// @param {Shape} shape\n// @param {Object} [options]\n// @param {number} [options.precision=0]       - accuracy for unifying duplicate points \n// @param {number} [options.digis=0]           - number of digits for number strings \n// @param {bool}   [options.exportStyle=false] - If true, we also export style attributes\n//\n// Note: We currently have to use function syntax, otherwise we cannot use 'arguments' for the legacy fallback below.\nvar toSvg = function toSvg(shape, options) {\n\n  var precision = options && options.precision || 0;\n  var digits = options && options.digits || null; // means no limitation of digits\n  var exportStyle = options && options.exportStyle || false;\n\n  // add style params if wanted\n  var stylePostfix = '';\n  if (exportStyle) {\n    var attribs = getSvgStyleAttributes(shape.style);\n    stylePostfix = getAttributePostFix(attribs);\n  }\n\n  // Legacy: Keep old code using that still passes precision/digits separately\n  // Todo: Remove this when checked with clients.\n  if (_typeof(options) !== 'object') {\n    if (typeof arguments[1] == 'number') precision = arguments[1];\n    if (typeof arguments[2] == 'number') digits = arguments[2];\n  }\n\n  if (shape instanceof Circle) {\n    return circleToSvg(shape, digits, stylePostfix);\n  }\n\n  if (!(shape instanceof PolyBase)) {\n    console.error('SVG serialization not supported for this shape: ', shape);\n    return;\n  }\n\n  // PolyBase and Path are translated to SVG Path\n  var path = pathToSvgPath(shape, precision, digits);\n\n  return \"<path d=\\\"\".concat(path.join(' '), \"\\\"\").concat(stylePostfix, \"/>\");\n};\n\n// see toSvg for options.\nvar createSvgShape = function createSvgShape(shape, options) {\n  var precision = options && options.precision || 0;\n  var digits = options && options.digits || 0;\n  var exportStyle = options && options.exportStyle || true;\n\n  // Todo: support circles and other shapes if anyone needs it.\n  if (!(shape instanceof PolyBase)) {\n    console.error('SVG serialization not supported for this shape: ', shape);\n    return;\n  }\n\n  var path = document.createElementNS(SvgNs, 'path');\n  path.setAttribute('d', pathToSvgPath(shape, precision, digits));\n\n  if (exportStyle) {\n    var attribs = getSvgStyleAttributes(shape.style);\n    applyAttributes(path, attribs);\n  }\n\n  return path;\n};\n\n// @param {string}  svg - e.g. '<path d=\"M 13.882,4.8592 L 14.6757,4.738\"/>'\nvar fromSvg = function fromSvg(svg) {\n  if (!svg) {\n    return;\n  }\n\n  // init on first use\n  domParser = domParser || new DOMParser();\n\n  var dom = domParser.parseFromString(svg, 'application/xml');\n\n  if (dom.childNodes.length !== 1) {\n    throw 'Function does only support svg with a single element: path, circle';\n  }\n  var node = dom.firstChild;\n  if (node.nodeName === 'circle') {\n    return domToCircle(node);\n  } else\n  if (node.nodeName === 'path') {\n    return domToPath(node);\n  }\n\n  throw \"Unsupported svg node type: \".concat(node.nodeName);\n};\n\n// Converts several shapes to an SVG element.\n//  @param {Object} [options]\n//  @param {Box2} [dstBox] - If specified, shapes can be rescaled to fit into a destination box for the given SVG.\n//  @param {Box2} [srcBox] - By default, srcBox is the union of all shapeBoxes. Shapes are uniformly rescaled from srcBox into dstBox.\n// see toSvg() for other options\nvar createSvgElement = function createSvgElement(shapes) {var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  // get summed box of all shapes\n  var sumBox = new THREE.Box2();\n  shapes.forEach(function (shape) {return sumBox.union(shape.getBBox());});\n\n  var srcBox = options.srcBox || sumBox;\n  var dstBox = options.dstBox || sumBox;\n\n  // Note that we always have to swap y-axis, because the y-axis direction is flipped when \n  // converting 2D world coords in LMV to SVG.\n  var scaleOptions = {\n    preserveAspect: true,\n    flipY: true };\n\n  var tf = Math2D.getFitToBoxTransform(srcBox, dstBox, scaleOptions);\n\n  // get required size of svg\n  var width = dstBox.max.x - dstBox.min.x;\n  var height = dstBox.max.y - dstBox.min.y;\n\n  // create svg root element      \n  var svg = document.createElementNS(SvgNs, 'svg');\n  svg.setAttribute('height', width);\n  svg.setAttribute('width', height);\n\n  // rescale & convert each shape\n  shapes.forEach(function (shape) {\n    var scaledShape = shape.clone().applyMatrix4(tf);\n    var path = createSvgShape(scaledShape, options);\n    svg.appendChild(path);\n  });\n\n  return svg;\n};\n\nexport var Svg = {\n  toSvg: toSvg,\n  fromSvg: fromSvg,\n  createSvgShape: createSvgShape,\n  createSvgElement: createSvgElement };","function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError(\"Cannot call a class as a function\");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;} // A tangent gizmo is a dashed line with two vertex gizmos at the end.\n// It is used to control tangents for Bezier arcs.\n\nimport { Math2D } from './Math2D.js';\nimport { Polyline } from './EditShapes.js';\nimport { VertexGizmo } from './CanvasGizmo.js';\nimport { Actions } from './Actions.js';\n\nvar tangentGizmoName = function tangentGizmoName(vertexIndex, loopIndex, sideIndex) {\n  return \"TangentGizmo-$loopIndex-$vertexIndex-$sideIndex\";\n};\n\n// Indicates which endpoint of the tangent is being dragged\nvar DragIndex = {\n  None: -1, // Nothing dragged\n  Start: 0, // Dragging start point\n  End: 1 // Dragging end point\n};\n\nvar tmpVec = new THREE.Vector2();var\n\nTangentGizmo = /*#__PURE__*/function () {\n\n  function TangentGizmo(path, index, loopIndex, layer, gizmoLayer, gizmoManager, undoStack) {_classCallCheck(this, TangentGizmo);\n\n    this.path = path;\n    this.gizmoLayer = gizmoLayer;\n    this.layer = layer;\n    this.gizmoManager = gizmoManager; // Used to track which gizmo is under mouse\n    this.undoStack = undoStack;\n\n    // index of the vertex whose tangent we control\n    this.index = index;\n    this.loopIndex = loopIndex;\n\n    // dashed tangent line\n    this.line = new Polyline();\n    this.lineVisible = false;\n\n    // configure style of dashed line\n    this.line.style.isScreenSpace = true;\n    this.line.style.lineColor = 'rgb(255, 0, 255)',\n    this.line.style.lineWidth = 1.0,\n    this.line.style.lineStyle = 10;\n    this.line.style.lineAlpha = 1.0;\n\n    // VertexGizmos at both ends of the tangent line\n    this.vertexGizmo1 = new VertexGizmo(this.gizmoLayer, 0, 0, tangentGizmoName(index, loopIndex, 1));\n    this.vertexGizmo2 = new VertexGizmo(this.gizmoLayer, 0, 0, tangentGizmoName(index, loopIndex, 2));\n\n    // Hide vertex gizmos until we have proper positions\n    this.vertexGizmo1.setVisible(false);\n    this.vertexGizmo2.setVisible(false);\n\n    // Start/end vertex of tangent Gizmo\n    this.pStart = new THREE.Vector2();\n    this.pEnd = new THREE.Vector2();\n\n    // Add this to main layer. This triggers this.update() on layer updates to respond to\n    // vertex position changes.\n    this.layer.addCanvasGizmo(this);\n\n    // 0: dragging startPoint, 1: dragging endPoint, 2: nothing dragged\n    this.dragIndex = DragIndex.None;\n\n    // Last tracked dragging position for currently dragged vertex\n    this.lastDragPos = new THREE.Vector2(); // in layer coords\n\n    // When dragging vertices, we store the offset (in layer-coords) between \n    // the accurate click position and the center of the clicked vertex gizmo\n    this.dragOffset = new THREE.Vector2(0, 0); // in pixels\n\n    // An action used during a drag operation\n    this.action = null;\n\n    this.update();\n  }_createClass(TangentGizmo, [{ key: \"dtor\", value: function dtor()\n\n    {\n      this.setVisible(false);\n      this.layer.removeCanvasGizmo(this);\n    } }, { key: \"setVisible\", value: function setVisible(\n\n    visible) {\n\n      this.vertexGizmo1.setVisible(visible);\n      this.vertexGizmo2.setVisible(visible);\n\n      // Show/Hide tangent line gizmo\n      if (visible !== this.lineVisible) {\n        if (visible) {\n          this.gizmoLayer.addShape(this.line);\n        } else {\n          this.gizmoLayer.removeShape(this.line);\n        }\n      }\n      this.lineVisible = visible;\n    } }, { key: \"update\", value: function update()\n\n    {\n\n      // get index of previous edge (ending at the vertex)\n      var prevEdgeIndex = this.path.edgeBeforeVertex(this.index, this.loopIndex);\n      var nextEdgeIndex = this.path.edgeAfterVertex(this.index, this.loopIndex);\n\n      // prev/next edge may not exist in case of polyline paths\n      var prevEdgeExists = prevEdgeIndex !== -1;\n      var nextEdgeExists = nextEdgeIndex !== -1;\n\n      // Check which of the adjacent edges are arcs\n      var prevIsArc = prevEdgeExists && this.path.isBezierArc(prevEdgeIndex, this.loopIndex);\n      var nextIsArc = nextEdgeExists && this.path.isBezierArc(nextEdgeIndex, this.loopIndex);\n\n      // If none of the edges is an Arc, just hide all gizmos\n      if (!prevIsArc && !nextIsArc) {\n        this.setVisible(false);\n        return;\n      }\n\n      // Compute both endpoints of tangent gizmo\n      var p = this.path.getPoint(this.index, this.loopIndex, tmpVec);\n      if (nextIsArc) {\n\n        // End point is first control point of the arc starting at p\n        this.pEnd = this.path.getControlPoint(this.index, 1, this.loopIndex, this.pEnd);\n\n        // In general, the start point would be cp2 of the previous arc. \n        // But, we enforce tangents to be identical for previous edge and next edge.\n        // Therefore, we obtain the other endpoint by mirroring the tangent of the leaving edge\n        // on point p\n        Math2D.mirrorPointOnPoint(this.pEnd, p, this.pStart);\n      } else {\n        // Only previous edge is an arc: We have to obtain the tangent from\n        // control point 2 of the previous edge.\n        this.pStart = this.path.getControlPoint(prevEdgeIndex, 2, this.loopIndex, this.pStart);\n\n        Math2D.mirrorPointOnPoint(this.pStart, p, this.pEnd);\n      }\n\n      // update vertex gizmos\n      this.vertexGizmo1.setPosition(this.pStart.x, this.pStart.y);\n      this.vertexGizmo2.setPosition(this.pEnd.x, this.pEnd.y);\n\n      // update line gizmo\n      this.line.makeLine(this.pStart.x, this.pStart.y, this.pEnd.x, this.pEnd.y);\n      this.gizmoLayer.update();\n\n      this.setVisible(true);\n    }\n\n    // Apply modified tangent endpoints after dragging on of the tangent vertices.\n    //\n    // @param {Vector2} pStart, pEnd - Tangent start/end point in layer coords.\n  }, { key: \"updateAction\", value: function updateAction(pStart, pEnd) {\n\n      // Init action for the current drag-interaction (if needed)\n      if (!this.action) {\n        this.action = new Actions.ChangeBezierTangent(this.layer, this.path, this.index, this.loopIndex, pStart, pEnd);\n      } else {\n        // However, for this specific action, it makes no difference.            \n        this.action.setTangent(pStart, pEnd);\n      }\n\n      // In general, we need to undo() an action before calling redo() again. But, for this specific action,\n      // it does not make a difference, because we are overwriting the same control points.\n      this.action.redo();\n\n      // update gizmos\n      this.update();\n    }\n\n    // @param {Vector2} newPos - new position in layer coords\n  }, { key: \"onStartVertexMoved\", value: function onStartVertexMoved(startPos) {\n      // get new tangent end point by mirroring on vertex position\n      var center = this.path.getPoint(this.index, this.loopIndex);\n      var endPos = Math2D.mirrorPointOnPoint(startPos, center);\n\n      this.updateAction(startPos, endPos);\n    }\n\n    // @param {Vector2} startPos - new position in layer coords\n  }, { key: \"onEndVertexMoved\", value: function onEndVertexMoved(endPos) {\n      // get new tangent start point by mirroring on vertex position\n      var center = this.path.getPoint(this.index, this.loopIndex);\n      var startPos = Math2D.mirrorPointOnPoint(endPos, center);\n\n      this.updateAction(startPos, endPos);\n    }\n\n    // @param {DragIndex} dragIndex\n  }, { key: \"startDrag\", value: function startDrag(canvasX, canvasY, dragIndex) {\n\n      this.dragIndex = dragIndex;\n\n      // Store offset between exact mouse pos and the vertex we are dragging\n      var vpos = dragIndex === DragIndex.Start ? this.pStart : this.pEnd;\n      var vposScreen = this.layer.layerToCanvas(vpos.x, vpos.y);\n      this.dragOffset.set(vposScreen.x - canvasX, vposScreen.y - canvasY);\n\n      this.lastDragPos.copy(vpos);\n    }\n\n    // process last position and finish dragging\n  }, { key: \"endDrag\", value: function endDrag(canvasX, canvasY) {\n      this.moveDrag(canvasX, canvasY);\n\n      // Mark action as finished. It is important to do this before running the action,\n      // because PolygonEditTool cancels unfinished dragging operations on external actions.\n      this.dragIndex = DragIndex.None;\n\n      // apply the action\n      if (this.action) {\n        this.undoStack.run(this.action);\n        this.action = null;\n      }\n    } }, { key: \"cancelDrag\", value: function cancelDrag()\n\n    {\n      if (!this.isDragging()) {\n        return;\n      }\n\n      this.dragIndex = DragIndex.None;\n      this.action && this.action.undo();\n      this.action = null;\n    } }, { key: \"moveDrag\", value: function moveDrag(\n\n    canvasX, canvasY) {\n\n      // Compute canvas position of the gizmo after drag\n      // Note that the vertex we are dragging does not always match exactly with the mouse position. \n      // E.g., we may have picked the bottom-left boundary of a vertex gizmo at drag-start.\n      var x = canvasX + this.dragOffset.x;\n      var y = canvasY + this.dragOffset.y;\n      var p = this.layer.canvasToLayer(x, y);\n\n      // Move tangent vertex by dx/dy\n      if (this.dragIndex === DragIndex.Start) {\n        this.onStartVertexMoved(p);\n      } else if (this.dragIndex === DragIndex.End) {\n        this.onEndVertexMoved(p);\n      }\n\n      this.layer.update();\n    }\n\n    // @returns {bool} true if dragging started\n  }, { key: \"onButtonDown\", value: function onButtonDown(canvasX, canvasY) {\n\n      var startDragged = this.gizmoManager.isUnderMouse(this.vertexGizmo1);\n      var endDragged = this.gizmoManager.isUnderMouse(this.vertexGizmo2);\n\n      if (!startDragged && !endDragged) {\n        return false;\n      }\n\n      var dragIndex = startDragged ? DragIndex.Start : DragIndex.End;\n      this.startDrag(canvasX, canvasY, dragIndex);\n\n      return true;\n    } }, { key: \"isDragging\", value: function isDragging()\n\n    {\n      return this.dragIndex !== DragIndex.None;\n    } }]);return TangentGizmo;}();export { TangentGizmo as default };\n;","var Drag = 'drag';\nvar Click = 'click';\nvar ButtonDown = 'buttonDown';\nvar ButtonUp = 'buttonUp';\n\nexport var Trackings = {\n  ButtonDown: ButtonDown,\n  ButtonUp: ButtonUp,\n  Click: Click,\n  Drag: Drag };","function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError(\"Cannot call a class as a function\");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}\nvar av = Autodesk.Viewing;var\n\nUndoStack = /*#__PURE__*/function () {\n\n  function UndoStack() {_classCallCheck(this, UndoStack);\n\n    av.EventDispatcher.prototype.apply(this);\n\n    // Array of action objects\n    this.stack = [];\n\n    // By default, this simply points to the end of this.stack. Only if undo has been called, \n    // it points to the next operation to be run on a redo() call\n    this.current = 0;\n  }\n\n  // Executes an action and pushes it to the undo stack\n  _createClass(UndoStack, [{ key: \"run\", value: function run(action) {\n      // If we did a couple of undos before, a new operation will clear all redo steps\n      this.stack.length = this.current;\n\n      this.dispatchEvent({ type: UndoStack.BEFORE_ACTION, action: action });\n\n      action.redo();\n\n      this.dispatchEvent({ type: UndoStack.AFTER_ACTION, action: action });\n\n      this.stack.push(action);\n      this.current = this.stack.length;\n    } }, { key: \"undo\", value: function undo()\n\n    {\n      if (!this.current) {\n        // We reached the beginning of the stack\n        return false;\n      }\n      this.current--;\n\n      var action = this.stack[this.current];\n\n      this.dispatchEvent({ type: UndoStack.BEFORE_ACTION, action: action, isUndo: true });\n\n      action.undo();\n\n      this.dispatchEvent({ type: UndoStack.AFTER_ACTION, action: action, isUndo: true });\n\n      action.layer.update();\n\n      return true;\n    } }, { key: \"redo\", value: function redo()\n\n    {\n      var action = this.stack[this.current];\n      if (!action) {\n        // Nothing to redo\n        return false;\n      }\n\n      this.dispatchEvent({ type: UndoStack.BEFORE_ACTION, action: action, isUndo: false });\n\n      action.redo();\n\n      this.dispatchEvent({ type: UndoStack.AFTER_ACTION, action: action, isUndo: false });\n\n      this.current++;\n\n      action.layer.update();\n\n      return true;\n    } }, { key: \"clear\", value: function clear()\n\n    {\n      this.stack.length = 0;\n      this.current = 0;\n    } }]);return UndoStack;}();\n\n\n// Events sent before/after any action is executed by UndoStack\nexport { UndoStack as default };UndoStack.BEFORE_ACTION = 'beforeAction';\nUndoStack.AFTER_ACTION = 'afterAction';","function _typeof(obj) {\"@babel/helpers - typeof\";if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;};}return _typeof(obj);}function _get(target, property, receiver) {if (typeof Reflect !== \"undefined\" && Reflect.get) {_get = Reflect.get;} else {_get = function _get(target, property, receiver) {var base = _superPropBase(target, property);if (!base) return;var desc = Object.getOwnPropertyDescriptor(base, property);if (desc.get) {return desc.get.call(receiver);}return desc.value;};}return _get(target, property, receiver || target);}function _superPropBase(object, property) {while (!Object.prototype.hasOwnProperty.call(object, property)) {object = _getPrototypeOf(object);if (object === null) break;}return object;}function _inherits(subClass, superClass) {if (typeof superClass !== \"function\" && superClass !== null) {throw new TypeError(\"Super expression must either be null or a function\");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}function _createSuper(Derived) {var hasNativeReflectConstruct = _isNativeReflectConstruct();return function _createSuperInternal() {var Super = _getPrototypeOf(Derived),result;if (hasNativeReflectConstruct) {var NewTarget = _getPrototypeOf(this).constructor;result = Reflect.construct(Super, arguments, NewTarget);} else {result = Super.apply(this, arguments);}return _possibleConstructorReturn(this, result);};}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");}return self;}function _isNativeReflectConstruct() {if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;if (Reflect.construct.sham) return false;if (typeof Proxy === \"function\") return true;try {Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));return true;} catch (e) {return false;}}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError(\"Cannot call a class as a function\");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}import { DefaultMeasureTransform } from './MeasureTransform.js';\n\nvar avp = Autodesk.Viewing.Private;\n\n// Interface to control display of length/area units.\nexport var UnitHandler = /*#__PURE__*/function () {\n\n  function UnitHandler() {_classCallCheck(this, UnitHandler);\n    // Optional: Returns a transform that is applied to all points for length/area calculations.\n    //  @returns {MeasureTransform}\n    this.measureTransform = null;\n  }\n\n  // @param   {number} val - length in layer coords\n  // @returns {string} String to display, including units.\n  _createClass(UnitHandler, [{ key: \"lengthToString\", value: function lengthToString(val) {\n      console.error('Not implemented');\n    }\n\n    // @param   {number} val - area in layer coords\n    // @returns {string} String to display - including units.\n  }, { key: \"areaToString\", value: function areaToString(val) {\n      console.error('Not implemented');\n    } }]);return UnitHandler;}();\n;\n\n// If nothing is specified, we display with 2 digits and assume all unit in inches.\nvar DefaultPrecision = 2;\nvar DefaultUnits = \"inch\";\n\n// Format length / area strings based on:\n//  - layerUnits:  We assume the layer to be specified in these units.\n//  - displayUnit: Values are converted from layerUnits to displayUnits for display\n//  - precision:   Number of digits shown\n//  - scaleFactor: Optional scale factor applied to all values\nexport var SimpleUnitHandler = /*#__PURE__*/function (_UnitHandler) {_inherits(SimpleUnitHandler, _UnitHandler);var _super = _createSuper(SimpleUnitHandler);\n\n  function SimpleUnitHandler(viewer) {var _this;_classCallCheck(this, SimpleUnitHandler);\n    _this = _super.call(this);\n\n    _this.viewer = viewer;\n\n    _this.config = {\n      // {string} We assume layers to be in these units (in GNU units format)\n      layerUnits: DefaultUnits,\n\n      // {string} Units in which we display lengths/areas (in GNU units format)\n      displayUnits: DefaultUnits,\n\n      // {number} Number of digits that we display\n      precision: DefaultPrecision,\n\n      // {number} Optional scale factor applied to all values\n      scaleFactor: 1.0,\n\n      // {string} Optional area suffix to alter display unit\n      areaSuffix: '^2',\n\n      // {boolean} Optional flag for mixed unit measurements such as m-and-cm to fallback to the larger unit\n      noMixedArea: false,\n\n      // {boolean} Optional flag for inches and feet, use 'in' and 'ft' over ' and \" respectively.\n      preferLetters: false };return _this;\n\n  }_createClass(SimpleUnitHandler, [{ key: \"lengthToString\", value: function lengthToString(\n\n    val) {\n      var cfg = this.config;\n\n      // Convert length units\n      val = avp.convertUnits(cfg.layerUnits, cfg.displayUnits, cfg.scaleFactor, val);\n\n      // Format length value with unit string\n      return avp.formatValueWithUnits(val, cfg.displayUnits, 3, cfg.precision, { preferLetters: cfg.preferLetters });\n    } }, { key: \"areaToString\", value: function areaToString(\n\n    val) {\n      var cfg = this.config;\n\n      // Convert area units\n      val = avp.convertUnits(cfg.layerUnits, cfg.displayUnits, cfg.scaleFactor, val, 'square');\n\n      // Format area value with unit string\n      var units = cfg.displayUnits ? \"\".concat(cfg.displayUnits).concat(cfg.areaSuffix) : null;\n      return avp.formatValueWithUnits(val, units, 3, cfg.precision, { noMixedArea: cfg.noMixedArea, preferLetters: cfg.preferLetters });\n    } }]);return SimpleUnitHandler;}(UnitHandler);\n\n\n// The DefaultUnitHandler synchronizes the unit configuration based on current viewer model \n// and current settings from MeasureToolExtension:\n//  - If MeasureExtension is loaded, it displays in the same way as Measure tools\n//  - If MeasureExtension is not loaded, it just uses units of the current model without unit conversion.\n//  - If there is not even a model, it falls back to a fixed default configuration (see SimpleUnitHandler)\nexport var DefaultUnitHandler = /*#__PURE__*/function (_SimpleUnitHandler) {_inherits(DefaultUnitHandler, _SimpleUnitHandler);var _super2 = _createSuper(DefaultUnitHandler);\n\n  function DefaultUnitHandler(viewer) {var _this2;_classCallCheck(this, DefaultUnitHandler);\n    _this2 = _super2.call(this, viewer);\n\n    _this2.measureTransform = new DefaultMeasureTransform(viewer);return _this2;\n  }_createClass(DefaultUnitHandler, [{ key: \"updateConfig\", value: function updateConfig()\n\n    {\n      var cfg = this.config;\n\n      // Assume values to be in model units or default units\n      var model = this.viewer.model;\n      cfg.layerUnits = model ? model.getUnitString() : DefaultUnits;\n\n      // Set other configuration values\n      var ext = this.viewer.getExtension('Autodesk.Measure');\n      var msrCfg = ext && ext.sharedMeasureConfig;\n      if (msrCfg) {\n        // get from measure extension\n        cfg.displayUnits = msrCfg.units;\n        cfg.precision = msrCfg.precision;\n        cfg.scaleFactor = msrCfg.calibrationFactor || 1.0;\n      } else {\n        // No Measure extension available => use defaults\n        cfg.displayUnits = this.config.layerUnits;\n        cfg.precision = DefaultPrecision;\n        cfg.scaleFactor = 1.0;\n      }\n    } }, { key: \"lengthToString\", value: function lengthToString(\n\n    val) {\n      this.updateConfig();\n      return _get(_getPrototypeOf(DefaultUnitHandler.prototype), \"lengthToString\", this).call(this, val);\n    } }, { key: \"areaToString\", value: function areaToString(\n\n    val) {\n      this.updateConfig();\n      return _get(_getPrototypeOf(DefaultUnitHandler.prototype), \"areaToString\", this).call(this, val);\n    } }, { key: \"getPrecision\", value: function getPrecision()\n\n    {\n      this.updateConfig();\n      return this.config.precision;\n    }\n\n    // Convert from current display units to the given units, considering the scale factor backwards.\n  }, { key: \"fromDisplayUnits\", value: function fromDisplayUnits(toUnits, value) {\n      this.updateConfig();\n      return avp.convertUnits(this.config.displayUnits, toUnits, 1.0 / this.config.scaleFactor, value);\n    }\n\n    // Same for Vec3 value\n  }, { key: \"fromDisplayUnitsVec3\", value: function fromDisplayUnitsVec3(toUnits, vec) {var target = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new THREE.Vector3();\n      this.updateConfig();\n      target.x = this.fromDisplayUnits(toUnits, vec.x);\n      target.y = this.fromDisplayUnits(toUnits, vec.y);\n      target.z = this.fromDisplayUnits(toUnits, vec.z);\n      return target;\n    }\n\n    // Convert from current given fromUnits to display units, considering the current scale factor.\n  }, { key: \"toDisplayUnits\", value: function toDisplayUnits(fromUnits, value) {\n      this.updateConfig();\n      return avp.convertUnits(fromUnits, this.config.displayUnits, this.config.scaleFactor, value);\n    }\n\n    // Same for Vec3 value\n  }, { key: \"toDisplayUnitsVec3\", value: function toDisplayUnitsVec3(fromUnits, vec) {var target = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new THREE.Vector3();\n      this.updateConfig();\n      target.x = this.toDisplayUnits(fromUnits, vec.x);\n      target.y = this.toDisplayUnits(fromUnits, vec.y);\n      target.z = this.toDisplayUnits(fromUnits, vec.z);\n      return target;\n    }\n\n    // @returns {string} name of the display unit, e.g. \"ft\" or \"m\".\n  }, { key: \"getDisplayUnit\", value: function getDisplayUnit() {\n      this.updateConfig();\n      return this.config.displayUnits;\n    }\n\n    // @returns {string} Similar to getDisplayUnit(), but simplifies combined units like \"decimal-feet\" or \"ft-and-fractional-in\" stuff to just \"ft\".\n  }, { key: \"getMainDisplayUnit\", value: function getMainDisplayUnit() {\n      var unit = this.getDisplayUnit();\n      return Autodesk.Viewing.Private.getMainUnit(unit);\n    } }]);return DefaultUnitHandler;}(SimpleUnitHandler);","/**\n * Include each locale json file and return it in an object\n * that can be consumed by i18n\n */\n\nimport json_en from '../../res/locales/en/nobundle-edit2d.loc';\nimport json_en_GB from '../../res/locales/en-GB/nobundle-edit2d.loc';\nimport json_cs from '../../res/locales/cs/nobundle-edit2d.loc';\nimport json_de from '../../res/locales/de/nobundle-edit2d.loc';\nimport json_es from '../../res/locales/es/nobundle-edit2d.loc';\nimport json_fr from '../../res/locales/fr/nobundle-edit2d.loc';\nimport json_fr_CA from '../../res/locales/fr-CA/nobundle-edit2d.loc';\nimport json_it from '../../res/locales/it/nobundle-edit2d.loc';\nimport json_ja from '../../res/locales/ja/nobundle-edit2d.loc';\nimport json_ko from '../../res/locales/ko/nobundle-edit2d.loc';\nimport json_pl from '../../res/locales/pl/nobundle-edit2d.loc';\nimport json_pt_BR from '../../res/locales/pt-BR/nobundle-edit2d.loc';\nimport json_ru from '../../res/locales/ru/nobundle-edit2d.loc';\nimport json_tr from '../../res/locales/tr/nobundle-edit2d.loc';\nimport json_zh_HANS from '../../res/locales/zh-HANS/nobundle-edit2d.loc';\nimport json_zh_HANT from '../../res/locales/zh-HANT/nobundle-edit2d.loc';\nimport json_zh_HK from '../../res/locales/zh-HK/nobundle-edit2d.loc';\nimport json_nl from '../../res/locales/nl/nobundle-edit2d.loc';\nimport json_sv from '../../res/locales/sv/nobundle-edit2d.loc';\nimport json_da from '../../res/locales/da/nobundle-edit2d.loc';\n\nexport var locales = {\n  en: json_en,\n  \"en-GB\": json_en_GB,\n  cs: json_cs,\n  de: json_de,\n  es: json_es,\n  fr: json_fr,\n  \"fr-CA\": json_fr_CA,\n  it: json_it,\n  ja: json_ja,\n  ko: json_ko,\n  pl: json_pl,\n  \"pt-BR\": json_pt_BR,\n  ru: json_ru,\n  tr: json_tr,\n  \"zh-HANS\": json_zh_HANS,\n  \"zh-HANT\": json_zh_HANT,\n  \"zh-HK\": json_zh_HK,\n  nl: json_nl,\n  sv: json_sv,\n  da: json_da };","function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError(\"Cannot call a class as a function\");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}import { Actions } from '../Actions.js';\nimport Clipboard from '../Clipboard.js';\n\nvar CopyToolName = 'Edit2_CopyTool';\n\nvar av = Autodesk.Viewing;\n\n// Apply constant offset in x/y for each paste step, so that pasted shapes are not exactly on top of the src shapes.\nvar PasteOffset = 30;var\n\nCopyTool = /*#__PURE__*/function () {\n\n  function CopyTool(ctx) {var _this = this;_classCallCheck(this, CopyTool);\n\n    Autodesk.Viewing.EventDispatcher.prototype.apply(this);\n\n    this.viewer = ctx.viewer;\n    this.layer = ctx.layer;\n    this.selection = ctx.selection;\n    this.undoStack = ctx.undoStack;\n    this.clipboard = ctx.clipboard;\n    this.nameSuffix = \"_\".concat(ctx.toolSetName);\n\n    this.enableCut = false;\n\n    // Track when this tool is posting shapes to the clipboard.\n    // Used to avoid modifying the pasteCounter when this tool is posting shapes.\n    // This is a reference to the array being posted or null. An array is used rather than\n    // a flag in case a clipboard listener posts to the clipboard during a callback.\n    this.shapesBeingPosted = null;\n    // Tracks the number of times the clipboard contents have been pasted.\n    // Pasted shapes are offset whenever the counter is greater than zero.\n    // Set the counter to a negative value to prevent offsetting for some pastes.\n    this.pasteCounter = 0;\n\n    this.onClipboardContentChanged = function (event) {\n      if (event.shapes !== _this.shapesBeingPosted) {\n        // Do not apply offset to the first paste of content placed on the clipboard by other code\n        // to preserve its location\n        _this.pasteCounter = -1;\n      }\n    };\n  }_createClass(CopyTool, [{ key: \"register\", value: function register()\n\n    {\n      this.clipboard.addEventListener(Clipboard.CONTENT_CHANGED, this.onClipboardContentChanged);\n    } }, { key: \"deregister\", value: function deregister()\n\n    {\n      this.clipboard.removeEventListener(Clipboard.CONTENT_CHANGED, this.onClipboardContentChanged);\n    } }, { key: \"_postSelectedShapesToClipboard\", value: function _postSelectedShapesToClipboard()\n\n    {\n      var shapes = this.selection.getSelectedShapes();\n\n      this.shapesBeingPosted = shapes;\n      this.clipboard.postShapes(shapes);\n      this.shapesBeingPosted = null;\n\n      return shapes;\n    }\n\n\n    /**\n       * Copy the currently selected shapes to the clipboard.\n       *\n       * Each time the shapes are pasted, they will be offset from their original positions (first paste)\n       * or their last pasted positions. The offset currently doesn't change with the undo/redo of paste operations.\n       */ }, { key: \"copy\", value: function copy()\n    {\n      this._postSelectedShapesToClipboard();\n      this.pasteCounter = 0;\n    }\n\n    /**\n       * Cut the currently selected shapes to the clipboard.\n       *\n       * Each time the shapes are pasted, they will be in their original positions (first paste)\n       * or offset from their last pasted positions. The offset currently doesn't change with the\n       * undo/redo of paste operations.\n       */ }, { key: \"cut\", value: function cut()\n    {\n      var shapes = this._postSelectedShapesToClipboard();\n      // Do not apply offset to the first paste\n      this.pasteCounter = -1;\n\n      this.undoStack.run(new Actions.RemoveShapes(this.layer, shapes));\n    }\n\n    /**\n       * Paste clones of the shapes from the clipboard.\n       *\n       * Pasting will not occur if the BEFORE_PASTE event is vetoed.\n       * Shapes may be offset from their original or previously pasted positions depending on\n       * how they were posted to the clipboard (whether by this tool's copy/cut operations,\n       * or application code)\n       */ }, { key: \"paste\", value: function paste()\n    {\n      this.pasteCounter++;\n      var shapes = this.clipboard.cloneShapes();\n\n      var beforePasteEvent = { type: CopyTool.BEFORE_PASTE, veto: false };\n      this.dispatchEvent(beforePasteEvent);\n      if (beforePasteEvent.veto) {\n        return;\n      }\n\n      if (this.pasteCounter > 0) {\n        // Compute how far we want to shift the copy that we create.\n        // We shift by 30 pixels, then by 60, etc.\n        var shapeOffset = this.pasteCounter * PasteOffset * this.layer.getUnitsPerPixel();\n        shapes.forEach(function (shape) {return shape.move(shapeOffset, shapeOffset);});\n      }\n\n      this.undoStack.run(new Actions.AddShapes(this.layer, shapes));\n      // Change selection to new shapes\n      this.selection.setSelection(shapes);\n\n      this.dispatchEvent({ type: CopyTool.AFTER_PASTE, shapes: shapes });\n    }\n\n    /**\n       * Delete all selected shapes\n       */ }, { key: \"delete\", value: function _delete()\n    {\n      var shapes = this.selection.getSelectedShapes();\n      this.undoStack.run(new Actions.RemoveShapes(this.layer, shapes));\n      this.selection.clear();\n    } }, { key: \"handleKeyDown\", value: function handleKeyDown(\n\n    event, keyCode) {\n\n      // Accept command key on Mac as alternative to ctrl.\n      var ctrlKey = event.ctrlKey || event.metaKey;\n\n      if (!this.selection.empty()) {\n        if (keyCode === av.KeyCode.DELETE) {\n          this.delete();\n          return true;\n        }\n\n        if (ctrlKey) {\n          if (keyCode === av.KeyCode.c) {\n            this.copy();\n            return true;\n          }\n          if (this.enableCut && keyCode === av.KeyCode.x) {\n            this.cut();\n            return true;\n          }\n        }\n      }\n\n      if (this.clipboard.hasShapes() && ctrlKey && keyCode === av.KeyCode.v) {\n        this.paste();\n        return true;\n      }\n\n      return false;\n    } }, { key: \"getName\",\n\n    // Some paperwork for ToolController\n    value: function getName() {\n      return CopyToolName + this.nameSuffix;\n    } }, { key: \"getNames\", value: function getNames()\n    {\n      return [this.getName()];\n    } }, { key: \"activate\", value: function activate()\n    {} }, { key: \"deactivate\", value: function deactivate()\n    {} }]);return CopyTool;}();export { CopyTool as default };\n;\n\nCopyTool.BEFORE_PASTE = \"BEFORE_PASTE\";\nCopyTool.AFTER_PASTE = \"AFTER_PASTE\";","function _typeof(obj) {\"@babel/helpers - typeof\";if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;};}return _typeof(obj);}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError(\"Cannot call a class as a function\");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}function _get(target, property, receiver) {if (typeof Reflect !== \"undefined\" && Reflect.get) {_get = Reflect.get;} else {_get = function _get(target, property, receiver) {var base = _superPropBase(target, property);if (!base) return;var desc = Object.getOwnPropertyDescriptor(base, property);if (desc.get) {return desc.get.call(receiver);}return desc.value;};}return _get(target, property, receiver || target);}function _superPropBase(object, property) {while (!Object.prototype.hasOwnProperty.call(object, property)) {object = _getPrototypeOf(object);if (object === null) break;}return object;}function _inherits(subClass, superClass) {if (typeof superClass !== \"function\" && superClass !== null) {throw new TypeError(\"Super expression must either be null or a function\");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}function _createSuper(Derived) {var hasNativeReflectConstruct = _isNativeReflectConstruct();return function _createSuperInternal() {var Super = _getPrototypeOf(Derived),result;if (hasNativeReflectConstruct) {var NewTarget = _getPrototypeOf(this).constructor;result = Reflect.construct(Super, arguments, NewTarget);} else {result = Super.apply(this, arguments);}return _possibleConstructorReturn(this, result);};}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");}return self;}function _isNativeReflectConstruct() {if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;if (Reflect.construct.sham) return false;if (typeof Proxy === \"function\") return true;try {Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));return true;} catch (e) {return false;}}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}\nimport { Actions } from '../Actions.js';\nimport { Math2D } from '../Math2D.js';\nimport { PolyIndex, PolyBase, Polyline, Style } from '../EditShapes.js';\nimport { EdgeMoveGizmo, ArcEdgeGizmo, LengthLabel } from '../CanvasGizmo.js';\nimport EditToolBase from './EditToolBase.js';\n\nvar EdgeMoveToolName = \"Edit2_EdgeMoveTool\";\n\nvar av = Autodesk.Viewing;\n\nvar edgeGizmoName = function edgeGizmoName(index) {\n  return 'PolygonEditTool_edgeGizmo_' + index.toString();\n};\n\n// Given a Polyline/Polygon and a vertex index, check if the two edges next to 'vertex' are collinear.\n// Returns false if vertex does not have 2 different neighbor edges.\nvar edgesCollinear = function edgesCollinear(poly, vertex, loopIndex) {\n\n  // If polygon/polyline just contains 0 or 1 edges, just return false.\n  var vertexCount = poly.getVertexCount(loopIndex);\n  if (vertexCount < 3) {\n    return false;\n  }\n\n  // check if neighbor edges exist\n  var isLine = poly.isPolyline();\n  var prevExists = !(isLine && vertex === 0);\n  var nextExists = !(isLine && vertex === vertexCount - 1);\n\n  // If poly has only 1 edge or 'vertex' is an end vertex of a polyline, stop here.\n  if (!prevExists || !nextExists) {\n    return false;\n  }\n\n  // get points before and after vertex\n  var prevIndex = poly.prevIndex(vertex, loopIndex);\n  var nextIndex = poly.nextIndex(vertex, loopIndex);\n\n  var precision = 1.e-5;\n\n  var a = poly.getPoint(prevIndex, loopIndex);\n  var b = poly.getPoint(vertex, loopIndex);\n  var c = poly.getPoint(nextIndex, loopIndex);\n  return Math2D.isPointOnLine(b, a, c, precision);\n};var\n\nEdgeMoveTool = /*#__PURE__*/function (_EditToolBase) {_inherits(EdgeMoveTool, _EditToolBase);var _super = _createSuper(EdgeMoveTool);\n\n  function EdgeMoveTool(ctx) {var _this;var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};_classCallCheck(this, EdgeMoveTool);\n    _this = _super.call(this, ctx);\n\n    _this.options = options;\n    _this.layer = ctx.layer;\n    _this.selection = ctx.selection;\n    _this.nameSuffix = \"_\".concat(ctx.toolSetName);\n\n    _this.keyMap.CancelEdit = av.KeyCode.ESCAPE;\n\n    // When dragging an edge, this stores a copy of its original position\n    _this.dragEdgeStartPos = {\n      a: new THREE.Vector2(),\n      b: new THREE.Vector2() };\n\n\n    // Last drag position in layer coords\n    _this.lastDragPoint = new THREE.Vector2();\n\n    // Index of the edge being dragged or -1\n    _this.draggedEdge = null; // {PolyIndex}\n\n    // When dragging an edge, selectedEdge is the same as draggedEdge. After the interaction, draggedEdge is reset to -1, but\n    // the edge keeps selected until clicking somewhere else.\n    _this.selectedEdge = null; // {PolyIndex}\n\n    // In some cases, we duplicate start/end vertex when beginning to drag an edge. This may shift this.draggedEdge by 1 or 2.\n    // draggedEdgeBefore stores the original edgeIndex before duplicating vertices.\n    _this.draggedEdgeBefore = null; //{PolyIndex};\n\n    // Reused to store edge normal of dragged edge\n    _this.draggedEdgeNormal = new THREE.Vector2();\n\n    // When dragging edges, we store the offset (in layer-coords) between the accurate click position and the center of the clicked edge gizmo\n    // Stored in pixels.\n    _this.dragOffset = new THREE.Vector2(0, 0);\n\n    // Used when dragging an edge: Indicates whether we had to duplicate\n    // start/end vertex of the edge in order to move it.\n    _this.duplicateStartVertex = false;\n    _this.duplicateEndVertex = false;\n\n    // {EdgeGizmo[][]} Array of Gizmos per loop for moving edges.\n    _this.edgeGizmos = [];\n\n    // gizmos are enabled by default.\n    _this.gizmosEnabled = true;\n\n    // Used to highlight a dragged edge in a different color by drawing a single-edge overlay.\n    _this.edgeGizmo = new Polyline();\n    _this.edgeGizmoShown = false; // indicates that gizmo is currently added to gizmoLayer\n\n    // Displays dashed lines that connect start/end vertex of arc segments\n    _this.arcEdgeGizmo = new ArcEdgeGizmo(ctx.layer, ctx.gizmoLayer);\n\n    // Create length label. Default hidden - showing is optional.\n    _this.lengthLabel = new LengthLabel(null, _this.layer, ctx.unitHandler, false);\n\n    // Constant color for highlighted edges\n    _this.edgeHighlightStyle = _this.options.edgeHighlightStyle || new Style({ lineColor: 'rgb(0, 255, 0)' });\n\n    _this.gizmoClassName = _this.options.gizmoClassName;return _this;\n  }_createClass(EdgeMoveTool, [{ key: \"getName\", value: function getName()\n\n    {\n      return EdgeMoveToolName + this.nameSuffix;\n    } }, { key: \"deactivate\", value: function deactivate()\n\n    {\n      _get(_getPrototypeOf(EdgeMoveTool.prototype), \"deactivate\", this).call(this);\n      this.reset();\n    }\n\n    // Enable the length labels (public API)\n  }, { key: \"setLengthLabelVisible\", value: function setLengthLabelVisible(visible) {\n      this.lengthLabel.setVisible(visible);\n    } }, { key: \"handleButtonDown\", value: function handleButtonDown(\n\n    event, button) {\n      // Support suppressing mouse buttons by holding a key\n      if (this.ignoreDragging) {\n        return false;\n      }\n\n      _get(_getPrototypeOf(EdgeMoveTool.prototype), \"handleButtonDown\", this).call(this, event, button);\n\n      // Only respond to left mouse button.\n      if (!button == 0) {\n        return false;\n      }\n\n      if (!this.poly) {\n        return;\n      }\n\n      this.setSelectedEdge(null);\n\n      // Handle Edge-Move: If we hit an EdgeGizmo, start dragging it\n      var selectedEdgeGizmo = this.getEdgeIndex();\n\n      if (this.edgeMovePossible() && selectedEdgeGizmo) {\n        this.startedDragging = true;\n        this.startDragEdge(event, selectedEdgeGizmo);\n        return true;\n      }\n\n      return false;\n    } }, { key: \"handleMouseMove\", value: function handleMouseMove(\n\n    event) {\n      _get(_getPrototypeOf(EdgeMoveTool.prototype), \"handleMouseMove\", this).call(this, event);\n\n      this.updateEdgeGizmo();\n\n      if (!this.poly) {\n        return false;\n      }\n\n      if (this.draggedEdge) {\n        this.moveDragEdge(event);\n\n        return true;\n      }\n\n      return false;\n    } }, { key: \"handleButtonUp\", value: function handleButtonUp(\n\n    event, button) {\n      _get(_getPrototypeOf(EdgeMoveTool.prototype), \"handleButtonUp\", this).call(this, event, button);\n\n      var wasDragging = this.startedDragging;\n      this.startedDragging = false;\n\n      if (!this.poly) {\n        return;\n      }\n\n      if (this.draggedEdge) {\n        this.endDragEdge();\n        return true;\n      }\n\n      // Consider all left-button events as handled. E.g., if dragging was cancelled using Esc,\n      // we do nothing here, but letting the mouseUp pass to navigation classes would cause camera jumps.\n      return !this.ignoreDragging && wasDragging;\n    } }, { key: \"handleKeyDown\", value: function handleKeyDown(\n\n    event, keyCode) {\n      var handled = _get(_getPrototypeOf(EdgeMoveTool.prototype), \"handleKeyDown\", this).call(this, event, keyCode);\n\n      if (keyCode === this.keyMap.CancelEdit) {\n        handled = this.cancelDrag();\n      }\n\n      return handled;\n    } }, { key: \"getCursor\", value: function getCursor()\n\n    {\n\n      if (!this.poly) {\n        return;\n      }\n\n      // Note: Vertex gizmos and edge gizmos are separate DomElements and define own mouse cursors via style.\n      // Indicate: \"Moving a gizmo\". Currently, we use the same as for shape move. Note that\n      //           the cursor for gizmo dragging must be consistent with the one we have if the mouse is on the gizmo.\n      //           Otherwise, the mouse cursor would change its state when temporarily leaving the gizmo on fast moves.\n      if (this.draggedEdge) {\n        return 'move';\n      }\n\n      // => Just default cursor\n      return undefined;\n    }\n\n    // Returns the index of the edge gizmo under mouse (or -1 if no EdgeGizmo is hit)\n    // (x,y) are in layer-coords\n    //  @returns {PolyIndex}\n  }, { key: \"getEdgeIndex\", value: function getEdgeIndex() {\n      for (var l = 0; l < this.edgeGizmos.length; l++) {\n        var gizmos = this.edgeGizmos[l];\n        var index = this.gizmoManager.getGizmoIndex(gizmos);\n        if (index !== -1) {\n          return new PolyIndex({ vertex: index, loop: l });\n        }\n      }\n      return null;\n    } }, { key: \"cancelDrag\", value: function cancelDrag()\n\n    {\n\n      var needsUpdate = false;\n\n      if (this.draggedEdge) {\n        this.restoreDragEdge();\n        this.draggedEdge = null;\n        needsUpdate = true;\n      }\n\n      if (needsUpdate) {\n        this.updateAllGizmos();\n        this.layer.update();\n      }\n\n      this.snapper.clearSnappingGizmos();\n\n      return needsUpdate;\n    } }, { key: \"handleExternalAction\", value: function handleExternalAction(\n\n    action, isUndo) {\n\n      // make sure that selected edge/vertex are still valid (or switched off)\n      this.updateSelectionState(action, isUndo);\n\n      // Stop any ongoing drag-operations (e.g., an undo operation might have removed the vertex that we are just dragging)\n      this.cancelDrag();\n\n      // Sync gizmos in case vertices were modified\n      this.updateAllGizmos();\n\n      this.snapper.clearSnappingGizmos();\n    }\n\n    // Updates selection of shape(s), vertex, and edge after an action\n  }, { key: \"updateSelectionState\", value: function updateSelectionState(action, isUndo) {\n\n      // Check if the action provides a hint how we should update selection\n      var hint = action.getSelectionHint(isUndo);\n      if (hint) {\n        this.setSelectedEdge(hint.edge);\n\n        return;\n      }\n\n      // Default behavior - if we don't know anything better:\n      //  - Keep shape selected if still existing\n      //  - Reset vertex/edge selection\n\n      // If shape was removed, reset state\n      var shapeFound = Boolean(this.poly && this.layer.findShapeById(this.poly.id));\n      if (!shapeFound) {\n        this.reset();\n      }\n\n      // If poly was modified from outside, we can't know if the selected vertex or edge\n      // still exist or have the same meaning. E.g., when undo/redoing a vertex-insert, the indices may have shifted.\n      this.setSelectedEdge(null);\n    } }, { key: \"startDragEdge\", value: function startDragEdge(\n\n    event, draggedEdge) {\n      var edgeIndex = draggedEdge.vertex;\n      var loopIndex = draggedEdge.loop;\n\n      if (this.mouseTracker) {\n        this.mouseTracker.startTracking(this.getName(), Autodesk.Edit2D.Trackings.Drag);\n      }\n\n      // store edge normal for the edge being dragged\n      this.draggedEdgeNormal = this.poly.getLeftEdgeNormal(edgeIndex, loopIndex, this.draggedEdgeNormal);\n\n      // get edge\n      var a = new THREE.Vector2();\n      var b = new THREE.Vector2();\n      this.poly.getEdge(edgeIndex, a, b, loopIndex);\n\n      // get edge direction\n      var edgeDir = Math2D.getEdgeDirection(a, b);\n\n      // compute projection of p to the line spanned by the edge\n      var pointOnEdge = this.layer.canvasToLayer(event.canvasX, event.canvasY);\n      Math2D.projectToLine(pointOnEdge, a, edgeDir);\n\n      // Set inital dragging point exactly on edge\n      this.lastDragPoint.copy(pointOnEdge);\n\n      // Store offset between exact mouse pos and the edge we are dragging\n      var edgePosScreen = this.layer.layerToCanvas(pointOnEdge.x, pointOnEdge.y);\n      this.dragOffset.set(edgePosScreen.x - event.canvasX, edgePosScreen.y - event.canvasY);\n\n      // store original position of the two edge vertices\n      var ia = edgeIndex;\n      var ib = (edgeIndex + 1) % this.poly.getVertexCount(loopIndex);\n      this.dragEdgeStartPos.a.copy(this.poly.getPoint(ia, loopIndex));\n      this.dragEdgeStartPos.b.copy(this.poly.getPoint(ib, loopIndex));\n\n      // Check if we need to duplicate start and/or end vertex of the edge.\n      // This happens when the neighbor edges are collinear with the ones being moved.\n      this.duplicateStartVertex = edgesCollinear(this.poly, ia, loopIndex);\n      this.duplicateEndVertex = edgesCollinear(this.poly, ib, loopIndex);\n\n      // Duplicate start/end vertices if necessary\n      Actions.MoveEdge.duplicateVertices(this.poly, edgeIndex, loopIndex, this.duplicateStartVertex, this.duplicateEndVertex);\n\n      // Store initial edge index (not considering any duplicated vertices)\n      this.draggedEdgeBefore = draggedEdge;\n\n      // Select the edge - using its index after duplicating vertices\n      var newEdgeIndex = Actions.MoveEdge.getNewEdgeIndex(this.poly, edgeIndex, loopIndex, this.duplicateStartVertex, this.duplicateEndVertex);\n      var polyIndex = new PolyIndex({ vertex: newEdgeIndex, loop: loopIndex });\n      this.setSelectedEdge(polyIndex);\n\n      // Set the edge being dragged\n      this.draggedEdge = polyIndex;\n\n      // Make sure that all gizmos are updated if we duplicated vertices\n      if (this.duplicateStartVertex || this.duplicateEndVertex) {\n        this.updateAllGizmos();\n      }\n    }\n\n    // If selection changes (may also be triggered outside this tool), we choose the selected polyon for editing\n  }, { key: \"onSelectionChanged\", value: function onSelectionChanged() {\n      var selected = this.selection.getSelectedShapes();\n\n      // Activate if exactly one shape is selected\n      var shape = selected.length == 1 ? selected[0] : null;\n      if (shape instanceof PolyBase) {\n        this.setEditPoly(shape);\n      } else {\n        this.setEditPoly(null);\n      }\n    }\n\n    // Finishes editing of a previous polygon\n  }, { key: \"reset\", value: function reset() {\n\n      if (!this.poly) {\n        return;\n      }\n\n      this.poly = null;\n      this.draggedEdge = null;\n      this.selectedEdge = null;\n\n      // Clear any gizmos from previous polygon\n      this.updateAllGizmos();\n\n      this.lengthLabel.setShape(null);\n\n      this.snapper.stopAngleSnapping();\n    }\n\n    // Selects a new polygon / polyline for editing\n  }, { key: \"setEditPoly\", value: function setEditPoly(poly) {\n\n      this.reset();\n\n      if (poly) {\n        this.poly = poly;\n        this.updateAllGizmos();\n      }\n\n      var polyline = poly && poly.isPolyline() ? poly : null;\n      this.lengthLabel.setShape(polyline);\n    }\n\n    // Update edgeGizmos to this.poly or hide all if poly is null\n  }, { key: \"createEdgeGizmos\", value: function createEdgeGizmos() {\n      // Make sure that we don't leak outdated ones\n      this.clearEdgeGizmos();\n\n      if (!this.gizmosEnabled) {\n        // gizmos not enabled, so don't add them.\n        return;\n      }\n\n      var hasEdgeMoveGizmos = false;\n\n      var loopCount = this.poly ? this.poly.loopCount : 0;\n      for (var l = 0; l < loopCount; l++) {\n\n        // Create gizmo per edge\n        var edgeCount = this.poly.getEdgeCount(l);\n\n        // For simple lines, we don't show the edge-move gizmo: It does not make sense to\n        // move an edge, because you can simply move the whole shape instead.\n        var needEdgeMoveGizmos = edgeCount >= 2;\n\n        var gizmos = [];\n        if (needEdgeMoveGizmos) {\n          for (var i = 0; i < edgeCount; i++) {\n            var gizmo = new EdgeMoveGizmo(this.layer, edgeGizmoName(i), undefined, this.gizmoClassName);\n            gizmo.attachToEdge(this.poly, i, l);\n            gizmos.push(gizmo);\n          }\n\n          hasEdgeMoveGizmos = true;\n        }\n\n        // add gizmos for this loop\n        this.edgeGizmos.push(gizmos);\n      }\n\n      // attach arcEdgeGizmo to current shape, so that dashed lines are displayed for its arc segments\n      this.arcEdgeGizmo.setPoly(this.poly);\n\n      this.updateEdgeGizmoHighlighting();\n\n      // Shift label a bit up to avoid it from occluding the move-edge gizmo\n      var yOffset = hasEdgeMoveGizmos ? 20 : 0;\n      this.lengthLabel.pixelOffset.set(0, yOffset);\n    } }, { key: \"moveDragEdge\", value: function moveDragEdge(\n\n    event) {\n\n      if (!this.draggedEdge) {\n        return;\n      }\n\n      var edgeIndex = this.draggedEdge.vertex;\n      var loopIndex = this.draggedEdge.loop;\n\n      // Note that the edge we are dragging does not always match exactly with the mouse position. E.g., we may have picked the bottom-left boundary of a edge gizmo at drag-start.\n      var x = event.canvasX + this.dragOffset.x;\n      var y = event.canvasY + this.dragOffset.y;\n\n      var p = this.getSnapPosition(x, y);\n\n      // get delta between last and current position\n      var delta = p.clone().sub(this.lastDragPoint);\n\n      // get indices of prev and next edge\n      var prevEdgeIndex = this.poly.prevEdgeIndex(edgeIndex, loopIndex);\n      var nextEdgeIndex = this.poly.nextEdgeIndex(edgeIndex, loopIndex);\n\n      // prev/next edge may not exist if we are at the end of a polyline\n      var prevEdgeExists = prevEdgeIndex !== -1;\n      var nextEdgeExists = nextEdgeIndex !== -1;\n\n      // Will contain the new edge endpoints\n      var newEdgeA = new THREE.Vector2();\n      var newEdgeB = new THREE.Vector2();\n\n      // get edge vertices\n      var curEdgeA = new THREE.Vector2();\n      var curEdgeB = new THREE.Vector2();\n      this.poly.getEdge(edgeIndex, curEdgeA, curEdgeB, loopIndex);\n\n      if (!prevEdgeExists && !nextEdgeExists) {\n        // If prev/next are both missing, we are moving an isoldated line segment around.\n        // In this case, we can just allow unconstrained moving and are done here.\n        newEdgeA.copy(curEdgeA).add(delta);\n        newEdgeB.copy(curEdgeB).add(delta);\n      } else {\n\n        // get next/previous edge (if existing)\n        var prevEdgeA = new THREE.Vector2();\n        var prevEdgeB = new THREE.Vector2();\n        var nextEdgeA = new THREE.Vector2();\n        var nextEdgeB = new THREE.Vector2();\n        prevEdgeExists && this.poly.getEdge(prevEdgeIndex, prevEdgeA, prevEdgeB, loopIndex);\n        nextEdgeExists && this.poly.getEdge(nextEdgeIndex, nextEdgeA, nextEdgeB, loopIndex);\n\n        // Handle start edges of polylines: Choose some \"assumed\" previous edge if there is none.\n        if (!prevEdgeExists) {\n\n          prevEdgeB.copy(curEdgeA);\n\n          if (!this.duplicateEndVertex) {\n            // Assume previous edge to be parallel to the next one. In this\n            // way, we constrain the movement only along one direction.\n            prevEdgeA.copy(nextEdgeB).sub(curEdgeB).add(curEdgeA);\n          } else {\n            // The second edge was collinear with the first, so we had to add an extra vertex at dragStart.\n            // Therefore, nextEdge is degenerated and we cannot use it.\n            // For this case, we just assume prevEdge to be perpendicular to the current edge.\n            prevEdgeA.copy(curEdgeA).add(this.draggedEdgeNormal);\n          }\n        }\n\n        // Handle end edges of polylines: Choose some \"assumed\" next edge if there is none\n        if (!nextEdgeExists) {\n\n          nextEdgeA.copy(curEdgeB);\n\n          if (!this.duplicateStartVertex) {\n            // Assume next edge to be parallel to the previous one. In this\n            // way, we constrain the movement only along one direction.\n            nextEdgeB.copy(prevEdgeA).sub(curEdgeA).add(curEdgeB);\n          } else {\n            // The previous edge was collinear with the current one, so we had to add an extra vertex at dragStart.\n            // Therefore, prevEdge is degenerated and we cannot use it.\n            // For this case, we just assume nextEdge to be perpendicular to the current edge.\n            nextEdgeB.copy(curEdgeB).add(this.draggedEdgeNormal);\n          }\n        }\n\n        // Compute directions for each edge to intersect\n        var prevEdgeDir = Math2D.getEdgeDirection(prevEdgeA, prevEdgeB);\n        var curEdgeDir = Math2D.getEdgeDirection(curEdgeA, curEdgeB);\n        var nextEdgeDir = Math2D.getEdgeDirection(nextEdgeA, nextEdgeB);\n\n        // Apply move offset\n        curEdgeA.add(delta);\n        curEdgeB.add(delta);\n\n        // If we added extra vertices, the (newly inserted) neighbor edges will be degenerated\n        // and the edge directions will be invalid. In this case, we choose the edge direction\n        // perpendicular to the edge that we are dragging.\n        if (this.duplicateStartVertex) prevEdgeDir.copy(this.draggedEdgeNormal);\n        if (this.duplicateEndVertex) nextEdgeDir.copy(this.draggedEdgeNormal);\n\n        // Compute new edge endpoints as intersection of prev/next edge with the moved line\n        if (!Math2D.intersectLines(prevEdgeA, prevEdgeDir, curEdgeA, curEdgeDir, newEdgeA) ||\n        !Math2D.intersectLines(nextEdgeA, nextEdgeDir, curEdgeA, curEdgeDir, newEdgeB)) {\n          // If we don't find an intersection, reject this edge move attempt, because\n          // it's not possible to move the edge in this way by enlarging the neighbor edges.\n          return;\n        }\n      }\n\n      // get indices of the points to modify\n      var ia = edgeIndex;\n      var ib = this.poly.nextIndex(ia, loopIndex);\n\n      // The intersections gives us the new position for the edge vertices\n      this.poly.updatePoint(ia, newEdgeA.x, newEdgeA.y, loopIndex);\n      this.poly.updatePoint(ib, newEdgeB.x, newEdgeB.y, loopIndex);\n\n      this.gizmoLayer.update();\n      this.layer.update();\n\n      this.lastDragPoint.copy(p);\n\n      // We moved the edge => Keep gizmo in-sync\n      this.updateEdgeGizmo();\n    }\n\n    // While dragging an edge, this function restores the original position at drag start\n  }, { key: \"restoreDragEdge\", value: function restoreDragEdge() {\n\n      if (!this.draggedEdge) {\n        return;\n      }\n\n      var edgeIndex = this.draggedEdge.vertex;\n      var loopIndex = this.draggedEdge.loop;\n\n      var a = this.dragEdgeStartPos.a;\n      var b = this.dragEdgeStartPos.b;\n\n      var ia = edgeIndex;\n      var ib = this.poly.nextIndex(ia, loopIndex);\n\n      this.poly.updatePoint(ia, a.x, a.y, loopIndex);\n      this.poly.updatePoint(ib, b.x, b.y, loopIndex);\n\n      // Revert insertion of extra vertices\n      Actions.MoveEdge.revertDuplicateVertices(this.poly, this.draggedEdgeBefore.vertex, loopIndex, this.duplicateStartVertex, this.duplicateEndVertex);\n\n      // If we duplicated vertices at dragStart and reverted it now,\n      // the index of the selected edge may have shifted. So, we must change it to the old one to keep to (visually) keep the same\n      // edge selected as before.\n      this.selectedEdge = this.draggedEdgeBefore;\n    } }, { key: \"endDragEdge\", value: function endDragEdge()\n\n    {\n      if (this.mouseTracker) {\n        this.mouseTracker.stopTracking(this.getName(), Autodesk.Edit2D.Trackings.Drag);\n      }\n\n      if (!this.draggedEdge) {\n        return;\n      }\n      var edgeIndex = this.draggedEdge.vertex;\n      var loopIndex = this.draggedEdge.loop;\n\n      // get final position of the edge vertices\n      var ia = edgeIndex;\n      var ib = this.poly.nextIndex(ia, loopIndex);\n\n      var newPos1 = this.poly.getPoint(ia, loopIndex);\n      var newPos2 = this.poly.getPoint(ib, loopIndex);\n\n      this.restoreDragEdge();\n\n      // If the edge was hardly moved at all, we drop the operation. Otherwise, the only effect would be to add invisible\n      // vertex duplicates.\n      var delta = this.dragEdgeStartPos.a.distanceTo(newPos1) * this.layer.getPixelsPerUnit();\n      if (delta >= 3) {\n        this.runAction(new Actions.MoveEdge(this.layer, this.poly, this.draggedEdgeBefore, newPos1, newPos2, this.duplicateStartVertex, this.duplicateEndVertex));\n\n        // If the action duplicated vertices, make sure that the selected edge is updated to\n        // the index that the selected edge has after the action.\n        this.selectedEdge = this.draggedEdge;\n      }\n\n      // Reset draggedEdge, but the edge keeps selected (we don't reset this.selectedEdge)\n      this.draggedEdge = null;\n\n      // update all gizmos\n      this.updateAllGizmos();\n    } }, { key: \"edgeMovePossible\", value: function edgeMovePossible(\n\n    loopIndex) {\n      return this.poly && this.poly.getVertexCount(loopIndex) > 2;\n    }\n\n    // Make sure that EdgeGizmo is up-to-date: Its purpose is to highlight the edge being dragged.\n  }, { key: \"updateEdgeGizmo\", value: function updateEdgeGizmo() {\n\n      // Check if mouse is on an edge gizmo\n      var edgeUnderMouse = this.getEdgeIndex(); // {PolyIndex}\n\n      var edgeMovePossible = this.edgeMovePossible();\n\n      // Check if we need any highlight\n      var edgeSelected = Boolean(this.poly && this.selectedEdge);\n      var edgeHovered = edgeMovePossible && edgeUnderMouse;\n\n      // If edge is an arc and hovered, we just colorize the arcEdgeGizmo and don't need the extra edge-highlight gizmo\n      var arcEdgeHovered = edgeHovered && this.poly.isPath() && this.poly.isArc(edgeUnderMouse.vertex, edgeUnderMouse.loop);\n\n      // We show the gizmo if an edge is selected or a line-segment is hovered. If gizmos are not enabled, don't show it\n      // regardless of mouse position.\n      var gizmoNeeded = this.gizmosEnabled ? edgeSelected || edgeHovered && !arcEdgeHovered : false;\n\n      // Make sure that edge gizmo is shown if needed\n      if (gizmoNeeded && !this.edgeGizmoShown) {\n        this.gizmoLayer.addShape(this.edgeGizmo);\n        this.edgeGizmoShown = true;\n      } else\n      if (!gizmoNeeded && this.edgeGizmoShown) {\n        this.gizmoLayer.removeShape(this.edgeGizmo);\n        this.edgeGizmoShown = false;\n      }\n\n      // get index of the edge to be highlighted\n      var polyIndex = edgeSelected ? this.selectedEdge : edgeUnderMouse; // {PolyBase}\n      var edgeToHighlight = polyIndex ? polyIndex.vertex : -1;\n      var loopIndex = polyIndex ? polyIndex.loop : -1;\n\n      // Only for arcs: Colorize ArcEdgeGizmo if needed. For hover, this replaces the highlight gizmo. For select, we just set it to the same color to avoid color conflicts.\n      var colorizeArcEdge = this.edgeGizmoShown || arcEdgeHovered;\n      colorizeArcEdge ? this.arcEdgeGizmo.setEdgeHighlighted(edgeToHighlight, loopIndex, this.edgeHighlightStyle.lineColor) : this.arcEdgeGizmo.clearEdgeHighlighting();\n\n      // If we just had to hide it, we are done here\n      if (!gizmoNeeded) {\n        return;\n      }\n\n      // Update edge gizmo position...\n\n      // get the two vertex positions of the edge\n      var a = new THREE.Vector2();\n      var b = new THREE.Vector2();\n      this.poly.getEdge(edgeToHighlight, a, b, loopIndex);\n\n      // copy values to edge gizmo\n      this.edgeGizmo.makeLine(a.x, a.y, b.x, b.y);\n\n      this.edgeGizmo.style = this.edgeHighlightStyle;\n\n      // Adopt lineWidth from selected polygon\n      this.edgeGizmo.style.lineWidth = this.poly.style.lineWidth;\n      this.edgeGizmo.style.isScreenSpace = this.poly.style.isScreenSpace;\n\n      if (edgeSelected) {\n        this.edgeGizmo.style.lineAlpha = 1.0;\n      } else {\n        // Just make it a bit brighter using a semitransparent white overlay\n        this.edgeGizmo.style.lineAlpha = 0.5;\n      }\n\n      this.gizmoLayer.update();\n    }\n\n    // @param {PolyIndex}\n  }, { key: \"setSelectedEdge\", value: function setSelectedEdge(polyIndex) {\n      this.selectedEdge = polyIndex;\n      this.updateEdgeGizmo();\n      this.updateEdgeGizmoHighlighting();\n    } }, { key: \"clearEdgeGizmos\", value: function clearEdgeGizmos()\n\n    {\n      for (var l = 0; l < this.edgeGizmos.length; l++) {\n        var gizmos = this.edgeGizmos[l];\n        for (var i = 0; i < gizmos.length; i++) {\n          gizmos[i].dtor();\n        }\n      }\n      this.edgeGizmos.length = 0;\n\n      // Clear dashed lines between start/endPoint of arcs.\n      this.arcEdgeGizmo.setPoly(null);\n    }\n\n    // Exclude currently edited polygon from snapping: The polygon shouldn't snap to itself, but rather\n    // to geometry below it.\n  }, { key: \"snappingFilter\", value: function snappingFilter(shape) {\n      return shape !== this.poly;\n    }\n\n    // Update edge gizmos (for edge highlighting)\n  }, { key: \"updateAllGizmos\", value: function updateAllGizmos() {\n      this.updateEdgeGizmo();\n      this.createEdgeGizmos();\n      this.updateEdgeGizmoHighlighting();\n      this.snapper.clearSnappingGizmos();\n    } }, { key: \"setAllGizmosEnabled\", value: function setAllGizmosEnabled(\n\n    enabled) {\n      this.gizmosEnabled = enabled;\n\n      this.updateAllGizmos();\n    }\n\n    // Update selection highlighting for edge gizmos\n  }, { key: \"updateEdgeGizmoHighlighting\", value: function updateEdgeGizmoHighlighting() {\n      if (!this.gizmosEnabled) {\n        // if gizmos are not enabled, there is nothing to highlight\n        return;\n      }\n\n      var edgeIndex = this.selectedEdge ? this.selectedEdge.vertex : -1;\n      var loopIndex = this.selectedEdge ? this.selectedEdge.loop : -1;\n\n      for (var l = 0; l < this.edgeGizmos.length; l++) {\n        var gizmos = this.edgeGizmos[l];\n        for (var i = 0; i < gizmos.length; i++) {\n          var gizmo = gizmos[i];\n          var selected = i === edgeIndex && l === loopIndex;\n          gizmo.setSelected(selected);\n        }\n      }\n    } }]);return EdgeMoveTool;}(EditToolBase);export { EdgeMoveTool as default };","function _typeof(obj) {\"@babel/helpers - typeof\";if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;};}return _typeof(obj);}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError(\"Cannot call a class as a function\");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}\n\nimport Selection from '../Selection.js';\nimport UndoStack from '../UndoStack.js';\nimport { GizmoManager } from '../CanvasGizmo.js';\n\nvar av = Autodesk.Viewing;\n\n\n// Utility class shared by Edit2D tools to facilitate snapping\nvar EditToolBase = /*#__PURE__*/function () {\n\n  function EditToolBase(ctx) {var _this = this;_classCallCheck(this, EditToolBase);\n\n    this.viewer = ctx.viewer;\n    this.setGlobalManager(this.viewer.globalManager);\n    this.layer = ctx.layer;\n    this.gizmoLayer = ctx.gizmoLayer;\n    this.snapper = ctx.snapper;\n    this.selection = ctx.selection;\n    this.undoStack = ctx.undoStack;\n    this.unitHandler = ctx.unitHandler;\n    this.nameSuffix = \"_\".concat(ctx.toolSetName);\n    this.mouseTracker = ctx.mouseTracker; // needed for tracking mouse in Edit 2D\n\n    // If true, all mouse-dragging handlers just return false, so that the events are handled by LMV navigation tools instead.\n    this.ignoreDragging = false;\n\n    // This flag is used to avoid triggering handleExternalAction if we triggered an action ourselves.\n    this.ignoreActions = false;\n\n    // If another tool applies changes while this tool is active, we want to keep the tool state consistent.\n    // E.g., the UndoTool or CopyTool may be active in parallel and may modify/remove a polygon we are working on.\n    // his event listener makes sure that handleExternalAction() is called in this case so that this tool can respond. \n    this.onActionCb = function (event) {\n      if (!_this.ignoreActions) {\n        _this.handleExternalAction(event.action, event.isUndo);\n      }\n    };\n\n    // indicates if snapping is currently suppressed by hold modifier key\n    this.suppressSnapping = false;\n\n    this.keyMap = {\n      SnapKey: av.KeyCode.SHIFT, // Holding this key suppresses snapping\n      PanKey: av.KeyCode.SPACE // Holding space bypasses all edit tools, so that default navigation (usually panning) steps in\n    };\n\n    // When using selection, register a handler to notify about selection changed\n    if (this.selection) {\n      this.selectionCb = function () {\n\n        // Only respond if tool is activated\n        if (!_this.active) {\n          return;\n        }\n\n        // Call handler if derived class defines one\n        _this.onSelectionChanged && _this.onSelectionChanged();\n      };\n\n      this.selection.addEventListener(Selection.Events.SELECTION_CHANGED, this.selectionCb);\n    }\n\n    this.active = false;\n\n    // Track last mouse position in canvas coords. Note that derived classes must call\n    // the base class mouse handlers to keep this value valid.\n    this.canvasPos = new THREE.Vector2();\n\n    // Tracks which gizmo is under mouse\n    this.gizmoManager = new GizmoManager();\n\n    // Track which keys are currently hold down\n    this.keyState = {\n      ctrl: false,\n      shift: false,\n      alt: false };\n\n  }_createClass(EditToolBase, [{ key: \"getSnapPosition\", value: function getSnapPosition(\n\n    canvasX, canvasY) {var _this2 = this;\n      var useSnapper = this.snapper && !this.suppressSnapping;\n      if (useSnapper) {\n        return this.snapper.getSnapPosition(canvasX, canvasY, function (s) {return _this2.snappingFilter(s);});\n      } else {\n        // Make sure that we don't keep outdated snapping gizmos\n        this.snapper.clearSnappingGizmos();\n\n        // Just convert canvas pos to layer pos\n        return this.layer.canvasToLayer(canvasX, canvasY);\n      }\n    } }, { key: \"dtor\", value: function dtor()\n\n    {\n      if (this.selectionCb) {\n        this.selection.removeEventListener(Selection.Events.SELECTION_CHANGED, this.selectionCb);\n      }\n    } }, { key: \"getNames\", value: function getNames()\n\n    {\n      return [this.getName()];\n    } }, { key: \"handleKeyDown\", value: function handleKeyDown(\n\n    event, keyCode) {\n\n      this.keyState[keyCode] = true;\n\n      // Hold key to suppress snapping\n      if (keyCode === this.keyMap.SnapKey && !this.suppressSnapping) {\n        this.suppressSnapping = true;\n\n        // Let tool instantly update hover-gizmos\n        this.onSnappingToggled && this.onSnappingToggled(this.canvasPos.x, this.canvasPos.y);\n      }\n\n      // While edit tools are active the BACKSPACE key should not make the browser go back in history, otherwise\n      // the customer might lose his drawings when he's in an editing session, does a invalid selection and\n      // hits backspace.\n      if (keyCode === av.KeyCode.BACKSPACE) {\n        return true;\n      }\n\n      if (keyCode === this.keyMap.PanKey) {\n        this.ignoreDragging = true;\n      }\n    } }, { key: \"handleKeyUp\", value: function handleKeyUp(\n\n    event, keyCode) {\n\n      this.keyState[keyCode] = false;\n\n      if (keyCode === this.keyMap.SnapKey && this.suppressSnapping) {\n        this.suppressSnapping = false;\n\n        // Let tool instantly update hover-gizmos\n        this.onSnappingToggled && this.onSnappingToggled(this.canvasPos.x, this.canvasPos.y);\n      }\n\n      if (keyCode === this.keyMap.PanKey) {\n        this.ignoreDragging = false;\n      }\n    }\n\n    // Invoked whenever another tool triggered \n  }, { key: \"handleExternalAction\", value: function handleExternalAction(action, isUndo) {}\n\n    // Run an action without triggering handleExternalAction\n  }, { key: \"runAction\", value: function runAction(action) {\n      this.ignoreActions = true;\n      this.undoStack.run(action);\n      this.ignoreActions = false;\n    } }, { key: \"activate\", value: function activate()\n\n    {\n      this.active = true;\n      this.undoStack.addEventListener(UndoStack.AFTER_ACTION, this.onActionCb);\n    } }, { key: \"deactivate\", value: function deactivate()\n\n    {\n      this.active = false;\n      this.undoStack.removeEventListener(UndoStack.AFTER_ACTION, this.onActionCb);\n\n      // Make sure we don't keep outdated snapping indicators\n      this.snapper && this.snapper.clearSnappingGizmos();\n    } }, { key: \"register\", value: function register()\n\n    {}\n\n    // Maps a key event to a function key in the key-map.\n  }, { key: \"mapKey\", value: function mapKey(event, keyMap) {\n\n      for (var key in keyMap) {\n        var assigned = keyMap[key];\n\n        // Skip disabled key commands\n        if (assigned === null) {\n          continue;\n        }\n\n        // If a single key is assigned to this function and it matches, return the function key\n        if (event.keyCode == assigned) {\n          return key;\n        }\n\n        // If multiple keys are assigned, check if one matches.\n        if (Array.isArray(assigned) && assigned.includes(event.keyCode)) {\n          return key;\n        }\n\n        // If it is an object, it may define modifiers and a custom filter\n        if (_typeof(assigned) === 'object') {\n          var ctrl = assigned.ctrlKey === undefined ? true : assigned.ctrlKey === event.ctrlKey;\n          var shift = assigned.shiftKey === undefined ? true : assigned.shiftKey === event.shiftKey;\n          var alt = assigned.altKey === undefined ? true : assigned.altKey === event.altKey;\n          var meta = assigned.meta === undefined ? true : assigned.metaKey === event.metaKey;\n\n          // return true if code and all (assigned) modifiers match\n          var match = assigned.keyCode === event.keyCode && ctrl && shift && alt && meta;\n          if (match) {\n            return key;\n          }\n        }\n\n        // Allow generic key-handler function\n        if (typeof assigned === 'function' && assigned(event)) {\n          return key;\n        }\n      }\n      // event does not match any assigned keyCode\n      return null;\n    } }, { key: \"snappingFilter\",\n\n    // By default, we consider all EditShapes for snapping\n    value: function snappingFilter() {\n      return true;\n    }\n\n    // pass mouse changes to method provided to extension\n  }, { key: \"trackMouseHook\", value: function trackMouseHook(event) {\n      if (this.mouseTracker) {\n        var p = this.layer.canvasToLayer(event.canvasX, event.canvasY);\n        this.mouseTracker.trackMouse(event, p);\n      }\n    }\n\n    // Remember last mouse position\n  }, { key: \"trackMousePos\", value: function trackMousePos(e) {\n      this.trackMouseHook(e);\n      this.canvasPos.set(e.canvasX, e.canvasY);\n      this.gizmoManager.update(e);\n    } }, { key: \"handleMouseMove\", value: function handleMouseMove(\n\n    e) {this.trackMousePos(e);} }, { key: \"handleSingleClick\", value: function handleSingleClick(\n    e) {this.trackMousePos(e);} }, { key: \"handleDoubleClick\", value: function handleDoubleClick(\n    e) {this.trackMousePos(e);} }, { key: \"handleButtonUp\", value: function handleButtonUp(\n    e) {this.trackMousePos(e);} }, { key: \"handleButtonDown\", value: function handleButtonDown(\n    e) {this.trackMousePos(e);} }]);return EditToolBase;}();export { EditToolBase as default };\n;\n\nav.GlobalManagerMixin.call(EditToolBase.prototype);","function _typeof(obj) {\"@babel/helpers - typeof\";if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;};}return _typeof(obj);}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError(\"Cannot call a class as a function\");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}function _inherits(subClass, superClass) {if (typeof superClass !== \"function\" && superClass !== null) {throw new TypeError(\"Super expression must either be null or a function\");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}function _createSuper(Derived) {var hasNativeReflectConstruct = _isNativeReflectConstruct();return function _createSuperInternal() {var Super = _getPrototypeOf(Derived),result;if (hasNativeReflectConstruct) {var NewTarget = _getPrototypeOf(this).constructor;result = Reflect.construct(Super, arguments, NewTarget);} else {result = Super.apply(this, arguments);}return _possibleConstructorReturn(this, result);};}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");}return self;}function _isNativeReflectConstruct() {if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;if (Reflect.construct.sham) return false;if (typeof Proxy === \"function\") return true;try {Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));return true;} catch (e) {return false;}}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}import { Style, Circle } from '../EditShapes.js';\nimport { Actions } from '../Actions.js';\nimport EditToolBase from './EditToolBase';\n\nvar InsertSymbolToolName = \"Edit2_InsertSymbolTool\";var\n\nInsertSymbolTool = /*#__PURE__*/function (_EditToolBase) {_inherits(InsertSymbolTool, _EditToolBase);var _super = _createSuper(InsertSymbolTool);\n\n  function InsertSymbolTool(ctx) {var _this;_classCallCheck(this, InsertSymbolTool);\n    _this = _super.call(this, ctx);\n\n    Autodesk.Viewing.EventDispatcher.prototype.apply(_assertThisInitialized(_this));\n\n    _this.symbol = new Circle(0, 0,\n    0.2,\n    new Style({\n      fillAlpha: 1.0,\n      lineWidth: 0.01,\n      fillColor: 'rgb(255, 255, 0)' }));return _this;\n\n  }_createClass(InsertSymbolTool, [{ key: \"getName\", value: function getName()\n\n    {\n      return InsertSymbolToolName + this.nameSuffix;\n    } }, { key: \"activate\", value: function activate()\n\n    {} }, { key: \"deactivate\", value: function deactivate()\n    {} }, { key: \"register\", value: function register()\n    {} }, { key: \"setSymbol\", value: function setSymbol(\n\n    symbol) {\n      this.symbol = symbol;\n    } }, { key: \"handleMouseMove\", value: function handleMouseMove(\n\n    event) {\n    } }, { key: \"handleSingleClick\", value: function handleSingleClick(\n\n    event) {\n\n      var res = this.layer.canvasToLayer(event.canvasX, event.canvasY);\n      var symbol = this.symbol.clone();\n      symbol.move(res.x, res.y);\n\n      this.undoStack.run(new Actions.AddShape(this.layer, symbol));\n\n      this.dispatchEvent({ type: InsertSymbolTool.SYMBOL_INSERTED, symbol: symbol });\n\n      return true;\n    } }, { key: \"handleDoubleClick\", value: function handleDoubleClick()\n\n    /*event , button */{\n      return true;\n    } }, { key: \"getCursor\", value: function getCursor()\n\n    {\n      return 'crosshair';\n    } }]);return InsertSymbolTool;}(EditToolBase);export { InsertSymbolTool as default };\n\n\nInsertSymbolTool.SYMBOL_INSERTED = \"symbolInserted\";","function _typeof(obj) {\"@babel/helpers - typeof\";if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;};}return _typeof(obj);}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError(\"Cannot call a class as a function\");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}function _inherits(subClass, superClass) {if (typeof superClass !== \"function\" && superClass !== null) {throw new TypeError(\"Super expression must either be null or a function\");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}function _createSuper(Derived) {var hasNativeReflectConstruct = _isNativeReflectConstruct();return function _createSuperInternal() {var Super = _getPrototypeOf(Derived),result;if (hasNativeReflectConstruct) {var NewTarget = _getPrototypeOf(this).constructor;result = Reflect.construct(Super, arguments, NewTarget);} else {result = Super.apply(this, arguments);}return _possibleConstructorReturn(this, result);};}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");}return self;}function _isNativeReflectConstruct() {if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;if (Reflect.construct.sham) return false;if (typeof Proxy === \"function\") return true;try {Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));return true;} catch (e) {return false;}}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}import { Polyline, PolylinePath } from '../EditShapes.js';\nimport { Actions } from '../Actions.js';\nimport { Math2D } from '../Math2D.js';\n\nimport EditToolBase from './EditToolBase.js';\nimport { Style } from '../EditShapes';\nimport { LengthLabel } from '../CanvasGizmo';\n\nvar LineToolName = \"Edit2_LineTool\";\n\nvar av = Autodesk.Viewing;\n\n// Draws lines with single drag\nvar LineTool = /*#__PURE__*/function (_EditToolBase) {_inherits(LineTool, _EditToolBase);var _super = _createSuper(LineTool);\n\n  function LineTool(ctx) {var _this;var style = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Style();_classCallCheck(this, LineTool);\n    _this = _super.call(this, ctx);\n\n    _this.style = style;\n\n    // New polyline created by dragging\n    _this.line = null;\n\n    // Start/Endpoint of the line being dragged\n    _this.startPoint = new THREE.Vector2();\n    _this.endPoint = new THREE.Vector2();\n\n    // Indicates that we interrupted dragging with Esc. In this case, we still consume the mouse-up\n    // event to avoid inconsistencies in other tool.\n    _this.dragCanceled = false;\n\n    // Create length label. Default hidden - showing is optional.\n    _this.lengthLabel = new LengthLabel(null, _this.layer, ctx.unitHandler, false);\n\n    // If true, create Paths instead of Polygons\n    _this.enableArcs = true;return _this;\n  }\n\n  // Enable the length labels (public API)\n  _createClass(LineTool, [{ key: \"setLengthLabelVisible\", value: function setLengthLabelVisible(visible) {\n      this.lengthLabel.setVisible(visible);\n    } }, { key: \"getName\", value: function getName()\n\n    {\n      return LineToolName + this.nameSuffix;\n    } }, { key: \"activate\", value: function activate()\n\n    {} }, { key: \"deactivate\", value: function deactivate()\n    {} }, { key: \"register\", value: function register()\n    {} }, { key: \"handleButtonDown\", value: function handleButtonDown(\n\n    event, button) {\n\n      // Only respond to left button\n      if (button != 0) {\n        return;\n      }\n\n      var p = this.getSnapPosition(event.canvasX, event.canvasY);\n      this.startDrag(p);\n      return true;\n    } }, { key: \"handleButtonUp\", value: function handleButtonUp(\n\n    event, button) {\n\n      // Only respond to left button\n      if (button != 0) {\n        return;\n      }\n\n      // Make sure that we consider latest end-coords\n      this.handleMouseMove(event);\n\n      // If drag has been interrupted, consider the endDrag() as handled\n      if (this.dragCanceled) {\n        this.dragCanceled = false;\n        return true;\n      }\n\n      return this.endDrag();\n    } }, { key: \"handleMouseMove\", value: function handleMouseMove(\n\n    event) {\n\n      // Get snapping position. Note that this even makes sense when not dragging: In this case, we \n      // just do it to update the snapping indicator.\n      var p = this.getSnapPosition(event.canvasX, event.canvasY);\n\n      if (!this.line) {\n        return false;\n      }\n\n      this.moveDrag(p, event.shiftKey);\n\n      return true;\n    }\n\n    // Start dragging a shape\n    //  @param {Shape}   shape\n    //  @param {Vector2} startPos - in layer coords\n  }, { key: \"startDrag\", value: function startDrag(startPos) {\n      if (this.mouseTracker) {\n        this.mouseTracker.startTracking(this.getName(), Autodesk.Edit2D.Trackings.Drag);\n      }\n      var points = [startPos.clone(), startPos.clone()];\n      var style = this.style.clone();\n\n      this.line = this.enableArcs ? new PolylinePath(points, style) : new Polyline(points, style);\n      this.startPoint.copy(startPos);\n      this.endPoint.copy(startPos);\n\n      this.gizmoLayer.addShape(this.line);\n    } }, { key: \"updateLine\", value: function updateLine()\n\n    {\n\n      if (!this.isDragging()) {\n        return;\n      }\n\n      this.line.updatePoint(1, this.endPoint.x, this.endPoint.y);\n      this.gizmoLayer.update();\n\n      this.lengthLabel.setShape(this.line);\n    }\n\n    // p is in layer coords\n  }, { key: \"moveDrag\", value: function moveDrag(p, forceQuad) {\n\n      // update rectangle\n      this.endPoint.copy(p);\n      this.updateLine();\n    } }, { key: \"endDrag\", value: function endDrag()\n\n    {\n      if (this.mouseTracker) {\n        this.mouseTracker.stopTracking(this.getName(), Autodesk.Edit2D.Trackings.Drag);\n      }\n\n      if (!this.line) {\n        return false;\n      }\n\n      // Remove temporary gizmo shape\n      this.gizmoLayer.removeShape(this.line);\n\n      // Add line shape if valid\n      var lineValid = !Math2D.edgeIsDegenerated(this.startPoint, this.endPoint);\n      if (lineValid) {\n        this.undoStack.run(new Actions.AddShape(this.layer, this.line));\n      }\n\n      this.line = null;\n\n      this.lengthLabel.setShape(null);\n\n      return true;\n    } }, { key: \"cancelDrag\", value: function cancelDrag()\n\n    {\n      if (this.mouseTracker) {\n        this.mouseTracker.stopTracking(this.getName(), Autodesk.Edit2D.Trackings.Drag);\n      }\n\n      if (this.line) {\n        // Remove temporary gizmo shape\n        this.gizmoLayer.removeShape(this.line);\n        this.line = null;\n\n        this.dragCanceled = true;\n\n        this.lengthLabel.setShape(null);\n      }\n    } }, { key: \"isDragging\", value: function isDragging()\n\n    {\n      return Boolean(this.line);\n    } }, { key: \"handleKeyDown\", value: function handleKeyDown(\n\n    event, keyCode) {\n      // Update shape when toggling between rect and quad mode\n      if (keyCode == av.KeyCode.SHIFT) {\n        this.updateLine(true);\n      }\n    } }, { key: \"handleKeyUp\", value: function handleKeyUp(\n\n    event, keyCode) {\n      // Update shape when toggling between rect and quad mode\n      if (keyCode == av.KeyCode.SHIFT) {\n        this.updateLine(false);\n      }\n    } }]);return LineTool;}(EditToolBase);export { LineTool as default };","function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError(\"Cannot call a class as a function\");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}\nimport { Actions } from '../Actions.js';\n\nvar MoveToolName = \"Edit2_MoveTool\";\n\nvar av = Autodesk.Viewing;var\n\nMoveTool = /*#__PURE__*/function () {\n\n  function MoveTool(ctx) {_classCallCheck(this, MoveTool);\n    this.layer = ctx.layer;\n    this.gizmoLayer = ctx.gizmoLayer;\n    this.selection = ctx.selection;\n    this.undoStack = ctx.undoStack;\n    this.nameSuffix = \"_\".concat(ctx.toolSetName);\n\n    // Only set during dragging\n    this.shapes = null; // Shape[]\n\n    // Optioanl: Only move a single loop. Only supported if only a single shape is selected.\n    this.loopIndex = -1;\n\n    // drag-start position in layer coords\n    this.dragStartPoint = new THREE.Vector2();\n\n    // backup original shapes on drag-start as long as we are modifying it on-hover\n    this.backupShapes = null; // Shape[]\n\n    this.keyMap = {\n      CancelEdit: av.KeyCode.ESCAPE };\n\n\n    // Remember last mouse-pos on mouse-move events\n    this.lastMousePos = new THREE.Vector2(); // in layer coords\n\n    this.mouseTracker = ctx.mouseTracker;\n\n    this.moveFilters = [this.defaultMoveFilter];\n  }_createClass(MoveTool, [{ key: \"addMoveFilter\", value: function addMoveFilter(\n\n    filter) {\n      this.moveFilters.push(filter);\n    } }, { key: \"removeMoveFilter\", value: function removeMoveFilter(\n\n    filter) {\n      var index = this.moveFilters.indexOf(filter);\n      if (index == -1) {\n        return false;\n      }\n      this.moveFilters.splice(index, 1);\n      return true;\n    } }, { key: \"defaultMoveFilter\", value: function defaultMoveFilter(\n\n    shapes) {\n      return shapes.every(function (s) {return s.movable;});\n    } }, { key: \"getNames\", value: function getNames()\n\n    {\n      return [this.getName()];\n    } }, { key: \"getName\", value: function getName()\n\n    {\n      return MoveToolName + this.nameSuffix;\n    } }, { key: \"activate\", value: function activate()\n\n    {} }, { key: \"deactivate\", value: function deactivate()\n    {} }, { key: \"register\", value: function register()\n    {} }, { key: \"handleSingleClick\", value: function handleSingleClick()\n\n    /*event , button */{\n      var shapesToMove = this.selection.getSelectedShapes();\n      return shapesToMove && shapesToMove.length > 0;\n    } }, { key: \"handleDoubleClick\", value: function handleDoubleClick()\n\n    /*event , button */{\n      var shapesToMove = this.selection.getSelectedShapes();\n      return shapesToMove && shapesToMove.length > 0;\n    } }, { key: \"handleButtonDown\", value: function handleButtonDown(\n\n    event, button) {\n      // Only respond to left button\n      if (button !== 0) {\n        return;\n      }\n\n      var p = this.layer.canvasToLayer(event.canvasX, event.canvasY);\n      var hitShape = this.layer.hitTest(p.x, p.y);\n\n      if (!hitShape) {\n        this.selection.clear();\n        return false;\n      }\n\n      // If shape was not selected before, select it\n      var wasSelected = hitShape && this.selection.shapeIsSelected(hitShape);\n      if (!wasSelected) {\n        this.selection.selectOnly(hitShape);\n      }\n\n      // Move all selected shapes\n      var shapesToMove = this.selection.getSelectedShapes();\n      if (shapesToMove.length > 0) {\n        this.startDrag(shapesToMove, p);\n      }\n\n      return true;\n    }\n\n    // Start dragging one or more shapes\n    //  @param {Shape[]} shapes\n    //  @param {Vector2} startPos - in layer coords\n  }, { key: \"startDrag\", value: function startDrag(shapes, startPos) {var loopIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : -1;\n      var allShapesCanBeMoved = this.moveFilters.every(function (m) {return m(shapes);});\n      if (!allShapesCanBeMoved) {\n        // if any of the selected shapes cannot be moved, don't allow the group to be moved.\n        return false;\n      }\n\n      if (this.mouseTracker) {\n        this.mouseTracker.startTracking(this.getName(), Autodesk.Edit2D.Trackings.Drag);\n      }\n\n      this.shapes = shapes;\n      this.loopIndex = loopIndex;\n      this.dragStartPoint.copy(startPos);\n      this.backupShapes = shapes.map(function (s) {return s.clone();});\n    }\n\n    // p is in layer coords\n  }, { key: \"moveDrag\", value: function moveDrag(p) {var _this = this;\n      var dx = p.x - this.dragStartPoint.x;\n      var dy = p.y - this.dragStartPoint.y;\n\n      // Apply this offset to shape. We always start with the original shape as a reference \n      // to avoid accumulating delta inaccuracies.\n      this.shapes.forEach(function (shape, i) {\n        shape.copy(_this.backupShapes[i]);\n\n        if (_this.loopIndex === -1) {\n          // Default: Move whole shape(s)\n          shape.move(dx, dy);\n        } else {\n          // Only move single loop\n          shape.moveLoop(dx, dy, _this.loopIndex);\n        }\n      });\n      this.layer.update();\n      this.gizmoLayer.update();\n    }\n\n    // Clean up data hold during a drag interaction\n  }, { key: \"resetDragging\", value: function resetDragging() {\n      this.shapes = null;\n      this.loopIndex = -1;\n      this.backupShapes = null;\n    } }, { key: \"endDrag\", value: function endDrag(\n\n    p) {var _this2 = this;\n      if (this.mouseTracker) {\n        this.mouseTracker.stopTracking(this.getName(), Autodesk.Edit2D.Trackings.Drag);\n      }\n\n      // No drag active\n      if (!this.shapes) {\n        return;\n      }\n\n      // Revert any temporary modifications done during mouse move\n      this.shapes.forEach(function (shape, i) {return shape.copy(_this2.backupShapes[i]);});\n\n      // Apply move operation\n      var dx = p.x - this.dragStartPoint.x;\n      var dy = p.y - this.dragStartPoint.y;\n\n      if (this.loopIndex === -1) {\n        this.undoStack.run(new Actions.MoveShapes(this.layer, this.shapes, dx, dy));\n      } else {\n        this.undoStack.run(new Actions.MoveLoop(this.layer, this.shapes[0], this.loopIndex, dx, dy));\n      }\n\n      this.shapes = null;\n      this.loopIndex = -1;\n      return true;\n    } }, { key: \"cancelDrag\", value: function cancelDrag()\n\n    {var _this3 = this;\n      if (this.mouseTracker) {\n        this.mouseTracker.stopTracking(this.getName(), Autodesk.Edit2D.Trackings.Drag);\n      }\n\n      if (this.isDragging()) {\n\n        // Revert shape o state when dragging was started\n        this.shapes.forEach(function (shape, i) {return shape.copy(_this3.backupShapes[i]);});\n        this.layer.update();\n        this.gizmoLayer.update();\n\n        this.resetDragging();\n\n        this.startedDragging = true;\n\n        return true;\n      }\n\n      return false;\n    } }, { key: \"isDragging\", value: function isDragging()\n\n    {\n      return Boolean(this.shapes);\n    } }, { key: \"handleMouseMove\", value: function handleMouseMove(\n\n    event) {\n\n      // Get and store latest mouse position\n      var p = this.layer.canvasToLayer(event.canvasX, event.canvasY);\n      this.lastMousePos.copy(p);\n\n      if (!this.shapes) {\n        return false;\n      }\n\n      // get delta between last and current position        \n      this.moveDrag(p);\n\n      return true;\n    } }, { key: \"handleButtonUp\", value: function handleButtonUp(\n\n    event, button) {\n      // Only respond to left button\n      if (button !== 0) {\n        return;\n      }\n\n      var wasDragging = this.startedDragging;\n      this.startedDragging = false;\n\n      var p = this.layer.canvasToLayer(event.canvasX, event.canvasY);\n      return this.endDrag(p) || wasDragging;\n    } }, { key: \"handleKeyDown\", value: function handleKeyDown(\n\n    event, keyCode) {\n      if (keyCode === this.keyMap.CancelEdit) {\n        return this.cancelDrag();\n      }\n\n      return;\n    }\n\n    // Display move cursor if a shape is under mouse or if we are dragging\n  }, { key: \"getCursor\", value: function getCursor() {\n      // this.shape is defined when we are dragging\n      if (this.shapes) {\n        return 'move';\n      }\n\n      // Show move cursor if a shape is under mouse\n      var shapeAtMouse = this.layer.hitTest(this.lastMousePos.x, this.lastMousePos.y);\n\n      if (shapeAtMouse) {\n        var canBeMoved = this.moveFilters.every(function (m) {return m([shapeAtMouse]);});\n        if (canBeMoved) {\n          // if any of the selected shapes cannot be moved, don't allow the group to be moved.\n          return 'move';\n        }\n      }\n      return undefined;\n    } }]);return MoveTool;}();export { MoveTool as default };","function _typeof(obj) {\"@babel/helpers - typeof\";if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;};}return _typeof(obj);}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError(\"Cannot call a class as a function\");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}function _get(target, property, receiver) {if (typeof Reflect !== \"undefined\" && Reflect.get) {_get = Reflect.get;} else {_get = function _get(target, property, receiver) {var base = _superPropBase(target, property);if (!base) return;var desc = Object.getOwnPropertyDescriptor(base, property);if (desc.get) {return desc.get.call(receiver);}return desc.value;};}return _get(target, property, receiver || target);}function _superPropBase(object, property) {while (!Object.prototype.hasOwnProperty.call(object, property)) {object = _getPrototypeOf(object);if (object === null) break;}return object;}function _inherits(subClass, superClass) {if (typeof superClass !== \"function\" && superClass !== null) {throw new TypeError(\"Super expression must either be null or a function\");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}function _createSuper(Derived) {var hasNativeReflectConstruct = _isNativeReflectConstruct();return function _createSuperInternal() {var Super = _getPrototypeOf(Derived),result;if (hasNativeReflectConstruct) {var NewTarget = _getPrototypeOf(this).constructor;result = Reflect.construct(Super, arguments, NewTarget);} else {result = Super.apply(this, arguments);}return _possibleConstructorReturn(this, result);};}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");}return self;}function _isNativeReflectConstruct() {if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;if (Reflect.construct.sham) return false;if (typeof Proxy === \"function\") return true;try {Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));return true;} catch (e) {return false;}}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}import { Path, PolyBase, Polygon, Polyline, PolyIndex, EdgeType } from '../EditShapes.js';\nimport { Actions } from '../Actions.js';\nimport { Math2D } from '../Math2D.js';\nimport { AreaLabel } from '../CanvasGizmo.js';\nimport TangentGizmo from '../TangentGizmo.js';\nimport { EllipseArcGizmo } from '../EllipseArcGizmo.js';\nimport { getEllipseArcEdgeParams } from '../EllipseArcGizmo.js';\n\nimport MoveTool from './MoveTool.js';\nimport VertexMoveTool from \"./VertexMoveTool.js\";\nimport EdgeMoveTool from './EdgeMoveTool.js';\nimport EditToolBase from './EditToolBase.js';\n\nvar PolygonEditToolName = 'Edit2_PolygonEditTool';\n\nvar av = Autodesk.Viewing;\n\n// Allow to pick an edge within \nvar EdgeSelectTolerance = 17;var\n\nPolygonEditTool = /*#__PURE__*/function (_EditToolBase) {_inherits(PolygonEditTool, _EditToolBase);var _super = _createSuper(PolygonEditTool);\n\n  function PolygonEditTool(ctx) {var _this;_classCallCheck(this, PolygonEditTool);\n    _this = _super.call(this, ctx);\n\n    _this.moveTool = new MoveTool(ctx);\n    _this.edgeMoveTool = new EdgeMoveTool(ctx);\n    _this.vertexMoveTool = new VertexMoveTool(ctx);\n\n    // Only set during dragging\n    _this.poly = null;\n\n    _this.keyMap.DeleteSelectedVertex = av.KeyCode.BACKSPACE;\n    _this.keyMap.CancelEdit = av.KeyCode.ESCAPE;\n    _this.keyMap.ChangeToArc = av.KeyCode.a; // Change selected edge to arc\n    _this.keyMap.ChangeToLine = av.KeyCode.l; // Change selected edge to line\n    _this.keyMap.ChangeToEllipse = av.KeyCode.e; // Change selected edge to ellipse arc\n\n    // Track mouse position in layer-coords\n    _this.mousePos = new THREE.Vector2();\n\n    // Create area label. Default hidden - showing is optional.\n    _this.areaLabel = new AreaLabel(null, _this.layer, ctx.unitHandler, false);\n\n    // {TangentGizmo[]} Array of TangentGizmos for BezierArcs\n    _this.tangentGizmos = [];\n\n    _this.tangentGizmosEnabled = true;\n    _this.ellipseArcGizmosEnabled = true;\n\n    // If true, we apply hover-highlight on shape under mouse.\n    _this.hoverEnabled = true;\n\n    // If true, we allow changing edge type to ellipse arcs.\n    _this.enableEllipseArcs = false;\n\n    // Ellipse-arc gizmo. Only shown if an ellipse-edge is selected\n    _this.ellipseArcGizmo = new EllipseArcGizmo(ctx.layer, _this.gizmoManager, ctx.undoStack, false);\n\n    // Used in mouseDown handler: Indicates that mouse-down has been consumed by this tool, so that\n    // other LMV tools shouldn't handle the singleClick either. This avoids unwanted LMV object selection\n    // after ctrl-click on Edit2D shapes.\n    _this.clickConsumed = false;return _this;\n  }_createClass(PolygonEditTool, [{ key: \"setTangentGizmosEnabled\", value: function setTangentGizmosEnabled(\n\n    enabled) {\n      this.tangentGizmosEnabled = enabled;\n      if (enabled) {\n        this.updateTangentGizmos();\n      } else {\n        this.clearTangentGizmos();\n      }\n    } }, { key: \"setEllipseArcGizmoEnabled\", value: function setEllipseArcGizmoEnabled(\n\n    enabled) {\n      this.ellipseArcGizmosEnabled = enabled;\n      this.updateEllipseArcGizmo();\n    } }, { key: \"setAllGizmosEnabled\", value: function setAllGizmosEnabled(\n\n    enabled) {\n      this.setTangentGizmosEnabled(enabled);\n      this.setEllipseArcGizmoEnabled(enabled);\n      this.vertexMoveTool.setAllGizmosEnabled(enabled);\n      this.edgeMoveTool.setAllGizmosEnabled(enabled);\n    } }, { key: \"setHoverEnabled\", value: function setHoverEnabled(\n\n    enabled) {\n\n      // On disable, make sure that we don't leave any highlight behind\n      if (this.hoverEnabled && !enabled) {\n        this.selection.setHovered(null);\n      }\n\n      this.hoverEnabled = enabled;\n    }\n\n    // Enable the area labels (public API)\n  }, { key: \"setAreaLabelVisible\", value: function setAreaLabelVisible(visible) {\n      this.areaLabel.setVisible(visible);\n    }\n\n    // Enable the length labels (public API)\n  }, { key: \"setLengthLabelVisible\", value: function setLengthLabelVisible(visible) {\n      this.edgeMoveTool.setLengthLabelVisible(visible);\n    } }, { key: \"getName\", value: function getName()\n\n    {\n      return PolygonEditToolName + this.nameSuffix;\n    } }, { key: \"deactivate\", value: function deactivate()\n\n    {\n      _get(_getPrototypeOf(PolygonEditTool.prototype), \"deactivate\", this).call(this);\n      this.reset();\n    }\n\n    // Update vertex-gizmos, and tangent gizmos.\n  }, { key: \"updateAllGizmos\", value: function updateAllGizmos() {\n      this.updateTangentGizmos();\n      this.updateEllipseArcGizmo();\n      this.updateMouseOverHighlights();\n      this.vertexMoveTool.updateAllGizmos();\n      this.edgeMoveTool.updateAllGizmos();\n    }\n\n    // Finishes editing of a previous polygon\n  }, { key: \"reset\", value: function reset() {\n\n      if (!this.poly) {\n        return;\n      }\n\n      this.poly = null;\n\n      this.vertexMoveTool.reset();\n      this.edgeMoveTool.reset();\n\n      // Clear any gizmos from previous polygon\n      this.updateAllGizmos();\n\n      // Cleanup area and length labels\n      this.areaLabel.setShape(null);\n\n      this.snapper.stopAngleSnapping();\n    }\n\n    // Selects a new polygon / polyline for editing\n  }, { key: \"setEditPoly\", value: function setEditPoly(poly) {\n\n      this.reset();\n\n      if (poly) {\n        this.poly = poly;\n        this.updateAllGizmos();\n      }\n\n      // Sync label with polygon or polyline. If this.poly is null, it will be hidden\n      var polygon = poly && poly.isPolygon() ? poly : null;\n      this.areaLabel.setShape(polygon);\n    } }, { key: \"insertPoint\", value: function insertPoint(\n\n    polyIndex, p) {\n\n      this.runAction(new Actions.AddVertex(this.layer, this.poly, polyIndex, p));\n\n      // removeupdate edge gizmos and tangent gizmos\n      this.updateAllGizmos();\n\n      // Display polygon change and new gizmo\n      this.layer.update();\n    }\n\n    // Remove loop (including any other loop it contains)\n  }, { key: \"removeLoop\", value: function removeLoop(loopIndex) {\n\n      // Collect all loops to remove\n      var loopsToRemove = this.poly.getChildLoops(loopIndex);\n      loopsToRemove.push(loopIndex);\n\n      var action = new Actions.RemoveLoops(this.layer, this.poly, loopsToRemove);\n      this.runAction(action);\n\n      // Reset vertex/edge selection. We cannot keep it because the meaning of loopIndices has changed.\n      this.vertexMoveTool.setSelectedVertex(null);\n      this.edgeMoveTool.setSelectedEdge(null);\n\n      this.updateAllGizmos();\n      this.layer.update();\n    } }, { key: \"removePoint\", value: function removePoint(\n\n    polyIndex) {var\n\n      loop = polyIndex.loop;\n\n      // If removing a vertex would make the loop degenerate, remove it completely        \n      var minVerts = this.poly.isPolygon() ? 3 : 2;\n      if (this.poly.getVertexCount(loop) <= minVerts) {\n        this.removeLoop(loop);\n        return;\n      }\n\n      this.runAction(new Actions.RemoveVertex(this.layer, this.poly, polyIndex));\n\n      // update vertex gizmos\n      this.vertexMoveTool.updateVertexGizmos();\n\n      // update edge gizmos and tangent gizmos\n      this.updateAllGizmos();\n\n      // Make sure that this vertex is not selected anymore\n      if (polyIndex.equals(this.vertexMoveTool.selectedVertex)) {\n        this.vertexMoveTool.setSelectedVertex(null);\n      }\n\n      // Unselect edge if edgeIndex got invalid        \n      this.edgeMoveTool.setSelectedEdge(null);\n\n      this.layer.update();\n    } }, { key: \"isSingleLine\", value: function isSingleLine()\n\n    {\n      return this.poly && this.poly.loopCount === 1 && this.poly.getVertexCount(0) === 2;\n    }\n\n    // If the given mousePos (in layerCoords) is located close to an edge (not edge gizmo), \n    // the edge index is returned, otherwise null.\n    //  @returns {PolyIndex|null}\n  }, { key: \"findEdgeUnderMouse\", value: function findEdgeUnderMouse(pos) {\n      if (!this.poly) {\n        return null;\n      }\n\n      var precision = EdgeSelectTolerance * this.layer.getUnitsPerPixel();\n      for (var l = 0; l < this.poly.loopCount; l++) {\n        var index = this.poly.findEdgeIndex(pos, precision, l);\n        if (index !== -1) {\n          return new PolyIndex({ vertex: index, loop: l });\n        }\n      }\n      return null;\n    }\n\n    // Checks if a point p can be inserted to split the given edge. If so, it returns the projected\n    // position that is located exactly on edge to be split.\n    //\n    //  @param {Vector2} p           - pos in layer coords - usually close to given edge.\n    //  @param {PolyIndex} polyIndex - index of the edge to be split by this vertex\n    //  @returns {Vector2|null} Adjusted position where the new point will be added.\n  }, { key: \"getNewVertexPosition\", value: function getNewVertexPosition(p, polyIndex) {\n\n      if (!this.poly || !polyIndex) {\n        return null;\n      }\n\n      var edgeIndex = polyIndex.vertex;\n      var loopIndex = polyIndex.loop;\n      if (!this.poly.edgeIndexValid(edgeIndex, loopIndex)) {\n        return null;\n      }\n\n      // get edge\n      var a = new THREE.Vector2();\n      var b = new THREE.Vector2();\n      this.poly.getEdge(edgeIndex, a, b, loopIndex);\n\n      // get edge direction\n      var edgeDir = Math2D.getEdgeDirection(a, b);\n\n      // compute projection of p to the line spanned by the edge\n      var newPos = p.clone();\n      Math2D.projectToLine(newPos, a, edgeDir);\n\n      // Reject position if the projection is outside the segment\n      if (!Math2D.isPointOnEdge(newPos, a, b, 0.0001)) {\n        return null;\n      }\n\n      // Return position where to insert the new vertex\n      return newPos;\n    } }, { key: \"handleButtonDown\", value: function handleButtonDown(\n\n    event, button) {\n      // Support suppressing mouse buttons by holding a key\n      if (this.ignoreDragging) {\n        return false;\n      }\n\n      _get(_getPrototypeOf(PolygonEditTool.prototype), \"handleButtonDown\", this).call(this, event, button);\n\n      // Only respond to left mouse button.\n      if (!button == 0) {\n        return false;\n      }\n\n      var p = this.layer.canvasToLayer(event.canvasX, event.canvasY);\n      this.mousePos.copy(p);\n\n      if (this.vertexMoveTool.handleButtonDown(event, button)) {\n        this.edgeMoveTool.setSelectedEdge(null);\n        return true;\n      }\n\n      // Note: In LMV, ToolController handles command key and ctrl key in the same way.\n      //       For consistency, we do the same here.\n      var ctrlHold = event.ctrlKey || event.metaKey;\n\n      // Handle Vertex-Add: Check if we hold ctrl and hit an edge\n      var newVertex = -1;\n      if (ctrlHold) {\n        // Is mouse close to an edge and can be projected onto that edge?\n        var _edgeIndex = this.findEdgeUnderMouse(this.mousePos);\n        var newVertexPos = this.getNewVertexPosition(this.mousePos, _edgeIndex);\n        if (newVertexPos) {\n          // We don't insert exactly at the mouse position. Instead, new vertices\n          // are always located exactly on the edge being split. Therefore, newVertexPos is\n          // usually slightly different from mousePos.\n\n          // insert new vertex after edge starting point\n          newVertex = new PolyIndex({ vertex: _edgeIndex.vertex + 1, loop: _edgeIndex.loop });\n          this.insertPoint(newVertex, newVertexPos);\n\n          // Allow to drag the new vertex immediately\n          if (this.mouseTracker) {\n            this.mouseTracker.startTracking(this.getName(), Autodesk.Edit2D.Trackings.ButtonDown);\n          }\n          this.vertexMoveTool.startDragVertex(event, newVertex);\n\n          return true;\n        }\n      }\n\n      // Handle dragging of TangentGizmo control points for Bezier arcs.\n      for (var i = 0; i < this.tangentGizmos.length; i++) {\n        var gizmo = this.tangentGizmos[i];\n        if (gizmo.onButtonDown(event.canvasX, event.canvasY)) {\n          // We started dragging of a Bezier control point\n          return true;\n        }\n      }\n\n      // Handle dragging of EllipseArc gizmo\n      if (this.ellipseArcGizmo.startDrag(event.canvasX, event.canvasY)) {\n        if (this.mouseTracker) {\n          this.mouseTracker.startTracking(this.getName(), Autodesk.Edit2D.Trackings.ButtonDown);\n        }\n        // We started dragging an ellipse arc\n        return true;\n      }\n\n      // Reset selection highlighting of vertices.\n      this.vertexMoveTool.setSelectedVertex(null);\n\n      if (this.edgeMoveTool.handleButtonDown(event, button)) {\n        this.updateTangentGizmos();\n        this.updateEllipseArcGizmo();\n        return true;\n      }\n\n      // Check which polygon was hit\n      var newPolygon = this.layer.hitTest(p.x, p.y);\n\n      // Handle multiselect\n      if (this.enableMultiselection && ctrlHold && newPolygon) {\n        this.selection.toggleSelection(newPolygon);\n\n        // eat mouseUp event as well. Otherwise, LMV defaultHandler will select objects in the background in parallel\n        this.clickConsumed = true;\n        return true;\n      }\n\n      // Check if click was close to an edge of the current polygon.\n      var edgeIndex = this.poly && this.findEdgeUnderMouse(this.mousePos);\n\n      // Since tolerance for edge selection is higher, the edge shape hitTest may slightly miss\n      // the polygon, but we may be close to an edge. In this case, consider the shape as being it as well.\n      if (!newPolygon && edgeIndex) {\n        newPolygon = this.poly;\n      }\n\n      // If we just clicked inside the already selected polygon, delegate it to MoveTool.        \n      if (this.selection.shapeIsSelected(newPolygon)) {\n\n        var loopIndex = edgeIndex ? edgeIndex.loop : -1;\n\n        // Allow moving loops - unless it is a single outer one\n        var mainLoops = this.poly && this.poly.getMainLoops();\n        var isOnlyMainLoop = mainLoops && mainLoops.length === 1 && mainLoops[0] === loopIndex;\n\n        // Handle single-loop move\n        var moveLoop = edgeIndex && !isOnlyMainLoop;\n        if (moveLoop) {\n          // Move single loop\n          this.moveTool.startDrag([this.poly], p, loopIndex);\n        } else {\n          // Move selected shape(s)\n          var shapesToMove = this.selection.getSelectedShapes();\n          this.moveTool.startDrag(shapesToMove, p);\n        }\n        return true;\n      }\n\n      // If the clicked object is neither polygon nor polyline, ignore it.\n      var isPolygon = newPolygon instanceof Polygon;\n      var isPolyline = newPolygon instanceof Polyline;\n      var isPath = newPolygon instanceof Path;\n      if (!isPolygon && !isPolyline && !isPath) {\n        newPolygon = null;\n      }\n\n      // Set selection to current polygon. This will also trigger setEditPoly() \n      // via selectionChanged event.\n      this.selection.selectOnly(newPolygon);\n\n      return false;\n    } }, { key: \"handleSingleClick\", value: function handleSingleClick(\n\n    e) {\n      _get(_getPrototypeOf(PolygonEditTool.prototype), \"handleSingleClick\", this).call(this, e);\n\n      var handled = this.clickConsumed || Boolean(this.poly);\n\n      if (this.mouseTracker) {\n        this.mouseTracker.stopTracking(this.getName(), Autodesk.Edit2D.Trackings.Click);\n      }\n\n      this.clickConsumed = false;\n      return handled;\n    } }, { key: \"handleMouseMove\", value: function handleMouseMove(\n\n    event) {\n      _get(_getPrototypeOf(PolygonEditTool.prototype), \"handleMouseMove\", this).call(this, event);\n\n      this.mousePos.copy(this.layer.canvasToLayer(event.canvasX, event.canvasY));\n      this.updateMouseOverHighlights();\n\n      if (this.moveTool.isDragging()) {\n        this.moveTool.moveDrag(this.mousePos);\n      }\n\n      if (!this.poly) {\n        return false;\n      }\n\n      if (this.vertexMoveTool.handleMouseMove(event)) {\n        return true;\n      }\n\n      if (this.edgeMoveTool.handleMouseMove(event)) {\n        return true;\n      }\n\n      // Check if we are dragging an endpoint of any tangent gizmo\n      var tangentGizmo = this.findDraggedTangentGizmo();\n      if (tangentGizmo) {\n        tangentGizmo.moveDrag(event.canvasX, event.canvasY);\n      }\n\n      // Check if we are dragging the ellipseArc gizmo\n      if (this.ellipseArcGizmo.dragging) {\n        return this.ellipseArcGizmo.moveDrag(event.canvasX, event.canvasY);\n      }\n\n      return false;\n    } }, { key: \"handleButtonUp\", value: function handleButtonUp(\n\n    event, button) {\n      _get(_getPrototypeOf(PolygonEditTool.prototype), \"handleButtonUp\", this).call(this, event, button);\n\n      // Avoid triggering the handler for external modifications, because we control the EdgeMoveTool ourselves\n      this.ignoreActions = true;\n      var handled = this.vertexMoveTool.handleButtonUp(event, button);\n      this.ignoreActions = false;\n\n      if (handled) {\n        return true;\n      }\n\n      // Avoid triggering the handler for external modifications, because we control the EdgeMoveTool ourselves\n      this.ignoreActions = true;\n      handled = this.edgeMoveTool.handleButtonUp(event, button);\n      this.ignoreActions = false;\n\n      if (handled) {\n        return true;\n      }\n\n      if (this.moveTool.isDragging()) {\n        var p = this.layer.canvasToLayer(event.canvasX, event.canvasY);\n\n        // Avoid triggering the handler for external modifications, because we control the MoveTool ourselves\n        this.ignoreActions = true;\n        this.moveTool.endDrag(p);\n        this.ignoreActions = false;\n\n        return true;\n      }\n\n      // Check if we are dragging an endpoint of any tangent gizmo\n      var tangentGizmo = this.findDraggedTangentGizmo();\n      if (tangentGizmo) {\n        if (this.mouseTracker) {\n          this.mouseTracker.stopTracking(this.getName(), Autodesk.Edit2D.Trackings.ButtonUp);\n        }\n        tangentGizmo.endDrag(event.canvasX, event.canvasY);\n      }\n\n      // Check if we are dragging the center of an ellipse arc\n      if (this.ellipseArcGizmo.dragging) {\n        if (this.mouseTracker) {\n          this.mouseTracker.stopTracking(this.getName(), Autodesk.Edit2D.Trackings.ButtonUp);\n        }\n        this.ellipseArcGizmo.endDrag(event.canvasX, event.canvasY);\n\n      }\n\n      // We let other tools down the stack such as the MoveTool and EdgeMoveTool handle the button up.\n      return false;\n    }\n\n    // Exclude currently edited polygon from snapping: The polygon shouldn't snap to itself, but rather\n    // to geometry below it.\n  }, { key: \"snappingFilter\", value: function snappingFilter(shape) {\n      return shape !== this.poly;\n    }\n\n    // If selection changes (may also be triggered outside this tool), we choose the selected polyon for editing\n  }, { key: \"onSelectionChanged\", value: function onSelectionChanged() {\n      var selected = this.selection.getSelectedShapes();\n\n      // Activate if exactly one shape is selected\n      var shape = selected.length == 1 ? selected[0] : null;\n      if (shape instanceof PolyBase) {\n        this.setEditPoly(shape);\n      } else {\n        this.setEditPoly(null);\n      }\n\n      this.vertexMoveTool.onSelectionChanged();\n      this.edgeMoveTool.onSelectionChanged();\n    } }, { key: \"handleKeyDown\", value: function handleKeyDown(\n\n    event, keyCode) {\n      var handled = _get(_getPrototypeOf(PolygonEditTool.prototype), \"handleKeyDown\", this).call(this, event, keyCode);\n\n      // Needed in order to update suppressSnapping\n      this.vertexMoveTool.handleKeyDown(event, keyCode);\n      this.edgeMoveTool.handleKeyDown(event, keyCode);\n\n      if (keyCode === this.keyMap.DeleteSelectedVertex) {\n        if (this.poly && this.vertexMoveTool.selectedVertex) {\n          this.removePoint(this.vertexMoveTool.selectedVertex);\n          handled = true;\n        }\n      }\n\n      if (keyCode === this.keyMap.CancelEdit) {\n        this.cancelDrag();\n        return true;\n      }\n\n      // Check if we have an edge to work on\n      var targetEdge = this.isSingleLine() ? new PolyIndex({ vertex: 0, loop: 0 }) : this.edgeMoveTool.selectedEdge; // If we have just a single segment, we don't need edge selection.\n      var targetEdgeValid = Boolean(this.poly && targetEdge && this.poly.edgeIndexValid(targetEdge.vertex, targetEdge.loop));\n\n      if (keyCode === this.keyMap.ChangeToArc) {\n\n        // If a line segment is selected, convert it to an arc\n        var lineSegmentSelected = targetEdgeValid && !this.poly.isBezierArc(targetEdge.vertex, targetEdge.loop);\n        if (lineSegmentSelected) {\n          this.changeEdgeToBezier(targetEdge);\n        }\n        return true;\n      }\n\n      if (keyCode === this.keyMap.ChangeToEllipse) {\n\n        // If a line segment is selected, convert it to an arc\n        var segmentSelected = targetEdgeValid && !this.poly.isEllipseArc(targetEdge.vertex, targetEdge.loop);\n        if (segmentSelected) {\n          this.changeEdgeToEllipse(targetEdge);\n        }\n        return true;\n      }\n\n      if (keyCode === this.keyMap.ChangeToLine) {\n        // If an arc segment is selected, convert it to a line\n        var arcSegmentSelected = targetEdgeValid && this.poly.isArc(targetEdge.vertex, targetEdge.loop);\n        if (arcSegmentSelected) {\n          this.changeEdgeToLine(targetEdge);\n        }\n      }\n\n      return handled;\n    } }, { key: \"handleKeyUp\", value: function handleKeyUp(\n\n    event, keyCode) {\n      var handled = _get(_getPrototypeOf(PolygonEditTool.prototype), \"handleKeyUp\", this).call(this, event, keyCode);\n\n      // Needed in order to update suppressSnapping\n      this.vertexMoveTool.handleKeyUp(event, keyCode);\n      this.edgeMoveTool.handleKeyUp(event, keyCode);\n\n      return handled;\n    }\n\n    // If snapping has toggled on/off, we instantly \"replay\" hovering at current mouse position. Purpose is to\n    // give instant feedback (e.g. hide/show SnapLine gizmos and adjust position of preview edge)\n  }, { key: \"onSnappingToggled\", value: function onSnappingToggled(canvasX, canvasY) {\n      this.vertexMoveTool.onSnappingToggled(canvasX, canvasY);\n    } }, { key: \"cancelDrag\", value: function cancelDrag()\n\n    {\n\n      var needsUpdate = false;\n\n      if (this.vertexMoveTool.cancelDrag()) {\n        needsUpdate = true;\n      }\n\n      if (this.edgeMoveTool.cancelDrag()) {\n        needsUpdate = true;\n      }\n\n      if (this.moveTool.cancelDrag()) {\n        needsUpdate = true;\n      }\n\n      this.tangentGizmos.forEach(function (tg) {\n        if (tg.isDragging()) {\n          tg.cancelDrag();\n          needsUpdate = true;\n        }\n      });\n\n      if (needsUpdate) {\n        this.updateAllGizmos();\n        this.layer.update();\n      }\n\n      if (this.ellipseArcGizmo.dragging) {\n        if (this.mouseTracker) {\n          this.mouseTracker.stopTracking(this.getName(), Autodesk.Edit2D.Trackings.Drag);\n        }\n        this.ellipseArcGizmo.cancelDrag();\n        this.updateAllGizmos();\n      }\n\n      this.snapper.clearSnappingGizmos();\n    }\n\n    // Updates selection of shape(s), vertex, and edge after an action\n  }, { key: \"updateSelectionState\", value: function updateSelectionState(action, isUndo) {\n\n      // If the action is invoked by our own TangentGizmo, attach the currently selected item on first run.\n      // This allows us to recover later whether a vertex or an edge was selected.\n      if (action instanceof Actions.ChangeBezierTangent) {\n        var _hint = action.getSelectionHint(isUndo);\n        if (!_hint) {\n          action.setSelectionItem(\n          this.vertexMoveTool.selectedVertex,\n          this.edgeMoveTool.selectedEdge);\n\n        }\n      }\n\n      // Check if the action provides a hint how we should update selection\n      var hint = action.getSelectionHint(isUndo);\n      if (hint) {\n\n        // apply shape selection\n        var shapes = hint.shape ? [hint.shape] : hint.shapes;\n        this.selection.setSelection(shapes);\n\n        this.vertexMoveTool.setSelectedVertex(hint.vertex);\n        this.edgeMoveTool.setSelectedEdge(hint.edge);\n\n        return;\n      }\n\n      // Default behavior - if we don't know anything better:\n      //  - Keep shape selected if still existing\n      //  - Reset vertex/edge selection\n\n      // If shape was removed, reset state\n      var shapeFound = Boolean(this.poly && this.layer.findShapeById(this.poly.id));\n      if (!shapeFound) {\n        this.reset();\n      }\n\n      // If poly was modified from outside, we can't know if the selected vertex or edge\n      // still exist or have the same meaning. E.g., when undo/redoing a vertex-insert, the indices may have shifted.\n      this.vertexMoveTool.setSelectedVertex(null);\n      this.edgeMoveTool.setSelectedEdge(null);\n    } }, { key: \"handleExternalAction\", value: function handleExternalAction(\n\n    action, isUndo) {\n\n      // make sure that selected edge/vertex are still valid (or switched off)\n      this.updateSelectionState(action, isUndo);\n\n      // Stop any ongoing drag-operations (e.g., an undo operation might have removed the vertex that we are just dragging)\n      this.cancelDrag();\n\n      // Sync gizmos in case vertices were modified\n      this.updateAllGizmos();\n\n      this.snapper.clearSnappingGizmos();\n    } }, { key: \"updateMouseOverHighlights\", value: function updateMouseOverHighlights()\n\n\n    {\n      // Handle mouse-over highlighting for shapes\n      if (this.hoverEnabled) {\n        var shape = this.layer.hitTest(this.mousePos.x, this.mousePos.y);\n        this.selection.setHoveredId(shape ? shape.id : 0);\n      }\n    } }, { key: \"getCursor\", value: function getCursor()\n\n    {\n\n      if (!this.poly) {\n        return;\n      }\n\n      // Note: Vertex gizmos and edge gizmos are separate DomElements and define own mouse cursors via style.\n\n      var p = this.mousePos;\n\n      // Indicate: \"Moving whole shape\"\n      // While dragging, keep the move-cursor, even if the mouse is temporarily leaving polygon and gizmos\n      if (this.moveTool.isDragging()) {\n        return 'move';\n      }\n\n      // Indicate: \"Moving a gizmo\". Currently, we use the same as for shape move. Note that\n      //           the cursor for gizmo dragging must be consistent with the one we have if the mouse is on the gizmo.\n      //           Otherwise, the mouse cursor would change its state when temporarily leaving the gizmo on fast moves.\n      var vertexEdgeCursor = this.vertexMoveTool.getCursor() || this.edgeMoveTool.getCursor();\n      if (vertexEdgeCursor) {\n        return vertexEdgeCursor;\n      }\n\n      // Indicate: \"Moving a ellipse-arc gizmo\" to modify radius of an ellipse arc.\n      if (this.ellipseArcGizmo.dragging) {\n        return 'move';\n      }\n\n      // Check if mouse is close to an edge\n      var precision = EdgeSelectTolerance * this.layer.getUnitsPerPixel();\n      var edgeIndex = this.findEdgeUnderMouse(this.mousePos, precision);\n\n      // Indicate: \"Click to insert new vertex\"\n      //\n      // If we are holding down Ctrl (or command) and hover over an edge, clicking would insert a vertex.\n      var ctrlHold = this.keyState[av.KeyCode.CONTROL];\n      if (ctrlHold) {\n        if (edgeIndex) {\n          return 'copy';\n        }\n      }\n\n      // Are we about to move a shape?\n      var hitRadius = this.layer.getLineHitRadius(this.poly);\n      var moveShape = edgeIndex || this.poly.hitTest(p.x, p.y, hitRadius);\n      if (moveShape) {\n        return 'move';\n      }\n\n      // => Just default cursor\n      return undefined;\n    } }, { key: \"clearTangentGizmos\", value: function clearTangentGizmos()\n\n    {\n      this.tangentGizmos.forEach(function (g) {return g.dtor();});\n      this.tangentGizmos.length = 0;\n    } }, { key: \"updateTangentGizmos\", value: function updateTangentGizmos()\n\n    {\n\n      // Clear any previous gizmos (if any)\n      this.clearTangentGizmos();\n\n      if (!this.poly || !this.poly.isPath()) {\n        return;\n      }\n\n      // We only show a tangent gizmo if it has relevance for the selected vertex or edge:\n      // For a vertex v with neighbor edges prevEdge und nextEdge, we show a tangent gizmo if...\n      //  - v, prevEdge, or nextEdge is selected\n      //  - If an edge is selected, the selected edge is an arc\n      //  - If v is selected, prevEdge or nextEdge is an arc\n      for (var l = 0; l < this.poly.loopCount; l++) {\n        var vertexCount = this.poly.getVertexCount(l);\n        for (var i = 0; i < vertexCount; i++) {\n\n          var sv = this.vertexMoveTool.selectedVertex;\n          var vertexSelected = Boolean(sv && sv.vertex === i && sv.loop === l);\n\n          // get prev/next edge. \n          var prevEdge = this.poly.edgeBeforeVertex(i, l);\n          var nextEdge = this.poly.edgeAfterVertex(i, l);\n\n          // edges may not exist at polyline ends\n          var prevExists = prevEdge !== -1;\n          var nextExists = nextEdge !== -1;\n\n          // check if any neighbor edge is selected\n          var se = this.edgeMoveTool.selectedEdge;\n          var prevSelected = Boolean(prevExists && se && se.vertex === prevEdge && se.loop === l);\n          var nextSelected = Boolean(nextExists && se && se.vertex === nextEdge && se.loop === l);\n\n          // check if any neighbor edge is an arc\n          var prevIsArc = prevExists && this.poly.isBezierArc(prevEdge, l);\n          var nextIsArc = nextExists && this.poly.isBezierArc(nextEdge, l);\n\n          // If we just have a single line segment, always show the tangent gizmos\n          var isSingleLine = this.isSingleLine();\n\n          // Check if we selected an arc edge or a vertex of one\n          var arcVertexSelected = vertexSelected && (prevIsArc || nextIsArc);\n          var arcEdgeSelected = prevSelected && prevIsArc || nextSelected && nextIsArc;\n\n          // show the gizmo if anything is selected and one of the edges is an arc\n          var showTangents = isSingleLine || arcVertexSelected || arcEdgeSelected;\n          if (showTangents) {\n            this.tangentGizmos.push(new TangentGizmo(this.poly, i, l, this.layer, this.gizmoLayer, this.gizmoManager, this.undoStack));\n          }\n        }\n      }\n    } }, { key: \"updateEllipseArcGizmo\", value: function updateEllipseArcGizmo()\n\n    {\n      var se = this.edgeMoveTool.selectedEdge;\n\n      var edgeSelected = Boolean(se);\n\n      // if ellipse arc gizmos are enabled, check if edge is selected and we the polygon at hand is a path, as well\n      // if the selected edge's vertex and loop is an ellipse arc. If ellipse arc gizmos are not enabled, then dettach\n      // them from the edge and return.\n      var showGizmo = this.ellipseArcGizmosEnabled ?\n      edgeSelected && this.poly instanceof Path && this.poly.isEllipseArc(se.vertex, se.loop) :\n      false;\n\n      this.ellipseArcGizmo.setVisible(showGizmo);\n\n      if (!showGizmo) {\n        // Make sure that ellipseArcGizmo doesn't keep bound to an edge. Otherwise, it may\n        // cause an error later if that edge is removed.\n        this.ellipseArcGizmo.detachFromEdge();\n        return;\n      }\n\n      this.ellipseArcGizmo.attachToEdge(this.poly, se.vertex, se.loop);\n    }\n\n    // If any tangent gizmo is being dragged, it is returned.\n    // Result is null if nothing is dragged.\n  }, { key: \"findDraggedTangentGizmo\", value: function findDraggedTangentGizmo() {\n      return this.tangentGizmos.find(function (gizmo) {return gizmo.isDragging();});\n    }\n\n    // Heuristic for choosing the tangent length when turning a line segment into an arc.\n    // The basic idea here is\n    //  - When turning all 4 lines of a square into arcs, we should get something that approximates a circle.\n    //  - When generalizing that to more fancy cases, it should at least behave consistent and sort-of reasonable (e.g. always keep within a reasonable ratio to segment lengths)\n    //\n    // Note: It's probably cleaner to always approximate some sort of elliptical arcs for the general case. But that will make things a lot harder (and possibly slower).\n    //       So let's get away with the linear-scale cheating for now.\n  }, { key: \"getVertexTangentLength\", value: function getVertexTangentLength(prevLength, nextLength) {\n\n      // Given a square of edge length sqrt(2), the circle passing through all 4 vertices can be\n      // approximated by 4 cubic bezier arc segments. The tangents for these bezier arcs all have this length:\n      // (See here: http://spencermortensen.com/articles/bezier-circle/)\n      var c = 0.551915024494;\n\n      // Scaling down the quad/beziers to a unit quad, we obtain the corresponding tangent lengths for a unit quad as:\n      var unitQuadTangentLength = c / Math.SQRT2;\n\n      // For a square of length l, the tangent length scales up accordingly.\n      // For different segment lengths, we simply use the average of both lengths.\n      var l = 0.5 * (prevLength + nextLength);\n\n      return l * unitQuadTangentLength;\n    }\n\n    // Given a corner vertex p and its previous and next neighbor, this function computes an averaged tangent\n    // vector that we use if (prev, p) and (p, next) are replaced by Bezier arcs.\n  }, { key: \"getVertexTangent\", value: function getVertexTangent(prev, p, next) {\n\n      // get tangent direction by averaging the edge directions.\n      var tangent = new THREE.Vector2().copy(next).sub(prev).normalize();\n\n      // Scale tangent direction\n      var prevLength = p.distanceTo(prev);\n      var nextLength = p.distanceTo(next);\n      var tangentLength = this.getVertexTangentLength(prevLength, nextLength);\n\n      return tangent.multiplyScalar(tangentLength);\n    } }, { key: \"changeEdgeToEllipse\", value: function changeEdgeToEllipse(\n\n    polyIndex) {\n\n      var edgeIndex = polyIndex.vertex;\n      var loopIndex = polyIndex.loop;\n\n      // By default, bend outsidde by half of the edge length. In this way, we get a circle centered\n      // at the line-segment midpoint.\n      var bendRadius = 0.5 * this.poly.getEdgeLength(edgeIndex, loopIndex);\n      var arcParams = getEllipseArcEdgeParams(this.poly, edgeIndex, loopIndex, bendRadius);\n      this.runAction(new Actions.ChangeEdgeType(this.layer, this.poly, polyIndex, EdgeType.Ellipse, null, null, arcParams));\n\n      this.layer.update();\n      this.edgeMoveTool.setSelectedEdge(polyIndex);\n      this.updateAllGizmos();\n    } }, { key: \"changeEdgeToBezier\", value: function changeEdgeToBezier(\n\n    polyIndex) {\n\n      var edgeIndex = polyIndex.vertex;\n      var loopIndex = polyIndex.loop;\n\n      var path = this.poly;\n\n      // get neighbor edges\n      var prevEdgeIndex = path.prevEdgeIndex(edgeIndex, loopIndex);\n      var nextEdgeIndex = path.nextEdgeIndex(edgeIndex, loopIndex);\n\n      // check if neighbor edge exist (usually true unless at the end of a polyline)\n      var prevExists = prevEdgeIndex !== -1;\n      var nextExists = nextEdgeIndex !== -1;\n\n      // get start/end position of the segment\n      var a = new THREE.Vector2();\n      var b = new THREE.Vector2();\n      path.getEdge(edgeIndex, a, b, loopIndex);\n\n      // If previous/next edge exist, get their start/endVertex as well\n      var prevEdgeA = prevExists && path.getPoint(prevEdgeIndex, loopIndex);\n      var nextEdgeB = nextExists && path.getPoint(path.nextIndex(nextEdgeIndex, loopIndex), loopIndex);\n\n      // If prev/nextEdge do not exist, we simply assume length and angle of the missing edge to be the same as the current edge.\n      if (!prevExists) prevEdgeA = Math2D.mirrorPointOnPoint(b, a);\n      if (!nextExists) nextEdgeB = Math2D.mirrorPointOnPoint(a, b);\n\n      // Control points 0 and 3 are already given by edge a and b\n      // Below, we have to determine cp1, cp2 to define the tangents\n      var cp1 = null;\n      var cp2 = null;\n\n      // Check if previous and next edges are arcs as well\n      var prevIsArc = prevExists && path.isBezierArc(prevEdgeIndex, loopIndex);\n      var nextIsArc = nextExists && path.isBezierArc(nextEdgeIndex, loopIndex);\n\n      // Determine control point for start tangent cp1\n      if (prevIsArc) {\n        // Previous edge is an arc: Get start tangent by mirroring the end tangent of that arc.\n        var prevCp2 = path.getControlPoint(prevEdgeIndex, 2, loopIndex);\n        cp1 = Math2D.mirrorPointOnPoint(prevCp2, a);\n      } else {\n        // Previous edge is a line: Use average direction of both segments to choose the new tangent\n        cp1 = this.getVertexTangent(prevEdgeA, a, b).add(a);\n      }\n\n      // Analog for end tangent cp2\n      if (nextIsArc) {\n        // Next edge is an arc: Get end tangent by mirroring the start tangent of that arc.\n        var nextCp1 = path.getControlPoint(nextEdgeIndex, 1, loopIndex);\n        cp2 = Math2D.mirrorPointOnPoint(nextCp1, b);\n      } else {\n        // Next edge is a line: Use average direction of both segments to choose the new tangent\n        // Note that we must pass the points in backward order for the end tangent.\n        cp2 = this.getVertexTangent(nextEdgeB, b, a).add(b);\n      }\n\n      this.runAction(new Actions.ChangeEdgeType(this.layer, this.poly, polyIndex, EdgeType.Bezier, cp1, cp2));\n\n      this.layer.update();\n\n      // select the edge so that you can edit its tangents\n      this.edgeMoveTool.setSelectedEdge(polyIndex);\n      this.updateAllGizmos();\n    } }, { key: \"changeEdgeToLine\", value: function changeEdgeToLine(\n\n    polyIndex) {\n      this.runAction(new Actions.ChangeEdgeType(this.layer, this.poly, polyIndex, EdgeType.Line));\n      this.layer.update();\n\n      this.edgeMoveTool.setSelectedEdge(polyIndex);\n      this.updateAllGizmos();\n    } }]);return PolygonEditTool;}(EditToolBase);export { PolygonEditTool as default };","function _typeof(obj) {\"@babel/helpers - typeof\";if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;};}return _typeof(obj);}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError(\"Cannot call a class as a function\");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}function _get(target, property, receiver) {if (typeof Reflect !== \"undefined\" && Reflect.get) {_get = Reflect.get;} else {_get = function _get(target, property, receiver) {var base = _superPropBase(target, property);if (!base) return;var desc = Object.getOwnPropertyDescriptor(base, property);if (desc.get) {return desc.get.call(receiver);}return desc.value;};}return _get(target, property, receiver || target);}function _superPropBase(object, property) {while (!Object.prototype.hasOwnProperty.call(object, property)) {object = _getPrototypeOf(object);if (object === null) break;}return object;}function _inherits(subClass, superClass) {if (typeof superClass !== \"function\" && superClass !== null) {throw new TypeError(\"Super expression must either be null or a function\");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}function _createSuper(Derived) {var hasNativeReflectConstruct = _isNativeReflectConstruct();return function _createSuperInternal() {var Super = _getPrototypeOf(Derived),result;if (hasNativeReflectConstruct) {var NewTarget = _getPrototypeOf(this).constructor;result = Reflect.construct(Super, arguments, NewTarget);} else {result = Super.apply(this, arguments);}return _possibleConstructorReturn(this, result);};}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");}return self;}function _isNativeReflectConstruct() {if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;if (Reflect.construct.sham) return false;if (typeof Proxy === \"function\") return true;try {Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));return true;} catch (e) {return false;}}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}import { Polygon, Polyline, Path, Style } from '../EditShapes.js';\nimport { AreaLabel, VertexGizmo, EdgeLabel } from '../CanvasGizmo.js';\nimport { Actions } from '../Actions.js';\n\nimport EditToolBase from './EditToolBase.js';\nimport RectangleTool from './RectangleTool.js';\nimport LineTool from './LineTool.js';\n\nvar Mode = {\n  Polyline: 1,\n  Polygon: 2 };\n\n\nvar PolygonToolName = \"Edit2_PolygonTool\";\nvar PolylineToolName = \"Edit2_PolylineTool\";\n\nvar av = Autodesk.Viewing;\nvar DefaultStyle = new Style();var\n\nPolygonTool = /*#__PURE__*/function (_EditToolBase) {_inherits(PolygonTool, _EditToolBase);var _super = _createSuper(PolygonTool);\n\n  function PolygonTool(ctx) {var _this;var mode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Mode.Polygon;var style = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new Style();_classCallCheck(this, PolygonTool);\n    _this = _super.call(this, ctx);\n\n    // Delegate single-drag interactions: \n    _this.lineRectTool = mode === Mode.Polygon ?\n    new RectangleTool(ctx, style) : // PolygonMode: Draw rect/quad on drag\n    new LineTool(ctx, style) // PolylineMode: Draw simple line on drag\n    ;\n\n    Autodesk.Viewing.EventDispatcher.prototype.apply(_assertThisInitialized(_this));\n\n    // Circle shapes per vertex\n    _this.vertexGizmos = [];\n\n    // The polygon/polyline we are currently creating (if tool is active)\n    _this.poly = undefined;\n\n    // Style used for polygon creation\n    _this.style = style;\n\n    // Style used to display the thin line to connect last added vertex with current mouse position.        \n    _this.edgePreviewStyle = new Style({\n      lineWidth: 2,\n      isScreenSpace: true,\n      lineStyle: 11 // dashed line\n    });\n\n    // whether editing Polylines or Polygons\n    _this.mode = mode;\n\n    // last canvas position where we added a vertex\n    _this.lastClickX = undefined;\n    _this.lastClickY = undefined;\n\n    _this.keyMap.CANCEL_EDIT = av.KeyCode.ESCAPE;\n    _this.keyMap.REMOVE_LAST_VERTEX = av.KeyCode.BACKSPACE;\n    _this.keyMap.FINISH_EDIT = [av.KeyCode.ENTER, av.KeyCode.c];\n\n    // FillGizmo: When editing a polygon, fillGizmo displays the polygon formed by all vertices + mousePos\n    _this.fillGizmo = null;\n\n    // OutlineGizmo: Polyline that connects all added vertices\n    _this.outlineGizmo = null;\n\n    // Line to connect last added vertex with mouse position\n    _this.edgePreviewGizmo = null;\n\n    // Last tracked mouse-pos in layer-coords (after considering snapping)\n    _this.mousePos = new THREE.Vector2();\n\n    // Label to display polygon area - hidden by default\n    // Note that the polygon preview is in the gizmoLayer. So we add the areaLabel there as well to keep it in sync.\n    _this.areaLabel = new AreaLabel(null, _this.gizmoLayer, _this.unitHandler, false);\n\n    // Label to display polyline length\n    _this.lengthLabel = new EdgeLabel(_this.gizmoLayer, false);\n\n    // If true, we always create Paths instead of Polygons\n    _this.enableArcs = true;return _this;\n  }\n\n  // Enable the area labels (public API)\n  _createClass(PolygonTool, [{ key: \"setAreaLabelVisible\", value: function setAreaLabelVisible(visible) {\n      this.areaLabel.setVisible(visible);\n    } }, { key: \"setLengthLabelVisible\", value: function setLengthLabelVisible(\n\n    visible) {\n      this.lengthLabel.setVisible(visible);\n    }\n\n    // If true, all new shapes are Paths instead of Polygons/Polylines.\n  }, { key: \"setArcsEnabled\", value: function setArcsEnabled(enable) {\n      this.enableArcs = enable;\n      this.lineRectTool.enableArcs = enable;\n    } }, { key: \"deactivate\", value: function deactivate()\n\n    {\n      _get(_getPrototypeOf(PolygonTool.prototype), \"deactivate\", this).call(this);\n      this.cancelEdit();\n    }\n\n    // Returns true when editing a Polygon, false when editing a Polyline or nothing.\n  }, { key: \"isPolygon\", value: function isPolygon() {\n      return this.poly && this.poly.isPolygon();\n    }\n\n    /**\n       * Set depending styles for the polygon / polyline tool. It will also set most of the styles to the temporary lines\n       * that appear during drawing. Style.isScreenSpace won't be considered.\n       * @param {Style} style         - a Style instance\n       * @param {boolean} skipDefault - If set (default) just apply the style that differ from the default Style\n       */ }, { key: \"setStyles\", value: function setStyles(\n    style) {var skipDefault = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      if (style.lineColor !== DefaultStyle.lineColor || !skipDefault) {\n        this.style.lineColor = style.lineColor;\n      }\n      if (style.lineAlpha !== DefaultStyle.lineAlpha || !skipDefault) {\n        this.style.lineAlpha = style.lineAlpha;\n      }\n      if (style.lineWidth !== DefaultStyle.lineWidth || !skipDefault) {\n        this.style.lineWidth = style.lineWidth;\n        this.lineRectTool.style.lineWidth = style.lineWidth;\n        this.edgePreviewStyle.lineWidth = style.lineWidth * 2 / 3;\n      }\n      if (style.lineStyle !== DefaultStyle.lineStyle || !skipDefault) {\n        this.style.lineStyle = style.lineStyle;\n        this.lineRectTool.style.lineStyle = style.lineStyle;\n        // skip this.edgePreviewStyle.lineStyle\n      }\n\n      if (style.fillColor !== DefaultStyle.fillColor || !skipDefault) {\n        this.style.fillColor = style.fillColor;\n      }\n      if (style.fillAlpha !== DefaultStyle.fillAlpha || !skipDefault) {\n        this.style.fillAlpha = style.fillAlpha;\n      }\n\n      // skip isScreenSpace\n    }\n\n    // Initialize all gizmos when starting to edit a Polygon/Polyline\n  }, { key: \"initGizmos\", value: function initGizmos() {\n\n      // FillGizmo: Draw fill of polygon formed by added vertices + mousePos\n      if (this.isPolygon()) {\n        this.fillGizmo = new Polygon([], this.style.clone());\n        this.fillGizmo.style.lineAlpha = 0;\n        this.gizmoLayer.addShape(this.fillGizmo);\n      }\n\n      // OutlineGizmo: Connect added vertices\n      this.outlineGizmo = new Polyline([], this.style.clone());\n      this.gizmoLayer.addShape(this.outlineGizmo);\n\n      // CurrentEdgeGizmo: Draw dashed line from last vertex to mousePos.\n      this.edgePreviewGizmo = new Polyline([], this.edgePreviewStyle);\n      this.edgePreviewGizmo.style.lineColor = this.poly.style.lineColor;\n      this.gizmoLayer.addShape(this.edgePreviewGizmo);\n\n      this.areaLabel.setShape(this.fillGizmo);\n\n      // For Polylines, attach label to preview edge that displays the summed length\n      if (this.poly && this.poly.isPolyline()) {\n        this.lengthLabel.attachToEdge(this.edgePreviewGizmo, 0);\n      }\n    } }, { key: \"clearGizmos\", value: function clearGizmos()\n\n    {\n      if (this.fillGizmo) {\n        this.gizmoLayer.removeShape(this.fillGizmo);\n        this.fillGizmo = null;\n      }\n\n      this.areaLabel.setShape(null);\n      this.lengthLabel.detachFromEdge();\n\n      if (this.outlineGizmo) {\n        this.gizmoLayer.removeShape(this.outlineGizmo);\n        this.outlineGizmo = null;\n      }\n\n      if (this.edgePreviewGizmo) {\n        this.gizmoLayer.removeShape(this.edgePreviewGizmo);\n        this.edgePreviewGizmo = null;\n      }\n\n      // clear vertex gizmos\n      for (var i = 0; i < this.vertexGizmos.length; i++) {\n        this.vertexGizmos[i].dtor();\n      }\n      this.vertexGizmos.length = 0;\n    }\n\n    // Update gizmos and snapping if polygon was modified\n  }, { key: \"polyModified\", value: function polyModified() {\n      this.updateGizmos();\n\n      // Configure angle snapping to consider latest state of the polygon\n      // Note that angleSnapper requires the shape including \"vertex under mouse\", while\n      // this.poly only contains the already added/clicked vertices.\n      // Note that we cannot use fillGizmo here, because it does not exist for polylines.\n      var snapGeom = this.poly.clone();\n      snapGeom.addPoint(this.mousePos.x, this.mousePos.y);\n      this.snapper.startAngleSnapping(snapGeom, this.poly.vertexCount, 0); // For new polygons, loopIndex is always 0\n    }\n\n    // Update gizmos if vertices of current polygon/polyline have changed\n  }, { key: \"updateGizmos\", value: function updateGizmos() {\n\n      // FillGizmo: Show fill without outline for the polygon formed by all added\n      // vertices + current mousePos\n      if (this.fillGizmo) {\n        // copy vertices of main polygon (not geom, not style)\n        this.fillGizmo.clear();\n        for (var i = 0; i < this.poly.vertexCount; i++) {\n          var p = this.poly.getPoint(i);\n          this.fillGizmo.addPoint(p.x, p.y);\n        }\n        // add additional point that traces mouse-pos\n        this.fillGizmo.addPoint(this.mousePos.x, this.mousePos.y);\n      }\n\n      // OutlineGizmo: Solid polyline that connects all added vertices\n      this.outlineGizmo.clear();\n      if (this.poly.vertexCount >= 2) {\n        for (var _i = 0; _i < this.poly.vertexCount; _i++) {\n          var _p = this.poly.getPoint(_i);\n          this.outlineGizmo.addPoint(_p.x, _p.y);\n        }\n      }\n\n      // currentEdgeGizmo: Dashed line to connect last added vertex with mouse position\n      this.edgePreviewGizmo.clear();\n      if (this.poly.vertexCount >= 1) {\n        var pLast = this.poly.getPoint(this.poly.vertexCount - 1);\n        this.edgePreviewGizmo.addPoint(pLast.x, pLast.y);\n        this.edgePreviewGizmo.addPoint(this.mousePos.x, this.mousePos.y);\n\n        this.updateLengthLabel();\n      }\n\n      this.gizmoLayer.update();\n    } }, { key: \"updateLengthLabel\", value: function updateLengthLabel()\n\n    {\n      // Compute resulting length of polyline including previewEdge\n      if (this.poly && this.poly.isPolyline()) {\n        // get transform from geometry coords to measure coordinate system\n        var transform = this.unitHandler.measureTransform;\n\n        var length = this.poly.getLength(transform) + this.edgePreviewGizmo.getLength(transform);\n        var lengthStr = this.unitHandler.lengthToString(length);\n        this.lengthLabel.setText(lengthStr);\n      }\n    } }, { key: \"getName\", value: function getName()\n\n    {\n      return (this.mode === Mode.Polygon ? PolygonToolName : PolylineToolName) + this.nameSuffix;\n    } }, { key: \"handleMouseMove\", value: function handleMouseMove(\n\n    event) {\n      _get(_getPrototypeOf(PolygonTool.prototype), \"handleMouseMove\", this).call(this, event);\n\n      if (!event.buttons) {\n        // When not dragging, we always return false here. Otherwise, the event will not propagated\n        // to navigation tools, so that the zoom focus is not updated properly.\n        this.onHover(event.canvasX, event.canvasY);\n        return false;\n      }\n      return this.lineRectTool.handleMouseMove(event);\n    } }, { key: \"onHover\", value: function onHover(\n\n    canvasX, canvasY) {\n      // Check if shape editing is already in progress\n      if (!this.poly) {\n\n        // Perform snapping check, so that SnappingIndicator reflects if the start point would be snapped.\n        this.getSnapPosition(canvasX, canvasY);\n        return;\n      }\n\n      var pLayer = this.layer.canvasToLayer(canvasX, canvasY);\n\n      // When hovering the start vertex that will close the polygon (or line-loop), don't show any snapping indicators\n      var closingAllowed = this.poly.vertexCount >= 3;\n      var startVertexHit = closingAllowed && this.gizmoManager.isUnderMouse(this.vertexGizmos[0]);\n      this.setStartVertexHighlighted(startVertexHit); // indicate when hoving closing-vertex\n      if (startVertexHit) {\n        // Remove snapping indicators\n        this.snapper.clearSnappingGizmos();\n\n        // snap position to vertex center\n        pLayer.copy(this.vertexGizmos[0].layerPos);\n      } else {\n        // Standard case: If mouse is not on start vertex, allow standard snapping\n        pLayer = this.getSnapPosition(canvasX, canvasY);\n      }\n\n      // track last mouse pos\n      this.mousePos.copy(pLayer);\n\n      // Just hover: Only update vertex-positions for fillGizmo, edgePreview and alignmentGizmo\n      this.edgePreviewGizmo.updatePoint(1, pLayer.x, pLayer.y);\n      this.fillGizmo && this.fillGizmo.updatePoint(this.fillGizmo.vertexCount - 1, pLayer.x, pLayer.y); // will be null if this.poly is a Polyline\n      this.gizmoLayer.update();\n      this.updateLengthLabel();\n    }\n\n    // If we have enough vertices, clicking on the first vertex gizmo again will finish the shape.\n  }, { key: \"handleStartVertexClicked\", value: function handleStartVertexClicked(event) {\n\n      if (!this.poly && this.poly.vertexCount < 3) {\n        return;\n      }\n\n      // For polylines, we have to repeat the first vertex to close it\n      if (this.poly.isPolyline()) {\n        var pStart = this.poly.getPoint(0);\n        this.addVertex(pStart.x, pStart.y);\n      }\n\n      // Finish editing\n      this.finishPolygon();\n\n      // Make sure that the event is not passed on to ToolManager. Otherwise,\n      // we would evaluate it a second time in handleSingleClick()\n      event.stopPropagation();\n    }\n\n    // Add vertex on single-click\n  }, { key: \"handleSingleClick\", value: function handleSingleClick(event, button) {\n      _get(_getPrototypeOf(PolygonTool.prototype), \"handleSingleClick\", this).call(this, event, button);\n\n      // Only respond to left mouse button.\n      if (!button == 0) {\n        return false;\n      }\n\n      // Avoid duplicate vertices on double-clicks\n      if (this.vertexGizmos.length > 0 && event.canvasX === this.lastClickX && event.canvasY === this.lastClickY) {\n        return true;\n      }\n\n      this.lastClickX = event.canvasX;\n      this.lastClickY = event.canvasY;\n\n      this.mousePos.copy(this.getSnapPosition(event.canvasX, event.canvasY));\n\n      if (this.mouseTracker) {\n        this.mouseTracker.startTracking(this.getName(), Autodesk.Edit2D.Trackings.Click);\n      }\n\n      // Init polygon on first click\n      if (!this.poly) {\n        this.startPoly(this.mousePos.x, this.mousePos.y);\n      }\n\n      this.addVertex(this.mousePos.x, this.mousePos.y);\n      return true;\n    } }, { key: \"handleButtonDown\", value: function handleButtonDown(\n\n    event, button) {\n      // Support suppressing mouse buttons by holding a key. Note that we only need that for dragging operations.\n      if (this.ignoreDragging) {\n        return false;\n      }\n\n      // If no clicks have been made so far, allow to drag line/rectangle.\n      if (!this.poly) {\n        // Clear the selection, this will make sure all other gizmos get removed\n        this.selection.clear();\n\n        return this.lineRectTool.handleButtonDown(event, button);\n      }\n\n      return false;\n    } }, { key: \"handleButtonUp\", value: function handleButtonUp(\n\n    event, button) {\n      return this.lineRectTool.handleButtonUp(event, button);\n    } }, { key: \"handleDoubleClick\", value: function handleDoubleClick(\n\n    event, button) {\n      _get(_getPrototypeOf(PolygonTool.prototype), \"handleDoubleClick\", this).call(this, event, button);\n\n      // Only respond to left mouse button.\n      if (!button == 0) {\n        return false;\n      }\n\n      this.finishPolygon();\n      return true;\n    }\n\n    // Start new polyline or polygon\n  }, { key: \"startPoly\", value: function startPoly(x, y) {\n\n      if (this.enableArcs) {\n        // Arcs enabled: Always create Paths\n        var isClosed = this.mode === Mode.Polygon;\n        this.poly = new Path([], isClosed, this.style.clone());\n      } else {\n        // No arcs enabled: Create Polygons or Polylines\n        if (this.mode === Mode.Polygon) {\n          this.poly = new Polygon([], this.style.clone());\n        } else {\n          this.poly = new Polyline([], this.style.clone());\n        }\n      }\n\n      this.initGizmos();\n    } }, { key: \"addVertex\", value: function addVertex(\n\n    x, y) {var _this2 = this;\n\n      // add \"next\" point - which will follow the mouse motion \n      // until next click\n      this.poly.addPoint(x, y);\n\n      // add vertex-gizmo\n      var name = 'PolygonTool_vertexGizmo_' + this.vertexGizmos.length;\n      var vertex = new VertexGizmo(this.gizmoLayer, x, y, name);\n      this.vertexGizmos.push(vertex);\n\n      // For the start vertex-gizmo, we register a handler to finish the polygon when clicking it again\n      var isStartVertex = this.vertexGizmos.length === 1;\n      if (isStartVertex) {\n        vertex.container.addEventListener('click', function (e) {return _this2.handleStartVertexClicked(e);});\n      }\n\n      this.polyModified();\n    } }, { key: \"removeLastVertex\", value: function removeLastVertex()\n\n    {\n      if (!this.poly || !this.poly.vertexCount) {\n        return;\n      }\n\n      // Cancel edit if there was only the starting point.\n      if (this.poly.vertexCount <= 1) {\n        this.cancelEdit();\n        return;\n      }\n\n      if (this.mouseTracker) {\n        this.mouseTracker.stopTracking(this.getName(), Autodesk.Edit2D.Trackings.Click);\n      }\n\n      this.poly.removePoint(this.poly.vertexCount - 1);\n\n      // remove last added vertex gizmo\n      var lastGizmo = this.vertexGizmos[this.vertexGizmos.length - 1];\n      lastGizmo.dtor();\n      this.vertexGizmos.pop();\n\n      this.polyModified();\n    } }, { key: \"finishPolygon\", value: function finishPolygon()\n\n    {\n      if (this.mouseTracker) {\n        this.mouseTracker.stopTracking(this.getName(), Autodesk.Edit2D.Trackings.Click);\n      }\n\n      // remove all vertex gizmos\n      this.clearGizmos();\n\n      // Stop snapping to edges of this polygon\n      this.snapper.stopAngleSnapping();\n\n      // move polygon to main layer\n      this.runAction(new Actions.AddShape(this.layer, this.poly));\n\n      this.dispatchEvent({ type: PolygonTool.POLYGON_ADDED, polygon: this.poly });\n\n      // Start another polygon on next click\n      this.poly = null;\n    } }, { key: \"cancelEdit\", value: function cancelEdit()\n\n    {\n      if (this.mouseTracker) {\n        this.mouseTracker.stopTracking(this.getName(), Autodesk.Edit2D.Trackings.Click);\n      }\n\n      if (this.lineRectTool.isDragging()) {\n        this.lineRectTool.cancelDrag();\n      }\n\n      if (this.poly) {\n        this.gizmoLayer.removeShape(this.poly);\n        this.poly = null;\n      }\n\n      this.clearGizmos();\n      this.snapper.stopAngleSnapping();\n    } }, { key: \"handleFinishKey\", value: function handleFinishKey(\n\n    event) {\n      if (!this.poly) {\n        return false;\n      }\n\n      // Avoid closing if it would result in a polygon that is degenerated to a line.\n      if (this.isPolygon() && this.poly.vertexCount < 3) {\n        return false;\n      }\n\n      this.finishPolygon();\n      return true;\n    } }, { key: \"handleKeyDown\", value: function handleKeyDown(\n\n    event, keyCode) {\n      var handled = _get(_getPrototypeOf(PolygonTool.prototype), \"handleKeyDown\", this).call(this, event, keyCode);\n\n      // delegate to rectTool\n      handled = this.lineRectTool.handleKeyDown(event, keyCode) || handled;\n\n      // Map event to any known key in this.keyMap\n      var funcKey = this.mapKey(event, this.keyMap);\n      switch (funcKey) {\n        case 'CANCEL_EDIT':this.cancelEdit();handled = true;break;\n        case 'REMOVE_LAST_VERTEX':this.removeLastVertex();handled = true;break;\n        case 'FINISH_EDIT':handled = this.handleFinishKey(event);break;}\n\n      return handled;\n    } }, { key: \"handleKeyUp\", value: function handleKeyUp(\n\n    event, keyCode) {\n      _get(_getPrototypeOf(PolygonTool.prototype), \"handleKeyUp\", this).call(this, event, keyCode);\n      this.lineRectTool.handleKeyUp(event, keyCode);\n    }\n\n    // If snapping has toggled on/off, we instantly \"replay\" hovering at current mouse position. Purpose is to\n    // give instant feedback (e.g. hide/show SnapLine gizmos and adjust position of preview edge)\n  }, { key: \"onSnappingToggled\", value: function onSnappingToggled(canvasX, canvasY) {\n      this.onHover(canvasX, canvasY);\n    } }, { key: \"mouseOnStartVertex\", value: function mouseOnStartVertex()\n\n    {\n      if (!this.vertexGizmos[0]) {\n        return false;\n      }\n\n      // Check if start vertex was clicked\n      return this.gizmoManager(this.this.vertexGizmos[0]);\n    } }, { key: \"setStartVertexHighlighted\", value: function setStartVertexHighlighted(\n\n    enable) {\n      if (this.vertexGizmos[0]) {\n        this.vertexGizmos[0].setSelected(enable);\n      }\n    } }, { key: \"getCursor\", value: function getCursor()\n\n    {\n      return 'crosshair';\n    } }]);return PolygonTool;}(EditToolBase);export { PolygonTool as default };\n\n\nPolygonTool.POLYGON_ADDED = \"polygonAdded\";\nPolygonTool.Mode = Mode;","function _typeof(obj) {\"@babel/helpers - typeof\";if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;};}return _typeof(obj);}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError(\"Cannot call a class as a function\");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}function _inherits(subClass, superClass) {if (typeof superClass !== \"function\" && superClass !== null) {throw new TypeError(\"Super expression must either be null or a function\");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}function _createSuper(Derived) {var hasNativeReflectConstruct = _isNativeReflectConstruct();return function _createSuperInternal() {var Super = _getPrototypeOf(Derived),result;if (hasNativeReflectConstruct) {var NewTarget = _getPrototypeOf(this).constructor;result = Reflect.construct(Super, arguments, NewTarget);} else {result = Super.apply(this, arguments);}return _possibleConstructorReturn(this, result);};}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");}return self;}function _isNativeReflectConstruct() {if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;if (Reflect.construct.sham) return false;if (typeof Proxy === \"function\") return true;try {Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));return true;} catch (e) {return false;}}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}\nimport { Polygon, PolygonPath } from '../EditShapes.js';\nimport { Actions } from '../Actions.js';\n\nimport EditToolBase from './EditToolBase.js';\nimport { Style } from '../EditShapes.js';\nimport { AreaLabel } from '../CanvasGizmo.js';\nimport ModifierMask from '../ModifierMask.js';\n\nvar RectangleToolName = \"Edit2_RectangleTool\";\n\nvar av = Autodesk.Viewing;\n\n// Creates rectangles by dragging\nvar RectangleTool = /*#__PURE__*/function (_EditToolBase) {_inherits(RectangleTool, _EditToolBase);var _super = _createSuper(RectangleTool);\n\n  function RectangleTool(ctx) {var _this;var style = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Style();_classCallCheck(this, RectangleTool);\n    _this = _super.call(this, ctx);\n\n    Autodesk.Viewing.EventDispatcher.prototype.apply(_assertThisInitialized(_this));\n\n    _this.style = style;\n\n    // New polygon created by dragging\n    _this.rect = null;\n\n    // First corner of the new rectangle\n    _this.startPoint = new THREE.Vector2();\n    _this.endPoint = new THREE.Vector2();\n\n    // Indicates that we interrupted dragging with Esc. In this case, we still consume the mouse-up\n    // event to avoid inconsistencies in other tool.\n    _this.dragCanceled = false;\n\n    // Create area label. Default hidden - showing is optional.\n    _this.areaLabel = new AreaLabel(null, _this.layer, ctx.unitHandler, false);\n\n    // Allow to enable/disable tool based on modifiers\n    _this.modifiers = new ModifierMask();\n\n    // If true, create Paths instead of Polygons\n    _this.enableArcs = true;return _this;\n  }\n\n  // Enable the area labels (public API)\n  _createClass(RectangleTool, [{ key: \"setAreaLabelVisible\", value: function setAreaLabelVisible(visible) {\n      this.areaLabel.setVisible(visible);\n    } }, { key: \"getName\", value: function getName()\n\n    {\n      return RectangleToolName + this.nameSuffix;\n    } }, { key: \"activate\", value: function activate()\n\n    {} }, { key: \"deactivate\", value: function deactivate()\n    {} }, { key: \"register\", value: function register()\n    {} }, { key: \"handleButtonDown\", value: function handleButtonDown(\n\n    event, button) {\n\n      // Check if modifers allow starting an interaction\n      if (!this.modifiers.accepts(event)) {\n        return false;\n      }\n\n      // Only respond to left button\n      if (button != 0) {\n        return;\n      }\n\n      var p = this.getSnapPosition(event.canvasX, event.canvasY);\n      this.startDrag(p);\n      return true;\n    } }, { key: \"handleButtonUp\", value: function handleButtonUp(\n\n    event, button) {\n\n      // Only respond to left button\n      if (button != 0) {\n        return false;\n      }\n\n      // If drag has been interrupted, consider the endDrag() as handled\n      if (this.dragCanceled) {\n        this.dragCanceled = false;\n        return true;\n      }\n\n      // Make sure that we consider latest mouse position\n      this.handleMouseMove(event);\n\n      return this.endDrag();\n    } }, { key: \"handleMouseMove\", value: function handleMouseMove(\n\n    event) {\n\n      // Get snapping position. Note that this even makes sense when not dragging: In this case, we \n      // just do it to update the snapping indicator.\n      var p = this.getSnapPosition(event.canvasX, event.canvasY);\n\n      if (!this.rect) {\n        return false;\n      }\n\n      this.moveDrag(p, event.shiftKey);\n\n      return true;\n    }\n\n    // Start dragging a shape\n    //  @param {Shape}   shape\n    //  @param {Vector2} startPos - in layer coords\n  }, { key: \"startDrag\", value: function startDrag(startPos) {\n      if (this.mouseTracker) {\n        this.mouseTracker.startTracking(this.getName(), Autodesk.Edit2D.Trackings.Drag);\n      }\n      var points = [startPos.clone(), startPos.clone(), startPos.clone(), startPos.clone()];\n      var style = this.style.clone();\n\n      this.rect = this.enableArcs ? new PolygonPath(points, style) : new Polygon(points, style);\n\n      this.startPoint.copy(startPos);\n      this.endPoint.copy(startPos);\n\n      this.gizmoLayer.addShape(this.rect);\n    } }, { key: \"updateRect\", value: function updateRect(\n\n    forceQuad) {\n\n      if (!this.isDragging()) {\n        return;\n      }\n\n      var p0 = this.startPoint;\n      var p1 = this.endPoint;\n\n      if (forceQuad) {\n\n        // Use maximum of dx/dy as edge length\n        var dx = p1.x - p0.x;\n        var dy = p1.y - p0.y;\n\n        var edgeLength = Math.max(Math.abs(dx), Math.abs(dy));\n\n        // Consider drag direction to span quad right/left resp. up/down\n        var sx = Math.sign(dx);\n        var sy = Math.sign(dy);\n\n        this.rect.updatePoint(1, p0.x + edgeLength * sx, p0.y);\n        this.rect.updatePoint(2, p0.x + edgeLength * sx, p0.y + edgeLength * sy);\n        this.rect.updatePoint(3, p0.x, p0.y + edgeLength * sy);\n\n      } else {\n        this.rect.updatePoint(1, p1.x, p0.y);\n        this.rect.updatePoint(2, p1.x, p1.y);\n        this.rect.updatePoint(3, p0.x, p1.y);\n      }\n\n      this.gizmoLayer.update();\n\n      this.areaLabel.setShape(this.rect);\n    }\n\n    // p is in layer coords\n  }, { key: \"moveDrag\", value: function moveDrag(p, forceQuad) {\n\n      // update rectangle\n      this.endPoint.copy(p);\n      this.updateRect(forceQuad);\n    } }, { key: \"endDrag\", value: function endDrag()\n\n    {\n      if (this.mouseTracker) {\n        this.mouseTracker.stopTracking(this.getName(), Autodesk.Edit2D.Trackings.Drag);\n      }\n\n      if (!this.rect) {\n        return false;\n      }\n\n      // Check if rect is valid\n      var dx = this.endPoint.x - this.startPoint.x;\n      var dy = this.endPoint.y - this.startPoint.y;\n      var Eps = 1.e-10;\n      var rectValid = Math.abs(dx) > Eps && Math.abs(dy) > Eps;\n\n      // Move shape to main layer (or just remove if invalid)\n      this.gizmoLayer.removeShape(this.rect);\n      if (rectValid) {\n        this.undoStack.run(new Actions.AddShape(this.layer, this.rect));\n      }\n\n      this.rect = null;\n\n      this.areaLabel.setShape(null);\n\n      return true;\n    } }, { key: \"cancelDrag\", value: function cancelDrag()\n\n    {\n      if (this.mouseTracker) {\n        this.mouseTracker.stopTracking(this.getName(), Autodesk.Edit2D.Trackings.Drag);\n      }\n\n      if (this.rect) {\n        // Remove temporary gizmo shape\n        this.gizmoLayer.removeShape(this.rect);\n        this.rect = null;\n\n        this.dragCanceled = true;\n\n        this.areaLabel.setShape(null);\n      }\n    } }, { key: \"isDragging\", value: function isDragging()\n\n    {\n      return Boolean(this.rect);\n    } }, { key: \"handleKeyDown\", value: function handleKeyDown(\n\n    event, keyCode) {\n      // Update shape when toggling between rect and quad mode\n      if (keyCode == av.KeyCode.SHIFT) {\n        this.updateRect(true);\n      }\n    } }, { key: \"handleKeyUp\", value: function handleKeyUp(\n\n    event, keyCode) {\n      // Update shape when toggling between rect and quad mode\n      if (keyCode == av.KeyCode.SHIFT) {\n        this.updateRect(false);\n      }\n    } }]);return RectangleTool;}(EditToolBase);export { RectangleTool as default };","function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError(\"Cannot call a class as a function\");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}var UndoToolName = 'Edit2_UndoTool';\n\nvar av = Autodesk.Viewing;\n\n// Simple tool that triggers undo/redo in response to a keyboard shortcut\nvar UndoTool = /*#__PURE__*/function () {\n\n  function UndoTool(undoStack) {_classCallCheck(this, UndoTool);\n    this.undoStack = undoStack;\n  }_createClass(UndoTool, [{ key: \"handleKeyDown\", value: function handleKeyDown(\n\n    event, keyCode) {\n      // Undo\n      //  - Ctrl + Z (Windows)\n      //  - Command + Z (Mac)\n      // Redo\n      // - Ctrl + Shift + Z (Windows)\n      // - Command + Shift + Z (Mac)\n      // - Ctrl + Y (Used on Windows but not Mac)\n\n      if ((event.ctrlKey || event.metaKey) && keyCode === av.KeyCode.z) {\n        if (event.shiftKey) {\n          this.undoStack.redo();\n        } else {\n          this.undoStack.undo();\n        }\n\n        return true;\n      }\n\n      if (event.ctrlKey && keyCode === av.KeyCode.y) {\n        this.undoStack.redo();\n        return true;\n      }\n\n      return false;\n    } }, { key: \"getName\",\n\n    // Some paperwork for ToolController\n    value: function getName() {\n      return UndoToolName;\n    } }, { key: \"getNames\", value: function getNames()\n    {\n      return [this.getName()];\n    } }, { key: \"activate\", value: function activate()\n    {} }, { key: \"deactivate\", value: function deactivate()\n    {} }, { key: \"register\", value: function register()\n    {} }]);return UndoTool;}();export { UndoTool as default };\n;","function _typeof(obj) {\"@babel/helpers - typeof\";if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;};}return _typeof(obj);}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError(\"Cannot call a class as a function\");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}function _get(target, property, receiver) {if (typeof Reflect !== \"undefined\" && Reflect.get) {_get = Reflect.get;} else {_get = function _get(target, property, receiver) {var base = _superPropBase(target, property);if (!base) return;var desc = Object.getOwnPropertyDescriptor(base, property);if (desc.get) {return desc.get.call(receiver);}return desc.value;};}return _get(target, property, receiver || target);}function _superPropBase(object, property) {while (!Object.prototype.hasOwnProperty.call(object, property)) {object = _getPrototypeOf(object);if (object === null) break;}return object;}function _inherits(subClass, superClass) {if (typeof superClass !== \"function\" && superClass !== null) {throw new TypeError(\"Super expression must either be null or a function\");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}function _createSuper(Derived) {var hasNativeReflectConstruct = _isNativeReflectConstruct();return function _createSuperInternal() {var Super = _getPrototypeOf(Derived),result;if (hasNativeReflectConstruct) {var NewTarget = _getPrototypeOf(this).constructor;result = Reflect.construct(Super, arguments, NewTarget);} else {result = Super.apply(this, arguments);}return _possibleConstructorReturn(this, result);};}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");}return self;}function _isNativeReflectConstruct() {if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;if (Reflect.construct.sham) return false;if (typeof Proxy === \"function\") return true;try {Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));return true;} catch (e) {return false;}}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}\nimport { Actions } from '../Actions.js';\nimport { Math2D } from '../Math2D.js';\nimport { PolyIndex, PolyBase, Polyline } from '../EditShapes.js';\nimport { VertexGizmo } from '../CanvasGizmo.js';\nimport EditToolBase from './EditToolBase.js';\n\nvar VertexMoveToolName = \"Edit2_VertexMoveTool\";\n\nvar av = Autodesk.Viewing;\n\nvar vertexGizmoName = function vertexGizmoName(index, loopIndex) {\n  return 'PolygonEditTool_vertexGizmo_' + loopIndex.toString() + '_' + index.toString();\n};var\n\nVertexMoveTool = /*#__PURE__*/function (_EditToolBase) {_inherits(VertexMoveTool, _EditToolBase);var _super = _createSuper(VertexMoveTool);\n\n  function VertexMoveTool(ctx) {var _this;_classCallCheck(this, VertexMoveTool);\n    _this = _super.call(this, ctx);\n\n    _this.layer = ctx.layer;\n    _this.selection = ctx.selection;\n    _this.nameSuffix = \"_\".concat(ctx.toolSetName);\n\n    _this.keyMap.CancelEdit = av.KeyCode.ESCAPE;\n    _this.keyMap.DeleteSelectedVertex = av.KeyCode.BACKSPACE;\n\n    // Track mouse position in layer-coords\n    _this.mousePos = new THREE.Vector2();\n\n    // Array of VertexGizmo per loop\n    _this.vertexGizmos = []; // VertexGizmo[][]\n\n    // Index of the vertex currently being dragged (or -1 if no dragging is active)\n    _this.draggedVertex = null; // {PolyIndex}\n\n    // When dragging a vertex, this stores a copy of its original position\n    _this.dragVertexStartPos = new THREE.Vector2();\n\n    // gizmos are enabled by default.\n    _this.gizmosEnabled = true;\n\n    // selectedVertex is the one that was last clicked on. It is set together with draggedVertex,\n    // but (unlike draggedVertex) keeps the same after dragEnd.\n    // selectedVertex is the one that is highlighted and which will be deleted when pressing backspace.\n    _this.selectedVertex = null; // {PolyIndex}\n\n    // When dragging vertices, we store the offset (in layer-coords) between the accurate click position and the center of the clicked vertex gizmo\n    // Stored in pixels.\n    _this.dragOffset = new THREE.Vector2(0, 0);\n\n    // Last drag position in layer coords\n    _this.lastDragPoint = new THREE.Vector2();return _this;\n  }_createClass(VertexMoveTool, [{ key: \"getName\", value: function getName()\n\n    {\n      return VertexMoveToolName + this.nameSuffix;\n    } }, { key: \"deactivate\", value: function deactivate()\n\n    {\n      _get(_getPrototypeOf(VertexMoveTool.prototype), \"deactivate\", this).call(this);\n      this.reset();\n    } }, { key: \"setAllGizmosEnabled\", value: function setAllGizmosEnabled(\n\n    enabled) {\n      this.gizmosEnabled = enabled;\n\n      this.updateVertexGizmos();\n    }\n\n    // create VertexGizmos for a single loop\n  }, { key: \"updateVertexGizmoLoop\", value: function updateVertexGizmoLoop(loopIndex) {\n\n      var gizmos = [];\n      var vertexCount = this.poly.getVertexCount(loopIndex);\n      for (var i = 0; i < vertexCount; i++) {\n\n        // create new vertex gizmo\n        var p = this.poly.getPoint(i, loopIndex);\n        var vertex = new VertexGizmo(this.gizmoLayer, p.x, p.y, vertexGizmoName(i, loopIndex));\n        vertex.attachToVertex(this.poly, i, loopIndex);\n        gizmos.push(vertex);\n\n        // We implement drag-behavior, so we want hover-highlight\n        vertex.setHoverEnabled(true);\n      }\n\n      this.vertexGizmos[loopIndex] = gizmos;\n    }\n\n    // Create VertexGizmos for all loops\n  }, { key: \"updateVertexGizmos\", value: function updateVertexGizmos() {\n      // clear any outdated ones\n      this.clearVertexGizmos();\n\n      if (!this.gizmosEnabled) {\n        return;\n      }\n\n      if (this.poly) {\n        for (var l = 0; l < this.poly.loopCount; l++) {\n          this.updateVertexGizmoLoop(l);\n        }\n      }\n\n      // Make sure that vertex-highlighting is up to date\n      this.updateVertexHighlighting();\n    } }, { key: \"clearVertexGizmos\", value: function clearVertexGizmos()\n\n    {\n      for (var l = 0; l < this.vertexGizmos.length; l++) {\n        var gizmos = this.vertexGizmos[l];\n        for (var i = 0; i < gizmos.length; i++) {\n          gizmos[i].dtor();\n        }\n      }\n      this.vertexGizmos.length = 0;\n    }\n\n    // Make sure that only the vertexGizmo is only highlighted for the selectedVertex (if any)\n  }, { key: \"updateVertexHighlighting\", value: function updateVertexHighlighting() {\n      var selected = this.selectedVertex;\n      for (var l = 0; l < this.vertexGizmos.length; l++) {\n        var gizmos = this.vertexGizmos[l];\n        for (var i = 0; i < gizmos.length; i++) {\n          gizmos[i].setSelected(selected && selected.vertex === i && selected.loop === l);\n        }\n      }\n    }\n\n    // Update vertex-gizmos, and tangent gizmos.\n  }, { key: \"updateAllGizmos\", value: function updateAllGizmos() {\n      this.updateVertexGizmos();\n    }\n\n    // @param{PolyIndex} polyIndex\n  }, { key: \"setSelectedVertex\", value: function setSelectedVertex(polyIndex) {\n      this.selectedVertex = this.poly ? polyIndex : null;\n      this.updateVertexHighlighting();\n    }\n\n    // Return index of the vertex gizmo under mouse. (or null if no vertexGizmo is hit)\n    // returns {PolyIndex}\n  }, { key: \"findVertexUnderMouse\", value: function findVertexUnderMouse() {\n      var vertexIndex = -1;\n      for (var l = 0; l < this.vertexGizmos.length; l++) {\n        var gizmos = this.vertexGizmos[l];\n        vertexIndex = this.gizmoManager.getGizmoIndex(gizmos);\n\n        // Return vertex index if we found one.\n        if (vertexIndex >= 0) {\n          return new PolyIndex({\n            loop: l,\n            vertex: vertexIndex });\n\n        }\n      }\n      return null;\n    }\n\n    // Finishes editing of a previous polygon\n  }, { key: \"reset\", value: function reset() {\n\n      if (!this.poly) {\n        return;\n      }\n\n      this.poly = null;\n      this.draggedVertex = null;\n      this.selectedVertex = null;\n\n      // Clear any gizmos from previous polygon\n      this.updateAllGizmos();\n\n      this.snapper.stopAngleSnapping();\n    }\n\n    // Selects a new polygon / polyline for editing\n  }, { key: \"setEditPoly\", value: function setEditPoly(poly) {\n\n      this.reset();\n\n      if (poly) {\n        this.poly = poly;\n        this.updateAllGizmos();\n      }\n    }\n\n    // If selection changes (may also be triggered outside this tool), we choose the selected polyon for editing\n  }, { key: \"onSelectionChanged\", value: function onSelectionChanged() {\n      var selected = this.selection.getSelectedShapes();\n\n      // Activate if exactly one shape is selected\n      var shape = selected.length == 1 ? selected[0] : null;\n      if (shape instanceof PolyBase) {\n        this.setEditPoly(shape);\n      } else {\n        this.setEditPoly(null);\n      }\n    } }, { key: \"handleButtonDown\", value: function handleButtonDown(\n\n    event, button) {\n      // Support suppressing mouse buttons by holding a key\n      if (this.ignoreDragging) {\n        return false;\n      }\n\n      _get(_getPrototypeOf(VertexMoveTool.prototype), \"handleButtonDown\", this).call(this, event, button);\n\n      // Only respond to left mouse button.\n      if (!button == 0) {\n        return false;\n      }\n\n      var p = this.layer.canvasToLayer(event.canvasX, event.canvasY);\n      this.mousePos.copy(p);\n\n      // If we hit an existing vertex, start dragging it\n      var draggedVertex = this.findVertexUnderMouse();\n      if (draggedVertex) {\n        this.startDragVertex(event, draggedVertex);\n        this.startedDragging = true;\n        return true;\n      }\n\n      return false;\n    }\n\n\n    // @param {Event} event\n    // @param {PolyIndex} draggedVertex\n  }, { key: \"startDragVertex\", value: function startDragVertex(event, draggedVertex) {\n      if (this.mouseTracker) {\n        this.mouseTracker.startTracking(this.getName(), Autodesk.Edit2D.Trackings.Drag);\n      }\n\n      // Configure angle snapping to consider latest state of the polygon\n      this.snapper.startAngleSnapping(this.poly.clone(), draggedVertex.vertex, draggedVertex.loop);\n\n      this.draggedVertex = draggedVertex;\n\n      // Store offset between exact mouse pos and the vertex we are dragging\n      var vpos = this.poly.getPoint(this.draggedVertex.vertex, this.draggedVertex.loop);\n      var vposScreen = this.layer.layerToCanvas(vpos.x, vpos.y);\n      this.dragOffset.set(vposScreen.x - event.canvasX, vposScreen.y - event.canvasY);\n\n      // highlight the vertex we clicked on\n      this.setSelectedVertex(this.draggedVertex);\n\n      this.lastDragPoint.copy(vpos);\n      this.dragVertexStartPos.copy(vpos);\n    } }, { key: \"moveDragVertex\", value: function moveDragVertex(\n\n    canvasX, canvasY) {var _this$draggedVertex =\n\n      this.draggedVertex,loop = _this$draggedVertex.loop,vertex = _this$draggedVertex.vertex;\n\n      // Note that the vertex we are dragging does not always match exactly with the mouse position. E.g., we may have picked the bottom-left boundary of a vertex gizmo at drag-start.\n      var x = canvasX + this.dragOffset.x;\n      var y = canvasY + this.dragOffset.y;\n\n      // get delta between last and current position\n      var p = this.getSnapPosition(x, y);\n      var dx = p.x - this.lastDragPoint.x;\n      var dy = p.y - this.lastDragPoint.y;\n\n      // apply this offset to polygon point\n      var point = this.poly.getPoint(vertex, loop);\n      this.poly.updatePoint(vertex, point.x + dx, point.y + dy, loop);\n\n      // re-center gizmo at new point position\n      var vertexGizmo = this.vertexGizmos[loop][vertex];\n      vertexGizmo.setPosition(point.x, point.y);\n\n      this.gizmoLayer.update(); // we moved the vertex gizmo\n      this.layer.update(); // we changed the main polygon\n\n      this.lastDragPoint.copy(p);\n    } }, { key: \"restoreDragVertex\", value: function restoreDragVertex()\n\n    {\n      this.poly.updatePoint(this.draggedVertex.vertex, this.dragVertexStartPos.x, this.dragVertexStartPos.y, this.draggedVertex.loop);\n    } }, { key: \"endDragVertex\", value: function endDragVertex()\n\n    {\n      if (this.mouseTracker) {\n        this.mouseTracker.stopTracking(this.getName(), Autodesk.Edit2D.Trackings.Drag);\n      }\n\n      // First, restore \"before move\" position of the vertex\n      this.restoreDragVertex();\n\n      var pBefore = this.dragVertexStartPos;\n      var pAfter = this.lastDragPoint;\n\n      // don't add extra undo-operation if the vertex was hardly moved at all\n      var minDist = this.layer.getUnitsPerPixel() * 0.5;\n      var moved = pBefore.distanceTo(pAfter) > minDist;\n\n      if (moved) {\n        // Finalize vertex-move\n        this.runAction(new Actions.MoveVertex(this.layer, this.poly, this.draggedVertex, pAfter));\n      }\n\n      this.draggedVertex = null;\n      this.snapper.clearSnappingGizmos();\n    } }, { key: \"handleMouseMove\", value: function handleMouseMove(\n\n    event) {\n      _get(_getPrototypeOf(VertexMoveTool.prototype), \"handleMouseMove\", this).call(this, event);\n\n      this.mousePos.copy(this.layer.canvasToLayer(event.canvasX, event.canvasY));\n\n      if (!this.poly) {\n        return false;\n      }\n\n      if (this.draggedVertex) {\n        this.moveDragVertex(event.canvasX, event.canvasY);\n        return true;\n      }\n\n      return false;\n    } }, { key: \"handleButtonUp\", value: function handleButtonUp(\n\n    event, button) {\n      _get(_getPrototypeOf(VertexMoveTool.prototype), \"handleButtonUp\", this).call(this, event, button);\n\n      var wasDragging = this.startedDragging;\n      this.startedDragging = false;\n\n      if (this.draggedVertex) {\n        this.endDragVertex();\n        return true;\n      }\n\n      // Consider all left-button events as handled. E.g., if dragging was cancelled using Esc,\n      // we do nothing here, but letting the mouseUp pass to navigation classes would cause camera jumps.\n      return !this.ignoreDragging && wasDragging;\n    }\n\n    // Exclude currently edited polygon from snapping: The polygon shouldn't snap to itself, but rather\n    // to geometry below it.\n  }, { key: \"snappingFilter\", value: function snappingFilter(shape) {\n      return shape !== this.poly;\n    } }, { key: \"handleKeyDown\", value: function handleKeyDown(\n\n    event, keyCode) {\n      var handled = _get(_getPrototypeOf(VertexMoveTool.prototype), \"handleKeyDown\", this).call(this, event, keyCode);\n\n      if (keyCode === this.keyMap.CancelEdit) {\n        handled = this.cancelDrag();\n      }\n\n      return handled;\n    } }, { key: \"cancelDrag\", value: function cancelDrag()\n\n    {\n\n      var needsUpdate = false;\n\n      if (this.draggedVertex) {\n        this.restoreDragVertex();\n        this.draggedVertex = null;\n        needsUpdate = true;\n      }\n\n      if (needsUpdate) {\n        this.updateAllGizmos();\n        this.layer.update();\n      }\n\n      this.snapper.clearSnappingGizmos();\n\n      return needsUpdate;\n    }\n\n    // If snapping has toggled on/off, we instantly \"replay\" hovering at current mouse position. Purpose is to\n    // give instant feedback (e.g. hide/show SnapLine gizmos and adjust position of preview edge)\n  }, { key: \"onSnappingToggled\", value: function onSnappingToggled(canvasX, canvasY) {\n\n      // If we are dragging a vertex, toggling snapping will affect the result and \n      // we should update line gizmos and snapping lines.\n      if (this.draggedVertex) {\n        this.moveDragVertex(canvasX, canvasY);\n      }\n    }\n\n    // Updates selection of shape(s), vertex, and edge after an action\n  }, { key: \"updateSelectionState\", value: function updateSelectionState(action, isUndo) {\n      // Check if the action provides a hint how we should update selection\n      var hint = action.getSelectionHint(isUndo);\n      if (hint) {\n        this.setSelectedVertex(hint.vertex);\n        return;\n      }\n\n      // Default behavior - if we don't know anything better:\n      //  - Keep shape selected if still existing\n      //  - Reset vertex/edge selection\n\n      // If shape was removed, reset state\n      var shapeFound = Boolean(this.poly && this.layer.findShapeById(this.poly.id));\n      if (!shapeFound) {\n        this.reset();\n      }\n\n      this.setSelectedVertex(null);\n    } }, { key: \"handleExternalAction\", value: function handleExternalAction(\n\n    action, isUndo) {\n\n      // make sure that selected edge/vertex are still valid (or switched off)\n      this.updateSelectionState(action, isUndo);\n\n      // Stop any ongoing drag-operations (e.g., an undo operation might have removed the vertex that we are just dragging)\n      this.cancelDrag();\n\n      // Sync gizmos in case vertices were modified\n      this.updateAllGizmos();\n\n      this.snapper.clearSnappingGizmos();\n    } }, { key: \"getCursor\", value: function getCursor()\n\n    {\n\n      if (!this.poly) {\n        return;\n      }\n\n      // Note: Vertex gizmos and edge gizmos are separate DomElements and define own mouse cursors via style.\n      // Indicate: \"Moving a gizmo\". Currently, we use the same as for shape move. Note that\n      //           the cursor for gizmo dragging must be consistent with the one we have if the mouse is on the gizmo.\n      //           Otherwise, the mouse cursor would change its state when temporarily leaving the gizmo on fast moves.\n      if (this.draggedVertex) {\n        return 'move';\n      }\n\n      // => Just default cursor\n      return undefined;\n    } }]);return VertexMoveTool;}(EditToolBase);export { VertexMoveTool as default };","function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError(\"Cannot call a class as a function\");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}function _typeof(obj) {\"@babel/helpers - typeof\";if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;};}return _typeof(obj);} /*!\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             * Copyright 2017 Autodesk, Inc. All rights reserved.\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             * This computer source code and related instructions and comments are the\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             * unpublished confidential and proprietary information of Autodesk, Inc.\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             * and are protected under applicable copyright and trade secret law. They\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             * may not be disclosed to, copied or used by any third party without the\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             * prior written consent of Autodesk, Inc.\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             */\n!function (e, t) {\"object\" == (typeof exports === \"undefined\" ? \"undefined\" : _typeof(exports)) && \"object\" == (typeof module === \"undefined\" ? \"undefined\" : _typeof(module)) ? module.exports = t() : \"function\" == typeof define && define.amd ? define([], t) : \"object\" == (typeof exports === \"undefined\" ? \"undefined\" : _typeof(exports)) ? exports[\"solid-definition\"] = t() : e.SolidDefinition = t();}(\"undefined\" != typeof self ? self : this, function () {return function (e) {var t = {};function r(n) {if (t[n]) return t[n].exports;var o = t[n] = { i: n, l: !1, exports: {} };return e[n].call(o.exports, o, o.exports, r), o.l = !0, o.exports;}return r.m = e, r.c = t, r.d = function (e, t, n) {r.o(e, t) || Object.defineProperty(e, t, { enumerable: !0, get: n });}, r.r = function (e) {\"undefined\" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, { value: \"Module\" }), Object.defineProperty(e, \"__esModule\", { value: !0 });}, r.t = function (e, t) {if (1 & t && (e = r(e)), 8 & t) return e;if (4 & t && \"object\" == _typeof(e) && e && e.__esModule) return e;var n = Object.create(null);if (r.r(n), Object.defineProperty(n, \"default\", { enumerable: !0, value: e }), 2 & t && \"string\" != typeof e) for (var o in e) {r.d(n, o, function (t) {return e[t];}.bind(null, o));}return n;}, r.n = function (e) {var t = e && e.__esModule ? function () {return e.default;} : function () {return e;};return r.d(t, \"a\", t), t;}, r.o = function (e, t) {return Object.prototype.hasOwnProperty.call(e, t);}, r.p = \"\", r(r.s = 86);}([function (e, t, r) {\"use strict\";Object.defineProperty(t, \"__esModule\", { value: !0 });var n = !1;\"undefined\" != typeof window && window.isJaguar && (t.isSceneComposerEnv = n = !0);var o = !1;n && (t.USE_LEGACY_LEIDS = o = window.isJaguar && window.isJaguar() || !!JSON.parse(localStorage.getItem(\"USE_LEGACY_LEIDS\"))), t.KERNEL_TOLERANCE = 1e-6, t.KERNEL_ANGULAR_TOLERANCE = 1e-10, t.PARAMETER_SPACE_TOLERANCE = 1e-10, t.SPLINE_TANGENT_HANDLE_SCALE = 1, t.SPLINE_DISTANCE_TOLERANCE = 1e-4, t.DEFAULT_CURVE_RESOLUTION = 64, t.isSceneComposerEnv = n, t.NO_ID = \"\", t.USE_LEGACY_LEIDS = o, t.TESSELLATION = { LINEAR_PRECISION: 1e-4, ANGULAR_PRECISION: 1e-5 }, t.GEOMETRY_TYPES = { POINT: 1, BCURVE: 2, CIRCLE: 3, ELLIPSE: 4, HAPCURVE: 5, LINE: 6, BSURFACE: 7, CONE: 8, CYLINDER: 9, ELLIPTICAL_CONE: 10, ELLIPTICAL_CYLINDER: 11, PLANE: 12, SPHERE: 13, TORUS: 14, toString: function toString(e) {switch (e) {case this.POINT:return \"Point\";case this.BCURVE:return \"BCurve\";case this.CIRCLE:return \"Circle\";case this.ELLIPSE:return \"Ellipse\";case this.HAPCURVE:return \"HapCurve\";case this.LINE:return \"Line\";case this.BSURFACE:return \"BSurface\";case this.CONE:return \"Cone\";case this.CYLINDER:return \"Cylinder\";case this.ELLIPTICAL_CONE:return \"EllipticalCone\";case this.ELLIPTICAL_CYLINDER:return \"EllipticalCylinder\";case this.PLANE:return \"Plane\";case this.SPHERE:return \"Sphere\";case this.TORUS:return \"Torus\";default:return \"unknown\";}} }, t.TOPOLOGY_TYPES = { VERTEX: 1, EDGE: 2, COEDGE: 3, LOOP: 4, FACE: 5, SHELL: 6, LUMP: 7, BODY: 8, WIRE: 9, WIREBODY: 10, toString: function toString(e) {switch (e) {case this.VERTEX:return \"Vertex\";case this.EDGE:return \"Edge\";case this.COEDGE:return \"Coedge\";case this.LOOP:return \"Loop\";case this.FACE:return \"Face\";case this.SHELL:return \"Shell\";case this.LUMP:return \"Lump\";case this.BODY:return \"Body\";case this.WIRE:return \"Wire\";case this.WIREBODY:return \"WireBody\";default:return \"unknown\";}} };}, function (e, t, r) {\"use strict\";r.r(t), r.d(t, \"Vector2\", function () {return s;}), r.d(t, \"Vector3\", function () {return c;}), r.d(t, \"Vector4\", function () {return l;}), r.d(t, \"Matrix22\", function () {return d;}), r.d(t, \"Matrix33\", function () {return p;}), r.d(t, \"Matrix44\", function () {return v;}), r.d(t, \"Quat\", function () {return y;}), r.d(t, \"ProjectionUtils\", function () {return m;}), r.d(t, \"FLOAT64_TOLERANCE\", function () {return n;}), r.d(t, \"FLOAT32_TOLERANCE\", function () {return o;});var n = 1e-12,o = 1e-6;var i = { createFloat32: function createFloat32() {var e = new Float32Array(2);return e[0] = 0, e[1] = 0, e;}, createFloat64: function createFloat64() {var e = new Float64Array(2);return e[0] = 0, e[1] = 0, e;}, createNumber: function createNumber() {return [0, 0];}, clone: function clone(e) {var t = new e.constructor(2);return t[0] = e[0], t[1] = e[1], t;}, createFloat32FromValues: function createFloat32FromValues(e, t) {var r = new Float32Array(2);return r[0] = e, r[1] = t, r;} };i.asFloat32 = i.createFloat32FromValues, i.createFloat64FromValues = function (e, t) {var r = new Float64Array(2);return r[0] = e, r[1] = t, r;}, i.asFloat64 = i.createFloat64FromValues, i.createNumberFromValues = function (e, t) {return [e, t];}, i.copy = function (e, t) {return e[0] = t[0], e[1] = t[1], e;}, i.set = function (e, t, r) {return e[0] = t, e[1] = r, e;}, i.add = function (e, t, r) {return e[0] = t[0] + r[0], e[1] = t[1] + r[1], e;}, i.subtract = function (e, t, r) {return e[0] = t[0] - r[0], e[1] = t[1] - r[1], e;}, i.sub = i.subtract, i.multiply = function (e, t, r) {return e[0] = t[0] * r[0], e[1] = t[1] * r[1], e;}, i.mul = i.multiply, i.divide = function (e, t, r) {return e[0] = t[0] / r[0], e[1] = t[1] / r[1], e;}, i.div = i.divide, i.ceil = function (e, t) {return e[0] = Math.ceil(t[0]), e[1] = Math.ceil(t[1]), e;}, i.floor = function (e, t) {return e[0] = Math.floor(t[0]), e[1] = Math.floor(t[1]), e;}, i.min = function (e, t, r) {return e[0] = Math.min(t[0], r[0]), e[1] = Math.min(t[1], r[1]), e;}, i.max = function (e, t, r) {return e[0] = Math.max(t[0], r[0]), e[1] = Math.max(t[1], r[1]), e;}, i.round = function (e, t) {return e[0] = Math.round(t[0]), e[1] = Math.round(t[1]), e;}, i.scale = function (e, t, r) {return e[0] = t[0] * r, e[1] = t[1] * r, e;}, i.scaleAndAdd = function (e, t, r, n) {return e[0] = t[0] + r[0] * n, e[1] = t[1] + r[1] * n, e;}, i.distance = function (e, t) {var r = t[0] - e[0],n = t[1] - e[1];return Math.sqrt(r * r + n * n);}, i.dist = i.distance, i.squaredDistance = function (e, t) {var r = t[0] - e[0],n = t[1] - e[1];return r * r + n * n;}, i.sqrDist = i.squaredDistance, i.length = function (e) {var t = e[0],r = e[1];return Math.sqrt(t * t + r * r);}, i.len = i.length, i.squaredLength = function (e) {var t = e[0],r = e[1];return t * t + r * r;}, i.sqrLen = i.squaredLength, i.negate = function (e, t) {return e[0] = -t[0], e[1] = -t[1], e;}, i.inverse = function (e, t) {return e[0] = 1 / t[0], e[1] = 1 / t[1], e;}, i.normalize = function (e, t) {var r = t[0],n = t[1],o = r * r + n * n;return o > 0 && (o = 1 / Math.sqrt(o), e[0] = t[0] * o, e[1] = t[1] * o), e;}, i.dot = function (e, t) {return e[0] * t[0] + e[1] * t[1];}, i.cross = function (e, t, r) {var n = t[0] * r[1] - t[1] * r[0];return e[0] = e[1] = 0, e[2] = n, e;}, i.lerp = function (e, t, r, n) {var o = t[0],i = t[1];return e[0] = o + n * (r[0] - o), e[1] = i + n * (r[1] - i), e;}, i.random = function (e, t) {t = t || 1;var r = 2 * Math.random() * Math.PI;return e[0] = Math.cos(r) * t, e[1] = Math.sin(r) * t, e;}, i.transformMatrix22 = function (e, t, r) {var n = t[0],o = t[1];return e[0] = r[0] * n + r[2] * o, e[1] = r[1] * n + r[3] * o, e;}, i.transformMatrix33 = function (e, t, r) {var n = t[0],o = t[1];return e[0] = r[0] * n + r[3] * o + r[6], e[1] = r[1] * n + r[4] * o + r[7], e;}, i.transformMatrix44 = function (e, t, r) {var n = t[0],o = t[1];return e[0] = r[0] * n + r[4] * o + r[12], e[1] = r[1] * n + r[5] * o + r[13], e;}, i.angle = function (e, t) {var r = i.clone(e),n = i.clone(t);i.normalize(r, r), i.normalize(n, n);var o = i.dot(r, n),s = Math.abs(r[0] * n[1] - r[1] * n[0]);return Math.atan2(s, o);}, i.isParallel = function (e, t, r, o) {o = o || n, r = r || 0;var s = e[0] * t[1] - e[1] * t[0];return !(s * s > o * o * i.squaredLength(e) * i.squaredLength(t)) && (r > 0 ? i.dot(e, t) > 0 : !(r < 0) || i.dot(e, t) < 0);}, i.isOrthogonal = function (e, t, r) {r = r || n;var o = i.dot(e, t);return o * o <= r * r * i.squaredLength(e) * i.squaredLength(t);}, i.toString = function (e) {return \"[\" + e[0] + \", \" + e[1] + \"]\";}, i.exactEquals = function (e, t) {return e[0] === t[0] && e[1] === t[1];}, i.equals = function (e, t, r) {return r = r || n, Math.abs(e[0] - t[0]) <= r && Math.abs(e[1] - t[1]) <= r;};var s = i,a = { createFloat32: function createFloat32() {var e = new Float32Array(3);return e[0] = 0, e[1] = 0, e[2] = 0, e;}, createFloat64: function createFloat64() {var e = new Float64Array(3);return e[0] = 0, e[1] = 0, e[2] = 0, e;}, createNumber: function createNumber() {return [0, 0, 0];}, clone: function clone(e) {var t = new e.constructor(3);return t[0] = e[0], t[1] = e[1], t[2] = e[2], t;}, createFloat32FromValues: function createFloat32FromValues(e, t, r) {var n = new Float32Array(3);return n[0] = e, n[1] = t, n[2] = r, n;} };a.asFloat32 = a.createFloat32FromValues, a.createFloat64FromValues = function (e, t, r) {var n = new Float64Array(3);return n[0] = e, n[1] = t, n[2] = r, n;}, a.asFloat64 = a.createFloat64FromValues, a.createNumberFromValues = function (e, t, r) {return [e, t, r];}, a.copy = function (e, t) {return e[0] = t[0], e[1] = t[1], e[2] = t[2], e;}, a.set = function (e, t, r, n) {return e[0] = t, e[1] = r, e[2] = n, e;}, a.add = function (e, t, r) {return e[0] = t[0] + r[0], e[1] = t[1] + r[1], e[2] = t[2] + r[2], e;}, a.subtract = function (e, t, r) {return e[0] = t[0] - r[0], e[1] = t[1] - r[1], e[2] = t[2] - r[2], e;}, a.sub = a.subtract, a.multiply = function (e, t, r) {return e[0] = t[0] * r[0], e[1] = t[1] * r[1], e[2] = t[2] * r[2], e;}, a.mul = a.multiply, a.divide = function (e, t, r) {return e[0] = t[0] / r[0], e[1] = t[1] / r[1], e[2] = t[2] / r[2], e;}, a.div = a.divide, a.ceil = function (e, t) {return e[0] = Math.ceil(t[0]), e[1] = Math.ceil(t[1]), e[2] = Math.ceil(t[2]), e;}, a.floor = function (e, t) {return e[0] = Math.floor(t[0]), e[1] = Math.floor(t[1]), e[2] = Math.floor(t[2]), e;}, a.min = function (e, t, r) {return e[0] = Math.min(t[0], r[0]), e[1] = Math.min(t[1], r[1]), e[2] = Math.min(t[2], r[2]), e;}, a.max = function (e, t, r) {return e[0] = Math.max(t[0], r[0]), e[1] = Math.max(t[1], r[1]), e[2] = Math.max(t[2], r[2]), e;}, a.round = function (e, t) {return e[0] = Math.round(t[0]), e[1] = Math.round(t[1]), e[2] = Math.round(t[2]), e;}, a.scale = function (e, t, r) {return e[0] = t[0] * r, e[1] = t[1] * r, e[2] = t[2] * r, e;}, a.scaleAndAdd = function (e, t, r, n) {return e[0] = t[0] + r[0] * n, e[1] = t[1] + r[1] * n, e[2] = t[2] + r[2] * n, e;}, a.distance = function (e, t) {var r = t[0] - e[0],n = t[1] - e[1],o = t[2] - e[2];return Math.sqrt(r * r + n * n + o * o);}, a.dist = a.distance, a.squaredDistance = function (e, t) {var r = t[0] - e[0],n = t[1] - e[1],o = t[2] - e[2];return r * r + n * n + o * o;}, a.sqrDist = a.squaredDistance, a.length = function (e) {var t = e[0],r = e[1],n = e[2];return Math.sqrt(t * t + r * r + n * n);}, a.len = a.length, a.squaredLength = function (e) {var t = e[0],r = e[1],n = e[2];return t * t + r * r + n * n;}, a.sqrLen = a.squaredLength, a.negate = function (e, t) {return e[0] = -t[0], e[1] = -t[1], e[2] = -t[2], e;}, a.inverse = function (e, t) {return e[0] = 1 / t[0], e[1] = 1 / t[1], e[2] = 1 / t[2], e;}, a.normalize = function (e, t) {var r = t[0],n = t[1],o = t[2],i = r * r + n * n + o * o;return i > 0 && (i = 1 / Math.sqrt(i), e[0] = t[0] * i, e[1] = t[1] * i, e[2] = t[2] * i), e;}, a.dot = function (e, t) {return e[0] * t[0] + e[1] * t[1] + e[2] * t[2];}, a.cross = function (e, t, r) {var n = t[0],o = t[1],i = t[2],s = r[0],a = r[1],c = r[2];return e[0] = o * c - i * a, e[1] = i * s - n * c, e[2] = n * a - o * s, e;}, a.lerp = function (e, t, r, n) {var o = t[0],i = t[1],s = t[2];return e[0] = o + n * (r[0] - o), e[1] = i + n * (r[1] - i), e[2] = s + n * (r[2] - s), e;}, a.hermite = function (e, t, r, n, o, i) {var s = i * i,a = s * (2 * i - 3) + 1,c = s * (i - 2) + i,u = s * (i - 1),l = s * (3 - 2 * i);return e[0] = t[0] * a + r[0] * c + n[0] * u + o[0] * l, e[1] = t[1] * a + r[1] * c + n[1] * u + o[1] * l, e[2] = t[2] * a + r[2] * c + n[2] * u + o[2] * l, e;}, a.bezier = function (e, t, r, n, o, i) {var s = 1 - i,a = s * s,c = i * i,u = a * s,l = 3 * i * a,h = 3 * c * s,d = c * i;return e[0] = t[0] * u + r[0] * l + n[0] * h + o[0] * d, e[1] = t[1] * u + r[1] * l + n[1] * h + o[1] * d, e[2] = t[2] * u + r[2] * l + n[2] * h + o[2] * d, e;}, a.random = function (e, t) {t = t || 1;var r = 2 * Math.random() * Math.PI,n = 2 * Math.random() - 1,o = Math.sqrt(1 - n * n) * t;return e[0] = Math.cos(r) * o, e[1] = Math.sin(r) * o, e[2] = n * t, e;}, a.transformMatrix44 = function (e, t, r) {var n = t[0],o = t[1],i = t[2];return e[0] = r[0] * n + r[4] * o + r[8] * i + r[12], e[1] = r[1] * n + r[5] * o + r[9] * i + r[13], e[2] = r[2] * n + r[6] * o + r[10] * i + r[14], e;}, a.transformAsDirectionMatrix44 = function (e, t, r) {var n = t[0],o = t[1],i = t[2];return e[0] = r[0] * n + r[4] * o + r[8] * i, e[1] = r[1] * n + r[5] * o + r[9] * i, e[2] = r[2] * n + r[6] * o + r[10] * i, e;}, a.transformMatrix33 = function (e, t, r) {var n = t[0],o = t[1],i = t[2];return e[0] = n * r[0] + o * r[3] + i * r[6], e[1] = n * r[1] + o * r[4] + i * r[7], e[2] = n * r[2] + o * r[5] + i * r[8], e;}, a.transformQuat = function (e, t, r) {var n = t[0],o = t[1],i = t[2],s = r[0],a = r[1],c = r[2],u = r[3],l = u * n + a * i - c * o,h = u * o + c * n - s * i,d = u * i + s * o - a * n,g = -s * n - a * o - c * i;return e[0] = l * u + g * -s + h * -c - d * -a, e[1] = h * u + g * -a + d * -s - l * -c, e[2] = d * u + g * -c + l * -a - h * -s, e;}, a.setFromMatrixScale = function (e, t) {var r = Math.sqrt(t[0] * t[0] + t[1] * t[1] + t[2] * t[2]),n = Math.sqrt(t[4] * t[4] + t[5] * t[5] + t[6] * t[6]),o = Math.sqrt(t[8] * t[8] + t[9] * t[9] + t[10] * t[10]);return e[0] = r, e[1] = n, e[2] = o, e;}, a.rotateX = function (e, t, r, n) {var o = [],i = [];return o[0] = t[0] - r[0], o[1] = t[1] - r[1], o[2] = t[2] - r[2], i[0] = o[0], i[1] = o[1] * Math.cos(n) - o[2] * Math.sin(n), i[2] = o[1] * Math.sin(n) + o[2] * Math.cos(n), e[0] = i[0] + r[0], e[1] = i[1] + r[1], e[2] = i[2] + r[2], e;}, a.rotateY = function (e, t, r, n) {var o = [],i = [];return o[0] = t[0] - r[0], o[1] = t[1] - r[1], o[2] = t[2] - r[2], i[0] = o[2] * Math.sin(n) + o[0] * Math.cos(n), i[1] = o[1], i[2] = o[2] * Math.cos(n) - o[0] * Math.sin(n), e[0] = i[0] + r[0], e[1] = i[1] + r[1], e[2] = i[2] + r[2], e;}, a.rotateZ = function (e, t, r, n) {var o = [],i = [];return o[0] = t[0] - r[0], o[1] = t[1] - r[1], o[2] = t[2] - r[2], i[0] = o[0] * Math.cos(n) - o[1] * Math.sin(n), i[1] = o[0] * Math.sin(n) + o[1] * Math.cos(n), i[2] = o[2], e[0] = i[0] + r[0], e[1] = i[1] + r[1], e[2] = i[2] + r[2], e;}, a.angle = function (e, t) {var r = a.clone(e),n = a.clone(t);a.normalize(r, r), a.normalize(n, n);var o = a.dot(r, n),i = a.length(a.cross(r, r, n));return Math.atan2(i, o);}, a.isParallel = function (e, t, r, o) {o = o || n, r = r || 0;var i = a.createFloat64();return a.cross(i, e, t), !(a.squaredLength(i) > o * o * a.squaredLength(e) * a.squaredLength(t)) && (r > 0 ? a.dot(e, t) > 0 : !(r < 0) || a.dot(e, t) < 0);}, a.isOrthogonal = function (e, t, r) {r = r || n;var o = a.dot(e, t);return o * o <= r * r * a.squaredLength(e) * a.squaredLength(t);}, a.computeOrthogonal = function (e, t) {return t[0] * t[0] > t[2] * t[2] ? a.set(e, t[1], -t[0], 0) : a.set(e, 0, t[2], -t[1]), e;}, a.setEulerFromRotationMatrix = function (e, t, r) {var o = 1 - n;function i(e) {return Math.min(Math.max(e, -1), 1);}var s = t[0],a = t[4],c = t[8],u = t[1],l = t[5],h = t[9],d = t[2],g = t[6],p = t[10];return void 0 === r || \"XYZ\" === r ? (e[1] = Math.asin(i(c)), Math.abs(c) < o ? (e[0] = Math.atan2(-h, p), e[2] = Math.atan2(-a, s)) : (e[0] = Math.atan2(g, l), e[2] = 0)) : \"YXZ\" === r ? (e[0] = Math.asin(-i(h)), Math.abs(h) < o ? (e[1] = Math.atan2(c, p), e[2] = Math.atan2(u, l)) : (e[1] = Math.atan2(-d, s), e[2] = 0)) : \"ZXY\" === r ? (e[0] = Math.asin(i(g)), Math.abs(g) < o ? (e[1] = Math.atan2(-d, p), e[2] = Math.atan2(-a, l)) : (e[1] = 0, e[2] = Math.atan2(u, s))) : \"ZYX\" === r ? (e[1] = Math.asin(-i(d)), Math.abs(d) < o ? (e[0] = Math.atan2(g, p), e[2] = Math.atan2(u, s)) : (e[0] = 0, e[2] = Math.atan2(-a, l))) : \"YZX\" === r ? (e[2] = Math.asin(i(u)), Math.abs(u) < o ? (e[0] = Math.atan2(-h, l), e[1] = Math.atan2(-d, s)) : (e[0] = 0, e[1] = Math.atan2(c, p))) : \"XZY\" === r && (e[2] = Math.asin(-i(a)), Math.abs(a) < o ? (e[0] = Math.atan2(g, l), e[1] = Math.atan2(c, s)) : (e[0] = Math.atan2(-h, p), e[1] = 0)), e;}, a.toString = function (e) {return \"[\" + e[0] + \", \" + e[1] + \", \" + e[2] + \"]\";}, a.exactEquals = function (e, t) {return e[0] === t[0] && e[1] === t[1] && e[2] === t[2];}, a.equals = function (e, t, r) {return r = r || n, Math.abs(e[0] - t[0]) <= r && Math.abs(e[1] - t[1]) <= r && Math.abs(e[2] - t[2]) <= r;};var c = a,u = { createFloat32: function createFloat32() {var e = new Float32Array(4);return e[0] = 0, e[1] = 0, e[2] = 0, e[3] = 0, e;}, createFloat64: function createFloat64() {var e = new Float64Array(4);return e[0] = 0, e[1] = 0, e[2] = 0, e[3] = 0, e;}, createNumber: function createNumber() {return [0, 0, 0, 0];}, clone: function clone(e) {var t = new e.constructor(4);return t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t;}, createFloat32FromValues: function createFloat32FromValues(e, t, r, n) {var o = new Float32Array(4);return o[0] = e, o[1] = t, o[2] = r, o[3] = n, o;} };u.asFloat32 = u.createFloat32FromValues, u.createFloat64FromValues = function (e, t, r, n) {var o = new Float64Array(4);return o[0] = e, o[1] = t, o[2] = r, o[3] = n, o;}, u.asFloat64 = u.createFloat64FromValues, u.createNumberFromValues = function (e, t, r, n) {return [e, t, r, n];}, u.copy = function (e, t) {return e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e;}, u.set = function (e, t, r, n, o) {return e[0] = t, e[1] = r, e[2] = n, e[3] = o, e;}, u.add = function (e, t, r) {return e[0] = t[0] + r[0], e[1] = t[1] + r[1], e[2] = t[2] + r[2], e[3] = t[3] + r[3], e;}, u.subtract = function (e, t, r) {return e[0] = t[0] - r[0], e[1] = t[1] - r[1], e[2] = t[2] - r[2], e[3] = t[3] - r[3], e;}, u.sub = u.subtract, u.multiply = function (e, t, r) {return e[0] = t[0] * r[0], e[1] = t[1] * r[1], e[2] = t[2] * r[2], e[3] = t[3] * r[3], e;}, u.mul = u.multiply, u.divide = function (e, t, r) {return e[0] = t[0] / r[0], e[1] = t[1] / r[1], e[2] = t[2] / r[2], e[3] = t[3] / r[3], e;}, u.div = u.divide, u.ceil = function (e, t) {return e[0] = Math.ceil(t[0]), e[1] = Math.ceil(t[1]), e[2] = Math.ceil(t[2]), e[3] = Math.ceil(t[3]), e;}, u.floor = function (e, t) {return e[0] = Math.floor(t[0]), e[1] = Math.floor(t[1]), e[2] = Math.floor(t[2]), e[3] = Math.floor(t[3]), e;}, u.min = function (e, t, r) {return e[0] = Math.min(t[0], r[0]), e[1] = Math.min(t[1], r[1]), e[2] = Math.min(t[2], r[2]), e[3] = Math.min(t[3], r[3]), e;}, u.max = function (e, t, r) {return e[0] = Math.max(t[0], r[0]), e[1] = Math.max(t[1], r[1]), e[2] = Math.max(t[2], r[2]), e[3] = Math.max(t[3], r[3]), e;}, u.round = function (e, t) {return e[0] = Math.round(t[0]), e[1] = Math.round(t[1]), e[2] = Math.round(t[2]), e[3] = Math.round(t[3]), e;}, u.scale = function (e, t, r) {return e[0] = t[0] * r, e[1] = t[1] * r, e[2] = t[2] * r, e[3] = t[3] * r, e;}, u.scaleAndAdd = function (e, t, r, n) {return e[0] = t[0] + r[0] * n, e[1] = t[1] + r[1] * n, e[2] = t[2] + r[2] * n, e[3] = t[3] + r[3] * n, e;}, u.distance = function (e, t) {var r = t[0] - e[0],n = t[1] - e[1],o = t[2] - e[2],i = t[3] - e[3];return Math.sqrt(r * r + n * n + o * o + i * i);}, u.dist = u.distance, u.squaredDistance = function (e, t) {var r = t[0] - e[0],n = t[1] - e[1],o = t[2] - e[2],i = t[3] - e[3];return r * r + n * n + o * o + i * i;}, u.sqrDist = u.squaredDistance, u.length = function (e) {var t = e[0],r = e[1],n = e[2],o = e[3];return Math.sqrt(t * t + r * r + n * n + o * o);}, u.len = u.length, u.squaredLength = function (e) {var t = e[0],r = e[1],n = e[2],o = e[3];return t * t + r * r + n * n + o * o;}, u.sqrLen = u.squaredLength, u.negate = function (e, t) {return e[0] = -t[0], e[1] = -t[1], e[2] = -t[2], e[3] = -t[3], e;}, u.inverse = function (e, t) {return e[0] = 1 / t[0], e[1] = 1 / t[1], e[2] = 1 / t[2], e[3] = 1 / t[3], e;}, u.normalize = function (e, t) {var r = t[0],n = t[1],o = t[2],i = t[3],s = r * r + n * n + o * o + i * i;return s > 0 && (s = 1 / Math.sqrt(s), e[0] = r * s, e[1] = n * s, e[2] = o * s, e[3] = i * s), e;}, u.dot = function (e, t) {return e[0] * t[0] + e[1] * t[1] + e[2] * t[2] + e[3] * t[3];}, u.lerp = function (e, t, r, n) {var o = t[0],i = t[1],s = t[2],a = t[3];return e[0] = o + n * (r[0] - o), e[1] = i + n * (r[1] - i), e[2] = s + n * (r[2] - s), e[3] = a + n * (r[3] - a), e;}, u.random = function (e, t) {return t = t || 1, e[0] = Math.random(), e[1] = Math.random(), e[2] = Math.random(), e[3] = Math.random(), u.normalize(e, e), u.scale(e, e, t), e;}, u.transformMatrix44 = function (e, t, r) {var n = t[0],o = t[1],i = t[2],s = t[3];return e[0] = r[0] * n + r[4] * o + r[8] * i + r[12] * s, e[1] = r[1] * n + r[5] * o + r[9] * i + r[13] * s, e[2] = r[2] * n + r[6] * o + r[10] * i + r[14] * s, e[3] = r[3] * n + r[7] * o + r[11] * i + r[15] * s, e;}, u.transformQuat = function (e, t, r) {var n = t[0],o = t[1],i = t[2],s = r[0],a = r[1],c = r[2],u = r[3],l = u * n + a * i - c * o,h = u * o + c * n - s * i,d = u * i + s * o - a * n,g = -s * n - a * o - c * i;return e[0] = l * u + g * -s + h * -c - d * -a, e[1] = h * u + g * -a + d * -s - l * -c, e[2] = d * u + g * -c + l * -a - h * -s, e[3] = t[3], e;}, u.toString = function (e) {return \"[\" + e[0] + \", \" + e[1] + \", \" + e[2] + \", \" + e[3] + \"]\";}, u.exactEquals = function (e, t) {return e[0] === t[0] && e[1] === t[1] && e[2] === t[2] && e[3] === t[3];}, u.equals = function (e, t, r) {return r = r || n, Math.abs(e[0] - t[0]) <= r && Math.abs(e[1] - t[1]) <= r && Math.abs(e[2] - t[2]) <= r && Math.abs(e[2] - t[2]) <= r;};var l = u,h = { createFloat32: function createFloat32() {var e = new Float32Array(4);return e[0] = 1, e[1] = 0, e[2] = 0, e[3] = 1, e;}, createFloat64: function createFloat64() {var e = new Float64Array(4);return e[0] = 1, e[1] = 0, e[2] = 0, e[3] = 1, e;}, createNumber: function createNumber() {return [1, 0, 0, 1];}, clone: function clone(e) {var t = new e.constructor(9);return t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t;}, copy: function copy(e, t) {return e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e;}, createFloat32FromValues: function createFloat32FromValues(e, t, r, n) {var o = new Float32Array(4);return o[0] = e, o[1] = t, o[2] = r, o[3] = n, o;} };h.asFloat32 = h.createFloat32FromValues, h.createFloat64FromValues = function (e, t, r, n) {var o = new Float64Array(4);return o[0] = e, o[1] = t, o[2] = r, o[3] = n, o;}, h.asFloat64 = h.createFloat64FromValues, h.createNumberFromValues = function (e, t, r, n) {return [e, t, r, n];}, h.set = function (e, t, r, n, o) {return e[0] = t, e[1] = r, e[2] = n, e[3] = o, e;}, h.identity = function (e) {return e[0] = 1, e[1] = 0, e[2] = 0, e[3] = 1, e;}, h.transpose = function (e, t) {if (e === t) {var r = t[1];e[1] = t[2], e[2] = r;} else e[0] = t[0], e[1] = t[2], e[2] = t[1], e[3] = t[3];return e;}, h.invert = function (e, t) {var r = t[0],n = t[1],o = t[2],i = t[3],s = r * i - o * n;return s ? (s = 1 / s, e[0] = i * s, e[1] = -n * s, e[2] = -o * s, e[3] = r * s, e) : null;}, h.determinant = function (e) {return e[0] * e[3] - e[2] * e[1];}, h.multiply = function (e, t, r) {var n = t[0],o = t[1],i = t[2],s = t[3],a = r[0],c = r[1],u = r[2],l = r[3];return e[0] = n * a + i * c, e[1] = o * a + s * c, e[2] = n * u + i * l, e[3] = o * u + s * l, e;}, h.mul = h.multiply, h.scale = function (e, t, r) {var n = t[0],o = t[1],i = t[2],s = t[3],a = r[0],c = r[1];return e[0] = n * a, e[1] = o * a, e[2] = i * c, e[3] = s * c, e;}, h.toString = function (e) {return \"[\" + e[0] + \", \" + e[1] + \", \" + e[2] + \", \" + e[3] + \"]\";}, h.add = function (e, t, r) {return e[0] = t[0] + r[0], e[1] = t[1] + r[1], e[2] = t[2] + r[2], e[3] = t[3] + r[3], e;}, h.subtract = function (e, t, r) {return e[0] = t[0] - r[0], e[1] = t[1] - r[1], e[2] = t[2] - r[2], e[3] = t[3] - r[3], e;}, h.sub = h.subtract, h.multiplyScalar = function (e, t, r) {return e[0] = t[0] * r, e[1] = t[1] * r, e[2] = t[2] * r, e[3] = t[3] * r, e;}, h.multiplyScalarAndAdd = function (e, t, r, n) {return e[0] = t[0] + r[0] * n, e[1] = t[1] + r[1] * n, e[2] = t[2] + r[2] * n, e[3] = t[3] + r[3] * n, e;}, h.exactEquals = function (e, t) {return e[0] === t[0] && e[1] === t[1] && e[2] === t[2] && e[3] === t[3];}, h.equals = function (e, t, r) {return r = r || n, Math.abs(e[0] - t[0]) <= r && Math.abs(e[1] - t[1]) <= r && Math.abs(e[2] - t[2]) <= r && Math.abs(e[3] - t[3]) <= r;};var d = h,g = { createFloat32: function createFloat32() {var e = new Float32Array(9);return e[0] = 1, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 1, e[5] = 0, e[6] = 0, e[7] = 0, e[8] = 1, e;}, createFloat64: function createFloat64() {var e = new Float64Array(9);return e[0] = 1, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 1, e[5] = 0, e[6] = 0, e[7] = 0, e[8] = 1, e;}, createNumber: function createNumber() {return [1, 0, 0, 0, 1, 0, 0, 0, 1];}, fromMatrix44: function fromMatrix44(e, t) {return e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[4], e[4] = t[5], e[5] = t[6], e[6] = t[8], e[7] = t[9], e[8] = t[10], e;}, clone: function clone(e) {var t = new e.constructor(9);return t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t[4] = e[4], t[5] = e[5], t[6] = e[6], t[7] = e[7], t[8] = e[8], t;}, copy: function copy(e, t) {return e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e[4] = t[4], e[5] = t[5], e[6] = t[6], e[7] = t[7], e[8] = t[8], e;}, createFloat32FromValues: function createFloat32FromValues(e, t, r, n, o, i, s, a, c) {var u = new Float32Array(9);return u[0] = e, u[1] = t, u[2] = r, u[3] = n, u[4] = o, u[5] = i, u[6] = s, u[7] = a, u[8] = c, u;} };g.asFloat32 = g.createFloat32FromValues, g.createFloat64FromValues = function (e, t, r, n, o, i, s, a, c) {var u = new Float64Array(9);return u[0] = e, u[1] = t, u[2] = r, u[3] = n, u[4] = o, u[5] = i, u[6] = s, u[7] = a, u[8] = c, u;}, g.asFloat64 = g.createFloat64FromValues, g.createNumberFromValues = function (e, t, r, n, o, i, s, a, c) {return [e, t, r, n, o, i, s, a, c];}, g.set = function (e, t, r, n, o, i, s, a, c, u) {return e[0] = t, e[1] = r, e[2] = n, e[3] = o, e[4] = i, e[5] = s, e[6] = a, e[7] = c, e[8] = u, e;}, g.identity = function (e) {return e[0] = 1, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 1, e[5] = 0, e[6] = 0, e[7] = 0, e[8] = 1, e;}, g.transpose = function (e, t) {if (e === t) {var r = t[1],n = t[2],o = t[5];e[1] = t[3], e[2] = t[6], e[3] = r, e[5] = t[7], e[6] = n, e[7] = o;} else e[0] = t[0], e[1] = t[3], e[2] = t[6], e[3] = t[1], e[4] = t[4], e[5] = t[7], e[6] = t[2], e[7] = t[5], e[8] = t[8];return e;}, g.invert = function (e, t) {var r = t[0],n = t[1],o = t[2],i = t[3],s = t[4],a = t[5],c = t[6],u = t[7],l = t[8],h = l * s - a * u,d = -l * i + a * c,g = u * i - s * c,p = r * h + n * d + o * g;return p ? (p = 1 / p, e[0] = h * p, e[1] = (-l * n + o * u) * p, e[2] = (a * n - o * s) * p, e[3] = d * p, e[4] = (l * r - o * c) * p, e[5] = (-a * r + o * i) * p, e[6] = g * p, e[7] = (-u * r + n * c) * p, e[8] = (s * r - n * i) * p, e) : null;}, g.determinant = function (e) {var t = e[0],r = e[1],n = e[2],o = e[3],i = e[4],s = e[5],a = e[6],c = e[7],u = e[8];return t * (u * i - s * c) + r * (-u * o + s * a) + n * (c * o - i * a);}, g.multiply = function (e, t, r) {var n = t[0],o = t[1],i = t[2],s = t[3],a = t[4],c = t[5],u = t[6],l = t[7],h = t[8],d = r[0],g = r[1],p = r[2],f = r[3],v = r[4],_ = r[5],y = r[6],m = r[7],E = r[8];return e[0] = d * n + g * s + p * u, e[1] = d * o + g * a + p * l, e[2] = d * i + g * c + p * h, e[3] = f * n + v * s + _ * u, e[4] = f * o + v * a + _ * l, e[5] = f * i + v * c + _ * h, e[6] = y * n + m * s + E * u, e[7] = y * o + m * a + E * l, e[8] = y * i + m * c + E * h, e;}, g.mul = g.multiply, g.fromTranslation = function (e, t) {return e[0] = 1, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 1, e[5] = 0, e[6] = t[0], e[7] = t[1], e[8] = 1, e;}, g.fromRotation = function (e, t) {var r = Math.sin(t),n = Math.cos(t);return e[0] = n, e[1] = r, e[2] = 0, e[3] = -r, e[4] = n, e[5] = 0, e[6] = 0, e[7] = 0, e[8] = 1, e;}, g.fromScaling = function (e, t) {return e[0] = t[0], e[1] = 0, e[2] = 0, e[3] = 0, e[4] = t[1], e[5] = 0, e[6] = 0, e[7] = 0, e[8] = 1, e;}, g.fromQuat = function (e, t) {var r = t[0],n = t[1],o = t[2],i = t[3],s = r + r,a = n + n,c = o + o,u = r * s,l = n * s,h = n * a,d = o * s,g = o * a,p = o * c,f = i * s,v = i * a,_ = i * c;return e[0] = 1 - h - p, e[3] = l - _, e[6] = d + v, e[1] = l + _, e[4] = 1 - u - p, e[7] = g - f, e[2] = d - v, e[5] = g + f, e[8] = 1 - u - h, e;}, g.normalFromMatrix44 = function (e, t) {var r = t[0],n = t[1],o = t[2],i = t[3],s = t[4],a = t[5],c = t[6],u = t[7],l = t[8],h = t[9],d = t[10],g = t[11],p = t[12],f = t[13],v = t[14],_ = t[15],y = r * a - n * s,m = r * c - o * s,E = r * u - i * s,x = n * c - o * a,R = n * u - i * a,A = o * u - i * c,P = l * f - h * p,V = l * v - d * p,T = l * _ - g * p,C = h * v - d * f,b = h * _ - g * f,L = d * _ - g * v,O = y * L - m * b + E * C + x * T - R * V + A * P;return O ? (O = 1 / O, e[0] = (a * L - c * b + u * C) * O, e[1] = (c * T - s * L - u * V) * O, e[2] = (s * b - a * T + u * P) * O, e[3] = (o * b - n * L - i * C) * O, e[4] = (r * L - o * T + i * V) * O, e[5] = (n * T - r * b - i * P) * O, e[6] = (f * A - v * R + _ * x) * O, e[7] = (v * E - p * A - _ * m) * O, e[8] = (p * R - f * E + _ * y) * O, e) : null;}, g.toString = function (e) {return \"[\" + e[0] + \", \" + e[1] + \", \" + e[2] + \", \" + e[3] + \", \" + e[4] + \", \" + e[5] + \", \" + e[6] + \", \" + e[7] + \", \" + e[8] + \"]\";}, g.add = function (e, t, r) {return e[0] = t[0] + r[0], e[1] = t[1] + r[1], e[2] = t[2] + r[2], e[3] = t[3] + r[3], e[4] = t[4] + r[4], e[5] = t[5] + r[5], e[6] = t[6] + r[6], e[7] = t[7] + r[7], e[8] = t[8] + r[8], e;}, g.subtract = function (e, t, r) {return e[0] = t[0] - r[0], e[1] = t[1] - r[1], e[2] = t[2] - r[2], e[3] = t[3] - r[3], e[4] = t[4] - r[4], e[5] = t[5] - r[5], e[6] = t[6] - r[6], e[7] = t[7] - r[7], e[8] = t[8] - r[8], e;}, g.sub = g.subtract, g.multiplyScalar = function (e, t, r) {return e[0] = t[0] * r, e[1] = t[1] * r, e[2] = t[2] * r, e[3] = t[3] * r, e[4] = t[4] * r, e[5] = t[5] * r, e[6] = t[6] * r, e[7] = t[7] * r, e[8] = t[8] * r, e;}, g.multiplyScalarAndAdd = function (e, t, r, n) {return e[0] = t[0] + r[0] * n, e[1] = t[1] + r[1] * n, e[2] = t[2] + r[2] * n, e[3] = t[3] + r[3] * n, e[4] = t[4] + r[4] * n, e[5] = t[5] + r[5] * n, e[6] = t[6] + r[6] * n, e[7] = t[7] + r[7] * n, e[8] = t[8] + r[8] * n, e;}, g.exactEquals = function (e, t) {return e[0] === t[0] && e[1] === t[1] && e[2] === t[2] && e[3] === t[3] && e[4] === t[4] && e[5] === t[5] && e[6] === t[6] && e[7] === t[7] && e[8] === t[8];}, g.equals = function (e, t, r) {return r = r || n, Math.abs(e[0] - t[0]) <= r && Math.abs(e[1] - t[1]) <= r && Math.abs(e[2] - t[2]) <= r && Math.abs(e[3] - t[3]) <= r && Math.abs(e[4] - t[4]) <= r && Math.abs(e[5] - t[5]) <= r && Math.abs(e[6] - t[6]) <= r && Math.abs(e[7] - t[7]) <= r && Math.abs(e[8] - t[8]) <= r;};var p = g,f = { createFloat32: function createFloat32() {var e = new Float32Array(16);return e[0] = 1, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = 1, e[6] = 0, e[7] = 0, e[8] = 0, e[9] = 0, e[10] = 1, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, e;}, createFloat64: function createFloat64() {var e = new Float64Array(16);return e[0] = 1, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = 1, e[6] = 0, e[7] = 0, e[8] = 0, e[9] = 0, e[10] = 1, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, e;}, createNumber: function createNumber() {return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];}, clone: function clone(e) {var t = new e.constructor(16);return t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t[4] = e[4], t[5] = e[5], t[6] = e[6], t[7] = e[7], t[8] = e[8], t[9] = e[9], t[10] = e[10], t[11] = e[11], t[12] = e[12], t[13] = e[13], t[14] = e[14], t[15] = e[15], t;}, copy: function copy(e, t) {return e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e[4] = t[4], e[5] = t[5], e[6] = t[6], e[7] = t[7], e[8] = t[8], e[9] = t[9], e[10] = t[10], e[11] = t[11], e[12] = t[12], e[13] = t[13], e[14] = t[14], e[15] = t[15], e;}, createFloat32FromValues: function createFloat32FromValues(e, t, r, n, o, i, s, a, c, u, l, h, d, g, p, f) {var v = new Float32Array(16);return v[0] = e, v[1] = t, v[2] = r, v[3] = n, v[4] = o, v[5] = i, v[6] = s, v[7] = a, v[8] = c, v[9] = u, v[10] = l, v[11] = h, v[12] = d, v[13] = g, v[14] = p, v[15] = f, v;} };f.asFloat32 = f.createFloat32FromValues, f.createFloat64FromValues = function (e, t, r, n, o, i, s, a, c, u, l, h, d, g, p, f) {var v = new Float64Array(16);return v[0] = e, v[1] = t, v[2] = r, v[3] = n, v[4] = o, v[5] = i, v[6] = s, v[7] = a, v[8] = c, v[9] = u, v[10] = l, v[11] = h, v[12] = d, v[13] = g, v[14] = p, v[15] = f, v;}, f.asFloat64 = f.createFloat64FromValues, f.createNumberFromValues = function (e, t, r, n, o, i, s, a, c, u, l, h, d, g, p, f) {return [e, t, r, n, o, i, s, a, c, u, l, h, d, g, p, f];}, f.set = function (e, t, r, n, o, i, s, a, c, u, l, h, d, g, p, f, v) {return e[0] = t, e[1] = r, e[2] = n, e[3] = o, e[4] = i, e[5] = s, e[6] = a, e[7] = c, e[8] = u, e[9] = l, e[10] = h, e[11] = d, e[12] = g, e[13] = p, e[14] = f, e[15] = v, e;}, f.identity = function (e) {return e[0] = 1, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = 1, e[6] = 0, e[7] = 0, e[8] = 0, e[9] = 0, e[10] = 1, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, e;}, f.transpose = function (e, t) {if (e === t) {var r = t[1],n = t[2],o = t[3],i = t[6],s = t[7],a = t[11];e[1] = t[4], e[2] = t[8], e[3] = t[12], e[4] = r, e[6] = t[9], e[7] = t[13], e[8] = n, e[9] = i, e[11] = t[14], e[12] = o, e[13] = s, e[14] = a;} else e[0] = t[0], e[1] = t[4], e[2] = t[8], e[3] = t[12], e[4] = t[1], e[5] = t[5], e[6] = t[9], e[7] = t[13], e[8] = t[2], e[9] = t[6], e[10] = t[10], e[11] = t[14], e[12] = t[3], e[13] = t[7], e[14] = t[11], e[15] = t[15];return e;}, f.invert = function (e, t) {var r = t[0],n = t[1],o = t[2],i = t[3],s = t[4],a = t[5],c = t[6],u = t[7],l = t[8],h = t[9],d = t[10],g = t[11],p = t[12],f = t[13],v = t[14],_ = t[15],y = r * a - n * s,m = r * c - o * s,E = r * u - i * s,x = n * c - o * a,R = n * u - i * a,A = o * u - i * c,P = l * f - h * p,V = l * v - d * p,T = l * _ - g * p,C = h * v - d * f,b = h * _ - g * f,L = d * _ - g * v,O = y * L - m * b + E * C + x * T - R * V + A * P;return O ? (O = 1 / O, e[0] = (a * L - c * b + u * C) * O, e[1] = (o * b - n * L - i * C) * O, e[2] = (f * A - v * R + _ * x) * O, e[3] = (d * R - h * A - g * x) * O, e[4] = (c * T - s * L - u * V) * O, e[5] = (r * L - o * T + i * V) * O, e[6] = (v * E - p * A - _ * m) * O, e[7] = (l * A - d * E + g * m) * O, e[8] = (s * b - a * T + u * P) * O, e[9] = (n * T - r * b - i * P) * O, e[10] = (p * R - f * E + _ * y) * O, e[11] = (h * E - l * R - g * y) * O, e[12] = (a * V - s * C - c * P) * O, e[13] = (r * C - n * V + o * P) * O, e[14] = (f * m - p * x - v * y) * O, e[15] = (l * x - h * m + d * y) * O, e) : null;}, f.determinant = function (e) {var t = e[0],r = e[1],n = e[2],o = e[3],i = e[4],s = e[5],a = e[6],c = e[7],u = e[8],l = e[9],h = e[10],d = e[11],g = e[12],p = e[13],f = e[14],v = e[15];return (t * s - r * i) * (h * v - d * f) - (t * a - n * i) * (l * v - d * p) + (t * c - o * i) * (l * f - h * p) + (r * a - n * s) * (u * v - d * g) - (r * c - o * s) * (u * f - h * g) + (n * c - o * a) * (u * p - l * g);}, f.multiply = function (e, t, r) {var n = t[0],o = t[1],i = t[2],s = t[3],a = t[4],c = t[5],u = t[6],l = t[7],h = t[8],d = t[9],g = t[10],p = t[11],f = t[12],v = t[13],_ = t[14],y = t[15],m = r[0],E = r[1],x = r[2],R = r[3];return e[0] = m * n + E * a + x * h + R * f, e[1] = m * o + E * c + x * d + R * v, e[2] = m * i + E * u + x * g + R * _, e[3] = m * s + E * l + x * p + R * y, m = r[4], E = r[5], x = r[6], R = r[7], e[4] = m * n + E * a + x * h + R * f, e[5] = m * o + E * c + x * d + R * v, e[6] = m * i + E * u + x * g + R * _, e[7] = m * s + E * l + x * p + R * y, m = r[8], E = r[9], x = r[10], R = r[11], e[8] = m * n + E * a + x * h + R * f, e[9] = m * o + E * c + x * d + R * v, e[10] = m * i + E * u + x * g + R * _, e[11] = m * s + E * l + x * p + R * y, m = r[12], E = r[13], x = r[14], R = r[15], e[12] = m * n + E * a + x * h + R * f, e[13] = m * o + E * c + x * d + R * v, e[14] = m * i + E * u + x * g + R * _, e[15] = m * s + E * l + x * p + R * y, e;}, f.mul = f.multiply, f.fromTranslation = function (e, t) {return e[0] = 1, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = 1, e[6] = 0, e[7] = 0, e[8] = 0, e[9] = 0, e[10] = 1, e[11] = 0, e[12] = t[0], e[13] = t[1], e[14] = t[2], e[15] = 1, e;}, f.fromScaling = function (e, t) {return e[0] = t[0], e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = t[1], e[6] = 0, e[7] = 0, e[8] = 0, e[9] = 0, e[10] = t[2], e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, e;}, f.fromRotation = function (e, t, r) {var o,i,s,a = r[0],c = r[1],u = r[2],l = Math.sqrt(a * a + c * c + u * u);return Math.abs(l) < n ? null : (a *= l = 1 / l, c *= l, u *= l, o = Math.sin(t), s = 1 - (i = Math.cos(t)), e[0] = a * a * s + i, e[1] = c * a * s + u * o, e[2] = u * a * s - c * o, e[3] = 0, e[4] = a * c * s - u * o, e[5] = c * c * s + i, e[6] = u * c * s + a * o, e[7] = 0, e[8] = a * u * s + c * o, e[9] = c * u * s - a * o, e[10] = u * u * s + i, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, e);}, f.fromXRotation = function (e, t) {var r = Math.sin(t),n = Math.cos(t);return e[0] = 1, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = n, e[6] = r, e[7] = 0, e[8] = 0, e[9] = -r, e[10] = n, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, e;}, f.fromYRotation = function (e, t) {var r = Math.sin(t),n = Math.cos(t);return e[0] = n, e[1] = 0, e[2] = -r, e[3] = 0, e[4] = 0, e[5] = 1, e[6] = 0, e[7] = 0, e[8] = r, e[9] = 0, e[10] = n, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, e;}, f.fromZRotation = function (e, t) {var r = Math.sin(t),n = Math.cos(t);return e[0] = n, e[1] = r, e[2] = 0, e[3] = 0, e[4] = -r, e[5] = n, e[6] = 0, e[7] = 0, e[8] = 0, e[9] = 0, e[10] = 1, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, e;}, f.fromRotationTranslation = function (e, t, r) {var n = t[0],o = t[1],i = t[2],s = t[3],a = n + n,c = o + o,u = i + i,l = n * a,h = n * c,d = n * u,g = o * c,p = o * u,f = i * u,v = s * a,_ = s * c,y = s * u;return e[0] = 1 - (g + f), e[1] = h + y, e[2] = d - _, e[3] = 0, e[4] = h - y, e[5] = 1 - (l + f), e[6] = p + v, e[7] = 0, e[8] = d + _, e[9] = p - v, e[10] = 1 - (l + g), e[11] = 0, e[12] = r[0], e[13] = r[1], e[14] = r[2], e[15] = 1, e;}, f.getTranslation = function (e, t) {return e[0] = t[12], e[1] = t[13], e[2] = t[14], e;}, f.extractRotation = function (e, t) {var r = 1 / Math.sqrt(t[0] * t[0] + t[1] * t[1] + t[2] * t[2]),n = 1 / Math.sqrt(t[4] * t[4] + t[5] * t[5] + t[6] * t[6]),o = 1 / Math.sqrt(t[8] * t[8] + t[9] * t[9] + t[10] * t[10]);return e[0] = t[0] * r, e[1] = t[1] * r, e[2] = t[2] * r, e[3] = 0, e[4] = t[4] * n, e[5] = t[5] * n, e[6] = t[6] * n, e[7] = 0, e[8] = t[8] * o, e[9] = t[9] * o, e[10] = t[10] * o, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, this;}, f.getRotation = function (e, t) {var r = t[0] + t[5] + t[10],n = 0;return r > 0 ? (n = 2 * Math.sqrt(r + 1), e[3] = .25 * n, e[0] = (t[6] - t[9]) / n, e[1] = (t[8] - t[2]) / n, e[2] = (t[1] - t[4]) / n) : t[0] > t[5] && t[0] > t[10] ? (n = 2 * Math.sqrt(1 + t[0] - t[5] - t[10]), e[3] = (t[6] - t[9]) / n, e[0] = .25 * n, e[1] = (t[1] + t[4]) / n, e[2] = (t[8] + t[2]) / n) : t[5] > t[10] ? (n = 2 * Math.sqrt(1 + t[5] - t[0] - t[10]), e[3] = (t[8] - t[2]) / n, e[0] = (t[1] + t[4]) / n, e[1] = .25 * n, e[2] = (t[6] + t[9]) / n) : (n = 2 * Math.sqrt(1 + t[10] - t[0] - t[5]), e[3] = (t[1] - t[4]) / n, e[0] = (t[8] + t[2]) / n, e[1] = (t[6] + t[9]) / n, e[2] = .25 * n), e;}, f.fromRotationTranslationScale = function (e, t, r, n) {var o = t[0],i = t[1],s = t[2],a = t[3],c = o + o,u = i + i,l = s + s,h = o * c,d = o * u,g = o * l,p = i * u,f = i * l,v = s * l,_ = a * c,y = a * u,m = a * l,E = n[0],x = n[1],R = n[2];return e[0] = (1 - (p + v)) * E, e[1] = (d + m) * E, e[2] = (g - y) * E, e[3] = 0, e[4] = (d - m) * x, e[5] = (1 - (h + v)) * x, e[6] = (f + _) * x, e[7] = 0, e[8] = (g + y) * R, e[9] = (f - _) * R, e[10] = (1 - (h + p)) * R, e[11] = 0, e[12] = r[0], e[13] = r[1], e[14] = r[2], e[15] = 1, e;}, f.fromRotationTranslationScaleOrigin = function (e, t, r, n, o) {var i = t[0],s = t[1],a = t[2],c = t[3],u = i + i,l = s + s,h = a + a,d = i * u,g = i * l,p = i * h,f = s * l,v = s * h,_ = a * h,y = c * u,m = c * l,E = c * h,x = n[0],R = n[1],A = n[2],P = o[0],V = o[1],T = o[2];return e[0] = (1 - (f + _)) * x, e[1] = (g + E) * x, e[2] = (p - m) * x, e[3] = 0, e[4] = (g - E) * R, e[5] = (1 - (d + _)) * R, e[6] = (v + y) * R, e[7] = 0, e[8] = (p + m) * A, e[9] = (v - y) * A, e[10] = (1 - (d + f)) * A, e[11] = 0, e[12] = r[0] + P - (e[0] * P + e[4] * V + e[8] * T), e[13] = r[1] + V - (e[1] * P + e[5] * V + e[9] * T), e[14] = r[2] + T - (e[2] * P + e[6] * V + e[10] * T), e[15] = 1, e;}, f.fromQuat = function (e, t) {var r = t[0],n = t[1],o = t[2],i = t[3],s = r + r,a = n + n,c = o + o,u = r * s,l = n * s,h = n * a,d = o * s,g = o * a,p = o * c,f = i * s,v = i * a,_ = i * c;return e[0] = 1 - h - p, e[1] = l + _, e[2] = d - v, e[3] = 0, e[4] = l - _, e[5] = 1 - u - p, e[6] = g + f, e[7] = 0, e[8] = d + v, e[9] = g - f, e[10] = 1 - u - h, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, e;}, f.setRotationFromEuler = function (e, t, r) {var n = t[0],o = t[1],i = t[2],s = Math.cos(n),a = Math.sin(n),c = Math.cos(o),u = Math.sin(o),l = Math.cos(i),h = Math.sin(i);if (void 0 === r || \"XYZ\" === r) {var d = s * l,g = s * h,p = a * l,f = a * h;e[0] = c * l, e[4] = -c * h, e[8] = u, e[1] = g + p * u, e[5] = d - f * u, e[9] = -a * c, e[2] = f - d * u, e[6] = p + g * u, e[10] = s * c;} else if (\"YXZ\" === r) {var v = c * l,_ = c * h,y = u * l,m = u * h;e[0] = v + m * a, e[4] = y * a - _, e[8] = s * u, e[1] = s * h, e[5] = s * l, e[9] = -a, e[2] = _ * a - y, e[6] = m + v * a, e[10] = s * c;} else if (\"ZXY\" === r) v = c * l, _ = c * h, y = u * l, m = u * h, e[0] = v - m * a, e[4] = -s * h, e[8] = y + _ * a, e[1] = _ + y * a, e[5] = s * l, e[9] = m - v * a, e[2] = -s * u, e[6] = a, e[10] = s * c;else if (\"ZYX\" === r) d = s * l, g = s * h, p = a * l, f = a * h, e[0] = c * l, e[4] = p * u - g, e[8] = d * u + f, e[1] = c * h, e[5] = f * u + d, e[9] = g * u - p, e[2] = -u, e[6] = a * c, e[10] = s * c;else if (\"YZX\" === r) {var E = s * c,x = s * u,R = a * c,A = a * u;e[0] = c * l, e[4] = A - E * h, e[8] = R * h + x, e[1] = h, e[5] = s * l, e[9] = -a * l, e[2] = -u * l, e[6] = x * h + R, e[10] = E - A * h;} else \"XZY\" === r && (E = s * c, x = s * u, R = a * c, A = a * u, e[0] = c * l, e[4] = -h, e[8] = u * l, e[1] = E * h + A, e[5] = s * l, e[9] = x * h - R, e[2] = R * h - x, e[6] = a * l, e[10] = A * h + E);return e;}, f.toString = function (e) {return \"[\" + e[0] + \", \" + e[1] + \", \" + e[2] + \", \" + e[3] + \", \" + e[4] + \", \" + e[5] + \", \" + e[6] + \", \" + e[7] + \", \" + e[8] + \", \" + e[9] + \", \" + e[10] + \", \" + e[11] + \", \" + e[12] + \", \" + e[13] + \", \" + e[14] + \", \" + e[15] + \"]\";}, f.add = function (e, t, r) {return e[0] = t[0] + r[0], e[1] = t[1] + r[1], e[2] = t[2] + r[2], e[3] = t[3] + r[3], e[4] = t[4] + r[4], e[5] = t[5] + r[5], e[6] = t[6] + r[6], e[7] = t[7] + r[7], e[8] = t[8] + r[8], e[9] = t[9] + r[9], e[10] = t[10] + r[10], e[11] = t[11] + r[11], e[12] = t[12] + r[12], e[13] = t[13] + r[13], e[14] = t[14] + r[14], e[15] = t[15] + r[15], e;}, f.subtract = function (e, t, r) {return e[0] = t[0] - r[0], e[1] = t[1] - r[1], e[2] = t[2] - r[2], e[3] = t[3] - r[3], e[4] = t[4] - r[4], e[5] = t[5] - r[5], e[6] = t[6] - r[6], e[7] = t[7] - r[7], e[8] = t[8] - r[8], e[9] = t[9] - r[9], e[10] = t[10] - r[10], e[11] = t[11] - r[11], e[12] = t[12] - r[12], e[13] = t[13] - r[13], e[14] = t[14] - r[14], e[15] = t[15] - r[15], e;}, f.sub = f.subtract, f.multiplyScalar = function (e, t, r) {return e[0] = t[0] * r, e[1] = t[1] * r, e[2] = t[2] * r, e[3] = t[3] * r, e[4] = t[4] * r, e[5] = t[5] * r, e[6] = t[6] * r, e[7] = t[7] * r, e[8] = t[8] * r, e[9] = t[9] * r, e[10] = t[10] * r, e[11] = t[11] * r, e[12] = t[12] * r, e[13] = t[13] * r, e[14] = t[14] * r, e[15] = t[15] * r, e;}, f.multiplyScalarAndAdd = function (e, t, r, n) {return e[0] = t[0] + r[0] * n, e[1] = t[1] + r[1] * n, e[2] = t[2] + r[2] * n, e[3] = t[3] + r[3] * n, e[4] = t[4] + r[4] * n, e[5] = t[5] + r[5] * n, e[6] = t[6] + r[6] * n, e[7] = t[7] + r[7] * n, e[8] = t[8] + r[8] * n, e[9] = t[9] + r[9] * n, e[10] = t[10] + r[10] * n, e[11] = t[11] + r[11] * n, e[12] = t[12] + r[12] * n, e[13] = t[13] + r[13] * n, e[14] = t[14] + r[14] * n, e[15] = t[15] + r[15] * n, e;}, f.exactEquals = function (e, t) {return e[0] === t[0] && e[1] === t[1] && e[2] === t[2] && e[3] === t[3] && e[4] === t[4] && e[5] === t[5] && e[6] === t[6] && e[7] === t[7] && e[8] === t[8] && e[9] === t[9] && e[10] === t[10] && e[11] === t[11] && e[12] === t[12] && e[13] === t[13] && e[14] === t[14] && e[15] === t[15];}, f.equals = function (e, t, r) {return r = r || n, Math.abs(e[0] - t[0]) <= r && Math.abs(e[1] - t[1]) <= r && Math.abs(e[2] - t[2]) <= r && Math.abs(e[3] - t[3]) <= r && Math.abs(e[4] - t[4]) <= r && Math.abs(e[5] - t[5]) <= r && Math.abs(e[6] - t[6]) <= r && Math.abs(e[7] - t[7]) <= r && Math.abs(e[8] - t[8]) <= r && Math.abs(e[9] - t[9]) <= r && Math.abs(e[10] - t[10]) <= r && Math.abs(e[11] - t[11]) <= r && Math.abs(e[12] - t[12]) <= r && Math.abs(e[13] - t[13]) <= r && Math.abs(e[14] - t[14]) <= r && Math.abs(e[15] - t[15]) <= r;};var v = f,_ = { createFloat32: function createFloat32() {var e = new Float32Array(4);return e[0] = 0, e[1] = 0, e[2] = 0, e[3] = 1, e;}, createFloat64: function createFloat64() {var e = new Float64Array(4);return e[0] = 0, e[1] = 0, e[2] = 0, e[3] = 1, e;}, createNumber: function createNumber() {return [0, 0, 0, 1];} };_.rotationTo = function () {var e = c.createFloat64(),t = c.createFloat64FromValues(1, 0, 0),r = c.createFloat64FromValues(0, 1, 0);return function (o, i, s) {var a = c.dot(i, s);return a < -1 + n ? (c.cross(e, t, i), c.length(e) < n && c.cross(e, r, i), c.normalize(e, e), _.setAxisAngle(o, e, Math.PI), o) : a > 1 - n ? (o[0] = 0, o[1] = 0, o[2] = 0, o[3] = 1, o) : (c.cross(e, i, s), o[0] = e[0], o[1] = e[1], o[2] = e[2], o[3] = 1 + a, _.normalize(o, o));};}(), _.setAxes = function () {var e = p.createFloat64();return function (t, r, n, o) {return e[0] = n[0], e[3] = n[1], e[6] = n[2], e[1] = o[0], e[4] = o[1], e[7] = o[2], e[2] = -r[0], e[5] = -r[1], e[8] = -r[2], _.normalize(t, _.fromMatrix33(t, e));};}(), _.clone = l.clone, _.createFloat32FromValues = l.createFloat32FromValues, _.createFloat64FromValues = l.createFloat64FromValues, _.createNumberFromValues = l.createNumberFromValues, _.asFloat32 = l.createFloat32FromValues, _.asFloat64 = l.createFloat64FromValues, _.copy = l.copy, _.set = l.set, _.identity = function (e) {return e[0] = 0, e[1] = 0, e[2] = 0, e[3] = 1, e;}, _.setAxisAngle = function (e, t, r) {r *= .5;var n = Math.sin(r);return e[0] = n * t[0], e[1] = n * t[1], e[2] = n * t[2], e[3] = Math.cos(r), e;}, _.getAxisAngle = function (e, t) {var r = 2 * Math.acos(t[3]),n = Math.sin(r / 2);return 0 !== n ? (e[0] = t[0] / n, e[1] = t[1] / n, e[2] = t[2] / n) : (e[0] = 1, e[1] = 0, e[2] = 0), r;}, _.add = l.add, _.multiply = function (e, t, r) {var n = t[0],o = t[1],i = t[2],s = t[3],a = r[0],c = r[1],u = r[2],l = r[3];return e[0] = n * l + s * a + o * u - i * c, e[1] = o * l + s * c + i * a - n * u, e[2] = i * l + s * u + n * c - o * a, e[3] = s * l - n * a - o * c - i * u, e;}, _.mul = _.multiply, _.scale = l.scale, _.rotateX = function (e, t, r) {r *= .5;var n = t[0],o = t[1],i = t[2],s = t[3],a = Math.sin(r),c = Math.cos(r);return e[0] = n * c + s * a, e[1] = o * c + i * a, e[2] = i * c - o * a, e[3] = s * c - n * a, e;}, _.rotateY = function (e, t, r) {r *= .5;var n = t[0],o = t[1],i = t[2],s = t[3],a = Math.sin(r),c = Math.cos(r);return e[0] = n * c - i * a, e[1] = o * c + s * a, e[2] = i * c + n * a, e[3] = s * c - o * a, e;}, _.rotateZ = function (e, t, r) {r *= .5;var n = t[0],o = t[1],i = t[2],s = t[3],a = Math.sin(r),c = Math.cos(r);return e[0] = n * c + o * a, e[1] = o * c - n * a, e[2] = i * c + s * a, e[3] = s * c - i * a, e;}, _.calculateW = function (e, t) {var r = t[0],n = t[1],o = t[2];return e[0] = r, e[1] = n, e[2] = o, e[3] = Math.sqrt(Math.abs(1 - r * r - n * n - o * o)), e;}, _.dot = l.dot, _.lerp = l.lerp, _.slerp = function (e, t, r, o) {var i,s,a,c,u,l = t[0],h = t[1],d = t[2],g = t[3],p = r[0],f = r[1],v = r[2],_ = r[3];return (s = l * p + h * f + d * v + g * _) < 0 && (s = -s, p = -p, f = -f, v = -v, _ = -_), 1 - s > n ? (i = Math.acos(s), a = Math.sin(i), c = Math.sin((1 - o) * i) / a, u = Math.sin(o * i) / a) : (c = 1 - o, u = o), e[0] = c * l + u * p, e[1] = c * h + u * f, e[2] = c * d + u * v, e[3] = c * g + u * _, e;}, _.sqlerp = function () {var e = _.createFloat64(),t = _.createFloat64();return function (r, n, o, i, s, a) {return _.slerp(e, n, s, a), _.slerp(t, o, i, a), _.slerp(r, e, t, 2 * a * (1 - a)), r;};}(), _.invert = function (e, t) {var r = t[0],n = t[1],o = t[2],i = t[3],s = r * r + n * n + o * o + i * i,a = s ? 1 / s : 0;return e[0] = -r * a, e[1] = -n * a, e[2] = -o * a, e[3] = i * a, e;}, _.conjugate = function (e, t) {return e[0] = -t[0], e[1] = -t[1], e[2] = -t[2], e[3] = t[3], e;}, _.length = l.length, _.len = _.length, _.squaredLength = l.squaredLength, _.sqrLen = _.squaredLength, _.normalize = l.normalize, _.fromMatrix33 = function (e, t) {var r,n = t[0] + t[4] + t[8];if (n > 0) r = Math.sqrt(n + 1), e[3] = .5 * r, r = .5 / r, e[0] = (t[5] - t[7]) * r, e[1] = (t[6] - t[2]) * r, e[2] = (t[1] - t[3]) * r;else {var o = 0;t[4] > t[0] && (o = 1), t[8] > t[3 * o + o] && (o = 2);var i = (o + 1) % 3,s = (o + 2) % 3;r = Math.sqrt(t[3 * o + o] - t[3 * i + i] - t[3 * s + s] + 1), e[o] = .5 * r, r = .5 / r, e[3] = (t[3 * i + s] - t[3 * s + i]) * r, e[i] = (t[3 * i + o] + t[3 * o + i]) * r, e[s] = (t[3 * s + o] + t[3 * o + s]) * r;}return e;}, _.toString = function (e) {return \"[\" + e[0] + \", \" + e[1] + \", \" + e[2] + \", \" + e[3] + \"]\";}, _.exactEquals = l.exactEquals, _.equals = l.equals;var y = _,m = { frustum: function frustum(e, t, r, n, o, i, s) {var a = 1 / (r - t),c = 1 / (o - n),u = 1 / (i - s);return e[0] = 2 * i * a, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = 2 * i * c, e[6] = 0, e[7] = 0, e[8] = (r + t) * a, e[9] = (o + n) * c, e[10] = (s + i) * u, e[11] = -1, e[12] = 0, e[13] = 0, e[14] = s * i * 2 * u, e[15] = 0, e;}, perspective: function perspective(e, t, r, n, o) {var i = 1 / Math.tan(t / 2),s = 1 / (n - o);return e[0] = i / r, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = i, e[6] = 0, e[7] = 0, e[8] = 0, e[9] = 0, e[10] = (o + n) * s, e[11] = -1, e[12] = 0, e[13] = 0, e[14] = 2 * o * n * s, e[15] = 0, e;}, ortho: function ortho(e, t, r, n, o, i, s) {var a = 1 / (t - r),c = 1 / (n - o),u = 1 / (i - s);return e[0] = -2 * a, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = -2 * c, e[6] = 0, e[7] = 0, e[8] = 0, e[9] = 0, e[10] = 2 * u, e[11] = 0, e[12] = (t + r) * a, e[13] = (o + n) * c, e[14] = (s + i) * u, e[15] = 1, e;}, lookAt: function lookAt(e, t, r, o) {var i,s,a,c,u,l,h,d,g,p,f = t[0],_ = t[1],y = t[2],m = o[0],E = o[1],x = o[2],R = r[0],A = r[1],P = r[2];return Math.abs(f - R) < n && Math.abs(_ - A) < n && Math.abs(y - P) < n ? v.identity(e) : (h = f - R, d = _ - A, g = y - P, i = E * (g *= p = 1 / Math.sqrt(h * h + d * d + g * g)) - x * (d *= p), s = x * (h *= p) - m * g, a = m * d - E * h, (p = Math.sqrt(i * i + s * s + a * a)) ? (i *= p = 1 / p, s *= p, a *= p) : (i = 0, s = 0, a = 0), c = d * a - g * s, u = g * i - h * a, l = h * s - d * i, (p = Math.sqrt(c * c + u * u + l * l)) ? (c *= p = 1 / p, u *= p, l *= p) : (c = 0, u = 0, l = 0), e[0] = i, e[1] = c, e[2] = h, e[3] = 0, e[4] = s, e[5] = u, e[6] = d, e[7] = 0, e[8] = a, e[9] = l, e[10] = g, e[11] = 0, e[12] = -(i * f + s * _ + a * y), e[13] = -(c * f + u * _ + l * y), e[14] = -(h * f + d * _ + g * y), e[15] = 1, e);}, transformProjectionMatrix: function transformProjectionMatrix(e, t, r) {var n = t[0],o = t[1],i = t[2],s = r[3] * n + r[7] * o + r[11] * i + r[15];return s = s || 1, e[0] = (r[0] * n + r[4] * o + r[8] * i + r[12]) / s, e[1] = (r[1] * n + r[5] * o + r[9] * i + r[13]) / s, e[2] = (r[2] * n + r[6] * o + r[10] * i + r[14]) / s, e;} };t.default = { Vector2: s, Vector3: c, Vector4: l, Matrix22: d, Matrix33: p, Matrix44: v, Quat: y, ProjectionUtils: m, FLOAT64_TOLERANCE: n, FLOAT32_TOLERANCE: o };}, function (e, t, r) {\"use strict\";Object.defineProperty(t, \"__esModule\", { value: !0 });var n = { assert: function assert(e, t) {if (!e) throw new Error(t);} };t.ConsoleUtils = n;}, function (e, t, r) {\"use strict\";Object.defineProperty(t, \"__esModule\", { value: !0 }), t.definePlaneThroughPoints = t.getPlaneTransforms = t.limitRange = t.PI2 = t.sortedIndex = t.clamp = t.orient2D = t.signedDistanceTo2DLine = t.intersectIntervals = t.solveTwoEquationsTwoVariables = t.closestPointToTriangle = t.closestPointToPolyline = t.distancePointToLineSegment = t.projectPointToLineSegment = t.angleDifference = t.periodicDifference = t.minMaxCosSinFunc = t.convertToOtherPeriodicRange = t.adjustParameterToPeriodicRange = t.getShortestParametricRange = t.isParameterWithinPeriodicRange = t.normalizeSegmentsToPeriodicRange = t.normalizeParametricRange = t.normalizeParametricRangeToShiftedRange = t.normalizeParameterToShiftedRange = t.adjustAngleToRange = t.normalizeAngleRange = t.normalizeAngle = t.normalizeParameter = t.foldNearTo = t.foldAbove = t.fold = t.modulus = t.getSignedAngle = t.isPointInsidePolygon2D = t.binomialCoefficients = void 0;var n = r(1),o = r(0),i = r(2),s = 2 * Math.PI,a = [];!function () {for (var e = 0; e < 8; ++e) {a[e] = [1];for (var t = 1; t < e; ++t) {a[e][t] = a[e - 1][t - 1] + a[e - 1][t];}a[e][e] = 1;}}();var c = function c(e, t, r) {return Math.min(Math.max(t, e), r);},u = function u(e, t) {return e - t * Math.floor(e / t);},l = function l(e, t) {var r = e % t;return r < 0 ? r + t : r;},h = function h(e, t, r) {return l(e - t, r) + t;},d = function d(e, t) {return e < 0 ? t + e % t : e % t;},g = function g(e, t) {return d(e - t[0], t[1] - t[0]) + t[0];},p = function p(e, t) {i.ConsoleUtils.assert(e[1] >= e[0], \"normalizeParametricRange: in_range ends not in order.\");var r = e[1] - e[0],n = d(e[0], t);return [n, n + r];},f = function f(e, t, r, n, o) {if (!isFinite(r)) return e;var i = p(t, r),s = d(e, r),a = s + r;if (n = !!n, s >= i[0] && s <= i[1]) return t[0] + (s - i[0]);if (a >= i[0] && a <= i[1]) return t[0] + (a - i[0]);var c = Math.abs(i[0] - s),u = Math.abs(s - i[1]),l = Math.abs(i[0] - a),h = Math.abs(a - i[1]);return o ? Math.min(c, l) < Math.min(u, h) ? t[0] : t[1] : Math.min(c, u) > Math.min(l, h) && !n ? t[0] + (a - i[0]) : t[0] + (s - i[0]);},v = function v(e, t, r) {var n = Math.abs(e - t);return isFinite(r) && (n %= r) > r / 2 ? r - n : n;},_ = function _(e, t, r) {var i = n.Vector3.sub(n.Vector3.createFloat64(), t, e),s = n.Vector3.dot(i, i);if (s < o.KERNEL_TOLERANCE * o.KERNEL_TOLERANCE) return 0;var a = n.Vector3.sub(n.Vector3.createFloat64(), r, e);return n.Vector3.dot(a, i) / s;};t.binomialCoefficients = a, t.isPointInsidePolygon2D = function (e, t) {for (var r = !1, n = t.length, o = 0, i = n - 2; o < n; o += 2) {t[o + 1] > e[1] != t[i + 1] > e[1] && e[0] < (t[i] - t[o]) * (e[1] - t[o + 1]) / (t[i + 1] - t[o + 1]) + t[o] && (r = !r), i = o;}return r;}, t.getSignedAngle = function (e, t) {var r = c(n.Vector2.dot(e, t), -1, 1),o = t[0] * e[1] - t[1] * e[0];return 0 === o ? .5 * Math.PI * (r - 1) : o < 0 ? -Math.acos(r) : Math.acos(r);}, t.modulus = u, t.fold = l, t.foldAbove = h, t.foldNearTo = function (e, t, r) {return h(e, t - r / 2, r);}, t.normalizeParameter = d, t.normalizeAngle = function (e) {return d(e, s);}, t.normalizeAngleRange = function (e) {return p(e, 2 * Math.PI);}, t.adjustAngleToRange = function (e, t) {return f(e, t, 2 * Math.PI);}, t.normalizeParameterToShiftedRange = g, t.normalizeParametricRangeToShiftedRange = function (e, t) {i.ConsoleUtils.assert(e[1] >= e[0], \"normalizeParametricRangeToShiftedRange: in_range ends not in order.\");var r = e[1] - e[0],n = g(e[0], t);return [n, n + r];}, t.normalizeParametricRange = p, t.normalizeSegmentsToPeriodicRange = function (e, t, r, n, i) {for (var s = void 0 !== n ? n : o.KERNEL_TOLERANCE, a = void 0 !== i ? i : t[1] - t[0], c = [], u = 0; u < e.length; u++) {var l = g(e[u][0], t),h = e[u][1] - e[u][0];if (h >= a) return [[t[0], t[1]]];var d = l + h;d < t[1] ? c.push([l, d]) : (c.push([l, t[1]]), c.push([t[0], d - t[1] + t[0]]));}var p = [];for (c.sort(function (e, t) {return e[0] - t[0];}), u = 0; u < c.length; u++) {for (var f = c[u]; u + 1 < c.length && c[u + 1][0] < f[1];) {f[1] = Math.max(f[1], c[u + 1][1]), u++;}(Math.abs(f[1] - f[0]) > s || !r) && p.push(f);}return p;}, t.isParameterWithinPeriodicRange = function (e, t, r, n) {var o = f(e, t, r);return n = n || 0, o > t[0] - n && o < t[1] + n;}, t.getShortestParametricRange = function (e, t, r) {if ((e = d(e, r)) > (t = d(t, r))) {var n = e;e = t, t = n;}return e - t + r < t - e ? [t, e + r] : [e, t];}, t.adjustParameterToPeriodicRange = f, t.convertToOtherPeriodicRange = function (e, t, r, n) {if (!isFinite(r)) return i.ConsoleUtils.assert(e[0] >= t[0] - n, \"The start of the input range doesn't lie in the target range.\"), i.ConsoleUtils.assert(e[1] <= t[1] + n, \"The input range doesn't lie within the target range.\"), e;if (n = n || 0, e[1] - e[0] >= r - n) return t[1] - t[0] < r - n && console.error(\"The input range is larger than the target range.\"), t;var o = f(e[0], t, r);i.ConsoleUtils.assert(o >= t[0] - n, \"The start of the input range doesn't lie in the target range.\");var s = o + e[1] - e[0];return i.ConsoleUtils.assert(s <= t[1] + n, \"The input range doesn't lie within the target range.\"), [o, s];}, t.minMaxCosSinFunc = function (e, t, r, n) {if (0 === e && 0 === t) return [r, r];var o,i = p(n, 2 * Math.PI),s = f(Math.atan(t / e), i, Math.PI, !0),a = [];for (o = 0; o < 3; ++o) {i[0] <= s && i[1] >= s && a.push(e * Math.cos(s) + t * Math.sin(s)), s += Math.PI;}if (n[1] - n[0] < 2 * Math.PI) for (o = 0; o < 2; o++) {a.push(e * Math.cos(n[o]) + t * Math.sin(n[o]));}return [Math.min.apply(null, a) + r, Math.max.apply(null, a) + r];}, t.periodicDifference = v, t.angleDifference = function (e, t) {return v(e, t, 2 * Math.PI);}, t.projectPointToLineSegment = _, t.distancePointToLineSegment = function (e, t, r, o) {var i = _(e, t, r);i = c(i, 0, 1);var s = o || n.Vector3.createFloat64();return n.Vector3.lerp(s, e, t, i), n.Vector3.distance(s, r);}, t.closestPointToPolyline = function (e, t, r, o, i) {for (var s = \"number\" == typeof t[0], a = s ? t.length / 3 : t.length, u = void 0, l = Number.POSITIVE_INFINITY, h = n.Vector3.createFloat64(), d = 0; d < a - 1; ++d) {var g = r ? r[d] : d,p = r ? r[d + 1] : d + 1,f = 0,v = 1;if (!(o && (o[0] > g && (f = (o[0] - g) / (p - g)), o[1] < p && (v = (o[1] - g) / (p - g)), v < f))) {var y, m;s ? (y = [t[3 * d], t[3 * d + 1], t[3 * d + 2]], m = [t[3 * d + 3], t[3 * d + 4], t[3 * d + 5]]) : (y = t[d], m = t[d + 1]);var E = _(y, m, e);E = c(E, f, v), n.Vector3.lerp(h, y, m, E);var x = n.Vector3.squaredDistance(h, e);x < l && (u = (1 - E) * g + E * p, l = x, i && n.Vector3.copy(i, h));}}return u;}, t.closestPointToTriangle = function (e, t, r, i, s) {var a,u,l = n.Vector3.sub(n.Vector3.createFloat64(), r, t),h = n.Vector3.sub(n.Vector3.createFloat64(), i, t),d = n.Vector3.sub(n.Vector3.createFloat64(), e, t),g = n.Vector3.squaredLength(l),p = n.Vector3.squaredLength(h),f = n.Vector3.dot(l, h),v = n.Vector3.dot(d, l),y = n.Vector3.dot(d, h);if (g < o.KERNEL_TOLERANCE * o.KERNEL_TOLERANCE && p < o.KERNEL_TOLERANCE * o.KERNEL_TOLERANCE) a = u = 0;else if (g < o.KERNEL_TOLERANCE * o.KERNEL_TOLERANCE) a = 0, u = c(y / p, 0, 1);else if (p < o.KERNEL_TOLERANCE * o.KERNEL_TOLERANCE) a = c(v / g, 0, 1), u = 0;else {var m = n.Matrix22.createFloat64FromValues(g, f, f, p);if (Math.abs(n.Matrix22.determinant(m)) > n.FLOAT64_TOLERANCE) {n.Matrix22.invert(m, m);var E = [v, y];n.Vector2.transformMatrix22(E, E, m), a = E[0], u = E[1];} else u = y / p, (a = v / g) <= 0 || u <= 0 ? (a = c(a, 0, 1), u = c(u, 0, 1)) : a < u ? (a = c(a, 0, 1), u = 0) : (a = 0, u = c(u, 0, 1));}if (a < 0 && y >= 0 && y <= p && (a = 0, u = y / p), u < 0 && v >= 0 && v <= g && (a = v / g, u = 0), a + u > 1) {var x = _(r, i, e);x >= 0 && x <= 1 && (a = 1 - x, u = x);}if (a < 0 || u < 0 || a + u > 1) {var R = n.Vector3.squaredLength(d),A = n.Vector3.squaredDistance(e, r),P = n.Vector3.squaredDistance(e, i);A <= R && A <= P ? (a = 1, u = 0) : P <= R && P <= A ? (a = 0, u = 1) : a = u = 0;}return s && (n.Vector3.scaleAndAdd(s, t, l, a), n.Vector3.scaleAndAdd(s, s, h, u)), { coordA: a, coordB: u };}, t.solveTwoEquationsTwoVariables = function (e) {var t = e[0][0],r = e[0][1],n = e[1][0],o = e[1][1],i = t * o - r * n;if (0 !== i) {var s = o * e[0][2] - r * e[1][2],a = -n * e[0][2] + t * e[1][2];return [s /= i, a /= i];}}, t.intersectIntervals = function (e, t, r) {r = r || 0;for (var n = [], o = 0; o < e.length; o++) {for (var i = 0; i < t.length; i++) {var s = Math.max(e[o][0], t[i][0]),a = Math.min(e[o][1], t[i][1]);a - r > s && (a > s ? n.push([s, a]) : n.push([a, a]));}}return n;}, t.signedDistanceTo2DLine = function (e, t, r) {var n = r[0] - e[0],o = r[1] - e[1];return t[1] * n - t[0] * o;}, t.orient2D = function (e, t, r) {var n = e[0] - r[0],o = t[0] - r[0],i = e[1] - r[1];return n * (t[1] - r[1]) - i * o;}, t.clamp = c, t.sortedIndex = function (e, t) {for (var r = 0, n = e.length; n > r;) {var o = Math.floor((r + n) / 2);t > e[o] ? r = o + 1 : n = o;}return n;}, t.PI2 = s, t.limitRange = function (e, t, r, o) {if (i.ConsoleUtils.assert(2 === t.length), i.ConsoleUtils.assert(t[0] <= t[1]), r) return t[1] - t[0] < o + n.FLOAT64_TOLERANCE ? [t[0], t[1]] : (console.warn(\"limitRange : in_limitRange length cannot be greater than in_period\"), [t[0], t[0] + o]);var s = Math.max(e[0], t[0]),a = Math.min(e[1], t[1]);return s > a && (s > a + n.FLOAT64_TOLERANCE && console.warn(\"limitRange : requested range must overlap in_oldRange\"), s = a = t[0] > e[1] ? e[1] : e[0]), [s, a];}, t.getPlaneTransforms = function (e) {var t,r,o = e.evaluateDu(0, 0),i = e.evaluateDv(0, 0),s = e.getOrigin();if (!n.Vector3.isParallel(o, [1, 0, 0], 1) || !n.Vector3.isParallel(i, [0, 1, 0], 1) || Math.abs(s[2]) > n.FLOAT64_TOLERANCE) {var a = e.evaluateNormal(0, 0);t = n.Matrix44.createFloat64FromValues(o[0], o[1], o[2], 0, i[0], i[1], i[2], 0, a[0], a[1], a[2], 0, s[0], s[1], s[2], 1), r = n.Matrix44.createFloat64(), n.Matrix44.invert(r, t);}return { uvToThreeSpace: t, threeSpaceToUV: r };}, t.definePlaneThroughPoints = function (e) {var t,r,i,s = [0, 0, 0],a = [0, 0, 0];if (!(e.length < 3)) {var c = [0, 0, 0];for (t = 0; t < e.length; ++t) {n.Vector3.add(c, c, e[t]);}n.Vector3.scale(c, c, 1 / e.length);var l = [0, 0, 0];r = 0;var h = 0,d = 0;for (t = 0; t < e.length; ++t) {(i = n.Vector3.squaredDistance(c, e[t])) > d && (d = i, h = t), (i /= 100) > r && (r = i, n.Vector3.sub(l, e[t], c));var g = (t + 1) % e.length;(i = n.Vector3.squaredDistance(e[t], e[g])) > r && (r = i, n.Vector3.sub(l, e[g], e[t]));}if (!(d < o.KERNEL_TOLERANCE * o.KERNEL_TOLERANCE)) {n.Vector3.normalize(l, l);var p = [0, 0, 0];for (r = 0, t = 0; t < e.length; ++t) {n.Vector3.sub(s, e[t], c), n.Vector3.cross(s, s, l), (i = n.Vector3.squaredLength(s)) > r && (r = i, n.Vector3.copy(p, s));}if (!(r < o.KERNEL_TOLERANCE * o.KERNEL_TOLERANCE)) {n.Vector3.normalize(p, p);var f = e[h],v = e[u(h - 1, e.length)],_ = e[u(h + 1, e.length)];n.Vector3.sub(s, v, f), n.Vector3.sub(a, _, f), n.Vector3.dot(n.Vector3.cross(a, a, s), p) < 0 && n.Vector3.negate(p, p);var y = [0, 0, 0];n.Vector3.cross(y, p, l), n.Vector3.normalize(y, y);var m = Number.POSITIVE_INFINITY,E = Number.NEGATIVE_INFINITY,x = Number.POSITIVE_INFINITY,R = Number.NEGATIVE_INFINITY;for (t = 0; t < e.length; ++t) {n.Vector3.sub(s, e[t], c);var A = n.Vector3.dot(s, l),P = n.Vector3.dot(s, y);m = Math.min(m, A), E = Math.max(E, A), x = Math.min(x, P), R = Math.max(R, P);}return { origin: c, normal: p, uAxis: l, vAxis: y, uRange: [m, E], vRange: [x, R] };}}}};}, function (e, t, r) {\"use strict\";Object.defineProperty(t, \"__esModule\", { value: !0 }), t.BoundingBox = void 0;var n = r(1),o = r(0),i = function i(e, t) {this.min = e ? n.Vector3.createFloat64FromValues(e[0], e[1], e[2]) : n.Vector3.createFloat64FromValues(1 / 0, 1 / 0, 1 / 0), this.max = t ? n.Vector3.createFloat64FromValues(t[0], t[1], t[2]) : n.Vector3.createFloat64FromValues(-1 / 0, -1 / 0, -1 / 0);};i.prototype.toString = function () {return \"(x:\" + this.min[0] + \", y:\" + this.min[1] + \", z:\" + this.min[2] + \") -> (x:\" + this.max[0] + \", y:\" + this.max[1] + \", z:\" + this.max[2] + \")\";}, i.prototype.copy = function (e) {return n.Vector3.copy(this.min, e.min), n.Vector3.copy(this.max, e.max), this;}, i.prototype.clone = function () {return new i(this.min, this.max);}, i.prototype.getWidth = function (e) {var t = 0;return 0 <= e && e <= 2 ? (t = this.max[e] - this.min[e], isFinite(t) ? t : 0) : (console.error(\"wrong axis argument supplied to BoundingBox.getWidth(): \" + e), 0);}, i.prototype.getMaxMinAligned = function (e, t, r) {for (var o, s, a, c = this.getCorners(), u = [], l = [], h = [], d = 0; d < c.length; ++d) {o = n.Vector3.dot(c[d], e), s = n.Vector3.dot(c[d], t), a = n.Vector3.dot(c[d], r), u.push(o), l.push(s), h.push(a);}var g = Math.min.apply(void 0, u),p = Math.min.apply(void 0, l),f = Math.min.apply(void 0, h),v = Math.max.apply(void 0, u),_ = Math.max.apply(void 0, l),y = Math.max.apply(void 0, h);return new i([g, p, f], [v, _, y]);}, i.prototype.include = function (e) {return this.includeX(e.min[0], e.max[0]), this.includeY(e.min[1], e.max[1]), this.includeZ(e.min[2], e.max[2]), this;}, i.prototype.includeX = function (e, t) {return this.min[0] = Math.min(this.min[0], e), this.max[0] = Math.max(this.max[0], t), this;}, i.prototype.includeY = function (e, t) {return this.min[1] = Math.min(this.min[1], e), this.max[1] = Math.max(this.max[1], t), this;}, i.prototype.includeZ = function (e, t) {return this.min[2] = Math.min(this.min[2], e), this.max[2] = Math.max(this.max[2], t), this;}, i.prototype.includeSphere = function (e) {var t = e.getCenter(),r = e.getRadius();return this.includeX(t[0] - r, t[0] + r), this.includeY(t[1] - r, t[1] + r), this.includeZ(t[2] - r, t[2] + r), this;}, i.prototype.translate = function (e) {return n.Vector3.add(this.min, this.min, e), n.Vector3.add(this.max, this.max, e), this;}, i.prototype.getCorners = function () {var e = this.getDiagonal();return [n.Vector3.clone(this.min), n.Vector3.createFloat64FromValues(this.min[0] + e[0], this.min[1], this.min[2]), n.Vector3.createFloat64FromValues(this.min[0], this.min[1] + e[1], this.min[2]), n.Vector3.createFloat64FromValues(this.min[0], this.min[1], this.min[2] + e[2]), n.Vector3.createFloat64FromValues(this.min[0] + e[0], this.min[1] + e[1], this.min[2]), n.Vector3.createFloat64FromValues(this.min[0] + e[0], this.min[1], this.min[2] + e[2]), n.Vector3.createFloat64FromValues(this.min[0], this.min[1] + e[1], this.min[2] + e[2]), n.Vector3.clone(this.max)];}, i.prototype.transform = function (e) {if (!this.isEmpty()) {var t = this.getCorners();this.max[0] = -1 / 0, this.max[1] = -1 / 0, this.max[2] = -1 / 0, this.min[0] = 1 / 0, this.min[1] = 1 / 0, this.min[2] = 1 / 0;for (var r = 0; r < t.length; ++r) {n.Vector3.transformMatrix44(t[r], t[r], e), n.Vector3.max(this.max, this.max, t[r]), n.Vector3.min(this.min, this.min, t[r]);}}return this;}, i.prototype.includePointXYZ = function (e) {return this.includeX(e.x, e.x), this.includeY(e.y, e.y), this.includeZ(e.z, e.z), this;}, i.prototype.includePoint = function (e) {return this.includeX(e[0], e[0]), this.includeY(e[1], e[1]), this.includeZ(e[2], e[2]), this;}, i.prototype.getCenter = function () {var e = n.Vector3.createFloat64();return n.Vector3.add(e, this.min, this.max), n.Vector3.scale(e, e, .5), e;}, i.prototype.getDiagonal = function () {var e = n.Vector3.createFloat64();return n.Vector3.sub(e, this.max, this.min), e;}, i.prototype.isPointInside = function (e) {return !(e[0] < this.min[0] || e[0] > this.max[0] || e[1] < this.min[1] || e[1] > this.max[1] || e[2] < this.min[2] || e[2] > this.max[2]);}, i.prototype.isPointInsideWithTolerance = function (e, t) {return t || (t = o.KERNEL_TOLERANCE), !(e[0] < this.min[0] - t || e[0] > this.max[0] + t || e[1] < this.min[1] - t || e[1] > this.max[1] + t || e[2] < this.min[2] - t || e[2] > this.max[2] + t);}, i.prototype.intersects = function (e) {return !(e.min[0] > this.max[0] || e.max[0] < this.min[0] || e.min[1] > this.max[1] || e.max[1] < this.min[1] || e.min[2] > this.max[2] || e.max[2] < this.min[2]);}, i.prototype.intersectsWithTolerance = function (e, t) {return t || (t = o.KERNEL_TOLERANCE), !(e.min[0] > this.max[0] + t || e.max[0] < this.min[0] - t || e.min[1] > this.max[1] + t || e.max[1] < this.min[1] - t || e.min[2] > this.max[2] + t || e.max[2] < this.min[2] - t);}, i.prototype.isEmpty = function () {return this.max[0] < this.min[0] || this.max[1] < this.min[1] || this.max[2] < this.min[2];}, i.prototype.setEmpty = function () {return this.max[0] = -1 / 0, this.min[0] = 1 / 0, this.max[1] = -1 / 0, this.min[1] = 1 / 0, this.max[2] = -1 / 0, this.min[2] = 1 / 0, this;}, i.prototype.isBounded = function () {return isFinite(this.max[0]) && isFinite(this.max[1]) && isFinite(this.max[2]) && isFinite(this.min[0]) && isFinite(this.min[1]) && isFinite(this.min[2]);}, t.BoundingBox = i;}, function (e, t, r) {\"use strict\";var n,o,i = e.exports = r(10),s = r(61);i.codegen = r(99), i.fetch = r(100), i.path = r(101), i.fs = i.inquire(\"fs\"), i.toArray = function (e) {if (e) {for (var t = Object.keys(e), r = new Array(t.length), n = 0; n < t.length;) {r[n] = e[t[n++]];}return r;}return [];}, i.toObject = function (e) {for (var t = {}, r = 0; r < e.length;) {var n = e[r++],o = e[r++];void 0 !== o && (t[n] = o);}return t;};var a = /\\\\/g,c = /\"/g;i.isReserved = function (e) {return /^(?:do|if|in|for|let|new|try|var|case|else|enum|eval|false|null|this|true|void|with|break|catch|class|const|super|throw|while|yield|delete|export|import|public|return|static|switch|typeof|default|extends|finally|package|private|continue|debugger|function|arguments|interface|protected|implements|instanceof)$/.test(e);}, i.safeProp = function (e) {return !/^[$\\w_]+$/.test(e) || i.isReserved(e) ? '[\"' + e.replace(a, \"\\\\\\\\\").replace(c, '\\\\\"') + '\"]' : \".\" + e;}, i.ucFirst = function (e) {return e.charAt(0).toUpperCase() + e.substring(1);};var u = /_([a-z])/g;i.camelCase = function (e) {return e.substring(0, 1) + e.substring(1).replace(u, function (e, t) {return t.toUpperCase();});}, i.compareFieldsById = function (e, t) {return e.id - t.id;}, i.decorateType = function (e, t) {if (e.$type) return t && e.$type.name !== t && (i.decorateRoot.remove(e.$type), e.$type.name = t, i.decorateRoot.add(e.$type)), e.$type;n || (n = r(63));var o = new n(t || e.name);return i.decorateRoot.add(o), o.ctor = e, Object.defineProperty(e, \"$type\", { value: o, enumerable: !1 }), Object.defineProperty(e.prototype, \"$type\", { value: o, enumerable: !1 }), o;};var l = 0;i.decorateEnum = function (e) {if (e.$type) return e.$type;o || (o = r(11));var t = new o(\"Enum\" + l++, e);return i.decorateRoot.add(t), Object.defineProperty(e, \"$type\", { value: t, enumerable: !1 }), t;}, Object.defineProperty(i, \"decorateRoot\", { get: function get() {return s.decorated || (s.decorated = new (r(71))());} });}, function (e, t, r) {\"use strict\";Object.defineProperty(t, \"__esModule\", { value: !0 }), t.Point = void 0;var n = r(1),o = r(43),i = r(4),s = r(0),a = function a(e) {o.BaseGeometry.call(this), this._position = n.Vector3.createFloat64(), e && n.Vector3.copy(this._position, e);};(a.prototype = Object.create(o.BaseGeometry.prototype)).getGeometryType = function () {return s.GEOMETRY_TYPES.POINT;}, a.prototype.clone = function () {var e = new a();return e.copy(this), e;}, a.prototype.copy = function (e) {o.BaseGeometry.prototype.copy.call(this, e), this.copyPosition(e.getPosition());}, a.prototype.getPosition = function () {return this._position;}, a.prototype.copyPosition = function (e) {n.Vector3.copy(this._position, e);}, a.prototype.setPosition = function (e, t, r) {n.Vector3.set(this._position, e, t, r);}, a.prototype.getBoundingBox = function () {var e = new i.BoundingBox();return e.includePoint(this.getPosition()), e;}, a.prototype.transform = function (e) {n.Vector3.transformMatrix44(this._position, this._position, e);}, a.prototype.toObject = function () {return { position: this.vectorToObject(this._position) };}, t.Point = a;}, function (e, t, r) {\"use strict\";Object.defineProperty(t, \"__esModule\", { value: !0 }), t.Line = void 0;var n = r(1),o = r(4),i = r(34),s = r(0),a = r(32),c = r(3),u = r(2),l = function l() {a.Curve.call(this), this._position = n.Vector3.createFloat64FromValues(0, 0, 0), this._direction = n.Vector3.createFloat64FromValues(1, 0, 0);};(l.prototype = Object.create(a.Curve.prototype)).getGeometryType = function () {return s.GEOMETRY_TYPES.LINE;}, l.prototype.set = function (e, t) {u.ConsoleUtils.assert(n.Vector3.squaredLength(t) > s.KERNEL_TOLERANCE * s.KERNEL_TOLERANCE), n.Vector3.copy(this._position, e), n.Vector3.copy(this._direction, t);}, l.prototype.clone = function () {var e = new l();return e.copy(this), e;}, l.prototype.tessellate = function (e, t) {var r = { positions: [], offsets: [], tolerance: 0 };r.offsets.push(0);var n = e[0];r.positions.push(this.evaluatePosition(n));for (var o = 1; o < e.length; ++o) {var i = e[o];r.positions.push(this.evaluatePosition(i)), r.offsets.push(r.positions.length - 1), n = i;}return r;}, l.prototype.copy = function (e) {a.Curve.prototype.copy.call(this, e), n.Vector3.copy(this._position, e._position), n.Vector3.copy(this._direction, e._direction);}, l.prototype.getRangeUnlimited = function () {return [-1 / 0, 1 / 0];}, l.prototype.isPeriodicUnlimited = function () {return !1;}, l.prototype.isClosedUnlimited = function () {return !1;}, l.prototype.evaluatePosition = function (e) {var t = n.Vector3.createFloat64();return n.Vector3.scaleAndAdd(t, this._position, this._direction, e);}, l.prototype.evaluateDt = function (e) {return n.Vector3.clone(this._direction);}, l.prototype.tangentLength = function (e) {return n.Vector3.length(this._direction);}, l.prototype.getTangentCone = function (e) {var t = n.Vector3.createFloat64();return new i.TangentCone(n.Vector3.normalize(t, this.evaluateDt(0)), 0);}, l.prototype.getArcLength = function (e) {return void 0 === e ? e = this.getRange() : 0 === e.length && (e = this.getRangeUnlimited()), isFinite(e[0]) && isFinite(e[1]) ? (e[1] - e[0]) * n.Vector3.length(this._direction) : 1 / 0;}, l.prototype.getParameterFromArcLength = function (e, t) {if (void 0 === t ? t = this.getRange() : 0 === t.length && (t = this.getRangeUnlimited()), isFinite(t[0]) && isFinite(t[1])) {var r = t[0] + e / n.Vector3.length(this._direction);return (0, c.clamp)(r, t[0], t[1]);}return NaN;}, l.prototype.getBoundingBox = function (e) {void 0 === e ? e = this.getRange() : 0 === e.length && (e = this.getRangeUnlimited());var t = new o.BoundingBox();return isFinite(e[0]) && isFinite(e[1]) ? (t.includePoint(this.evaluatePosition(e[0])), t.includePoint(this.evaluatePosition(e[1]))) : (t.includePoint([1 / 0, 1 / 0, 1 / 0]), t.includePoint([-1 / 0, -1 / 0, -1 / 0])), t;}, l.prototype.closestToRayParam = function (e, t, r, o) {var i = n.Vector3.createFloat64();n.Vector3.sub(i, this._position, e);var s = n.Vector3.squaredLength(this._direction),a = n.Vector3.squaredLength(t),c = n.Vector3.dot(this._direction, t),u = n.Vector3.dot(i, this._direction),l = n.Vector3.dot(i, t),h = s * a - c * c,d = (c * l - a * u) / h,g = (c * u - s * l) / h;if (isFinite(d) && isFinite(g)) {if (r) if (d < r[0]) {if (d = r[0], void 0 !== o) {var p = this.evaluatePosition(r[0]),f = n.Vector3.createFloat64();n.Vector3.sub(f, p, e), g = n.Vector3.dot(f, t) / a;}} else if (d > r[1] && (d = r[1], void 0 !== o)) {var v = this.evaluatePosition(r[1]);f = n.Vector3.createFloat64(), n.Vector3.sub(f, v, e), g = n.Vector3.dot(f, t) / a;}if (void 0 !== o) {var _ = this.evaluatePosition(d),y = n.Vector3.createFloat64();if (n.Vector3.scaleAndAdd(y, e, t, g), n.Vector3.squaredDistance(_, y) > o * o) return;}return d;}}, l.prototype.setFromEndpoints = function (e, t) {u.ConsoleUtils.assert(n.Vector3.squaredDistance(e, t) > s.KERNEL_TOLERANCE * s.KERNEL_TOLERANCE), this._position = n.Vector3.clone(e), n.Vector3.normalize(this._direction, n.Vector3.sub(this._direction, t, e)), this.unlimitRange();}, l.prototype.transform = function (e) {n.Vector3.transformMatrix44(this._position, this._position, e), n.Vector3.transformAsDirectionMatrix44(this._direction, this._direction, e);}, l.prototype.closestToPointParam = function (e, t) {void 0 === t ? t = this.getRange() : 0 === t.length && (t = this.getRangeUnlimited());var r = n.Vector3.createFloat64();n.Vector3.sub(r, e, this._position);var o = this._direction,i = n.Vector3.dot(r, o) / n.Vector3.squaredLength(o);return isFinite(t[0]) && isFinite(t[1]) ? (0, c.clamp)(i, t[0], t[1]) : i;}, l.prototype.suggestSplittingParam = function (e) {}, l.prototype.toObject = function () {return { position: this.vectorToObject(this._position), direction: this.vectorToObject(this._direction), range: this.rangeToObject(this.getRange(), this.isLimited()) };}, t.Line = l;}, function (e, t, r) {\"use strict\";Object.defineProperty(t, \"__esModule\", { value: !0 });var n = !1,o = !1,i = {},s = { init3D: function init3D(e) {for (var t in n = !0, e) {\"function\" == typeof e[t] && (s[t] = e[t].bind(e));}}, setLevel: function setLevel(e, t) {var r = i[e];return i[e] = t, console.log(\"Debug of \" + e + \" set to level \" + t), r;}, level: function level(e) {if (!n) return 0;var t = i[e];return void 0 === t ? 0 : t;}, setConsoleWarnings: function setConsoleWarnings(e) {o = e;}, warn: function warn(e) {o && console.warn(e);} };t.DebugUtils = s;}, function (e, t, r) {\"use strict\";Object.defineProperty(t, \"__esModule\", { value: !0 }), t.BaseTopology = void 0;var n = r(44),o = r(0),i = function i() {n.Base.call(this), this._attributes = [];};(i.prototype = Object.create(n.Base.prototype)).getTopologyType = function () {console.warn(\"BaseTopology.getTopologyType : abstract method invoked!\");}, i.prototype.getBoundingBox = function () {console.warn(\"BaseTopology.getBoundingBox : abstract method invoked!\");}, i.prototype.getBody = function () {console.warn(\"BaseTopology.getBody : abstract method invoked!\");}, i.prototype.collectFaces = function (e) {return console.warn(\"BaseTopology.collectFaces : abstract method invoked!\"), e || new Set();}, i.prototype.collectEdges = function (e) {return console.warn(\"BaseTopology.collectEdges : abstract method invoked!\"), e || new Set();}, i.prototype.collectVertices = function (e) {return console.warn(\"BaseTopology.collectVertices : abstract method invoked!\"), e || new Set();}, i.prototype.getAttributes = function () {return this._attributes;}, i.prototype.addAttribute = function (e) {this._attributes ? this._attributes.push(e) : this._attributes = [e], e.addTopology(this);}, i.prototype.removeAttribute = function (e) {var t = this._attributes.indexOf(e);return t > -1 && (this._attributes.splice(t, 1), e.removeTopology(this), !0);}, i.prototype.removeAllAttributes = function () {if (this._attributes) for (var _e2 = 0; _e2 < this._attributes.length; _e2++) {this.removeAttribute(this._attributes[_e2]);}}, i.prototype.isVertex = function () {return this.getTopologyType() === o.TOPOLOGY_TYPES.VERTEX;}, i.prototype.getFaces = function () {return Array.from(this.collectFaces());}, i.prototype.getEdges = function () {return Array.from(this.collectEdges());}, i.prototype.getVertices = function () {return Array.from(this.collectVertices());}, i.prototype.addAllToModelObject = function (e, t) {if (!e.topologies[this.getGuid()]) {var _t2 = {};_t2[o.TOPOLOGY_TYPES.toString(this.getTopologyType()).toLowerCase()] = this.toObject(), e.topologies[this.getGuid()] = _t2;}t.forEach(function (t) {null != t && (Array.isArray(t) ? t.forEach(function (t) {t.addToModelObject(e);}) : t.addToModelObject(e));});}, t.BaseTopology = i;}, function (e, t, r) {\"use strict\";(function (e) {var n = t;function o(e, t, r) {for (var n = Object.keys(t), o = 0; o < n.length; ++o) {void 0 !== e[n[o]] && r || (e[n[o]] = t[n[o]]);}return e;}function i(e) {function t(e, r) {if (!(this instanceof t)) return new t(e, r);Object.defineProperty(this, \"message\", { get: function get() {return e;} }), Error.captureStackTrace ? Error.captureStackTrace(this, t) : Object.defineProperty(this, \"stack\", { value: new Error().stack || \"\" }), r && o(this, r);}return (t.prototype = Object.create(Error.prototype)).constructor = t, Object.defineProperty(t.prototype, \"name\", { get: function get() {return e;} }), t.prototype.toString = function () {return this.name + \": \" + this.message;}, t;}n.asPromise = r(58), n.base64 = r(90), n.EventEmitter = r(91), n.float = r(92), n.inquire = r(59), n.utf8 = r(93), n.pool = r(94), n.LongBits = r(95), n.global = \"undefined\" != typeof window && window || void 0 !== e && e || \"undefined\" != typeof self && self || this, n.emptyArray = Object.freeze ? Object.freeze([]) : [], n.emptyObject = Object.freeze ? Object.freeze({}) : {}, n.isNode = Boolean(n.global.process && n.global.process.versions && n.global.process.versions.node), n.isInteger = Number.isInteger || function (e) {return \"number\" == typeof e && isFinite(e) && Math.floor(e) === e;}, n.isString = function (e) {return \"string\" == typeof e || e instanceof String;}, n.isObject = function (e) {return e && \"object\" == _typeof(e);}, n.isset = n.isSet = function (e, t) {var r = e[t];return !(null == r || !e.hasOwnProperty(t)) && (\"object\" != _typeof(r) || (Array.isArray(r) ? r.length : Object.keys(r).length) > 0);}, n.Buffer = function () {try {var e = n.inquire(\"buffer\").Buffer;return e.prototype.utf8Write ? e : null;} catch (e) {return null;}}(), n._Buffer_from = null, n._Buffer_allocUnsafe = null, n.newBuffer = function (e) {return \"number\" == typeof e ? n.Buffer ? n._Buffer_allocUnsafe(e) : new n.Array(e) : n.Buffer ? n._Buffer_from(e) : \"undefined\" == typeof Uint8Array ? e : new Uint8Array(e);}, n.Array = \"undefined\" != typeof Uint8Array ? Uint8Array : Array, n.Long = n.global.dcodeIO && n.global.dcodeIO.Long || n.global.Long || n.inquire(\"long\"), n.key2Re = /^true|false|0|1$/, n.key32Re = /^-?(?:0|[1-9][0-9]*)$/, n.key64Re = /^(?:[\\\\x00-\\\\xff]{8}|-?(?:0|[1-9][0-9]*))$/, n.longToHash = function (e) {return e ? n.LongBits.from(e).toHash() : n.LongBits.zeroHash;}, n.longFromHash = function (e, t) {var r = n.LongBits.fromHash(e);return n.Long ? n.Long.fromBits(r.lo, r.hi, t) : r.toNumber(Boolean(t));}, n.merge = o, n.lcFirst = function (e) {return e.charAt(0).toLowerCase() + e.substring(1);}, n.newError = i, n.ProtocolError = i(\"ProtocolError\"), n.oneOfGetter = function (e) {for (var t = {}, r = 0; r < e.length; ++r) {t[e[r]] = 1;}return function () {for (var e = Object.keys(this), r = e.length - 1; r > -1; --r) {if (1 === t[e[r]] && void 0 !== this[e[r]] && null !== this[e[r]]) return e[r];}};}, n.oneOfSetter = function (e) {return function (t) {for (var r = 0; r < e.length; ++r) {e[r] !== t && delete this[e[r]];}};}, n.toJSONOptions = { longs: String, enums: String, bytes: String, json: !0 }, n._configure = function () {var e = n.Buffer;e ? (n._Buffer_from = e.from !== Uint8Array.from && e.from || function (t, r) {return new e(t, r);}, n._Buffer_allocUnsafe = e.allocUnsafe || function (t) {return new e(t);}) : n._Buffer_from = n._Buffer_allocUnsafe = null;};}).call(this, r(57));}, function (e, t, r) {\"use strict\";e.exports = s;var n = r(21);((s.prototype = Object.create(n.prototype)).constructor = s).className = \"Enum\";var o = r(30),i = r(5);function s(e, t, r, o, i) {if (n.call(this, e, r), t && \"object\" != _typeof(t)) throw TypeError(\"values must be an object\");if (this.valuesById = {}, this.values = Object.create(this.valuesById), this.comment = o, this.comments = i || {}, this.reserved = void 0, t) for (var s = Object.keys(t), a = 0; a < s.length; ++a) {\"number\" == typeof t[s[a]] && (this.valuesById[this.values[s[a]] = t[s[a]]] = s[a]);}}s.fromJSON = function (e, t) {var r = new s(e, t.values, t.options, t.comment, t.comments);return r.reserved = t.reserved, r;}, s.prototype.toJSON = function (e) {var t = !!e && Boolean(e.keepComments);return i.toObject([\"options\", this.options, \"values\", this.values, \"reserved\", this.reserved && this.reserved.length ? this.reserved : void 0, \"comment\", t ? this.comment : void 0, \"comments\", t ? this.comments : void 0]);}, s.prototype.add = function (e, t, r) {if (!i.isString(e)) throw TypeError(\"name must be a string\");if (!i.isInteger(t)) throw TypeError(\"id must be an integer\");if (void 0 !== this.values[e]) throw Error(\"duplicate name '\" + e + \"' in \" + this);if (this.isReservedId(t)) throw Error(\"id \" + t + \" is reserved in \" + this);if (this.isReservedName(e)) throw Error(\"name '\" + e + \"' is reserved in \" + this);if (void 0 !== this.valuesById[t]) {if (!this.options || !this.options.allow_alias) throw Error(\"duplicate id \" + t + \" in \" + this);this.values[e] = t;} else this.valuesById[this.values[e] = t] = e;return this.comments[e] = r || null, this;}, s.prototype.remove = function (e) {if (!i.isString(e)) throw TypeError(\"name must be a string\");var t = this.values[e];if (null == t) throw Error(\"name '\" + e + \"' does not exist in \" + this);return delete this.valuesById[t], delete this.values[e], delete this.comments[e], this;}, s.prototype.isReservedId = function (e) {return o.isReservedId(this.reserved, e);}, s.prototype.isReservedName = function (e) {return o.isReservedName(this.reserved, e);};}, function (e, t, r) {\"use strict\";Object.defineProperty(t, \"__esModule\", { value: !0 }), t.Surface = void 0;var n = r(1),o = r(43),i = r(0),s = r(3),a = function a() {o.BaseGeometry.call(this), this._subrangeU = [], this._subrangeV = [];};(a.prototype = Object.create(o.BaseGeometry.prototype)).copy = function (e) {o.BaseGeometry.prototype.copy.call(this, e), this._subrangeU = e.isLimitedU() ? [e._subrangeU[0], e._subrangeU[1]] : [], this._subrangeV = e.isLimitedV() ? [e._subrangeV[0], e._subrangeV[1]] : [];}, a.prototype.isLimitedU = function () {return this._subrangeU.length > 0;}, a.prototype.isLimitedV = function () {return this._subrangeV.length > 0;}, a.prototype.getRangeU = function () {return this.isLimitedU() ? this._subrangeU : this.getRangeUnlimitedU();}, a.prototype.getRangeV = function () {return this.isLimitedV() ? this._subrangeV : this.getRangeUnlimitedV();}, a.prototype.getRangeUnlimitedU = function () {console.warn(\"Surface.getRangeUnlimitedU : abstract method invoked!\");}, a.prototype.getRangeUnlimitedV = function () {console.warn(\"Surface.getRangeUnlimitedV : abstract method invoked!\");}, a.prototype.limitRangeU = function (e) {var t = this.getRangeU();this._subrangeU = (0, s.limitRange)(t, e, this.isPeriodicU(), this.getPeriodU());}, a.prototype.limitRangeV = function (e) {var t = this.getRangeV();this._subrangeV = (0, s.limitRange)(t, e, this.isPeriodicV(), this.getPeriodV());}, a.prototype.unlimitRangeU = function () {this._subrangeU = [];}, a.prototype.unlimitRangeV = function () {this._subrangeV = [];}, a.prototype.isPeriodicU = function () {return this.isPeriodicUnlimitedU() && !this.isLimitedU();}, a.prototype.isPeriodicV = function () {return this.isPeriodicUnlimitedV() && !this.isLimitedV();}, a.prototype.isPeriodicUnlimitedU = function () {console.warn(\"Surface.isPeriodicUnlimitedU : abstract method invoked!\");}, a.prototype.isPeriodicUnlimitedV = function () {console.warn(\"Surface.isPeriodicUnlimitedV : abstract method invoked!\");}, a.prototype.getPeriodU = function () {return this.isLimitedU() ? void 0 : this.getPeriodUnlimitedU();}, a.prototype.getPeriodV = function () {return this.isLimitedV() ? void 0 : this.getPeriodUnlimitedV();}, a.prototype.getPeriodUnlimitedU = function () {if (this.isPeriodicUnlimitedU()) {var e = this.getRangeUnlimitedU();return e[1] - e[0];}}, a.prototype.getPeriodUnlimitedV = function () {if (this.isPeriodicUnlimitedV()) {var e = this.getRangeUnlimitedV();return e[1] - e[0];}}, a.prototype.isClosedU = function () {if (this.isClosedUnlimitedU()) {if (this.isLimitedU()) {var e = this.getRangeUnlimitedU(),t = e[1] - e[0];return this._subrangeU[1] - this._subrangeU[0] > t - i.PARAMETER_SPACE_TOLERANCE;}return !0;}return !1;}, a.prototype.isClosedV = function () {if (this.isClosedUnlimitedV()) {if (this.isLimitedV()) {var e = this.getRangeUnlimitedV(),t = e[1] - e[0];return this._subrangeV[1] - this._subrangeV[0] > t - i.PARAMETER_SPACE_TOLERANCE;}return !0;}return !1;}, a.prototype.isClosedUnlimitedU = function () {console.warn(\"Surface.isClosedUnlimitedU : abstract method invoked!\");}, a.prototype.isClosedUnlimitedV = function () {console.warn(\"Surface.isClosedUnlimitedV : abstract method invoked!\");}, a.prototype.evaluatePosition = function (e, t) {console.warn(\"Surface.evaluatePosition : abstract method invoked\");}, a.prototype.evaluateDu = function (e, t) {console.warn(\"Surface.evaluateDu : abstract method invoked\");}, a.prototype.evaluateDv = function (e, t) {console.warn(\"Surface.evaluateDv : abstract method invoked\");}, a.prototype.evaluateNormal = function (e, t) {var r = this.evaluateDu(e, t);return n.Vector3.cross(r, r, this.evaluateDv(e, t)), n.Vector3.normalize(r, r), r;}, a.prototype.closestParam = function (e) {console.warn(\"Surface.closestParam : abstract method invoked\");}, a.prototype.vParamLine = function (e) {console.warn(\"Surface.vParamLine : abstract method invoked, returning undefined\");}, a.prototype.uParamLine = function (e) {console.warn(\"Surface.uParamLine : abstract method invoked, returning undefined\");}, a.prototype.getBoundingBox = function (e, t) {console.warn(\"Surface.getBoundingBox : abstract method invoked, returning undefined\");}, a.prototype.transform = function (e) {console.warn(\"Surface.transform : abstract method invoked\");}, t.Surface = a;}, function (e, t, r) {\"use strict\";Object.defineProperty(t, \"__esModule\", { value: !0 }), t.Loop = void 0;var n = r(9),o = r(0),i = function i() {n.BaseTopology.call(this), this._coedges = [], this._face = void 0;};(i.prototype = Object.create(n.BaseTopology.prototype)).getTopologyType = function () {return o.TOPOLOGY_TYPES.LOOP;}, i.prototype.getFace = function () {return this._face;}, i.prototype.setFace = function (e) {this._face = e;}, i.prototype.getCoedges = function () {return this._coedges;}, i.prototype.setCoedges = function (e) {this._coedges = new Array(e.length);for (var t = 0; t < e.length; ++t) {this._coedges[t] = e[t];}}, i.prototype.addCoedge = function (e) {this._coedges ? this._coedges.push(e) : this._coedges = [e], e.setLoop(this);}, i.prototype.addCoedges = function (e) {this._coedges || (this._coedges = []);for (var t = 0; t < e.length; ++t) {e[t].setLoop(this);}this._coedges = this._coedges.concat(e);}, i.prototype.removeCoedge = function (e) {var t = this._coedges.indexOf(e);return t > -1 && (this._coedges.splice(t, 1), e.getLoop() === this && e.setLoop(void 0), !0);}, i.prototype.getBody = function () {return this._face ? this._face.getBody() : void 0;}, i.prototype.collectFaces = function (e) {return e = e || new Set(), this._face && e.add(this._face), e;}, i.prototype.collectEdges = function (e) {e = e || new Set();for (var t = 0; t < this._coedges.length; ++t) {this._coedges[t].collectEdges(e);}return e;}, i.prototype.collectVertices = function (e) {e = e || new Set();for (var t = 0; t < this._coedges.length; ++t) {this._coedges[t].collectVertices(e);}return e;}, i.prototype.toString = function () {return \"Loop\";}, i.prototype.toObject = function () {return { coedges: this.refsToStrings(this._coedges), attributes: this.refsToStrings(this._attributes) };}, i.prototype.addToModelObject = function (e) {this.addAllToModelObject(e, [this._coedges, this._attributes]);}, t.Loop = i;}, function (e, t, r) {\"use strict\";Object.defineProperty(t, \"__esModule\", { value: !0 }), t.Circle = void 0;var n = r(1),o = r(4),i = r(34),s = r(0),a = r(32),c = r(3),u = r(2),l = r(50),h = function h() {a.Curve.call(this), this._center = n.Vector3.createFloat64FromValues(0, 0, 0), this._normal = n.Vector3.createFloat64FromValues(0, 0, 1), this._xAxis = n.Vector3.createFloat64FromValues(1, 0, 0), this._yAxis = n.Vector3.createFloat64FromValues(0, 1, 0), this._radius = 1;};(h.prototype = Object.create(a.Curve.prototype)).getGeometryType = function () {return s.GEOMETRY_TYPES.CIRCLE;}, h.prototype.set = function (e, t, r) {u.ConsoleUtils.assert(n.Vector3.squaredLength(t) > s.KERNEL_TOLERANCE * s.KERNEL_TOLERANCE), u.ConsoleUtils.assert(n.Vector3.squaredLength(r) > s.KERNEL_TOLERANCE * s.KERNEL_TOLERANCE), u.ConsoleUtils.assert(n.Vector3.isOrthogonal(t, r, s.KERNEL_ANGULAR_TOLERANCE)), n.Vector3.copy(this._center, e), n.Vector3.normalize(this._normal, t), n.Vector3.normalize(this._xAxis, r), this._radius = n.Vector3.length(r), this._computeYAxis();}, h.prototype._computeYAxis = function () {n.Vector3.cross(this._yAxis, this._normal, this._xAxis);}, h.prototype.clone = function () {var e = new h();return e.copy(this), e;}, h.prototype.getCenter = function () {return this._center;}, h.prototype.getNormal = function () {return this._normal;}, h.prototype.setNormal = function (e) {u.ConsoleUtils.assert(n.Vector3.squaredLength(e) > s.KERNEL_TOLERANCE * s.KERNEL_TOLERANCE), this._normal !== e && (n.Vector3.normalize(this._normal, e), n.Vector3.isOrthogonal(this._xAxis, this._normal) || (n.Vector3.computeOrthogonal(this._xAxis, this._normal), n.Vector3.normalize(this._xAxis, this._xAxis)), this._computeYAxis());}, h.prototype.getRadius = function () {return this._radius;}, h.prototype.setRadius = function (e) {u.ConsoleUtils.assert(e > s.KERNEL_TOLERANCE), this._radius = e;}, h.prototype.setCenter = function (e) {n.Vector3.copy(this._center, e);}, h.prototype.setOrigin = function (e) {u.ConsoleUtils.assert(n.Vector3.squaredLength(e) > s.KERNEL_TOLERANCE * s.KERNEL_TOLERANCE), u.ConsoleUtils.assert(n.Vector3.isOrthogonal(e, this._normal, s.KERNEL_ANGULAR_TOLERANCE)), n.Vector3.normalize(this._xAxis, e), this._computeYAxis();}, h.prototype.copy = function (e) {a.Curve.prototype.copy.call(this, e), n.Vector3.copy(this._xAxis, e._xAxis), n.Vector3.copy(this._yAxis, e._yAxis), this._radius = e._radius, n.Vector3.copy(this._center, e._center), n.Vector3.copy(this._normal, e._normal);}, h.prototype.getRangeUnlimited = function () {return [-Math.PI, Math.PI];}, h.prototype.isPeriodicUnlimited = function () {return !0;}, h.prototype.isClosedUnlimited = function () {return !0;}, h.prototype._computeRadiusVector = function () {return n.Vector3.scale(n.Vector3.createFloat64(), this._xAxis, this._radius);}, h.prototype.tessellate = function (e, t) {t = t || s.TESSELLATION.LINEAR_PRECISION;var r = { positions: [], offsets: [], tolerance: 0 };r.offsets.push(0);for (var n = e[0], o = 1; o < e.length; ++o) {var i = e[o],a = l.CurveTessellator.getCircularArcRenderPoints(this, [n, i], t, 1 === o, r.positions);r.offsets.push(r.positions.length - 1), n = i, r.tolerance = Math.max(r.tolerance, a);}return r;}, h.prototype.evaluatePosition = function (e) {var t = n.Vector3.createFloat64FromValues(0, 0, 0);return n.Vector3.scaleAndAdd(t, t, this._xAxis, Math.cos(e) * this._radius), n.Vector3.scaleAndAdd(t, t, this._yAxis, Math.sin(e) * this._radius), n.Vector3.add(t, t, this._center), t;}, h.prototype.evaluateDt = function (e) {var t = n.Vector3.createFloat64FromValues(0, 0, 0);return n.Vector3.scaleAndAdd(t, t, this._xAxis, -Math.sin(e) * this._radius), n.Vector3.scaleAndAdd(t, t, this._yAxis, Math.cos(e) * this._radius), t;}, h.prototype.evaluateDtt = function (e) {var t = n.Vector3.createFloat64FromValues(0, 0, 0);return n.Vector3.scaleAndAdd(t, t, this._xAxis, -Math.cos(e) * this._radius), n.Vector3.scaleAndAdd(t, t, this._yAxis, -Math.sin(e) * this._radius), t;}, h.prototype.tangentLength = function (e) {return this.getRadius();}, h.prototype.getArcLength = function (e) {return void 0 === e ? e = this.getRange() : 0 === e.length && (e = this.getRangeUnlimited()), this.getRadius() * (e[1] - e[0]);}, h.prototype.getParameterFromArcLength = function (e, t) {void 0 === t ? t = this.getRange() : 0 === t.length && (t = this.getRangeUnlimited());var r = t[0] + e / this.getRadius();return (0, c.clamp)(r, t[0], t[1]);}, h.prototype.getBoundingBox = function (e) {void 0 === e ? e = this.getRange() : 0 === e.length && (e = this.getRangeUnlimited());var t = (0, c.minMaxCosSinFunc)(this._xAxis[0] * this._radius, this._yAxis[0] * this._radius, this._center[0], e),r = (0, c.minMaxCosSinFunc)(this._xAxis[1] * this._radius, this._yAxis[1] * this._radius, this._center[1], e),n = (0, c.minMaxCosSinFunc)(this._xAxis[2] * this._radius, this._yAxis[2] * this._radius, this._center[2], e),i = new o.BoundingBox();return i.min[0] = t[0], i.max[0] = t[1], i.min[1] = r[0], i.max[1] = r[1], i.min[2] = n[0], i.max[2] = n[1], i;}, h.prototype.getTangentCone = function (e) {void 0 === e ? e = this.getRange() : 0 === e.length && (e = this.getRangeUnlimited());var t = .5 * (e[0] + e[1]),r = n.Vector3.createFloat64FromValues(0, 0, 0);n.Vector3.scaleAndAdd(r, r, this._xAxis, -Math.sin(t)), n.Vector3.scaleAndAdd(r, r, this._yAxis, Math.cos(t));var o = Math.min(Math.PI, .5 * (e[1] - e[0]));return new i.TangentCone(r, o);}, h.prototype.closestToRayParam = function (e, t, r) {var o = n.Vector3.createFloat64();n.Vector3.sub(o, this._center, e);var i = n.Vector3.dot(o, this._normal) / n.Vector3.dot(t, this._normal);if (isFinite(i)) {var s = n.Vector3.createFloat64();return n.Vector3.scaleAndAdd(s, e, t, i), this.closestToPointParam(s, r);}}, h.prototype.getRadiusAndRangeFromEndpoints = function (e, t, r) {var o = n.Vector3.createFloat64();n.Vector3.sub(o, e, this._center);var i = n.Vector3.createFloat64();n.Vector3.sub(i, t, this._center);var a,u = .5 * (n.Vector3.length(o) + n.Vector3.length(i)),l = n.Vector3.dot(o, this._xAxis),h = n.Vector3.dot(o, this._yAxis),d = (0, c.normalizeAngle)(Math.atan2(h, l));if (e === t || n.Vector3.squaredDistance(e, t) < s.KERNEL_TOLERANCE * s.KERNEL_TOLERANCE) a = d + c.PI2;else {var g = n.Vector3.dot(i, this._xAxis),p = n.Vector3.dot(i, this._yAxis);if ((a = (0, c.normalizeAngle)(Math.atan2(p, g))) < d && (a += c.PI2), r) {var f = a;a = d, d = f - c.PI2;}}return { radius: u, range: [d, a] };}, h.prototype.closestToPointParam = function (e, t) {void 0 === t ? t = this.getRange() : 0 === t.length && (t = this.getRangeUnlimited());var r = n.Vector3.createFloat64();n.Vector3.sub(r, e, this._center);var o,i = n.Vector3.dot(r, this._xAxis),a = n.Vector3.dot(r, this._yAxis);return o = i * i + a * a < s.KERNEL_TOLERANCE * s.KERNEL_TOLERANCE ? .5 * Math.PI : Math.atan2(a, i), o = (0, c.foldNearTo)(o, .5 * (t[0] + t[1]), 2 * Math.PI), (0, c.clamp)(o, t[0], t[1]);}, h.prototype.transform = function (e) {n.Vector3.transformMatrix44(this._center, this._center, e), n.Vector3.transformAsDirectionMatrix44(this._normal, this._normal, e), n.Vector3.scale(this._xAxis, this._xAxis, this._radius), n.Vector3.transformAsDirectionMatrix44(this._xAxis, this._xAxis, e), this._radius = n.Vector3.length(this._xAxis), n.Vector3.normalize(this._normal, this._normal), n.Vector3.normalize(this._xAxis, this._xAxis), this._computeYAxis();}, h.prototype.suggestSplittingParam = function (e) {}, h.prototype.toObject = function () {var e = this.evaluatePosition(0);return n.Vector3.sub(e, e, this.getCenter()), { center: this.vectorToObject(this._center), radius: this.vectorToObject(e), normal: this.vectorToObject(this._normal), range: this.rangeToObject(this.getRange(), this.isLimited()) };}, t.Circle = h;}, function (e, t, r) {\"use strict\";Object.defineProperty(t, \"__esModule\", { value: !0 }), t.Face = void 0;var n = r(1),o = r(9),i = r(0),s = r(8),a = function a(e) {o.BaseTopology.call(this), this._surface = e, this._reversed = !1, this._loops = [], this._shell = void 0;};(a.prototype = Object.create(o.BaseTopology.prototype)).getTopologyType = function () {return i.TOPOLOGY_TYPES.FACE;}, a.prototype.getSurfaceType = function () {return this._surface ? this._surface.getGeometryType() : void 0;}, a.prototype.clone = function () {var e = new a();return e._surface = this._surface ? this._surface.clone() : void 0, e._reversed = this._reversed, e.setLoops(this._loops), e._shell = this._shell, e._vertexUvData = void 0, e;}, a.prototype.getSurface = function () {return this._surface;}, a.prototype.setSurface = function (e) {this._surface = e;}, a.prototype.getShell = function () {return this._shell;}, a.prototype.setShell = function (e) {this._shell = e;}, a.prototype.getLoops = function () {return this._loops;}, a.prototype.setLoops = function (e) {this._loops = new Array(e.length);for (var t = 0; t < e.length; ++t) {this._loops[t] = e[t];}}, a.prototype.addLoop = function (e) {this._loops ? this._loops.push(e) : this._loops = [e], e.setFace(this);}, a.prototype.addLoops = function (e) {this._loops || (this._loops = []);for (var t = 0; t < e.length; ++t) {e[t].setFace(this);}this._loops = this._loops.concat(e);}, a.prototype.removeLoop = function (e) {var t = this._loops.indexOf(e);return t > -1 && (this._loops.splice(t, 1), e.getFace() === this && e.setFace(void 0), !0);}, a.prototype.isReversed = function () {return this._reversed;}, a.prototype.setReversed = function (e) {this._reversed = e;}, a.prototype.getVertices = function () {return Array.from(this.collectVertices());}, a.prototype.evaluatePosition = function (e, t) {return this._surface.evaluatePosition(e, t);}, a.prototype.evaluateNormal = function (e, t) {var r = this._surface.evaluateNormal(e, t);return !0 === this.isReversed() && n.Vector3.negate(r, r), r;}, a.prototype.getBody = function () {return this._shell ? this._shell.getBody() : void 0;}, a.prototype.collectFaces = function (e) {return (e = e || new Set()).add(this), e;}, a.prototype.collectEdges = function (e) {e = e || new Set();for (var t = 0; t < this._loops.length; ++t) {this._loops[t].collectEdges(e);}return e;}, a.prototype.collectVertices = function (e) {e = e || new Set();for (var t = 0; t < this._loops.length; ++t) {this._loops[t].collectVertices(e);}return e;}, a.prototype.getBoundingBox = function () {var e = this._surface.getRangeU(),t = this._surface.getRangeV();return isFinite(e[0]) && isFinite(e[1]) || (s.DebugUtils.warn(\"Face.getBoundingBox: Surface is unbounded in u.\"), e = [0, 1]), isFinite(t[0]) && isFinite(t[1]) || (s.DebugUtils.warn(\"Face.getBoundingBox: Surface is unbounded in v.\"), t = [0, 1]), this._surface.getBoundingBox(e, t);}, a.prototype.closestParam = function (e) {return this._surface.closestParam(e);}, a.prototype.isPlanarFace = function () {return this.getSurfaceType() === i.GEOMETRY_TYPES.PLANE;}, a.prototype.toObject = function () {return { loops: this.refsToStrings(this._loops), reversed: this._reversed, geometry: this.refToString(this._surface), attributes: this.refsToStrings(this._attributes) };}, a.prototype.addToModelObject = function (e) {this.addAllToModelObject(e, [this._loops, this._surface, this._attributes]);}, t.Face = a;}, function (e, t, r) {\"use strict\";Object.defineProperty(t, \"__esModule\", { value: !0 }), t.Vertex = void 0;var n = r(9),o = r(0),i = r(2),s = r(78),a = function a(e) {n.BaseTopology.call(this), this._point = e, this._precision = 0, this._edges = [];};(a.prototype = Object.create(n.BaseTopology.prototype)).getTopologyType = function () {return o.TOPOLOGY_TYPES.VERTEX;}, a.prototype.getPoint = function () {return this._point;}, a.prototype.setPoint = function (e) {this._point = e;}, a.prototype.getPrecision = function () {return this._precision;}, a.prototype.setPrecision = function (e) {i.ConsoleUtils.assert(e >= 0), this._precision = e;}, a.prototype.getEdges = function () {return this._edges;}, a.prototype.isAdjacentEdge = function (e) {return -1 !== this._edges.indexOf(e);}, a.prototype.getOtherEdge = function (e) {for (var t = 0; t < this._edges.length; t++) {var r = this._edges[t];if (r !== e) return r;}return null;}, a.prototype.getOtherEdges = function (e) {for (var t = [], r = 0; r < this._edges.length; r++) {var n = this._edges[r];n !== e && t.push(n);}return t;}, a.prototype.getAdjacentVertices = function () {for (var e = [], t = 0; t < this._edges.length; t++) {var r = this._edges[t].getOtherVertex(this);r !== this && e.indexOf(r) < 0 && e.push(r);}return e;}, a.prototype.getCommonEdges = function (e) {for (var t = [], r = 0; r < this._edges.length; r++) {var n = this._edges[r],o = n.getStartVertex(),i = n.getEndVertex();(o === this && i === e || i === this && o === e) && t.push(n);}return t;}, a.prototype.addEdge = function (e) {-1 === this._edges.indexOf(e) && this._edges.push(e);}, a.prototype.removeEdge = function (e) {var t = this._edges.indexOf(e);return t >= 0 && (this._edges.splice(t, 1), !0);}, a.prototype.getPosition = function () {return this._point.getPosition();}, a.prototype.getBody = function () {return this._edges.length > 0 ? this._edges[0].getBody() : void 0;}, a.prototype.collectFaces = function (e) {e = e || new Set();for (var t = 0; t < this._edges.length; ++t) {this._edges[t].collectFaces(e);}return e;}, a.prototype.collectEdges = function (e) {e = e || new Set();for (var t = 0; t < this._edges.length; ++t) {e.add(this._edges[t]);}return e;}, a.prototype.collectVertices = function (e) {return (e = e || new Set()).add(this), e;}, a.prototype.getBoundingBox = function () {return this._point.getBoundingBox();}, a.prototype.toString = function () {return String(this._point.getPosition());}, a.prototype.getOrderedFaces = function () {var e = [],t = (0, s.getOrderedFacesOnVertex)(this);for (var _r = 0; _r < t.length; _r++) {t[_r].faces.forEach(function (t) {e.push(t);});}return e;}, a.prototype.toObject = function () {return { geometry: this.refToString(this._point), precision: this.getPrecision(), attributes: this.refsToStrings(this._attributes) };}, a.prototype.addToModelObject = function (e) {this.addAllToModelObject(e, [this._point, this._attributes]);}, t.Vertex = a;}, function (e, t, r) {\"use strict\";Object.defineProperty(t, \"__esModule\", { value: !0 }), t.controlPointsFromHomogeneous = t.controlPointsToHomogeneous = t.getUniqueKnots = t.findKnotSpanAndMultiplicity = t.findKnotSpan = void 0;var n = r(0),o = r(2),i = function i(e, t) {var r = 0,n = t.length - 1;if (e <= t[r]) {for (; t[r] === t[r + 1] && r < n - 1;) {r += 1;}return r;}if (e >= t[n]) {for (; t[n] === t[n - 1] && n > r + 1;) {n -= 1;}return n - 1;}for (var o = Math.floor((r + n) / 2); e < t[o] || e >= t[o + 1];) {e < t[o] ? n = o : r = o, o = Math.floor((r + n) / 2);}return o;};t.findKnotSpan = i, t.findKnotSpanAndMultiplicity = function (e, t) {var r = n.PARAMETER_SPACE_TOLERANCE,o = i(e, t),s = 0,a = e,c = o;if (e < t[c] + r) for (a = t[c]; c >= 0 && Math.abs(t[c] - a) < r;) {--c, ++s;} else if (e > t[c + 1] - r) {for (a = t[++c]; c < t.length && Math.abs(t[c] - a) < r;) {++c, ++s;}a = c < t.length ? t[o = c - 1] : t[t.length - 1];}return { span: o, multiplicity: s, knot: a };}, t.getUniqueKnots = function (e) {for (var t = [e[0]], r = 1; r < e.length; ++r) {e[r] !== e[r - 1] && t.push(e[r]);}return t;}, t.controlPointsToHomogeneous = function (e, t) {o.ConsoleUtils.assert(e.length > 0 && e.length === 3 * t.length);for (var r = t.length, n = new Array(4 * r), i = 0; i < r; ++i) {var s = t[i];n[4 * i] = e[3 * i] * s, n[4 * i + 1] = e[3 * i + 1] * s, n[4 * i + 2] = e[3 * i + 2] * s, n[4 * i + 3] = s;}return n;}, t.controlPointsFromHomogeneous = function (e) {o.ConsoleUtils.assert(e.length > 0 && e.length % 4 == 0);for (var t = e.length / 4, r = new Array(3 * t), n = new Array(t), i = 0; i < t; ++i) {var s = e[4 * i + 3];r[3 * i] = e[4 * i] / s, r[3 * i + 1] = e[4 * i + 1] / s, r[3 * i + 2] = e[4 * i + 2] / s, n[i] = s;}return { P: r, w: n };};}, function (e, t, r) {\"use strict\";Object.defineProperty(t, \"__esModule\", { value: !0 }), t.Plane = void 0;var n = r(1),o = r(4),i = r(0),s = r(12),a = r(7),c = r(2),u = function u() {s.Surface.call(this), this._origin = n.Vector3.createFloat64(), this._normal = n.Vector3.createFloat64(), this._uAxis = n.Vector3.createFloat64(), this._vAxis = n.Vector3.createFloat64();};(u.prototype = Object.create(s.Surface.prototype)).getGeometryType = function () {return i.GEOMETRY_TYPES.PLANE;}, u.prototype.clone = function () {var e = new u();return e.copy(this), e;}, u.prototype.copy = function (e) {s.Surface.prototype.copy.call(this, e), n.Vector3.copy(this._origin, e._origin), n.Vector3.copy(this._normal, e._normal), n.Vector3.copy(this._uAxis, e._uAxis), n.Vector3.copy(this._vAxis, e._vAxis);}, u.prototype._computeVAxis = function () {n.Vector3.cross(this._vAxis, this._normal, this._uAxis);}, u.prototype.set = function (e, t, r) {n.Vector3.copy(this._origin, e), c.ConsoleUtils.assert(n.Vector3.squaredLength(t) > i.KERNEL_TOLERANCE * i.KERNEL_TOLERANCE), n.Vector3.normalize(this._normal, t), void 0 === r || n.Vector3.squaredLength(r) < i.KERNEL_TOLERANCE * i.KERNEL_TOLERANCE ? (n.Vector3.computeOrthogonal(this._uAxis, this._normal), n.Vector3.normalize(this._uAxis, this._uAxis)) : (c.ConsoleUtils.assert(n.Vector3.isOrthogonal(r, t, i.KERNEL_ANGULAR_TOLERANCE)), n.Vector3.copy(this._uAxis, r)), this._computeVAxis();}, u.prototype.getOrigin = function () {return this._origin;}, u.prototype.setOrigin = function (e) {n.Vector3.copy(this._origin, e);}, u.prototype.getNormal = function () {return this._normal;}, u.prototype.setNormal = function (e) {c.ConsoleUtils.assert(n.Vector3.squaredLength(e) > i.KERNEL_TOLERANCE * i.KERNEL_TOLERANCE), n.Vector3.normalize(this._normal, e), (n.Vector3.squaredLength(this._uAxis) <= i.KERNEL_TOLERANCE * i.KERNEL_TOLERANCE || !n.Vector3.isOrthogonal(this._uAxis, this._normal, i.KERNEL_ANGULAR_TOLERANCE)) && (n.Vector3.computeOrthogonal(this._uAxis, this._normal), n.Vector3.normalize(this._uAxis, this._uAxis)), this._computeVAxis();}, u.prototype.getUAxis = function () {return this._uAxis;}, u.prototype.setUAxis = function (e) {c.ConsoleUtils.assert(n.Vector3.squaredLength(e) > i.KERNEL_TOLERANCE * i.KERNEL_TOLERANCE), n.Vector3.copy(this._uAxis, e), this._computeVAxis();}, u.prototype.evaluatePosition = function (e, t) {var r = n.Vector3.clone(this._origin);return n.Vector3.scaleAndAdd(r, r, this._uAxis, e), n.Vector3.scaleAndAdd(r, r, this._vAxis, t), r;}, u.prototype.evaluateNormal = function (e, t) {return n.Vector3.clone(this._normal);}, u.prototype.evaluateDu = function (e, t) {return n.Vector3.clone(this._uAxis);}, u.prototype.evaluateDv = function (e, t) {return n.Vector3.clone(this._vAxis);}, u.prototype.closestParam = function (e) {var t = n.Vector3.createFloat64();return n.Vector3.sub(t, e, this._origin), { u: n.Vector3.dot(t, this._uAxis) / n.Vector3.squaredLength(this._uAxis), v: n.Vector3.dot(t, this._vAxis) / n.Vector3.squaredLength(this._vAxis) };}, u.prototype.vParamLine = function (e) {var t = new a.Line();return t.set(this.evaluatePosition(e, 0), this._vAxis), t;}, u.prototype.uParamLine = function (e) {var t = new a.Line();return t.set(this.evaluatePosition(0, e), this._uAxis), t;}, u.prototype.getBoundingBox = function (e, t) {var r = new o.BoundingBox();return e && t ? (r.includePoint(this.evaluatePosition(e[0], t[0])), r.includePoint(this.evaluatePosition(e[0], t[1])), r.includePoint(this.evaluatePosition(e[1], t[1])), r.includePoint(this.evaluatePosition(e[1], t[0]))) : (r.includePoint([-1 / 0, -1 / 0, -1 / 0]), r.includePoint([1 / 0, 1 / 0, 1 / 0])), r;}, u.prototype.transform = function (e) {n.Vector3.transformMatrix44(this._origin, this._origin, e), n.Vector3.transformAsDirectionMatrix44(this._uAxis, this._uAxis, e), n.Vector3.transformAsDirectionMatrix44(this._vAxis, this._vAxis, e), n.Vector3.transformAsDirectionMatrix44(this._normal, this._normal, e), n.Vector3.normalize(this._normal, this._normal);}, u.prototype.getRangeUnlimitedU = function () {return [-1 / 0, 1 / 0];}, u.prototype.getRangeUnlimitedV = function () {return [-1 / 0, 1 / 0];}, u.prototype.isPeriodicUnlimitedU = function () {return !1;}, u.prototype.isPeriodicUnlimitedV = function () {return !1;}, u.prototype.isClosedUnlimitedU = function () {return !1;}, u.prototype.isClosedUnlimitedV = function () {return !1;}, u.prototype.toObject = function () {return { origin: this.vectorToObject(this._origin), normal: this.vectorToObject(this._normal), uAxis: this.vectorToObject(this._uAxis), uRange: this.rangeToObject(this.getRangeU(), this.isLimitedU()), vRange: this.rangeToObject(this.getRangeV(), this.isLimitedV()) };}, t.Plane = u;}, function (e, t, r) {\"use strict\";Object.defineProperty(t, \"__esModule\", { value: !0 }), t.mergeConnectedFaces = t.mergeFaces = t.findConnectedFaces = t.findConnectedEdges = t.mergeCoincidentVertices = t.transformTopology = t.reverseFace = void 0;var n = r(1),o = r(0),i = r(13),s = r(2),a = function a(e) {e.setReversed(!e.isReversed());},c = function c(e, t) {var r = !1,n = !0,o = new Set();t && (void 0 !== t.inputFacesOnly && (r = t.inputFacesOnly), void 0 !== t.allowVertexConnections && (n = t.allowVertexConnections), void 0 !== t.barrierEdges && (o = new Set(t.barrierEdges)));var i = new Set(),s = new Set(e);function a(t) {s.delete(t), i.add(t), i.forEach(function (t) {var a = new Set();n ? t.collectVertices().forEach(function (e) {e.collectEdges(a);}) : (t.collectEdges(a), o.forEach(function (e) {a.delete(e);})), a.forEach(function (t) {for (var n = t.getCoedge(), o = n; o;) {if (o.getLoop()) {var a = o.getLoop().getFace();i.has(a) || r && !(e.indexOf(a) >= 0) || (i.add(a), s.delete(a));}(o = o.getPartner()) === n && (o = void 0);}});});}for (var c = []; s.size > 0;) {i.clear(), a(s.values().next().value), c.push(Array.from(i));}return c;},u = function u(e) {if (1 !== e.length) {var t = new Set();e.forEach(function (e) {e.collectEdges(t);});var r = new Set(),n = [];t.forEach(function (t) {var o = t.getCoedges(),i = o.map(function (t) {return e.indexOf(t.getFace()) >= 0;});if (2 === o.length && i[0] && i[1]) n.push(t);else for (var s = 0; s < o.length; s++) {i[s] && (r.add(o[s]), o[s].resetUVCurve());}});for (var o = []; r.size > 0;) {for (var a = [], c = r.values().next().value; c;) {a.push(c), r.delete(c);var u = c,l = void 0,h = 2 * c.getEndVertex().getEdges().length;do {if (u = u.getNext(), r.has(u)) {l = u;break;}u = u.getPartner();} while (u && u !== c && --h > 0);c = l;}s.ConsoleUtils.assert(a[0].getStartVertex() === a[a.length - 1].getEndVertex()), o.push(a);}n.forEach(function (e) {e.setStartVertex(null), e.setEndVertex(null);});var d = e[0];d.setLoops([]), o.forEach(function (e) {var t = new i.Loop();t.addCoedges(e), d.addLoop(t);});for (var g = 1; g < e.length; g++) {e[g].getShell() && e[g].getShell().removeFace(e[g]);}var p = d.getSurface();p.unlimitRangeU(), p.unlimitRangeV();}};t.reverseFace = function (e) {e.setReversed(!e.isReversed());for (var t = e.getLoops(), r = 0; r < t.length; ++r) {for (var n = t[r].getCoedges(), o = 0; o < n.length; ++o) {a(n[o]);}n.reverse();}}, t.transformTopology = function (e, t) {Array.isArray(e) || (e = [e]);for (var r = new Set(), n = new Set(), i = new Set(), s = 0; s < e.length; ++s) {var a = e[s],c = a.getTopologyType();a.collectVertices(r), c !== o.TOPOLOGY_TYPES.VERTEX && a.collectEdges(n), c !== o.TOPOLOGY_TYPES.VERTEX && c !== o.TOPOLOGY_TYPES.EDGE && c !== o.TOPOLOGY_TYPES.COEDGE && c !== o.TOPOLOGY_TYPES.LOOP && a.collectFaces(i);}r.forEach(function (e) {e.getPoint() && e.getPoint().transform(t);}), n.forEach(function (e) {e.getCurve() && e.getCurve().transform(t);}), i.forEach(function (e) {e.getSurface() && e.getSurface().transform(t);});}, t.mergeCoincidentVertices = function (e) {for (var t = o.KERNEL_TOLERANCE * o.KERNEL_TOLERANCE, r = [], i = 0; i < e.length; ++i) {var s,a = e[i],c = a.getStartVertex(),u = a.getEndVertex();for (s = 0; s < r.length && !(n.Vector3.squaredDistance(c.getPosition(), r[s].getPosition()) < t); ++s) {;}if (s === r.length ? r.push(c) : (r[s].setPrecision(Math.max(r[s].getPrecision(), c.getPrecision())), a.setStartVertex(r[s])), c !== u) for (s = 0; s < r.length && !(n.Vector3.squaredDistance(u.getPosition(), r[s].getPosition()) < t); ++s) {;}s === r.length ? r.push(u) : (r[s].setPrecision(Math.max(r[s].getPrecision(), u.getPrecision())), a.setEndVertex(r[s]));}}, t.findConnectedEdges = function (e, t) {for (var r = t || !1, n = [], o = new Set(), i = 0; i < e.length; ++i) {var s = e[i];if (!o.has(s)) {for (var a = [], c = [s], u = 0; u < c.length; ++u) {var l = c[u];o.has(l) || r && !(e.indexOf(l) >= 0) || (o.add(l), a.push(l), c = c.concat(l.getStartVertex().getEdges(), l.getEndVertex().getEdges()));}n.push(a);}}return n;}, t.findConnectedFaces = c, t.mergeFaces = u, t.mergeConnectedFaces = function (e) {var t = [];return c(e, { inputFacesOnly: !0, allowVertexConnections: !1 }).forEach(function (e) {u(e), t.push(e[0]);}), t;};}, function (e, t, r) {\"use strict\";Object.defineProperty(t, \"__esModule\", { value: !0 }), t.Edge = void 0;var n = r(1),o = r(9),i = r(0),s = r(2),a = function a(e) {o.BaseTopology.call(this), this._curve = e, this._reversed = !1, this._vertices = [null, null], this._range = [0, 0], this._precision = 0, this._coedge = void 0, this._wire = void 0, this._tessellationPoints = [];};(a.prototype = Object.create(o.BaseTopology.prototype)).getTopologyType = function () {return i.TOPOLOGY_TYPES.EDGE;}, a.prototype.getCurveType = function () {return this._curve ? this._curve.getGeometryType() : void 0;}, a.prototype.clone = function () {var e = new a();return e._curve = this._curve ? this._curve.clone() : void 0, e._reversed = this._reversed, e._vertices[0] = this._vertices[0], e._vertices[1] = this._vertices[1], e._range[0] = this._range[0], e._range[1] = this._range[1], e._precision = this._precision, e._coedge = this._coedge, e._wire = this._wire, e._tessellationPoints = [], e;}, a.prototype.getCurve = function () {return this._curve;}, a.prototype.setCurve = function (e) {this._curve = e;}, a.prototype.getArcLength = function () {var e = this.getRange();return this.isReversed() && (e = [-e[1], -e[0]]), this._curve.getArcLength(e);}, a.prototype.getVertices = function () {return this._vertices;}, a.prototype.getVertex = function (e) {return s.ConsoleUtils.assert(0 === e || 1 === e), this._vertices[e];}, a.prototype.getStartVertex = function () {return this._vertices[0];}, a.prototype.getEndVertex = function () {return this._vertices[1];}, a.prototype.setCoedge = function (e) {this._coedge = e;}, a.prototype.getCoedge = function () {return this._coedge;}, a.prototype.getCoedges = function () {for (var e = [], t = this._coedge; t;) {e.push(t), (t = t.getPartner()) === this._coedge && (t = void 0);}return e;}, a.prototype.setWire = function (e) {this._wire = e;}, a.prototype.getWire = function () {return this._wire;}, a.prototype.getRange = function () {return this._range;}, a.prototype.setRange = function (e) {s.ConsoleUtils.assert(2 === e.length), this._range[0] = e[0], this._range[1] = e[1];}, a.prototype.t0 = function () {return this._range[0];}, a.prototype.sett0 = function (e) {this._range[0] = e;}, a.prototype.t1 = function () {return this._range[1];}, a.prototype.sett1 = function (e) {this._range[1] = e;}, a.prototype.isClosed = function () {return this._curve && this._vertices[0] && this._vertices[0] === this._vertices[1];}, a.prototype.getOtherVertex = function (e) {return s.ConsoleUtils.assert(this._vertices[0] === e || this._vertices[1] === e), this._vertices[0] === e ? this._vertices[1] : this._vertices[0];}, a.prototype.getCommonVertex = function (e) {var t = this.getStartVertex(),r = this.getEndVertex(),n = e.getStartVertex(),o = e.getEndVertex();return t === n || t === o ? t : r === n || r === o ? r : null;}, a.prototype.setVertex = function (e, t) {s.ConsoleUtils.assert(0 === e || 1 === e), t !== this._vertices[e] && (this._vertices[e] && this._vertices[0] !== this._vertices[1] && this._vertices[e].removeEdge(this), this._vertices[e] = t, t && this._vertices[e].addEdge(this));}, a.prototype.setStartVertex = function (e) {this.setVertex(0, e);}, a.prototype.setEndVertex = function (e) {this.setVertex(1, e);}, a.prototype.getCoedgeForFace = function (e) {for (var t = this._coedge; t;) {if (t.getFace() === e) return t;if ((t = t.getPartner()) === this._coedge) break;}}, a.prototype.getOtherFace = function (e) {var t = this.getCoedgeForFace(e);s.ConsoleUtils.assert(t);var r = t.getPartner();if (r && r !== t) return r.getFace();}, a.prototype.isReversed = function () {return this._reversed;}, a.prototype.setReversed = function (e) {this._reversed = e;}, a.prototype.getPrecision = function () {return this._precision;}, a.prototype.setPrecision = function (e) {s.ConsoleUtils.assert(e >= 0), this._precision = e;}, a.prototype.evaluatePosition = function (e) {return this.isReversed() && (e = -e), this._curve.evaluatePosition(e);}, a.prototype.evaluateDt = function (e) {this.isReversed() && (e = -e);var t = this._curve.evaluateDt(e);return this.isReversed() && n.Vector3.negate(t, t), t;}, a.prototype.evaluateCurvature = function (e, t) {return this.isReversed() && (e = -e), this._curve.evaluateCurvature(e, t);}, a.prototype.closestToPointParam = function (e, t) {if (this._curve) {var r = t || this.getRange();this.isReversed() && (r = [-r[1], -r[0]]);var n = this._curve.closestToPointParam(e, r);return this.isReversed() ? -n : n;}}, a.prototype.includesPoint = function (e) {var t = Math.max(this.getPrecision(), i.KERNEL_TOLERANCE),r = this.closestToPointParam(e),o = this.evaluatePosition(r);return n.Vector3.squaredDistance(o, e) < t * t;}, a.prototype.distanceToPoint = function (e) {var t = this.closestToPointParam(e),r = this.evaluatePosition(t);return n.Vector3.distance(r, e);}, a.prototype.tessellate = function (e, t) {var r, o;if (!1 === this.isReversed()) r = e || [this._range[0], this._range[1]];else if (e) {r = new Array(e.length);for (var i = 0; i < e.length; ++i) {r[i] = -e[e.length - 1 - i];}} else r = [-this._range[1], -this._range[0]];var s,a = this._curve.tessellate(r, t);if (this._tessellationPoints.length !== a.positions.length) for (this._tessellationPoints = new Array(a.positions.length), i = 0; i < a.positions.length; i++) {this._tessellationPoints[i] = n.Vector3.createFloat64();}if (!1 === this.isReversed()) for (s = a.offsets, o = 0; o < a.positions.length; ++o) {n.Vector3.copy(this._tessellationPoints[o], a.positions[o]);} else {for (o = 0; o < a.positions.length; ++o) {n.Vector3.copy(this._tessellationPoints[o], a.positions[a.positions.length - 1 - o]);}for (s = new Array(a.offsets.length), o = 0; o < a.offsets.length; ++o) {s[o] = a.positions.length - 1 - a.offsets[a.offsets.length - 1 - o];}}return { positions: this._tessellationPoints, offsets: s, tolerance: a.tolerance };}, a.prototype.getBody = function () {return s.ConsoleUtils.assert(void 0 === this._coedge || void 0 === this._wire), this._coedge ? this._coedge.getBody() : this._wire ? this._wire.getBody() : void 0;}, a.prototype.collectFaces = function (e) {e = e || new Set();for (var t = this._coedge; t;) {t.collectFaces(e), (t = t.getPartner()) === this._coedge && (t = void 0);}return e;}, a.prototype.collectEdges = function (e) {return (e = e || new Set()).add(this), e;}, a.prototype.collectVertices = function (e) {e = e || new Set();for (var t = 0; t < this._vertices.length; ++t) {this._vertices[t] && e.add(this._vertices[t]);}return e;}, a.prototype.getBoundingBox = function () {var e = this.getRange();return !0 === this.isReversed() && (e = [-e[1], -e[0]]), this._curve.getBoundingBox(e);}, a.prototype.closestToRayParam = function (e, t, r) {var n = this.getRange();!0 === this.isReversed() && (n = [-n[1], -n[0]]);var o = this._curve.closestToRayParam(e, t, n, r);return !0 === this.isReversed() ? -o : o;}, a.prototype.toString = function () {return i.GEOMETRY_TYPES.toString(this.getCurveType()) + \" \" + String(this.getStartVertex()) + \" -> \" + String(this.getEndVertex());}, a.prototype.getLoops = function () {var e = this.getCoedges(),t = new Set();for (var _r2 = 0; _r2 < e.length; _r2++) {t.add(e[_r2].getLoop());}return Array.from(t);}, a.prototype.toObject = function () {return { vertex0: this.refToString(this._vertices[0]), vertex1: this.refToString(this._vertices[1]), precision: this._precision, range: this.rangeToObject(this._range, !0), reversed: this._reversed, geometry: this.refToString(this._curve), attributes: this.refsToStrings(this._attributes) };}, a.prototype.addToModelObject = function (e) {this.addAllToModelObject(e, [this._vertices[0], this._vertices[1], this._curve, this._attributes]);}, t.Edge = a;}, function (e, t, r) {\"use strict\";e.exports = i, i.className = \"ReflectionObject\";var n,o = r(5);function i(e, t) {if (!o.isString(e)) throw TypeError(\"name must be a string\");if (t && !o.isObject(t)) throw TypeError(\"options must be an object\");this.options = t, this.name = e, this.parent = null, this.resolved = !1, this.comment = null, this.filename = null;}Object.defineProperties(i.prototype, { root: { get: function get() {for (var e = this; null !== e.parent;) {e = e.parent;}return e;} }, fullName: { get: function get() {for (var e = [this.name], t = this.parent; t;) {e.unshift(t.name), t = t.parent;}return e.join(\".\");} } }), i.prototype.toJSON = function () {throw Error();}, i.prototype.onAdd = function (e) {this.parent && this.parent !== e && this.parent.remove(this), this.parent = e, this.resolved = !1;var t = e.root;t instanceof n && t._handleAdd(this);}, i.prototype.onRemove = function (e) {var t = e.root;t instanceof n && t._handleRemove(this), this.parent = null, this.resolved = !1;}, i.prototype.resolve = function () {return this.resolved || this.root instanceof n && (this.resolved = !0), this;}, i.prototype.getOption = function (e) {if (this.options) return this.options[e];}, i.prototype.setOption = function (e, t, r) {return r && this.options && void 0 !== this.options[e] || ((this.options || (this.options = {}))[e] = t), this;}, i.prototype.setOptions = function (e, t) {if (e) for (var r = Object.keys(e), n = 0; n < r.length; ++n) {this.setOption(r[n], e[r[n]], t);}return this;}, i.prototype.toString = function () {var e = this.constructor.className,t = this.fullName;return t.length ? e + \" \" + t : e;}, i._configure = function (e) {n = e;};}, function (e, t, r) {\"use strict\";e.exports = u;var n = r(21);((u.prototype = Object.create(n.prototype)).constructor = u).className = \"Field\";var o,i = r(11),s = r(31),a = r(5),c = /^required|optional|repeated$/;function u(e, t, r, o, i, u, l) {if (a.isObject(o) ? (l = i, u = o, o = i = void 0) : a.isObject(i) && (l = u, u = i, i = void 0), n.call(this, e, u), !a.isInteger(t) || t < 0) throw TypeError(\"id must be a non-negative integer\");if (!a.isString(r)) throw TypeError(\"type must be a string\");if (void 0 !== o && !c.test(o = o.toString().toLowerCase())) throw TypeError(\"rule must be a string rule\");if (void 0 !== i && !a.isString(i)) throw TypeError(\"extend must be a string\");this.rule = o && \"optional\" !== o ? o : void 0, this.type = r, this.id = t, this.extend = i || void 0, this.required = \"required\" === o, this.optional = !this.required, this.repeated = \"repeated\" === o, this.map = !1, this.message = null, this.partOf = null, this.typeDefault = null, this.defaultValue = null, this.long = !!a.Long && void 0 !== s.long[r], this.bytes = \"bytes\" === r, this.resolvedType = null, this.extensionField = null, this.declaringField = null, this._packed = null, this.comment = l;}u.fromJSON = function (e, t) {return new u(e, t.id, t.type, t.rule, t.extend, t.options, t.comment);}, Object.defineProperty(u.prototype, \"packed\", { get: function get() {return null === this._packed && (this._packed = !1 !== this.getOption(\"packed\")), this._packed;} }), u.prototype.setOption = function (e, t, r) {return \"packed\" === e && (this._packed = null), n.prototype.setOption.call(this, e, t, r);}, u.prototype.toJSON = function (e) {var t = !!e && Boolean(e.keepComments);return a.toObject([\"rule\", \"optional\" !== this.rule && this.rule || void 0, \"type\", this.type, \"id\", this.id, \"extend\", this.extend, \"options\", this.options, \"comment\", t ? this.comment : void 0]);}, u.prototype.resolve = function () {if (this.resolved) return this;if (void 0 === (this.typeDefault = s.defaults[this.type]) && (this.resolvedType = (this.declaringField ? this.declaringField.parent : this.parent).lookupTypeOrEnum(this.type), this.resolvedType instanceof o ? this.typeDefault = null : this.typeDefault = this.resolvedType.values[Object.keys(this.resolvedType.values)[0]]), this.options && null != this.options.default && (this.typeDefault = this.options.default, this.resolvedType instanceof i && \"string\" == typeof this.typeDefault && (this.typeDefault = this.resolvedType.values[this.typeDefault])), this.options && (!0 !== this.options.packed && (void 0 === this.options.packed || !this.resolvedType || this.resolvedType instanceof i) || delete this.options.packed, Object.keys(this.options).length || (this.options = void 0)), this.long) this.typeDefault = a.Long.fromNumber(this.typeDefault, \"u\" === this.type.charAt(0)), Object.freeze && Object.freeze(this.typeDefault);else if (this.bytes && \"string\" == typeof this.typeDefault) {var e;a.base64.test(this.typeDefault) ? a.base64.decode(this.typeDefault, e = a.newBuffer(a.base64.length(this.typeDefault)), 0) : a.utf8.write(this.typeDefault, e = a.newBuffer(a.utf8.length(this.typeDefault)), 0), this.typeDefault = e;}return this.map ? this.defaultValue = a.emptyObject : this.repeated ? this.defaultValue = a.emptyArray : this.defaultValue = this.typeDefault, this.parent instanceof o && (this.parent.ctor.prototype[this.name] = this.defaultValue), n.prototype.resolve.call(this);}, u.d = function (e, t, r, n) {return \"function\" == typeof t ? t = a.decorateType(t).name : t && \"object\" == _typeof(t) && (t = a.decorateEnum(t).name), function (o, i) {a.decorateType(o.constructor).add(new u(i, e, t, r, { default: n }));};}, u._configure = function (e) {o = e;};}, function (e, t, r) {\"use strict\";Object.defineProperty(t, \"__esModule\", { value: !0 }), t.Ellipse = void 0;var n = r(1),o = r(4),i = r(34),s = r(0),a = r(32),c = r(3),u = r(35),l = r(2),h = r(50),d = function d() {a.Curve.call(this), this._center = n.Vector3.createFloat64FromValues(0, 0, 0), this._normal = n.Vector3.createFloat64FromValues(0, 0, 1), this._xAxis = n.Vector3.createFloat64FromValues(1, 0, 0), this._yAxis = n.Vector3.createFloat64FromValues(0, 1, 0), this._majorRadius = 0, this._minorRadius = 0, this._tessellationCache = new h.TessellationCache();};(d.prototype = Object.create(a.Curve.prototype)).getGeometryType = function () {return s.GEOMETRY_TYPES.ELLIPSE;}, d.prototype.set = function (e, t, r, o) {l.ConsoleUtils.assert(n.Vector3.squaredLength(t) > s.KERNEL_TOLERANCE * s.KERNEL_TOLERANCE), l.ConsoleUtils.assert(n.Vector3.squaredLength(r) > s.KERNEL_TOLERANCE * s.KERNEL_TOLERANCE), l.ConsoleUtils.assert(n.Vector3.isOrthogonal(t, r, s.KERNEL_ANGULAR_TOLERANCE)), l.ConsoleUtils.assert(o > n.FLOAT64_TOLERANCE && o <= 1, \"Invalid radius ratio\"), n.Vector3.copy(this._center, e), n.Vector3.normalize(this._normal, t), n.Vector3.normalize(this._xAxis, r), this._majorRadius = n.Vector3.length(r), this._minorRadius = this._majorRadius * o, this._computeYAxis(), this._dirtyTessellation();}, d.prototype._computeYAxis = function () {n.Vector3.cross(this._yAxis, this._normal, this._xAxis);}, d.prototype.getCenter = function () {return this._center;}, d.prototype.getNormal = function () {return this._normal;}, d.prototype.setCenter = function (e) {n.Vector3.copy(this._center, e), this._dirtyTessellation();}, d.prototype.setNormal = function (e) {l.ConsoleUtils.assert(n.Vector3.squaredLength(e) > s.KERNEL_TOLERANCE * s.KERNEL_TOLERANCE), this._normal !== e && (n.Vector3.normalize(this._normal, e), n.Vector3.isOrthogonal(this._xAxis, this._normal) || (n.Vector3.computeOrthogonal(this._xAxis, this._normal), n.Vector3.normalize(this._xAxis, this._xAxis)), this._computeYAxis(), this._dirtyTessellation());}, d.prototype.setMajorAxis = function (e) {l.ConsoleUtils.assert(n.Vector3.squaredLength(e) > s.KERNEL_TOLERANCE * s.KERNEL_TOLERANCE), l.ConsoleUtils.assert(n.Vector3.isOrthogonal(e, this._normal, s.KERNEL_ANGULAR_TOLERANCE)), n.Vector3.normalize(this._xAxis, e), this._computeYAxis(), this._dirtyTessellation();}, d.prototype.getMajorAxis = function () {return this._xAxis;}, d.prototype.getMinorAxis = function () {return this._yAxis;}, d.prototype.clone = function () {var e = new d();return e.copy(this), e;}, d.prototype.copy = function (e) {a.Curve.prototype.copy.call(this, e), n.Vector3.copy(this._xAxis, e._xAxis), n.Vector3.copy(this._yAxis, e._yAxis), this._majorRadius = e._majorRadius, this._minorRadius = e._minorRadius, n.Vector3.copy(this._center, e._center), n.Vector3.copy(this._normal, e._normal);}, d.prototype.getMajorRadius = function () {return this._majorRadius;}, d.prototype.getMinorRadius = function () {return this._minorRadius;}, d.prototype.setMajorRadius = function (e) {l.ConsoleUtils.assert(e > s.KERNEL_TOLERANCE), this._majorRadius = e, this._dirtyTessellation();}, d.prototype.setMinorRadius = function (e) {l.ConsoleUtils.assert(e > s.KERNEL_TOLERANCE), this._minorRadius = e, this._dirtyTessellation();}, d.prototype.getRangeUnlimited = function () {return [-Math.PI, Math.PI];}, d.prototype.isPeriodicUnlimited = function () {return !0;}, d.prototype.isClosedUnlimited = function () {return !0;}, d.prototype._dirtyTessellation = function () {this._tessellationCache.setDirty(!0);}, d.prototype._evaluateArcLengthIntegrand = function (e) {var t = this._majorRadius * Math.sin(e),r = this._minorRadius * Math.cos(e);return Math.sqrt(t * t + r * r);}, d.prototype.getArcLength = function (e) {void 0 === e ? e = this.getRange() : 0 === e.length && (e = this.getRangeUnlimited());for (var t = e[0], r = 0; t < e[1] + s.PARAMETER_SPACE_TOLERANCE;) {for (var n = t, o = [this._evaluateArcLengthIntegrand(t)]; o.length < 5 && t < e[1] + s.PARAMETER_SPACE_TOLERANCE;) {t += .01, o.push(this._evaluateArcLengthIntegrand(t));}switch (n = t - n, o.length) {case 1:break;case 2:r += (o[0] + o[1]) * n / 2;break;case 3:r += (o[0] + 4 * o[1] + o[2]) * n / 6;break;case 4:r += (o[0] + 3 * o[1] + 3 * o[2] + o[3]) * n / 8;break;default:r += (7 * o[0] + 32 * o[1] + 12 * o[2] + 32 * o[3] + 7 * o[4]) * n / 90;}(n = t - e[1]) > s.PARAMETER_SPACE_TOLERANCE && (r -= this._evaluateArcLengthIntegrand(e[1]) * n);}return r;}, d.prototype.getParameterFromArcLength = function (e, t) {return void 0 === t ? t = this.getRange() : 0 === t.length && (t = this.getRangeUnlimited()), (0, u.invertIntegral1D)(this._evaluateArcLengthIntegrand.bind(this), e, t);}, d.prototype.evaluatePosition = function (e) {var t = n.Vector3.createFloat64FromValues(0, 0, 0);return n.Vector3.scaleAndAdd(t, t, this._xAxis, Math.cos(e) * this._majorRadius), n.Vector3.scaleAndAdd(t, t, this._yAxis, Math.sin(e) * this._minorRadius), n.Vector3.add(t, t, this._center), t;}, d.prototype.evaluateDt = function (e) {var t = n.Vector3.createFloat64FromValues(0, 0, 0);return n.Vector3.scaleAndAdd(t, t, this._xAxis, -Math.sin(e) * this._majorRadius), n.Vector3.scaleAndAdd(t, t, this._yAxis, Math.cos(e) * this._minorRadius), t;}, d.prototype.evaluateDtt = function (e) {var t = n.Vector3.createFloat64FromValues(0, 0, 0);return n.Vector3.scaleAndAdd(t, t, this._xAxis, -Math.cos(e) * this._majorRadius), n.Vector3.scaleAndAdd(t, t, this._yAxis, -Math.sin(e) * this._minorRadius), t;}, d.prototype._getFullTessellation = function (e) {var t = [-Math.PI, -Math.PI / 2, 0, Math.PI / 2, Math.PI],r = h.CurveTessellator.getAdaptiveRenderPoints(this, e, [-Math.PI, Math.PI], t);return r.didRetessellate = !0, r;}, d.prototype.tessellate = function (e, t) {return t = t || s.TESSELLATION.LINEAR_PRECISION, this._tessellationCache.getTessellation(e, this, t, this._getFullTessellation.bind(this));}, d.prototype.getBoundingBox = function (e) {void 0 === e ? e = this.getRange() : 0 === e.length && (e = this.getRangeUnlimited());var t = (0, c.minMaxCosSinFunc)(this._xAxis[0] * this._majorRadius, this._yAxis[0] * this._minorRadius, this._center[0], e),r = (0, c.minMaxCosSinFunc)(this._xAxis[1] * this._majorRadius, this._yAxis[1] * this._minorRadius, this._center[1], e),n = (0, c.minMaxCosSinFunc)(this._xAxis[2] * this._majorRadius, this._yAxis[2] * this._minorRadius, this._center[2], e),i = new o.BoundingBox();return i.min[0] = t[0], i.max[0] = t[1], i.min[1] = r[0], i.max[1] = r[1], i.min[2] = n[0], i.max[2] = n[1], i;}, d.prototype.getTangentCone = function (e) {void 0 === e ? e = this.getRange() : 0 === e.length && (e = this.getRangeUnlimited());var t = this.evaluateDt(e[0]);n.Vector3.normalize(t, t);var r = this.evaluateDt(e[1]);n.Vector3.normalize(r, r);var o = n.Vector3.createFloat64(),a = n.Vector3.dot(t, r),u = n.Vector3.dot(n.Vector3.cross(o, t, r), this._normal),l = Math.atan2(u, a);l < 0 ? l += c.PI2 : e[1] - e[0] > c.PI2 - s.PARAMETER_SPACE_TOLERANCE && (l = c.PI2), l *= .5, a = Math.cos(l), u = Math.sin(l);var h = n.Vector3.clone(t);return n.Vector3.scale(h, h, a), n.Vector3.cross(o, this._normal, t), n.Vector3.scaleAndAdd(h, h, o, u), new i.TangentCone(h, l);}, d.prototype.transform = function (e) {n.Vector3.transformMatrix44(this._center, this._center, e), n.Vector3.transformAsDirectionMatrix44(this._normal, this._normal, e), n.Vector3.scale(this._xAxis, this._xAxis, this._majorRadius), n.Vector3.scale(this._yAxis, this._yAxis, this._minorRadius), n.Vector3.transformAsDirectionMatrix44(this._xAxis, this._xAxis, e), n.Vector3.transformAsDirectionMatrix44(this._yAxis, this._yAxis, e), this._majorRadius = n.Vector3.length(this._xAxis), this._minorRadius = n.Vector3.length(this._yAxis), n.Vector3.normalize(this._normal, this._normal), n.Vector3.normalize(this._xAxis, this._xAxis), this._computeYAxis(), this._dirtyTessellation();}, d.prototype.closestToRayParam = function (e, t, r) {var o = n.Vector3.createFloat64();n.Vector3.sub(o, this._center, e);var i = n.Vector3.dot(o, this._normal) / n.Vector3.dot(t, this._normal);if (isFinite(i)) {var s = n.Vector3.createFloat64();return n.Vector3.scaleAndAdd(s, e, t, i), this.closestToPointParam(s, r);}}, d.prototype.isCircular = function () {return Math.abs(this._majorRadius - this._minorRadius) < s.KERNEL_TOLERANCE;}, d.prototype.closestToPointParam = function (e, t) {void 0 === t ? t = this.getRange() : 0 === t.length && (t = this.getRangeUnlimited());var r = n.Vector3.createFloat64();n.Vector3.sub(r, e, this._center);var o = n.Vector3.dot(r, this._xAxis),i = n.Vector3.dot(r, this._yAxis);if (o * o + i * i < s.KERNEL_TOLERANCE * s.KERNEL_TOLERANCE) {var a = .5 * Math.PI;if (((a = (0, c.adjustParameterToPeriodicRange)(a, t, c.PI2)) < t[0] || a > t[1]) && (a = (0, c.adjustParameterToPeriodicRange)(.5 * -Math.PI, t, c.PI2)), a < t[0] || a > t[1]) {var l = this.evaluatePosition(t[0]),h = this.evaluatePosition(t[1]);a = n.Vector3.squaredDistance(this._center, l) < n.Vector3.squaredDistance(this._center, h) ? t[0] : t[1];}return a;}var d = this._majorRadius,g = this._minorRadius,p = Math.atan2(d * i, g * o),f = this.evaluatePosition(p);n.Vector3.sub(f, f, this._center), o * o + i * i < n.Vector3.squaredLength(f) && (p = (i < s.KERNEL_TOLERANCE ? -1 : 1) * Math.acos(o / d));var v,_ = n.FLOAT64_TOLERANCE,y = function y(t) {var r = this.evaluatePosition(t),n = this.evaluateDt(t),o = this.evaluateDtt(t),i = [r[0] - e[0], r[1] - e[1], r[2] - e[2]];return { val: 2 * (i[0] * n[0] + i[1] * n[1] + i[2] * n[2]), deriv: 2 * (i[0] * o[0] + i[1] * o[1] + i[2] * o[2] + (n[0] * n[0] + n[1] * n[1] + n[2] * n[2])) };},m = (0, u.newtonRaphson1D)(y.bind(this), void 0, p, _, 32);(m = (0, c.adjustParameterToPeriodicRange)(m, t, c.PI2)) < t[0] || m > t[1] ? (m = (0, u.newtonRaphson1D)(y.bind(this), void 0, -m, _, 32), v = (m = (0, c.adjustParameterToPeriodicRange)(m, t, c.PI2)) < t[0] || m > t[1] ? 1 / 0 : n.Vector3.squaredDistance(e, this.evaluatePosition(m))) : v = n.Vector3.squaredDistance(e, this.evaluatePosition(m));var E = n.Vector3.squaredDistance(e, this.evaluatePosition(t[0])),x = n.Vector3.squaredDistance(e, this.evaluatePosition(t[1]));return E < v && (v = E, m = t[0]), x < v && (m = t[1]), m;}, d.prototype.suggestSplittingParam = function (e) {}, d.prototype.toObject = function () {var e = this.evaluatePosition(0);return n.Vector3.sub(e, e, this.getCenter()), { center: this.vectorToObject(this._center), majorRadius: this.vectorToObject(e), normal: this.vectorToObject(this._normal), radiusRatio: this.getMinorRadius() / this.getMajorRadius(), range: this.rangeToObject(this.getRange(), this.isLimited()) };}, t.Ellipse = d;}, function (e, t, r) {\"use strict\";Object.defineProperty(t, \"__esModule\", { value: !0 }), t.Body = void 0;var n = r(9),o = r(0),i = r(4),s = r(19),a = function a() {n.BaseTopology.call(this), this._lumps = [];};(a.prototype = Object.create(n.BaseTopology.prototype)).getTopologyType = function () {return o.TOPOLOGY_TYPES.BODY;}, a.prototype.getLumps = function () {return this._lumps;}, a.prototype.setLumps = function (e) {this._lumps = new Array(e.length);for (var t = 0; t < e.length; ++t) {this._lumps[t] = e[t];}}, a.prototype.addLump = function (e) {this._lumps ? this._lumps.push(e) : this._lumps = [e], e.setBody(this);}, a.prototype.addLumps = function (e) {this._lumps || (this._lumps = []);for (var t = 0; t < e.length; ++t) {e[t].setBody(this);}this._lumps = this._lumps.concat(e);}, a.prototype.removeLump = function (e) {var t = this._lumps.indexOf(e);return t > -1 && (this._lumps.splice(t, 1), e.getBody() === this && e.setBody(void 0), !0);}, a.prototype.getBody = function () {return this;}, a.prototype.collectFaces = function (e) {e = e || new Set();for (var t = 0; t < this._lumps.length; ++t) {this._lumps[t].collectFaces(e);}return e;}, a.prototype.collectEdges = function (e) {e = e || new Set();for (var t = 0; t < this._lumps.length; ++t) {this._lumps[t].collectEdges(e);}return e;}, a.prototype.collectVertices = function (e) {e = e || new Set();for (var t = 0; t < this._lumps.length; ++t) {this._lumps[t].collectVertices(e);}return e;}, a.prototype.getBoundingBox = function () {for (var e = new i.BoundingBox(), t = 0; t < this._lumps.length; ++t) {e.include(this._lumps[t].getBoundingBox());}return e;}, a.prototype.transform = function (e) {(0, s.transformTopology)(this, e);}, a.prototype.toObject = function () {return { lumps: this.refsToStrings(this._lumps), attributes: this.refsToStrings(this._attributes) };}, a.prototype.addToModelObject = function (e) {this.addAllToModelObject(e, [this._lumps, this._attributes]);}, t.Body = a;}, function (e, t, r) {\"use strict\";Object.defineProperty(t, \"__esModule\", { value: !0 }), t.Lump = void 0;var n = r(9),o = r(0),i = r(4),s = function s() {n.BaseTopology.call(this), this._shells = [], this._body = void 0;};(s.prototype = Object.create(n.BaseTopology.prototype)).getTopologyType = function () {return o.TOPOLOGY_TYPES.LUMP;}, s.prototype.getBody = function () {return this._body;}, s.prototype.setBody = function (e) {this._body = e;}, s.prototype.getShells = function () {return this._shells;}, s.prototype.setShells = function (e) {this._shells = new Array(e.length);for (var t = 0; t < e.length; ++t) {this._shells[t] = e[t];}}, s.prototype.addShell = function (e) {this._shells ? this._shells.push(e) : this._shells = [e], e.setLump(this);}, s.prototype.addShells = function (e) {this._shells || (this._shells = []);for (var t = 0; t < e.length; ++t) {e[t].setLump(this);}this._shells = this._shells.concat(e);}, s.prototype.removeShell = function (e) {var t = this._shells.indexOf(e);return t > -1 && (this._shells.splice(t, 1), e.getLump() === this && e.setLump(void 0), !0);}, s.prototype.collectFaces = function (e) {e = e || new Set();for (var t = 0; t < this._shells.length; ++t) {this._shells[t].collectFaces(e);}return e;}, s.prototype.collectEdges = function (e) {e = e || new Set();for (var t = 0; t < this._shells.length; ++t) {this._shells[t].collectEdges(e);}return e;}, s.prototype.collectVertices = function (e) {e = e || new Set();for (var t = 0; t < this._shells.length; ++t) {this._shells[t].collectVertices(e);}return e;}, s.prototype.getBoundingBox = function () {for (var e = new i.BoundingBox(), t = 0; t < this._shells.length; ++t) {e.include(this._shells[t].getBoundingBox());}return e;}, s.prototype.toString = function () {return \"Lump\";}, s.prototype.toObject = function () {return { shells: this.refsToStrings(this._shells), attributes: this.refsToStrings(this._attributes) };}, s.prototype.addToModelObject = function (e) {this.addAllToModelObject(e, [this._shells, this._attributes]);}, t.Lump = s;}, function (e, t, r) {\"use strict\";Object.defineProperty(t, \"__esModule\", { value: !0 }), t.Shell = void 0;var n = r(9),o = r(0),i = r(4),s = function s() {n.BaseTopology.call(this), this._faces = [], this._lump = void 0;};(s.prototype = Object.create(n.BaseTopology.prototype)).getTopologyType = function () {return o.TOPOLOGY_TYPES.SHELL;}, s.prototype.getLump = function () {return this._lump;}, s.prototype.setLump = function (e) {this._lump = e;}, s.prototype.getFaces = function () {return this._faces;}, s.prototype.setFaces = function (e) {this._faces = new Array(e.length);for (var t = 0; t < e.length; ++t) {this._faces[t] = e[t];}}, s.prototype.addFace = function (e) {this._faces ? this._faces.push(e) : this._faces = [e], e.setShell(this);}, s.prototype.addFaces = function (e) {this._faces || (this._faces = []);for (var t = 0; t < e.length; ++t) {e[t].setShell(this);}this._faces = this._faces.concat(e);}, s.prototype.removeFace = function (e) {var t = this._faces.indexOf(e);return t > -1 && (this._faces.splice(t, 1), e.getShell() === this && e.setShell(void 0), !0);}, s.prototype.getBody = function () {return this._lump ? this._lump.getBody() : void 0;}, s.prototype.collectFaces = function (e) {e = e || new Set();for (var t = 0; t < this._faces.length; ++t) {e.add(this._faces[t]);}return e;}, s.prototype.collectEdges = function (e) {e = e || new Set();for (var t = 0; t < this._faces.length; ++t) {this._faces[t].collectEdges(e);}return e;}, s.prototype.collectVertices = function (e) {e = e || new Set();for (var t = 0; t < this._faces.length; ++t) {this._faces[t].collectVertices(e);}return e;}, s.prototype.getBoundingBox = function () {for (var e = new i.BoundingBox(), t = 0; t < this._faces.length; ++t) {e.include(this._faces[t].getBoundingBox());}return e;}, s.prototype.toString = function () {return \"Shell\";}, s.prototype.toObject = function () {return { faces: this.refsToStrings(this._faces), attributes: this.refsToStrings(this._attributes) };}, s.prototype.addToModelObject = function (e) {this.addAllToModelObject(e, [this._faces, this._attributes]);}, t.Shell = s;}, function (e, t, r) {\"use strict\";Object.defineProperty(t, \"__esModule\", { value: !0 }), t.Coedge = void 0;var n = r(1),o = r(9),i = r(0),s = r(2),a = r(3),c = r(36),u = function u(e) {o.BaseTopology.call(this), this._reversed = !1, this._edge = e, this._loop = void 0, this._partner = void 0, this._uvCurve = void 0;};(u.prototype = Object.create(o.BaseTopology.prototype)).getTopologyType = function () {return i.TOPOLOGY_TYPES.COEDGE;}, u.prototype.getEdge = function () {return this._edge;}, u.prototype.getLoop = function () {return this._loop;}, u.prototype.getPartner = function () {return this._partner;}, u.prototype.setEdge = function (e) {this._edge = e;}, u.prototype.setLoop = function (e) {this._loop = e;}, u.prototype.setPartner = function (e) {this._partner = e;}, u.prototype.getStartVertex = function () {return this._reversed ? this._edge.getEndVertex() : this._edge.getStartVertex();}, u.prototype.getEndVertex = function () {return this._reversed ? this._edge.getStartVertex() : this._edge.getEndVertex();}, u.prototype.getFace = function () {return this._loop ? this._loop.getFace() : void 0;}, u.prototype.getNext = function () {if (this._loop) {var e = this._loop.getCoedges(),t = e.indexOf(this);return s.ConsoleUtils.assert(t >= 0), e[(t + 1) % e.length];}}, u.prototype.getPrevious = function () {if (this._loop) {var e = this._loop.getCoedges(),t = e.indexOf(this);return s.ConsoleUtils.assert(t >= 0), e[(0, a.modulus)(t - 1, e.length)];}}, u.prototype.isReversed = function () {return this._reversed;}, u.prototype.setReversed = function (e) {this._reversed = e;}, u.prototype.getRange = function () {if (this._edge) return this._reversed ? [-this._edge.t1(), -this._edge.t0()] : [this._edge.t0(), this._edge.t1()];}, u.prototype.t0 = function () {if (this._edge) return this._reversed ? -this._edge.t1() : this._edge.t0();}, u.prototype.t1 = function () {if (this._edge) return this._reversed ? -this._edge.t0() : this._edge.t1();}, u.prototype.evaluatePosition = function (e) {if (this._edge) return this.isReversed() && (e = -e), this._edge.evaluatePosition(e);}, u.prototype.evaluateDt = function (e) {if (this._edge) {this.isReversed() && (e = -e);var t = this._edge.evaluateDt(e);return this.isReversed() && n.Vector3.negate(t, t), t;}}, u.prototype.evaluateCurvature = function (e, t) {if (this._edge) return this.isReversed() && (e = -e), this._edge.evaluateCurvature(e, t);}, u.prototype.evaluateFaceUV = function (e) {var t = this.getFace();if (t) {var r = this.evaluatePosition(e);return t.closestParam(r);}}, u.prototype.evaluateInwardDirection = function (e) {var t = this.getFace();if (t) {var r = this.evaluateDt(e),o = this.evaluateFaceUV(e),i = t.evaluateNormal(o.u, o.v),s = [0, 0, 0];return n.Vector3.cross(s, i, r), n.Vector3.normalize(s, s), s;}}, u.prototype.getBoundingBox = function () {if (this._edge) return this._edge.getBoundingBox();}, u.prototype.generateUVCurve = function (e) {if (!this._uvCurve && this._edge) {var t = this._edge.getCurve();if (t && this._loop && this._loop.getFace()) {var r = this._loop.getFace().getSurface();r && r.getGeometryType() === i.GEOMETRY_TYPES.PLANE && (e || (e = (0, a.getPlaneTransforms)(r).threeSpaceToUV), e ? (this._uvCurve = t.clone(), this._uvCurve.transform(e)) : this._uvCurve = t);}}}, u.prototype.resetUVCurve = function () {this._uvCurve = void 0;}, u.prototype.uvAngleSubtended = function (e) {var t = this._loop.getFace().getSurface().closestParam(e),r = [t.u, t.v, 0];this.generateUVCurve(), s.ConsoleUtils.assert(this._uvCurve);var o = this.getRange(),u = 1;this.isReversed() !== this._edge.isReversed() && (o = [-o[1], -o[0]], u = -1), this._loop && this._loop.getFace() && this._loop.getFace().isReversed() && (u *= -1);var l = !1,h = this._uvCurve.getRange();this._uvCurve.isClosed() && o[1] - o[0] >= h[1] - h[0] - 2 * i.PARAMETER_SPACE_TOLERANCE && (l = !0);var d = this._uvCurve.evaluatePosition(o[0]),g = this._uvCurve.evaluatePosition(o[1]),p = n.Vector3.createFloat64();n.Vector3.sub(p, d, r), n.Vector3.normalize(p, p);var f = n.Vector3.createFloat64();n.Vector3.sub(f, g, r), n.Vector3.normalize(f, f);var v = (0, a.getSignedAngle)(p, f),_ = v < 0,y = !1,m = !1;switch (this._edge.getCurveType()) {case i.GEOMETRY_TYPES.LINE:break;case i.GEOMETRY_TYPES.CIRCLE:m = this._uvCurve.getNormal()[2] > 0, y = n.Vector3.distance(r, this._uvCurve.getCenter()) < this._uvCurve.getRadius(), l || (y = y && _ !== m);break;case i.GEOMETRY_TYPES.ELLIPSE:m = this._uvCurve.getNormal()[2] > 0;var E = n.Vector3.sub([0, 0, 0], r, this._uvCurve.getCenter()),x = n.Vector3.dot(E, this._uvCurve.getMajorAxis()) / this._uvCurve.getMajorRadius(),R = n.Vector3.dot(E, this._uvCurve.getMinorAxis()) / this._uvCurve.getMinorRadius();y = x * x + R * R <= 1, l || (y = y && _ !== m);break;case i.GEOMETRY_TYPES.BCURVE:this._uvCurve.isPlanarXY() || console.warn(\"Unsupported non-planar curve for uvAngleSubtended\");var A = [r[0], r[1]];y = c.SplineCurveHelper.isPointInsideSplineRegionXYPlanar3D(A, this._uvCurve, o), m = !0;break;default:throw new Error(\"Unsupported curve type for uvAngleSubtended\");}return l ? v = y ? 2 * Math.PI * (m ? -1 : 1) : 0 : y && (v < 0 ? v = 2 * Math.PI + v : v -= 2 * Math.PI), v * u;}, u.prototype.getBody = function () {return this._loop ? this._loop.getBody() : void 0;}, u.prototype.collectFaces = function (e) {return e = e || new Set(), this._loop && this._loop.collectFaces(e), e;}, u.prototype.collectEdges = function (e) {return e = e || new Set(), this._edge && e.add(this._edge), e;}, u.prototype.collectVertices = function (e) {return e = e || new Set(), this._edge && this._edge.collectVertices(e), e;}, u.prototype.toString = function () {return \"Coedge\";}, u.prototype.toObject = function () {return { edge: this.refToString(this._edge), partner: this.refToString(this._partner), reversed: this._reversed, attributes: this.refsToStrings(this._attributes) };}, u.prototype.addToModelObject = function (e) {this.addAllToModelObject(e, [this._edge, this._attributes]);}, t.Coedge = u;}, function (e, t, r) {\"use strict\";Object.defineProperty(t, \"__esModule\", { value: !0 }), t.createShellsFromFaces = t.createWiresFromEdges = t.createEdgesFromCurves = t.createEdgeFromCurve = t.createLoopFromPolyline = t.createFaceFromPolyline = t.makeConeOrCylinderVParamLoop = t.createCoedgeOnEdge = t.createLineEdge = t.createLineEdgeBetweenVertices = void 0;var n = r(1),o = r(0),i = r(2),s = r(6),a = r(7),c = r(18),u = r(27),l = r(16),h = r(26),d = r(20),g = r(13),p = r(15),f = r(40),v = r(3),_ = r(19),y = function y(e, t) {var r = e.getPosition(),o = t.getPosition(),i = new a.Line();i.setFromEndpoints(r, o);var s = new d.Edge(i);return s.setRange([0, n.Vector3.distance(r, o)]), s.setStartVertex(e), s.setEndVertex(t), s;},m = function m(e) {var t = new u.Coedge();t.setEdge(e);var r = e.getCoedge();return r ? (i.ConsoleUtils.assert(!r.getPartner()), r.setPartner(t), t.setPartner(r), t.setReversed(!r.isReversed())) : e.setCoedge(t), t;},E = function E(e) {for (var t = e.length, r = new Array(t), n = 0; n < t; ++n) {r[n] = new l.Vertex(new s.Point(e[n]));}var o = new Array(t);for (n = 0; n < t; ++n) {var i = (n + 1) % t,a = y(r[n], r[i]);o[n] = m(a);}var c = new g.Loop();return c.addCoedges(o), c;},x = function x(e) {var t = new d.Edge(e),r = e.getRange();r[0] !== -1 / 0 && r[1] !== 1 / 0 ? (t.sett0(r[0]), t.sett1(r[1])) : (t.sett0(0), t.sett1(1));var n = t.evaluatePosition(t.t0());if (t.setStartVertex(new l.Vertex(new s.Point(n))), e.isClosed()) t.setEndVertex(t.getStartVertex());else {var o = t.evaluatePosition(t.t1());t.setEndVertex(new l.Vertex(new s.Point(o)));}return t;};t.createLineEdgeBetweenVertices = y, t.createLineEdge = function (e, t) {var r = new l.Vertex(new s.Point(e)),n = new l.Vertex(new s.Point(t));return y(r, n);}, t.createCoedgeOnEdge = m, t.makeConeOrCylinderVParamLoop = function (e, t) {i.ConsoleUtils.assert(e.getGeometryType() === o.GEOMETRY_TYPES.CYLINDER || e.getGeometryType() === o.GEOMETRY_TYPES.CONE || e.getGeometryType() === o.GEOMETRY_TYPES.ELLIPTICAL_CYLINDER || e.getGeometryType() === o.GEOMETRY_TYPES.ELLIPTICAL_CONE), i.ConsoleUtils.assert(e.isPeriodicV());var r,n = new d.Edge(),a = e.vParamLine(t);a.getGeometryType() === o.GEOMETRY_TYPES.POINT ? r = a : (r = new s.Point(a.evaluatePosition(a.getRange()[0])), n.setCurve(a), n.setRange(a.getRange()));var c = new l.Vertex(r);n.setStartVertex(c), n.setEndVertex(c);var u = new g.Loop();return u.addCoedge(m(n)), u;}, t.createFaceFromPolyline = function (e) {var t = E(e),r = (0, v.definePlaneThroughPoints)(e),n = new c.Plane();n.set(r.origin, r.normal, r.uAxis), n.limitRangeU(r.uRange), n.limitRangeV(r.vRange);var o = new p.Face(n);return o.addLoop(t), o;}, t.createLoopFromPolyline = E, t.createEdgeFromCurve = x, t.createEdgesFromCurves = function (e) {for (var t = [], r = 0; r < e.length; ++r) {t.push(x(e[r]));}return (0, _.mergeCoincidentVertices)(t), t;}, t.createWiresFromEdges = function (e) {for (var t = (0, _.findConnectedEdges)(e), r = [], n = 0; n < t.length; ++n) {var o = new f.Wire();o.addEdges(t[n]), r.push(o);}return r;}, t.createShellsFromFaces = function (e) {for (var t = (0, _.findConnectedFaces)(e), r = new Array(t.length), n = 0; n < t.length; ++n) {var o = new h.Shell();o.addFaces(t[n]), r[n] = o;}return r;};}, function (e, t, r) {\"use strict\";r.r(t), function (e) {r.d(t, \"default\", function () {return _;}), r.d(t, \"VERSION\", function () {return y;}), r.d(t, \"iteratee\", function () {return x;}), r.d(t, \"restArguments\", function () {return A;}), r.d(t, \"each\", function () {return S;}), r.d(t, \"forEach\", function () {return S;}), r.d(t, \"map\", function () {return M;}), r.d(t, \"collect\", function () {return M;}), r.d(t, \"reduce\", function () {return N;}), r.d(t, \"foldl\", function () {return N;}), r.d(t, \"inject\", function () {return N;}), r.d(t, \"reduceRight\", function () {return F;}), r.d(t, \"foldr\", function () {return F;}), r.d(t, \"find\", function () {return I;}), r.d(t, \"detect\", function () {return I;}), r.d(t, \"filter\", function () {return D;}), r.d(t, \"select\", function () {return D;}), r.d(t, \"reject\", function () {return j;}), r.d(t, \"every\", function () {return B;}), r.d(t, \"all\", function () {return B;}), r.d(t, \"some\", function () {return U;}), r.d(t, \"any\", function () {return U;}), r.d(t, \"contains\", function () {return k;}), r.d(t, \"includes\", function () {return k;}), r.d(t, \"include\", function () {return k;}), r.d(t, \"invoke\", function () {return G;}), r.d(t, \"pluck\", function () {return z;}), r.d(t, \"where\", function () {return Y;}), r.d(t, \"findWhere\", function () {return K;}), r.d(t, \"max\", function () {return q;}), r.d(t, \"min\", function () {return W;}), r.d(t, \"shuffle\", function () {return H;}), r.d(t, \"sample\", function () {return X;}), r.d(t, \"sortBy\", function () {return J;}), r.d(t, \"groupBy\", function () {return Z;}), r.d(t, \"indexBy\", function () {return Q;}), r.d(t, \"countBy\", function () {return ee;}), r.d(t, \"toArray\", function () {return re;}), r.d(t, \"size\", function () {return ne;}), r.d(t, \"partition\", function () {return oe;}), r.d(t, \"first\", function () {return ie;}), r.d(t, \"head\", function () {return ie;}), r.d(t, \"take\", function () {return ie;}), r.d(t, \"initial\", function () {return se;}), r.d(t, \"last\", function () {return ae;}), r.d(t, \"rest\", function () {return ce;}), r.d(t, \"tail\", function () {return ce;}), r.d(t, \"drop\", function () {return ce;}), r.d(t, \"compact\", function () {return ue;}), r.d(t, \"flatten\", function () {return he;}), r.d(t, \"without\", function () {return de;}), r.d(t, \"uniq\", function () {return ge;}), r.d(t, \"unique\", function () {return ge;}), r.d(t, \"union\", function () {return pe;}), r.d(t, \"intersection\", function () {return fe;}), r.d(t, \"difference\", function () {return ve;}), r.d(t, \"unzip\", function () {return _e;}), r.d(t, \"zip\", function () {return ye;}), r.d(t, \"object\", function () {return me;}), r.d(t, \"findIndex\", function () {return xe;}), r.d(t, \"findLastIndex\", function () {return Re;}), r.d(t, \"sortedIndex\", function () {return Ae;}), r.d(t, \"indexOf\", function () {return Ve;}), r.d(t, \"lastIndexOf\", function () {return Te;}), r.d(t, \"range\", function () {return Ce;}), r.d(t, \"chunk\", function () {return be;}), r.d(t, \"bind\", function () {return Oe;}), r.d(t, \"partial\", function () {return Se;}), r.d(t, \"bindAll\", function () {return Me;}), r.d(t, \"memoize\", function () {return we;}), r.d(t, \"delay\", function () {return Ne;}), r.d(t, \"defer\", function () {return Fe;}), r.d(t, \"throttle\", function () {return Ie;}), r.d(t, \"debounce\", function () {return De;}), r.d(t, \"wrap\", function () {return je;}), r.d(t, \"negate\", function () {return Be;}), r.d(t, \"compose\", function () {return Ue;}), r.d(t, \"after\", function () {return ke;}), r.d(t, \"before\", function () {return Ge;}), r.d(t, \"once\", function () {return ze;}), r.d(t, \"keys\", function () {return We;}), r.d(t, \"allKeys\", function () {return He;}), r.d(t, \"values\", function () {return Xe;}), r.d(t, \"mapObject\", function () {return Je;}), r.d(t, \"pairs\", function () {return $e;}), r.d(t, \"invert\", function () {return Ze;}), r.d(t, \"functions\", function () {return Qe;}), r.d(t, \"methods\", function () {return Qe;}), r.d(t, \"extend\", function () {return tt;}), r.d(t, \"extendOwn\", function () {return rt;}), r.d(t, \"assign\", function () {return rt;}), r.d(t, \"findKey\", function () {return nt;}), r.d(t, \"pick\", function () {return it;}), r.d(t, \"omit\", function () {return st;}), r.d(t, \"defaults\", function () {return at;}), r.d(t, \"create\", function () {return ct;}), r.d(t, \"clone\", function () {return ut;}), r.d(t, \"tap\", function () {return lt;}), r.d(t, \"isMatch\", function () {return ht;}), r.d(t, \"isEqual\", function () {return dt;}), r.d(t, \"isEmpty\", function () {return gt;}), r.d(t, \"isElement\", function () {return pt;}), r.d(t, \"isArray\", function () {return vt;}), r.d(t, \"isObject\", function () {return _t;}), r.d(t, \"isArguments\", function () {return yt;}), r.d(t, \"isFunction\", function () {return mt;}), r.d(t, \"isString\", function () {return Et;}), r.d(t, \"isNumber\", function () {return xt;}), r.d(t, \"isDate\", function () {return Rt;}), r.d(t, \"isRegExp\", function () {return At;}), r.d(t, \"isError\", function () {return Pt;}), r.d(t, \"isSymbol\", function () {return Vt;}), r.d(t, \"isMap\", function () {return Tt;}), r.d(t, \"isWeakMap\", function () {return Ct;}), r.d(t, \"isSet\", function () {return bt;}), r.d(t, \"isWeakSet\", function () {return Lt;}), r.d(t, \"isFinite\", function () {return St;}), r.d(t, \"isNaN\", function () {return Mt;}), r.d(t, \"isBoolean\", function () {return wt;}), r.d(t, \"isNull\", function () {return Nt;}), r.d(t, \"isUndefined\", function () {return Ft;}), r.d(t, \"has\", function () {return It;}), r.d(t, \"identity\", function () {return Dt;}), r.d(t, \"constant\", function () {return jt;}), r.d(t, \"noop\", function () {return Bt;}), r.d(t, \"property\", function () {return Ut;}), r.d(t, \"propertyOf\", function () {return kt;}), r.d(t, \"matcher\", function () {return Gt;}), r.d(t, \"matches\", function () {return Gt;}), r.d(t, \"times\", function () {return zt;}), r.d(t, \"random\", function () {return Yt;}), r.d(t, \"now\", function () {return Kt;}), r.d(t, \"escape\", function () {return Xt;}), r.d(t, \"unescape\", function () {return Jt;}), r.d(t, \"result\", function () {return $t;}), r.d(t, \"uniqueId\", function () {return Qt;}), r.d(t, \"templateSettings\", function () {return er;}), r.d(t, \"template\", function () {return ir;}), r.d(t, \"chain\", function () {return sr;}), r.d(t, \"mixin\", function () {return cr;});var n = \"object\" == (typeof self === \"undefined\" ? \"undefined\" : _typeof(self)) && self.self === self && self || \"object\" == _typeof(e) && e.global === e && e || Function(\"return this\")() || {},o = Array.prototype,i = Object.prototype,s = \"undefined\" != typeof Symbol ? Symbol.prototype : null,a = o.push,c = o.slice,u = i.toString,l = i.hasOwnProperty,h = Array.isArray,d = Object.keys,g = Object.create,p = n.isNaN,f = n.isFinite,v = function v() {};function _(e) {return e instanceof _ ? e : this instanceof _ ? void (this._wrapped = e) : new _(e);}var y = _.VERSION = \"1.10.2\";function m(e, t, r) {if (void 0 === t) return e;switch (null == r ? 3 : r) {case 1:return function (r) {return e.call(t, r);};case 3:return function (r, n, o) {return e.call(t, r, n, o);};case 4:return function (r, n, o, i) {return e.call(t, r, n, o, i);};}return function () {return e.apply(t, arguments);};}function E(e, t, r) {return null == e ? Dt : mt(e) ? m(e, t, r) : _t(e) && !vt(e) ? Gt(e) : Ut(e);}function x(e, t) {return E(e, t, 1 / 0);}function R(e, t, r) {return _.iteratee !== x ? _.iteratee(e, t) : E(e, t, r);}function A(e, t) {return t = null == t ? e.length - 1 : +t, function () {for (var r = Math.max(arguments.length - t, 0), n = Array(r), o = 0; o < r; o++) {n[o] = arguments[o + t];}switch (t) {case 0:return e.call(this, n);case 1:return e.call(this, arguments[0], n);case 2:return e.call(this, arguments[0], arguments[1], n);}var i = Array(t + 1);for (o = 0; o < t; o++) {i[o] = arguments[o];}return i[t] = n, e.apply(this, i);};}function P(e) {if (!_t(e)) return {};if (g) return g(e);v.prototype = e;var t = new v();return v.prototype = null, t;}function V(e) {return function (t) {return null == t ? void 0 : t[e];};}function T(e, t) {return null != e && l.call(e, t);}function C(e, t) {for (var r = t.length, n = 0; n < r; n++) {if (null == e) return;e = e[t[n]];}return r ? e : void 0;}_.iteratee = x;var b = Math.pow(2, 53) - 1,L = V(\"length\");function O(e) {var t = L(e);return \"number\" == typeof t && t >= 0 && t <= b;}function S(e, t, r) {var n, o;if (t = m(t, r), O(e)) for (n = 0, o = e.length; n < o; n++) {t(e[n], n, e);} else {var i = We(e);for (n = 0, o = i.length; n < o; n++) {t(e[i[n]], i[n], e);}}return e;}function M(e, t, r) {t = R(t, r);for (var n = !O(e) && We(e), o = (n || e).length, i = Array(o), s = 0; s < o; s++) {var a = n ? n[s] : s;i[s] = t(e[a], a, e);}return i;}function w(e) {return function (t, r, n, o) {var i = arguments.length >= 3;return function (t, r, n, o) {var i = !O(t) && We(t),s = (i || t).length,a = e > 0 ? 0 : s - 1;for (o || (n = t[i ? i[a] : a], a += e); a >= 0 && a < s; a += e) {var c = i ? i[a] : a;n = r(n, t[c], c, t);}return n;}(t, m(r, o, 4), n, i);};}var N = w(1),F = w(-1);function I(e, t, r) {var n = (O(e) ? xe : nt)(e, t, r);if (void 0 !== n && -1 !== n) return e[n];}function D(e, t, r) {var n = [];return t = R(t, r), S(e, function (e, r, o) {t(e, r, o) && n.push(e);}), n;}function j(e, t, r) {return D(e, Be(R(t)), r);}function B(e, t, r) {t = R(t, r);for (var n = !O(e) && We(e), o = (n || e).length, i = 0; i < o; i++) {var s = n ? n[i] : i;if (!t(e[s], s, e)) return !1;}return !0;}function U(e, t, r) {t = R(t, r);for (var n = !O(e) && We(e), o = (n || e).length, i = 0; i < o; i++) {var s = n ? n[i] : i;if (t(e[s], s, e)) return !0;}return !1;}function k(e, t, r, n) {return O(e) || (e = Xe(e)), (\"number\" != typeof r || n) && (r = 0), Ve(e, t, r) >= 0;}var G = A(function (e, t, r) {var n, o;return mt(t) ? o = t : vt(t) && (n = t.slice(0, -1), t = t[t.length - 1]), M(e, function (e) {var i = o;if (!i) {if (n && n.length && (e = C(e, n)), null == e) return;i = e[t];}return null == i ? i : i.apply(e, r);});});function z(e, t) {return M(e, Ut(t));}function Y(e, t) {return D(e, Gt(t));}function K(e, t) {return I(e, Gt(t));}function q(e, t, r) {var n,o,i = -1 / 0,s = -1 / 0;if (null == t || \"number\" == typeof t && \"object\" != _typeof(e[0]) && null != e) for (var a = 0, c = (e = O(e) ? e : Xe(e)).length; a < c; a++) {null != (n = e[a]) && n > i && (i = n);} else t = R(t, r), S(e, function (e, r, n) {((o = t(e, r, n)) > s || o === -1 / 0 && i === -1 / 0) && (i = e, s = o);});return i;}function W(e, t, r) {var n,o,i = 1 / 0,s = 1 / 0;if (null == t || \"number\" == typeof t && \"object\" != _typeof(e[0]) && null != e) for (var a = 0, c = (e = O(e) ? e : Xe(e)).length; a < c; a++) {null != (n = e[a]) && n < i && (i = n);} else t = R(t, r), S(e, function (e, r, n) {((o = t(e, r, n)) < s || o === 1 / 0 && i === 1 / 0) && (i = e, s = o);});return i;}function H(e) {return X(e, 1 / 0);}function X(e, t, r) {if (null == t || r) return O(e) || (e = Xe(e)), e[Yt(e.length - 1)];var n = O(e) ? ut(e) : Xe(e),o = L(n);t = Math.max(Math.min(t, o), 0);for (var i = o - 1, s = 0; s < t; s++) {var a = Yt(s, i),c = n[s];n[s] = n[a], n[a] = c;}return n.slice(0, t);}function J(e, t, r) {var n = 0;return t = R(t, r), z(M(e, function (e, r, o) {return { value: e, index: n++, criteria: t(e, r, o) };}).sort(function (e, t) {var r = e.criteria,n = t.criteria;if (r !== n) {if (r > n || void 0 === r) return 1;if (r < n || void 0 === n) return -1;}return e.index - t.index;}), \"value\");}function $(e, t) {return function (r, n, o) {var i = t ? [[], []] : {};return n = R(n, o), S(r, function (t, o) {var s = n(t, o, r);e(i, t, s);}), i;};}var Z = $(function (e, t, r) {T(e, r) ? e[r].push(t) : e[r] = [t];}),Q = $(function (e, t, r) {e[r] = t;}),ee = $(function (e, t, r) {T(e, r) ? e[r]++ : e[r] = 1;}),te = /[^\\ud800-\\udfff]|[\\ud800-\\udbff][\\udc00-\\udfff]|[\\ud800-\\udfff]/g;function re(e) {return e ? vt(e) ? c.call(e) : Et(e) ? e.match(te) : O(e) ? M(e, Dt) : Xe(e) : [];}function ne(e) {return null == e ? 0 : O(e) ? e.length : We(e).length;}var oe = $(function (e, t, r) {e[r ? 0 : 1].push(t);}, !0);function ie(e, t, r) {return null == e || e.length < 1 ? null == t ? void 0 : [] : null == t || r ? e[0] : se(e, e.length - t);}function se(e, t, r) {return c.call(e, 0, Math.max(0, e.length - (null == t || r ? 1 : t)));}function ae(e, t, r) {return null == e || e.length < 1 ? null == t ? void 0 : [] : null == t || r ? e[e.length - 1] : ce(e, Math.max(0, e.length - t));}function ce(e, t, r) {return c.call(e, null == t || r ? 1 : t);}function ue(e) {return D(e, Boolean);}function le(e, t, r, n) {for (var o = (n = n || []).length, i = 0, s = L(e); i < s; i++) {var a = e[i];if (O(a) && (vt(a) || yt(a))) {if (t) for (var c = 0, u = a.length; c < u;) {n[o++] = a[c++];} else le(a, t, r, n), o = n.length;} else r || (n[o++] = a);}return n;}function he(e, t) {return le(e, t, !1);}var de = A(function (e, t) {return ve(e, t);});function ge(e, t, r, n) {wt(t) || (n = r, r = t, t = !1), null != r && (r = R(r, n));for (var o = [], i = [], s = 0, a = L(e); s < a; s++) {var c = e[s],u = r ? r(c, s, e) : c;t && !r ? (s && i === u || o.push(c), i = u) : r ? k(i, u) || (i.push(u), o.push(c)) : k(o, c) || o.push(c);}return o;}var pe = A(function (e) {return ge(le(e, !0, !0));});function fe(e) {for (var t = [], r = arguments.length, n = 0, o = L(e); n < o; n++) {var i = e[n];if (!k(t, i)) {var s;for (s = 1; s < r && k(arguments[s], i); s++) {;}s === r && t.push(i);}}return t;}var ve = A(function (e, t) {return t = le(t, !0, !0), D(e, function (e) {return !k(t, e);});});function _e(e) {for (var t = e && q(e, L).length || 0, r = Array(t), n = 0; n < t; n++) {r[n] = z(e, n);}return r;}var ye = A(_e);function me(e, t) {for (var r = {}, n = 0, o = L(e); n < o; n++) {t ? r[e[n]] = t[n] : r[e[n][0]] = e[n][1];}return r;}function Ee(e) {return function (t, r, n) {r = R(r, n);for (var o = L(t), i = e > 0 ? 0 : o - 1; i >= 0 && i < o; i += e) {if (r(t[i], i, t)) return i;}return -1;};}var xe = Ee(1),Re = Ee(-1);function Ae(e, t, r, n) {for (var o = (r = R(r, n, 1))(t), i = 0, s = L(e); i < s;) {var a = Math.floor((i + s) / 2);r(e[a]) < o ? i = a + 1 : s = a;}return i;}function Pe(e, t, r) {return function (n, o, i) {var s = 0,a = L(n);if (\"number\" == typeof i) e > 0 ? s = i >= 0 ? i : Math.max(i + a, s) : a = i >= 0 ? Math.min(i + 1, a) : i + a + 1;else if (r && i && a) return n[i = r(n, o)] === o ? i : -1;if (o != o) return (i = t(c.call(n, s, a), Mt)) >= 0 ? i + s : -1;for (i = e > 0 ? s : a - 1; i >= 0 && i < a; i += e) {if (n[i] === o) return i;}return -1;};}var Ve = Pe(1, xe, Ae),Te = Pe(-1, Re);function Ce(e, t, r) {null == t && (t = e || 0, e = 0), r || (r = t < e ? -1 : 1);for (var n = Math.max(Math.ceil((t - e) / r), 0), o = Array(n), i = 0; i < n; i++, e += r) {o[i] = e;}return o;}function be(e, t) {if (null == t || t < 1) return [];for (var r = [], n = 0, o = e.length; n < o;) {r.push(c.call(e, n, n += t));}return r;}function Le(e, t, r, n, o) {if (!(n instanceof t)) return e.apply(r, o);var i = P(e.prototype),s = e.apply(i, o);return _t(s) ? s : i;}var Oe = A(function (e, t, r) {if (!mt(e)) throw new TypeError(\"Bind must be called on a function\");var n = A(function (o) {return Le(e, n, t, this, r.concat(o));});return n;}),Se = A(function (e, t) {var r = Se.placeholder,n = function n() {for (var o = 0, i = t.length, s = Array(i), a = 0; a < i; a++) {s[a] = t[a] === r ? arguments[o++] : t[a];}for (; o < arguments.length;) {s.push(arguments[o++]);}return Le(e, n, this, this, s);};return n;});Se.placeholder = _;var Me = A(function (e, t) {var r = (t = le(t, !1, !1)).length;if (r < 1) throw new Error(\"bindAll must be passed function names\");for (; r--;) {var n = t[r];e[n] = Oe(e[n], e);}});function we(e, t) {var r = function r(n) {var o = r.cache,i = \"\" + (t ? t.apply(this, arguments) : n);return T(o, i) || (o[i] = e.apply(this, arguments)), o[i];};return r.cache = {}, r;}var Ne = A(function (e, t, r) {return setTimeout(function () {return e.apply(null, r);}, t);}),Fe = Se(Ne, _, 1);function Ie(e, t, r) {var n,o,i,s,a = 0;r || (r = {});var c = function c() {a = !1 === r.leading ? 0 : Kt(), n = null, s = e.apply(o, i), n || (o = i = null);},u = function u() {var u = Kt();a || !1 !== r.leading || (a = u);var l = t - (u - a);return o = this, i = arguments, l <= 0 || l > t ? (n && (clearTimeout(n), n = null), a = u, s = e.apply(o, i), n || (o = i = null)) : n || !1 === r.trailing || (n = setTimeout(c, l)), s;};return u.cancel = function () {clearTimeout(n), a = 0, n = o = i = null;}, u;}function De(e, t, r) {var n,o,i = function i(t, r) {n = null, r && (o = e.apply(t, r));},s = A(function (s) {if (n && clearTimeout(n), r) {var a = !n;n = setTimeout(i, t), a && (o = e.apply(this, s));} else n = Ne(i, t, this, s);return o;});return s.cancel = function () {clearTimeout(n), n = null;}, s;}function je(e, t) {return Se(t, e);}function Be(e) {return function () {return !e.apply(this, arguments);};}function Ue() {var e = arguments,t = e.length - 1;return function () {for (var r = t, n = e[t].apply(this, arguments); r--;) {n = e[r].call(this, n);}return n;};}function ke(e, t) {return function () {if (--e < 1) return t.apply(this, arguments);};}function Ge(e, t) {var r;return function () {return --e > 0 && (r = t.apply(this, arguments)), e <= 1 && (t = null), r;};}var ze = Se(Ge, 2),Ye = !{ toString: null }.propertyIsEnumerable(\"toString\"),Ke = [\"valueOf\", \"isPrototypeOf\", \"toString\", \"propertyIsEnumerable\", \"hasOwnProperty\", \"toLocaleString\"];function qe(e, t) {var r = Ke.length,n = e.constructor,o = mt(n) && n.prototype || i,s = \"constructor\";for (T(e, s) && !k(t, s) && t.push(s); r--;) {(s = Ke[r]) in e && e[s] !== o[s] && !k(t, s) && t.push(s);}}function We(e) {if (!_t(e)) return [];if (d) return d(e);var t = [];for (var r in e) {T(e, r) && t.push(r);}return Ye && qe(e, t), t;}function He(e) {if (!_t(e)) return [];var t = [];for (var r in e) {t.push(r);}return Ye && qe(e, t), t;}function Xe(e) {for (var t = We(e), r = t.length, n = Array(r), o = 0; o < r; o++) {n[o] = e[t[o]];}return n;}function Je(e, t, r) {t = R(t, r);for (var n = We(e), o = n.length, i = {}, s = 0; s < o; s++) {var a = n[s];i[a] = t(e[a], a, e);}return i;}function $e(e) {for (var t = We(e), r = t.length, n = Array(r), o = 0; o < r; o++) {n[o] = [t[o], e[t[o]]];}return n;}function Ze(e) {for (var t = {}, r = We(e), n = 0, o = r.length; n < o; n++) {t[e[r[n]]] = r[n];}return t;}function Qe(e) {var t = [];for (var r in e) {mt(e[r]) && t.push(r);}return t.sort();}function et(e, t) {return function (r) {var n = arguments.length;if (t && (r = Object(r)), n < 2 || null == r) return r;for (var o = 1; o < n; o++) {for (var i = arguments[o], s = e(i), a = s.length, c = 0; c < a; c++) {var u = s[c];t && void 0 !== r[u] || (r[u] = i[u]);}}return r;};}var tt = et(He),rt = et(We);function nt(e, t, r) {t = R(t, r);for (var n, o = We(e), i = 0, s = o.length; i < s; i++) {if (t(e[n = o[i]], n, e)) return n;}}function ot(e, t, r) {return t in r;}var it = A(function (e, t) {var r = {},n = t[0];if (null == e) return r;mt(n) ? (t.length > 1 && (n = m(n, t[1])), t = He(e)) : (n = ot, t = le(t, !1, !1), e = Object(e));for (var o = 0, i = t.length; o < i; o++) {var s = t[o],a = e[s];n(a, s, e) && (r[s] = a);}return r;}),st = A(function (e, t) {var r,n = t[0];return mt(n) ? (n = Be(n), t.length > 1 && (r = t[1])) : (t = M(le(t, !1, !1), String), n = function n(e, r) {return !k(t, r);}), it(e, n, r);}),at = et(He, !0);function ct(e, t) {var r = P(e);return t && rt(r, t), r;}function ut(e) {return _t(e) ? vt(e) ? e.slice() : tt({}, e) : e;}function lt(e, t) {return t(e), e;}function ht(e, t) {var r = We(t),n = r.length;if (null == e) return !n;for (var o = Object(e), i = 0; i < n; i++) {var s = r[i];if (t[s] !== o[s] || !(s in o)) return !1;}return !0;}function dt(e, t) {return function e(t, r, n, o) {if (t === r) return 0 !== t || 1 / t == 1 / r;if (null == t || null == r) return !1;if (t != t) return r != r;var i = _typeof(t);return (\"function\" === i || \"object\" === i || \"object\" == _typeof(r)) && function (t, r, n, o) {t instanceof _ && (t = t._wrapped), r instanceof _ && (r = r._wrapped);var i = u.call(t);if (i !== u.call(r)) return !1;switch (i) {case \"[object RegExp]\":case \"[object String]\":return \"\" + t == \"\" + r;case \"[object Number]\":return +t != +t ? +r != +r : 0 == +t ? 1 / +t == 1 / r : +t == +r;case \"[object Date]\":case \"[object Boolean]\":return +t == +r;case \"[object Symbol]\":return s.valueOf.call(t) === s.valueOf.call(r);}var a = \"[object Array]\" === i;if (!a) {if (\"object\" != _typeof(t) || \"object\" != _typeof(r)) return !1;var c = t.constructor,l = r.constructor;if (c !== l && !(mt(c) && c instanceof c && mt(l) && l instanceof l) && \"constructor\" in t && \"constructor\" in r) return !1;}o = o || [];for (var h = (n = n || []).length; h--;) {if (n[h] === t) return o[h] === r;}if (n.push(t), o.push(r), a) {if ((h = t.length) !== r.length) return !1;for (; h--;) {if (!e(t[h], r[h], n, o)) return !1;}} else {var d,g = We(t);if (h = g.length, We(r).length !== h) return !1;for (; h--;) {if (!T(r, d = g[h]) || !e(t[d], r[d], n, o)) return !1;}}return n.pop(), o.pop(), !0;}(t, r, n, o);}(e, t);}function gt(e) {return null == e || (O(e) && (vt(e) || Et(e) || yt(e)) ? 0 === e.length : 0 === We(e).length);}function pt(e) {return !(!e || 1 !== e.nodeType);}function ft(e) {return function (t) {return u.call(t) === \"[object \" + e + \"]\";};}var vt = h || ft(\"Array\");function _t(e) {var t = _typeof(e);return \"function\" === t || \"object\" === t && !!e;}var yt = ft(\"Arguments\"),mt = ft(\"Function\"),Et = ft(\"String\"),xt = ft(\"Number\"),Rt = ft(\"Date\"),At = ft(\"RegExp\"),Pt = ft(\"Error\"),Vt = ft(\"Symbol\"),Tt = ft(\"Map\"),Ct = ft(\"WeakMap\"),bt = ft(\"Set\"),Lt = ft(\"WeakSet\");!function () {yt(arguments) || (yt = function yt(e) {return T(e, \"callee\");});}();var Ot = n.document && n.document.childNodes;function St(e) {return !Vt(e) && f(e) && !p(parseFloat(e));}function Mt(e) {return xt(e) && p(e);}function wt(e) {return !0 === e || !1 === e || \"[object Boolean]\" === u.call(e);}function Nt(e) {return null === e;}function Ft(e) {return void 0 === e;}function It(e, t) {if (!vt(t)) return T(e, t);for (var r = t.length, n = 0; n < r; n++) {var o = t[n];if (null == e || !l.call(e, o)) return !1;e = e[o];}return !!r;}function Dt(e) {return e;}function jt(e) {return function () {return e;};}function Bt() {}function Ut(e) {return vt(e) ? function (t) {return C(t, e);} : V(e);}function kt(e) {return null == e ? function () {} : function (t) {return vt(t) ? C(e, t) : e[t];};}function Gt(e) {return e = rt({}, e), function (t) {return ht(t, e);};}function zt(e, t, r) {var n = Array(Math.max(0, e));t = m(t, r, 1);for (var o = 0; o < e; o++) {n[o] = t(o);}return n;}function Yt(e, t) {return null == t && (t = e, e = 0), e + Math.floor(Math.random() * (t - e + 1));}\"object\" != (typeof Int8Array === \"undefined\" ? \"undefined\" : _typeof(Int8Array)) && \"function\" != typeof Ot && (mt = function mt(e) {return \"function\" == typeof e || !1;});var Kt = Date.now || function () {return new Date().getTime();},qt = { \"&\": \"&amp;\", \"<\": \"&lt;\", \">\": \"&gt;\", '\"': \"&quot;\", \"'\": \"&#x27;\", \"`\": \"&#x60;\" },Wt = Ze(qt);function Ht(e) {var t = function t(_t3) {return e[_t3];},r = \"(?:\" + We(e).join(\"|\") + \")\",n = RegExp(r),o = RegExp(r, \"g\");return function (e) {return e = null == e ? \"\" : \"\" + e, n.test(e) ? e.replace(o, t) : e;};}var Xt = Ht(qt),Jt = Ht(Wt);function $t(e, t, r) {vt(t) || (t = [t]);var n = t.length;if (!n) return mt(r) ? r.call(e) : r;for (var o = 0; o < n; o++) {var i = null == e ? void 0 : e[t[o]];void 0 === i && (i = r, o = n), e = mt(i) ? i.call(e) : i;}return e;}var Zt = 0;function Qt(e) {var t = ++Zt + \"\";return e ? e + t : t;}var er = _.templateSettings = { evaluate: /<%([\\s\\S]+?)%>/g, interpolate: /<%=([\\s\\S]+?)%>/g, escape: /<%-([\\s\\S]+?)%>/g },tr = /(.)^/,rr = { \"'\": \"'\", \"\\\\\": \"\\\\\", \"\\r\": \"r\", \"\\n\": \"n\", \"\\u2028\": \"u2028\", \"\\u2029\": \"u2029\" },nr = /\\\\|'|\\r|\\n|\\u2028|\\u2029/g,or = function or(e) {return \"\\\\\" + rr[e];};function ir(e, t, r) {!t && r && (t = r), t = at({}, t, _.templateSettings);var n,o = RegExp([(t.escape || tr).source, (t.interpolate || tr).source, (t.evaluate || tr).source].join(\"|\") + \"|$\", \"g\"),i = 0,s = \"__p+='\";e.replace(o, function (t, r, n, o, a) {return s += e.slice(i, a).replace(nr, or), i = a + t.length, r ? s += \"'+\\n((__t=(\" + r + \"))==null?'':_.escape(__t))+\\n'\" : n ? s += \"'+\\n((__t=(\" + n + \"))==null?'':__t)+\\n'\" : o && (s += \"';\\n\" + o + \"\\n__p+='\"), t;}), s += \"';\\n\", t.variable || (s = \"with(obj||{}){\\n\" + s + \"}\\n\"), s = \"var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};\\n\" + s + \"return __p;\\n\";try {n = new Function(t.variable || \"obj\", \"_\", s);} catch (e) {throw e.source = s, e;}var a = function a(e) {return n.call(this, e, _);},c = t.variable || \"obj\";return a.source = \"function(\" + c + \"){\\n\" + s + \"}\", a;}function sr(e) {var t = _(e);return t._chain = !0, t;}function ar(e, t) {return e._chain ? _(t).chain() : t;}function cr(e) {return S(Qe(e), function (t) {var r = _[t] = e[t];_.prototype[t] = function () {var e = [this._wrapped];return a.apply(e, arguments), ar(this, r.apply(_, e));};}), _;}S([\"pop\", \"push\", \"reverse\", \"shift\", \"sort\", \"splice\", \"unshift\"], function (e) {var t = o[e];_.prototype[e] = function () {var r = this._wrapped;return t.apply(r, arguments), \"shift\" !== e && \"splice\" !== e || 0 !== r.length || delete r[0], ar(this, r);};}), S([\"concat\", \"join\", \"slice\"], function (e) {var t = o[e];_.prototype[e] = function () {return ar(this, t.apply(this._wrapped, arguments));};}), _.prototype.value = function () {return this._wrapped;}, _.prototype.valueOf = _.prototype.toJSON = _.prototype.value, _.prototype.toString = function () {return String(this._wrapped);};}.call(this, r(57));}, function (e, t, r) {\"use strict\";e.exports = l;var n = r(21);((l.prototype = Object.create(n.prototype)).constructor = l).className = \"Namespace\";var o,i,s,a = r(22),c = r(5);function u(e, t) {if (e && e.length) {for (var r = {}, n = 0; n < e.length; ++n) {r[e[n].name] = e[n].toJSON(t);}return r;}}function l(e, t) {n.call(this, e, t), this.nested = void 0, this._nestedArray = null;}function h(e) {return e._nestedArray = null, e;}l.fromJSON = function (e, t) {return new l(e, t.options).addJSON(t.nested);}, l.arrayToJSON = u, l.isReservedId = function (e, t) {if (e) for (var r = 0; r < e.length; ++r) {if (\"string\" != typeof e[r] && e[r][0] <= t && e[r][1] >= t) return !0;}return !1;}, l.isReservedName = function (e, t) {if (e) for (var r = 0; r < e.length; ++r) {if (e[r] === t) return !0;}return !1;}, Object.defineProperty(l.prototype, \"nestedArray\", { get: function get() {return this._nestedArray || (this._nestedArray = c.toArray(this.nested));} }), l.prototype.toJSON = function (e) {return c.toObject([\"options\", this.options, \"nested\", u(this.nestedArray, e)]);}, l.prototype.addJSON = function (e) {if (e) for (var t, r = Object.keys(e), n = 0; n < r.length; ++n) {t = e[r[n]], this.add((void 0 !== t.fields ? o.fromJSON : void 0 !== t.values ? s.fromJSON : void 0 !== t.methods ? i.fromJSON : void 0 !== t.id ? a.fromJSON : l.fromJSON)(r[n], t));}return this;}, l.prototype.get = function (e) {return this.nested && this.nested[e] || null;}, l.prototype.getEnum = function (e) {if (this.nested && this.nested[e] instanceof s) return this.nested[e].values;throw Error(\"no such enum: \" + e);}, l.prototype.add = function (e) {if (!(e instanceof a && void 0 !== e.extend || e instanceof o || e instanceof s || e instanceof i || e instanceof l)) throw TypeError(\"object must be a valid nested object\");if (this.nested) {var t = this.get(e.name);if (t) {if (!(t instanceof l && e instanceof l) || t instanceof o || t instanceof i) throw Error(\"duplicate name '\" + e.name + \"' in \" + this);for (var r = t.nestedArray, n = 0; n < r.length; ++n) {e.add(r[n]);}this.remove(t), this.nested || (this.nested = {}), e.setOptions(t.options, !0);}} else this.nested = {};return this.nested[e.name] = e, e.onAdd(this), h(this);}, l.prototype.remove = function (e) {if (!(e instanceof n)) throw TypeError(\"object must be a ReflectionObject\");if (e.parent !== this) throw Error(e + \" is not a member of \" + this);return delete this.nested[e.name], Object.keys(this.nested).length || (this.nested = void 0), e.onRemove(this), h(this);}, l.prototype.define = function (e, t) {if (c.isString(e)) e = e.split(\".\");else if (!Array.isArray(e)) throw TypeError(\"illegal path\");if (e && e.length && \"\" === e[0]) throw Error(\"path must be relative\");for (var r = this; e.length > 0;) {var n = e.shift();if (r.nested && r.nested[n]) {if (!((r = r.nested[n]) instanceof l)) throw Error(\"path conflicts with non-namespace objects\");} else r.add(r = new l(n));}return t && r.addJSON(t), r;}, l.prototype.resolveAll = function () {for (var e = this.nestedArray, t = 0; t < e.length;) {e[t] instanceof l ? e[t++].resolveAll() : e[t++].resolve();}return this.resolve();}, l.prototype.lookup = function (e, t, r) {if (\"boolean\" == typeof t ? (r = t, t = void 0) : t && !Array.isArray(t) && (t = [t]), c.isString(e) && e.length) {if (\".\" === e) return this.root;e = e.split(\".\");} else if (!e.length) return this;if (\"\" === e[0]) return this.root.lookup(e.slice(1), t);var n = this.get(e[0]);if (n) {if (1 === e.length) {if (!t || t.indexOf(n.constructor) > -1) return n;} else if (n instanceof l && (n = n.lookup(e.slice(1), t, !0))) return n;} else for (var o = 0; o < this.nestedArray.length; ++o) {if (this._nestedArray[o] instanceof l && (n = this._nestedArray[o].lookup(e, t, !0))) return n;}return null === this.parent || r ? null : this.parent.lookup(e, t);}, l.prototype.lookupType = function (e) {var t = this.lookup(e, [o]);if (!t) throw Error(\"no such type: \" + e);return t;}, l.prototype.lookupEnum = function (e) {var t = this.lookup(e, [s]);if (!t) throw Error(\"no such Enum '\" + e + \"' in \" + this);return t;}, l.prototype.lookupTypeOrEnum = function (e) {var t = this.lookup(e, [o, s]);if (!t) throw Error(\"no such Type or Enum '\" + e + \"' in \" + this);return t;}, l.prototype.lookupService = function (e) {var t = this.lookup(e, [i]);if (!t) throw Error(\"no such Service '\" + e + \"' in \" + this);return t;}, l._configure = function (e, t, r) {o = e, i = t, s = r;};}, function (e, t, r) {\"use strict\";var n = t,o = r(5),i = [\"double\", \"float\", \"int32\", \"uint32\", \"sint32\", \"fixed32\", \"sfixed32\", \"int64\", \"uint64\", \"sint64\", \"fixed64\", \"sfixed64\", \"bool\", \"string\", \"bytes\"];function s(e, t) {var r = 0,n = {};for (t |= 0; r < e.length;) {n[i[r + t]] = e[r++];}return n;}n.basic = s([1, 5, 0, 0, 0, 5, 5, 0, 0, 0, 1, 1, 0, 2, 2]), n.defaults = s([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, !1, \"\", o.emptyArray, null]), n.long = s([0, 0, 0, 1, 1], 7), n.mapKey = s([0, 0, 0, 5, 5, 0, 0, 0, 1, 1, 0, 2], 2), n.packed = s([1, 5, 0, 0, 0, 5, 5, 0, 0, 0, 1, 1, 0]);}, function (e, t, r) {\"use strict\";Object.defineProperty(t, \"__esModule\", { value: !0 }), t.Curve = void 0;var n = r(1),o = r(43),i = r(0),s = r(3),a = r(2),c = function c() {o.BaseGeometry.call(this), this._subrange = [];};(c.prototype = Object.create(o.BaseGeometry.prototype)).copy = function (e) {o.BaseGeometry.prototype.copy.call(this, e), this._subrange = e.isLimited() ? [e._subrange[0], e._subrange[1]] : [];}, c.prototype.isLimited = function () {return this._subrange.length > 0;}, c.prototype.getRange = function () {return this.isLimited() ? this._subrange : this.getRangeUnlimited();}, c.prototype.getRangeUnlimited = function () {console.warn(\"Curve.getRangeUnlimited : abstract method invoked!\");}, c.prototype.limitRange = function (e) {this._subrange = (0, s.limitRange)(this.getRange(), e, this.isPeriodic(), this.getPeriod());}, c.prototype.unlimitRange = function () {this._subrange = [];}, c.prototype.isPeriodic = function () {return this.isPeriodicUnlimited() && !this.isLimited();}, c.prototype.isPeriodicUnlimited = function () {console.warn(\"Curve.isPeriodicUnlimited : abstract method invoked!\");}, c.prototype.getPeriod = function () {return this.isLimited() ? void 0 : this.getPeriodUnlimited();}, c.prototype.getPeriodUnlimited = function () {if (this.isPeriodicUnlimited()) {var e = this.getRangeUnlimited();return e[1] - e[0];}}, c.prototype.isClosed = function () {if (this.isClosedUnlimited()) {if (this.isLimited()) {var e = this.getRangeUnlimited(),t = e[1] - e[0];return this._subrange[1] - this._subrange[0] > t - i.PARAMETER_SPACE_TOLERANCE;}return !0;}return !1;}, c.prototype.isClosedUnlimited = function () {console.warn(\"Curve.isClosedUnlimited : abstract method invoked!\");}, c.prototype._restrictRangeToUnlimited = function (e) {a.ConsoleUtils.assert(2 === e.length), a.ConsoleUtils.assert(e[0] <= e[1]);var t = this.getRangeUnlimited(),r = [];if (this.isPeriodicUnlimited()) {var o = t[1] - t[0];if (e[1] - e[0] > o - i.PARAMETER_SPACE_TOLERANCE) r.push([t[0], t[1]]);else {var c = (0, s.foldAbove)(e[0], t[0], o) - e[0];r.push([e[0] + c, e[1] + c]), r[0][1] > t[1] + i.PARAMETER_SPACE_TOLERANCE && (r.push([t[0], r[0][1] - o]), r[0][1] = t[1]);}} else {var u = Math.max(e[0], t[0]),l = Math.min(e[1], t[1]);u > t[1] ? u < t[1] + n.FLOAT64_TOLERANCE && r.push([t[1], t[1]]) : l < t[0] ? l > t[0] - n.FLOAT64_TOLERANCE && r.push([t[0], t[0]]) : r.push([u, l]);}return r;}, c.prototype.transform = function (e) {console.warn(\"Curve.transform : abstract method invoked! Doing nothing.\");}, c.prototype.evaluatePosition = function (e) {console.warn(\"Curve.evaluatePosition : abstract method invoked! Returning undefined.\");}, c.prototype.evaluateDt = function (e) {console.warn(\"Curve.evaluateDt : abstract method invoked! Returning undefined.\");}, c.prototype.evaluateCurvature = function (e, t) {var r = this.evaluateDt(e),o = this.evaluateDt(e + i.KERNEL_TOLERANCE);n.Vector3.sub(o, o, r);var s = n.Vector3.createFloat64();n.Vector3.scale(s, o, 1 / i.KERNEL_TOLERANCE), t && (n.Vector3.copy(t, s), n.Vector3.normalize(t, t));var a = n.Vector3.squaredLength(r);return n.Vector3.cross(s, r, s), n.Vector3.length(s) / Math.pow(a, 1.5);}, c.prototype.tangentLength = function (e) {return n.Vector3.length(this.evaluateDt(e));}, c.prototype.suggestSplittingParam = function (e) {console.warn(\"Curve.suggestSplittingParam : abstract method invoked! Returning undefined.\");}, c.prototype.getTangentCone = function (e) {console.warn(\"Curve.getTangentCone : abstract method invoked! Returning undefined.\");}, c.prototype.closestToRayParam = function (e, t, r) {console.warn(\"Curve.closestToRayParam : abstract method invoked! Returning undefined.\");}, c.prototype.closestToPointParam = function (e, t) {console.warn(\"Curve.closestToPointParam : abstract method invoked! Returning undefined.\");}, c.prototype.getArcLength = function (e) {console.warn(\"Curve.getArcLength : abstract method invoked!\");}, c.prototype.getParameterFromArcLength = function (e, t) {console.warn(\"Curve.getParameterFromArcLength : abstract method invoked!\");}, c.prototype.getBoundingBox = function (e) {console.warn(\"Curve.getBoundingBox : abstract method invoked! Returning undefined.\");}, c.prototype.tessellate = function (e, t) {console.warn(\"Curve.tessellate : abstract method invoked! Returning undefined.\");}, t.Curve = c;}, function (e, t, r) {\"use strict\";Object.defineProperty(t, \"__esModule\", { value: !0 }), t.BCurve = void 0;var n = r(1),o = r(4),i = r(34),s = r(0),a = r(32),c = r(7),u = r(3),l = r(35),h = r(2),d = r(8),g = r(50),p = r(36),f = r(17),v = r(37),_ = r(102),y = r(73),m = function m() {a.Curve.call(this), this._controlPoints = [], this._weights = [], this._degree = 0, this._knots = [], this._isRational = void 0, this._isPeriodic = void 0, this._isClosed = void 0, this._isPlanarXY = void 0, this._discretizationCache = void 0, this._segments = void 0, this._hasDirtySegments = !0, this._isDirtyControlPoint = [], this._tessellationCache = new g.TessellationCache();};(m.prototype = Object.create(a.Curve.prototype)).getGeometryType = function () {return s.GEOMETRY_TYPES.BCURVE;}, m.prototype.clone = function () {var e = new m();return e.copy(this), e;}, m.prototype.getControlPointsVector3 = function () {for (var e = new Array(this._controlPoints.length / 3), t = 0; t < this._controlPoints.length / 3; t++) {e[t] = n.Vector3.createFloat64FromValues(this._controlPoints[3 * t], this._controlPoints[3 * t + 1], this._controlPoints[3 * t + 2]);}return e;}, m.prototype.copy = function (e) {a.Curve.prototype.copy.call(this, e), this._isRational = e._isRational, this._weights = e._weights.slice(0), this._degree = e._degree, this._knots = e._knots.slice(0), this._isPeriodic = e._isPeriodic, this._isClosed = e._isClosed, this._weights = e._weights.slice(0), this._controlPoints = e._controlPoints.slice(0), this._isPlanarXY = e._isPlanarXY, this._hasDirtySegments = !0, this._tessellationCache.reset();}, m.prototype.set = function (e, t, r, o) {this.dirtyCurveRepresentation(), this._weights = Array.prototype.slice.call(t), this._degree = r;var i = 0;if (this._isRational = !1, this._weights.length !== t.length) {this._weights = Array.prototype.slice.call(t);var s = this._weights[0];for (i = 1; i < this._weights.length; ++i) {if (Math.abs(this._weights[i] - s) > n.FLOAT64_TOLERANCE) {this._isRational = !0;break;}}} else for (s = this._weights[0], i = 1; i < this._weights.length; ++i) {this._weights[i] = t[i], Math.abs(this._weights[i] - s) > n.FLOAT64_TOLERANCE && (this._isRational = !0);}if (this._knots.length !== o.length) this._knots = Array.prototype.slice.call(o);else for (i = 0; i < this._knots.length; ++i) {this._knots[i] = o[i];}var a = e.length / 3;if (0 === this._weights.length) for (this._weights = new Array(a), i = 0; i < a; ++i) {this._weights[i] = 1;}if (this._controlPoints.length !== e.length) this._controlPoints = Array.prototype.slice.call(e);else for (i = 0; i < e.length; ++i) {this._controlPoints[i] = e[i];}this._isDirtyControlPoint.length !== a && (this._isDirtyControlPoint = new Array(a)), this._isDirtyControlPoint.fill(!1);}, m.prototype.dirtyCurveRepresentation = function () {this._isPlanarXY = void 0, this._isRational = void 0, this._isClosed = void 0, this._isPeriodic = void 0, this._discretizationCache = void 0, this._hasDirtySegments = !0, this._tessellationCache.setDirty(!0);}, m.prototype.hasDirtyTessellation = function () {return this._tessellationCache.isDirty();}, m.prototype.getTessellationCacheTolerance = function () {return this._tessellationCache.getTolerance();}, m.prototype.weightedControlPoints = function () {for (var e = [], t = 0; t < this._controlPoints.length / 3; ++t) {var r = this._weights[t];e.push(this._controlPoints[3 * t] * r, this._controlPoints[3 * t + 1] * r, this._controlPoints[3 * t + 2] * r, r);}return e;}, m.prototype.getControlPoints = function () {return this._controlPoints;}, m.prototype._findChangedControlPoints = function (e) {var t = e.length === this._controlPoints.length;t || (this._isDirtyControlPoint = new Array(e.length / 3), this._isDirtyControlPoint.fill(!0));for (var r = 0; r < e.length / 3; ++r) {if (t) {var n = e[3 * r] - this._controlPoints[3 * r],o = e[3 * r + 1] - this._controlPoints[3 * r + 1],i = e[3 * r + 2] - this._controlPoints[3 * r + 2];n * n + o * o + i * i > s.KERNEL_TOLERANCE * s.KERNEL_TOLERANCE && (this._isDirtyControlPoint[r] = !0);} else this._isDirtyControlPoint[r] = !0;}}, m.prototype.setControlPoints = function (e) {this._findChangedControlPoints(e), this._controlPoints = e, this.dirtyCurveRepresentation();}, m.prototype.copyControlPoints = function (e) {if (this._findChangedControlPoints(e), e !== this._controlPoints) {this._controlPoints.length = e.length;for (var t = 0; t < e.length; ++t) {this._controlPoints[t] = e[t];}}this.dirtyCurveRepresentation();}, m.prototype.transform = function (e) {for (var t = [], r = n.Vector3.createFloat64(), o = 0; o < this._controlPoints.length; o += 3) {n.Vector3.set(r, this._controlPoints[o], this._controlPoints[o + 1], this._controlPoints[o + 2]), n.Vector3.transformMatrix44(r, r, e), t.push(r[0], r[1], r[2]);}this.setControlPoints(t);}, m.prototype.getControlPointPosition = function (e) {return n.Vector3.createFloat64FromValues(this._controlPoints[3 * e], this._controlPoints[3 * e + 1], this._controlPoints[3 * e + 2]);}, m.prototype.extendBBoxFromControlPoints = function (e) {for (var t = n.Vector3.createFloat64(), r = 0; r < this._controlPoints.length; r += 3) {n.Vector3.set(t, this._controlPoints[r], this._controlPoints[r + 1], this._controlPoints[r + 2]), e.includePoint(t);}}, m.prototype.setControlPointPosition = function (e, t, r, n) {this._controlPoints[3 * e] = t, this._controlPoints[3 * e + 1] = r, this._controlPoints[3 * e + 2] = n, this._isDirtyControlPoint[e] = !0, this.dirtyCurveRepresentation();}, m.prototype.getWeights = function () {return this._weights;}, m.prototype.setWeights = function (e) {this._weights = e, this.dirtyCurveRepresentation();}, m.prototype.getKnotVector = function () {return this._knots;}, m.prototype.setKnotVector = function (e) {this._knots = e, this.dirtyCurveRepresentation();}, m.prototype.getDegree = function () {return this._degree;}, m.prototype.isRational = function () {if (void 0 === this._isRational && (this._isRational = !1, this._weights)) for (var e = this._weights[0], t = 0; t < this._weights.length; ++t) {if (Math.abs(this._weights[t] - e) > n.FLOAT64_TOLERANCE) return this._isRational = !0, !0;}return this._isRational;}, m.prototype.isSimpleBezier = function () {return this._knots.length === 2 * this._degree + 2;}, m.prototype.getNumControlPoints = function () {return this._controlPoints.length / 3;}, m.prototype.getTessellationCache = function () {return this._tessellationCache.getCache();}, m.prototype.getEvaluationCache = function () {return void 0 === this._discretizationCache && this.evaluate(), this._discretizationCache;}, m.prototype.getRangeUnlimited = function () {return [this._knots[0], this._knots[this._knots.length - 1]];}, m.prototype.isPeriodicUnlimited = function () {return this._checkClosure(), this._isPeriodic;}, m.prototype.isClosedUnlimited = function () {return this._checkClosure(), this._isClosed;}, m.prototype._checkClosure = function () {if (void 0 === this._isClosed || void 0 === this._isPeriodic) {this._isClosed = this._isPeriodic = !1;var e = this.getRangeUnlimited(),t = this.evaluatePosition(e[0]),r = this.evaluatePosition(e[1]);if (n.Vector3.equals(t, r, s.KERNEL_TOLERANCE)) {this._isClosed = !0;var o = this.evaluateDt(e[0]),i = this.evaluateDt(e[1]);n.Vector3.isParallel(o, i, 1, s.KERNEL_ANGULAR_TOLERANCE) && (this._isPeriodic = !0);}}}, m.prototype.getBezierSegments = function () {return this._decomposeCurve(), this.isSimpleBezier() ? [this] : this._segments;}, m.prototype.isPlanarXY = function () {if (void 0 === this._isPlanarXY) {var e = s.SPLINE_DISTANCE_TOLERANCE;this._isPlanarXY = !0;for (var t = 1 / 0, r = -1 / 0, n = 2; n < this._controlPoints.length; n += 3) {t = Math.min(t, this._controlPoints[n]), r = Math.max(r, this._controlPoints[n]);}Math.abs(r - t) > 2 * e && (this._isPlanarXY = !1);}return this._isPlanarXY;}, m.prototype.getBezierSegmentsInRange = function (e, t) {for (var r = this.getBezierSegments(), n = e || this._knots[0], o = t || this._knots[this._knots.length - 1], i = [], s = 0; s < r.length; ++s) {var a = r[s].getKnotVector();n <= a[a.length - 1] && a[0] >= o && i.push(r[s]);}return i;}, m.prototype.getApproxParameterSpaceTolerance = function () {if (12 === this.getControlPoints().length) return p.SplineCurveHelper.getApproxBezierParameterSpaceTolerance(this.getBoundingBox(), s.KERNEL_TOLERANCE);this._decomposeCurve();for (var e = 0, t = 0; t < this._segments.size(); ++t) {e += p.SplineCurveHelper.getApproxBezierParameterSpaceTolerance(this._segments[t].getBoundingBox(), s.KERNEL_TOLERANCE);}return e;}, m.prototype.getArcLength = function (e) {void 0 === e ? e = this.getRange() : 0 === e.length && (e = this.getRangeUnlimited());for (var t = this._restrictRangeToUnlimited(e), r = 0, o = this.getBezierSegments(), i = 0; i < o.length; ++i) {for (var a = o[i], c = a.getRangeUnlimited(), u = 0; u < t.length; ++u) {var h = [Math.max(c[0], t[u][0]), Math.min(c[1], t[u][1])];h[1] - h[0] > s.PARAMETER_SPACE_TOLERANCE && (r += (0, l.integrateFunction1D)(function (e) {return n.Vector3.length(a.evaluateDt(e));}, h));}}return r;}, m.prototype.getParameterFromArcLength = function (e, t) {void 0 === t ? t = this.getRange() : 0 === t.length && (t = this.getRangeUnlimited());var r = this;return (0, l.invertIntegral1D)(function (e) {return n.Vector3.length(r.evaluateDt(e));}, e, t);}, m.prototype._decomposeCurve = function () {if (this._hasDirtySegments) if (this._hasDirtySegments = !1, this.isSimpleBezier()) this._segments = void 0;else {var e;this._isDirtyControlPoint.length === this.getNumControlPoints() ? e = (0, _.decomposeBCurveFlags)(this.getKnotVector(), this._isDirtyControlPoint) : (this._isDirtyControlPoint = new Array(this.getNumControlPoints()), (e = new Array(this.getNumControlPoints())).fill(!0)), this._isDirtyControlPoint.fill(!1);var t = (0, _.decomposeBCurveToBezier)(this._knots, this._controlPoints, this.isRational() ? this._weights : void 0);this._segments && this._segments.length === t.P.length || (this._segments = []);for (var r = 0; r < t.P.length; ++r) {void 0 === this._segments[r] && (this._segments[r] = new m(), e[r] = !0), e[r] && this._segments[r].set(t.P[r], t.w ? t.w[r] : new Array(2 * this._degree + 2).fill(1), this._degree, t.U[r]);}}}, m.prototype.evaluatePosition = function (e) {this.isPeriodicUnlimited() && (e = (0, u.normalizeParameterToShiftedRange)(e, [this._knots[0], this._knots[this._knots.length - 1]]));var t = this.isRational() ? this._weights : void 0;return (0, v.evaluateBCurvePoint)(e, this._degree, this._knots, this._controlPoints, t);}, m.prototype.evaluateDt = function (e) {this.isPeriodicUnlimited() && (e = (0, u.normalizeParameterToShiftedRange)(e, [this._knots[0], this._knots[this._knots.length - 1]]));var t = this.isRational() ? this._weights : void 0;return (0, v.evaluateBCurveDerivs)(e, 1, this._degree, this._knots, this._controlPoints, t)[1];}, m.prototype.closestToRayParam = function (e, t, r, o) {if (!(this._controlPoints.length < 9)) {if (this.isPlanarXY()) {var i = t[2],a = n.Vector3.createFloat64();if (Math.abs(i) < s.KERNEL_ANGULAR_TOLERANCE) n.Vector3.copy(a, e);else {var c = (this._controlPoints[2] - e[2]) / i;n.Vector3.add(a, n.Vector3.scale(a, t, c), e);}return this.closestToPointParam(a);}d.DebugUtils.warn(\"BCurve.closestToRayParam() only defined for planar curves\");}}, m.prototype.closestToPointParam = function (e, t) {void 0 === t ? t = this.getRange() : 0 === t.length && (t = this.getRangeUnlimited());for (var r = this._restrictRangeToUnlimited(t), o = n.FLOAT64_TOLERANCE, i = this.getBezierSegments(), s = (0, y.closestBCurveSegments)(e, i, void 0, r), a = Number.POSITIVE_INFINITY, c = void 0, l = 0; l < s.length; ++l) {if (!(s[l].minDistSqr > a)) for (var h = i[s[l].index], d = h.getRangeUnlimited(), g = 0; g < r.length; ++g) {var p = [Math.max(d[0], r[g][0]), Math.min(d[1], r[g][1])];if (!(p[1] - p[0] <= n.FLOAT64_TOLERANCE)) {var f = h.getEvaluationCache(),v = (0, u.closestPointToPolyline)(e, f.points, f.offset, p),_ = (0, y.relaxBCurveToPerpendicular)(this._knots, this._controlPoints, this.isRational() ? this._weights : void 0, e, v, p, o, 32),m = h.evaluatePosition(_),E = n.Vector3.squaredDistance(m, e);E < a && (a = E, c = _);var x = h.evaluatePosition(p[0]),R = n.Vector3.squaredDistance(x, e);R < a && (a = R, c = p[0]);var A = h.evaluatePosition(p[1]),P = n.Vector3.squaredDistance(A, e);P < a && (a = P, c = p[1]);}}}return this.isPeriodicUnlimited() && (c = (0, u.foldNearTo)(c, .5 * (t[0] + t[1]), this.getPeriodUnlimited())), c;}, m.prototype.evaluate = function () {var e = this.getBezierSegments();if (e[0] === this) void 0 === this._discretizationCache && (this._discretizationCache = p.SplineCurveHelper.evaluateCurve(this.getDegree(), this.getKnotVector(), this.getControlPoints(), this.getWeights(), !0));else for (var t = 0; t < e.length; ++t) {var r = e[t];void 0 === r._discretizationCache && (r._discretizationCache = p.SplineCurveHelper.evaluateCurve(r.getDegree(), r.getKnotVector(), r.getControlPoints(), r.getWeights(), !0));}}, m.prototype._getFullTessellation = function (e) {var t,r,o = this.getBezierSegments(),i = 0,s = !1;if (o[0] === this) {s = !0;var a = g.CurveTessellator.getAdaptiveRenderPoints(this, e, this.getRangeUnlimited());t = a.positions, r = a.params, i = Math.max(i, a.tolerance);} else {t = [], r = [];for (var c = 0; c < o.length; ++c) {var u = o[c];if (u.hasDirtyTessellation() || u.getTessellationCacheTolerance() > e + n.FLOAT64_TOLERANCE) {s = !0;var l = g.CurveTessellator.getAdaptiveRenderPoints(u, e, u.getRangeUnlimited());u._tessellationCache.setCache(l), i = Math.max(i, l.tolerance);}u._tessellationCache && (0 === c ? (t.push.apply(t, u._tessellationCache.getCache().positions), r.push.apply(r, u._tessellationCache.getCache().params)) : (t.push.apply(t, u._tessellationCache.getCache().positions.slice(1)), r.push.apply(r, u._tessellationCache.getCache().params.slice(1))));}}return { positions: t, params: r, didRetessellate: s, tolerance: i };}, m.prototype.tessellate = function (e, t) {return t = t || s.TESSELLATION.LINEAR_PRECISION, this._tessellationCache.getTessellation(e, this, t, this._getFullTessellation.bind(this));}, m.prototype.getBoundingBox = function (e) {void 0 === e ? e = this.getRange() : 0 === e.length && (e = this.getRangeUnlimited());var t = this._restrictRangeToUnlimited(e),r = new o.BoundingBox(),n = this.getRangeUnlimited();if (t[0][0] < n[0] + s.PARAMETER_SPACE_TOLERANCE && t[0][1] > n[1] - s.PARAMETER_SPACE_TOLERANCE) this.extendBBoxFromControlPoints(r);else for (var i = this.getBezierSegments(), a = 0; a < t.length; a++) {for (var c = 0; c < i.length; c++) {var u = i[c];(u = u._getSubset(t[a][0], t[a][1])) && u.extendBBoxFromControlPoints(r);}}return r;}, m.prototype.getTangentCone = function (e) {void 0 === e ? e = this.getRange() : 0 === e.length && (e = this.getRangeUnlimited());var t = this.evaluatePosition(e[0]),r = this.evaluatePosition(e[1]);n.Vector3.sub(r, r, t), n.Vector3.squaredLength(r) < .01 * s.KERNEL_TOLERANCE * s.KERNEL_TOLERANCE && (r = this.evaluateDt(.5 * (e[0] + e[1]))), n.Vector3.normalize(r, r);for (var o = new i.TangentCone(r, 0), a = this._restrictRangeToUnlimited(e), c = n.Vector3.createFloat64FromValues(0, 0, 0), u = this.getBezierSegments(), l = 0; l < a.length; l++) {for (var h = 0; h < u.length; h++) {var d = u[h];if (d = d._getSubset(a[l][0], a[l][1])) for (var g = d._controlPoints, p = 0; p < g.length - 3; p += 3) {c[0] = g[p + 3] - g[p], c[1] = g[p + 4] - g[p + 1], c[2] = g[p + 5] - g[p + 2], n.Vector3.dot(c, r) >= 0 ? o.includeVector(c) : o.angle = Math.PI;}}}return o;}, m.prototype._getSubset = function (e, t) {var r;if (this.isPeriodicUnlimited()) return t - e > this.getPeriodUnlimited() - s.PARAMETER_SPACE_TOLERANCE ? this : ((r = this.clone())._periodicTrimToParams(e, t), r);var n = this.getRangeUnlimited();return e > n[1] - s.PARAMETER_SPACE_TOLERANCE || t < n[0] + s.PARAMETER_SPACE_TOLERANCE ? void 0 : e < n[0] + s.PARAMETER_SPACE_TOLERANCE && t > n[1] - s.PARAMETER_SPACE_TOLERANCE ? this : (r = this.clone(), e > n[0] + s.PARAMETER_SPACE_TOLERANCE && r.trimToParam(!0, e), t < n[1] - s.PARAMETER_SPACE_TOLERANCE && r.trimToParam(!1, t), r);}, m.prototype._periodicTrimToParams = function (e, t) {h.ConsoleUtils.assert(this._isPeriodic);var r = this.getRangeUnlimited(),n = (0, u.normalizeParametricRangeToShiftedRange)([e, t], r);if (n[1] > r[1]) this._isClosed = this._isPeriodic = !1, this.trimToParam(!0, n[1] - (r[1] - r[0]), void 0), this.trimToParam(!1, n[0], void 0);else {var o,i,s = this.getControlPoints(),a = this.getKnotVector(),c = this.getWeights(),l = this.getDegree(),d = this.getPeriodUnlimited(),g = [],f = a.slice(),v = a.slice(),_ = [];for (i = 0; i < s.length / 3; ++i) {g[4 * i + 0] = s[3 * i + 0] * c[i], g[4 * i + 1] = s[3 * i + 1] * c[i], g[4 * i + 2] = s[3 * i + 2] * c[i], g[4 * i + 3] = c[i];}for (o = g.slice(), p.SplineCurveHelper.extractCurveSegment(l, n[1], r[1], f, g), p.SplineCurveHelper.extractCurveSegment(l, r[0], n[0], v, o), i = 0; i < v.length; ++i) {v[i] = v[i] + d;}p.SplineCurveHelper.joinCurves(l, f, g, v, o);var y = g.length / 4,m = [];for (_.length = y, m.length = 3 * y, i = 0; i < y; ++i) {var E = g[4 * i + 3];m[3 * i] = g[4 * i] / E, m[3 * i + 1] = g[4 * i + 1] / E, m[3 * i + 2] = g[4 * i + 2] / E, _[i] = E;}this.set(m, _, l, f), this._isClosed = this._isPeriodic = !1;}}, m.prototype.trimToParam = function (e, t, r) {if (this.isPeriodicUnlimited()) return h.ConsoleUtils.assert(void 0 !== r), void this._periodicTrimToParams(t, r);var n,o,i = this.getControlPoints(),s = this.getKnotVector(),a = this.getWeights(),c = this.getDegree(),u = [];for (n = 0; n < i.length / 3; ++n) {u[4 * n + 0] = i[3 * n + 0] * a[n], u[4 * n + 1] = i[3 * n + 1] * a[n], u[4 * n + 2] = i[3 * n + 2] * a[n], u[4 * n + 3] = a[n];}var l = [],d = 0,g = p.SplineCurveHelper.insertKnot(c, s, u, t, c),v = (0, f.findKnotSpan)(t, g.U);for (e ? (g.U.splice(0, v - c + 1, t), o = g.U.length - c - 1, d = 4 * (g.Pw.length / 4 - o)) : (g.U.splice(v + 1, g.U.length, t), o = g.U.length - c - 1), u.length = 3 * o, l.length = o, n = 0; n < o; ++n) {var _ = g.Pw[4 * n + 3 + d];u[3 * n] = g.Pw[4 * n + 0 + d] / _, u[3 * n + 1] = g.Pw[4 * n + 1 + d] / _, u[3 * n + 2] = g.Pw[4 * n + 2 + d] / _, l[n] = _;}this.set(u, l, c, g.U);}, m.prototype.addControlPoint = function (e, t) {var r = this.getControlPoints(),o = this.getNumControlPoints(),i = this.getKnotVector(),a = this.getWeights(),u = this.getDegree(),l = this.getControlPointPosition(e),h = this.getControlPointPosition(e + 1),d = new c.Line();d.setFromEndpoints(l, h);var g = d.closestToPointParam(t),f = d.evaluatePosition(g),v = n.Vector3.distance(f, l),_ = n.Vector3.distance(f, h),y = a[e] * v + a[e + 1] * _;if (Math.abs(y) < s.KERNEL_TOLERANCE) console.warn(\"numerical error in addControlPoints -- coincident control points / negative weights?\");else {for (var m = a[e] * v / y, E = i[e + 1] + m * (i[e + u + 1] - i[e + 1]), x = [], R = 0; R < r.length / 3; ++R) {x[4 * R] = r[3 * R] * a[R], x[4 * R + 1] = r[3 * R + 1] * a[R], x[4 * R + 2] = r[3 * R + 2] * a[R], x[4 * R + 3] = a[R];}var A = p.SplineCurveHelper.findKnotMultiplicity(E, i),P = p.SplineCurveHelper.insertKnot(u, i, x, E, A + 1),V = [];for (x.length = 3 * (o + 1), V.length = o + 1, R = 0; R <= o; ++R) {var T = P.Pw[4 * R + 3];x[3 * R] = P.Pw[4 * R] / T, x[3 * R + 1] = P.Pw[4 * R + 1] / T, x[3 * R + 2] = P.Pw[4 * R + 2] / T, V[R] = T;}this.set(x, V, u, P.U);}}, m.prototype.addControlPointOnCurve = function (e) {for (var t = this.getNumControlPoints(), r = Number.MAX_VALUE, o = -1, i = n.Vector3.createFloat64FromValues(0, 0, 0), s = n.Vector3.createFloat64FromValues(0, 0, 0), a = 0; a < t - 1; ++a) {i[0] = this._controlPoints[3 * a + 0], i[1] = this._controlPoints[3 * a + 1], s[0] = this._controlPoints[3 * a + 3], s[1] = this._controlPoints[3 * a + 4];var c = (0, u.distancePointToLineSegment)(i, s, e);c < r && (r = c, o = a);}-1 !== o && this.addControlPoint(o, e);}, m.prototype.makePeriodic = function () {if (!this.isPeriodicUnlimited()) {for (var e = this.getControlPoints(), t = this.getKnotVector(), r = this.getWeights(), n = this.getDegree(), o = [], i = 0; i < e.length / 3; ++i) {o[4 * i] = e[3 * i] * r[i], o[4 * i + 1] = e[3 * i + 1] * r[i], o[4 * i + 2] = e[3 * i + 2] * r[i], o[4 * i + 3] = r[i];}var s = t.slice();p.SplineCurveHelper.makePeriodic(n, s, o);var a = [],c = [],u = o.length / 4;for (a.length = u, c.length = 3 * u, i = 0; i < u; ++i) {var l = o[4 * i + 3];c[3 * i] = o[4 * i] / l, c[3 * i + 1] = o[4 * i + 1] / l, c[3 * i + 2] = o[4 * i + 2] / l, a[i] = l;}this.set(c, a, n, s), this._isClosed = this._isPeriodic = !0;}}, m.prototype.suggestSplittingParam = function (e) {var t,r = this.getKnotVector(),n = .5 * (e[0] + e[1]),o = (0, u.sortedIndex)(r, n);if (0 === o) t = r[o];else if (o === r.length) t = r[o - 1];else {var i = r[o - 1],s = r[o];t = n - i < s - n ? i : s;}return t >= e[0] && t <= e[1] ? t : void 0;}, m.prototype.toObject = function () {return { degree: this._degree, knots: this._knots, controlPoints: this._controlPoints, weights: this._weights, range: this.rangeToObject(this.getRange(), this.isLimited()) };}, t.BCurve = m;}, function (e, t, r) {\"use strict\";Object.defineProperty(t, \"__esModule\", { value: !0 }), t.TangentCone = void 0;var n = r(1),o = r(0),i = r(3),s = function s(e, t) {this.set(e, t);};s.prototype.set = function (e, t) {void 0 === e || void 0 === t ? (this.axis = void 0, this.angle = void 0) : (this.axis = n.Vector3.clone(e), this.angle = t);}, s.prototype.toString = function () {return this.isDegenerate() ? \"degenerate\" : \"(x:\" + this.axis[0] + \", y:\" + this.axis[1] + \", z:\" + this.axis[2] + \", radians:\" + this.angle + \")\";}, s.prototype.copy = function (e) {return e.isDegenerate() ? (this.axis = void 0, this.angle = void 0) : (this.axis = n.Vector3.clone(e.axis), this.angle = e.angle), this;}, s.prototype.clone = function () {return new s(this.axis, this.angle);}, s.prototype.isDegenerate = function () {return void 0 === this.axis || void 0 === this.angle;}, s.prototype.includeVector = function (e) {if (n.Vector3.squaredLength(e) < o.KERNEL_TOLERANCE * o.KERNEL_TOLERANCE) return this;if (this.isDegenerate()) return this.axis || (this.axis = n.Vector3.createFloat64()), n.Vector3.normalize(this.axis, e), this.angle = 0, this;var t = n.Vector3.dot(this.axis, e) / n.Vector3.length(e);t = (0, i.clamp)(t, -1, 1);var r = Math.acos(t);return this.angle = Math.max(this.angle, r), this;}, s.prototype.includeCone = function (e) {if (e.isDegenerate()) return this;if (this.isDegenerate()) return this.copy(e);var t = n.Vector3.dot(this.axis, e.axis),r = Math.acos((0, i.clamp)(t, -1, 1));if (this.angle >= e.angle + r) return this;if (e.angle >= this.angle + r) return this.copy(e);if (r > Math.PI - o.KERNEL_ANGULAR_TOLERANCE) return this.angle = Math.PI, this;var s = (this.angle + e.angle + r) / 2;if (s >= Math.PI) return this.angle = Math.PI, this;var a = Math.sin(s - e.angle),c = Math.sin(s - this.angle);return n.Vector3.scale(this.axis, this.axis, a), n.Vector3.scaleAndAdd(this.axis, this.axis, e.axis, c), n.Vector3.normalize(this.axis, this.axis), this.angle = s, this;}, s.prototype.contains = function (e, t) {if (t = \"number\" == typeof t ? t : o.KERNEL_ANGULAR_TOLERANCE, !this.isDegenerate()) return n.Vector3.squaredLength(e) < o.KERNEL_TOLERANCE * o.KERNEL_TOLERANCE || n.Vector3.angle(this.axis, e) < this.angle + t;}, t.TangentCone = s;}, function (e, t, r) {\"use strict\";Object.defineProperty(t, \"__esModule\", { value: !0 }), t.invertIntegral1D = t.integrateFunction1D = t.newtonRaphson1D = void 0;var n = r(0),o = r(3),i = r(8),s = function () {var e = [.9914553711208126, .9491079123427585, .8648644233597691, .7415311855993945, .5860872354676911, .4058451513773972, .20778495500789848, 0],t = [.022935322010529224, .06309209262997856, .10479001032225019, .14065325971552592, .1690047266392679, .19035057806478542, .20443294007529889, .20948214108472782],r = [.1294849661688697, .27970539148927664, .3818300505051189, .4179591836734694];return function (o, a, c) {var u = function (n, o, i) {for (var s = .5 * (o + i), a = .5 * (i - o), c = n(s), u = c * t[7], l = c * r[3], h = 0; h < 7; ++h) {var d = a * e[h],g = n(s - d) + n(s + d);u += g * t[h], h % 2 == 1 && (l += g * r[Math.floor(h / 2)]);}var p = 200 * Math.abs(u - l) * a;return { length: u * a, error: p *= Math.sqrt(p) };}(o, a[0], a[1]);if (void 0 === c) c = 0;else if (c > 8) return i.DebugUtils.warn(\"Max depth reached in integrateFunction1D!\"), u.length;if (u.error > n.KERNEL_TOLERANCE) {var l = .5 * (a[0] + a[1]);return s(o, [a[0], l], c + 1) + s(o, [l, a[1]], c + 1);}return u.length;};}();t.newtonRaphson1D = function (e, t, r, n, s) {var a,c = r;t && (c = (0, o.clamp)(c, t[0], t[1]));var u = 0;do {++u;var l = e(c),h = c - l.val / l.deriv;t && (h = (0, o.clamp)(h, t[0], t[1])), a = Math.abs(h - c), c = h;} while (a > n && u < s);return u >= s && i.DebugUtils.warn(\"Maximum number of iterations reached. Something wrong is going on here !!!\"), c;}, t.integrateFunction1D = s, t.invertIntegral1D = function (e, t, r) {var i = n.KERNEL_TOLERANCE,a = s(e, r);if (t < i) return r[0];if (t > a - i) return r[1];for (var c = r[0], u = r[1], l = t; u - c > n.PARAMETER_SPACE_TOLERANCE;) {var h = l / a,d = c + (h = (0, o.clamp)(h, .01, .99)) * (u - c),g = s(e, [c, d]),p = a - (g = (0, o.clamp)(g, 0, a));if (Math.abs(l - g) < i) return d;g > l ? (u = d, a = g) : (c = d, l -= g, a = p);}return .5 * (c + u);};}, function (e, t, r) {\"use strict\";Object.defineProperty(t, \"__esModule\", { value: !0 }), t.SplineCurveHelper = void 0;var n = r(1),o = r(0),i = r(3),s = r(8),a = r(17),c = r(37),u = r(72),l = function l() {};l.getApproxBezierParameterSpaceTolerance = function (e, t) {var r = e.getDiagonal(),i = 2 * t / n.Vector3.length(r);return i < .01 * o.PARAMETER_SPACE_TOLERANCE ? .01 * o.PARAMETER_SPACE_TOLERANCE : i;}, l.solve_cubic_uniqueRoots = function (e, t) {var r = e[2] * e[2] - 3 * e[1],n = e[2] * (2 * e[2] * e[2] - 9 * e[1]) + 27 * e[0];if (0 === n && 0 === r) return t[0] = -e[2] / 3, 1;if (n * n / 4 < r * r * r) {var o = -2 * Math.sqrt(r),i = Math.acos(-n / (r * o));return t[0] = (o * Math.cos(i / 3) - e[2]) / 3, t[1] = (o * Math.cos((i + 2 * Math.PI) / 3) - e[2]) / 3, t[2] = (o * Math.cos((i - 2 * Math.PI) / 3) - e[2]) / 3, 3;}var s = Math.pow(Math.abs(n) / 2 + Math.sqrt(n * n / 4 - r * r * r), 1 / 3) / 3;return n > 0 && (s = -s), t[0] = s + r / (9 * s) - e[2] / 3, 1;};var h = function h(e, t, r) {return 6 * ((1 - r) * (e[6 + t] - 2 * e[3 + t] + e[t]) + r * (e[9 + t] - 2 * e[6 + t] + e[3 + t]));},d = function d(e, t) {return 6 * (e[9 + t] - e[t] + 3 * (e[3 + t] - e[6 + t]));},g = function g(e, t) {var r = new Array(3);!function (e, t, r) {r[0] = 3 * (e[3 + t] - e[t]), r[1] = 6 * (e[t] + e[6 + t] - 2 * e[3 + t]), r[2] = 3 * (e[9 + t] - e[t] + 3 * (e[3 + t] - e[6 + t]));}(e, t, r);var n,o = new Array(2),i = function (e, t) {var r = e[1] * e[1] - 4 * e[2] * e[0];if (r < 0) return 0;if (0 === r) return t[0] = -.5 * e[1] / e[2], 1;var n = e[1] > 0 ? -.5 * (e[1] + Math.sqrt(r)) : -.5 * (e[1] - Math.sqrt(r));return t[0] = n / e[2], t[1] = e[0] / n, 2;}(r, o);2 === i && o[0] > o[1] && (n = o[0], o[0] = o[1], o[1] = n);for (var s = [], a = 0; a < i; a++) {o[a] > 0 && o[a] < 1 && ((n = Math.abs(h(e, t, o[a])) < 1e-12) ? (n = Math.abs(d(e, t)) < 1e-12) && s.push(o[a]) : s.push(o[a]));}return s;},p = function p(e, t, r) {return e + t[0] + t[1] * r + t[2] * r * r + t[3] * r * r * r;};l.intersect_xAxis_NonRationalCubicBSpline_XYPlanar3D = function (e, t, r, n) {var i = new Float64Array(4),s = new Float64Array(4);i[0] = t[0] - e[0], i[1] = 3 * (t[3] - t[0]), i[2] = 3 * (t[0] + t[6] - 2 * t[3]), i[3] = t[9] - t[0] + 3 * (t[3] - t[6]), s[0] = t[1] - e[1], s[1] = 3 * (t[4] - t[1]), s[2] = 3 * (t[1] + t[7] - 2 * t[4]), s[3] = t[10] - t[1] + 3 * (t[4] - t[7]);var a,c = s;if (Math.abs(c[3]) > 1e-4) c[0] /= c[3], c[1] /= c[3], c[2] /= c[3], c[3] = 1, a = this.solve_cubic_uniqueRoots(c, r);else {var l = [].slice.call(c).reverse();0 === l[0] && (l = l.slice(1));var h = (0, u.getRealPolynomialRoots)(l);a = h.length;for (var d = 0; d < a; d++) {r[d] = h[d];}}if (1 === a) return (f = r[0]) < 0 || f > 1 ? 0 : (r[0] = p(e[0], i, f), 1);d = 0;for (var g = 0; g < a; ++g) {(f = r[g]) >= 0 && f <= 1 && (r[d] = p(e[0], i, f), ++d);}if (void 0 !== n) {var f, v;if (Math.abs(s[3]) < 1e-12) Math.abs(s[2]) < 1e-12 ? v = -1 : (f = -s[1] / (2 * s[2]), v = 0);else {var _ = 2 / 3 * s[2] / s[3];v = _ * _ / 4 - 1 / 3 * s[1] / s[3], f = -_ / 2;}if (0 === v) {if (f < 0 || f > 1) {var y = p(e[0], s, 0),m = p(e[0], s, 1);Math.abs(y) > Math.abs(m) ? n.push([p(e[0], i, 0), y]) : n.push([p(e[0], i, 1), m]);} else n.push([p(e[0], i, f), p(e[0], s, f)]);} else if (v > 0) {for (g = 0; g < 2; g++) {(f = -_ / 2 + (0 === g ? -1 : 1) * Math.sqrt(v)) < -o.PARAMETER_SPACE_TOLERANCE || f > 1 + o.PARAMETER_SPACE_TOLERANCE || (f = Math.max(Math.min(1, f), 0), n.push([p(e[0], i, f), p(e[0], s, f)]));}if (n.length > 1 && n[0][0] > n[1][0]) {var E = n[0];n[0] = n[1], n[1] = E;}}}return d;}, l.isPointInsideSplineRegionXYPlanar3D = function (e, t, r) {var o,s,a = new Float64Array(3),c = t.getBezierSegments();if (t.isRational() || !c || 3 !== t.getDegree()) {for (var u = t.tessellate().positions, l = new Float64Array(2 * u.length), h = 0; h < u.length; ++h) {l[2 * h] = u[h].x, l[2 * h + 1] = u[h].y;}return (0, i.isPointInsidePolygon2D)(e, l);}var d,g = 0,p = n.Vector3.createFloat64();for (h = 0; h < c.length; ++h) {s = c[h].getControlPoints(), o = this.intersect_xAxis_NonRationalCubicBSpline_XYPlanar3D(e, s, a);for (var f = 0; f < o; ++f) {n.Vector3.set(p, a[f], e[1], 0), (d = t.closestToPointParam(p)) >= r[0] && d <= r[1] && a[f] > e[0] && ++g;}}var v = t.evaluatePosition(r[0]),_ = t.evaluatePosition(r[1]),y = n.Vector3.createFloat64();n.Vector3.normalize(y, n.Vector3.sub(y, _, v)), y[1] < 0 && n.Vector3.negate(y, y);var m = n.Vector2.createFloat64FromValues(e[0], e[1]);return (0, i.signedDistanceTo2DLine)(v, y, m) <= 0 && e[1] >= Math.min(v[1], _[1]) && e[1] <= Math.max(v[1], _[1]) && ++g, 1 & g;}, l.insertKnot = function (e, t, r, n, o) {var i,s,c,u = [],l = [],h = [],d = r.length / 4,g = d + e + 1,p = (0, a.findKnotSpanAndMultiplicity)(n, t),f = o - p.multiplicity;if (f < 1) return { U: u = t.slice(), Pw: l = r.slice() };for (i = 0; i <= p.span; ++i) {u[i] = t[i];}for (i = 1; i <= f; ++i) {u[p.span + i] = n;}for (i = p.span + 1; i < g; ++i) {u[i + f] = t[i];}for (i = 0; i <= p.span - e; ++i) {for (s = 0; s < 4; ++s) {l[4 * i + s] = r[4 * i + s];}}for (i = p.span - p.multiplicity; i < d; ++i) {for (s = 0; s < 4; ++s) {l[4 * (i + f) + s] = r[4 * i + s];}}for (i = 0; i <= e - p.multiplicity; ++i) {for (s = 0; s < 4; ++s) {h[4 * i + s] = r[4 * (p.span - e + i) + s];}}for (var v = 1; v <= f; ++v) {for (c = p.span - e + v, i = 0; i <= e - v - p.multiplicity; ++i) {var _ = (n - t[c + i]) / (t[i + p.span + 1] - t[c + i]);for (s = 0; s < 4; ++s) {h[4 * i + s] = h[4 * (i + 1) + s] * _ + h[4 * i + s] * (1 - _);}}for (s = 0; s < 4; ++s) {l[4 * c + s] = h[s], l[4 * (p.span + f - v - p.multiplicity) + s] = h[4 * (e - v - p.multiplicity) + s];}}for (i = c + 1; i < p.span - p.multiplicity; ++i) {for (s = 0; s < 4; ++s) {l[4 * i + s] = h[4 * (i - c) + s];}}return { U: u, Pw: l };}, l.refineKnotVector = function (e, t, r, n) {var i,s,c = [],u = [],l = r.length / 4 - 1,h = n.length - 1,d = l + e + 1,g = (0, a.findKnotSpan)(n[0], t),p = (0, a.findKnotSpan)(n[h], t) + 1;for (i = 0; i <= g - e; ++i) {for (s = 0; s < 4; ++s) {u[4 * i + s] = r[4 * i + s];}}for (i = p - 1; i <= l; ++i) {for (s = 0; s < 4; ++s) {u[4 * (i + h + 1) + s] = r[4 * i + s];}}for (i = 0; i <= g; ++i) {c[i] = t[i];}for (i = p + e; i <= d; ++i) {c[i + h + 1] = t[i];}var f = p + e - 1,v = p + e + h;for (i = h; i >= 0; --i) {for (; n[i] <= t[f] && f > g;) {for (s = 0; s < 4; ++s) {u[4 * (v - e - 1) + s] = r[4 * (f - e - 1) + s];}c[v] = t[f], --v, --f;}for (s = 0; s < 4; ++s) {u[4 * (v - e - 1) + 1] = u[4 * (v - e) + s];}for (var _ = 1; _ <= e; ++_) {var y = v - e + _,m = c[v + _] - n[i];if (Math.abs(m) < o.KERNEL_TOLERANCE) for (s = 0; s < 4; ++s) {u[4 * (y - 1) + s] = u[4 * y + s];} else for (m /= c[v + _] - t[f - e + _], s = 0; s < 4; ++s) {u[4 * (y - 1) + s] = u[4 * (y - 1) + s] * m + u[4 * y + s] * (1 - m);}}c[v] = n[i], --v;}return { U: c, Pw: u };};var f = function f(e, t, r, o) {var s = (0, i.projectPointToLineSegment)(t, r, e);return o && (s = (0, i.clamp)(s, 0, 1)), n.Vector3.lerp(n.Vector3.createFloat64(), t, r, s);};l.validControlPolygon = function (e) {for (var t = e.length / 3, r = e.length, o = n.Vector3.createFloat64(), i = n.Vector3.createFloat64(), s = n.Vector3.createFloat64(), a = 3, c = 1; c < t - 1; ++c) {n.Vector3.set(o, e[a], e[a + 1], e[a + 2]), n.Vector3.set(i, e[a - 3], e[a - 2], e[a - 1]), n.Vector3.set(s, e[a + 3], e[a + 4], e[a + 5]);var u = f(o, i, s, !1);if (n.Vector3.sub(o, o, u), c < t / 2 ? n.Vector3.sub(i, [e[r - 3], e[r - 2], e[r - 1]], u) : n.Vector3.sub(i, [e[0], e[1], e[2]], u), n.Vector3.dot(o, i) > 0) return !1;a += 3;}return !0;};var v = function v(e) {if (e) for (var t = 0; t < e.length; ++t) {if (Math.abs(e[t] - 1) > n.FLOAT64_TOLERANCE) return !0;}return !1;},_ = function () {var e = new Float64Array(4),t = new Float64Array(4),r = new Float64Array(4),n = new Float64Array(16);return function (o, i, s, a, c) {var u,l,h,d,g,p,f = 1 - s;if (e[0] = f * f * f, e[1] = 3 * s * f * f, e[2] = 3 * s * s * f, e[3] = s * s * s, t[0] = -3 * f * f, t[1] = 3 * (s - 1) * (3 * s - 1), t[2] = 3 * s * (2 - 3 * s), t[3] = 3 * s * s, r[0] = 6 * f, r[1] = 6 * (3 * s - 2), r[2] = 6 * (1 - 3 * s), r[3] = 6 * s, void 0 === c ? v(i) : c) {for (var _ = 0; _ < 4; ++_) {n[4 * _ + a] = o[3 * _ + a] * i[_], n[4 * _ + 3] = i[_];}for (u = n[a] * e[0], l = n[a] * t[0], h = n[a] * r[0], _ = 1; _ < 4; ++_) {u += n[4 * _ + a] * e[_], l += n[4 * _ + a] * t[_], h += n[4 * _ + a] * r[_];}for (d = n[3] * e[0], g = n[3] * t[0], p = n[3] * r[0], _ = 1; _ < 4; ++_) {d += n[4 * _ + 3] * e[_], g += n[4 * _ + 3] * t[_], p += n[4 * _ + 3] * r[_];}u /= d, l /= g, h /= p;} else for (u = o[a] * e[0], l = o[a] * t[0], h = o[a] * r[0], _ = 1; _ < 4; ++_) {u += o[3 * _ + a] * e[_], l += o[3 * _ + a] * t[_], h += o[3 * _ + a] * r[_];}return [u, l, h];};}(),y = function y(e, t, r, n) {var o = n;o[0] = r[0] - t[0], o[1] = r[1] - t[1];var i = o[0] * o[0] + o[1] * o[1],s = (e[0] - t[0]) * o[0] + (e[1] - t[1]) * o[1];if (0 === i || s <= 0) n[0] = e[0] - t[0], n[1] = e[1] - t[1], n[1] = n[0] * n[0] + n[1] * n[1], n[0] = 0;else if (s > i) n[0] = e[0] - r[0], n[1] = e[1] - r[1], n[1] = n[0] * n[0] + n[1] * n[1], n[0] = 1;else {var a = s / i;n[0] = t[0] + a * o[0] - e[0], n[1] = t[1] + a * o[1] - e[1], n[1] = n[0] * n[0] + n[1] * n[1], n[0] = a;}},m = function m(e, t, r, n) {var o = n;o[0] = r[0] - t[0], o[1] = r[1] - t[1], o[2] = r[2] - t[2];var i = o[0] * o[0] + o[1] * o[1] + o[2] * o[2],s = (e[0] - t[0]) * o[0] + (e[1] - t[1]) * o[1] + (e[2] - t[2]) * o[2];if (0 === i || s <= 0) n[0] = e[0] - t[0], n[1] = e[1] - t[1], n[2] = e[2] - t[2], n[1] = n[0] * n[0] + n[1] * n[1] + n[1] * n[1], n[0] = 0;else if (s > i) n[0] = e[0] - r[0], n[1] = e[1] - r[1], n[2] = e[2] - r[2], n[1] = n[0] * n[0] + n[1] * n[1] + n[1] * n[1], n[0] = 1;else {var a = s / i;n[0] = t[0] + a * o[0] - e[0], n[1] = t[1] + a * o[1] - e[1], n[2] = t[2] + a * o[2] - e[2], n[1] = n[0] * n[0] + n[1] * n[1] + n[2] * n[2], n[0] = a;}};l.closestStartPoint = function () {var e,t,r,n,o = new Float64Array(3),i = new Float64Array(3),s = new Float64Array(3),a = new Float64Array(2);return function (c, u, l, h) {if (l) for (a[0] = 0, a[1] = 1 / 0, r = u.points.length, n = 0; n < r - 3; n += 3) {o[0] = u.points[n], o[1] = u.points[n + 1], i[0] = u.points[n + 3], i[1] = u.points[n + 4], y(c, o, i, s), s[1] < a[1] && (e = n / 3, t = (1 - s[0]) * u.offset[e] + s[0] * u.offset[e + 1], (!h || t >= h[0] && t <= h[1]) && (a[0] = t, a[1] = s[1]));} else for (a[1] = 1 / 0, r = u.points.length, n = 0; n < r - 3; n += 3) {o[0] = u.points[n], o[1] = u.points[n + 1], o[2] = u.points[n + 2], i[0] = u.points[n + 3], i[1] = u.points[n + 4], i[2] = u.points[n + 5], m(c, o, i, s), s[1] < a[1] && (e = n / 3, t = (1 - s[0]) * u.offset[e] + s[0] * u.offset[e + 1], (!h || t >= h[0] && t <= h[1]) && (a[0] = t, a[1] = s[1]));}return a[0];};}(), l.extremalParams = function (e, t) {if (3 !== e.getDegree()) return s.DebugUtils.warn(\"SplineCurveHelper.extremalParams called with non-degree 3 curve\"), [];var r,i,a = e.getBezierSegments(),c = [];for (r = 0; r < a.length; ++r) {var u = a[r].getControlPoints(),h = a[r].getWeights(),d = a[r].getKnotVector(),g = l.extremalParamsXYPlanarBezierCurve(u, h, t),p = [];for (i = 0; i < g.length; i++) {p.push(d[0] * (1 - g[i]) + d[d.length - 1] * g[i]);}c.push(p);}var f = [];for (r = 0; r < a.length; ++r) {if (f = f.concat(c[r]), r < a.length - 1 || e.isPeriodicUnlimited()) {var v = a[r],_ = a[(r + 1) % a.length],y = c[r],m = c[(r + 1) % a.length],E = v.getRangeUnlimited()[1],x = _.getRangeUnlimited()[0],R = 0 === y.length || E - y[y.length - 1] > o.PARAMETER_SPACE_TOLERANCE,A = 0 === m.length || m[0] - x > o.PARAMETER_SPACE_TOLERANCE;if (R && A) {var P = v.evaluateDt(E)[t],V = _.evaluateDt(x)[t];(Math.abs(P) < n.FLOAT64_TOLERANCE || Math.abs(V) < n.FLOAT64_TOLERANCE || Math.sign(P) !== Math.sign(V)) && f.push(E);}}}return f;}, l.extremalParamsXYPlanarBezierCurve = function (e, t, r, n, o) {var i = v(t);if (!i) return g(e, r);for (var s, a, c = n || 16, u = o || 1e-12, l = [], h = void 0, d = 0; d < 8; d++) {if (a = _(e, t, d / 7, r, i), void 0 !== h && Math.sign(a[1]) !== h) {var p = (d - 1 + Math.abs(s) / (Math.abs(a[1]) + Math.abs(s))) / 7;l.push(p);}h = Math.sign(a[1]), s = a[1];}0 === l.length && (l[0] = 0 + u, l[1] = 1 - u), l.length > 2 && console.error(\"More than two roots in the second derivative of a cubic polynomial. This should not happen.\");var f,y,m,E = [],x = [];for (d = 0; d < l.length; d++) {var R = 0;do {++R, m = 0 !== (a = _(e, t, l[d], r, i))[2] ? l[d] - a[1] / a[2] : l[d], f = Math.abs(a[1]), y = Math.abs(l[d] - m), l[d] = m;} while ((f > u || y > 1e-6) && R < c);E[d] = f, x[d] = a[2];}for (d = 0; d < l.length; d++) {if (l[d] < 0 || l[d] > 1 || E[d] > u) l.splice(d, 1), d--;else if (Math.abs(x[d]) < 1e-6) {var A = (_(e, t, l[d] + 5e-7, r, i)[2] - _(e, t, l[d] - 5e-7, r, i)[2]) / 1e-6;Math.abs(A) > 1e-6 && (l.splice(d, 1), d--);}}if (2 === l.length) {if (Math.abs(l[0] - l[1]) < 1e-6) {var P = E[0] / (E[0] + E[1]);return [l[0] * (1 - P) + l[1] * P];}return l;}return l;}, l.evaluateNURBSCurvePointWithFactors = function (e, t, r, n, o, i) {var s,u,l,h = (0, a.findKnotSpan)(o, t),d = (0, c.evaluateBasisFunctions)(h, o, e, t),g = new Float64Array(3),p = 0,f = 3 * (h - e);for (i.rangeMin = h - e, i.rangeMax = h, u = 0; u <= e; ++u) {for (s = n[h - e + u] * d[u], i.factors[u] = s, l = 0; l < 3; ++l) {g[l] += r[f + l] * s;}p += s, f += 3;}for (u = 0; u < 3; ++u) {g[u] /= p;}for (u = 0; u <= e; ++u) {i.factors[u] /= p;}return g;};var E = function E(e, t, r, o, i, s, a, u, h, d, g, p, v) {var _ = .5 * (r + i),y = (0, c.evaluateBCurvePoint)(_, e, t, a, h ? u : void 0);if (p > v) g.push({ offset: _, point: y });else {var m = f(y, o, s, !1),x = n.Vector3.squaredDistance(s, o),R = n.Vector3.squaredDistance(m, y);l.validControlPolygon(a) && R < d * x ? g.push({ offset: _, point: y }) : (E(e, t, r, o, _, y, a, u, h, d, g, p + 1, v), E(e, t, _, y, i, s, a, u, h, d, g, p + 1, v));}};l.renderNURBSCurve = function (e, t, r, i, s, a, u, l) {var h = a || o.DEFAULT_CURVE_RESOLUTION,d = u || [t[0], t[t.length - 1]];l = void 0 === l || l;var g,p = v(i);if (s) {var f,_,y = [];f = (0, c.evaluateBCurvePoint)(d[0], e, t, r, p ? i : void 0), _ = (0, c.evaluateBCurvePoint)(d[1], e, t, r, p ? i : void 0), y.push({ offset: d[0], point: f }), E(e, t, d[0], f, d[1], _, r, i, p, o.SPLINE_DISTANCE_TOLERANCE, y, 0, 4), y.push({ offset: d[1], point: _ }), g = new Array(4 * y.length);for (var m = l ? 0 : 1, x = l ? 0 : 1; x < y.length; x++) {g[m] = y[x].point[0], g[m + 1] = y[x].point[1], g[m + 2] = y[x].point[2], g[m + 3] = y[x].offset, m += 4;}} else {for (var R = 0, A = 3; A < r.length; A += 3) {R += n.Vector3.distance([r[A - 3], r[A - 2], r[A - 1]], [r[A], r[A + 1], r[A + 2]]);}for (h = 10 * Math.round(R), l ? (A = 0, g = new Float32Array(3 * h)) : (A = 1, g = new Float32Array(3 * (h - 1))); A < h; ++A) {var P,V = d[0] + (d[1] - d[0]) * A / (h - 1);P = (0, c.evaluateBCurvePoint)(V, e, t, r, p ? i : void 0);for (var T = 3 * A, C = 0; C < 3; ++C) {g[T + C] = P[C];}}}return g;}, l.evaluateCurve = function (e, t, r, n, i, s) {if (i) {var a = (0, c.evaluateBCurvePoint)(t[0], e, t, r, n),u = (0, c.evaluateBCurvePoint)(t[t.length - 1], e, t, r, n),l = [];l.push({ offset: t[0], point: a }), E(e, t, t[0], a, t[t.length - 1], u, r, n, !0, o.SPLINE_DISTANCE_TOLERANCE, l, 0, 3), l.push({ offset: t[t.length - 1], point: u });for (var h = [], d = [], g = 0; g < l.length; ++g) {h.push(l[g].offset), d.push(l[g].point[0], l[g].point[1], l[g].point[2]);}} else {var p = s || .01,f = t[0],v = 0;h = [], d = [];do {var _ = (0, c.evaluateBCurvePoint)(f, e, t, r, n);for (h[v] = f, g = 0; g < 3; ++g) {d[3 * v + g] = _[g];}++v, f += p;} while (f <= t[t.length - 1]);}return { offset: h, points: d };};var x = function x(e, t, r) {var n = new Float64Array(2);n[0] = r[0] - t[0], n[1] = r[1] - t[1];var o = n[0] * n[0] + n[1] * n[1];if (0 === o) return n[0] = e[0] - t[0], n[1] = e[1] - t[1], n[0] * n[0] + n[1] * n[1];var i = (e[0] - t[0]) * n[0] + (e[1] - t[1]) * n[1];return i < 0 ? (n[0] = e[0] - t[0], n[1] = e[1] - t[1]) : i > o ? (n[0] = e[0] - r[0], n[1] = e[1] - r[1]) : (i /= o, n[0] = t[0] + i * n[0] - e[0], n[1] = t[1] + i * n[1] - e[1]), n[0] * n[0] + n[1] * n[1];},R = function R(e, t) {var r,n = !1,o = t.length;r = 0;for (var i = o - 3; r < o; r += 3) {t[r + 1] > e[1] != t[i + 1] > e[1] && e[0] < (t[i] - t[r]) * (e[1] - t[r + 1]) / (t[i + 1] - t[r + 1]) + t[r] && (n = !n), i = r;}return n;},A = function A(e, t) {for (var r, n = new Float64Array(2), o = Number.NEGATIVE_INFINITY, i = 0; i < t.length; i += 3) {n[0] = t[i] - e[0], n[1] = t[i + 1] - e[1], (r = n[0] * n[0] + n[1] * n[1]) > o && (o = r);}return o;},P = function P(e, t, r) {for (var n, o = t.length, i = new Float64Array(2), s = new Float64Array(2), a = Number.POSITIVE_INFINITY, c = 0; c < o - 3; c += 3) {i[0] = t[c], i[1] = t[c + 1], s[0] = t[c + 3], s[1] = t[c + 4], (n = x(e, i, s)) < a && (a = n);}return void 0 !== r && r && (i[0] = t[o - 3], i[1] = t[o - 2], s[0] = t[0], s[1] = t[1], (n = x(e, i, s)) < a && (a = n)), a;};l.closestSegmentsXYPlanar = function (e, t, r, n) {for (var o = Number.POSITIVE_INFINITY, i = [], s = 0; s < t.length; ++s) {var a,c = t[s],u = c.getRangeUnlimited();if (n) {a = !1;for (var l = 0; l < n.length; ++l) {if (u[1] >= n[l][0] && u[0] <= n[l][1]) {a = !0;break;}}} else a = !0;if (a) {var h,d,g = r ? r[s] : 0,p = c.getControlPoints();R(e, p) ? h = 0 : (h = P(e, p, !0), h = Math.max(0, h - g)), h <= o && (d = A(e, p) + g, i.push({ index: s, minDistSqr: h, maxDistSqr: d }), d < o && (o = d));}}var f = [];for (s = 0; s < i.length; ++s) {i[s].minDistSqr <= o && f.push(i[s]);}return f.sort(function (e, t) {var r = e.minDistSqr - t.minDistSqr;return 0 === r ? e.maxDistSqr - t.maxDistSqr : r;}), f;}, l.findKnotMultiplicity = function (e, t) {for (var r = 0, n = 0; n < t.length; ++n) {if (t[n] > e + 1e-8) return r;Math.abs(t[n] - e) < 1e-8 && r++;}return r;}, l.unclampCurve = function (e, t, r, n) {var o,i,s,a,c,u = r.length / 4 - 1,l = n || 1;for (o = 0; o < e - 1; ++o) {for (t[e - o - 1] = t[e - o] - (t[u - o + 1] - t[u - o]) * l, s = e - 1, i = o; i >= 0; --i) {for (a = (t[e] - t[s]) / (t[e + i + 1] - t[s]), c = 0; c < 4; ++c) {r[4 * i + c] = (r[4 * i + c] - a * r[4 * (i + 1) + c]) / (1 - a);}s -= 1;}}for (t[0] = t[1] - (t[u - e + 2] - t[u - e + 1]) * l, o = 0; o < e - 1; ++o) {for (t[u + o + 2] = t[u + o + 1] + (t[e + o + 1] - t[e + o]) * l, i = o; i >= 0; --i) {for (a = (t[u + 1] - t[u - i]) / (t[u - i + o + 2] - t[u - i]), c = 0; c < 4; ++c) {r[4 * (u - i) + c] = (r[4 * (u - i) + c] - (1 - a) * r[4 * (u - i - 1) + c]) / a;}}}t[u + e + 1] = t[u + e] + (t[2 * e] - t[2 * e - 1]) * l;}, l.extractCurveSegment = function (e, t, r, n, o) {var i = this.insertKnot(e, n, o, t, e);i = this.insertKnot(e, i.U, i.Pw, r, e);var s,c = (0, a.findKnotSpan)(t, i.U);for (n.length = i.U.length - (c - e), n[0] = t, s = 1; s < n.length; ++s) {n[s] = i.U[s + c - e];}var u = n.length - e - 1,l = 4 * (i.Pw.length / 4 - u);for (o.length = i.Pw.length - l, s = 0; s < o.length; ++s) {o[s] = i.Pw[s + l];}c = (0, a.findKnotSpan)(r, n), n.length = c + 1, n.push(r), o.length = 4 * (n.length - e - 1);};var V = function V(e, t, r, n) {for (var o = 0, i = 0; i < 4; ++i) {o += (e[t + i] - r[n + i]) * (e[t + i] - r[n + i]);}return Math.sqrt(o);};l.removeKnot = function (e, t, r, n, i) {if (t <= n[0] || t >= n[n.length - 1]) return 0;var s,c,u,l,h,d = [],g = e + 1,p = (0, a.findKnotSpanAndMultiplicity)(t, n);if (p.multiplicity < 1) return 0;for (var f, v, _, y, m = (2 * p.span - p.multiplicity - e) / 2, E = o.KERNEL_TOLERANCE, x = p.span - p.multiplicity, R = p.span - e, A = !1, P = [0, 0, 0, 0], T = 0; T < r; ++T) {for (f = R - 1, h = 0; h < 4; ++h) {d[0 + h] = i[4 * f + h], d[4 * (x + 1 - f) + h] = i[4 * (x + 1) + h];}for (s = R, c = x, u = 1, l = x - f, A = !1; c - s > T;) {for (v = (t - n[s]) / (n[s + g + T] - n[s]), _ = (t - n[c - T]) / (n[c + g] - n[c - T]), h = 0; h < 4; ++h) {d[4 * u + h] = (i[4 * s + h] - (1 - v) * d[4 * (u - 1) + h]) / v, d[4 * l + h] = (i[4 * c + h] - _ * d[4 * (l + 1) + h]) / (1 - _);}++s, ++u, --c, --l;}if (c - s < T) V(d, 4 * (u - 1), d, 4 * (l + 1)) <= E && (A = !0);else {for (v = (t - n[s]) / (n[s + g + T] - n[s]), h = 0; h < 4; ++h) {P[h] = v * d[4 * (u + T + 1) + h] + (1 - v) * d[4 * (u - 1) + h];}V(i, 4 * s, P, 0) <= E && (A = !0);}if (!A) break;for (s = R, c = x; c - s > T;) {for (h = 0; h < 4; ++h) {i[4 * s + h] = d[4 * (s - f) + h], i[4 * c + h] = d[4 * (c - f) + h];}++s, --c;}--R, ++x;}if (0 === T) return 0;for (y = p.span + 1; y < n.length; ++y) {n[y - T] = n[y];}for (n.length = n.length - T, s = c = m, y = 1; y < T; ++y) {y % 2 == 1 ? s += 1 : c -= 1;}for (y = s + 1; y < i.length / 4; ++y) {for (h = 0; h < 4; ++h) {i[4 * c + h] = i[4 * y + h];}c += 1;}return i.length = i.length - 4 * T, T;}, l.joinCurves = function (e, t, r, n, o) {var i,s = t[t.length - 1];for (t.length = t.length - 1, i = e + 1; i < n.length; ++i) {t.push(n[i]);}for (i = 4; i < o.length; ++i) {r.push(o[i]);}var a = this.removeKnot(e, s, e - 1, t, r);a !== e - 1 && console.warn(\"Failed knot removal, only removed seam knot \" + a + \" times.\");}, l.clampCurve = function (e, t, r) {var n = t[e],o = t[t.length - e - 1];this.extractCurveSegment(e, n, o, t, r);}, l.makePeriodic = function (e, t, r) {var n,o,i = function (e, t, r) {var n,o,i,s = 0;for (n = 1; n < r.length / 4; ++n) {for (i = 0, o = 0; o < 3; ++o) {i += (r[4 * n + o] - r[4 * (n - 1) + o]) * (r[4 * n + o] - r[4 * (n - 1) + o]);}s += Math.sqrt(i);}for (i = 0, o = 0; o < 3; ++o) {i += (r[o] - r[r.length - 4 + o]) * (r[o] - r[r.length - 4 + o]);}var a = Math.sqrt(i),c = (t[t.length - 1] - t[0]) / s,u = r.length / 4 - 1,l = t.slice();for (n = 0; n < e - 1; ++n) {l[e - n - 1] = l[e - n] - (l[u - n + 1] - l[u - n]), l[u + n + 2] = l[u + n + 1] + (l[e + n + 1] - l[e + n]);}var h = l[1] - (l[u - e + 2] - l[u - e + 1]),d = l[u + e] + (l[2 * e] - l[2 * e - 1]);return c / ((t[0] - h + d - t[t.length - 1]) / a);}(e, t, r);this.unclampCurve(e, t, r, i);var s = t.length;for (n = e - 1; n >= 0; --n) {t[s - n] = t[s - n - 1] + (t[e - (n - 1)] - t[e - n]);}var a = r.length / 4;for (r.length = 4 * a + 4 * e, t.length = s + e, n = 0; n < e; ++n) {for (o = 0; o < 4; ++o) {r[4 * (a + n) + o] = r[4 * n + o];}t[s + n] = t[s + n - 1] + (t[e + n + 1] - t[e + n]);}this.clampCurve(e, t, r);}, t.SplineCurveHelper = l;}, function (e, t, r) {\"use strict\";Object.defineProperty(t, \"__esModule\", { value: !0 }), t.evaluateBCurveDerivs = t.evaluateBCurvePoint = t.evaluateBasisDerivatives = t.evaluateBasisFunctions = void 0;var n = r(1),o = r(3),i = r(17),s = function () {var e = null,t = null;return function (r, n, o, i) {(null === e || e.length < o + 1) && (e = new Float64Array(o + 1), t = new Float64Array(o + 1));var s = new Float64Array(o + 1);s[0] = 1;for (var a = 1; a <= o; ++a) {e[a] = n - i[r + 1 - a], t[a] = i[r + a] - n;for (var c = 0, u = 0; u < a; ++u) {var l = s[u] / (t[u + 1] + e[a - u]);s[u] = c + t[u + 1] * l, c = e[a - u] * l;}s[a] = c;}return s;};}(),a = function () {var e = null,t = null,r = null,n = null;return function (o, i, s, a, c, u) {var l, h, d;if (null === t || t.length < s + 1) {for (e = [new Float64Array(s + 1), new Float64Array(s + 1)], t = new Array(s + 1), l = 0; l < s + 1; ++l) {t[l] = new Float64Array(s + 1);}r = new Float64Array(s + 1), n = new Float64Array(s + 1);}if (!u) for (u = new Array(a + 1), l = 0; l <= a; ++l) {u[l] = new Float64Array(s + 1);}for (t[0][0] = 1, l = 1; l <= s; ++l) {r[l] = i - c[o + 1 - l], n[l] = c[o + l] - i;var g = 0;for (d = 0; d < l; ++d) {t[l][d] = n[d + 1] + r[l - d];var p = t[d][l - 1] / t[l][d];t[d][l] = g + n[d + 1] * p, g = r[l - d] * p;}t[l][l] = g;}for (l = 0; l <= s; ++l) {u[0][l] = t[l][s];}for (d = 0; d <= s; ++d) {var f = 0,v = 1;for (e[0][0] = 1, h = 1; h <= a; ++h) {var _,y = 0,m = d - h,E = s - h;for (d >= h && (e[v][0] = e[f][0] / t[E + 1][m], y = e[v][0] * t[m][E]), _ = d - 1 <= E ? h - 1 : s - d, l = m >= -1 ? 1 : -m; l <= _; ++l) {e[v][l] = (e[f][l] - e[f][l - 1]) / t[E + 1][m + l], y += e[v][l] * t[m + l][E];}d <= E && (e[v][h] = -e[f][h - 1] / t[E + 1][d], y += e[v][h] * t[d][E]), u[h][d] = y, l = f, f = v, v = l;}}for (d = s, h = 1; h <= a; ++h) {for (l = 0; l <= s; ++l) {u[h][l] *= d;}d *= s - h;}return u;};}(),c = function () {var e = null,t = null;return function (r, s, c, u, l, h) {var d, g, p;if (null === e || e.length < c + 1) {for (e = new Array(c + 1), d = 0; d <= c; ++d) {e[d] = new Float64Array(c + 1);}t = new Float64Array(c + 1);}var f = Math.min(s, c),v = h && h.length > 0,_ = (0, i.findKnotSpan)(r, u);a(_, r, c, f, u, e);var y = new Array(s + 1);for (d = 0; d <= s; ++d) {y[d] = n.Vector3.createFloat64();}for (g = 0; g <= f; ++g) {var m = 3 * (_ - c);if (v) for (t[g] = 0, d = 0; d <= c; ++d) {p = h[_ - c + d] * e[g][d], y[g][0] += l[m] * p, y[g][1] += l[m + 1] * p, y[g][2] += l[m + 2] * p, t[g] += p, m += 3;} else for (d = 0; d <= c; ++d) {p = e[g][d], y[g][0] += l[m] * p, y[g][1] += l[m + 1] * p, y[g][2] += l[m + 2] * p, m += 3;}}if (v) for (g = 0; g <= f; ++g) {var E = y[g];for (d = 1; d <= g; ++d) {p = -o.binomialCoefficients[g][d] * t[d], n.Vector3.scaleAndAdd(E, E, y[g - d], p);}n.Vector3.scale(E, E, 1 / t[0]);}return y;};}();t.evaluateBasisFunctions = s, t.evaluateBasisDerivatives = a, t.evaluateBCurvePoint = function (e, t, r, o, a) {var c,u,l = (0, i.findKnotSpan)(e, r),h = s(l, e, t, r),d = a && a.length > 0,g = n.Vector3.createFloat64(),p = 0,f = 3 * (l - t);if (d) {for (c = 0; c <= t; ++c) {u = a[l - t + c] * h[c], g[0] += o[f] * u, g[1] += o[f + 1] * u, g[2] += o[f + 2] * u, p += u, f += 3;}n.Vector3.scale(g, g, 1 / p);} else for (c = 0; c <= t; ++c) {u = h[c], g[0] += o[f] * u, g[1] += o[f + 1] * u, g[2] += o[f + 2] * u, f += 3;}return g;}, t.evaluateBCurveDerivs = c;}, function (e, t, r) {\"use strict\";Object.defineProperty(t, \"__esModule\", { value: !0 }), t.Cylinder = void 0;var n = r(1),o = r(4),i = r(0),s = r(12),a = r(7),c = r(14),u = r(2),l = function l() {s.Surface.call(this), this._center = n.Vector3.createFloat64(), this._radius = 0, this._uScale = 1, this._xAxis = n.Vector3.createFloat64(), this._yAxis = n.Vector3.createFloat64(), this._zAxis = n.Vector3.createFloat64();};(l.prototype = Object.create(s.Surface.prototype)).getGeometryType = function () {return i.GEOMETRY_TYPES.CYLINDER;}, l.prototype.clone = function () {var e = new l();return e.copy(this), e;}, l.prototype.copy = function (e) {s.Surface.prototype.copy.call(this, e), this._radius = e._radius, this._uScale = e._uScale, n.Vector3.copy(this._center, e._center), n.Vector3.copy(this._xAxis, e._xAxis), n.Vector3.copy(this._yAxis, e._yAxis), n.Vector3.copy(this._zAxis, e._zAxis);}, l.prototype._computeYAxis = function () {n.Vector3.cross(this._yAxis, this._xAxis, this._zAxis);}, l.prototype.set = function (e, t, r, o, s) {n.Vector3.copy(this._center, e), u.ConsoleUtils.assert(t > i.KERNEL_TOLERANCE), this._radius = t, u.ConsoleUtils.assert(n.Vector3.squaredLength(r) > i.KERNEL_TOLERANCE * i.KERNEL_TOLERANCE), n.Vector3.normalize(this._zAxis, r), void 0 !== o && n.Vector3.squaredLength(o) > i.KERNEL_TOLERANCE * i.KERNEL_TOLERANCE ? (u.ConsoleUtils.assert(n.Vector3.isOrthogonal(r, o, i.KERNEL_ANGULAR_TOLERANCE)), n.Vector3.normalize(this._xAxis, o)) : (n.Vector3.computeOrthogonal(this._xAxis, this._zAxis), n.Vector3.normalize(this._xAxis, this._xAxis)), this._uScale = s || 1, u.ConsoleUtils.assert(this._uScale > i.PARAMETER_SPACE_TOLERANCE), this._computeYAxis();}, l.prototype.getRadius = function () {return this._radius;}, l.prototype.setRadius = function (e) {u.ConsoleUtils.assert(e > i.KERNEL_TOLERANCE), this._radius = e;}, l.prototype.getCenter = function () {return this._center;}, l.prototype.setCenter = function (e) {n.Vector3.copy(this._center, e);}, l.prototype.getAxisDir = function () {return this._zAxis;}, l.prototype.setAxisDir = function (e) {u.ConsoleUtils.assert(n.Vector3.squaredLength(e) > i.KERNEL_TOLERANCE * i.KERNEL_TOLERANCE), n.Vector3.normalize(this._zAxis, e), (n.Vector3.squaredLength(this._xAxis) <= i.KERNEL_TOLERANCE * i.KERNEL_TOLERANCE || !n.Vector3.isOrthogonal(this._xAxis, this._zAxis, i.KERNEL_ANGULAR_TOLERANCE)) && (n.Vector3.computeOrthogonal(this._xAxis, this._zAxis), n.Vector3.normalize(this._xAxis, this._xAxis)), this._computeYAxis();}, l.prototype.getUvOriginDir = function () {return this._xAxis;}, l.prototype.setUvOriginDir = function (e) {u.ConsoleUtils.assert(n.Vector3.squaredLength(e) > i.KERNEL_TOLERANCE * i.KERNEL_TOLERANCE), n.Vector3.normalize(this._xAxis, e), this._computeYAxis();}, l.prototype.getUScale = function () {return this._uScale;}, l.prototype.setUScale = function (e) {u.ConsoleUtils.assert(e > i.PARAMETER_SPACE_TOLERANCE), this._uScale = e;}, l.prototype.evaluatePosition = function (e, t) {var r = this._radius * Math.cos(t),o = this._radius * Math.sin(t),i = this._uScale * e,s = n.Vector3.clone(this._center);return n.Vector3.scaleAndAdd(s, s, this._xAxis, r), n.Vector3.scaleAndAdd(s, s, this._yAxis, o), n.Vector3.scaleAndAdd(s, s, this._zAxis, i), s;}, l.prototype.evaluateNormal = function (e, t) {var r = Math.cos(t),o = Math.sin(t),i = n.Vector3.createFloat64();return n.Vector3.scale(i, this._xAxis, r), n.Vector3.scaleAndAdd(i, i, this._yAxis, o), i;}, l.prototype.evaluateDu = function (e, t) {var r = n.Vector3.createFloat64();return n.Vector3.scale(r, this._zAxis, this._uScale), r;}, l.prototype.evaluateDv = function (e, t) {var r = -this._radius * Math.sin(t),o = this._radius * Math.cos(t),i = n.Vector3.createFloat64();return n.Vector3.scale(i, this._xAxis, r), n.Vector3.scaleAndAdd(i, i, this._yAxis, o), i;}, l.prototype.closestParam = function (e) {var t = n.Vector3.createFloat64();n.Vector3.sub(t, e, this._center);var r = n.Vector3.dot(t, this._xAxis),o = n.Vector3.dot(t, this._yAxis),s = n.Vector3.dot(t, this._zAxis) / this._uScale,a = 0;return r * r + o * o > i.KERNEL_TOLERANCE * i.KERNEL_TOLERANCE && (a = Math.atan2(o, r)), { u: s, v: a };}, l.prototype.vParamLine = function (e) {var t = new c.Circle(),r = n.Vector3.clone(this._center),o = e * this._uScale;n.Vector3.scaleAndAdd(r, r, this._zAxis, o);var i = n.Vector3.clone(this._xAxis);n.Vector3.scale(i, i, this._radius);var s = n.Vector3.clone(this._zAxis);return n.Vector3.negate(s, s), t.set(r, s, i), t;}, l.prototype.uParamLine = function (e) {var t = new a.Line(),r = n.Vector3.clone(this._center),o = this._radius * Math.cos(e),i = this._radius * Math.sin(e);return n.Vector3.scaleAndAdd(r, r, this._xAxis, o), n.Vector3.scaleAndAdd(r, r, this._yAxis, i), t.set(r, this.evaluateDu(0, e)), t;}, l.prototype.getBoundingBox = function (e, t) {if (e) {var r = e[0],n = e[1],i = this.vParamLine(r).getBoundingBox(t);return i.include(this.vParamLine(n).getBoundingBox(t)), i;}return new o.BoundingBox([-1 / 0, -1 / 0, -1 / 0], [1 / 0, 1 / 0, 1 / 0]);}, l.prototype.transform = function (e) {n.Vector3.transformMatrix44(this._center, this._center, e), n.Vector3.transformAsDirectionMatrix44(this._xAxis, this._xAxis, e), n.Vector3.transformAsDirectionMatrix44(this._yAxis, this._yAxis, e), n.Vector3.transformAsDirectionMatrix44(this._zAxis, this._zAxis, e);var t = n.Vector3.length(this._xAxis);this._radius *= t, this._uScale *= t, n.Vector3.normalize(this._xAxis, this._xAxis), n.Vector3.normalize(this._yAxis, this._yAxis), n.Vector3.normalize(this._zAxis, this._zAxis);}, l.prototype.getRangeUnlimitedU = function () {return [-1 / 0, 1 / 0];}, l.prototype.getRangeUnlimitedV = function () {return [-Math.PI, Math.PI];}, l.prototype.isPeriodicUnlimitedU = function () {return !1;}, l.prototype.isPeriodicUnlimitedV = function () {return !0;}, l.prototype.isClosedUnlimitedU = function () {return !1;}, l.prototype.isClosedUnlimitedV = function () {return !0;}, l.prototype.toObject = function () {var e = this.evaluatePosition(0, 0);return n.Vector3.sub(e, e, this.getCenter()), { center: this.vectorToObject(this._center), radius: this.vectorToObject(e), axis: this.vectorToObject(this.getAxisDir()), uCoordScale: this.getUScale(), uRange: this.rangeToObject(this.getRangeU(), this.isLimitedU()), vRange: this.rangeToObject(this.getRangeV(), this.isLimitedV()) };}, t.Cylinder = l;}, function (e, t, r) {\"use strict\";Object.defineProperty(t, \"__esModule\", { value: !0 }), t.EllipticalCylinder = void 0;var n = r(1),o = r(4),i = r(0),s = r(12),a = r(7),c = r(23),u = r(2),l = function l() {s.Surface.call(this), this._center = n.Vector3.createFloat64(), this._majorRadius = 0, this._minorRadius = 0, this._uScale = 1, this._xAxis = n.Vector3.createFloat64(), this._yAxis = n.Vector3.createFloat64(), this._zAxis = n.Vector3.createFloat64();};(l.prototype = Object.create(s.Surface.prototype)).getGeometryType = function () {return i.GEOMETRY_TYPES.ELLIPTICAL_CYLINDER;}, l.prototype.clone = function () {var e = new l();return e.copy(this), e;}, l.prototype.copy = function (e) {s.Surface.prototype.copy.call(this, e), this._majorRadius = e._majorRadius, this._minorRadius = e._minorRadius, this._uScale = e._uScale, n.Vector3.copy(this._center, e._center), n.Vector3.copy(this._xAxis, e._xAxis), n.Vector3.copy(this._yAxis, e._yAxis), n.Vector3.copy(this._zAxis, e._zAxis);}, l.prototype._computeYAxis = function () {n.Vector3.cross(this._yAxis, this._xAxis, this._zAxis);}, l.prototype.set = function (e, t, r, o, s) {n.Vector3.copy(this._center, e), this._majorRadius = n.Vector3.length(t), u.ConsoleUtils.assert(this._majorRadius > i.KERNEL_TOLERANCE), n.Vector3.normalize(this._xAxis, t), u.ConsoleUtils.assert(r <= 1), this._minorRadius = r * this._majorRadius, u.ConsoleUtils.assert(this._minorRadius > i.KERNEL_TOLERANCE), u.ConsoleUtils.assert(n.Vector3.squaredLength(o) > i.KERNEL_TOLERANCE * i.KERNEL_TOLERANCE), u.ConsoleUtils.assert(n.Vector3.isOrthogonal(o, t, i.KERNEL_ANGULAR_TOLERANCE)), n.Vector3.normalize(this._zAxis, o), this._uScale = s || 1, u.ConsoleUtils.assert(this._uScale > i.PARAMETER_SPACE_TOLERANCE), this._computeYAxis();}, l.prototype.getMajorRadius = function () {return this._majorRadius;}, l.prototype.setMajorRadius = function (e) {u.ConsoleUtils.assert(e > i.KERNEL_TOLERANCE), this._majorRadius = e;}, l.prototype.getMinorRadius = function () {return this._minorRadius;}, l.prototype.setMinorRadius = function (e) {u.ConsoleUtils.assert(e > i.KERNEL_TOLERANCE), this._minorRadius = e;}, l.prototype.getMajorAxis = function () {return this._xAxis;}, l.prototype.setMajorAxis = function (e) {u.ConsoleUtils.assert(n.Vector3.squaredLength(e) > i.KERNEL_TOLERANCE * i.KERNEL_TOLERANCE), n.Vector3.normalize(this._xAxis, e), this._computeYAxis();}, l.prototype.getCenter = function () {return this._center;}, l.prototype.setCenter = function (e) {n.Vector3.copy(this._center, e);}, l.prototype.getAxisDir = function () {return this._zAxis;}, l.prototype.setAxisDir = function (e) {u.ConsoleUtils.assert(n.Vector3.squaredLength(e) > i.KERNEL_TOLERANCE * i.KERNEL_TOLERANCE), n.Vector3.normalize(this._zAxis, e), this._computeYAxis();}, l.prototype.getUScale = function () {return this._uScale;}, l.prototype.setUScale = function (e) {u.ConsoleUtils.assert(e > i.PARAMETER_SPACE_TOLERANCE), this._uScale = e;}, l.prototype.evaluatePosition = function (e, t) {var r = this._majorRadius * Math.cos(t),o = this._minorRadius * Math.sin(t),i = this._uScale * e,s = n.Vector3.clone(this._center);return n.Vector3.scaleAndAdd(s, s, this._xAxis, r), n.Vector3.scaleAndAdd(s, s, this._yAxis, o), n.Vector3.scaleAndAdd(s, s, this._zAxis, i), s;}, l.prototype.evaluateNormal = function (e, t) {var r = this._minorRadius * Math.cos(t),o = this._majorRadius * Math.sin(t),i = Math.sqrt(r * r + o * o),s = n.Vector3.createFloat64();return n.Vector3.scale(s, this._xAxis, r / i), n.Vector3.scaleAndAdd(s, s, this._yAxis, o / i), s;}, l.prototype.evaluateDu = function (e, t) {var r = n.Vector3.createFloat64();return n.Vector3.scale(r, this._zAxis, this._uScale), r;}, l.prototype.evaluateDv = function (e, t) {var r = -this._majorRadius * Math.sin(t),o = this._minorRadius * Math.cos(t),i = n.Vector3.createFloat64();return n.Vector3.scale(i, this._xAxis, r), n.Vector3.scaleAndAdd(i, i, this._yAxis, o), i;}, l.prototype.closestParam = function (e) {var t = n.Vector3.createFloat64();n.Vector3.sub(t, e, this._center);var r = n.Vector3.dot(t, this._zAxis) / this._uScale;return { u: r, v: this.vParamLine(r).closestToPointParam(e) };}, l.prototype.vParamLine = function (e) {var t = new c.Ellipse(),r = n.Vector3.clone(this._center),o = e * this._uScale;n.Vector3.scaleAndAdd(r, r, this._zAxis, o);var i = n.Vector3.clone(this._xAxis);n.Vector3.scale(i, i, this._majorRadius);var s = n.Vector3.clone(this._zAxis);return n.Vector3.negate(s, s), t.set(r, s, i, this._minorRadius / this._majorRadius), t;}, l.prototype.uParamLine = function (e) {var t = new a.Line(),r = n.Vector3.clone(this._center),o = this._majorRadius * Math.cos(e),i = this._minorRadius * Math.sin(e);return n.Vector3.scaleAndAdd(r, r, this._xAxis, o), n.Vector3.scaleAndAdd(r, r, this._yAxis, i), t.set(r, this.evaluateDu(0, e)), t;}, l.prototype.getBoundingBox = function (e, t) {if (e) {var r = e[0],n = e[1],i = this.vParamLine(r).getBoundingBox(t);return i.include(this.vParamLine(n).getBoundingBox(t)), i;}return new o.BoundingBox([-1 / 0, -1 / 0, -1 / 0], [1 / 0, 1 / 0, 1 / 0]);}, l.prototype.transform = function (e) {n.Vector3.transformMatrix44(this._center, this._center, e), n.Vector3.transformAsDirectionMatrix44(this._xAxis, this._xAxis, e), n.Vector3.transformAsDirectionMatrix44(this._yAxis, this._yAxis, e), n.Vector3.transformAsDirectionMatrix44(this._zAxis, this._zAxis, e);var t = n.Vector3.length(this._xAxis);this._majorRadius *= t, this._minorRadius *= t, this._uScale *= t, n.Vector3.normalize(this._xAxis, this._xAxis), n.Vector3.normalize(this._yAxis, this._yAxis), n.Vector3.normalize(this._zAxis, this._zAxis);}, l.prototype.getRangeUnlimitedU = function () {return [-1 / 0, 1 / 0];}, l.prototype.getRangeUnlimitedV = function () {return [-Math.PI, Math.PI];}, l.prototype.isPeriodicUnlimitedU = function () {return !1;}, l.prototype.isPeriodicUnlimitedV = function () {return !0;}, l.prototype.isClosedUnlimitedU = function () {return !1;}, l.prototype.isClosedUnlimitedV = function () {return !0;}, l.prototype.toObject = function () {var e = this.evaluatePosition(0, 0);return n.Vector3.sub(e, e, this.getCenter()), { center: this.vectorToObject(this._center), majorRadius: this.vectorToObject(e), axis: this.vectorToObject(this.getAxisDir()), uCoordScale: this.getUScale(), radiusRatio: this.getMinorRadius() / this.getMajorRadius(), uRange: this.rangeToObject(this.getRangeU(), this.isLimitedU()), vRange: this.rangeToObject(this.getRangeV(), this.isLimitedV()) };}, t.EllipticalCylinder = l;}, function (e, t, r) {\"use strict\";Object.defineProperty(t, \"__esModule\", { value: !0 }), t.Wire = void 0;var n = r(9),o = r(4),i = r(0),s = function s() {n.BaseTopology.call(this), this._wireBody = void 0, this._edges = [];};(s.prototype = Object.create(n.BaseTopology.prototype)).getTopologyType = function () {return i.TOPOLOGY_TYPES.WIRE;}, s.prototype.getWireBody = function () {return this._wireBody;}, s.prototype.setWireBody = function (e) {this._wireBody = e;}, s.prototype.getEdges = function () {return this._edges;}, s.prototype.setEdges = function (e) {this._edges = new Array(e.length);for (var t = 0; t < e.length; ++t) {this._edges[t] = e[t];}}, s.prototype.addEdge = function (e) {this._edges ? this._edges.push(e) : this._edges = [e], e.setWire(this), e.setCoedge(void 0);}, s.prototype.addEdges = function (e) {this._edges || (this._edges = []);for (var t = 0; t < e.length; ++t) {e[t].setWire(this), e[t].setCoedge(void 0);}this._edges = this._edges.concat(e);}, s.prototype.removeEdge = function (e) {var t = this._edges.indexOf(e);return t > -1 && (this._edges.splice(t, 1), e.getWire() === this && e.setWire(void 0), !0);}, s.prototype.getBody = function () {return this._wireBody;}, s.prototype.collectFaces = function (e) {return e || new Set();}, s.prototype.collectEdges = function (e) {e = e || new Set();for (var t = 0; t < this._edges.length; ++t) {e.add(this._edges[t]);}return e;}, s.prototype.collectVertices = function (e) {e = e || new Set();for (var t = 0; t < this._edges.length; ++t) {this._edges[t].collectVertices(e);}return e;}, s.prototype.isBranched = function () {for (var e = 0; e < this._edges.length; ++e) {var t = this._edges[e],r = t.getStartVertex(),n = t.getEndVertex();if (r === n && r.getOtherEdge(t)) return !0;if (r.getEdges().length > 2 || n.getEdges().length > 2) return !0;}return !1;}, s.prototype.getOrderedEdges = function () {if (0 === this._edges.length) return { edges: [], start: void 0, end: void 0 };var e = [];e.push(this._edges[0]);for (var t = new Set(this._edges.slice(1)), r = e[0].getStartVertex(), n = e[0].getEndVertex(); t.size > 0;) {var o = t.size;if (t.forEach(function (o) {o.getEndVertex() === r ? (e.unshift(o), r = o.getStartVertex(), t.delete(o)) : o.getStartVertex() === r ? (e.unshift(o), r = o.getEndVertex(), t.delete(o)) : o.getEndVertex() === n ? (e.push(o), n = o.getStartVertex(), t.delete(o)) : o.getStartVertex() === n && (e.push(o), n = o.getEndVertex(), t.delete(o));}), o === t.size) {console.warn(\"Wire is disconnected or branching.\");break;}}return { edges: e, start: r, end: n };}, s.prototype.isClosed = function () {if (1 === this._edges.length) return this._edges[0].getStartVertex() === this._edges[0].getEndVertex();for (var e = this._edges[0], t = void 0, r = 0; r < this._edges.length; ++r) {var n,o = e.getStartVertex(),i = e.getEndVertex();if (o === i || 2 !== o.getEdges().length || 2 !== i.getEdges().length) return !1;if (t && o.getOtherEdge(e) !== t) {if (i.getOtherEdge(e) !== t) return !1;n = o.getOtherEdge(e);} else n = i.getOtherEdge(e);t = e, e = n;}return e === this._edges[0];}, s.prototype.getBoundingBox = function () {for (var e = new o.BoundingBox(), t = 0; t < this._edges.length; ++t) {e.include(this._edges[t].getBoundingBox());}return e;}, s.prototype.toString = function () {return \"Wire\";}, s.prototype.toObject = function () {return { edges: this.refsToStrings(this._edges), attributes: this.refsToStrings(this._attributes) };}, s.prototype.addToModelObject = function (e) {this.addAllToModelObject(e, [this._edges, this._attributes]);}, t.Wire = s;}, function (e, t, r) {\"use strict\";Object.defineProperty(t, \"__esModule\", { value: !0 }), t.ProgenitorMap = void 0;var n = r(0),o = r(2),i = function i() {this._newToOldMap = new Map(), this._oldToNewMap = new Map(), this._labelMap = new Map();};i.prototype.addEntry = function (e, t, r) {t = Array.from(new Set(t)), o.ConsoleUtils.assert(!this._newToOldMap.has(e)), this._newToOldMap.set(e, t), r && this._labelMap.set(e, r);for (var n = 0; n < t.length; n++) {var i = t[n],s = this._oldToNewMap.get(i);s ? s.indexOf(e) < 0 && s.push(e) : this._oldToNewMap.set(i, [e]);}}, i.prototype.hasEntry = function (e) {return this._newToOldMap.has(e);}, i.prototype.removeEntry = function (e) {var t = this._newToOldMap.get(e);if (t) {this._newToOldMap.delete(e), this._labelMap.delete(e);for (var r = 0; r < t.length; r++) {var n = this._oldToNewMap.get(t[r]),i = n.indexOf(e);o.ConsoleUtils.assert(i >= 0), n.splice(i, 1), 0 === n.length && this._oldToNewMap.delete(t[r]);}}}, i.prototype.size = function () {return this._newToOldMap.size;}, i.prototype.getProgenitors = function (e) {return this._newToOldMap.get(e);}, i.prototype.getDescendants = function (e) {return this._oldToNewMap.get(e) || [];}, i.prototype.getLabel = function (e) {return this._labelMap.get(e) || \"\";}, i.prototype.getAllNewTopology = function () {return Array.from(this._newToOldMap.keys());}, i.prototype.getAllOldTopology = function () {return Array.from(this._oldToNewMap.keys());}, i.prototype.clear = function () {this._newToOldMap.clear(), this._oldToNewMap.clear(), this._labelMap.clear();}, i.prototype.mergeMaps = function (e) {var t = new i(),r = new Set(this._newToOldMap.keys());return e._newToOldMap.keys().forEach(function (e) {r.add(e);}), r.forEach(function (r) {var n = this.getProgenitors(r) || [],o = e.getProgenitors(r) || [],i = this.getLabel(r) || e.getLabel(r);t.addEntry(r, n.concat(o), i);}), t;}, i.prototype.collapseMaps = function (e, t) {var r = !1,n = !1;t && (void 0 !== t.keepIntermediates && (r = t.keepIntermediates), void 0 !== t.keepAllDescendants && (n = t.keepAllDescendants));var o = new i(),s = void 0;return n && (s = new Set(e._newToOldMap.keys())), this._newToOldMap.forEach(function (t, i) {for (var a = new Set(), c = 0; c < t.length; c++) {var u = t[c],l = e.getProgenitors(u);l && l.length > 0 ? (l.forEach(function (e) {a.add(e);}), r && a.add(u)) : a.add(u), n && s.delete(u);}o.addEntry(i, Array.from(a));}), n && s.forEach(function (t) {var r = e.getProgenitors(t);o.hasEntry(t) && (r = r.concat(o.getProgenitors(t)), o.removeEntry(t)), o.addEntry(t, r);}), o;}, i.prototype.toString = function () {for (var e = \"ProgenitorMap:\\n\", t = this.getAllNewTopology(), r = 0; r < t.length; r++) {var o = t[r];e += n.TOPOLOGY_TYPES.toString(o.getTopologyType()) + \":\" + o.getGuid();var i = this.getLabel(o);i && (e += \" '\" + i + \"'\"), e += \" -> [ \";for (var s = this.getProgenitors(o), a = 0; a < s.length; a++) {a > 0 && (e += \", \"), e += n.TOPOLOGY_TYPES.toString(s[a].getTopologyType()) + \":\" + s[a].getGuid();}e += \" ]\\n\";}return e;}, t.ProgenitorMap = i;}, function (e, t, r) {\"use strict\";r.r(t), r.d(t, \"default\", function () {return i;}), r.d(t, \"VERSION\", function () {return n.VERSION;}), r.d(t, \"iteratee\", function () {return n.iteratee;}), r.d(t, \"restArguments\", function () {return n.restArguments;}), r.d(t, \"each\", function () {return n.each;}), r.d(t, \"forEach\", function () {return n.forEach;}), r.d(t, \"map\", function () {return n.map;}), r.d(t, \"collect\", function () {return n.collect;}), r.d(t, \"reduce\", function () {return n.reduce;}), r.d(t, \"foldl\", function () {return n.foldl;}), r.d(t, \"inject\", function () {return n.inject;}), r.d(t, \"reduceRight\", function () {return n.reduceRight;}), r.d(t, \"foldr\", function () {return n.foldr;}), r.d(t, \"find\", function () {return n.find;}), r.d(t, \"detect\", function () {return n.detect;}), r.d(t, \"filter\", function () {return n.filter;}), r.d(t, \"select\", function () {return n.select;}), r.d(t, \"reject\", function () {return n.reject;}), r.d(t, \"every\", function () {return n.every;}), r.d(t, \"all\", function () {return n.all;}), r.d(t, \"some\", function () {return n.some;}), r.d(t, \"any\", function () {return n.any;}), r.d(t, \"contains\", function () {return n.contains;}), r.d(t, \"includes\", function () {return n.includes;}), r.d(t, \"include\", function () {return n.include;}), r.d(t, \"invoke\", function () {return n.invoke;}), r.d(t, \"pluck\", function () {return n.pluck;}), r.d(t, \"where\", function () {return n.where;}), r.d(t, \"findWhere\", function () {return n.findWhere;}), r.d(t, \"max\", function () {return n.max;}), r.d(t, \"min\", function () {return n.min;}), r.d(t, \"shuffle\", function () {return n.shuffle;}), r.d(t, \"sample\", function () {return n.sample;}), r.d(t, \"sortBy\", function () {return n.sortBy;}), r.d(t, \"groupBy\", function () {return n.groupBy;}), r.d(t, \"indexBy\", function () {return n.indexBy;}), r.d(t, \"countBy\", function () {return n.countBy;}), r.d(t, \"toArray\", function () {return n.toArray;}), r.d(t, \"size\", function () {return n.size;}), r.d(t, \"partition\", function () {return n.partition;}), r.d(t, \"first\", function () {return n.first;}), r.d(t, \"head\", function () {return n.head;}), r.d(t, \"take\", function () {return n.take;}), r.d(t, \"initial\", function () {return n.initial;}), r.d(t, \"last\", function () {return n.last;}), r.d(t, \"rest\", function () {return n.rest;}), r.d(t, \"tail\", function () {return n.tail;}), r.d(t, \"drop\", function () {return n.drop;}), r.d(t, \"compact\", function () {return n.compact;}), r.d(t, \"flatten\", function () {return n.flatten;}), r.d(t, \"without\", function () {return n.without;}), r.d(t, \"uniq\", function () {return n.uniq;}), r.d(t, \"unique\", function () {return n.unique;}), r.d(t, \"union\", function () {return n.union;}), r.d(t, \"intersection\", function () {return n.intersection;}), r.d(t, \"difference\", function () {return n.difference;}), r.d(t, \"unzip\", function () {return n.unzip;}), r.d(t, \"zip\", function () {return n.zip;}), r.d(t, \"object\", function () {return n.object;}), r.d(t, \"findIndex\", function () {return n.findIndex;}), r.d(t, \"findLastIndex\", function () {return n.findLastIndex;}), r.d(t, \"sortedIndex\", function () {return n.sortedIndex;}), r.d(t, \"indexOf\", function () {return n.indexOf;}), r.d(t, \"lastIndexOf\", function () {return n.lastIndexOf;}), r.d(t, \"range\", function () {return n.range;}), r.d(t, \"chunk\", function () {return n.chunk;}), r.d(t, \"bind\", function () {return n.bind;}), r.d(t, \"partial\", function () {return n.partial;}), r.d(t, \"bindAll\", function () {return n.bindAll;}), r.d(t, \"memoize\", function () {return n.memoize;}), r.d(t, \"delay\", function () {return n.delay;}), r.d(t, \"defer\", function () {return n.defer;}), r.d(t, \"throttle\", function () {return n.throttle;}), r.d(t, \"debounce\", function () {return n.debounce;}), r.d(t, \"wrap\", function () {return n.wrap;}), r.d(t, \"negate\", function () {return n.negate;}), r.d(t, \"compose\", function () {return n.compose;}), r.d(t, \"after\", function () {return n.after;}), r.d(t, \"before\", function () {return n.before;}), r.d(t, \"once\", function () {return n.once;}), r.d(t, \"keys\", function () {return n.keys;}), r.d(t, \"allKeys\", function () {return n.allKeys;}), r.d(t, \"values\", function () {return n.values;}), r.d(t, \"mapObject\", function () {return n.mapObject;}), r.d(t, \"pairs\", function () {return n.pairs;}), r.d(t, \"invert\", function () {return n.invert;}), r.d(t, \"functions\", function () {return n.functions;}), r.d(t, \"methods\", function () {return n.methods;}), r.d(t, \"extend\", function () {return n.extend;}), r.d(t, \"extendOwn\", function () {return n.extendOwn;}), r.d(t, \"assign\", function () {return n.assign;}), r.d(t, \"findKey\", function () {return n.findKey;}), r.d(t, \"pick\", function () {return n.pick;}), r.d(t, \"omit\", function () {return n.omit;}), r.d(t, \"defaults\", function () {return n.defaults;}), r.d(t, \"create\", function () {return n.create;}), r.d(t, \"clone\", function () {return n.clone;}), r.d(t, \"tap\", function () {return n.tap;}), r.d(t, \"isMatch\", function () {return n.isMatch;}), r.d(t, \"isEqual\", function () {return n.isEqual;}), r.d(t, \"isEmpty\", function () {return n.isEmpty;}), r.d(t, \"isElement\", function () {return n.isElement;}), r.d(t, \"isArray\", function () {return n.isArray;}), r.d(t, \"isObject\", function () {return n.isObject;}), r.d(t, \"isArguments\", function () {return n.isArguments;}), r.d(t, \"isFunction\", function () {return n.isFunction;}), r.d(t, \"isString\", function () {return n.isString;}), r.d(t, \"isNumber\", function () {return n.isNumber;}), r.d(t, \"isDate\", function () {return n.isDate;}), r.d(t, \"isRegExp\", function () {return n.isRegExp;}), r.d(t, \"isError\", function () {return n.isError;}), r.d(t, \"isSymbol\", function () {return n.isSymbol;}), r.d(t, \"isMap\", function () {return n.isMap;}), r.d(t, \"isWeakMap\", function () {return n.isWeakMap;}), r.d(t, \"isSet\", function () {return n.isSet;}), r.d(t, \"isWeakSet\", function () {return n.isWeakSet;}), r.d(t, \"isFinite\", function () {return n.isFinite;}), r.d(t, \"isNaN\", function () {return n.isNaN;}), r.d(t, \"isBoolean\", function () {return n.isBoolean;}), r.d(t, \"isNull\", function () {return n.isNull;}), r.d(t, \"isUndefined\", function () {return n.isUndefined;}), r.d(t, \"has\", function () {return n.has;}), r.d(t, \"identity\", function () {return n.identity;}), r.d(t, \"constant\", function () {return n.constant;}), r.d(t, \"noop\", function () {return n.noop;}), r.d(t, \"property\", function () {return n.property;}), r.d(t, \"propertyOf\", function () {return n.propertyOf;}), r.d(t, \"matcher\", function () {return n.matcher;}), r.d(t, \"matches\", function () {return n.matches;}), r.d(t, \"times\", function () {return n.times;}), r.d(t, \"random\", function () {return n.random;}), r.d(t, \"now\", function () {return n.now;}), r.d(t, \"escape\", function () {return n.escape;}), r.d(t, \"unescape\", function () {return n.unescape;}), r.d(t, \"result\", function () {return n.result;}), r.d(t, \"uniqueId\", function () {return n.uniqueId;}), r.d(t, \"templateSettings\", function () {return n.templateSettings;}), r.d(t, \"template\", function () {return n.template;}), r.d(t, \"chain\", function () {return n.chain;}), r.d(t, \"mixin\", function () {return n.mixin;});var n = r(29),o = Object(n.mixin)(n);o._ = o;var i = o;}, function (e, t, r) {\"use strict\";Object.defineProperty(t, \"__esModule\", { value: !0 }), t.BaseGeometry = void 0;var n = r(44),o = r(0),i = function i() {n.Base.call(this);};(i.prototype = Object.create(n.Base.prototype)).getGeometryType = function () {console.warn(\"BaseGeometry.getGeometryType : abstract method invoked!\");}, i.prototype.clone = function () {console.warn(\"BaseGeometry.clone : abstract method invoked\");}, i.prototype.copy = function (e) {this._guid = \"\";}, i.prototype.addToModelObject = function (e) {if (!e.geometries[this.getGuid()]) {var _t4 = {};_t4[o.GEOMETRY_TYPES.toString(this.getGeometryType()).toLowerCase()] = this.toObject(), e.geometries[this.getGuid()] = _t4;}}, t.BaseGeometry = i;}, function (e, t, r) {\"use strict\";Object.defineProperty(t, \"__esModule\", { value: !0 }), t.Base = void 0;var n = r(56);var o = r(45).Autodesk.lookup(\"SolidDef.paramrange_1_0_0.typeEnum\");var i = function i() {this._guid = \"\";};i.prototype.setGuid = function (e) {this._guid = e;}, i.prototype.getGuid = function () {return this._guid || (this._guid = (0, n.generateGUID)()), this._guid;}, i.prototype.refsToStrings = function (e) {if (e) {var _t5 = new Array(e.length);for (var _r3 = 0; _r3 < e.length; ++_r3) {_t5[_r3] = e[_r3].getGuid();}return _t5;}return [];}, i.prototype.refToString = function (e) {return e ? e.getGuid() : \"\";}, i.prototype.toObject = function () {return console.warn(\"Base.toObject : abstract method invoked!\"), {};}, i.prototype.vectorToObject = function (e) {return { x: e[0], y: e[1], z: e[2] };}, i.prototype.rangeToObject = function (e, t) {var r = 1,n = 0;t && void 0 !== e && 2 === e.length && isFinite(e[0]) && isFinite(e[1]) && (r = e[0], n = e[1]);var i = r <= n ? \"finite\" : \"infinite\";return { low: r, high: n, type: o.values[i] };}, i.prototype.addToModelObject = function (e) {console.warn(\"Base.addToModelObject : abstract method invoked!\");}, t.Base = i;}, function (e, t, r) {\"use strict\";var n = r(87),o = (n.roots.default || (n.roots.default = new n.Root())).addJSON({ Autodesk: { nested: { SolidDef: { nested: { SolidDef_grpc: { methods: {} }, point3d_1_0_0: { fields: { x: { type: \"double\", id: 1 }, y: { type: \"double\", id: 2 }, z: { type: \"double\", id: 3 } } }, vector3d_1_0_0: { fields: { x: { type: \"double\", id: 1 }, y: { type: \"double\", id: 2 }, z: { type: \"double\", id: 3 } } }, geometry_1_0_0: { fields: {} }, geometry_1_0_0_Type: { oneofs: { geometry: { oneof: [\"point\", \"bsurface\", \"cone\", \"cylinder\", \"ellipticalcone\", \"ellipticalcylinder\", \"plane\", \"sphere\", \"surface\", \"torus\", \"bcurve\", \"circle\", \"curve\", \"ellipse\", \"line\"] } }, fields: { point: { type: \"point_1_0_0\", id: 1 }, bsurface: { type: \"bsurface_1_0_0\", id: 2 }, cone: { type: \"cone_1_0_0\", id: 3 }, cylinder: { type: \"cylinder_1_0_0\", id: 4 }, ellipticalcone: { type: \"ellipticalcone_1_0_0\", id: 5 }, ellipticalcylinder: { type: \"ellipticalcylinder_1_0_0\", id: 6 }, plane: { type: \"plane_1_0_0\", id: 7 }, sphere: { type: \"sphere_1_0_0\", id: 8 }, surface: { type: \"surface_1_0_0\", id: 9 }, torus: { type: \"torus_1_0_0\", id: 10 }, bcurve: { type: \"bcurve_1_0_0\", id: 11 }, circle: { type: \"circle_1_0_0\", id: 12 }, curve: { type: \"curve_1_0_0\", id: 13 }, ellipse: { type: \"ellipse_1_0_0\", id: 14 }, line: { type: \"line_1_0_0\", id: 15 } } }, paramrange_1_0_0: { fields: { low: { type: \"double\", id: 1 }, high: { type: \"double\", id: 2 }, type: { type: \"typeEnum\", id: 3 } }, nested: { typeEnum: { values: { infinite: 0, finite: 1, boundBelow: 2, boundAbove: 3 } } } }, point_1_0_0: { fields: { position: { type: \"point3d_1_0_0\", id: 1 } } }, bsurface_1_0_0: { fields: { uDegree: { type: \"uint32\", id: 1 }, vDegree: { type: \"uint32\", id: 2 }, uKnots: { rule: \"repeated\", type: \"double\", id: 3 }, vKnots: { rule: \"repeated\", type: \"double\", id: 4 }, controlPoints: { rule: \"repeated\", type: \"double\", id: 5 }, weights: { rule: \"repeated\", type: \"double\", id: 6 }, uRange: { type: \"paramrange_1_0_0\", id: 7 }, vRange: { type: \"paramrange_1_0_0\", id: 8 } } }, cone_1_0_0: { fields: { center: { type: \"point3d_1_0_0\", id: 1 }, axis: { type: \"vector3d_1_0_0\", id: 2 }, radius: { type: \"vector3d_1_0_0\", id: 3 }, angle: { type: \"double\", id: 4 }, uCoordScale: { type: \"double\", id: 5 }, uRange: { type: \"paramrange_1_0_0\", id: 6 }, vRange: { type: \"paramrange_1_0_0\", id: 7 } } }, cylinder_1_0_0: { fields: { center: { type: \"point3d_1_0_0\", id: 1 }, axis: { type: \"vector3d_1_0_0\", id: 2 }, radius: { type: \"vector3d_1_0_0\", id: 3 }, uCoordScale: { type: \"double\", id: 4 }, uRange: { type: \"paramrange_1_0_0\", id: 5 }, vRange: { type: \"paramrange_1_0_0\", id: 6 } } }, ellipticalcone_1_0_0: { fields: { center: { type: \"point3d_1_0_0\", id: 1 }, axis: { type: \"vector3d_1_0_0\", id: 2 }, majorRadius: { type: \"vector3d_1_0_0\", id: 3 }, radiusRatio: { type: \"double\", id: 4 }, angle: { type: \"double\", id: 5 }, uCoordScale: { type: \"double\", id: 6 }, uRange: { type: \"paramrange_1_0_0\", id: 7 }, vRange: { type: \"paramrange_1_0_0\", id: 8 } } }, ellipticalcylinder_1_0_0: { fields: { center: { type: \"point3d_1_0_0\", id: 1 }, axis: { type: \"vector3d_1_0_0\", id: 2 }, majorRadius: { type: \"vector3d_1_0_0\", id: 3 }, radiusRatio: { type: \"double\", id: 4 }, uCoordScale: { type: \"double\", id: 5 }, uRange: { type: \"paramrange_1_0_0\", id: 6 }, vRange: { type: \"paramrange_1_0_0\", id: 7 } } }, plane_1_0_0: { fields: { origin: { type: \"point3d_1_0_0\", id: 1 }, normal: { type: \"vector3d_1_0_0\", id: 2 }, uAxis: { type: \"vector3d_1_0_0\", id: 3 }, uRange: { type: \"paramrange_1_0_0\", id: 4 }, vRange: { type: \"paramrange_1_0_0\", id: 5 } } }, sphere_1_0_0: { fields: { center: { type: \"point3d_1_0_0\", id: 1 }, radius: { type: \"vector3d_1_0_0\", id: 2 }, axis: { type: \"vector3d_1_0_0\", id: 3 }, uRange: { type: \"paramrange_1_0_0\", id: 4 }, vRange: { type: \"paramrange_1_0_0\", id: 5 } } }, surface_1_0_0: { fields: { uRange: { type: \"paramrange_1_0_0\", id: 1 }, vRange: { type: \"paramrange_1_0_0\", id: 2 } } }, surface_1_0_0_Type: { oneofs: { surface: { oneof: [\"bsurface\", \"cone\", \"cylinder\", \"ellipticalcone\", \"ellipticalcylinder\", \"plane\", \"sphere\", \"torus\"] } }, fields: { bsurface: { type: \"bsurface_1_0_0\", id: 1 }, cone: { type: \"cone_1_0_0\", id: 2 }, cylinder: { type: \"cylinder_1_0_0\", id: 3 }, ellipticalcone: { type: \"ellipticalcone_1_0_0\", id: 4 }, ellipticalcylinder: { type: \"ellipticalcylinder_1_0_0\", id: 5 }, plane: { type: \"plane_1_0_0\", id: 6 }, sphere: { type: \"sphere_1_0_0\", id: 7 }, torus: { type: \"torus_1_0_0\", id: 8 } } }, torus_1_0_0: { fields: { center: { type: \"point3d_1_0_0\", id: 1 }, axis: { type: \"vector3d_1_0_0\", id: 2 }, majorRadius: { type: \"double\", id: 3 }, minorRadius: { type: \"double\", id: 4 }, coordAxis: { type: \"vector3d_1_0_0\", id: 5 }, lemon: { type: \"bool\", id: 6 }, uRange: { type: \"paramrange_1_0_0\", id: 7 }, vRange: { type: \"paramrange_1_0_0\", id: 8 } } }, bcurve_1_0_0: { fields: { degree: { type: \"uint32\", id: 1 }, knots: { rule: \"repeated\", type: \"double\", id: 2 }, controlPoints: { rule: \"repeated\", type: \"double\", id: 3 }, weights: { rule: \"repeated\", type: \"double\", id: 4 }, range: { type: \"paramrange_1_0_0\", id: 5 } } }, circle_1_0_0: { fields: { center: { type: \"point3d_1_0_0\", id: 1 }, normal: { type: \"vector3d_1_0_0\", id: 2 }, radius: { type: \"vector3d_1_0_0\", id: 3 }, range: { type: \"paramrange_1_0_0\", id: 4 } } }, curve_1_0_0: { fields: { range: { type: \"paramrange_1_0_0\", id: 1 } } }, curve_1_0_0_Type: { oneofs: { curve: { oneof: [\"bcurve\", \"circle\", \"ellipse\", \"line\"] } }, fields: { bcurve: { type: \"bcurve_1_0_0\", id: 1 }, circle: { type: \"circle_1_0_0\", id: 2 }, ellipse: { type: \"ellipse_1_0_0\", id: 3 }, line: { type: \"line_1_0_0\", id: 4 } } }, ellipse_1_0_0: { fields: { center: { type: \"point3d_1_0_0\", id: 1 }, normal: { type: \"vector3d_1_0_0\", id: 2 }, majorRadius: { type: \"vector3d_1_0_0\", id: 3 }, radiusRatio: { type: \"double\", id: 4 }, range: { type: \"paramrange_1_0_0\", id: 5 } } }, line_1_0_0: { fields: { position: { type: \"point3d_1_0_0\", id: 1 }, direction: { type: \"vector3d_1_0_0\", id: 2 }, range: { type: \"paramrange_1_0_0\", id: 3 } } }, attribute_1_0_0: { fields: {} }, attribute_1_0_0_Type: { oneofs: { attribute: { oneof: [\"nmiattribute\", \"nmiattributearr\", \"nmiattributestr\", \"textattribute\"] } }, fields: { nmiattribute: { type: \"nmiattribute_1_0_0\", id: 1 }, nmiattributearr: { type: \"nmiattributearr_1_0_0\", id: 4 }, nmiattributestr: { type: \"nmiattributestr_1_0_0\", id: 2 }, textattribute: { type: \"textattribute_1_0_0\", id: 3 } } }, body_1_0_0: { fields: { lumps: { rule: \"repeated\", type: \"string\", id: 1 }, attributes: { rule: \"repeated\", type: \"string\", id: 2 } } }, coedge_1_0_0: { fields: { edge: { type: \"string\", id: 1 }, partner: { type: \"string\", id: 2 }, reversed: { type: \"bool\", id: 3 }, attributes: { rule: \"repeated\", type: \"string\", id: 4 } } }, edge_1_0_0: { fields: { vertex0: { type: \"string\", id: 1 }, vertex1: { type: \"string\", id: 2 }, precision: { type: \"double\", id: 3 }, range: { type: \"paramrange_1_0_0\", id: 4 }, reversed: { type: \"bool\", id: 5 }, geometry: { type: \"string\", id: 6 }, attributes: { rule: \"repeated\", type: \"string\", id: 7 } } }, face_1_0_0: { fields: { loops: { rule: \"repeated\", type: \"string\", id: 1 }, reversed: { type: \"bool\", id: 2 }, geometry: { type: \"string\", id: 3 }, attributes: { rule: \"repeated\", type: \"string\", id: 4 } } }, loop_1_0_0: { fields: { coedges: { rule: \"repeated\", type: \"string\", id: 1 }, attributes: { rule: \"repeated\", type: \"string\", id: 2 } } }, lump_1_0_0: { fields: { shells: { rule: \"repeated\", type: \"string\", id: 1 }, attributes: { rule: \"repeated\", type: \"string\", id: 2 } } }, model_1_0_0: { fields: { geometries: { keyType: \"string\", type: \"geometry_1_0_0_Type\", id: 1 }, topologies: { keyType: \"string\", type: \"topology_1_0_0_Type\", id: 2 }, attributes: { keyType: \"string\", type: \"attribute_1_0_0_Type\", id: 3 } } }, shell_1_0_0: { fields: { faces: { rule: \"repeated\", type: \"string\", id: 1 }, attributes: { rule: \"repeated\", type: \"string\", id: 2 } } }, topology_1_0_0: { fields: { attributes: { rule: \"repeated\", type: \"string\", id: 1 } } }, topology_1_0_0_Type: { oneofs: { topology: { oneof: [\"body\", \"coedge\", \"edge\", \"face\", \"loop\", \"lump\", \"shell\", \"vertex\", \"wire\", \"wirebody\"] } }, fields: { body: { type: \"body_1_0_0\", id: 1 }, coedge: { type: \"coedge_1_0_0\", id: 2 }, edge: { type: \"edge_1_0_0\", id: 3 }, face: { type: \"face_1_0_0\", id: 4 }, loop: { type: \"loop_1_0_0\", id: 5 }, lump: { type: \"lump_1_0_0\", id: 6 }, shell: { type: \"shell_1_0_0\", id: 7 }, vertex: { type: \"vertex_1_0_0\", id: 8 }, wire: { type: \"wire_1_0_0\", id: 9 }, wirebody: { type: \"wirebody_1_0_0\", id: 10 } } }, vertex_1_0_0: { fields: { precision: { type: \"double\", id: 1 }, geometry: { type: \"string\", id: 2 }, attributes: { rule: \"repeated\", type: \"string\", id: 3 } } }, wire_1_0_0: { fields: { edges: { rule: \"repeated\", type: \"string\", id: 1 }, attributes: { rule: \"repeated\", type: \"string\", id: 2 } } }, wirebody_1_0_0: { fields: { wires: { rule: \"repeated\", type: \"string\", id: 1 }, attributes: { rule: \"repeated\", type: \"string\", id: 2 } } }, nmiattribute_1_0_0: { fields: { primaryId: { type: \"uint64\", id: 1 }, secondaryId: { type: \"int64\", id: 2 }, approachId: { type: \"int64\", id: 3 }, operationIds: { rule: \"repeated\", type: \"int64\", id: 4 } } }, nmiattributearr_1_0_0: { fields: { tagInfo: { rule: \"repeated\", type: \"nmiattributestr_1_0_0\", id: 1 } } }, nmiattributestr_1_0_0: { fields: { primaryId: { type: \"string\", id: 1 }, secondaryId: { type: \"string\", id: 2 }, approachId: { type: \"string\", id: 3 }, operationIds: { rule: \"repeated\", type: \"string\", id: 4 } } }, textattribute_1_0_0: { fields: { text: { type: \"string\", id: 1 } } }, entity: { oneofs: { entity: { oneof: [\"point3d\", \"vector3d\", \"geometry\", \"paramrange\", \"point\", \"bsurface\", \"cone\", \"cylinder\", \"ellipticalcone\", \"ellipticalcylinder\", \"plane\", \"sphere\", \"surface\", \"torus\", \"bcurve\", \"circle\", \"curve\", \"ellipse\", \"line\", \"attribute\", \"body\", \"coedge\", \"edge\", \"face\", \"loop\", \"lump\", \"model\", \"shell\", \"topology\", \"vertex\", \"wire\", \"wirebody\", \"nmiattribute\", \"nmiattributearr\", \"nmiattributestr\", \"textattribute\"] } }, fields: { id: { type: \"string\", id: 1 }, point3d: { type: \"point3d_1_0_0\", id: 2 }, vector3d: { type: \"vector3d_1_0_0\", id: 3 }, geometry: { type: \"geometry_1_0_0\", id: 4 }, paramrange: { type: \"paramrange_1_0_0\", id: 5 }, point: { type: \"point_1_0_0\", id: 6 }, bsurface: { type: \"bsurface_1_0_0\", id: 7 }, cone: { type: \"cone_1_0_0\", id: 8 }, cylinder: { type: \"cylinder_1_0_0\", id: 9 }, ellipticalcone: { type: \"ellipticalcone_1_0_0\", id: 10 }, ellipticalcylinder: { type: \"ellipticalcylinder_1_0_0\", id: 11 }, plane: { type: \"plane_1_0_0\", id: 12 }, sphere: { type: \"sphere_1_0_0\", id: 13 }, surface: { type: \"surface_1_0_0\", id: 14 }, torus: { type: \"torus_1_0_0\", id: 15 }, bcurve: { type: \"bcurve_1_0_0\", id: 16 }, circle: { type: \"circle_1_0_0\", id: 17 }, curve: { type: \"curve_1_0_0\", id: 18 }, ellipse: { type: \"ellipse_1_0_0\", id: 19 }, line: { type: \"line_1_0_0\", id: 20 }, attribute: { type: \"attribute_1_0_0\", id: 21 }, body: { type: \"body_1_0_0\", id: 22 }, coedge: { type: \"coedge_1_0_0\", id: 23 }, edge: { type: \"edge_1_0_0\", id: 24 }, face: { type: \"face_1_0_0\", id: 25 }, loop: { type: \"loop_1_0_0\", id: 26 }, lump: { type: \"lump_1_0_0\", id: 27 }, model: { type: \"model_1_0_0\", id: 28 }, shell: { type: \"shell_1_0_0\", id: 29 }, topology: { type: \"topology_1_0_0\", id: 30 }, vertex: { type: \"vertex_1_0_0\", id: 31 }, wire: { type: \"wire_1_0_0\", id: 32 }, wirebody: { type: \"wirebody_1_0_0\", id: 33 }, nmiattribute: { type: \"nmiattribute_1_0_0\", id: 34 }, nmiattributearr: { type: \"nmiattributearr_1_0_0\", id: 37 }, nmiattributestr: { type: \"nmiattributestr_1_0_0\", id: 35 }, textattribute: { type: \"textattribute_1_0_0\", id: 36 } } } } } } } });e.exports = o;}, function (e, t, r) {\"use strict\";e.exports = l;var n,o = r(10),i = o.LongBits,s = o.base64,a = o.utf8;function c(e, t, r) {this.fn = e, this.len = t, this.next = void 0, this.val = r;}function u() {}function l() {this.len = 0, this.head = new c(u, 0, 0), this.tail = this.head, this.states = null;}function h(e, t, r) {t[r] = 255 & e;}function d(e, t) {this.len = e, this.next = void 0, this.val = t;}function g(e, t, r) {for (; e.hi;) {t[r++] = 127 & e.lo | 128, e.lo = (e.lo >>> 7 | e.hi << 25) >>> 0, e.hi >>>= 7;}for (; e.lo > 127;) {t[r++] = 127 & e.lo | 128, e.lo = e.lo >>> 7;}t[r++] = e.lo;}function p(e, t, r) {t[r] = 255 & e, t[r + 1] = e >>> 8 & 255, t[r + 2] = e >>> 16 & 255, t[r + 3] = e >>> 24;}l.create = o.Buffer ? function () {return (l.create = function () {return new n();})();} : function () {return new l();}, l.alloc = function (e) {return new o.Array(e);}, o.Array !== Array && (l.alloc = o.pool(l.alloc, o.Array.prototype.subarray)), l.prototype._push = function (e, t, r) {return this.tail = this.tail.next = new c(e, t, r), this.len += t, this;}, d.prototype = Object.create(c.prototype), d.prototype.fn = function (e, t, r) {for (; e > 127;) {t[r++] = 127 & e | 128, e >>>= 7;}t[r] = e;}, l.prototype.uint32 = function (e) {return this.len += (this.tail = this.tail.next = new d((e >>>= 0) < 128 ? 1 : e < 16384 ? 2 : e < 2097152 ? 3 : e < 268435456 ? 4 : 5, e)).len, this;}, l.prototype.int32 = function (e) {return e < 0 ? this._push(g, 10, i.fromNumber(e)) : this.uint32(e);}, l.prototype.sint32 = function (e) {return this.uint32((e << 1 ^ e >> 31) >>> 0);}, l.prototype.uint64 = function (e) {var t = i.from(e);return this._push(g, t.length(), t);}, l.prototype.int64 = l.prototype.uint64, l.prototype.sint64 = function (e) {var t = i.from(e).zzEncode();return this._push(g, t.length(), t);}, l.prototype.bool = function (e) {return this._push(h, 1, e ? 1 : 0);}, l.prototype.fixed32 = function (e) {return this._push(p, 4, e >>> 0);}, l.prototype.sfixed32 = l.prototype.fixed32, l.prototype.fixed64 = function (e) {var t = i.from(e);return this._push(p, 4, t.lo)._push(p, 4, t.hi);}, l.prototype.sfixed64 = l.prototype.fixed64, l.prototype.float = function (e) {return this._push(o.float.writeFloatLE, 4, e);}, l.prototype.double = function (e) {return this._push(o.float.writeDoubleLE, 8, e);};var f = o.Array.prototype.set ? function (e, t, r) {t.set(e, r);} : function (e, t, r) {for (var n = 0; n < e.length; ++n) {t[r + n] = e[n];}};l.prototype.bytes = function (e) {var t = e.length >>> 0;if (!t) return this._push(h, 1, 0);if (o.isString(e)) {var r = l.alloc(t = s.length(e));s.decode(e, r, 0), e = r;}return this.uint32(t)._push(f, t, e);}, l.prototype.string = function (e) {var t = a.length(e);return t ? this.uint32(t)._push(a.write, t, e) : this._push(h, 1, 0);}, l.prototype.fork = function () {return this.states = new function (e) {this.head = e.head, this.tail = e.tail, this.len = e.len, this.next = e.states;}(this), this.head = this.tail = new c(u, 0, 0), this.len = 0, this;}, l.prototype.reset = function () {return this.states ? (this.head = this.states.head, this.tail = this.states.tail, this.len = this.states.len, this.states = this.states.next) : (this.head = this.tail = new c(u, 0, 0), this.len = 0), this;}, l.prototype.ldelim = function () {var e = this.head,t = this.tail,r = this.len;return this.reset().uint32(r), r && (this.tail.next = e.next, this.tail = t, this.len += r), this;}, l.prototype.finish = function () {for (var e = this.head.next, t = this.constructor.alloc(this.len), r = 0; e;) {e.fn(e.val, t, r), r += e.len, e = e.next;}return t;}, l._configure = function (e) {n = e;};}, function (e, t, r) {\"use strict\";e.exports = c;var n,o = r(10),i = o.LongBits,s = o.utf8;function a(e, t) {return RangeError(\"index out of range: \" + e.pos + \" + \" + (t || 1) + \" > \" + e.len);}function c(e) {this.buf = e, this.pos = 0, this.len = e.length;}var u = \"undefined\" != typeof Uint8Array ? function (e) {if (e instanceof Uint8Array || Array.isArray(e)) return new c(e);throw Error(\"illegal buffer\");} : function (e) {if (Array.isArray(e)) return new c(e);throw Error(\"illegal buffer\");};function l() {var e = new i(0, 0),t = 0;if (!(this.len - this.pos > 4)) {for (; t < 3; ++t) {if (this.pos >= this.len) throw a(this);if (e.lo = (e.lo | (127 & this.buf[this.pos]) << 7 * t) >>> 0, this.buf[this.pos++] < 128) return e;}return e.lo = (e.lo | (127 & this.buf[this.pos++]) << 7 * t) >>> 0, e;}for (; t < 4; ++t) {if (e.lo = (e.lo | (127 & this.buf[this.pos]) << 7 * t) >>> 0, this.buf[this.pos++] < 128) return e;}if (e.lo = (e.lo | (127 & this.buf[this.pos]) << 28) >>> 0, e.hi = (e.hi | (127 & this.buf[this.pos]) >> 4) >>> 0, this.buf[this.pos++] < 128) return e;if (t = 0, this.len - this.pos > 4) {for (; t < 5; ++t) {if (e.hi = (e.hi | (127 & this.buf[this.pos]) << 7 * t + 3) >>> 0, this.buf[this.pos++] < 128) return e;}} else for (; t < 5; ++t) {if (this.pos >= this.len) throw a(this);if (e.hi = (e.hi | (127 & this.buf[this.pos]) << 7 * t + 3) >>> 0, this.buf[this.pos++] < 128) return e;}throw Error(\"invalid varint encoding\");}function h(e, t) {return (e[t - 4] | e[t - 3] << 8 | e[t - 2] << 16 | e[t - 1] << 24) >>> 0;}function d() {if (this.pos + 8 > this.len) throw a(this, 8);return new i(h(this.buf, this.pos += 4), h(this.buf, this.pos += 4));}c.create = o.Buffer ? function (e) {return (c.create = function (e) {return o.Buffer.isBuffer(e) ? new n(e) : u(e);})(e);} : u, c.prototype._slice = o.Array.prototype.subarray || o.Array.prototype.slice, c.prototype.uint32 = function () {var e = 4294967295;return function () {if (e = (127 & this.buf[this.pos]) >>> 0, this.buf[this.pos++] < 128) return e;if (e = (e | (127 & this.buf[this.pos]) << 7) >>> 0, this.buf[this.pos++] < 128) return e;if (e = (e | (127 & this.buf[this.pos]) << 14) >>> 0, this.buf[this.pos++] < 128) return e;if (e = (e | (127 & this.buf[this.pos]) << 21) >>> 0, this.buf[this.pos++] < 128) return e;if (e = (e | (15 & this.buf[this.pos]) << 28) >>> 0, this.buf[this.pos++] < 128) return e;if ((this.pos += 5) > this.len) throw this.pos = this.len, a(this, 10);return e;};}(), c.prototype.int32 = function () {return 0 | this.uint32();}, c.prototype.sint32 = function () {var e = this.uint32();return e >>> 1 ^ -(1 & e) | 0;}, c.prototype.bool = function () {return 0 !== this.uint32();}, c.prototype.fixed32 = function () {if (this.pos + 4 > this.len) throw a(this, 4);return h(this.buf, this.pos += 4);}, c.prototype.sfixed32 = function () {if (this.pos + 4 > this.len) throw a(this, 4);return 0 | h(this.buf, this.pos += 4);}, c.prototype.float = function () {if (this.pos + 4 > this.len) throw a(this, 4);var e = o.float.readFloatLE(this.buf, this.pos);return this.pos += 4, e;}, c.prototype.double = function () {if (this.pos + 8 > this.len) throw a(this, 4);var e = o.float.readDoubleLE(this.buf, this.pos);return this.pos += 8, e;}, c.prototype.bytes = function () {var e = this.uint32(),t = this.pos,r = this.pos + e;if (r > this.len) throw a(this, e);return this.pos += e, Array.isArray(this.buf) ? this.buf.slice(t, r) : t === r ? new this.buf.constructor(0) : this._slice.call(this.buf, t, r);}, c.prototype.string = function () {var e = this.bytes();return s.read(e, 0, e.length);}, c.prototype.skip = function (e) {if (\"number\" == typeof e) {if (this.pos + e > this.len) throw a(this, e);this.pos += e;} else do {if (this.pos >= this.len) throw a(this);} while (128 & this.buf[this.pos++]);return this;}, c.prototype.skipType = function (e) {switch (e) {case 0:this.skip();break;case 1:this.skip(8);break;case 2:this.skip(this.uint32());break;case 3:for (; 4 != (e = 7 & this.uint32());) {this.skipType(e);}break;case 5:this.skip(4);break;default:throw Error(\"invalid wire type \" + e + \" at offset \" + this.pos);}return this;}, c._configure = function (e) {n = e;var t = o.Long ? \"toLong\" : \"toNumber\";o.merge(c.prototype, { int64: function int64() {return l.call(this)[t](!1);}, uint64: function uint64() {return l.call(this)[t](!0);}, sint64: function sint64() {return l.call(this).zzDecode()[t](!1);}, fixed64: function fixed64() {return d.call(this)[t](!0);}, sfixed64: function sfixed64() {return d.call(this)[t](!1);} });};}, function (e, t, r) {\"use strict\";e.exports = s;var n = r(21);((s.prototype = Object.create(n.prototype)).constructor = s).className = \"OneOf\";var o = r(22),i = r(5);function s(e, t, r, o) {if (Array.isArray(t) || (r = t, t = void 0), n.call(this, e, r), void 0 !== t && !Array.isArray(t)) throw TypeError(\"fieldNames must be an Array\");this.oneof = t || [], this.fieldsArray = [], this.comment = o;}function a(e) {if (e.parent) for (var t = 0; t < e.fieldsArray.length; ++t) {e.fieldsArray[t].parent || e.parent.add(e.fieldsArray[t]);}}s.fromJSON = function (e, t) {return new s(e, t.oneof, t.options, t.comment);}, s.prototype.toJSON = function (e) {var t = !!e && Boolean(e.keepComments);return i.toObject([\"options\", this.options, \"oneof\", this.oneof, \"comment\", t ? this.comment : void 0]);}, s.prototype.add = function (e) {if (!(e instanceof o)) throw TypeError(\"field must be a Field\");return e.parent && e.parent !== this.parent && e.parent.remove(e), this.oneof.push(e.name), this.fieldsArray.push(e), e.partOf = this, a(this), this;}, s.prototype.remove = function (e) {if (!(e instanceof o)) throw TypeError(\"field must be a Field\");var t = this.fieldsArray.indexOf(e);if (t < 0) throw Error(e + \" is not a member of \" + this);return this.fieldsArray.splice(t, 1), (t = this.oneof.indexOf(e.name)) > -1 && this.oneof.splice(t, 1), e.partOf = null, this;}, s.prototype.onAdd = function (e) {n.prototype.onAdd.call(this, e);for (var t = 0; t < this.oneof.length; ++t) {var r = e.get(this.oneof[t]);r && !r.partOf && (r.partOf = this, this.fieldsArray.push(r));}a(this);}, s.prototype.onRemove = function (e) {for (var t, r = 0; r < this.fieldsArray.length; ++r) {(t = this.fieldsArray[r]).parent && t.parent.remove(t);}n.prototype.onRemove.call(this, e);}, s.d = function () {for (var e = new Array(arguments.length), t = 0; t < arguments.length;) {e[t] = arguments[t++];}return function (t, r) {i.decorateType(t.constructor).add(new s(r, e)), Object.defineProperty(t, r, { get: i.oneOfGetter(e), set: i.oneOfSetter(e) });};};}, function (e, t, r) {\"use strict\";e.exports = o;var n = r(10);function o(e) {if (e) for (var t = Object.keys(e), r = 0; r < t.length; ++r) {this[t[r]] = e[t[r]];}}o.create = function (e) {return this.$type.create(e);}, o.encode = function (e, t) {return this.$type.encode(e, t);}, o.encodeDelimited = function (e, t) {return this.$type.encodeDelimited(e, t);}, o.decode = function (e) {return this.$type.decode(e);}, o.decodeDelimited = function (e) {return this.$type.decodeDelimited(e);}, o.verify = function (e) {return this.$type.verify(e);}, o.fromObject = function (e) {return this.$type.fromObject(e);}, o.toObject = function (e, t) {return this.$type.toObject(e, t);}, o.prototype.toJSON = function () {return this.$type.toObject(this, n.toJSONOptions);};}, function (e, t, r) {\"use strict\";Object.defineProperty(t, \"__esModule\", { value: !0 }), t.TessellationCache = t.CurveTessellator = void 0;var n = r(1),o = r(0),i = r(3),s = r(8),a = { getCircularArcRenderPoints: function getCircularArcRenderPoints(e, t, r, n, o) {var i = e.getRadius(),s = 2 * Math.acos((i - r) / i),a = t[1] - t[0],c = Math.ceil(a / s),u = 0;for (!1 === n && u++; u <= c; ++u) {var l = u / c,h = t[0] * (1 - l) + t[1] * l;o.push(e.evaluatePosition(h));}return i * (1 - Math.cos(a / c * .5));}, getAdaptiveRenderPoints: function getAdaptiveRenderPoints(e, t, r, i) {for (var a = t || .001, c = a * a, u = [], l = [], h = n.Vector3.createFloat64(), d = 0, g = function g(t, r, i, a, p) {var f = i - t,v = .5 * (t + i),_ = e.evaluatePosition(v);n.Vector3.scaleAndAdd(h, [0, 0, 0], r, .5), n.Vector3.scaleAndAdd(h, h, a, .5);var y = n.Vector3.squaredDistance(h, _);if (p > 64) s.DebugUtils.warn(\"Max recursion depth reach in getAdaptiveRenderPoints\");else if (f > 10 * o.PARAMETER_SPACE_TOLERANCE && y > c) return g(t, r, v, _, p + 1), void g(v, _, i, a, p + 1);d = Math.max(d, y), u.push(r), l.push(t);}, p = i || function (e, t, r) {for (var n = new Array(7), o = t, i = (r - t) / 6, s = 0; s < 7; s++) {var a = o;s > 0 && s < 6 && (a += Math.sin(s) * i * .1), n[s] = a, o += i;}return n;}(0, r[0], r[1]), f = 0; f < p.length - 1; ++f) {var v = p[f],_ = p[f + 1],y = e.evaluatePosition(v),m = e.evaluatePosition(_);g(v, y, _, m, 0), f === p.length - 2 && (u.push(m), l.push(_));}return { positions: u, params: l, tolerance: Math.sqrt(d) };} },c = function c() {this._hasDirtyTessellation = !0, this._tessellationCache = void 0, this._trimmedTessellationCache = { positions: void 0, offsets: void 0, transitions: [1, -1] };};c.prototype.setDirty = function (e) {this._hasDirtyTessellation = e;}, c.prototype.isDirty = function () {return this._hasDirtyTessellation;}, c.prototype.reset = function () {this._hasDirtyTessellation = !0, this._tessellationCache = void 0, this._trimmedTessellationCache = { positions: void 0, offsets: void 0, transitions: [1, -1] };}, c.prototype.setCache = function (e) {this._tessellationCache = e, this._hasDirtyTessellation = !1;}, c.prototype.getCache = function () {return this._tessellationCache;}, c.prototype.getTolerance = function () {if (this._tessellationCache) return this._tessellationCache.tolerance;}, c.prototype.getTessellation = function (e, t, r, s) {var a = !1;if (!1 === this._hasDirtyTessellation && this._tessellationCache.tolerance > r + n.FLOAT64_TOLERANCE && (this._hasDirtyTessellation = !0), this._hasDirtyTessellation) {this._hasDirtyTessellation = !1;var c = s(r);this._tessellationCache = { positions: c.positions, params: c.params, tolerance: c.tolerance }, a = c.didRetessellate;}var u = [e[0], e[e.length - 1]],l = 0,h = t.getRangeUnlimited();t.isPeriodicUnlimited() && (l = (u = (0, i.normalizeParametricRangeToShiftedRange)(u, h))[0] - e[0]);var d = this._trimmedTessellationCache,g = d.transitions[0] - u[0],p = d.transitions[d.transitions.length - 1] - u[1],f = g * g + p * p < n.FLOAT64_TOLERANCE;if (f && e.length > 2) {f = d.transitions.length === e.length;for (var v = 1; f && v < e.length - 1; ++v) {f = d.transitions[v - 1] === e[v - 1] + l;}}if (!f || a) {var _;for (d.transitions.length = e.length, _ = 0; _ < e.length; ++_) {d.transitions[_] = e[_] + l;}d.positions = [t.evaluatePosition(e[0])], d.offsets = [0];var y,m,E = 1,x = u[0];for (_ = 1; _ < e.length; _++) {var R = e[_] + l;for (m = 0; m < this._tessellationCache.positions.length; m++) {if ((y = this._tessellationCache.params[m]) > x + o.PARAMETER_SPACE_TOLERANCE) {if (y >= R - o.PARAMETER_SPACE_TOLERANCE) break;n.Vector3.sqrDist(d.positions[E - 1], this._tessellationCache.positions[m]) > o.KERNEL_TOLERANCE * o.KERNEL_TOLERANCE && (d.positions[E++] = n.Vector3.clone(this._tessellationCache.positions[m]));}}if (t.isPeriodicUnlimited() && R > h[1]) for (m = 1; m < this._tessellationCache.positions.length && (y = this._tessellationCache.params[m]) < R - (h[1] - h[0]) - o.PARAMETER_SPACE_TOLERANCE; m++) {n.Vector3.sqrDist(d.positions[E - 1], this._tessellationCache.positions[m]) > o.KERNEL_TOLERANCE * o.KERNEL_TOLERANCE && (d.positions[E++] = n.Vector3.clone(this._tessellationCache.positions[m]));}var A = t.evaluatePosition(R);n.Vector3.sqrDist(d.positions[E - 1], A) < o.KERNEL_TOLERANCE * o.KERNEL_TOLERANCE && E > d.offsets[d.offsets.length - 1] + 1 && E--, d.positions[E++] = A, d.offsets.push(d.positions.length - 1), x = R;}}return { positions: d.positions, offsets: d.offsets, tolerance: this._tessellationCache.tolerance };}, t.CurveTessellator = a, t.TessellationCache = c;}, function (e, t, r) {\"use strict\";Object.defineProperty(t, \"__esModule\", { value: !0 }), t.Cone = void 0;var n = r(1),o = r(4),i = r(0),s = r(12),a = r(6),c = r(7),u = r(14),l = r(2),h = function h() {s.Surface.call(this), this._center = n.Vector3.createFloat64(), this._radius = 0, this._angle = 0, this._uScale = 1, this._xAxis = n.Vector3.createFloat64(), this._yAxis = n.Vector3.createFloat64(), this._zAxis = n.Vector3.createFloat64();};(h.prototype = Object.create(s.Surface.prototype)).getGeometryType = function () {return i.GEOMETRY_TYPES.CONE;}, h.prototype.clone = function () {var e = new h();return e.copy(this), e;}, h.prototype.copy = function (e) {s.Surface.prototype.copy.call(this, e), this._radius = e._radius, this._angle = e._angle, this._uScale = e._uScale, n.Vector3.copy(this._center, e._center), n.Vector3.copy(this._xAxis, e._xAxis), n.Vector3.copy(this._yAxis, e._yAxis), n.Vector3.copy(this._zAxis, e._zAxis);}, h.prototype._computeYAxis = function () {n.Vector3.cross(this._yAxis, this._xAxis, this._zAxis);}, h.prototype.set = function (e, t, r, o, s, a) {n.Vector3.copy(this._center, e), l.ConsoleUtils.assert(t > i.KERNEL_TOLERANCE), this._radius = t, l.ConsoleUtils.assert(n.Vector3.squaredLength(r) > i.KERNEL_TOLERANCE * i.KERNEL_TOLERANCE), n.Vector3.normalize(this._zAxis, r), l.ConsoleUtils.assert(Math.abs(o) < Math.PI / 2), this._angle = o, void 0 !== s && n.Vector3.squaredLength(s) > i.KERNEL_TOLERANCE * i.KERNEL_TOLERANCE ? (l.ConsoleUtils.assert(n.Vector3.isOrthogonal(r, s, i.KERNEL_ANGULAR_TOLERANCE)), n.Vector3.normalize(this._xAxis, s)) : (n.Vector3.computeOrthogonal(this._xAxis, this._zAxis), n.Vector3.normalize(this._xAxis, this._xAxis)), this._uScale = a || 1, l.ConsoleUtils.assert(this._uScale > i.PARAMETER_SPACE_TOLERANCE), this._computeYAxis();}, h.prototype.getRadius = function () {return this._radius;}, h.prototype.setRadius = function (e) {l.ConsoleUtils.assert(e > i.KERNEL_TOLERANCE), this._radius = e;}, h.prototype.getCenter = function () {return this._center;}, h.prototype.setCenter = function (e) {n.Vector3.copy(this._center, e);}, h.prototype.getAxisDir = function () {return this._zAxis;}, h.prototype.setAxisDir = function (e) {l.ConsoleUtils.assert(n.Vector3.squaredLength(e) > i.KERNEL_TOLERANCE * i.KERNEL_TOLERANCE), n.Vector3.normalize(this._zAxis, e), (n.Vector3.squaredLength(this._xAxis) <= i.KERNEL_TOLERANCE * i.KERNEL_TOLERANCE || !n.Vector3.isOrthogonal(this._xAxis, this._zAxis, i.KERNEL_ANGULAR_TOLERANCE)) && (n.Vector3.computeOrthogonal(this._xAxis, this._zAxis), n.Vector3.normalize(this._xAxis, this._xAxis)), this._computeYAxis();}, h.prototype.getUvOriginDir = function () {return this._xAxis;}, h.prototype.setUvOriginDir = function (e) {l.ConsoleUtils.assert(n.Vector3.squaredLength(e) > i.KERNEL_TOLERANCE * i.KERNEL_TOLERANCE), n.Vector3.normalize(this._xAxis, e), this._computeYAxis();}, h.prototype.getUScale = function () {return this._uScale;}, h.prototype.setUScale = function (e) {l.ConsoleUtils.assert(e > i.PARAMETER_SPACE_TOLERANCE), this._uScale = e;}, h.prototype.getAngle = function () {return this._angle;}, h.prototype.setAngle = function (e) {l.ConsoleUtils.assert(Math.abs(e) < Math.PI / 2 - i.KERNEL_ANGULAR_TOLERANCE), this._angle = e;}, h.prototype.isCylinder = function () {return Math.abs(this._angle) < i.KERNEL_ANGULAR_TOLERANCE;}, h.prototype.getApexParam = function () {return this.isCylinder() ? void 0 : -this._radius / (this._uScale * Math.sin(this._angle));}, h.prototype.getApexPosition = function () {if (!this.isCylinder()) {var e = -this._radius / Math.tan(this._angle),t = n.Vector3.clone(this._center);return n.Vector3.scaleAndAdd(t, t, this._zAxis, e), t;}}, h.prototype.evaluatePosition = function (e, t) {var r = this._radius + e * this._uScale * Math.sin(this._angle),o = r * Math.cos(t),i = r * Math.sin(t),s = e * this._uScale * Math.cos(this._angle),a = n.Vector3.clone(this._center);return n.Vector3.scaleAndAdd(a, a, this._xAxis, o), n.Vector3.scaleAndAdd(a, a, this._yAxis, i), n.Vector3.scaleAndAdd(a, a, this._zAxis, s), a;}, h.prototype.evaluateNormal = function (e, t) {var r = Math.sin(this._angle),o = Math.cos(this._angle),i = o * Math.cos(t),s = o * Math.sin(t),a = -r,c = n.Vector3.createFloat64();return n.Vector3.scale(c, this._xAxis, i), n.Vector3.scaleAndAdd(c, c, this._yAxis, s), n.Vector3.scaleAndAdd(c, c, this._zAxis, a), c;}, h.prototype.evaluateDu = function (e, t) {var r = this._uScale * Math.sin(this._angle),o = r * Math.cos(t),i = r * Math.sin(t),s = this._uScale * Math.cos(this._angle),a = n.Vector3.createFloat64();return n.Vector3.scale(a, this._xAxis, o), n.Vector3.scaleAndAdd(a, a, this._yAxis, i), n.Vector3.scaleAndAdd(a, a, this._zAxis, s), a;}, h.prototype.evaluateDv = function (e, t) {var r = this._radius + e * this._uScale * Math.sin(this._angle),o = -r * Math.sin(t),i = r * Math.cos(t),s = n.Vector3.createFloat64();return n.Vector3.scale(s, this._xAxis, o), n.Vector3.scaleAndAdd(s, s, this._yAxis, i), s;}, h.prototype.closestParam = function (e) {var t = Math.sin(this._angle),r = Math.cos(this._angle),o = n.Vector3.createFloat64();n.Vector3.sub(o, e, this._center);var s = n.Vector3.dot(o, this._xAxis),a = n.Vector3.dot(o, this._yAxis),c = n.Vector3.dot(o, this._zAxis),u = Math.sqrt(s * s + a * a),l = this.getApexParam();if (void 0 !== l) {var h = l * this._uScale * r;(h > 0 && c > h || h < 0 && c < h) && (s = -s, a = -a, u = -u);}return { u: ((u - this._radius) * t + c * r) / this._uScale, v: Math.abs(u) > i.KERNEL_TOLERANCE ? Math.atan2(a, s) : 0 };}, h.prototype.vParamLine = function (e) {var t = this._radius + e * this._uScale * Math.sin(this._angle);if (Math.abs(t) > i.KERNEL_TOLERANCE) {var r = new u.Circle(),o = n.Vector3.clone(this._center),s = e * this._uScale * Math.cos(this._angle);n.Vector3.scaleAndAdd(o, o, this._zAxis, s);var c = n.Vector3.clone(this._xAxis);n.Vector3.scale(c, c, t);var l = n.Vector3.clone(this._zAxis);return n.Vector3.negate(l, l), r.set(o, l, c), r;}return new a.Point(this.getApexPosition());}, h.prototype.uParamLine = function (e) {var t = new c.Line(),r = n.Vector3.clone(this._center),o = this._radius * Math.cos(e),i = this._radius * Math.sin(e);return n.Vector3.scaleAndAdd(r, r, this._xAxis, o), n.Vector3.scaleAndAdd(r, r, this._yAxis, i), t.set(r, this.evaluateDu(0, e)), t;}, h.prototype.getBoundingBox = function (e, t) {if (e) {var r = e[0],n = e[1],i = this.vParamLine(r).getBoundingBox(t);return i.include(this.vParamLine(n).getBoundingBox(t)), i;}return new o.BoundingBox([-1 / 0, -1 / 0, -1 / 0], [1 / 0, 1 / 0, 1 / 0]);}, h.prototype.transform = function (e) {n.Vector3.transformMatrix44(this._center, this._center, e), n.Vector3.transformAsDirectionMatrix44(this._xAxis, this._xAxis, e), n.Vector3.transformAsDirectionMatrix44(this._yAxis, this._yAxis, e), n.Vector3.transformAsDirectionMatrix44(this._zAxis, this._zAxis, e);var t = n.Vector3.length(this._xAxis);this._radius *= t, this._uScale *= t, n.Vector3.normalize(this._xAxis, this._xAxis), n.Vector3.normalize(this._yAxis, this._yAxis), n.Vector3.normalize(this._zAxis, this._zAxis);}, h.prototype.getRangeUnlimitedU = function () {return [-1 / 0, 1 / 0];}, h.prototype.getRangeUnlimitedV = function () {return [-Math.PI, Math.PI];}, h.prototype.isPeriodicUnlimitedU = function () {return !1;}, h.prototype.isPeriodicUnlimitedV = function () {return !0;}, h.prototype.isClosedUnlimitedU = function () {return !1;}, h.prototype.isClosedUnlimitedV = function () {return !0;}, h.prototype.toObject = function () {var e = this.evaluatePosition(0, 0);return n.Vector3.sub(e, e, this.getCenter()), { center: this.vectorToObject(this._center), radius: this.vectorToObject(e), axis: this.vectorToObject(this.getAxisDir()), uCoordScale: this.getUScale(), angle: this.getAngle(), uRange: this.rangeToObject(this.getRangeU(), this.isLimitedU()), vRange: this.rangeToObject(this.getRangeV(), this.isLimitedV()) };}, t.Cone = h;}, function (e, t, r) {\"use strict\";Object.defineProperty(t, \"__esModule\", { value: !0 }), t.EllipticalCone = void 0;var n = r(1),o = r(4),i = r(35),s = r(0),a = r(12),c = r(6),u = r(7),l = r(23),h = r(2),d = function d() {a.Surface.call(this), this._center = n.Vector3.createFloat64(), this._majorRadius = 0, this._minorRadius = 0, this._angle = 0, this._uScale = 1, this._xAxis = n.Vector3.createFloat64(), this._yAxis = n.Vector3.createFloat64(), this._zAxis = n.Vector3.createFloat64();};(d.prototype = Object.create(a.Surface.prototype)).getGeometryType = function () {return s.GEOMETRY_TYPES.ELLIPTICAL_CONE;}, d.prototype.clone = function () {var e = new d();return e.copy(this), e;}, d.prototype.copy = function (e) {a.Surface.prototype.copy.call(this, e), this._majorRadius = e._majorRadius, this._minorRadius = e._minorRadius, this._angle = e._angle, this._uScale = e._uScale, n.Vector3.copy(this._center, e._center), n.Vector3.copy(this._xAxis, e._xAxis), n.Vector3.copy(this._yAxis, e._yAxis), n.Vector3.copy(this._zAxis, e._zAxis);}, d.prototype._computeYAxis = function () {n.Vector3.cross(this._yAxis, this._xAxis, this._zAxis);}, d.prototype.set = function (e, t, r, o, i, a) {n.Vector3.copy(this._center, e), this._majorRadius = n.Vector3.length(t), h.ConsoleUtils.assert(this._majorRadius > s.KERNEL_TOLERANCE), n.Vector3.normalize(this._xAxis, t), h.ConsoleUtils.assert(r <= 1), this._minorRadius = r * this._majorRadius, h.ConsoleUtils.assert(this._minorRadius > s.KERNEL_TOLERANCE), h.ConsoleUtils.assert(n.Vector3.squaredLength(o) > s.KERNEL_TOLERANCE * s.KERNEL_TOLERANCE), h.ConsoleUtils.assert(n.Vector3.isOrthogonal(o, t, s.KERNEL_ANGULAR_TOLERANCE)), n.Vector3.normalize(this._zAxis, o), h.ConsoleUtils.assert(Math.abs(i) < Math.PI / 2), this._angle = i, this._uScale = a || 1, h.ConsoleUtils.assert(this._uScale > s.PARAMETER_SPACE_TOLERANCE), this._computeYAxis();}, d.prototype.getMajorRadius = function () {return this._majorRadius;}, d.prototype.setMajorRadius = function (e) {h.ConsoleUtils.assert(e > s.KERNEL_TOLERANCE), this._majorRadius = e;}, d.prototype.getMinorRadius = function () {return this._minorRadius;}, d.prototype.setMinorRadius = function (e) {h.ConsoleUtils.assert(e > s.KERNEL_TOLERANCE), this._minorRadius = e;}, d.prototype.getMajorAxis = function () {return this._xAxis;}, d.prototype.setMajorAxis = function (e) {h.ConsoleUtils.assert(n.Vector3.squaredLength(e) > s.KERNEL_TOLERANCE * s.KERNEL_TOLERANCE), n.Vector3.normalize(this._xAxis, e), this._computeYAxis();}, d.prototype.getCenter = function () {return this._center;}, d.prototype.setCenter = function (e) {n.Vector3.copy(this._center, e);}, d.prototype.getAxisDir = function () {return this._zAxis;}, d.prototype.setAxisDir = function (e) {h.ConsoleUtils.assert(n.Vector3.squaredLength(e) > s.KERNEL_TOLERANCE * s.KERNEL_TOLERANCE), n.Vector3.normalize(this._zAxis, e), this._computeYAxis();}, d.prototype.getUScale = function () {return this._uScale;}, d.prototype.setUScale = function (e) {h.ConsoleUtils.assert(e > s.PARAMETER_SPACE_TOLERANCE), this._uScale = e;}, d.prototype.getAngle = function () {return this._angle;}, d.prototype.setAngle = function (e) {h.ConsoleUtils.assert(Math.abs(e) < Math.PI / 2 - s.KERNEL_ANGULAR_TOLERANCE), this._angle = e;}, d.prototype.isCylinder = function () {return Math.abs(this._angle) < s.KERNEL_ANGULAR_TOLERANCE;}, d.prototype.getApexParam = function () {return this.isCylinder() ? void 0 : -this._majorRadius / (this._uScale * Math.sin(this._angle));}, d.prototype.getApexPosition = function () {if (!this.isCylinder()) {var e = -this._majorRadius / Math.tan(this._angle),t = n.Vector3.clone(this._center);return n.Vector3.scaleAndAdd(t, t, this._zAxis, e), t;}}, d.prototype.evaluatePosition = function (e, t) {var r = 1 + e * this._uScale * Math.sin(this._angle) / this._majorRadius,o = r * this._majorRadius * Math.cos(t),i = r * this._minorRadius * Math.sin(t),s = e * this._uScale * Math.cos(this._angle),a = n.Vector3.clone(this._center);return n.Vector3.scaleAndAdd(a, a, this._xAxis, o), n.Vector3.scaleAndAdd(a, a, this._yAxis, i), n.Vector3.scaleAndAdd(a, a, this._zAxis, s), a;}, d.prototype.evaluateNormal = function (e, t) {var r = Math.cos(this._angle),o = r * this._minorRadius * Math.cos(t),i = r * this._majorRadius * Math.sin(t),s = -Math.sin(this._angle) * this._minorRadius,a = n.Vector3.createFloat64();return n.Vector3.scale(a, this._xAxis, o), n.Vector3.scaleAndAdd(a, a, this._yAxis, i), n.Vector3.scaleAndAdd(a, a, this._zAxis, s), n.Vector3.normalize(a, a), a;}, d.prototype.evaluateDu = function (e, t) {var r = this._uScale * Math.sin(this._angle) / this._majorRadius,o = r * this._majorRadius * Math.cos(t),i = r * this._minorRadius * Math.sin(t),s = this._uScale * Math.cos(this._angle),a = n.Vector3.createFloat64();return n.Vector3.scale(a, this._xAxis, o), n.Vector3.scaleAndAdd(a, a, this._yAxis, i), n.Vector3.scaleAndAdd(a, a, this._zAxis, s), a;}, d.prototype.evaluateDv = function (e, t) {var r = 1 + e * this._uScale * Math.sin(this._angle) / this._majorRadius,o = -r * this._majorRadius * Math.sin(t),i = r * this._minorRadius * Math.cos(t),s = n.Vector3.createFloat64();return n.Vector3.scale(s, this._xAxis, o), n.Vector3.scaleAndAdd(s, s, this._yAxis, i), s;}, d.prototype.closestParam = function (e) {var t, r;if (this.isCylinder()) {var o = n.Vector3.createFloat64();n.Vector3.sub(o, e, this._center), t = n.Vector3.dot(o, this._zAxis) / this._uScale, r = this.vParamLine(t).closestToPointParam(e);} else {var a = n.Vector3.createFloat64();n.Vector3.sub(a, e, this.getApexPosition());var c = n.Vector3.dot(a, this._xAxis),u = n.Vector3.dot(a, this._yAxis),l = n.Vector3.dot(a, this._zAxis),h = this._uScale * Math.sin(this._angle),d = h * this._minorRadius / this._majorRadius,g = this._uScale * Math.cos(this._angle),p = this._majorRadius / h,f = function (e, t, r, o, a, c) {if (o * o + a * a + c * c < s.KERNEL_TOLERANCE * s.KERNEL_TOLERANCE) return { u: 0, v: 0 };var u = n.FLOAT64_TOLERANCE,l = c * e >= 0 ? 1 : -1,h = (o * l >= 0 ? .25 : .75) * (a * l >= 0 ? 1 : -1),d = h * Math.PI,g = [(h - .25) * Math.PI, (h + .25) * Math.PI],p = (0, i.newtonRaphson1D)(function (n) {var i = Math.sin(n),s = Math.cos(n),u = e * (t * t + r * r) * o,l = t * (e * e + r * r) * a,h = r * (e * e - t * t) * c;return { val: u * i - l * s - h * i * s, deriv: u * s + l * i - h * (s * s - i * i) };}, g, d, u, 32),f = e * Math.cos(p),v = t * Math.sin(p);return { u: (f * o + v * a + r * c) / (f * f + v * v + r * r), v: p };}(h, d, g, c, u, l);t = f.u - p, r = f.v;}return { u: t, v: r };}, d.prototype.vParamLine = function (e) {var t = this._majorRadius + e * this._uScale * Math.sin(this._angle);if (Math.abs(t) > s.KERNEL_TOLERANCE) {var r = new l.Ellipse(),o = n.Vector3.clone(this._center),i = e * this._uScale * Math.cos(this._angle);n.Vector3.scaleAndAdd(o, o, this._zAxis, i);var a = n.Vector3.clone(this._xAxis);n.Vector3.scale(a, a, t);var u = n.Vector3.clone(this._zAxis);return n.Vector3.negate(u, u), r.set(o, u, a, this._minorRadius / this._majorRadius), r;}return new c.Point(this.getApexPosition());}, d.prototype.uParamLine = function (e) {var t = new u.Line(),r = n.Vector3.clone(this._center),o = this._majorRadius * Math.cos(e),i = this._minorRadius * Math.sin(e);return n.Vector3.scaleAndAdd(r, r, this._xAxis, o), n.Vector3.scaleAndAdd(r, r, this._yAxis, i), t.set(r, this.evaluateDu(0, e)), t;}, d.prototype.getBoundingBox = function (e, t) {if (e) {var r = e[0],n = e[1],i = this.vParamLine(r).getBoundingBox(t);return i.include(this.vParamLine(n).getBoundingBox(t)), i;}return new o.BoundingBox([-1 / 0, -1 / 0, -1 / 0], [1 / 0, 1 / 0, 1 / 0]);}, d.prototype.transform = function (e) {n.Vector3.transformMatrix44(this._center, this._center, e), n.Vector3.transformAsDirectionMatrix44(this._xAxis, this._xAxis, e), n.Vector3.transformAsDirectionMatrix44(this._yAxis, this._yAxis, e), n.Vector3.transformAsDirectionMatrix44(this._zAxis, this._zAxis, e);var t = n.Vector3.length(this._xAxis);this._majorRadius *= t, this._minorRadius *= t, this._uScale *= t, n.Vector3.normalize(this._xAxis, this._xAxis), n.Vector3.normalize(this._yAxis, this._yAxis), n.Vector3.normalize(this._zAxis, this._zAxis);}, d.prototype.getRangeUnlimitedU = function () {return [-1 / 0, 1 / 0];}, d.prototype.getRangeUnlimitedV = function () {return [-Math.PI, Math.PI];}, d.prototype.isPeriodicUnlimitedU = function () {return !1;}, d.prototype.isPeriodicUnlimitedV = function () {return !0;}, d.prototype.isClosedUnlimitedU = function () {return !1;}, d.prototype.isClosedUnlimitedV = function () {return !0;}, d.prototype.toObject = function () {var e = this.evaluatePosition(0, 0);return n.Vector3.sub(e, e, this.getCenter()), { center: this.vectorToObject(this._center), majorRadius: this.vectorToObject(e), axis: this.vectorToObject(this.getAxisDir()), uCoordScale: this.getUScale(), radiusRatio: this.getMinorRadius() / this.getMajorRadius(), angle: this.getAngle(), uRange: this.rangeToObject(this.getRangeU(), this.isLimitedU()), vRange: this.rangeToObject(this.getRangeV(), this.isLimitedV()) };}, t.EllipticalCone = d;}, function (e, t, r) {\"use strict\";Object.defineProperty(t, \"__esModule\", { value: !0 }), t.BSurface = void 0;var n = r(1),o = r(4),i = r(0),s = r(12),a = r(33),c = r(3),u = r(76),l = r(103),h = r(104),d = r(105),g = r(77),p = r(2),f = function f() {s.Surface.call(this), this._uDegree = 0, this._vDegree = 0, this._uKnots = [], this._vKnots = [], this._controlPoints = [], this._weights = [], this._isClosedU = void 0, this._isClosedV = void 0, this._isPeriodicU = void 0, this._isPeriodicV = void 0, this._patches = void 0;};(f.prototype = Object.create(s.Surface.prototype)).getGeometryType = function () {return i.GEOMETRY_TYPES.BSURFACE;}, f.prototype.clone = function () {var e = new f();return e.copy(this), e;}, f.prototype.copy = function (e) {s.Surface.prototype.copy.call(this, e), this._uDegree = e._uDegree, this._vDegree = e._vDegree, this._uKnots = e._uKnots.slice(0), this._vKnots = e._vKnots.slice(0), this._controlPoints = e._controlPoints.slice(0), this._weights = e._weights.slice(0), this._clearCaches();}, f.prototype.set = function (e, t, r, n, o, i) {p.ConsoleUtils.assert(e >= 1), this._uDegree = e, p.ConsoleUtils.assert(t >= 1), this._vDegree = t, p.ConsoleUtils.assert(r.length >= 2 * (e + 1)), this._uKnots = Array.prototype.slice.call(r), p.ConsoleUtils.assert(n.length >= 2 * (t + 1)), this._vKnots = Array.prototype.slice.call(n);var s = r.length - e - 1,a = n.length - t - 1;p.ConsoleUtils.assert(o.length === 3 * s * a), this._controlPoints = Array.prototype.slice.call(o), i && i.length > 0 ? (p.ConsoleUtils.assert(i.length === s * a), this._weights = Array.prototype.slice.call(i)) : this._weights = [], this._clearCaches();}, f.prototype.getDegreeU = function () {return this._uDegree;}, f.prototype.getDegreeV = function () {return this._vDegree;}, f.prototype.setDegreeU = function (e) {p.ConsoleUtils.assert(e >= 1), this._uDegree = e, this._clearCaches();}, f.prototype.setDegreeV = function (e) {p.ConsoleUtils.assert(e >= 1), this._vDegree = e, this._clearCaches();}, f.prototype.getNumKnotsU = function () {return this._uKnots.length;}, f.prototype.getNumKnotsV = function () {return this._vKnots.length;}, f.prototype.getKnotsU = function () {return this._uKnots;}, f.prototype.getKnotsV = function () {return this._vKnots;}, f.prototype.setKnotsU = function (e) {this._uKnots = e, this._clearCaches();}, f.prototype.setKnotsV = function (e) {this._vKnots = e, this._clearCaches();}, f.prototype.getNumControlPointsU = function () {return this._uKnots.length - this._uDegree - 1;}, f.prototype.getNumControlPointsV = function () {return this._vKnots.length - this._vDegree - 1;}, f.prototype.getControlPoints = function () {return this._controlPoints;}, f.prototype.setControlPoints = function (e) {this._controlPoints = e, this._clearCaches();}, f.prototype.getWeights = function () {return this._weights;}, f.prototype.setWeights = function (e) {e && e.length > 0 ? this._weights = e : this._weights = [], this._clearCaches();}, f.prototype.isRational = function () {return this._weights.length > 0;}, f.prototype.evaluate = function (e, t, r, n, o) {p.ConsoleUtils.assert(r >= 0), this.isPeriodicUnlimitedU() && (e = (0, c.normalizeParameterToShiftedRange)(e, this.getRangeUnlimitedU())), this.isPeriodicUnlimitedV() && (t = (0, c.normalizeParameterToShiftedRange)(t, this.getRangeUnlimitedV()));var i = (0, u.evaluateBSurfaceDerivs)(e, t, Math.min(r, 3), this._uDegree, this._vDegree, this._uKnots, this._vKnots, this._controlPoints, this._weights),s = { pos: i[0][0] };return r >= 1 && (s.du = i[1][0], s.dv = i[0][1]), r >= 2 && (s.duu = i[2][0], s.duv = i[1][1], s.dvv = i[0][2]), r >= 3 && (s.duuu = i[3][0], s.duuv = i[2][1], s.duvv = i[1][2], s.dvvv = i[0][3]), s;}, f.prototype.evaluatePosition = function (e, t) {return this.isPeriodicUnlimitedU() && (e = (0, c.normalizeParameterToShiftedRange)(e, this.getRangeUnlimitedU())), this.isPeriodicUnlimitedV() && (t = (0, c.normalizeParameterToShiftedRange)(t, this.getRangeUnlimitedV())), (0, u.evaluateBSurfacePoint)(e, t, this._uDegree, this._vDegree, this._uKnots, this._vKnots, this._controlPoints, this._weights);}, f.prototype.evaluateNormal = function (e, t) {return this.isPeriodicUnlimitedU() && (e = (0, c.normalizeParameterToShiftedRange)(e, this.getRangeUnlimitedU())), this.isPeriodicUnlimitedV() && (t = (0, c.normalizeParameterToShiftedRange)(t, this.getRangeUnlimitedV())), s.Surface.prototype.evaluateNormal.call(this, e, t);}, f.prototype.evaluateDu = function (e, t) {return this.isPeriodicUnlimitedU() && (e = (0, c.normalizeParameterToShiftedRange)(e, this.getRangeUnlimitedU())), this.isPeriodicUnlimitedV() && (t = (0, c.normalizeParameterToShiftedRange)(t, this.getRangeUnlimitedV())), (0, u.evaluateBSurfaceDerivs)(e, t, 1, this._uDegree, this._vDegree, this._uKnots, this._vKnots, this._controlPoints, this._weights)[1][0];}, f.prototype.evaluateDv = function (e, t) {return this.isPeriodicUnlimitedU() && (e = (0, c.normalizeParameterToShiftedRange)(e, this.getRangeUnlimitedU())), this.isPeriodicUnlimitedV() && (t = (0, c.normalizeParameterToShiftedRange)(t, this.getRangeUnlimitedV())), (0, u.evaluateBSurfaceDerivs)(e, t, 1, this._uDegree, this._vDegree, this._uKnots, this._vKnots, this._controlPoints, this._weights)[0][1];}, f.prototype.insertKnotU = function (e, t) {var r = (0, l.insertBSurfaceKnotU)(e, t, this._uDegree, this._vDegree, this._uKnots, this._vKnots, this._controlPoints, this._weights);this._uKnots = r.uknots, this._controlPoints = r.P, this._weights = r.weights || [], this._clearCaches();}, f.prototype.insertKnotV = function (e, t) {var r = (0, l.insertBSurfaceKnotV)(e, t, this._uDegree, this._vDegree, this._uKnots, this._vKnots, this._controlPoints, this._weights);this._vKnots = r.vknots, this._controlPoints = r.P, this._weights = r.weights || [], this._clearCaches();}, f.prototype.relaxToPerpendicular = function (e, t, r, o, i, s, a) {var c = this;o && 0 !== o.length || (o = this.getRangeU()), i && 0 !== i.length || (i = this.getRangeV());var u = (0, g.newtonRaphson2D)(function (t) {var r = c.evaluate(t[0], t[1], 2);n.Vector3.sub(r.pos, r.pos, e);var o = n.Vector3.dot(r.du, r.pos),i = n.Vector3.dot(r.dv, r.pos),s = n.Vector3.dot(r.duu, r.pos) + n.Vector3.dot(r.du, r.du),a = n.Vector3.dot(r.duv, r.pos) + n.Vector3.dot(r.du, r.dv);return { val: [o, i], deriv1: [s, a], deriv2: [a, n.Vector3.dot(r.dvv, r.pos) + n.Vector3.dot(r.dv, r.dv)] };}, [t, r], [o, i]);return { u: u.param[0], v: u.param[1], status: u.status };}, f.prototype.closestParam = function (e) {for (var t = n.FLOAT64_TOLERANCE, r = [[this.getRangeU(), this.getRangeV()]], o = this.getBezierPatches(), i = (0, d.closestBSurfacePatches)(e, o, r), s = Number.POSITIVE_INFINITY, a = { u: void 0, v: void 0 }, u = 0; u < i.length; ++u) {if (!(i[u].minDistSqr > s)) for (var l = i[u].index, h = o[l[0]][l[1]], g = h.getRangeUnlimitedU(), p = h.getRangeUnlimitedV(), f = 0; f < r.length; ++f) {var v = [Math.max(g[0], r[f][0][0]), Math.min(g[1], r[f][0][1])],_ = [Math.max(p[0], r[f][1][0]), Math.min(p[1], r[f][1][1])];if (!(v[1] - v[0] <= n.FLOAT64_TOLERANCE || _[1] - _[0] <= n.FLOAT64_TOLERANCE)) {var y = (0, d.closestBSurfacePointApprox)(e, h.getDegreeU(), h.getDegreeV(), h.getKnotsU(), h.getKnotsV(), h.getControlPoints(), h.isRational() ? h.getWeights() : void 0, v, _),m = this.relaxToPerpendicular(e, y.u, y.v, v, _, t, 64),E = h.evaluatePosition(m.u, m.v),x = n.Vector3.squaredDistance(E, e);x < s && (s = x, a.u = m.u, a.v = m.v);}}}return this.isPeriodicUnlimitedU() && (a.u = (0, c.foldNearTo)(a.u, .5 * (this.getRangeU()[0] + this.getRangeU()[1]), this.getPeriodUnlimitedU())), this.isPeriodicUnlimitedV() && (a.v = (0, c.foldNearTo)(a.v, .5 * (this.getRangeV()[0] + this.getRangeV()[1]), this.getPeriodUnlimitedV())), a;}, f.prototype.vParamLine = function (e) {var t = (0, l.extractBSurfaceParamLineV)(e, this._uDegree, this._vDegree, this._uKnots, this._vKnots, this._controlPoints, this._weights),r = t.ctrlPts.length / 3;t.weights && 0 !== t.weights.length || (t.weights = new Array(r), t.weights.fill(1));var n = new a.BCurve();return n.set(t.ctrlPts, t.weights, this._vDegree, this._vKnots), n;}, f.prototype.uParamLine = function (e) {var t = (0, l.extractBSurfaceParamLineU)(e, this._uDegree, this._vDegree, this._uKnots, this._vKnots, this._controlPoints, this._weights),r = t.ctrlPts.length / 3;t.weights && 0 !== t.weights.length || (t.weights = new Array(r), t.weights.fill(1));var n = new a.BCurve();return n.set(t.ctrlPts, t.weights, this._uDegree, this._uKnots), n;}, f.prototype.getBoundingBox = function (e, t) {for (var r = new o.BoundingBox(), i = n.Vector3.createFloat64(), s = 0; s < this._controlPoints.length; s += 3) {n.Vector3.set(i, this._controlPoints[s], this._controlPoints[s + 1], this._controlPoints[s + 2]), r.includePoint(i);}return r;}, f.prototype.transform = function (e) {for (var t = n.Vector3.createFloat64(), r = 0; r < this._controlPoints.length; r += 3) {n.Vector3.set(t, this._controlPoints[r], this._controlPoints[r + 1], this._controlPoints[r + 2]), n.Vector3.transformMatrix44(t, t, e), this._controlPoints[r] = t[0], this._controlPoints[r + 1] = t[1], this._controlPoints[r + 2] = t[2];}this._clearCaches();}, f.prototype.getRangeUnlimitedU = function () {return [this._uKnots[0], this._uKnots[this._uKnots.length - 1]];}, f.prototype.getRangeUnlimitedV = function () {return [this._vKnots[0], this._vKnots[this._vKnots.length - 1]];}, f.prototype.isPeriodicUnlimitedU = function () {return this._checkClosure(), this._isPeriodicU;}, f.prototype.isPeriodicUnlimitedV = function () {return this._checkClosure(), this._isPeriodicV;}, f.prototype.isClosedUnlimitedU = function () {return this._checkClosure(), this._isClosedU;}, f.prototype.isClosedUnlimitedV = function () {return this._checkClosure(), this._isClosedV;}, f.prototype._checkClosure = function () {void 0 !== this._isClosedU && void 0 !== this._isPeriodicU || (this._isClosedU = this._isPeriodicU = !1), void 0 !== this._isClosedV && void 0 !== this._isPeriodicV || (this._isClosedV = this._isPeriodicV = !1);}, f.prototype.isSimpleBezier = function () {return this._uKnots.length === 2 * this._uDegree + 2 && this._vKnots.length === 2 * this._vDegree + 2;}, f.prototype.getBezierPatches = function () {if (this.isSimpleBezier()) return this._patches = void 0, [[this]];if (!this._patches) {var e = (0, h.decomposeBSurfaceToBezier)(this._uDegree, this._vDegree, this._uKnots, this._vKnots, this._controlPoints, this._weights);this._patches = [];for (var t = 0; t < e.U.length; ++t) {this._patches[t] = [];for (var r = 0; r < e.V.length; ++r) {var n = new f();n.set(this._uDegree, this._vDegree, e.U[t], e.V[r], e.P[t][r], e.w ? e.w[t][r] : void 0), this._patches[t][r] = n;}}}return this._patches;}, f.prototype._clearCaches = function () {this._isClosedU = void 0, this._isClosedV = void 0, this._isPeriodicU = void 0, this._isPeriodicV = void 0, this._patches = void 0;}, f.prototype.toObject = function () {return { uDegree: this._uDegree, vDegree: this._vDegree, uKnots: this._uKnots, vKnots: this._vKnots, controlPoints: this._controlPoints, weights: this._weights, uRange: this.rangeToObject(this.getRangeU(), this.isLimitedU()), vRange: this.rangeToObject(this.getRangeV(), this.isLimitedV()) };}, t.BSurface = f;}, function (e, t, r) {\"use strict\";Object.defineProperty(t, \"__esModule\", { value: !0 }), t.WireBody = void 0;var n = r(9),o = r(0),i = r(4),s = r(19),a = function a() {n.BaseTopology.call(this), this._wires = [];};(a.prototype = Object.create(n.BaseTopology.prototype)).getTopologyType = function () {return o.TOPOLOGY_TYPES.WIREBODY;}, a.prototype.getWires = function () {return this._wires;}, a.prototype.setWires = function (e) {this._wires = new Array(e.length);for (var t = 0; t < e.length; ++t) {this._wires[t] = e[t];}}, a.prototype.addWire = function (e) {this._wires ? this._wires.push(e) : this._wires = [e], e.setWireBody(this);}, a.prototype.addWires = function (e) {this._wires || (this._wires = []);for (var t = 0; t < e.length; ++t) {e[t].setWireBody(this);}this._wires = this._wires.concat(e);}, a.prototype.removeWire = function (e) {var t = this._wires.indexOf(e);return t > -1 && (this._wires.splice(t, 1), e.getWireBody() === this && e.setWireBody(void 0), !0);}, a.prototype.getBody = function () {return this;}, a.prototype.collectFaces = function (e) {return e || new Set();}, a.prototype.collectEdges = function (e) {e = e || new Set();for (var t = 0; t < this._wires.length; ++t) {this._wires[t].collectEdges(e);}return e;}, a.prototype.collectVertices = function (e) {e = e || new Set();for (var t = 0; t < this._wires.length; ++t) {this._wires[t].collectVertices(e);}return e;}, a.prototype.getBoundingBox = function () {for (var e = new i.BoundingBox(), t = 0; t < this._wires.length; ++t) {e.include(this._wires[t].getBoundingBox());}return e;}, a.prototype.transform = function (e) {(0, s.transformTopology)(this, e);}, a.prototype.toString = function () {return \"WireBody\";}, a.prototype.toObject = function () {return { wires: this.refsToStrings(this._wires), attributes: this.refsToStrings(this._attributes) };}, a.prototype.addToModelObject = function (e) {this.addAllToModelObject(e, [this._wires, this._attributes]);}, t.WireBody = a;}, function (e, t, r) {\"use strict\";Object.defineProperty(t, \"__esModule\", { value: !0 }), t.TopologyCloner = void 0;var n = r(16),o = r(20),i = r(27),s = r(13),a = r(15),c = r(26),u = r(25),l = r(24),h = r(41),d = function d() {this._edgeMap = {}, this._vertexMap = {}, this._coedgeMap = {}, this._progenitorMap = new h.ProgenitorMap();};d.prototype.cloneVertex = function (e) {var t = this._vertexMap[e.getGuid()];return t || (t = new n.Vertex(e.getPoint().clone()), this._vertexMap[e.getGuid()] = t, t.setPrecision(e.getPrecision()), this._progenitorMap.addEntry(t, [e])), t;}, d.prototype.cloneEdge = function (e) {var t = this._edgeMap[e.getGuid()];return t || (t = new o.Edge(e.getCurve().clone()), this._edgeMap[e.getGuid()] = t, t.setReversed(e.isReversed()), t.setRange(e.getRange()), t.setStartVertex(this.cloneVertex(e.getStartVertex())), t.setEndVertex(this.cloneVertex(e.getEndVertex())), t.setPrecision(e.getPrecision()), this._progenitorMap.addEntry(t, [e])), t;}, d.prototype.cloneCoedge = function (e) {var t,r,n = new i.Coedge();this._coedgeMap[e.getGuid()] = n, n.setReversed(e.isReversed()), n.setEdge(this.cloneEdge(e.getEdge())), n.getEdge().setCoedge(n);for (var o = e.getPartner(); o;) {var s = this._coedgeMap[o.getGuid()];s && (t || (t = s), r = s, e.getEdge().getCoedge() === o && n.getEdge().setCoedge(s)), (o = o.getPartner()) === e && (o = void 0);}return t && r && (n.setPartner(t), r.setPartner(n)), this._progenitorMap.addEntry(n, [e]), n;}, d.prototype.cloneLoop = function (e) {for (var t = new s.Loop(), r = e.getCoedges(), n = new Array(r.length), o = 0; o < r.length; ++o) {n[o] = this.cloneCoedge(r[o]);}return t.addCoedges(n), this._progenitorMap.addEntry(t, [e]), t;}, d.prototype.cloneFace = function (e) {for (var t = new a.Face(), r = e.getLoops(), n = new Array(r.length), o = 0; o < r.length; ++o) {n[o] = this.cloneLoop(r[o]);}return t.addLoops(n), t.setSurface(e.getSurface().clone()), t.setReversed(e.isReversed()), this._progenitorMap.addEntry(t, [e]), t;}, d.prototype.cloneFaces = function (e) {for (var t = new Array(e.length), r = 0; r < e.length; ++r) {t[r] = this.cloneFace(e[r]);}return t;}, d.prototype.cloneShell = function (e) {var t = new c.Shell();return t.addFaces(this.cloneFaces(e.getFaces())), this._progenitorMap.addEntry(t, [e]), t;}, d.prototype.cloneLump = function (e) {for (var t = new u.Lump(), r = e.getShells(), n = 0; n < r.length; ++n) {t.addShell(this.cloneShell(r[n]));}return this._progenitorMap.addEntry(t, [e]), t;}, d.prototype.cloneBody = function (e) {for (var t = new l.Body(), r = e.getLumps(), n = 0; n < r.length; ++n) {t.addLump(this.cloneLump(r[n]));}return this._progenitorMap.addEntry(t, [e]), t;}, d.prototype.getProgenitorMap = function () {return this._progenitorMap;}, t.TopologyCloner = d;}, function (e, t, r) {\"use strict\";Object.defineProperty(t, \"__esModule\", { value: !0 });var n = function n(e, t) {if (t < 1) return \"\";for (var r = \"\"; t > 1;) {1 & t && (r += e), t >>= 1, e += e;}return r + e;},o = { isInitialized: !1, rngA: 4027999010, rngB: 3993266363, rngC: 3605298456, rotl32: function rotl32(e, t) {return (e << t >>> 0 | e >>> 32 - t) >>> 0;}, initialize: function initialize(e, t) {return o.isInitialized && !t ? 0 : (o.isInitialized && (o.rngA = 4027999010, o.rngB = 3993266363, o.rngC = 3605298456), o.isInitialized = !0, void 0 !== e ? r = e : (r = new Date().getTime(), r ^= Math.floor(2147483647 * Math.random() + 1)), o.rngA += 2097151 & r, o.rngB += r >> 7 & 524287, o.rngC += r >> 13, r);var r;}, genRandUInt32: function genRandUInt32() {return o.rngA = ~(2911329625 * o.rngA), o.rngA = o.rotl32(o.rngA, 17), o.rngB = 4031235431 * o.rngB, o.rngB = o.rotl32(o.rngB, 15), o.rngC = 3286325185 - o.rotl32(o.rngC, 19), o.rngA + o.rngB ^ o.rngC;} },i = function i(e) {for (var t = \"\", r = 0; r < 4; r++) {var o = e[r].toString(16);t += n(\"0\", 8 - o.length) + o;}return t.substr(0, 8) + \"-\" + t.substr(8, 4) + \"-\" + t.substr(12, 4) + \"-\" + t.substr(16, 4) + \"-\" + t.substr(20, 12);},s = function s(e, t) {var r = t;return void 0 === r && (r = new Uint32Array(4)), r[0] = parseInt(\"0x\" + e.substr(0, 8), 16), r[1] = parseInt(\"0x\" + e.substr(9, 4) + e.substr(14, 4), 16), r[2] = parseInt(\"0x\" + e.substr(19, 4) + e.substr(24, 4), 16), r[3] = parseInt(\"0x\" + e.substr(28, 8), 16), r;},a = function a(e, t) {var r = new Uint32Array(t);return r[0] += 2654435769, r[1] += 104395303, r[2] += 452930477, r[3] += 982451653, r[0] += e[3] << 6, r[1] += e[0] << 6, r[2] += e[1] << 6, r[3] += e[2] << 6, r[0] += e[2] >> 2, r[1] += e[3] >> 2, r[2] += e[0] >> 2, r[3] += e[1] >> 2, r[0] = 16777619 * (r[0] ^ e[1]) >>> 0, r[1] = 16777619 * (r[1] ^ e[2]) >>> 0, r[2] = 16777619 * (r[2] ^ e[3]) >>> 0, r[3] = 16777619 * (r[3] ^ e[0]) >>> 0, r;};o.initialize(), t.uint32x4ToGUID = i, t.guidToUint32x4 = s, t.generateGUID = function () {var e = new Uint32Array(4);return e[0] = o.genRandUInt32(), e[1] = o.genRandUInt32(), e[2] = o.genRandUInt32(), e[3] = o.genRandUInt32(), i(e);}, t.isGUID = function (e) {return /^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$/.test(e);}, t.combineGuids = function (e, t) {var r = s(e),n = s(t),o = a(r, n);return i(o);}, t.hashCombine4xUint32 = a;}, function (e, t) {var r;r = function () {return this;}();try {r = r || new Function(\"return this\")();} catch (e) {\"object\" == (typeof window === \"undefined\" ? \"undefined\" : _typeof(window)) && (r = window);}e.exports = r;}, function (e, t, r) {\"use strict\";e.exports = function (e, t) {for (var r = new Array(arguments.length - 1), n = 0, o = 2, i = !0; o < arguments.length;) {r[n++] = arguments[o++];}return new Promise(function (o, s) {r[n] = function (e) {if (i) if (i = !1, e) s(e);else {for (var t = new Array(arguments.length - 1), r = 0; r < t.length;) {t[r++] = arguments[r];}o.apply(null, t);}};try {e.apply(t || null, r);} catch (e) {i && (i = !1, s(e));}});};}, function (module, exports, __webpack_require__) {\"use strict\";function inquire(moduleName) {try {var mod = eval(\"quire\".replace(/^/, \"re\"))(moduleName);if (mod && (mod.length || Object.keys(mod).length)) return mod;} catch (e) {}return null;}module.exports = inquire;}, function (e, t, r) {\"use strict\";t.Service = r(98);}, function (e, t, r) {\"use strict\";e.exports = {};}, function (e, t, r) {\"use strict\";e.exports = function (e) {for (var t, r = i.codegen([\"m\", \"w\"], e.name + \"$encode\")(\"if(!w)\")(\"w=Writer.create()\"), a = e.fieldsArray.slice().sort(i.compareFieldsById), c = 0; c < a.length; ++c) {var u = a[c].resolve(),l = e._fieldsArray.indexOf(u),h = u.resolvedType instanceof n ? \"int32\" : u.type,d = o.basic[h];t = \"m\" + i.safeProp(u.name), u.map ? (r(\"if(%s!=null&&m.hasOwnProperty(%j)){\", t, u.name)(\"for(var ks=Object.keys(%s),i=0;i<ks.length;++i){\", t)(\"w.uint32(%i).fork().uint32(%i).%s(ks[i])\", (u.id << 3 | 2) >>> 0, 8 | o.mapKey[u.keyType], u.keyType), void 0 === d ? r(\"types[%i].encode(%s[ks[i]],w.uint32(18).fork()).ldelim().ldelim()\", l, t) : r(\".uint32(%i).%s(%s[ks[i]]).ldelim()\", 16 | d, h, t), r(\"}\")(\"}\")) : u.repeated ? (r(\"if(%s!=null&&%s.length){\", t, t), u.packed && void 0 !== o.packed[h] ? r(\"w.uint32(%i).fork()\", (u.id << 3 | 2) >>> 0)(\"for(var i=0;i<%s.length;++i)\", t)(\"w.%s(%s[i])\", h, t)(\"w.ldelim()\") : (r(\"for(var i=0;i<%s.length;++i)\", t), void 0 === d ? s(r, u, l, t + \"[i]\") : r(\"w.uint32(%i).%s(%s[i])\", (u.id << 3 | d) >>> 0, h, t)), r(\"}\")) : (u.optional && r(\"if(%s!=null&&m.hasOwnProperty(%j))\", t, u.name), void 0 === d ? s(r, u, l, t) : r(\"w.uint32(%i).%s(%s)\", (u.id << 3 | d) >>> 0, h, t));}return r(\"return w\");};var n = r(11),o = r(31),i = r(5);function s(e, t, r, n) {return t.resolvedType.group ? e(\"types[%i].encode(%s,w.uint32(%i)).uint32(%i)\", r, n, (t.id << 3 | 3) >>> 0, (t.id << 3 | 4) >>> 0) : e(\"types[%i].encode(%s,w.uint32(%i).fork()).ldelim()\", r, n, (t.id << 3 | 2) >>> 0);}}, function (e, t, r) {\"use strict\";e.exports = y;var n = r(30);((y.prototype = Object.create(n.prototype)).constructor = y).className = \"Type\";var o = r(11),i = r(48),s = r(22),a = r(64),c = r(65),u = r(49),l = r(47),h = r(46),d = r(5),g = r(62),p = r(67),f = r(68),v = r(69),_ = r(70);function y(e, t) {n.call(this, e, t), this.fields = {}, this.oneofs = void 0, this.extensions = void 0, this.reserved = void 0, this.group = void 0, this._fieldsById = null, this._fieldsArray = null, this._oneofsArray = null, this._ctor = null;}function m(e) {return e._fieldsById = e._fieldsArray = e._oneofsArray = null, delete e.encode, delete e.decode, delete e.verify, e;}Object.defineProperties(y.prototype, { fieldsById: { get: function get() {if (this._fieldsById) return this._fieldsById;this._fieldsById = {};for (var e = Object.keys(this.fields), t = 0; t < e.length; ++t) {var r = this.fields[e[t]],n = r.id;if (this._fieldsById[n]) throw Error(\"duplicate id \" + n + \" in \" + this);this._fieldsById[n] = r;}return this._fieldsById;} }, fieldsArray: { get: function get() {return this._fieldsArray || (this._fieldsArray = d.toArray(this.fields));} }, oneofsArray: { get: function get() {return this._oneofsArray || (this._oneofsArray = d.toArray(this.oneofs));} }, ctor: { get: function get() {return this._ctor || (this.ctor = y.generateConstructor(this)());}, set: function set(e) {var t = e.prototype;t instanceof u || ((e.prototype = new u()).constructor = e, d.merge(e.prototype, t)), e.$type = e.prototype.$type = this, d.merge(e, u, !0), this._ctor = e;for (var r = 0; r < this.fieldsArray.length; ++r) {this._fieldsArray[r].resolve();}var n = {};for (r = 0; r < this.oneofsArray.length; ++r) {n[this._oneofsArray[r].resolve().name] = { get: d.oneOfGetter(this._oneofsArray[r].oneof), set: d.oneOfSetter(this._oneofsArray[r].oneof) };}r && Object.defineProperties(e.prototype, n);} } }), y.generateConstructor = function (e) {for (var t, r = d.codegen([\"p\"], e.name), n = 0; n < e.fieldsArray.length; ++n) {(t = e._fieldsArray[n]).map ? r(\"this%s={}\", d.safeProp(t.name)) : t.repeated && r(\"this%s=[]\", d.safeProp(t.name));}return r(\"if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)\")(\"this[ks[i]]=p[ks[i]]\");}, y.fromJSON = function (e, t) {var r = new y(e, t.options);r.extensions = t.extensions, r.reserved = t.reserved;for (var u = Object.keys(t.fields), l = 0; l < u.length; ++l) {r.add((void 0 !== t.fields[u[l]].keyType ? a.fromJSON : s.fromJSON)(u[l], t.fields[u[l]]));}if (t.oneofs) for (u = Object.keys(t.oneofs), l = 0; l < u.length; ++l) {r.add(i.fromJSON(u[l], t.oneofs[u[l]]));}if (t.nested) for (u = Object.keys(t.nested), l = 0; l < u.length; ++l) {var h = t.nested[u[l]];r.add((void 0 !== h.id ? s.fromJSON : void 0 !== h.fields ? y.fromJSON : void 0 !== h.values ? o.fromJSON : void 0 !== h.methods ? c.fromJSON : n.fromJSON)(u[l], h));}return t.extensions && t.extensions.length && (r.extensions = t.extensions), t.reserved && t.reserved.length && (r.reserved = t.reserved), t.group && (r.group = !0), t.comment && (r.comment = t.comment), r;}, y.prototype.toJSON = function (e) {var t = n.prototype.toJSON.call(this, e),r = !!e && Boolean(e.keepComments);return d.toObject([\"options\", t && t.options || void 0, \"oneofs\", n.arrayToJSON(this.oneofsArray, e), \"fields\", n.arrayToJSON(this.fieldsArray.filter(function (e) {return !e.declaringField;}), e) || {}, \"extensions\", this.extensions && this.extensions.length ? this.extensions : void 0, \"reserved\", this.reserved && this.reserved.length ? this.reserved : void 0, \"group\", this.group || void 0, \"nested\", t && t.nested || void 0, \"comment\", r ? this.comment : void 0]);}, y.prototype.resolveAll = function () {for (var e = this.fieldsArray, t = 0; t < e.length;) {e[t++].resolve();}var r = this.oneofsArray;for (t = 0; t < r.length;) {r[t++].resolve();}return n.prototype.resolveAll.call(this);}, y.prototype.get = function (e) {return this.fields[e] || this.oneofs && this.oneofs[e] || this.nested && this.nested[e] || null;}, y.prototype.add = function (e) {if (this.get(e.name)) throw Error(\"duplicate name '\" + e.name + \"' in \" + this);if (e instanceof s && void 0 === e.extend) {if (this._fieldsById ? this._fieldsById[e.id] : this.fieldsById[e.id]) throw Error(\"duplicate id \" + e.id + \" in \" + this);if (this.isReservedId(e.id)) throw Error(\"id \" + e.id + \" is reserved in \" + this);if (this.isReservedName(e.name)) throw Error(\"name '\" + e.name + \"' is reserved in \" + this);return e.parent && e.parent.remove(e), this.fields[e.name] = e, e.message = this, e.onAdd(this), m(this);}return e instanceof i ? (this.oneofs || (this.oneofs = {}), this.oneofs[e.name] = e, e.onAdd(this), m(this)) : n.prototype.add.call(this, e);}, y.prototype.remove = function (e) {if (e instanceof s && void 0 === e.extend) {if (!this.fields || this.fields[e.name] !== e) throw Error(e + \" is not a member of \" + this);return delete this.fields[e.name], e.parent = null, e.onRemove(this), m(this);}if (e instanceof i) {if (!this.oneofs || this.oneofs[e.name] !== e) throw Error(e + \" is not a member of \" + this);return delete this.oneofs[e.name], e.parent = null, e.onRemove(this), m(this);}return n.prototype.remove.call(this, e);}, y.prototype.isReservedId = function (e) {return n.isReservedId(this.reserved, e);}, y.prototype.isReservedName = function (e) {return n.isReservedName(this.reserved, e);}, y.prototype.create = function (e) {return new this.ctor(e);}, y.prototype.setup = function () {for (var e = this.fullName, t = [], r = 0; r < this.fieldsArray.length; ++r) {t.push(this._fieldsArray[r].resolve().resolvedType);}this.encode = g(this)({ Writer: h, types: t, util: d }), this.decode = p(this)({ Reader: l, types: t, util: d }), this.verify = f(this)({ types: t, util: d }), this.fromObject = v.fromObject(this)({ types: t, util: d }), this.toObject = v.toObject(this)({ types: t, util: d });var n = _[e];if (n) {var o = Object.create(this);o.fromObject = this.fromObject, this.fromObject = n.fromObject.bind(o), o.toObject = this.toObject, this.toObject = n.toObject.bind(o);}return this;}, y.prototype.encode = function (e, t) {return this.setup().encode(e, t);}, y.prototype.encodeDelimited = function (e, t) {return this.encode(e, t && t.len ? t.fork() : t).ldelim();}, y.prototype.decode = function (e, t) {return this.setup().decode(e, t);}, y.prototype.decodeDelimited = function (e) {return e instanceof l || (e = l.create(e)), this.decode(e, e.uint32());}, y.prototype.verify = function (e) {return this.setup().verify(e);}, y.prototype.fromObject = function (e) {return this.setup().fromObject(e);}, y.prototype.toObject = function (e, t) {return this.setup().toObject(e, t);}, y.d = function (e) {return function (t) {d.decorateType(t, e);};};}, function (e, t, r) {\"use strict\";e.exports = s;var n = r(22);((s.prototype = Object.create(n.prototype)).constructor = s).className = \"MapField\";var o = r(31),i = r(5);function s(e, t, r, o, s, a) {if (n.call(this, e, t, o, void 0, void 0, s, a), !i.isString(r)) throw TypeError(\"keyType must be a string\");this.keyType = r, this.resolvedKeyType = null, this.map = !0;}s.fromJSON = function (e, t) {return new s(e, t.id, t.keyType, t.type, t.options, t.comment);}, s.prototype.toJSON = function (e) {var t = !!e && Boolean(e.keepComments);return i.toObject([\"keyType\", this.keyType, \"type\", this.type, \"id\", this.id, \"extend\", this.extend, \"options\", this.options, \"comment\", t ? this.comment : void 0]);}, s.prototype.resolve = function () {if (this.resolved) return this;if (void 0 === o.mapKey[this.keyType]) throw Error(\"invalid key type: \" + this.keyType);return n.prototype.resolve.call(this);}, s.d = function (e, t, r) {return \"function\" == typeof r ? r = i.decorateType(r).name : r && \"object\" == _typeof(r) && (r = i.decorateEnum(r).name), function (n, o) {i.decorateType(n.constructor).add(new s(o, e, t, r));};};}, function (e, t, r) {\"use strict\";e.exports = a;var n = r(30);((a.prototype = Object.create(n.prototype)).constructor = a).className = \"Service\";var o = r(66),i = r(5),s = r(60);function a(e, t) {n.call(this, e, t), this.methods = {}, this._methodsArray = null;}function c(e) {return e._methodsArray = null, e;}a.fromJSON = function (e, t) {var r = new a(e, t.options);if (t.methods) for (var n = Object.keys(t.methods), i = 0; i < n.length; ++i) {r.add(o.fromJSON(n[i], t.methods[n[i]]));}return t.nested && r.addJSON(t.nested), r.comment = t.comment, r;}, a.prototype.toJSON = function (e) {var t = n.prototype.toJSON.call(this, e),r = !!e && Boolean(e.keepComments);return i.toObject([\"options\", t && t.options || void 0, \"methods\", n.arrayToJSON(this.methodsArray, e) || {}, \"nested\", t && t.nested || void 0, \"comment\", r ? this.comment : void 0]);}, Object.defineProperty(a.prototype, \"methodsArray\", { get: function get() {return this._methodsArray || (this._methodsArray = i.toArray(this.methods));} }), a.prototype.get = function (e) {return this.methods[e] || n.prototype.get.call(this, e);}, a.prototype.resolveAll = function () {for (var e = this.methodsArray, t = 0; t < e.length; ++t) {e[t].resolve();}return n.prototype.resolve.call(this);}, a.prototype.add = function (e) {if (this.get(e.name)) throw Error(\"duplicate name '\" + e.name + \"' in \" + this);return e instanceof o ? (this.methods[e.name] = e, e.parent = this, c(this)) : n.prototype.add.call(this, e);}, a.prototype.remove = function (e) {if (e instanceof o) {if (this.methods[e.name] !== e) throw Error(e + \" is not a member of \" + this);return delete this.methods[e.name], e.parent = null, c(this);}return n.prototype.remove.call(this, e);}, a.prototype.create = function (e, t, r) {for (var n, o = new s.Service(e, t, r), a = 0; a < this.methodsArray.length; ++a) {var c = i.lcFirst((n = this._methodsArray[a]).resolve().name).replace(/[^$\\w_]/g, \"\");o[c] = i.codegen([\"r\", \"c\"], i.isReserved(c) ? c + \"_\" : c)(\"return this.rpcCall(m,q,s,r,c)\")({ m: n, q: n.resolvedRequestType.ctor, s: n.resolvedResponseType.ctor });}return o;};}, function (e, t, r) {\"use strict\";e.exports = i;var n = r(21);((i.prototype = Object.create(n.prototype)).constructor = i).className = \"Method\";var o = r(5);function i(e, t, r, i, s, a, c, u) {if (o.isObject(s) ? (c = s, s = a = void 0) : o.isObject(a) && (c = a, a = void 0), void 0 !== t && !o.isString(t)) throw TypeError(\"type must be a string\");if (!o.isString(r)) throw TypeError(\"requestType must be a string\");if (!o.isString(i)) throw TypeError(\"responseType must be a string\");n.call(this, e, c), this.type = t || \"rpc\", this.requestType = r, this.requestStream = !!s || void 0, this.responseType = i, this.responseStream = !!a || void 0, this.resolvedRequestType = null, this.resolvedResponseType = null, this.comment = u;}i.fromJSON = function (e, t) {return new i(e, t.type, t.requestType, t.responseType, t.requestStream, t.responseStream, t.options, t.comment);}, i.prototype.toJSON = function (e) {var t = !!e && Boolean(e.keepComments);return o.toObject([\"type\", \"rpc\" !== this.type && this.type || void 0, \"requestType\", this.requestType, \"requestStream\", this.requestStream, \"responseType\", this.responseType, \"responseStream\", this.responseStream, \"options\", this.options, \"comment\", t ? this.comment : void 0]);}, i.prototype.resolve = function () {return this.resolved ? this : (this.resolvedRequestType = this.parent.lookupType(this.requestType), this.resolvedResponseType = this.parent.lookupType(this.responseType), n.prototype.resolve.call(this));};}, function (e, t, r) {\"use strict\";e.exports = function (e) {var t = i.codegen([\"r\", \"l\"], e.name + \"$decode\")(\"if(!(r instanceof Reader))\")(\"r=Reader.create(r)\")(\"var c=l===undefined?r.len:r.pos+l,m=new this.ctor\" + (e.fieldsArray.filter(function (e) {return e.map;}).length ? \",k\" : \"\"))(\"while(r.pos<c){\")(\"var t=r.uint32()\");e.group && t(\"if((t&7)===4)\")(\"break\"), t(\"switch(t>>>3){\");for (var r = 0; r < e.fieldsArray.length; ++r) {var a = e._fieldsArray[r].resolve(),c = a.resolvedType instanceof n ? \"int32\" : a.type,u = \"m\" + i.safeProp(a.name);t(\"case %i:\", a.id), a.map ? (t(\"r.skip().pos++\")(\"if(%s===util.emptyObject)\", u)(\"%s={}\", u)(\"k=r.%s()\", a.keyType)(\"r.pos++\"), void 0 !== o.long[a.keyType] ? void 0 === o.basic[c] ? t('%s[typeof k===\"object\"?util.longToHash(k):k]=types[%i].decode(r,r.uint32())', u, r) : t('%s[typeof k===\"object\"?util.longToHash(k):k]=r.%s()', u, c) : void 0 === o.basic[c] ? t(\"%s[k]=types[%i].decode(r,r.uint32())\", u, r) : t(\"%s[k]=r.%s()\", u, c)) : a.repeated ? (t(\"if(!(%s&&%s.length))\", u, u)(\"%s=[]\", u), void 0 !== o.packed[c] && t(\"if((t&7)===2){\")(\"var c2=r.uint32()+r.pos\")(\"while(r.pos<c2)\")(\"%s.push(r.%s())\", u, c)(\"}else\"), void 0 === o.basic[c] ? t(a.resolvedType.group ? \"%s.push(types[%i].decode(r))\" : \"%s.push(types[%i].decode(r,r.uint32()))\", u, r) : t(\"%s.push(r.%s())\", u, c)) : void 0 === o.basic[c] ? t(a.resolvedType.group ? \"%s=types[%i].decode(r)\" : \"%s=types[%i].decode(r,r.uint32())\", u, r) : t(\"%s=r.%s()\", u, c), t(\"break\");}for (t(\"default:\")(\"r.skipType(t&7)\")(\"break\")(\"}\")(\"}\"), r = 0; r < e._fieldsArray.length; ++r) {var l = e._fieldsArray[r];l.required && t(\"if(!m.hasOwnProperty(%j))\", l.name)(\"throw util.ProtocolError(%j,{instance:m})\", s(l));}return t(\"return m\");};var n = r(11),o = r(31),i = r(5);function s(e) {return \"missing required '\" + e.name + \"'\";}}, function (e, t, r) {\"use strict\";e.exports = function (e) {var t = o.codegen([\"m\"], e.name + \"$verify\")('if(typeof m!==\"object\"||m===null)')(\"return%j\", \"object expected\"),r = {};e.oneofsArray.length && t(\"var p={}\");for (var n = 0; n < e.fieldsArray.length; ++n) {var c = e._fieldsArray[n].resolve(),u = \"m\" + o.safeProp(c.name);if (c.optional && t(\"if(%s!=null&&m.hasOwnProperty(%j)){\", u, c.name), c.map) t(\"if(!util.isObject(%s))\", u)(\"return%j\", i(c, \"object\"))(\"var k=Object.keys(%s)\", u)(\"for(var i=0;i<k.length;++i){\"), a(t, c, \"k[i]\"), s(t, c, n, u + \"[k[i]]\")(\"}\");else if (c.repeated) t(\"if(!Array.isArray(%s))\", u)(\"return%j\", i(c, \"array\"))(\"for(var i=0;i<%s.length;++i){\", u), s(t, c, n, u + \"[i]\")(\"}\");else {if (c.partOf) {var l = o.safeProp(c.partOf.name);1 === r[c.partOf.name] && t(\"if(p%s===1)\", l)(\"return%j\", c.partOf.name + \": multiple values\"), r[c.partOf.name] = 1, t(\"p%s=1\", l);}s(t, c, n, u);}c.optional && t(\"}\");}return t(\"return null\");};var n = r(11),o = r(5);function i(e, t) {return e.name + \": \" + t + (e.repeated && \"array\" !== t ? \"[]\" : e.map && \"object\" !== t ? \"{k:\" + e.keyType + \"}\" : \"\") + \" expected\";}function s(e, t, r, o) {if (t.resolvedType) {if (t.resolvedType instanceof n) {e(\"switch(%s){\", o)(\"default:\")(\"return%j\", i(t, \"enum value\"));for (var s = Object.keys(t.resolvedType.values), a = 0; a < s.length; ++a) {e(\"case %i:\", t.resolvedType.values[s[a]]);}e(\"break\")(\"}\");} else e(\"{\")(\"var e=types[%i].verify(%s);\", r, o)(\"if(e)\")(\"return%j+e\", t.name + \".\")(\"}\");} else switch (t.type) {case \"int32\":case \"uint32\":case \"sint32\":case \"fixed32\":case \"sfixed32\":e(\"if(!util.isInteger(%s))\", o)(\"return%j\", i(t, \"integer\"));break;case \"int64\":case \"uint64\":case \"sint64\":case \"fixed64\":case \"sfixed64\":e(\"if(!util.isInteger(%s)&&!(%s&&util.isInteger(%s.low)&&util.isInteger(%s.high)))\", o, o, o, o)(\"return%j\", i(t, \"integer|Long\"));break;case \"float\":case \"double\":e('if(typeof %s!==\"number\")', o)(\"return%j\", i(t, \"number\"));break;case \"bool\":e('if(typeof %s!==\"boolean\")', o)(\"return%j\", i(t, \"boolean\"));break;case \"string\":e(\"if(!util.isString(%s))\", o)(\"return%j\", i(t, \"string\"));break;case \"bytes\":e('if(!(%s&&typeof %s.length===\"number\"||util.isString(%s)))', o, o, o)(\"return%j\", i(t, \"buffer\"));}return e;}function a(e, t, r) {switch (t.keyType) {case \"int32\":case \"uint32\":case \"sint32\":case \"fixed32\":case \"sfixed32\":e(\"if(!util.key32Re.test(%s))\", r)(\"return%j\", i(t, \"integer key\"));break;case \"int64\":case \"uint64\":case \"sint64\":case \"fixed64\":case \"sfixed64\":e(\"if(!util.key64Re.test(%s))\", r)(\"return%j\", i(t, \"integer|Long key\"));break;case \"bool\":e(\"if(!util.key2Re.test(%s))\", r)(\"return%j\", i(t, \"boolean key\"));}return e;}}, function (e, t, r) {\"use strict\";var n = t,o = r(11),i = r(5);function s(e, t, r, n) {if (t.resolvedType) {if (t.resolvedType instanceof o) {e(\"switch(d%s){\", n);for (var i = t.resolvedType.values, s = Object.keys(i), a = 0; a < s.length; ++a) {t.repeated && i[s[a]] === t.typeDefault && e(\"default:\"), e(\"case%j:\", s[a])(\"case %i:\", i[s[a]])(\"m%s=%j\", n, i[s[a]])(\"break\");}e(\"}\");} else e('if(typeof d%s!==\"object\")', n)(\"throw TypeError(%j)\", t.fullName + \": object expected\")(\"m%s=types[%i].fromObject(d%s)\", n, r, n);} else {var c = !1;switch (t.type) {case \"double\":case \"float\":e(\"m%s=Number(d%s)\", n, n);break;case \"uint32\":case \"fixed32\":e(\"m%s=d%s>>>0\", n, n);break;case \"int32\":case \"sint32\":case \"sfixed32\":e(\"m%s=d%s|0\", n, n);break;case \"uint64\":c = !0;case \"int64\":case \"sint64\":case \"fixed64\":case \"sfixed64\":e(\"if(util.Long)\")(\"(m%s=util.Long.fromValue(d%s)).unsigned=%j\", n, n, c)('else if(typeof d%s===\"string\")', n)(\"m%s=parseInt(d%s,10)\", n, n)('else if(typeof d%s===\"number\")', n)(\"m%s=d%s\", n, n)('else if(typeof d%s===\"object\")', n)(\"m%s=new util.LongBits(d%s.low>>>0,d%s.high>>>0).toNumber(%s)\", n, n, n, c ? \"true\" : \"\");break;case \"bytes\":e('if(typeof d%s===\"string\")', n)(\"util.base64.decode(d%s,m%s=util.newBuffer(util.base64.length(d%s)),0)\", n, n, n)(\"else if(d%s.length)\", n)(\"m%s=d%s\", n, n);break;case \"string\":e(\"m%s=String(d%s)\", n, n);break;case \"bool\":e(\"m%s=Boolean(d%s)\", n, n);}}return e;}function a(e, t, r, n) {if (t.resolvedType) t.resolvedType instanceof o ? e(\"d%s=o.enums===String?types[%i].values[m%s]:m%s\", n, r, n, n) : e(\"d%s=types[%i].toObject(m%s,o)\", n, r, n);else {var i = !1;switch (t.type) {case \"double\":case \"float\":e(\"d%s=o.json&&!isFinite(m%s)?String(m%s):m%s\", n, n, n, n);break;case \"uint64\":i = !0;case \"int64\":case \"sint64\":case \"fixed64\":case \"sfixed64\":e('if(typeof m%s===\"number\")', n)(\"d%s=o.longs===String?String(m%s):m%s\", n, n, n)(\"else\")(\"d%s=o.longs===String?util.Long.prototype.toString.call(m%s):o.longs===Number?new util.LongBits(m%s.low>>>0,m%s.high>>>0).toNumber(%s):m%s\", n, n, n, n, i ? \"true\" : \"\", n);break;case \"bytes\":e(\"d%s=o.bytes===String?util.base64.encode(m%s,0,m%s.length):o.bytes===Array?Array.prototype.slice.call(m%s):m%s\", n, n, n, n, n);break;default:e(\"d%s=m%s\", n, n);}}return e;}n.fromObject = function (e) {var t = e.fieldsArray,r = i.codegen([\"d\"], e.name + \"$fromObject\")(\"if(d instanceof this.ctor)\")(\"return d\");if (!t.length) return r(\"return new this.ctor\");r(\"var m=new this.ctor\");for (var n = 0; n < t.length; ++n) {var a = t[n].resolve(),c = i.safeProp(a.name);a.map ? (r(\"if(d%s){\", c)('if(typeof d%s!==\"object\")', c)(\"throw TypeError(%j)\", a.fullName + \": object expected\")(\"m%s={}\", c)(\"for(var ks=Object.keys(d%s),i=0;i<ks.length;++i){\", c), s(r, a, n, c + \"[ks[i]]\")(\"}\")(\"}\")) : a.repeated ? (r(\"if(d%s){\", c)(\"if(!Array.isArray(d%s))\", c)(\"throw TypeError(%j)\", a.fullName + \": array expected\")(\"m%s=[]\", c)(\"for(var i=0;i<d%s.length;++i){\", c), s(r, a, n, c + \"[i]\")(\"}\")(\"}\")) : (a.resolvedType instanceof o || r(\"if(d%s!=null){\", c), s(r, a, n, c), a.resolvedType instanceof o || r(\"}\"));}return r(\"return m\");}, n.toObject = function (e) {var t = e.fieldsArray.slice().sort(i.compareFieldsById);if (!t.length) return i.codegen()(\"return {}\");for (var r = i.codegen([\"m\", \"o\"], e.name + \"$toObject\")(\"if(!o)\")(\"o={}\")(\"var d={}\"), n = [], s = [], c = [], u = 0; u < t.length; ++u) {t[u].partOf || (t[u].resolve().repeated ? n : t[u].map ? s : c).push(t[u]);}if (n.length) {for (r(\"if(o.arrays||o.defaults){\"), u = 0; u < n.length; ++u) {r(\"d%s=[]\", i.safeProp(n[u].name));}r(\"}\");}if (s.length) {for (r(\"if(o.objects||o.defaults){\"), u = 0; u < s.length; ++u) {r(\"d%s={}\", i.safeProp(s[u].name));}r(\"}\");}if (c.length) {for (r(\"if(o.defaults){\"), u = 0; u < c.length; ++u) {var l = c[u],h = i.safeProp(l.name);if (l.resolvedType instanceof o) r(\"d%s=o.enums===String?%j:%j\", h, l.resolvedType.valuesById[l.typeDefault], l.typeDefault);else if (l.long) r(\"if(util.Long){\")(\"var n=new util.Long(%i,%i,%j)\", l.typeDefault.low, l.typeDefault.high, l.typeDefault.unsigned)(\"d%s=o.longs===String?n.toString():o.longs===Number?n.toNumber():n\", h)(\"}else\")(\"d%s=o.longs===String?%j:%i\", h, l.typeDefault.toString(), l.typeDefault.toNumber());else if (l.bytes) {var d = \"[\" + Array.prototype.slice.call(l.typeDefault).join(\",\") + \"]\";r(\"if(o.bytes===String)d%s=%j\", h, String.fromCharCode.apply(String, l.typeDefault))(\"else{\")(\"d%s=%s\", h, d)(\"if(o.bytes!==Array)d%s=util.newBuffer(d%s)\", h, h)(\"}\");} else r(\"d%s=%j\", h, l.typeDefault);}r(\"}\");}var g = !1;for (u = 0; u < t.length; ++u) {l = t[u];var p = e._fieldsArray.indexOf(l);h = i.safeProp(l.name), l.map ? (g || (g = !0, r(\"var ks2\")), r(\"if(m%s&&(ks2=Object.keys(m%s)).length){\", h, h)(\"d%s={}\", h)(\"for(var j=0;j<ks2.length;++j){\"), a(r, l, p, h + \"[ks2[j]]\")(\"}\")) : l.repeated ? (r(\"if(m%s&&m%s.length){\", h, h)(\"d%s=[]\", h)(\"for(var j=0;j<m%s.length;++j){\", h), a(r, l, p, h + \"[j]\")(\"}\")) : (r(\"if(m%s!=null&&m.hasOwnProperty(%j)){\", h, l.name), a(r, l, p, h), l.partOf && r(\"if(o.oneofs)\")(\"d%s=%j\", i.safeProp(l.partOf.name), l.name)), r(\"}\");}return r(\"return d\");};}, function (e, t, r) {\"use strict\";var n = t,o = r(49);n[\".google.protobuf.Any\"] = { fromObject: function fromObject(e) {if (e && e[\"@type\"]) {var t = this.lookup(e[\"@type\"]);if (t) {var r = \".\" === e[\"@type\"].charAt(0) ? e[\"@type\"].substr(1) : e[\"@type\"];return this.create({ type_url: \"/\" + r, value: t.encode(t.fromObject(e)).finish() });}}return this.fromObject(e);}, toObject: function toObject(e, t) {if (t && t.json && e.type_url && e.value) {var r = e.type_url.substring(e.type_url.lastIndexOf(\"/\") + 1),n = this.lookup(r);n && (e = n.decode(e.value));}if (!(e instanceof this.ctor) && e instanceof o) {var i = e.$type.toObject(e, t);return i[\"@type\"] = e.$type.fullName, i;}return this.toObject(e, t);} };}, function (e, t, r) {\"use strict\";e.exports = h;var n = r(30);((h.prototype = Object.create(n.prototype)).constructor = h).className = \"Root\";var o,i,s,a = r(22),c = r(11),u = r(48),l = r(5);function h(e) {n.call(this, \"\", e), this.deferred = [], this.files = [];}function d() {}h.fromJSON = function (e, t) {return t || (t = new h()), e.options && t.setOptions(e.options), t.addJSON(e.nested);}, h.prototype.resolvePath = l.path.resolve, h.prototype.load = function e(t, r, n) {\"function\" == typeof r && (n = r, r = void 0);var o = this;if (!n) return l.asPromise(e, o, t, r);var a = n === d;function c(e, t) {if (n) {var r = n;if (n = null, a) throw e;r(e, t);}}function u(e, t) {try {if (l.isString(t) && \"{\" === t.charAt(0) && (t = JSON.parse(t)), l.isString(t)) {i.filename = e;var n,s = i(t, o, r),u = 0;if (s.imports) for (; u < s.imports.length; ++u) {(n = o.resolvePath(e, s.imports[u])) && h(n);}if (s.weakImports) for (u = 0; u < s.weakImports.length; ++u) {(n = o.resolvePath(e, s.weakImports[u])) && h(n, !0);}} else o.setOptions(t.options).addJSON(t.nested);} catch (e) {c(e);}a || g || c(null, o);}function h(e, t) {var r = e.lastIndexOf(\"google/protobuf/\");if (r > -1) {var i = e.substring(r);i in s && (e = i);}if (!(o.files.indexOf(e) > -1)) if (o.files.push(e), e in s) a ? u(e, s[e]) : (++g, setTimeout(function () {--g, u(e, s[e]);}));else if (a) {var h;try {h = l.fs.readFileSync(e).toString(\"utf8\");} catch (e) {return void (t || c(e));}u(e, h);} else ++g, l.fetch(e, function (r, i) {--g, n && (r ? t ? g || c(null, o) : c(r) : u(e, i));});}var g = 0;l.isString(t) && (t = [t]);for (var p, f = 0; f < t.length; ++f) {(p = o.resolvePath(\"\", t[f])) && h(p);}if (a) return o;g || c(null, o);}, h.prototype.loadSync = function (e, t) {if (!l.isNode) throw Error(\"not supported\");return this.load(e, t, d);}, h.prototype.resolveAll = function () {if (this.deferred.length) throw Error(\"unresolvable extensions: \" + this.deferred.map(function (e) {return \"'extend \" + e.extend + \"' in \" + e.parent.fullName;}).join(\", \"));return n.prototype.resolveAll.call(this);};var g = /^[A-Z]/;function p(e, t) {var r = t.parent.lookup(t.extend);if (r) {var n = new a(t.fullName, t.id, t.type, t.rule, void 0, t.options);return n.declaringField = t, t.extensionField = n, r.add(n), !0;}return !1;}h.prototype._handleAdd = function (e) {if (e instanceof a) void 0 === e.extend || e.extensionField || p(0, e) || this.deferred.push(e);else if (e instanceof c) g.test(e.name) && (e.parent[e.name] = e.values);else if (!(e instanceof u)) {if (e instanceof o) for (var t = 0; t < this.deferred.length;) {p(0, this.deferred[t]) ? this.deferred.splice(t, 1) : ++t;}for (var r = 0; r < e.nestedArray.length; ++r) {this._handleAdd(e._nestedArray[r]);}g.test(e.name) && (e.parent[e.name] = e);}}, h.prototype._handleRemove = function (e) {if (e instanceof a) {if (void 0 !== e.extend) if (e.extensionField) e.extensionField.parent.remove(e.extensionField), e.extensionField = null;else {var t = this.deferred.indexOf(e);t > -1 && this.deferred.splice(t, 1);}} else if (e instanceof c) g.test(e.name) && delete e.parent[e.name];else if (e instanceof n) {for (var r = 0; r < e.nestedArray.length; ++r) {this._handleRemove(e._nestedArray[r]);}g.test(e.name) && delete e.parent[e.name];}}, h._configure = function (e, t, r) {o = e, i = t, s = r;};}, function (e, t, r) {\"use strict\";function n(e, t, r, n, o, i) {o[0] = i.b = n[0], o[1] = i.a = -t * i.b + n[1];for (var s = 2; s < e; s++) {o[s] = -(t * i.a + r * i.b) + n[s], i.b = i.a, i.a = o[s];}}function o(e, t, r, o, i, s, a, c, u) {var l = new Object(),h = 3;return l.b = l.a = 0, n(t, a, c, s, u, l), i.c = l.a, i.d = l.b, Math.abs(i.c) <= 100 * e * Math.abs(s[t - 1]) && Math.abs(i.d) <= 100 * e * Math.abs(s[t - 2]) || (i.h = c * o, Math.abs(i.d) >= Math.abs(i.c) ? (h = 2, i.e = r / i.d, i.f = i.c / i.d, i.g = a * o, i.a3 = i.e * (i.g + r) + i.h * (o / i.d), i.a1 = -r + i.f * o, i.a7 = i.h + (i.f + a) * r) : (h = 1, i.e = r / i.c, i.f = i.d / i.c, i.g = i.e * a, i.a3 = i.e * r + (i.g + i.h / i.c) * o, i.a1 = -r * (i.d / i.c) + o, i.a7 = i.g * i.d + i.h * i.f + r)), h;}function i(e, t, r, n, o, i, s, a, c) {var u;if (3 != r) {if (u = 1 == r ? o : n, Math.abs(i.a1) > 10 * e * Math.abs(u)) for (i.a7 /= i.a1, i.a3 /= i.a1, s[0] = c[0], s[1] = -c[0] * i.a7 + c[1], l = 2; l < t; l++) {s[l] = -c[l - 1] * i.a7 + a[l - 2] * i.a3 + c[l];} else for (s[0] = 0, s[1] = -c[0] * i.a7, l = 2; l < t; l++) {s[l] = -c[l - 1] * i.a7 + a[l - 2] * i.a3;}} else {s[1] = s[0] = 0;for (var l = 2; l < t; l++) {s[l] = a[l - 2];}}}function s(e, t, r, n, o, i, s, a, c, u, l, h, d, g, p, f, v) {var _, y, m, E, x, R, A, P;t.b = t.a = 0, 3 != e && (2 != e ? (_ = r + d * s + h * u, y = a + (d + g * u) * c) : (_ = (r + l) * u + h, y = (u + d) * a + g * c), 0 != (P = -(A = -((x = (m = -p[f - 1] / v[f]) * i) + (R = m * m * o)) + g * (E = -(p[f - 2] + m * v[f - 1]) / v[f]) * n) + y + m * _) && (t.a = -(d * (R + x) + g * (m * n + E * i)) / P + d, t.b = g * (1 + A / P)));}function a(e, t, r, n) {var o, i, s;n.sr = n.si = n.lr = n.li = 0, 0 != e ? 0 != r ? (o = t / 2, Math.abs(o) < Math.abs(r) ? (s = -(s = r >= 0 ? e : -e) + o * (o / Math.abs(r)), i = Math.sqrt(Math.abs(s)) * Math.sqrt(Math.abs(r))) : (s = -e / o * (r / o) + 1, i = Math.sqrt(Math.abs(s)) * Math.abs(o)), s >= 0 ? (i = o >= 0 ? -i : i, n.lr = (-o + i) / e, n.sr = 0 != n.lr ? r / n.lr / e : n.sr) : (n.lr = n.sr = -o / e, n.si = Math.abs(i / e), n.li = -n.si)) : n.lr = -t / e : n.sr = 0 != t ? -r / t : n.sr;}function c(e, t, r, c, u, l, h, d, g, p, f, v) {var _,y,m,E,x,R,A,P,V,T,C,b = new Object(),L = 0,O = 0;r.NZ = 0, R = c, P = u;do {if (b.li = b.lr = b.si = b.sr = 0, a(1, R, P, b), r.szr = b.sr, r.szi = b.si, r.lzr = b.lr, r.lzi = b.li, Math.abs(Math.abs(r.szr) - Math.abs(r.lzr)) > .01 * Math.abs(r.lzr)) break;for (n(h, R, P, g, l, d), y = Math.abs(-r.szr * d.b + d.a) + Math.abs(r.szi * d.b), T = Math.sqrt(Math.abs(P)), _ = 2 * Math.abs(l[0]), x = -r.szr * d.b, C = 1; C < t; C++) {_ = _ * T + Math.abs(l[C]);}if (y <= 20 * (_ = (9 * (_ = _ * T + Math.abs(x + d.a)) + 2 * Math.abs(x) - 7 * (Math.abs(d.a + x) + T * Math.abs(d.b))) * e)) {r.NZ = 2;break;}if (++L > 20) break;if (L >= 2 && E <= .01 && y >= m && !O) {for (n(h, R -= R * (E = E < e ? Math.sqrt(e) : Math.sqrt(E)), P += P * E, g, l, d), C = 0; C < 5; C++) {i(e, t, o(e, t, d.a, d.b, f, v, R, P, p), d.a, d.b, f, v, p, l);}O = 1, L = 0;}m = y, i(e, t, o(e, t, d.a, d.b, f, v, R, P, p), d.a, d.b, f, v, p, l), s(o(e, t, d.a, d.b, f, v, R, P, p), d, d.a, f.a1, f.a3, f.a7, d.b, f.c, f.d, f.f, f.g, f.h, R, P, v, t, g), A = d.a, 0 != (V = d.b) && (E = Math.abs((-P + V) / V), R = A, P = V);} while (0 != V);}function u(e, t, r, n, o, i, s, a, c) {var u,l,h,d,g,p,f,v,_,y,m,E = n - 1;for (t.NZ = m = _ = 0, f = r.a;;) {for (s[0] = p = o[0], y = 1; y < i; y++) {s[y] = p = p * f + o[y];}for (h = Math.abs(p), d = Math.abs(f), u = .5 * Math.abs(s[0]), y = 1; y < i; y++) {u = u * d + Math.abs(s[y]);}if (h <= 20 * e * (2 * u - h)) {t.NZ = 1, t.szr = f, t.szi = 0;break;}if (++m > 10) break;if (m >= 2 && Math.abs(v) <= .001 * Math.abs(-v + f) && h > g) {_ = 1, t.a = f;break;}for (g = h, c[0] = l = a[0], y = 1; y < n; y++) {c[y] = l = l * f + a[y];}if (Math.abs(l) > 10 * Math.abs(a[E]) * e) for (v = -p / l, a[0] = s[0], y = 1; y < n; y++) {a[y] = v * c[y - 1] + s[y];} else for (a[0] = 0, y = 1; y < n; y++) {a[y] = c[y - 1];}for (l = a[0], y = 1; y < n; y++) {l = l * f + a[y];}f += v = Math.abs(l) > 10 * Math.abs(a[E]) * e ? -p / l : 0;}return _;}function l(e, t, r, a, l, h, d, g, p, f, v) {var _,y,m,E,x,R,A,P,V,T,C,b,L,O,S,M,w,N,F,I,D,j,B,U,k,G,z,Y,K = new Object(),q = new Object(),W = new Array(t),H = new Array(t);for (v.NZ = 0, E = m = .25, S = -2 * a, x = a, P = w = l, q.h = q.g = q.f = q.e = q.d = q.c = q.a7 = q.a3 = q.a1 = K.b = K.a = 0, n(p, S, w, g, f, K), G = o(e, d, _ = K.a, y = K.b, q, h, S, w, W), B = 0; B < r; B++) {if (i(e, d, G, _, y, q, h, W, f), s(G = o(e, d, _, y, q, h, S, w, W), K, _, q.a1, q.a3, q.a7, y, q.c, q.d, q.f, q.g, q.h, S, w, h, d, g), M = K.a, F = N = K.b, T = 0 != h[d - 1] ? -g[d] / h[d - 1] : 0, C = L = 1, 0 != B && 3 != G && (z = (O = (L = 0 != F ? Math.abs((F - P) / F) : L) < A ? L * A : 1) < E ? 1 : 0, (U = (b = (C = 0 != T ? Math.abs((T - x) / T) : C) < R ? C * R : 1) < m ? 1 : 0) || z)) {for (D = 0; D < d; D++) {H[D] = h[D];}V = T, k = Y = 0, I = 1;do {if (j = 1, I && 0 == (I = 0) && U && (!z || b < O)) ;else {if (c(e, d, v, M, N, f, p, K, g, W, q, h), _ = K.a, y = K.b, v.NZ > 0) return;if (Y = 1, E *= .25, k || !U) j = 0;else for (D = 0; D < d; D++) {h[D] = H[D];}}if (0 != j) {if (K.a = V, j = u(e, v, K, d, g, p, f, h, W), V = K.a, v.NZ > 0) return;if (k = 1, m *= .25, 0 != j) {M = -(V + V), N = V * V;continue;}}for (D = 0; D < d; D++) {h[D] = H[D];}} while (z && !Y);n(p, S, w, g, f, K), G = o(e, d, _ = K.a, y = K.b, q, h, S, w, W);}P = F, x = T, A = L, R = C;}}Object.defineProperty(t, \"__esModule\", { value: !0 }), t.getRealPolynomialRoots = function (e) {var t = { Degree: e.length - 1 },r = new Array(e.length),n = new Array(e.length);!function (e, t, r, n) {var o,i,s,c,u,h,d,g,p,f,v,_,y,m,E,x,R,A,P,V,T,C,b = e.Degree,L = Math.LN2,O = e.Degree + 1,S = new Array(O),M = new Array(O),w = new Array(O),N = new Array(O),F = new Object(),I = new Object();_ = 1;do {i = _, y = 1 + (_ /= 2);} while (y > 1);var D = 117549435082229e-52 / i,j = Math.cos(1.6406094968746698),B = Math.sin(1.6406094968746698),U = Math.sqrt(.5),k = -U;for (I.NZ = R = 0, I.szr = I.szi = I.lzr = I.lzi = 0; 0 == t[b];) {r[R] = n[R] = 0, b--, R++;}for (T = b + 1; b >= 1;) {if (b <= 2) {b < 2 ? (r[e.Degree - 1] = -t[1] / t[0], n[e.Degree - 1] = 0) : (F.li = F.lr = F.si = F.sr = 0, a(t[0], t[1], t[2], F), r[e.Degree - 2] = F.sr, n[e.Degree - 2] = F.si, r[e.Degree - 1] = F.lr, n[e.Degree - 1] = F.li);break;}for (d = 0, g = 340282346638529e24, G = 0; G < T; G++) {(f = Math.abs(t[G])) > d && (d = f), 0 != f && f < g && (g = f);}if (((p = D / g) <= 1 && d >= 10 || p > 1 && 340282346638529e24 / p >= d) && (p = 0 == p ? 117549435082229e-52 : p, P = Math.floor(Math.log(p) / L + .5), 1 != (u = Math.pow(2, P)))) for (G = 0; G < T; G++) {t[G] *= u;}for (var G = 0; G < T; G++) {M[G] = Math.abs(t[G]);}M[b] = -M[b], V = b - 1, f = Math.exp((Math.log(-M[b]) - Math.log(M[0])) / b), 0 != M[V] && (f = (v = -M[b] / M[V]) < f ? v : f), v = f;do {for (v = .1 * (f = v), h = M[0], G = 1; G < T; G++) {h = h * v + M[G];}} while (h > 0);for (c = f; Math.abs(c / f) > .005;) {for (s = h = M[0], G = 1; G < b; G++) {s = f * s + (h = f * h + M[G]);}f -= c = (h = f * h + M[b]) / s;}for (o = f, G = 1; G < b; G++) {S[G] = (b - G) * t[G] / b;}for (S[0] = t[0], _ = t[b], y = t[V], C = 0 == S[V] ? 1 : 0, A = 0; A < 5; A++) {if (m = S[V], C) {for (G = 0; G < V; G++) {S[R = V - G] = S[R - 1];}S[0] = 0, C = 0 == S[V] ? 1 : 0;} else {for (E = -_ / m, G = 0; G < V; G++) {S[R = V - G] = E * S[R - 1] + t[R];}S[0] = t[0], C = Math.abs(S[V]) <= Math.abs(y) * i * 10 ? 1 : 0;}}for (G = 0; G < b; G++) {N[G] = S[G];}for (A = 1; A <= 20; A++) {if (x = -B * k + j * U, k = B * U + j * k, l(i, O, 20 * A, o * (U = x), o, S, b, t, T, w, I), 0 != I.NZ) {for (r[R = e.Degree - b] = I.szr, n[R] = I.szi, b = (T -= I.NZ) - 1, G = 0; G < T; G++) {t[G] = w[G];}1 != I.NZ && (r[R + 1] = I.lzr, n[R + 1] = I.lzi);break;}for (G = 0; G < b; G++) {S[G] = N[G];}}if (A > 20) {e.Degree -= b;break;}}}(t, e, r, n);for (var o = [], i = e.length - t.Degree - 1; i < e.length; i++) {Math.abs(n[i]) < 1e-8 && o.push(r[i]);}return o;};}, function (e, t, r) {\"use strict\";Object.defineProperty(t, \"__esModule\", { value: !0 }), t.relaxBCurveToPerpendicular = t.closestBCurveSegments = t.maxDistanceSqrToHull = t.minDistanceSqrToHull = void 0;var n = r(1),o = r(0),i = r(37),s = r(35),a = function a(e, t) {var r,i = t.length / 3,s = n.Vector3.asFloat64(0, 0, 0);for (r = 0; r < i; ++r) {s[0] += t[3 * r], s[1] += t[3 * r + 1], s[2] += t[3 * r + 2];}n.Vector3.scale(s, s, 1 / i), n.Vector3.sub(s, s, e);var a = n.Vector3.squaredLength(s);if (a < o.KERNEL_TOLERANCE * o.KERNEL_TOLERANCE) return 0;var c = Number.POSITIVE_INFINITY;for (r = 0; r < i; ++r) {var u = s[0] * (t[3 * r] - e[0]) + s[1] * (t[3 * r + 1] - e[1]) + s[2] * (t[3 * r + 2] - e[2]);u < c && (c = u);}return c <= 0 ? 0 : c * c / a;},c = function c(e, t) {for (var r = t.length / 3, n = 0, o = 0; o < r; ++o) {var i = t[3 * o] - e[0],s = t[3 * o + 1] - e[1],a = t[3 * o + 2] - e[2],c = i * i + s * s + a * a;c > n && (n = c);}return n;};t.minDistanceSqrToHull = a, t.maxDistanceSqrToHull = c, t.closestBCurveSegments = function (e, t, r, o) {for (var i = Number.POSITIVE_INFINITY, s = [], u = 0; u < t.length; ++u) {var l,h = t[u],d = h.getRangeUnlimited();if (o) {l = !1;for (var g = 0; g < o.length; ++g) {if (d[1] >= o[g][0] + n.FLOAT64_TOLERANCE && d[0] <= o[g][1] - n.FLOAT64_TOLERANCE) {l = !0;break;}}} else l = !0;if (l) {var p = r ? r[u] : 0,f = h.getControlPoints(),v = a(e, f);if ((v = Math.max(0, v - p)) <= i) {var _ = c(e, f) + p;s.push({ index: u, minDistSqr: v, maxDistSqr: _ }), _ < i && (i = _);}}}return (s = s.filter(function (e) {return e.minDistSqr <= i;})).sort(function (e, t) {var r = e.minDistSqr - t.minDistSqr;return 0 === r ? e.maxDistSqr - t.maxDistSqr : r;}), s;}, t.relaxBCurveToPerpendicular = function (e, t, r, o, a, c, u, l) {var h = u || n.FLOAT64_TOLERANCE,d = l || 32,g = t.length / 3,p = e.length - g - 1;return (0, s.newtonRaphson1D)(function (n) {var s = (0, i.evaluateBCurveDerivs)(n, 2, p, e, t, r),a = s[0],c = s[1],u = s[2],l = [a[0] - o[0], a[1] - o[1], a[2] - o[2]];return { val: 2 * (l[0] * c[0] + l[1] * c[1] + l[2] * c[2]), deriv: 2 * (l[0] * u[0] + l[1] * u[1] + l[2] * u[2] + (c[0] * c[0] + c[1] * c[1] + c[2] * c[2])) };}, c, a, h, d);};}, function (e, t, r) {\"use strict\";Object.defineProperty(t, \"__esModule\", { value: !0 }), t.Sphere = void 0;var n = r(1),o = r(3),i = r(0),s = r(12),a = r(6),c = r(14),u = r(2),l = function l() {s.Surface.call(this), this._center = n.Vector3.createFloat64(), this._radius = 0, this._xAxis = n.Vector3.createFloat64(), this._yAxis = n.Vector3.createFloat64(), this._zAxis = n.Vector3.createFloat64();};(l.prototype = Object.create(s.Surface.prototype)).getGeometryType = function () {return i.GEOMETRY_TYPES.SPHERE;}, l.prototype.clone = function () {var e = new l();return e.copy(this), e;}, l.prototype.copy = function (e) {s.Surface.prototype.copy.call(this, e), this._radius = e._radius, n.Vector3.copy(this._center, e._center), n.Vector3.copy(this._xAxis, e._xAxis), n.Vector3.copy(this._yAxis, e._yAxis), n.Vector3.copy(this._zAxis, e._zAxis);}, l.prototype._computeYAxis = function () {n.Vector3.cross(this._yAxis, this._xAxis, this._zAxis);}, l.prototype.set = function (e, t, r, o) {n.Vector3.copy(this._center, e), u.ConsoleUtils.assert(t > i.KERNEL_TOLERANCE), this._radius = t;var s = void 0 === r || n.Vector3.squaredLength(r) < i.KERNEL_TOLERANCE * i.KERNEL_TOLERANCE,a = void 0 === o || n.Vector3.squaredLength(o) < i.KERNEL_TOLERANCE * i.KERNEL_TOLERANCE;s && a ? (n.Vector3.set(this._xAxis, 1, 0, 0), n.Vector3.set(this._zAxis, 0, 0, 1)) : s ? (n.Vector3.normalize(this._xAxis, o), n.Vector3.computeOrthogonal(this._zAxis, this._xAxis), n.Vector3.normalize(this._zAxis, this._zAxis)) : a ? (n.Vector3.normalize(this._zAxis, r), n.Vector3.computeOrthogonal(this._xAxis, this._zAxis), n.Vector3.normalize(this._xAxis, this._xAxis)) : (u.ConsoleUtils.assert(n.Vector3.isOrthogonal(r, o, i.KERNEL_ANGULAR_TOLERANCE)), n.Vector3.normalize(this._xAxis, o), n.Vector3.normalize(this._zAxis, r)), this._computeYAxis();}, l.prototype.getRadius = function () {return this._radius;}, l.prototype.setRadius = function (e) {u.ConsoleUtils.assert(e > i.KERNEL_TOLERANCE), this._radius = e;}, l.prototype.getCenter = function () {return this._center;}, l.prototype.setCenter = function (e) {n.Vector3.copy(this._center, e);}, l.prototype.getAxisDir = function () {return this._zAxis;}, l.prototype.setAxisDir = function (e) {u.ConsoleUtils.assert(n.Vector3.squaredLength(e) > i.KERNEL_TOLERANCE * i.KERNEL_TOLERANCE), n.Vector3.normalize(this._zAxis, e), (n.Vector3.squaredLength(this._xAxis) <= i.KERNEL_TOLERANCE * i.KERNEL_TOLERANCE || !n.Vector3.isOrthogonal(this._xAxis, this._zAxis, i.KERNEL_ANGULAR_TOLERANCE)) && (n.Vector3.computeOrthogonal(this._xAxis, this._zAxis), n.Vector3.normalize(this._xAxis, this._xAxis)), this._computeYAxis();}, l.prototype.getUvOriginDir = function () {return this._xAxis;}, l.prototype.setUvOriginDir = function (e) {u.ConsoleUtils.assert(n.Vector3.squaredLength(e) > i.KERNEL_TOLERANCE * i.KERNEL_TOLERANCE), n.Vector3.normalize(this._xAxis, e), (n.Vector3.squaredLength(this._zAxis) <= i.KERNEL_TOLERANCE * i.KERNEL_TOLERANCE || !n.Vector3.isOrthogonal(this._xAxis, this._zAxis, i.KERNEL_ANGULAR_TOLERANCE)) && (n.Vector3.computeOrthogonal(this._zAxis, this._xAxis), n.Vector3.normalize(this._zAxis, this._zAxis)), this._computeYAxis();}, l.prototype.evaluatePosition = function (e, t) {var r = Math.sin(e),o = Math.cos(e),i = Math.sin(t),s = Math.cos(t),a = this._radius * o * s,c = this._radius * o * i,u = this._radius * r,l = n.Vector3.clone(this._center);return n.Vector3.scaleAndAdd(l, l, this._xAxis, a), n.Vector3.scaleAndAdd(l, l, this._yAxis, c), n.Vector3.scaleAndAdd(l, l, this._zAxis, u), l;}, l.prototype.evaluateNormal = function (e, t) {var r = Math.sin(e),o = Math.cos(e),i = Math.sin(t),s = o * Math.cos(t),a = o * i,c = r,u = n.Vector3.createFloat64();return n.Vector3.scale(u, this._xAxis, s), n.Vector3.scaleAndAdd(u, u, this._yAxis, a), n.Vector3.scaleAndAdd(u, u, this._zAxis, c), u;}, l.prototype.evaluateDu = function (e, t) {var r = Math.sin(e),o = Math.cos(e),i = Math.sin(t),s = Math.cos(t),a = -this._radius * r * s,c = -this._radius * r * i,u = this._radius * o,l = n.Vector3.createFloat64();return n.Vector3.scale(l, this._xAxis, a), n.Vector3.scaleAndAdd(l, l, this._yAxis, c), n.Vector3.scaleAndAdd(l, l, this._zAxis, u), l;}, l.prototype.evaluateDv = function (e, t) {var r = Math.cos(e),o = Math.sin(t),i = Math.cos(t),s = -this._radius * r * o,a = this._radius * r * i,c = n.Vector3.createFloat64();return n.Vector3.scale(c, this._xAxis, s), n.Vector3.scaleAndAdd(c, c, this._yAxis, a), c;}, l.prototype.closestParam = function (e) {var t = n.Vector3.createFloat64();n.Vector3.sub(t, e, this._center);var r = n.Vector3.length(t);if (r < i.KERNEL_TOLERANCE) return { u: 0, v: 0 };var s = n.Vector3.dot(t, this._xAxis),a = n.Vector3.dot(t, this._yAxis),c = n.Vector3.dot(t, this._zAxis);return { u: Math.asin((0, o.clamp)(c / r, -1, 1)), v: Math.atan2(a, s) };}, l.prototype.vParamLine = function (e) {var t = Math.cos(e),r = Math.sin(e),o = this._radius * t,s = this._radius * r;if (Math.abs(o) > i.KERNEL_TOLERANCE) {var u = new c.Circle(),l = n.Vector3.clone(this._center);n.Vector3.scaleAndAdd(l, l, this._zAxis, s);var h = n.Vector3.clone(this._xAxis);n.Vector3.scale(h, h, o);var d = n.Vector3.clone(this._zAxis);return n.Vector3.negate(d, d), u.set(l, d, h), u;}var g = n.Vector3.clone(this._center);return s = s < 0 ? -this._radius : this._radius, n.Vector3.scaleAndAdd(g, g, this._zAxis, s), new a.Point(g);}, l.prototype.uParamLine = function (e) {var t = new c.Circle(),r = Math.sin(e),o = Math.cos(e),i = this._radius * o,s = this._radius * r,a = n.Vector3.clone(this._xAxis);n.Vector3.scale(a, a, -s), n.Vector3.scaleAndAdd(a, a, this._yAxis, i), n.Vector3.normalize(a, a);var u = n.Vector3.clone(this._xAxis);return n.Vector3.scale(u, u, i), n.Vector3.scaleAndAdd(u, u, this._yAxis, s), t.set(this._center, a, u), t;}, l.prototype.getBoundingBox = function (e, t) {e = e || [-Math.PI / 2, Math.PI / 2], t = t || [-Math.PI, Math.PI];var r = e[0],i = e[1],s = t[0],a = t[1],c = this.vParamLine(r).getBoundingBox(t);c.include(this.vParamLine(i).getBoundingBox(t)), c.include(this.uParamLine(s).getBoundingBox(e)), c.include(this.uParamLine(a).getBoundingBox(e));for (var u = n.Vector3.createFloat64(), l = 0; l < 3; ++l) {for (var h = 0; h < 2; ++h) {var d = 0 === h ? 1 : -1,g = Math.atan2(d * this._yAxis[l], d * this._xAxis[l]),p = Math.asin(d * this._zAxis[l]);g = (0, o.adjustParameterToPeriodicRange)(g, t, o.PI2), p > r && p < i && g > s && g < a && (n.Vector3.set(u, 0, 0, 0), u[l] = d * this._radius, c.includePoint(n.Vector3.add(u, this._center, u)));}}return c;}, l.prototype.transform = function (e) {n.Vector3.transformMatrix44(this._center, this._center, e), n.Vector3.transformAsDirectionMatrix44(this._xAxis, this._xAxis, e), n.Vector3.transformAsDirectionMatrix44(this._yAxis, this._yAxis, e), n.Vector3.transformAsDirectionMatrix44(this._zAxis, this._zAxis, e);var t = n.Vector3.length(this._xAxis);this._radius *= t, n.Vector3.normalize(this._xAxis, this._xAxis), n.Vector3.normalize(this._yAxis, this._yAxis), n.Vector3.normalize(this._zAxis, this._zAxis);}, l.prototype.getRangeUnlimitedU = function () {return [-Math.PI / 2, Math.PI / 2];}, l.prototype.getRangeUnlimitedV = function () {return [-Math.PI, Math.PI];}, l.prototype.isPeriodicUnlimitedU = function () {return !1;}, l.prototype.isPeriodicUnlimitedV = function () {return !0;}, l.prototype.isClosedUnlimitedU = function () {return !1;}, l.prototype.isClosedUnlimitedV = function () {return !0;}, l.prototype.toObject = function () {var e = this.evaluatePosition(0, 0);return n.Vector3.sub(e, e, this.getCenter()), { center: this.vectorToObject(this.getCenter()), radius: this.vectorToObject(e), axis: this.vectorToObject(this.getAxisDir()), uRange: this.rangeToObject(this.getRangeU(), this.isLimitedU()), vRange: this.rangeToObject(this.getRangeV(), this.isLimitedV()) };}, t.Sphere = l;}, function (e, t, r) {\"use strict\";Object.defineProperty(t, \"__esModule\", { value: !0 }), t.Torus = void 0;var n = r(1),o = r(3),i = r(0),s = r(12),a = r(6),c = r(14),u = r(2),l = function l() {s.Surface.call(this), this._center = n.Vector3.createFloat64(), this._majorRadius = 0, this._minorRadius = 0, this._lemon = !1, this._xAxis = n.Vector3.createFloat64(), this._yAxis = n.Vector3.createFloat64(), this._zAxis = n.Vector3.createFloat64();};(l.prototype = Object.create(s.Surface.prototype)).getGeometryType = function () {return i.GEOMETRY_TYPES.TORUS;}, l.prototype.clone = function () {var e = new l();return e.copy(this), e;}, l.prototype.copy = function (e) {s.Surface.prototype.copy.call(this, e), this._majorRadius = e._majorRadius, this._minorRadius = e._minorRadius, this._lemon = e._lemon, n.Vector3.copy(this._center, e._center), n.Vector3.copy(this._xAxis, e._xAxis), n.Vector3.copy(this._yAxis, e._yAxis), n.Vector3.copy(this._zAxis, e._zAxis);}, l.prototype._computeYAxis = function () {n.Vector3.cross(this._yAxis, this._xAxis, this._zAxis);}, l.prototype.set = function (e, t, r, o, s, a) {n.Vector3.copy(this._center, e), u.ConsoleUtils.assert(t > i.KERNEL_TOLERANCE), this._majorRadius = t, u.ConsoleUtils.assert(r > i.KERNEL_TOLERANCE), this._minorRadius = r, u.ConsoleUtils.assert(n.Vector3.squaredLength(o) > i.KERNEL_TOLERANCE * i.KERNEL_TOLERANCE), n.Vector3.normalize(this._zAxis, o), void 0 !== s && n.Vector3.squaredLength(s) > i.KERNEL_TOLERANCE * i.KERNEL_TOLERANCE ? (u.ConsoleUtils.assert(n.Vector3.isOrthogonal(o, s, i.KERNEL_ANGULAR_TOLERANCE)), n.Vector3.normalize(this._xAxis, s)) : (n.Vector3.computeOrthogonal(this._xAxis, this._zAxis), n.Vector3.normalize(this._xAxis, this._xAxis)), this._lemon = !0 === a, this._computeYAxis();}, l.prototype.getMajorRadius = function () {return this._majorRadius;}, l.prototype.setMajorRadius = function (e) {u.ConsoleUtils.assert(e > i.KERNEL_TOLERANCE), this._majorRadius = e;}, l.prototype.getMinorRadius = function () {return this._minorRadius;}, l.prototype.setMinorRadius = function (e) {u.ConsoleUtils.assert(e > i.KERNEL_TOLERANCE), this._minorRadius = e;}, l.prototype.getCenter = function () {return this._center;}, l.prototype.setCenter = function (e) {n.Vector3.copy(this._center, e);}, l.prototype.getAxisDir = function () {return this._zAxis;}, l.prototype.setAxisDir = function (e) {u.ConsoleUtils.assert(n.Vector3.squaredLength(e) > i.KERNEL_TOLERANCE * i.KERNEL_TOLERANCE), n.Vector3.normalize(this._zAxis, e), (n.Vector3.squaredLength(this._xAxis) <= i.KERNEL_TOLERANCE * i.KERNEL_TOLERANCE || !n.Vector3.isOrthogonal(this._xAxis, this._zAxis, i.KERNEL_ANGULAR_TOLERANCE)) && (n.Vector3.computeOrthogonal(this._xAxis, this._zAxis), n.Vector3.normalize(this._xAxis, this._xAxis)), this._computeYAxis();}, l.prototype.getUvOriginDir = function () {return this._xAxis;}, l.prototype.setUvOriginDir = function (e) {u.ConsoleUtils.assert(n.Vector3.squaredLength(e) > i.KERNEL_TOLERANCE * i.KERNEL_TOLERANCE), n.Vector3.normalize(this._xAxis, e), this._computeYAxis();}, l.prototype.isDoughnut = function () {return this._majorRadius > this._minorRadius + i.KERNEL_TOLERANCE;}, l.prototype.isVortex = function () {return Math.abs(this._majorRadius - this._minorRadius) <= i.KERNEL_TOLERANCE;}, l.prototype.isApple = function () {return this._majorRadius < this._minorRadius - i.KERNEL_TOLERANCE && !this._lemon;}, l.prototype.isLemon = function () {return this._majorRadius < this._minorRadius - i.KERNEL_TOLERANCE && this._lemon;}, l.prototype.setLemon = function (e) {this._lemon = e;}, l.prototype.getSingularUParams = function () {var e, t, r;return this.isDoughnut() ? [] : this.isApple() ? (e = -this._majorRadius, t = this._minorRadius, [-(r = Math.acos(e / t)), r]) : this.isLemon() ? (e = this._minorRadius - this._majorRadius, t = this._minorRadius, [-(r = Math.acos(e / t)), r]) : [-Math.PI, Math.PI];}, l.prototype.evaluatePosition = function (e, t) {var r = this._minorRadius * Math.cos(e);this.isLemon() ? r -= this._majorRadius : r += this._majorRadius;var o = r * Math.cos(t),i = r * Math.sin(t),s = this._minorRadius * Math.sin(e),a = n.Vector3.clone(this._center);return n.Vector3.scaleAndAdd(a, a, this._xAxis, o), n.Vector3.scaleAndAdd(a, a, this._yAxis, i), n.Vector3.scaleAndAdd(a, a, this._zAxis, s), a;}, l.prototype.evaluateNormal = function (e, t) {var r = Math.sin(e),o = Math.cos(e),i = Math.sin(t),s = o * Math.cos(t),a = o * i,c = r,u = n.Vector3.createFloat64();return n.Vector3.scale(u, this._xAxis, s), n.Vector3.scaleAndAdd(u, u, this._yAxis, a), n.Vector3.scaleAndAdd(u, u, this._zAxis, c), u;}, l.prototype.evaluateDu = function (e, t) {var r = -this._minorRadius * Math.sin(e),o = r * Math.cos(t),i = r * Math.sin(t),s = this._minorRadius * Math.cos(e),a = n.Vector3.createFloat64();return n.Vector3.scale(a, this._xAxis, o), n.Vector3.scaleAndAdd(a, a, this._yAxis, i), n.Vector3.scaleAndAdd(a, a, this._zAxis, s), a;}, l.prototype.evaluateDv = function (e, t) {var r = this._minorRadius * Math.cos(e);this.isLemon() ? r -= this._majorRadius : r += this._majorRadius;var o = -r * Math.sin(t),i = r * Math.cos(t),s = n.Vector3.createFloat64();return n.Vector3.scale(s, this._xAxis, o), n.Vector3.scaleAndAdd(s, s, this._yAxis, i), s;}, l.prototype.closestParam = function (e) {var t = n.Vector3.createFloat64();n.Vector3.sub(t, e, this._center);var r = n.Vector3.dot(t, this._xAxis),o = n.Vector3.dot(t, this._yAxis),s = n.Vector3.dot(t, this._zAxis),a = Math.sqrt(r * r + o * o);return this.isLemon() ? a += this._majorRadius : a -= this._majorRadius, { u: s * s + a * a > i.KERNEL_TOLERANCE * i.KERNEL_TOLERANCE ? Math.atan2(s, a) : 0, v: r * r + o * o > i.KERNEL_TOLERANCE * i.KERNEL_TOLERANCE ? Math.atan2(o, r) : 0 };}, l.prototype.vParamLine = function (e) {var t = this._minorRadius * Math.cos(e);this.isLemon() ? t -= this._majorRadius : t += this._majorRadius;var r = this._minorRadius * Math.sin(e);if (Math.abs(t) > i.KERNEL_TOLERANCE) {var o = new c.Circle(),s = n.Vector3.clone(this._center);n.Vector3.scaleAndAdd(s, s, this._zAxis, r);var u = n.Vector3.clone(this._xAxis);n.Vector3.scale(u, u, t);var l = n.Vector3.clone(this._zAxis);return n.Vector3.negate(l, l), o.set(s, l, u), o;}var h = n.Vector3.clone(this._center),d = this.getSingularUParams();return d[0] && r < 0 ? r = this._minorRadius * Math.sin(d[0]) : d[1] && r > 0 && (r = this._minorRadius * Math.sin(d[1])), n.Vector3.scaleAndAdd(h, h, this._zAxis, r), new a.Point(h);}, l.prototype.uParamLine = function (e) {var t = new c.Circle(),r = Math.sin(e),o = Math.cos(e),i = this._majorRadius * o,s = this._majorRadius * r;this.isLemon() && (i = -i, s = -s);var a = n.Vector3.clone(this._center);n.Vector3.scaleAndAdd(a, a, this._xAxis, i), n.Vector3.scaleAndAdd(a, a, this._yAxis, s);var u = this._minorRadius * o,l = this._minorRadius * r,h = n.Vector3.clone(this._xAxis);n.Vector3.scale(h, h, -l), n.Vector3.scaleAndAdd(h, h, this._yAxis, u), n.Vector3.normalize(h, h);var d = n.Vector3.clone(this._xAxis);return n.Vector3.scale(d, d, u), n.Vector3.scaleAndAdd(d, d, this._yAxis, l), t.set(a, h, d), t;}, l.prototype.getBoundingBox = function (e, t) {e = e || (this.isDoughnut() ? [-Math.PI, Math.PI] : this.getSingularUParams()), t = t || [-Math.PI, Math.PI];var r = e[0],i = e[1],s = t[0],a = t[1],c = this.vParamLine(r).getBoundingBox(t);c.include(this.vParamLine(i).getBoundingBox(t)), c.include(this.uParamLine(s).getBoundingBox(e)), c.include(this.uParamLine(a).getBoundingBox(e));for (var u = n.Vector3.createFloat64(), l = n.Vector3.createFloat64(), h = 0; h < 3; ++h) {for (var d = 0; d < 2; ++d) {var g = 0 === d ? -1 : 1,p = Math.atan2(g * this._yAxis[h], g * this._xAxis[h]);if ((p = (0, o.adjustParameterToPeriodicRange)(p, t, o.PI2)) > s && p < a) {var f = this.uParamLine(p);u = f.evaluatePosition(0), n.Vector3.sub(u, u, f.getCenter()), l = f.evaluatePosition(Math.PI / 2), n.Vector3.sub(l, l, f.getCenter());var v = (0, o.minMaxCosSinFunc)(u[h], l[h], f.getCenter()[h], e);0 === h ? c.includeX(v[d]) : 1 === h ? c.includeY(v[d]) : c.includeZ(v[d]);}}}return c;}, l.prototype.transform = function (e) {n.Vector3.transformMatrix44(this._center, this._center, e), n.Vector3.transformAsDirectionMatrix44(this._xAxis, this._xAxis, e), n.Vector3.transformAsDirectionMatrix44(this._yAxis, this._yAxis, e), n.Vector3.transformAsDirectionMatrix44(this._zAxis, this._zAxis, e);var t = n.Vector3.length(this._xAxis);this._majorRadius *= t, this._minorRadius *= t, n.Vector3.normalize(this._xAxis, this._xAxis), n.Vector3.normalize(this._yAxis, this._yAxis), n.Vector3.normalize(this._zAxis, this._zAxis);}, l.prototype.getRangeUnlimitedU = function () {return this.isDoughnut() ? [-Math.PI, Math.PI] : this.getSingularUParams();}, l.prototype.getRangeUnlimitedV = function () {return [-Math.PI, Math.PI];}, l.prototype.isPeriodicUnlimitedU = function () {return this.isDoughnut();}, l.prototype.isPeriodicUnlimitedV = function () {return !0;}, l.prototype.isClosedUnlimitedU = function () {return this.isDoughnut() || this.isVortex();}, l.prototype.isClosedUnlimitedV = function () {return !0;}, l.prototype.toObject = function () {var e = this.evaluatePosition(0, 0);return n.Vector3.sub(e, e, this.getCenter()), { center: this.vectorToObject(this.getCenter()), coordAxis: this.vectorToObject(this.getUvOriginDir()), axis: this.vectorToObject(this.getAxisDir()), majorRadius: this.getMajorRadius(), minorRadius: this.getMinorRadius(), lemon: this.isLemon(), uRange: this.rangeToObject(this.getRangeU(), this.isLimitedU()), vRange: this.rangeToObject(this.getRangeV(), this.isLimitedV()) };}, t.Torus = l;}, function (e, t, r) {\"use strict\";Object.defineProperty(t, \"__esModule\", { value: !0 }), t.evaluateBSurfaceDerivs = t.evaluateBSurfacePoint = void 0;var n = r(1),o = r(3),i = r(17),s = r(37);t.evaluateBSurfacePoint = function (e, t, r, o, a, c, u, l) {return l && l.length > 0 ? function (e, t, r, o, a, c, u, l) {for (var h, d = c.length - o - 1, g = (0, i.findKnotSpan)(e, a), p = (0, s.evaluateBasisFunctions)(g, e, r, a), f = (0, i.findKnotSpan)(t, c), v = (0, s.evaluateBasisFunctions)(f, t, o, c), _ = g - r, y = n.Vector4.createFloat64(), m = n.Vector4.createFloat64(), E = 0; E <= o; E++) {n.Vector4.set(m, 0, 0, 0, 0), h = f - o + E;for (var x = 0; x <= r; x++) {var R = (_ + x) * d + h,A = p[x] * l[R];m[0] += A * u[3 * R], m[1] += A * u[3 * R + 1], m[2] += A * u[3 * R + 2], m[3] += A;}y[0] += v[E] * m[0], y[1] += v[E] * m[1], y[2] += v[E] * m[2], y[3] += v[E] * m[3];}return n.Vector3.createFloat64FromValues(y[0] / y[3], y[1] / y[3], y[2] / y[3]);}(e, t, r, o, a, c, u, l) : function (e, t, r, o, a, c, u) {for (var l, h = c.length - o - 1, d = (0, i.findKnotSpan)(e, a), g = (0, s.evaluateBasisFunctions)(d, e, r, a), p = (0, i.findKnotSpan)(t, c), f = (0, s.evaluateBasisFunctions)(p, t, o, c), v = d - r, _ = n.Vector3.createFloat64(), y = n.Vector3.createFloat64(), m = 0; m <= o; m++) {n.Vector3.set(y, 0, 0, 0), l = p - o + m;for (var E = 0; E <= r; E++) {var x = (v + E) * h + l;y[0] += g[E] * u[3 * x], y[1] += g[E] * u[3 * x + 1], y[2] += g[E] * u[3 * x + 2];}_[0] += f[m] * y[0], _[1] += f[m] * y[1], _[2] += f[m] * y[2];}return _;}(e, t, r, o, a, c, u);}, t.evaluateBSurfaceDerivs = function (e, t, r, a, c, u, l, h, d) {return function (e, t, r, a, c, u, l, h, d) {var g,p,f,v,_,y,m = new Array(r + 1),E = new Array(r + 1),x = new Array(r + 1),R = new Array(r + 1);for (g = 0; g <= r; g++) {for (m[g] = new Array(r + 1 - g), E[g] = new Array(r + 1 - g), p = 0; p <= r - g; p++) {m[g][p] = n.Vector3.createFloat64(), E[g][p] = 0;}x[g] = new Array(a + 1), R[g] = new Array(c + 1);}var A = Math.min(r, a),P = (0, i.findKnotSpan)(e, u);(0, s.evaluateBasisDerivatives)(P, e, a, A, u, x);var V = Math.min(r, c),T = (0, i.findKnotSpan)(t, l);(0, s.evaluateBasisDerivatives)(T, t, c, V, l, R);var C = d && d.length > 0,b = l.length - c - 1,L = new Array(c + 1);for (g = 0; g <= A; g++) {for (f = 0; f <= c; f++) {for (L[f] = [0, 0, 0, 0], v = 0; v <= a; v++) {var O = (P - a + v) * b + (T - c + f),S = x[g][v];C && (S *= d[O], L[f][3] += S), L[f][0] += S * h[3 * O], L[f][1] += S * h[3 * O + 1], L[f][2] += S * h[3 * O + 2];}}var M = Math.min(r - g, V);for (p = 0; p <= M; p++) {for (f = 0; f <= c; f++) {m[g][p][0] += R[p][f] * L[f][0], m[g][p][1] += R[p][f] * L[f][1], m[g][p][2] += R[p][f] * L[f][2], C && (E[g][p] += R[p][f] * L[f][3]);}}}if (C) {var w = o.binomialCoefficients,N = n.Vector3.createFloat64();for (g = 0; g <= r; g++) {for (p = 0; p <= r - g; p++) {var F = m[g][p];for (y = 1; y <= p; y++) {n.Vector3.scaleAndAdd(F, F, m[g][p - y], -w[p][y] * E[0][y]);}for (_ = 1; _ <= g; _++) {for (n.Vector3.scaleAndAdd(F, F, m[g - _][p], -w[g][_] * E[_][0]), n.Vector3.set(N, 0, 0, 0), y = 1; y <= p; y++) {n.Vector3.scaleAndAdd(N, N, m[g - _][p - y], w[p][y] * E[_][y]);}n.Vector3.scaleAndAdd(F, F, N, -w[g][_]);}n.Vector3.scale(F, F, 1 / E[0][0]);}}}return m;}(e, t, r, a, c, u, l, h, d);};}, function (e, t, r) {\"use strict\";Object.defineProperty(t, \"__esModule\", { value: !0 }), t.newtonRaphson2D = t.RelaxResult = void 0;var n = r(1),o = {};o[o.Success = 0] = \"Success\", o[o.OutOfRange = 1] = \"OutOfRange\", o[o.DegenerateStep = 2] = \"DegenerateStep\", o[o.TooManySteps = 3] = \"TooManySteps\", o[o.RootNotFound = 4] = \"RootNotFound\", t.RelaxResult = o, t.newtonRaphson2D = function (e, t, r, i, s) {i = i || 1e-12, s = s || 100;var a = [void 0, void 0];r && 2 === r.length && (r[0] && 2 === r[0].length && (a[0] = r[0]), r[1] && 2 === r[1].length && (a[1] = r[1])), a[0] && (a[0][0], a[0][1]), a[1] && (a[1][0], a[1][1]);for (var c = [0, 0], u = 1 / 0, l = 1 / 0, h = !1, d = n.Matrix22.createFloat64(), g = n.Matrix22.createFloat64(), p = n.Vector2.clone(t), f = o.Success, v = 0; v <= s; v++) {var _ = e(p);if (u = n.Vector2.squaredLength(_.val), p[0], p[1], u < n.FLOAT64_TOLERANCE * n.FLOAT64_TOLERANCE) {f = o.Success;break;}if (v > 0) {var y = Math.max(Math.abs(c[0]), Math.abs(c[1]));if (y < i) {u >= l && (n.Vector2.sub(p, p, c), u = l, _ = e(p));var m = 10 * i * (n.Vector2.len(_.deriv1) + n.Vector2.len(_.deriv2)),E = m * m;f = u > E ? h ? o.OutOfRange : o.RootNotFound : o.Success;break;}}if (v === s) {u >= l && (n.Vector2.sub(p, p, c), u = l), f = o.TooManySteps;break;}if (v > 0 && u >= l) {var x = l / (l + u);x = Math.max(x, .1), n.Vector2.sub(p, p, c), n.Vector2.scale(c, c, x), n.Vector2.add(p, p, c), u = l;} else {if (l = u, n.Matrix22.set(d, -_.deriv1[0], -_.deriv1[1], -_.deriv2[0], -_.deriv2[1]), Math.abs(n.Matrix22.determinant(d)) < n.FLOAT64_TOLERANCE) {f = o.DegenerateStep;break;}n.Matrix22.invert(g, d), n.Vector2.transformMatrix22(c, _.val, g), c[0], c[1], n.Vector2.add(p, p, c), h = !1;for (var R = 0; R < 3; R++) {var A = R >= 2,P = R % 2;if (a[P]) {var V = 0;if (p[P] < a[P][0] ? (V = p[P] - a[P][0], p[P] = a[P][0]) : p[P] > a[P][1] && (V = p[P] - a[P][1], p[P] = a[P][1]), 0 !== V) {p[P];var T = c[P];if (c[P] -= V, A) ;else {var C = 1 - P;if (p[C] -= c[C], Math.abs(c[P]) > i) {var b = c[P] / T;c[C] *= b;} else {h = !0;var L = 0 === C ? _.deriv1 : _.deriv2;c[C] = -n.Vector2.dot(_.val, L) / Math.max(n.Vector2.dot(L, L), n.FLOAT64_TOLERANCE);}p[C] += c[C], c[0], c[1];}}}}}}return o[f], p[0], p[1], { param: p, status: f };};}, function (e, t, r) {\"use strict\";Object.defineProperty(t, \"__esModule\", { value: !0 }), t.getOrderedFacesOnVertex = function (e) {var t = e.getEdges(),r = new n(e),o = [];return t.forEach(function (t) {var n = t.getCoedges();for (var _t6 = 0; _t6 < n.length; ++_t6) {if (n[_t6].getStartVertex() === e) {var _e3 = r.marchFan(n[_t6]);_e3.faces.length > 0 && o.push(_e3);break;}}}), o;};var n = /*#__PURE__*/function () {function n(e) {_classCallCheck(this, n);this._vertex = e, this._visitedCoeds = new Set(), this._unvisitedCoeds = new Set(), this._faces = [], this._type = \"unset\";}_createClass(n, [{ key: \"addVisitedCoedge\", value: function addVisitedCoedge(e) {this._visitedCoeds.add(e), this._unvisitedCoeds.delete(e);} }, { key: \"getNextFace\", value: function getNextFace(e) {var t = e.getFace();t && this._faces.push(t), this.addVisitedCoedge(e);} }, { key: \"getPrevFace\", value: function getPrevFace(e) {var t = e.getFace();t && this._faces.unshift(t), this.addVisitedCoedge(e);} }, { key: \"collectUnvisitedCoeds\", value: function collectUnvisitedCoeds(e) {var _this = this;e.getEdge().getCoedges().forEach(function (e) {_this._visitedCoeds.has(e) || e.getStartVertex() !== _this._vertex || _this._unvisitedCoeds.add(e);});} }, { key: \"nextFace\", value: function nextFace(e) {var t = e.getPartner();if (!t) return void (\"unset\" === this._type && (this._type = \"chain\"));if (this._visitedCoeds.has(t)) return;if (t.getPartner() !== e && (this._type = \"unordered\", this.collectUnvisitedCoeds(e)), t.getEndVertex() !== this._vertex) return this._type = \"unordered\", void this.collectUnvisitedCoeds(t);this.addVisitedCoedge(t);var r = t.getNext();if (!this._visitedCoeds.has(r)) return this.getNextFace(r), r;\"unset\" === this._type && (this._type = \"cycle\");} }, { key: \"prevFace\", value: function prevFace(e) {var t = e.getPrevious();if (this._visitedCoeds.has(t)) return;var r = t.getPartner();return r && !this._visitedCoeds.has(r) ? (r.getPartner() !== t && (this._type = \"unordered\", this.collectUnvisitedCoeds(t)), r.getStartVertex() !== this._vertex ? (this._type = \"unordered\", void this.collectUnvisitedCoeds(r.getNext())) : (this.addVisitedCoedge(t), this.getPrevFace(r), r)) : void 0;} }, { key: \"collectFanFaces\", value: function collectFanFaces(e) {if (this._visitedCoeds.has(e)) return;var t = e;this.getNextFace(t);var r = t;for (; r;) {r = this.nextFace(r);}for (r = t; r;) {r = this.prevFace(r);}} }, { key: \"marchFan\", value: function marchFan(e) {for (this._faces = [], this._type = \"unset\", this.collectFanFaces(e); this._unvisitedCoeds.size > 0;) {var _e4 = this._unvisitedCoeds.values();this.collectFanFaces(_e4.next().value);}return { faces: this._faces, type: this._type };} }]);return n;}();}, function (e, t, r) {\"use strict\";Object.defineProperty(t, \"__esModule\", { value: !0 }), t.Attribute = void 0;var n = r(44);var o = { \"autodesk.brep:nmiattributestr-1.0.0\": \"nmiattributestr\", \"autodesk.brep:nmiattributearr-1.0.0\": \"nmiattributearr\", \"autodesk.brep:textattribute-1.0.0\": \"textattribute\" };var i = function i(e, t) {n.Base.call(this), this._topologies = [], this.typeid = e, this.values = t || {};};(i.prototype = Object.create(n.Base.prototype)).getValues = function () {return this.values;}, i.prototype.getTypeid = function () {return this.typeid;}, i.prototype.getTopologies = function () {return this._topologies;}, i.prototype.addTopology = function (e) {this._topologies ? this._topologies.push(e) : this._topologies = [e];}, i.prototype.removeTopology = function (e) {var t = this._topologies.indexOf(e);return t > -1 && (this._topologies.splice(t, 1), !0);}, i.prototype.toObject = function () {return this.values;}, i.prototype.addToModelObject = function (e) {if (!e.attributes[this.getGuid()]) {var _t7 = o[this.typeid];if (_t7) {var _r4 = {};_r4[_t7] = this.toObject(), e.attributes[this.getGuid()] = _r4;} else console.warn(\"Attribute.addToModelObject : Unknown attribute type for proto object!\");}}, t.Attribute = i;}, function (e, t, r) {\"use strict\";Object.defineProperty(t, \"__esModule\", { value: !0 }), t.SketchRegionSolver = void 0;var n = r(1),o = r(3),i = r(0),s = r(18),a = r(7),c = r(14),u = r(33),l = r(23),h = r(6),d = r(13),g = r(27),p = r(81),f = r(82),v = r(56),_ = r(36),y = r(55),m = r(41),E = r(112),x = r(113),R = r(2),A = r(8),P = function (e) {return e && e.__esModule ? e : { default: e };}(r(42)),V = function V() {this.SIDE = { LEFT: 0, RIGHT: 1 }, this._sketch = void 0, this._intersectionVertices = [], this._edgeSegments = [], this._cells = [], this._faces = [], this._workspace = { edgeIntersections: [], edgeOverlapRegions: [], segmentBlackList: [], edges: [], edgeIDs: [], sweepLineIntersections: void 0, sweepLineRegions: void 0, currentVertex: void 0, nextVertex: void 0, edgesPerCell: void 0 }, this._sketchRegionTopologies = {}, this._planeGeometry = new s.Plane(), this._planeGeometry.set([0, 0, 0], [0, 0, 1], [1, 0, 0]), this._sketchSummary = {}, this._internalToFinalMap = null, this._finalFaces = [], this._progenitorMap = null;};V.prototype.compute = function (e) {this._sketchEdges = e, this._initializeWorkspace(), this._findIntersections(), this._addGraphEdges(), this._mergeCoincidentSegments(), this._sortEdgesAroundVertex(), this._assignAdjacentEdges(), this._sweepRegions(), this._assignleftmostEdges(), this._removeGrazingIntersectionVertices(), this._updateVertexGuidLists(), this._removeTemporaryVertices(), this._assignLoops(), this._updateSketchRegionTopology(), this._clearWorkspace(), this._prepareResult();}, V.prototype._initializeWorkspace = function () {var e = this._workspace;e.edges = {};for (var t = 0; t < this._sketchEdges.length; ++t) {e.edges[this._sketchEdges[t].getGuid()] = this._sketchEdges[t];}for (e.edgeIDs = Object.getOwnPropertyNames(e.edges).sort(), e.edgeIntersections = {}, e.edgeOverlapRegions = {}, e.segmentBlackList = {}, t = 0; t < e.edgeIDs.length; t++) {e.edgeIntersections[e.edgeIDs[t]] = [], e.edgeOverlapRegions[e.edgeIDs[t]] = [], e.segmentBlackList[e.edgeIDs[t]] = [];}e.sweepLineIntersections = void 0, e.sweepLineRegions = void 0, e.edgesPerCell = [], this._faces = [];}, V.prototype._clearWorkspace = function () {this._workspace = { edgeIntersections: [], edgeOverlapRegions: [], segmentBlackList: [], edges: [], edgeIDs: [], sweepLineIntersections: void 0, sweepLineRegions: void 0, currentVertex: void 0, nextVertex: void 0, sweepLinePosition: void 0, edgesPerCell: [] };}, V.prototype._findIntersections = function () {for (var e = this._workspace, t = 0; t < e.edgeIDs.length; t++) {for (var r = e.edges[e.edgeIDs[t]], s = t; s < e.edgeIDs.length; s++) {var a = e.edges[e.edgeIDs[s]];if (s > t || r.getCurveType() === i.GEOMETRY_TYPES.BCURVE) for (var c = (0, p.computeCurveCurveIntersections)(r, a, !0, !1, i.KERNEL_TOLERANCE), u = 0; u < c.length; u++) {var l = c[u];if (l.rangeInfo) e.edgeIntersections[e.edgeIDs[t]].push(P.default.extend(l.rangeInfo[0], { temporary: !1 })), e.edgeIntersections[e.edgeIDs[t]].push(P.default.extend(l.rangeInfo[1], { temporary: !1 })), e.edgeIntersections[e.edgeIDs[s]].push(P.default.extend(l.rangeByInfo[0], { temporary: !1 })), e.edgeIntersections[e.edgeIDs[s]].push(P.default.extend(l.rangeByInfo[1], { temporary: !1 })), e.edgeOverlapRegions[e.edgeIDs[t]].push({ overlapRange: (0, o.convertToOtherPeriodicRange)([l.rangeInfo[0].param, l.rangeInfo[1].param], r.getRange(), r.getCurve().getPeriod(), i.KERNEL_TOLERANCE), otherEdge: e.edgeIDs[s], otherRange: (0, o.convertToOtherPeriodicRange)([l.rangeByInfo[0].param, l.rangeByInfo[1].param], a.getRange(), a.getCurve().getPeriod(), i.KERNEL_TOLERANCE) }), e.edgeOverlapRegions[e.edgeIDs[s]].push({ overlapRange: (0, o.convertToOtherPeriodicRange)([l.rangeByInfo[0].param, l.rangeByInfo[1].param], a.getRange(), a.getCurve().getPeriod(), i.KERNEL_TOLERANCE), otherEdge: e.edgeIDs[t], otherRange: (0, o.convertToOtherPeriodicRange)([l.rangeInfo[0].param, l.rangeInfo[1].param], r.getRange(), r.getCurve().getPeriod(), i.KERNEL_TOLERANCE) });else {if (l.cutInfo.param < r.t0() || l.cutInfo.param > r.t1()) {A.DebugUtils.warn(\"Intersection outside the bounds of the edge, ignoring\");continue;}e.edgeIntersections[e.edgeIDs[t]].push(P.default.defaults(l.cutInfo, { temporary: !1, virtualIntersection: !1 })), e.edgeIntersections[e.edgeIDs[s]].push(P.default.defaults(l.cutByInfo, { temporary: !1, virtualIntersection: !1 }));}}}var h = r.getStartVertex(),d = r.getEndVertex(),g = r.t0();h && void 0 !== P.default.findWhere(e.edgeIntersections[e.edgeIDs[t]], { param: g, atVertex: h }) || e.edgeIntersections[e.edgeIDs[t]].push({ param: g, atVertex: h, temporary: !1, virtualIntersection: void 0 });var f = r.t1();d && void 0 !== P.default.findWhere(e.edgeIntersections[e.edgeIDs[t]], { param: f, atVertex: d }) || e.edgeIntersections[e.edgeIDs[t]].push({ param: f, atVertex: d, temporary: !1, virtualIntersection: void 0 }), this._makeEdgeXMonotone(r, e.edgeIntersections[e.edgeIDs[t]]);}var v = [];for (t = 0; t < e.edgeIDs.length; t++) {for (s = 0; s < e.edgeIntersections[e.edgeIDs[t]].length; s++) {v.push({ position: e.edges[e.edgeIDs[t]].evaluatePosition(e.edgeIntersections[e.edgeIDs[t]][s].param), virtualIntersection: e.edgeIntersections[e.edgeIDs[t]][s].virtualIntersection });}}for (t = 0; t < e.edgeIDs.length; t++) {var _ = e.edges[e.edgeIDs[t]];for (s = 0; s < v.length; s++) {var y = v[s];if (_.getBoundingBox().isPointInsideWithTolerance(y.position, i.KERNEL_TOLERANCE)) {var m = _.closestToPointParam(y.position);n.Vector3.distance(y.position, _.evaluatePosition(m)) < i.KERNEL_TOLERANCE && m > _.t0() + i.PARAMETER_SPACE_TOLERANCE && m < _.t1() - i.PARAMETER_SPACE_TOLERANCE && e.edgeIntersections[e.edgeIDs[t]].push({ param: m, atVertex: null, temporary: !0, virtualIntersection: y.virtualIntersection });}}}}, V.prototype._addGraphEdges = function () {var e = this._workspace;this._intersectionVertices = [], this._edgeSegments = [];for (var t = function t(_t8, r) {var n = e.segmentBlackList[_t8],s = e.edges[_t8].getCurve(),a = s.getPeriod(),c = e.edges[_t8].isReversed() ? -1 : 1,u = i.KERNEL_TOLERANCE / s.tangentLength(c * r[0]),l = i.KERNEL_TOLERANCE / s.tangentLength(c * r[1]);if (e.edges[_t8].getCurve().isPeriodic()) {for (var h = 0; h < n.length; h++) {if ((0, o.periodicDifference)(n[h].range[0], r[0], a) < u && (0, o.periodicDifference)(n[h].range[1], r[1], a) < l) return n[h].edge;}} else for (h = 0; h < n.length; h++) {if (Math.abs(n[h].range[0] - r[0]) < u && Math.abs(n[h].range[1] - r[1]) < l) return n[h].edge;}}, r = 0; r < e.edgeIDs.length; r++) {var s = e.edges[e.edgeIDs[r]],a = 1,c = this._createGUIDfromEdgeAndLocalID(s, a);e.edgeIntersections[e.edgeIDs[r]] = e.edgeIntersections[e.edgeIDs[r]].sort(function (e, t) {return e.param - t.param;});for (var u = e.edgeIntersections[e.edgeIDs[r]], l = void 0, h = 0; h < u.length; h++) {var d = s.evaluatePosition(u[h].param),g = this._findVertexIndex(d);void 0 === g ? (g = this._intersectionVertices.length, this._intersectionVertices.push({ position: d, adjacentEdges: [], vertices: [], index: g, guidList: [], mergedPositions: [], topologyVertex: void 0, temporary: u[h].temporary, virtualIntersection: u[h].virtualIntersection })) : (this._intersectionVertices[g].temporary = this._intersectionVertices[g].temporary && u[h].temporary, void 0 !== u[h].virtualIntersection && (void 0 === this._intersectionVertices[g].virtualIntersection ? this._intersectionVertices[g].virtualIntersection = u[h].virtualIntersection : this._intersectionVertices[g].virtualIntersection = this._intersectionVertices[g].virtualIntersection && u[h].virtualIntersection), this._intersectionVertices[g].mergedPositions.push(d));var p = this._intersectionVertices[g];if (u[h].atVertex && -1 === p.vertices.indexOf(u[h].atVertex) && p.vertices.push(u[h].atVertex), h > 0 && l !== g) {c = this._createGUIDfromEdgeAndLocalID(s, a), a++;var f = [u[h - 1].param, u[h].param],v = t(s.getGuid(), f);if (void 0 === v) {var _ = { originalEdge: s, parameterRange: f, startVertex: this._intersectionVertices[l], endVertex: this._intersectionVertices[g], coincidentRanges: [], adjacent: [{ prevEdge: void 0, nextEdge: void 0, face: void 0 }, { prevEdge: void 0, nextEdge: void 0, face: void 0 }], index: this._edgeSegments.length, localGuid: c, topologyEdge: void 0 };this._edgeSegments.push(_), this._intersectionVertices[l].adjacentEdges.push(_), this._intersectionVertices[g].adjacentEdges.push(_);for (var y = 0; y < e.edgeOverlapRegions[e.edgeIDs[r]].length; y++) {var m = e.edgeOverlapRegions[e.edgeIDs[r]][y],E = f,x = i.KERNEL_TOLERANCE;if (s.getCurve().isPeriodic() && (s.getCurveType() === i.GEOMETRY_TYPES.CIRCLE && (x /= s.getCurve().getRadius()), E = (0, o.convertToOtherPeriodicRange)(E, s.getRange(), s.getCurve().getPeriod(), x)), E[0] >= m.overlapRange[0] - i.KERNEL_TOLERANCE && E[1] <= m.overlapRange[1] + i.KERNEL_TOLERANCE) {var R = m.otherEdge,A = [e.edges[R].getCurve().closestToPointParam(_.startVertex.position), e.edges[R].getCurve().closestToPointParam(_.endVertex.position)];if (e.edges[R].getCurve().isPeriodic()) {var P = _.originalEdge.getCurve().evaluateDt(_.parameterRange[0]),V = e.edges[R].getCurve().evaluateDt(A[0]);for (n.Vector3.dot(P, V) < 0 && (T = A[0], A[0] = A[1], A[1] = T); A[1] < A[0];) {A[1] += e.edges[R].getCurve().getPeriod();}} else if (A[0] > A[1]) {var T = A[0];A[0] = A[1], A[1] = T;}e.segmentBlackList[m.otherEdge].push({ range: A, edge: _ });}}} else {var C,b = n.Vector3.distance(v.startVertex.position, s.evaluatePosition(f[0])) > n.Vector3.distance(v.startVertex.position, s.evaluatePosition(f[1]));if (v.coincidentRanges.push({ originalEdge: s, parameterRange: f, localGuid: c, flipped: b }), 0 === p.adjacentEdges.length && ((C = n.Vector3.distance(d, v.startVertex.position) < n.Vector3.distance(d, v.endVertex.position) ? v.startVertex : v.endVertex).mergedPositions.push(d), d = C.position, g = C.index, u[h].atVertex && -1 === C.vertices.indexOf(u[h].atVertex) && C.vertices.push(u[h].atVertex), this._intersectionVertices.pop()), v.startVertex.index !== l && v.endVertex.index !== l) {var L = v.startVertex.index === g ? v.endVertex : v.startVertex,O = this._intersectionVertices[l];for (y = 0; y < O.adjacentEdges.length; y++) {var S = O.adjacentEdges[y];S.startVertex === O && (S.startVertex = L), S.endVertex === O && (S.endVertex = L), L.adjacentEdges.push(S);}for (L.mergedPositions.push(O.position), y = 0; y < O.mergedPositions.length; y++) {L.mergedPositions.push(O.mergedPositions[y]);}for (u[h].atVertex && -1 === L.vertices.indexOf(u[h].atVertex) && L.vertices.push(u[h].atVertex), this._intersectionVertices.splice(l, 1), y = l; y < this._intersectionVertices.length; y++) {this._intersectionVertices[y].index = y;}}}}l = g;}}}, V.prototype._mergeCoincidentSegments = function () {for (var e, t = {}, r = 0; r < this._intersectionVertices.length; r++) {for (var n = this._intersectionVertices[r], o = {}, s = 0; s < n.adjacentEdges.length; s++) {var a = (e = n.adjacentEdges[s]).startVertex === n ? e.endVertex : e.startVertex;t[String(n.index) + \"_\" + String(a.index)] || (o[String(a.index)] = o[String(a.index)] || [], o[String(a.index)].push(e));}var c = P.default.keys(o);for (s = 0; s < c.length; s++) {if (t[c[s] + \"_\" + String(n.index)] = !0, o[c[s]].length > 1) for (var u = o[c[s]], l = 0; l < u.length; l++) {for (var h = [], d = l + 1; d < u.length; d++) {(0, f.curvesAreCoincident)(u[l].originalEdge.getCurve(), u[d].originalEdge.getCurve(), u[l].parameterRange, u[d].parameterRange, i.KERNEL_TOLERANCE) && (h.push(u[d]), u.splice(d, 1), d--);}for (d = 0; d < h.length; d++) {var g = h[d];u[l].coincidentRanges.push({ originalEdge: g.originalEdge, parameterRange: g.parameterRange, localGuid: g.localGuid, flipped: g.startVertex !== u[l].startVertex }), g.startVertex.adjacentEdges.splice(g.startVertex.adjacentEdges.indexOf(g), 1), g.endVertex.adjacentEdges.splice(g.endVertex.adjacentEdges.indexOf(g), 1);var p = this._edgeSegments.indexOf(g);this._edgeSegments.splice(p, 1);for (var v = p; v < this._edgeSegments.length; v++) {this._edgeSegments[v].index = v;}}}}}}, V.prototype._sortEdgesAroundVertex = function () {for (var e = 0; e < this._intersectionVertices.length; e++) {for (var t = this._intersectionVertices[e], r = [], s = 0; s < t.adjacentEdges.length; s++) {var a = this._computeAngleAndPositionForEdge(s, t);r.push({ index: s, originalAngle: a.angle, angle: a.angle, position: a.position, derivative: void 0 });}for (var c = 0, u = !1; !u;) {u = !0;var l = -Math.PI + c;for (s = 0; s < r.length; s++) {if ((0, o.angleDifference)(l, r[s].angle) < 1e-5) {u = !1;break;}}if (u) break;c += 2e-5;}for (s = 0; s < t.adjacentEdges.length; s++) {r[s].angle = (0, o.normalizeParameterToShiftedRange)(r[s].angle - c, [-Math.PI, Math.PI]);}var h = this;r = r.sort(function (e, r) {if ((0, o.angleDifference)(e.angle, r.angle) > 1e-5) return e.angle - r.angle;var s = t.adjacentEdges[e.index],a = t.adjacentEdges[r.index],c = s.startVertex === t ? s.parameterRange[0] : s.parameterRange[1],u = a.startVertex === t ? a.parameterRange[0] : a.parameterRange[1],l = s.originalEdge.evaluatePosition(c),d = a.originalEdge.evaluatePosition(u),g = n.Vector3.distance(l, d),p = n.Vector3.createFloat64(),f = n.Vector3.createFloat64(),v = s.originalEdge.evaluateCurvature(c, p),_ = a.originalEdge.evaluateCurvature(u, f);if (0 === v && 0 === _) return e.angle - r.angle;if (0 === v || 0 === _) {var y = 1 / Math.max(v, _);g += 1.5 * Math.sqrt(Math.pow(y, 2) - Math.pow(y - g, 2)) + i.KERNEL_TOLERANCE;} else {var m = 1 / v,E = 1 / _;if (m < E) {var x = m;m = E, E = x;}n.Vector3.dot(p, f) < 0 ? g += -Math.sqrt(-.25 * Math.pow(g, 4) + Math.pow(g, 3) * m - g * g * m * m - (g * g - 2 * g * m) * E * E + (g * g * g - 3 * g * g * m + 2 * g * m * m) * E) / (g - m - E) * 1.5 : g += Math.sqrt(-.25 * Math.pow(g, 4) - Math.pow(g, 3) * m - g * g * m * m - (g * g + 2 * g * m) * E * E + (g * g * g + 3 * g * g * m + 2 * g * m * m) * E) / (g + m - E) * 1.5;}var R = Math.min(n.Vector3.distance(s.endVertex.position, s.startVertex.position), n.Vector3.distance(a.endVertex.position, a.startVertex.position));g = Math.max(i.KERNEL_TOLERANCE, g), g = Math.min(.9 * R, g);var A = !1;do {var P = h._computeEdgeDirectionAtVertex(e, t, g),V = h._computeEdgeDirectionAtVertex(r, t, g);A = (0, o.angleDifference)(P, V) > 1e-8, g *= 5;} while (!A && g < R);var T = P - V;return T > Math.PI ? T -= o.PI2 : T < -Math.PI && (T += o.PI2), T;}), t.adjacentEdges = P.default.map(r, function (e) {return t.adjacentEdges[e.index];});}}, V.prototype._assignAdjacentEdges = function () {for (var e = 0; e < this._edgeSegments.length; e++) {var t = this._edgeSegments[e];this._assignAdjacentEdgesToSegment(t);}}, V.prototype._assignAdjacentEdgesToSegment = function (e) {var t = e.startVertex.adjacentEdges,r = t.indexOf(e);R.ConsoleUtils.assert(-1 !== r, \"Error in topology\");for (var n = 0, i = e.endVertex.adjacentEdges; n < i.length && i[n] !== e;) {n++;}R.ConsoleUtils.assert(n < i.length, \"Error in topology\"), e.adjacent[this.SIDE.LEFT].nextEdge = i[(0, o.modulus)(n - 1, i.length)], e.adjacent[this.SIDE.LEFT].prevEdge = t[(0, o.modulus)(r + 1, t.length)], e.adjacent[this.SIDE.RIGHT].nextEdge = i[(0, o.modulus)(n + 1, i.length)], e.adjacent[this.SIDE.RIGHT].prevEdge = t[(0, o.modulus)(r - 1, t.length)];}, V.prototype._sweepRegions = function () {var e = this._workspace,t = P.default.clone(this._intersectionVertices).sort(function (e, t) {if (Math.abs(e.position[0] - t.position[0]) < 1e-9) {for (var r = 0; r < e.adjacentEdges.length; r++) {for (var o = 0; o < t.adjacentEdges.length; o++) {if (e.adjacentEdges[r].originalEdge === t.adjacentEdges[o].originalEdge) {var s = e.adjacentEdges[r],a = t.adjacentEdges[o],c = s.startVertex === e ? s.parameterRange[0] : s.parameterRange[1],u = a.startVertex === t ? a.parameterRange[0] : a.parameterRange[1],l = !0,h = n.Vector3.createFloat64();n.Vector3.normalize(h, s.originalEdge.evaluateDt(c));var d = n.Vector3.createFloat64();if (n.Vector3.normalize(d, a.originalEdge.evaluateDt(u)), Math.sign(h[0]) !== Math.sign(d[0])) continue;if (Math.abs(h[0]) > i.KERNEL_TOLERANCE && Math.abs(d[0]) > i.KERNEL_TOLERANCE) l = h[0] > 0;else {if (Math.abs(e.position[1] - t.position[1]) < i.KERNEL_TOLERANCE) continue;l = h[1] > 0;}return (c - u) * (l ? 1 : -1);}}}return e.position[1] - t.position[1];}return e.position[0] - t.position[0];});this._cells = [];var r = { index: -1, loops: [], loopOrientations: [], dangling: [], leftmostVertex: void 0 };e.sweepLineIntersections = [-1 / 0, 1 / 0], e.sweepLineRegions = e.sweepLineRegions = [r];for (var o = [], s = 0; s < t.length; s++) {e.sweepLineRegions.length !== e.sweepLineIntersections.length - 1 && console.error(\"Error during sweep computation\");var a = t[s],c = P.default.clone(a.adjacentEdges),u = void 0;if (o[a.index]) {for (var l = o[a.index], h = [], d = 0; d < e.sweepLineIntersections.length - 1; d++) {P.default.contains(l, e.sweepLineIntersections[d]) && (void 0 === u && (u = d - 1), P.default.contains(l, e.sweepLineIntersections[d + 1]) && h.push(d));}for (d = 0; d < l.length; d++) {for (var g = l[d], p = 0; p < e.sweepLineIntersections.length; p++) {e.sweepLineIntersections[p] === g && e.sweepLineIntersections.splice(p, 1);}for (p = 0; p < c.length; p++) {c[p] === g && c.splice(p, 1);}}for (d = h.length - 1; d >= 0; d--) {e.sweepLineRegions.splice(h[d], 1);}} else u = this._findVertexOnSweepLine(a), e.sweepLineRegions.splice(u + 1, 0, e.sweepLineRegions[u]);if (c.length > 0) {var f = u + 1;for (d = 0; d < c.length; d++) {var v = c[d];e.sweepLineIntersections.splice(f, 0, v);var _ = v.startVertex === a ? v.endVertex : v.startVertex;if (void 0 === o[_.index] && (o[_.index] = []), o[_.index].push(v), d > 0) {var y = { index: this._cells.length, loops: [], loopOrientations: [], dangling: [], leftmostVertex: a };this._cells.push(y), e.sweepLineRegions.splice(f - 1, 0, y);}f++;}for (f = u, d = 0; d < c.length; d++) {var m = (v = c[d]).startVertex !== a;v.adjacent[m ? this.SIDE.RIGHT : this.SIDE.LEFT].face = e.sweepLineRegions[f + 1], v.adjacent[m ? this.SIDE.LEFT : this.SIDE.RIGHT].face = e.sweepLineRegions[f], f++;}} else if (e.sweepLineRegions[u] !== e.sweepLineRegions[u + 1]) {var E = e.sweepLineRegions[u + 1],x = e.sweepLineRegions[u];for (x === r ? (x = E, E = r, e.sweepLineRegions.splice(u, 1)) : (void 0 !== x.leftmostVertex && (void 0 === E.leftmostVertex || E.leftmostVertex.position[0] > x.leftmostVertex.position[0]) && (E.leftmostVertex = x.leftmostVertex), e.sweepLineRegions.splice(u + 1, 1)), d = 0; d < this._edgeSegments.length; d++) {this._edgeSegments[d].adjacent[this.SIDE.LEFT].face === x && (this._edgeSegments[d].adjacent[this.SIDE.LEFT].face = E), this._edgeSegments[d].adjacent[this.SIDE.RIGHT].face === x && (this._edgeSegments[d].adjacent[this.SIDE.RIGHT].face = E);}for (d = 0; d < e.sweepLineRegions.length; d++) {e.sweepLineRegions[d] === x && (e.sweepLineRegions[d] = E);}this._cells[x.index] = void 0;} else e.sweepLineRegions.splice(u + 1, 1);}for (s = 0; s < this._cells.length; s++) {void 0 === this._cells[s] && (this._cells.splice(s, 1), s--);}for (s = 0; s < this._cells.length; s++) {this._cells[s].index = s;}}, V.prototype._assignleftmostEdges = function () {for (var e = this, t = 0; t < this._cells.length; t++) {var r = this._cells[t],n = r.leftmostVertex,o = P.default.filter(n.adjacentEdges, function (t) {var n = t.adjacent[e.SIDE.LEFT].face,o = t.adjacent[e.SIDE.RIGHT].face;return (n === r || o === r) && n !== o;});if (R.ConsoleUtils.assert(o.length >= 2, \"In each loop there should be at least two adjacent edges\"), o.length > 2) for (var i = 0; i < o.length; i++) {var s = o[i].adjacent[e.SIDE.LEFT].face === r ? e.SIDE.LEFT : e.SIDE.RIGHT,a = o[i].adjacent[s],c = o[i].startVertex === n ? a.prevEdge : a.nextEdge;if (P.default.contains(o, c)) {o = [o[i], c];break;}}var u = o[0];u.loopsCurveAligned = !!(u.startVertex === n ^ o[0].adjacent[e.SIDE.RIGHT].face === r), r.leftmostEdge = u, r.leftmostVertex = void 0;}}, V.prototype._removeGrazingIntersectionVertices = function () {for (var e = {}, t = 0, r = this._intersectionVertices.slice(); r.length > 0;) {var n = r.pop();if (2 === n.adjacentEdges.length && (1 === n.adjacentEdges[0].coincidentRanges.length || 1 === n.adjacentEdges[1].coincidentRanges.length) && n.virtualIntersection) {var i,s,a = 1 === n.adjacentEdges[0].coincidentRanges.length && 1 === n.adjacentEdges[1].coincidentRanges.length,c = n.adjacentEdges.slice();if (a) {if (i = [c[0].originalEdge, c[0].coincidentRanges[0].originalEdge], s = [c[1].originalEdge, c[1].coincidentRanges[0].originalEdge], !(i[0] === s[0] && i[1] === s[1] || i[0] === s[1] && i[1] === s[0])) continue;e[c[0].originalEdge.getGuid()] = !0, e[c[0].coincidentRanges[0].originalEdge.getGuid()] = !0, e[c[1].originalEdge.getGuid()] = !0, e[c[1].coincidentRanges[0].originalEdge] = !0;var u = [c[0].startVertex === n ? c[0].endVertex : c[0].startVertex, n, c[1].startVertex === n ? c[1].endVertex : c[1].startVertex];} else {var l;c[0].coincidentRanges.length > 0 ? (l = 0, i = [c[0].originalEdge, c[0].coincidentRanges[0].originalEdge]) : (l = 1, i = [c[1].originalEdge, c[1].coincidentRanges[0].originalEdge]), e[i[0].getGuid()] = !0, e[i[1].getGuid()] = !0, u = [c[l].startVertex === n ? c[l].endVertex : c[l].startVertex, n], c = [c[l]];}var h = void 0,d = void 0;if (u[0].vertices.length > 0 ? (h = u[0], d = a ? [u[1], u[2]] : [u[1]]) : a && u[2].vertices.length > 0 ? (h = u[2], d = [u[0], u[1]]) : (h = u[1], d = a ? [u[0], u[2]] : [u[0]]), d[0].vertices.length > 0 || d[1] && (d[1].vertices.length > 0 || d[0] === d[1])) continue;for (var g = !0, p = P.default.without(d, n), f = 0; f < p.length; f++) {var v = p[f].adjacentEdges;if ((v = P.default.difference(v, c)).length > 2) {g = !1;break;}for (var _ = 0; _ < v.length; _++) {if (v[_].coincidentRanges.length > 0 || v[_].originalEdge !== i[0] && v[_].originalEdge !== i[1]) {g = !1;break;}}}if (!g) continue;for (f = 0; f < p.length; f++) {var y = p[f],m = P.default.intersection(c, y.adjacentEdges)[0],E = n !== h && a ? P.default.without(c, m)[0] : m,x = P.default.without(y.adjacentEdges, m);for (y.adjacentEdges[1] === m && (x = x.reverse()), _ = 0; _ < x.length; _++) {var R = x[_],A = E.startVertex === h ? 0 : 1,V = void 0;if (E.originalEdge === R.originalEdge) V = E.parameterRange[A];else {var T = E.coincidentRanges[0].flipped ? 1 - A : A;V = E.coincidentRanges[0].parameterRange[T];}R.startVertex === y ? (R.startVertex = h, R.parameterRange[0] = V) : (R.endVertex = h, R.parameterRange[1] = V);for (var C = 0; C < R.adjacent.length; C++) {var b = R.adjacent[C].face;b.leftmostEdge !== m && b.leftmostEdge !== E || (R.loopsCurveAligned = b.leftmostEdge.loopsCurveAligned, b.leftmostEdge = R), (b.leftmostVertex === d[0] || void 0 !== d[1] && b.leftmostVertex === d[1]) && (b.leftmostVertex = h);}}var L = h.adjacentEdges.indexOf(E);Array.prototype.splice.apply(h.adjacentEdges, [L, 1].concat(x));var O = h.adjacentEdges.length,S = [(0, o.modulus)(L - 1, O), L, L + 1, (L + 2) % O];for (_ = 0; _ < S.length; _++) {var M = h.adjacentEdges[S[_]];this._assignAdjacentEdgesToSegment(M);}}this._intersectionVertices = P.default.difference(this._intersectionVertices, d), r = P.default.difference(r, d), this._edgeSegments = P.default.difference(this._edgeSegments, c), t++;}}if (t > 0) {for (var w = 0; w < this._intersectionVertices.length; w++) {this._intersectionVertices[w].index = w;}for (w = 0; w < this._edgeSegments.length; w++) {this._edgeSegments[w].index = w;}}var N = P.default.keys(e);for (w = 0; w < N.length; w++) {var F = N[w],I = [];for (f = 0; f < this._edgeSegments.length; f++) {for ((D = this._edgeSegments[f]).originalEdge.getGuid() === F && I.push([D, D.parameterRange[0]]), _ = 0; _ < D.coincidentRanges.length; _++) {D.coincidentRanges[_].originalEdge.getGuid() === F && I.push([D, D.coincidentRanges[_].parameterRange[0]]);}}for (I.sort(function (e, t) {return e[1] - t[1];}), f = 0; f < I.length; f++) {var D;for ((D = I[f][0]).originalEdge.getGuid() === F && (D.localGuid = this._createGUIDfromEdgeAndLocalID(D.originalEdge, f + 1)), _ = 0; _ < D.coincidentRanges.length; _++) {D.coincidentRanges[_].originalEdge.getGuid() === F && (D.coincidentRanges[_].localGuid = this._createGUIDfromEdgeAndLocalID(D.coincidentRanges[_].originalEdge, f + 1));}}}}, V.prototype._removeTemporaryVertices = function () {for (var e = 0, t = 0; t < this._intersectionVertices.length; t++) {var r = this._intersectionVertices[t];if (r.temporary && 2 === r.adjacentEdges.length && r.adjacentEdges[0].originalEdge === r.adjacentEdges[1].originalEdge && r.adjacentEdges[0] !== r.adjacentEdges[1]) {var n, o;r.adjacentEdges[0].endVertex === r ? (n = r.adjacentEdges[0], o = r.adjacentEdges[1]) : (n = r.adjacentEdges[1], o = r.adjacentEdges[0]), R.ConsoleUtils.assert(n.adjacent[this.SIDE.LEFT].face === o.adjacent[this.SIDE.LEFT].face), R.ConsoleUtils.assert(n.adjacent[this.SIDE.RIGHT].face === o.adjacent[this.SIDE.RIGHT].face);var s = n.parameterRange[1] - o.parameterRange[0],a = (n.originalEdge.isReversed() ? -1 : 1) * n.parameterRange[0],c = i.KERNEL_TOLERANCE / n.originalEdge.getCurve().tangentLength(a);if (n.originalEdge.getCurve().isPeriodic() && Math.abs(s - n.originalEdge.getCurve().getPeriod()) < c) n.parameterRange[1] = o.parameterRange[1] + s;else {if (Math.abs(s) > c) continue;n.parameterRange[1] = o.parameterRange[1];}n.endVertex = o.endVertex, n.adjacent[this.SIDE.LEFT].nextEdge = o.adjacent[this.SIDE.LEFT].nextEdge, n.adjacent[this.SIDE.RIGHT].nextEdge = o.adjacent[this.SIDE.RIGHT].nextEdge, n.adjacent[this.SIDE.LEFT].prevEdge === o && (n.adjacent[this.SIDE.LEFT].prevEdge = n), n.adjacent[this.SIDE.RIGHT].prevEdge === o && (n.adjacent[this.SIDE.RIGHT].prevEdge = n);var u = n.adjacent[this.SIDE.LEFT].nextEdge;u.adjacent[this.SIDE.LEFT].prevEdge === o && (u.adjacent[this.SIDE.LEFT].prevEdge = n), u.adjacent[this.SIDE.LEFT].nextEdge === o && (u.adjacent[this.SIDE.LEFT].nextEdge = n), u.adjacent[this.SIDE.RIGHT].prevEdge === o && (u.adjacent[this.SIDE.RIGHT].prevEdge = n), u.adjacent[this.SIDE.RIGHT].nextEdge === o && (u.adjacent[this.SIDE.RIGHT].nextEdge = n);var l = n.adjacent[this.SIDE.RIGHT].nextEdge;l.adjacent[this.SIDE.LEFT].prevEdge === o && (l.adjacent[this.SIDE.LEFT].prevEdge = n), l.adjacent[this.SIDE.LEFT].nextEdge === o && (l.adjacent[this.SIDE.LEFT].nextEdge = n), l.adjacent[this.SIDE.RIGHT].prevEdge === o && (l.adjacent[this.SIDE.RIGHT].prevEdge = n), l.adjacent[this.SIDE.RIGHT].nextEdge === o && (l.adjacent[this.SIDE.RIGHT].nextEdge = n), o.adjacent[this.SIDE.LEFT].face.leftmostEdge === o && (o.adjacent[this.SIDE.LEFT].face.leftmostEdge = n), o.adjacent[this.SIDE.RIGHT].face.leftmostEdge === o && (o.adjacent[this.SIDE.RIGHT].face.leftmostEdge = n), void 0 === n.loopsCurveAligned && (n.loopsCurveAligned = o.loopsCurveAligned), (0, v.hashCombine4xUint32)(n.localGuid, o.localGuid, n.localGuid);var h = n.endVertex.adjacentEdges.indexOf(o);n.endVertex.adjacentEdges[h] = n, this._intersectionVertices.splice(t, 1), this._edgeSegments.splice(o.index - e, 1), t--, e++;} else this._intersectionVertices[t].index -= e;}for (t = 0; t < this._edgeSegments.length; t++) {this._edgeSegments[t].index = t;}}, V.prototype._updateVertexGuidLists = function () {for (var e = 0; e < this._intersectionVertices.length; e++) {var t = this._intersectionVertices[e];if (t.vertices.length > 0) for (var r = 0; r < t.vertices.length; r++) {t.guidList.push((0, v.guidToUint32x4)(t.vertices[r].getGuid()));} else {var n = {};for (r = 0; r < t.adjacentEdges.length; r++) {var o = t.adjacentEdges[r];if (!n[o.index]) {n[o.index] = !0, t.guidList.push(o.localGuid);for (var i = 0; i < o.coincidentRanges.length; i++) {t.guidList.push(o.coincidentRanges[i].localGuid);}}}}}}, V.prototype._assignLoops = function () {var e = this._workspace;e.edgesPerCell = [];for (var t = 0; t < this._cells.length; t++) {e.edgesPerCell[t] = [];}for (t = 0; t < this._edgeSegments.length; t++) {var r = this._edgeSegments[t],n = r.adjacent[this.SIDE.LEFT].face.index;n >= 0 && e.edgesPerCell[n].push(r);var o = r.adjacent[this.SIDE.RIGHT].face.index;o >= 0 && n !== o && e.edgesPerCell[o].push(r);}var i = [];for (t = 0; t < this._cells.length; t++) {var s = [];i[t] = s;for (var a = this._followLoopFromEdge(this._cells[t].leftmostEdge, this._cells[t], !1, !0), c = 0; c < a.loop.length; c++) {s[a.loop[c].index] = !0;}this._cells[t].loops.push(a.loop), this._cells[t].loopOrientations.push(a.orientations);}for (t = 0; t < this._cells.length; t++) {s = i[t];for (var u = 0; u < e.edgesPerCell[t].length; u++) {var l = e.edgesPerCell[t][u];if (l.adjacent[this.SIDE.LEFT].face !== l.adjacent[this.SIDE.RIGHT].face) {if (!0 !== s[l.index]) {for (a = this._followLoopFromEdge(l, this._cells[t], !0, !1), c = 0; c < a.loop.length; c++) {s[a.loop[c].index] = !0;}this._cells[t].loops.push(a.loop), this._cells[t].loopOrientations.push(a.orientations);}} else this._cells[t].dangling.push(l);}}}, V.prototype._updateSketchRegionTopology = function () {for (var e = this._workspace, t = P.default.keys(this._sketchRegionTopologies), r = 0; r < t.length; r++) {var n = t[r];this._sketchRegionTopologies[n].updated = !1, \"FaceID\" === this._sketchRegionTopologies[n].topology.tuid && this._sketchRegionTopologies[n].topology.removeAllEdges();}var o = {},s = {};for (r = 0; r < this._intersectionVertices.length; r++) {var a = this._addOrFindTopologySubcomponent(\"VertexID\", i.GEOMETRY_TYPES.POINT, this._intersectionVertices[r].guidList, s);a.setPoint(new h.Point(this._intersectionVertices[r].position)), a.setAssociatedEntities(P.default.clone(this._intersectionVertices[r].vertices));for (var c = 0; c < this._intersectionVertices[r].vertices.length; ++c) {var u = this._intersectionVertices[r].vertices[c].getGuid();R.ConsoleUtils.assert(!o[u], \"vertex should only map to one topology vertex\"), o[u] = a;}this._intersectionVertices[r].topologyVertex = a;}for (r = 0; r < this._edgeSegments.length; r++) {var l = this._edgeSegments[r],p = [l.localGuid];for (c = 0; c < l.coincidentRanges.length; c++) {p.push(l.coincidentRanges[c].localGuid);}(V = this._addOrFindTopologySubcomponent(\"EdgeID\", l.originalEdge.getCurveType(), p, s)).setToEdgeSegment(l.originalEdge, l.parameterRange), V.setStartVertex(l.startVertex.topologyVertex), V.setEndVertex(l.endVertex.topologyVertex);var f = [{ edge: l.originalEdge, range: P.default.clone(l.parameterRange), flipped: !1 }];for (c = 0; c < l.coincidentRanges.length; c++) {f.push({ edge: l.coincidentRanges[c].originalEdge, range: P.default.clone(l.coincidentRanges[c].parameterRange), flipped: l.coincidentRanges[c].flipped });}V.setAssociatedEdges(f), l.topologyEdge = V;}for (r = 0; r < this._cells.length; r++) {var _ = this._cells[r];for (p = [], c = 0; c < e.edgesPerCell[r].length; c++) {p.push((0, v.guidToUint32x4)(e.edgesPerCell[r][c].topologyEdge.getGuid()));}var y = this._addOrFindTopologySubcomponent(\"FaceID\", i.GEOMETRY_TYPES.PLANE, p, s);y.setSurface(this._planeGeometry);var m = [];for (c = 0; c < _.loops.length; c++) {var E = new d.Loop();E.setFace(y), m.push(E);for (var x = [], A = 0; A < _.loops[c].length; A++) {var V = _.loops[c][A].topologyEdge,T = new g.Coedge();T.setLoop(E), x.push(T), T.setEdge(V), T.setReversed(!_.loopOrientations[c][A]), V.getCoedge() ? V.getCoedge().getPartner() || (V.getCoedge().setPartner(T), T.setPartner(V.getCoedge())) : V.setCoedge(T), _.loops[c][A].topologyEdge.setIsDangling(!1);}E.setCoedges(x);}for (y.setLoops(m), this._faces.push(y), c = 0; c < _.dangling.length; c++) {y.addDanglingEdge(_.dangling[c].topologyEdge), _.dangling[c].topologyEdge.setIsDangling(!0);}}for (r = 0; r < t.length; r++) {this._sketchRegionTopologies[t[r]].updated || delete this._sketchRegionTopologies[t[r]];}}, V.prototype._followLoopFromEdge = function (e, t, r, n) {var o = [],i = [],s = e,a = [],c = e.adjacent[this.SIDE.LEFT].face === t ? this.SIDE.LEFT : this.SIDE.RIGHT,u = !!(s.loopsCurveAligned ^ c !== this.SIDE.LEFT),l = u ? e.startVertex : e.endVertex;do {if (s.adjacent[c].face !== t) {console.error(\"REGION: Adjacent edge face does not match cell! FIXME!\");break;}if (a[s.index]) {console.error(\"REGION: Malformed edges; walking edge lead us to despair\");break;}a[s.index] = !0, o.push(s), i.push(u);do {u ? (l = s.endVertex, s = s.adjacent[c].nextEdge) : (l = s.startVertex, s = s.adjacent[c].prevEdge), s.startVertex === s.endVertex ? c = s.adjacent[this.SIDE.LEFT].face === t ? this.SIDE.LEFT : this.SIDE.RIGHT : (c = s.startVertex === l ? this.SIDE.LEFT : this.SIDE.RIGHT, s.adjacent[this.SIDE.LEFT].face === s.adjacent[this.SIDE.RIGHT].face && (c = 1 - c, l = s.startVertex === l ? s.endVertex : s.startVertex)), u = c === this.SIDE.LEFT;} while (s.adjacent[this.SIDE.LEFT].face === s.adjacent[this.SIDE.RIGHT].face);n && void 0 === s.loopsCurveAligned && (s.loopsCurveAligned = !!(u ^ c !== this.SIDE.LEFT));} while (s !== e);return { loop: o, orientations: i };}, V.prototype._addNewRegionTopology = function (e) {switch (e.tuid) {case \"VertexID\":var t = new E.RegionTopologyVertex(new h.Point());return t.setGuid(e.guid), t;case \"EdgeID\":var r = void 0;switch (e.minortype) {case i.GEOMETRY_TYPES.LINE:r = new a.Line();break;case i.GEOMETRY_TYPES.CIRCLE:r = new c.Circle();break;case i.GEOMETRY_TYPES.ELLIPSE:r = new l.Ellipse();break;case i.GEOMETRY_TYPES.BCURVE:r = new u.BCurve();break;default:console.error(\"Unhandled curve type\");}var n = new E.RegionTopologyEdge(r);return n.setGuid(e.guid), n;case \"FaceID\":switch (r = void 0, e.minortype) {case i.GEOMETRY_TYPES.PLANE:r = new s.Plane();break;default:console.error(\"Unhandled surface type\");}var o = new E.RegionTopologyFace(r);return o.setGuid(e.guid), o;default:console.error(\"Unhandled topology type\");}}, V.prototype._addOrFindTopologySubcomponent = function (e, t, r, n) {var o = this._createNameFromGuidList(e, t, r, n);if (this._sketchRegionTopologies[o]) {var i = this._sketchRegionTopologies[o];return i.updated = !0, i.topology;}var s = this._addNewRegionTopology({ tuid: e, minortype: t, guid: o });return this._sketchRegionTopologies[o] = { topology: s, updated: !0 }, s;};var T = { VertexID: [1168004130, 3764602020, 2270554856, 1368826480], EdgeID: [2942887333, 1472546498, 2159971906, 413489693], FaceID: [2166479754, 2329626594, 2838556660, 1584616933] },C = {};C[i.GEOMETRY_TYPES.POINT] = [2299429810, 2248164535, 3202574069, 2684287321], C[i.GEOMETRY_TYPES.LINE] = [910992607, 3428993096, 3010390753, 2966835859], C[i.GEOMETRY_TYPES.CIRCLE] = [2229232555, 842549819, 2526558959, 4217038233], C[i.GEOMETRY_TYPES.PLANE] = [2122299449, 3667741317, 2812958731, 939246365], C[i.GEOMETRY_TYPES.BCURVE] = [420548527, 2703575863, 2792852189, 2595995847], C[i.GEOMETRY_TYPES.ELLIPSE] = [902753991, 1129557208, 9277753211, 1913737389];var b = function b(e, t) {var r = 2166136261;return t && (r = 16777619 * (r ^ t) >>> 0), 16777619 * (((r = 16777619 * (((r = 16777619 * (((r = 16777619 * ((r ^ 255 & e) >>> 0) >>> 0) ^ e >> 8 & 255) >>> 0) >>> 0) ^ e >> 16 & 255) >>> 0) >>> 0) ^ e >> 24 & 255) >>> 0) >>> 0;},L = function () {var e = new Uint32Array(4);return function (t) {return e[0] = t, e[1] = 16777619, e[2] = t, e[3] = t, (0, v.hashCombine4xUint32)(e, e);};}(),O = function O(e, t) {for (var r = 0; r < e.length; r++) {e[r] = (e[r] ^ t[r]) >>> 0;}};V.prototype._createNameFromGuidList = function (e, t, r, n) {var o = P.default.clone(T[e]),i = C[t];R.ConsoleUtils.assert(o && i, \"Unsupported tuid or minortype!\"), O(o, i);for (var s = 0; s < r.length; s++) {O(o, r[s]);}var a = (0, v.uint32x4ToGUID)(o);if (n[a]) {var c = ++n[a];return (r = P.default.clone(r)).push(L(b(c))), this._createNameFromGuidList(e, t, r, n);}return n[a] = 1, a;}, V.prototype._createGUIDfromEdgeAndLocalID = function (e, t) {var r = (0, v.guidToUint32x4)(e.getGuid()),n = L(b(t));return (0, v.hashCombine4xUint32)(r, n);}, V.prototype._findVertexIndex = function (e) {for (var t = 0; t < this._intersectionVertices.length; t++) {if (n.Vector3.distance(this._intersectionVertices[t].position, e) < i.KERNEL_TOLERANCE) return t;for (var r = 0; r < this._intersectionVertices[t].mergedPositions.length; r++) {if (n.Vector3.distance(this._intersectionVertices[t].mergedPositions[r], e) < i.KERNEL_TOLERANCE) return t;}}}, V.prototype._findVertexOnSweepLine = function (e) {for (var t = this._workspace, r = 0, n = t.sweepLineIntersections.length - 1; n >= r;) {if (r + 1 >= n) return r;var o = Math.floor((r + n) / 2);this._isVertexAboveEdgeSegment(t.sweepLineIntersections[o], e) ? r = o : n = o;}console.error(\"Error in binary search function!\");}, V.prototype._isVertexAboveEdgeSegment = function (e, t) {if (e === -1 / 0) return !0;if (e === 1 / 0) return !1;var r = e.originalEdge;switch (r.getCurveType()) {case i.GEOMETRY_TYPES.LINE:var o = r.getStartVertex().getPosition(),s = n.Vector3.createFloat64();n.Vector3.subtract(s, r.getEndVertex().getPosition(), o);var a = n.Vector3.createFloat64();return n.Vector3.subtract(a, t.position, o), (s[0] < 0 || 0 === s[0] && s[1] < 0) && n.Vector3.negate(s, s), a[1] * s[0] - a[0] * s[1] > 0;case i.GEOMETRY_TYPES.CIRCLE:var c = t.position[0] - r.getCurve().getCenter()[0],u = .5 * (e.parameterRange[0] + e.parameterRange[1]),l = r.getCurve().evaluateDtt(u)[1] > 0 ? -1 : 1;return Math.abs(c) > r.getCurve().getRadius() ? r.getCurve().getCenter()[1] < t.position[1] : r.getCurve().getCenter()[1] + l * Math.sqrt(r.getCurve().getRadius() * r.getCurve().getRadius() - c * c) < t.position[1];default:return this.getYvalueForX(e, t.position[0]) < t.position[1];}}, V.prototype._makeEdgeXMonotone = function (e, t) {var r = e.getCurve(),s = [];switch (e.getCurveType()) {case i.GEOMETRY_TYPES.LINE:break;case i.GEOMETRY_TYPES.CIRCLE:var a = r.evaluatePosition(0);n.Vector3.subtract(a, a, r.getCenter());var c = r.getNormal()[2] > 0 ? -1 : 1;s[0] = c * Math.atan2(a[1], a[0]), s[1] = s[0] - Math.PI;break;case i.GEOMETRY_TYPES.ELLIPSE:var u = r.getMajorAxis()[0] * r.getMajorRadius(),l = r.getMinorAxis()[0] * r.getMinorRadius();s[0] = Math.atan2(l, u), s[1] = s[0] - Math.PI;break;case i.GEOMETRY_TYPES.BCURVE:s = _.SplineCurveHelper.extremalParams(r, 0);break;default:console.warn(\"Unsupported edge type in sketch region op\");}for (var h = 0; h < s.length; h++) {var d = s[h];e.isReversed() && (d = -d), r.isPeriodicUnlimited() && (d = (0, o.adjustParameterToPeriodicRange)(d, e.getRange(), r.getPeriodUnlimited())), d >= e.t0() && d <= e.t1() && (t.push({ param: d, atVertex: null, temporary: !0 }), A.DebugUtils.level(\"region3D\") > 0 && A.DebugUtils.drawPoint3D(e.evaluatePosition(d), { color: 16711935, label: \"x monotonic\" }));}}, V.prototype.plotSegments = function (e, t) {var r = this._workspace;Debug.hold(\"on\"), Debug.clearFigure(), Debug.delayUpdates(!0);for (var o = 0; o < this._intersectionVertices.length; o++) {var i = Debug.plotColorForIndex(this._intersectionVertices[o].adjacentEdges.length);if (\"sweepLineState\" === e && (i = \"k\", this._intersectionVertices[o] === r.currentVertex && (i = \"g\"), this._intersectionVertices[o] === r.nextVertex && (i = \"b\")), Debug.plot([this._intersectionVertices[o].position], i + \"o\"), \"orderColored\" === e) for (var s = this._intersectionVertices[o], a = [], c = 0; c < s.adjacentEdges.length; c++) {i = Debug.plotColorForIndex(c);var u = s.adjacentEdges[c],l = P.default.clone(u.parameterRange);u.startVertex !== s || a[u.index] ? l[0] = .5 * (l[0] + l[1]) : l[1] = .5 * (l[0] + l[1]), a[u.index] = !0;var h = u.originalEdge.tessellate(l).positions;Debug.plot(h, i + \"-\");}}if (\"orderColored\" !== e) for (o = 0; o < this._edgeSegments.length; o++) {if (u = this._edgeSegments[o], \"coincidenceCount\" === e) {var d = u.coincidentRanges.length + 1;i = Debug.plotColorForIndex(d);} else i = Debug.plotColorForIndex(o);if (\"sweepLineState\" === e && (i = r.sweepLineIntersections.indexOf(u) > -1 ? \"r\" : \"k\"), t && t.highlightLoop && (i = P.default.contains(t.highlightLoop, u) ? \"R\" : \"k\"), h = u.originalEdge.tessellate(u.parameterRange).positions, \"regions\" === e) {var g = [],p = [];for (c = 0; c < h.length; c++) {if (c < h.length - 1) {var f = n.Vector3.createFloat64();n.Vector3.subtract(f, h[c + 1], h[c]);} else f = n.Vector3.createFloat64(), n.Vector3.subtract(f, h[c], h[c - 1]);n.Vector3.normalize(f, f), n.Vector3.scale(f, f, .05), n.Vector3.cross(f, [0, 0, 1], f);var v = n.Vector3.clone(h[c]);g.push(n.Vector3.add(v, v, f));var _ = n.Vector3.clone(h[c]);p.push(n.Vector3.subtract(_, _, f));}var y = u.adjacent[this.SIDE.LEFT].face.index;i = Debug.plotColorForIndex(y), Debug.plot(g, i + \"-\");var m = u.adjacent[this.SIDE.RIGHT].face.index;i = Debug.plotColorForIndex(m), Debug.plot(p, i + \"-\");} else Debug.plot(h, i + \"-\");}if (\"sweepLineState\" === e && r.sweepLinePosition) {var E = r.sweepLinePosition,x = void 0;for (o = 0; o < r.sweepLineIntersections.length; o++) {var R,A = r.sweepLineIntersections[o];void 0 !== (R = A === 1 / 0 ? 5 : A === -1 / 0 ? -5 : this.getYvalueForX(A, E)) && (Debug.plot([E], [R], \"y.\"), void 0 !== x && (i = Debug.plotColorForIndex(r.sweepLineRegions[o - 1].index), Debug.plot([E, E], [x, R], i + \"-\")), x = R);}}if (t && t.showOrientation) {h = [];var V = [],T = [];for (o = 0; o < this._edgeSegments.length; o++) {var C = !(void 0 === (u = this._edgeSegments[o]).loopsCurveAligned || !0 === u.loopsCurveAligned),b = C ? .05 : .95,L = u.parameterRange[0] * (1 - b) + u.parameterRange[1] * b,O = u.originalEdge.evaluatePosition(L);h.push(O);var S = t.arrowSize || .1,M = C ? -S : S;if (u.adjacent[this.SIDE.LEFT].face.index >= 0) {var w = u.originalEdge.evaluateDt(L);n.Vector3.normalize(w, w);var N = [O[0] - S * w[1], O[1] + S * w[0]];V.push(N), T.push([M * w[0], M * w[1]]);}if (u.adjacent[this.SIDE.RIGHT].face.index >= 0) {var F = u.parameterRange[0] * b + u.parameterRange[1] * (1 - b),I = u.originalEdge.evaluatePosition(F),D = u.originalEdge.evaluateDt(F);n.Vector3.normalize(D, D);var j = [I[0] + S * D[1], I[1] - S * D[0]];V.push(j), T.push([-M * D[0], -M * D[1]]);}}Debug.plot(h, \"k.\"), Debug.quiver(V, T, \"g\", \"c\");}Debug.delayUpdates(!1), Debug.equalAxis();}, V.prototype.plotEdgeSegment = function (e, t) {Debug.plotEdgeList([e.originalEdge], !1, t + \"-\", { ranges: [e.parameterRange] });}, V.prototype.plotEdgesAroundVertex = function (e, t) {Debug.plot([e.position], \"gx\");for (var r = 0; r < e.adjacentEdges.length; r++) {var n,o = e.adjacentEdges[r];console.log(r), n = o.startVertex === e ? [o.parameterRange[0], o.parameterRange[0] + t / o.originalEdge.getCurve().tangentLength(o.parameterRange[0])] : [o.parameterRange[1] - t / o.originalEdge.getCurve().tangentLength(o.parameterRange[0]), o.parameterRange[1]], Debug.plotEdgeList([o.originalEdge], !1, \"-\" + Debug.plotColorForIndex(r), { ranges: [n], showOrientation: !1, resolution: 1e4 });}}, V.prototype.getYvalueForX = function (e, t) {var r = e.parameterRange[0],n = e.parameterRange[1],o = e.originalEdge.evaluatePosition(r),s = e.originalEdge.evaluatePosition(n),a = o[0],c = s[0];if (a > c) {var u = r;r = n, n = u, u = a, a = c, c = u, u = o, o = s, s = u;}if (t <= a + i.KERNEL_TOLERANCE || t >= c - i.KERNEL_TOLERANCE) return Math.abs(t - a) <= i.KERNEL_TOLERANCE ? o[1] : Math.abs(t - c) <= i.KERNEL_TOLERANCE ? s[1] : void console.warn(\"Failure in getYvalueForX, in_x oustide segment range, returning undefined\");for (; c >= a;) {if (a + i.KERNEL_TOLERANCE >= c) return h[1];var l = (r + n) / 2,h = e.originalEdge.evaluatePosition(l);if (Math.abs(r - n) <= i.PARAMETER_SPACE_TOLERANCE) return R.ConsoleUtils.assert(!1, \"Could not converge to a solution for getYvalueForX\"), h[1];h[0] < t ? (a = h[0], r = l) : (c = h[0], n = l);}console.warn(\"Failure in getYvalueForX, returning undefined\");}, V.prototype._computeAngleAndPositionForEdge = function (e, t, r) {var o = t.adjacentEdges[e],i = o.startVertex === t,s = o.parameterRange[i ? 0 : 1];if (void 0 === r || !((s += (i ? 1 : -1) * r) < o.parameterRange[0] || s > o.parameterRange[1])) {var a = n.Vector3.createFloat64();return n.Vector3.normalize(a, o.originalEdge.evaluateDt(s)), i || n.Vector3.negate(a, a), { angle: Math.atan2(a[1], a[0]), position: o.originalEdge.evaluatePosition(s) };}}, V.prototype._computeEdgeDirectionAtVertex = function (e, t, r) {var o = t.adjacentEdges[e.index],i = o.startVertex === t,s = o.parameterRange[i ? 0 : 1],a = s + (i ? 1 : -1) * r / n.Vector3.length(o.originalEdge.evaluateDt(s)),c = o.originalEdge.evaluatePosition(a),u = n.Vector3.subtract(c, c, t.position);return Math.atan2(u[1], u[0]);}, V.prototype._prepareResult = function () {var e = new y.TopologyCloner();this._finalFaces = e.cloneFaces(this._faces), this._internalToFinalMap = e.getProgenitorMap(), this._progenitorMap = new m.ProgenitorMap();for (var t = e.getProgenitorMap().getAllNewTopology(), r = 0; r < t.length; r++) {var n = t[r],o = e.getProgenitorMap().getProgenitors(n)[0],s = void 0;n.getTopologyType() === i.TOPOLOGY_TYPES.FACE ? (s = new Set(), o.collectEdges().forEach(function (e) {e.getAssociatedEntities().forEach(function (e) {s.add(e);});}), s = Array.from(s)) : (n.getTopologyType() === i.TOPOLOGY_TYPES.EDGE || n.getTopologyType() === i.TOPOLOGY_TYPES.VERTEX) && (s = o.getAssociatedEntities()), s && this._progenitorMap.addEntry(n, s);}this._sketchSummary = { regionFaces: [], regionEdges: [], regionVertices: [], sketchEdges: {} };for (var a = P.default.keys(this._sketchRegionTopologies), c = 0; c < a.length; c++) {var u = this._sketchRegionTopologies[a[c]].topology;u instanceof E.RegionTopologyFace ? this._sketchSummary.regionFaces.push(u) : u instanceof E.RegionTopologyEdge ? this._sketchSummary.regionEdges.push(u) : u instanceof E.RegionTopologyVertex ? this._sketchSummary.regionVertices.push(u) : R.ConsoleUtils.assert(!1);}for (var l = 0; l < this._sketchEdges.length; l++) {var h = this._sketchEdges[l];this._sketchSummary.sketchEdges[h.getGuid()] = h;}}, V.prototype.getFaces = function () {return this._finalFaces;}, V.prototype.getRegionTopologyFaces = function () {return this._faces;}, V.prototype.getProgenitorMap = function () {return this._progenitorMap;}, V.prototype.createFaceRecipe = function (e) {var t = this._finalFaces.indexOf(e);if (t < 0) return \"\";var r = this._faces[t],n = (0, x.createRecipeFromRegionFace)(r, this._sketchSummary);return (0, x.serializeRegionFaceRecipe)(n);}, V.prototype.matchFaceRecipe = function (e) {for (var t = (0, x.deserializeRegionFaceRecipe)(e), r = (0, x.matchRegionFaceRecipe)(t, this._sketchSummary), n = [], o = 0; o < r.regions.length; o++) {var i = this._faces.indexOf(r.regions[o]);R.ConsoleUtils.assert(i >= 0), n.push(this._finalFaces[i]);}return n;}, V.prototype.createEdgeRecipe = function (e) {var t = this._internalToFinalMap.getProgenitors(e);if (!t || 1 !== t.length) return \"\";var r = (0, x.createRecipeFromRegionEdge)(t[0], this._sketchSummary);return (0, x.serializeRegionEdgeRecipe)(r);}, V.prototype.matchEdgeRecipe = function (e) {for (var t = (0, x.deserializeRegionEdgeRecipe)(e), r = (0, x.matchRegionEdgeRecipe)(t, this._sketchSummary), n = [], o = 0; o < r.edges.length; o++) {var i = this._internalToFinalMap.getDescendants(r.edges[o]);R.ConsoleUtils.assert(1 === i.length), n.push(i[0]);}return n;}, t.SketchRegionSolver = V;}, function (e, t, r) {\"use strict\";Object.defineProperty(t, \"__esModule\", { value: !0 }), t.computeCurveCurveIntersections = void 0;var n = r(1),o = r(0),i = r(6),s = r(7),a = r(20),c = r(16),u = r(72),l = r(36),h = r(3),d = r(110),g = o.KERNEL_TOLERANCE,p = function p(e, t, r, o) {var i = t,s = e.getRange();if (e.getCurve().isPeriodicUnlimited() && (i < s[0] - n.FLOAT64_TOLERANCE || i > s[1] + n.FLOAT64_TOLERANCE)) {var a = e.getCurve().getPeriodUnlimited();i = (0, h.foldNearTo)(i, .5 * (s[0] + s[1]), a);}var c = Math.abs(i - s[0]) < Math.abs(i - s[1]) ? 0 : 1,u = n.Vector3.length(e.evaluateDt(i));return Math.abs(i - s[c]) * u < r ? { param: s[c], atVertex: e.getVertex(c) } : i >= s[0] && i <= s[1] ? { param: i, atVertex: void 0 } : !e.isClosed() && o.distanceToPoint(e.getVertex(c).getPosition()) < r ? { param: s[c], atVertex: e.getVertex(c) } : void 0;},f = function f(e, t, r, o, i) {var s = p(e, t, i, r);if (s) {if (s.atVertex) {var a = r.getRange();e === r && (a = [o - .1 * (l = Math.abs(a[1] - a[0])), o + .1 * l]);var c = r.closestToPointParam(s.atVertex.getPosition(), a);n.Vector3.distance(r.evaluatePosition(c), s.atVertex.getPosition()) < i && (o = c);}var u = p(r, o, i, e);if (u) {var l;if (u.atVertex) a = e.getRange(), e === r && (a = [t - .1 * (l = Math.abs(a[1] - a[0])), t + .1 * l]), c = e.closestToPointParam(u.atVertex.getPosition(), a), n.Vector3.distance(e.evaluatePosition(c), u.atVertex.getPosition()) < i && (s = p(e, t = c, i, r));if (s) return { cutInfo: s, cutByInfo: u };}}},v = function v(e, t, r) {var n = [t - e.getRange()[0], t - e.getRange()[1]];if (n[0] >= r && n[1] <= -r) return { param: t, atVertex: void 0 };var o = Math.abs(n[0]) < Math.abs(n[1]) ? 0 : 1;return Math.abs(n[o]) < r ? { param: e.getRange()[o], atVertex: e.getVertex(o) } : void 0;},_ = function _(e, t, r, i, s, a, c) {var u = e.getCurve().getPeriodUnlimited(),l = t.getCurve().getPeriodUnlimited(),d = [r[0], r[2]],g = [i[0], i[2]],f = [s / n.Vector3.length(e.evaluateDt(d[0])), s / n.Vector3.length(e.evaluateDt(d[1]))],v = [s / n.Vector3.length(t.evaluateDt(g[0])), s / n.Vector3.length(t.evaluateDt(g[1]))];if (((0, h.isParameterWithinPeriodicRange)(d[0], e.getRange(), u, f[0]) || (0, h.isParameterWithinPeriodicRange)(d[1], e.getRange(), u, f[1])) && ((0, h.isParameterWithinPeriodicRange)(g[0], t.getRange(), l, v[0]) || (0, h.isParameterWithinPeriodicRange)(g[1], t.getRange(), l, v[1]))) {for (var _ = 0; _ < 2; _++) {d[_] = (0, h.adjustParameterToPeriodicRange)(d[_], e.getRange(), u, !1, !0), g[_] = (0, h.adjustParameterToPeriodicRange)(g[_], t.getRange(), l, !1, !0);var y = (0, h.periodicDifference)(d[_], e.getRange()[0], u) < 3e-15 || (0, h.periodicDifference)(d[_], e.getRange()[1], u) < 3e-15,m = (0, h.periodicDifference)(g[_], t.getRange()[0], l) < 3e-15 || (0, h.periodicDifference)(g[_], t.getRange()[1], l) < 3e-15;if (d[_] - e.getRange()[0] < f[_] && (d[_] = e.getRange()[0], y = !0), e.getRange()[1] - d[_] < f[_] && (d[_] = e.getRange()[1], y = !0), g[_] - t.getRange()[0] < v[_] && (g[_] = t.getRange()[0], m = !0), t.getRange()[1] - g[_] < v[_] && (g[_] = t.getRange()[1], m = !0), y) {var E = t.closestToPointParam(e.evaluatePosition(d[_]));g[_] = (0, h.adjustParameterToPeriodicRange)(E, t.getRange(), l, !1, !0);}if (m) {var x = e.closestToPointParam(t.evaluatePosition(g[_]));d[_] = (0, h.adjustParameterToPeriodicRange)(x, e.getRange(), u, !1, !0), ((0, h.periodicDifference)(d[_], e.getRange()[0], u) < 3e-15 || (0, h.periodicDifference)(d[_], e.getRange()[1], u) < 3e-15) && (E = t.closestToPointParam(e.evaluatePosition(d[_])), g[_] = (0, h.adjustParameterToPeriodicRange)(E, t.getRange(), l, !1, !0));}}var R, A;if ((0, h.periodicDifference)(d[0], d[1], u) < Math.min(f[0], f[1]) && (0, h.periodicDifference)(g[0], g[1], l) < Math.min(v[0], v[1])) R = p(e, .5 * (d[0] + d[1]), s, e), A = p(t, .5 * (g[0] + g[1]), s, t);else for (R = p(e, r[1], s, e), A = p(t, i[1], s, t), _ = 0; _ < 2; _++) {if (!((0, h.periodicDifference)(d[_], R.param, u) < f[_] && (0, h.periodicDifference)(g[_], A.param, l) < v[_])) {var P,V,T = p(e, d[_], s, e),C = p(t, g[_], s, t);if (isFinite(u)) {var b = (0, h.getShortestParametricRange)(T.param, R.param, u);P = (0, h.periodicDifference)(R.param, b[0], u) <= o.KERNEL_ANGULAR_TOLERANCE;} else P = T.param > R.param;isFinite(l) ? (b = (0, h.getShortestParametricRange)(C.param, A.param, l), V = (0, h.periodicDifference)(A.param, b[0], l) <= o.KERNEL_ANGULAR_TOLERANCE) : V = C.param > A.param, a.push({ rangeInfo: P ? [R, T] : [T, R], rangeByInfo: V ? [A, C] : [C, A] });}}c && c.push({ firstParam: R.param, secondParam: A.param });}},y = function y(e, t, r, o) {var i = e.getRange(),s = e.evaluatePosition(0),a = e.evaluateDt(0),c = n.Vector2.length(a),u = t.getRange(),l = t.evaluatePosition(0),d = t.evaluateDt(0),g = n.Vector2.length(d),p = [a[1] / c, -a[0] / c],_ = t.evaluatePosition(u[0]);n.Vector2.subtract(_, _, s);var y = n.Vector2.dot(_, p),m = t.evaluatePosition(u[1]);n.Vector2.subtract(m, m, s);var E = n.Vector2.dot(m, p);if (Math.abs(y) <= o && Math.abs(E) <= o) {var x = n.Vector2.dot(_, a) / (c * c),R = n.Vector2.dot(m, a) / (c * c),A = [Math.min(x, R), Math.max(x, R)],P = o / c,V = o / g;if (A[1] < i[0] - P || A[0] > i[1] + P) return [];var T = [Math.max(i[0], A[0]), Math.min(i[1], A[1])];if (T[1] - T[0] < P) {var C = .5 * (T[0] + T[1]),b = Math.abs(R - x) > n.FLOAT64_TOLERANCE ? u[0] + (u[1] - u[0]) * (C - x) / (R - x) : .5 * (u[0] + u[1]);return [{ cutInfo: v(e, C, P), cutByInfo: v(t, b, V) }];}if (!r) return [];var L = u[0] + (u[1] - u[0]) * (T[0] - x) / (R - x),O = u[0] + (u[1] - u[0]) * (T[1] - x) / (R - x);return [{ rangeInfo: [v(e, T[0], P), v(e, T[1], P)], rangeByInfo: [v(t, Math.min(L, O), V), v(t, Math.max(L, O), V)] }];}if (y > o && E > o || y < -o && E < -o) return [];var S = [[a[0], -d[0], l[0] - s[0]], [a[1], -d[1], l[1] - s[1]]],M = (0, h.solveTwoEquationsTwoVariables)(S);if (M) {var w = f(e, M[0], t, M[1], o);if (w) return [w];}return [];},m = function m(e, t, r) {var o,i = t.getCenter(),s = e.closestToPointParam(i, []),a = e.evaluatePosition(s),c = n.Vector3.squaredDistance(a, i),u = [],l = t.getRadius(),h = l - Math.sqrt(c);if (h < -r) ;else if (h < r) o = t.closestToPointParam(a, []), u.push({ lineParam: s, circleParam: o });else for (var d = Math.sqrt(l * l - c) / n.Vector3.length(e.evaluateDt(0)), g = 0; g < 2; ++g) {var p = s + (0 === g ? -1 : 1) * d,f = e.evaluatePosition(p);o = t.closestToPointParam(f, []), u.push({ lineParam: p, circleParam: o });}return u;},E = function E(e, t, r, n, o, i) {var s = [r[0] + t * n[0] - e * n[1], r[1] + t * n[1] + e * n[0], 0];return { firstParam: o.closestToPointParam(s, [0, 2 * Math.PI]), secondParam: i.closestToPointParam(s, [0, 2 * Math.PI]) };},x = function x(e, t) {t || (t = o.KERNEL_TOLERANCE);for (var r = [], n = !1, i = [], s = [], a = 0; a < e.length; ++a) {e[a].hasOwnProperty(\"rangeInfo\") ? (!1 === n ? (i = e[a].rangeInfo, s = e[a].rangeByInfo) : Math.abs(i[1].param - e[a].rangeInfo[0].param) < t && Math.abs(s[1].param - e[a].rangeByInfo[0].param) < t ? (i[1] = e[a].rangeInfo[1], s[1] = e[a].rangeByInfo[1]) : (r.push({ rangeInfo: i, rangeByInfo: s }), i = e[a].rangeInfo, s = e[a].rangeByInfo), n = !0) : e[a].hasOwnProperty(\"cutInfo\") ? (n && r.push({ rangeInfo: i, rangeByInfo: s }), r.push(e[a]), n = !1) : console.warn(\"unknown segment type in intersection code\");}return n && r.push({ rangeInfo: i, rangeByInfo: s }), r;},R = function R(e, t, r, o, i) {var s = r.getControlPoints(),a = r.getKnotVector(),c = e.getBoundingBox(),u = [];if (!r.getBoundingBox([a[0], a[a.length - 1]]).intersectsWithTolerance(c, i)) return u;var d = new Float64Array(s.length),g = s.length / 3 - 1,y = n.Vector2.createFloat64FromValues(e.getStartVertex().getPosition()[0], e.getStartVertex().getPosition()[1]),m = n.Vector3.createFloat64();n.Vector3.sub(m, e.getEndVertex().getPosition(), e.getStartVertex().getPosition()), n.Vector3.normalize(m, m);for (var E = n.Vector2.createFloat64FromValues(m[0], m[1]), x = n.Vector2.createFloat64(), R = !0, A = 0; A <= g; ++A) {x[0] = s[3 * A + 0], x[1] = s[3 * A + 1], d[3 * A + 0] = A / g, d[3 * A + 1] = (0, h.signedDistanceTo2DLine)(y, E, x), Math.abs(d[3 * A + 1]) > i && (R = !1), d[3 * A + 2] = 0;}if (R) return o ? u = function (e, t, r, o, i) {var s = o.length / 3 - 1,a = n.Vector3.createFloat64FromValues(o[0], o[1], o[2]),c = e.closestToPointParam(a),u = n.Vector3.createFloat64FromValues(o[3 * s + 0], o[3 * s + 1], o[3 * s + 2]),l = e.closestToPointParam(u),h = [v(e, c, r), v(e, l, r)];if (h[0].param > h[1].param) {var d = h[0];h[0] = h[1], h[1] = d;}var g = i[0],f = i[i.length - 1];if (t.isReversed()) {var _ = g;g = -f, f = -_;}var y = [p(t, g, r, e), p(t, f, r, e)];return h[0] && h[1] && y[0] && y[1] ? [{ rangeInfo: h, rangeByInfo: y }] : (console.warn(\"Error in intersection computation.\"), []);}(e, t, i, s, a) : [];var P = new Float64Array(3),V = [];return function (e, t, r, n, o, i, s, a, c) {var u,l = [],h = n.length / 3 - 1;3 === i ? (s[0] > s[1] && (u = s[0], s[0] = s[1], s[1] = u), s[1] > s[2] && (u = s[1], s[1] = s[2], s[2] = u), s[0] > s[1] && (u = s[0], s[0] = s[1], s[1] = u)) : 2 === i && s[0] > s[1] && (u = s[0], s[0] = s[1], s[1] = u);var d = [!1, !1, !1],g = o[o.length - 1] - o[0],v = t.getCurve().tangentLength(o[0]) * g;Math.abs(n[1]) < r && (0 === i || s[0] > r / v) && (i++, s[2] = s[1], s[1] = s[0], s[0] = 0, d[0] = !0);var y = t.getCurve().tangentLength(o[o.length - 1]) * g;Math.abs(n[3 * h + 1]) < r && (0 === i || 1 - s[i - 1] > r / y) && (s[i] = 1, d[i] = !0, i++);for (var m = e.isReversed() ? -1 : 1, E = t.isReversed() ? -1 : 1, x = 0, R = 0; R < i + 1; ++R) {var A = !1;if (R !== i) {var P = s[R];s[R] = o[0] + (o[o.length - 1] - o[0]) * s[R];var V = t.getCurve().evaluatePosition(s[R]),T = e.getCurve().closestToPointParam(V, []),C = f(e, T * m, t, s[R] * E, r);C && (C.cutInfo.virtualIntersection = d[R], C.cutByInfo.virtualIntersection = d[R], l.push(C));} else P = o[o.length - 1], A = Math.abs(n[3 * h + 1]) > r;if (0 === R && P > 0 && Math.abs(n[0]) > r && (A = !0), c) {var b = void 0;if (a.length > 0 && a[0][0] >= x && a[0][0] <= P && (b = a[0]), a.length > 1 && a[1][0] >= x && a[1][0] <= P && (b = a[1]), void 0 !== b && Math.abs(b[1]) < r && !A) {var L = [o[0] + (o[o.length - 1] - o[0]) * x, o[0] + (o[o.length - 1] - o[0]) * P],O = [e.getCurve().closestToPointParam(t.getCurve().evaluatePosition(L[0]), []), e.getCurve().closestToPointParam(t.getCurve().evaluatePosition(L[1]), [])];if (Math.abs(O[0] - O[1]) > r) {var S = [p(e, O[0] * m, r, t), p(e, O[1] * m, r, t)],M = [p(t, L[0] * E, r, e), p(t, L[1] * E, r, e)];if (S[0] && S[1] && M[0] && M[1]) {var w = o[0] + (o[o.length - 1] - o[0]) * b[0];w !== L[0] && w !== L[1] || (w = .5 * (L[0] + L[1]));var N = e.getCurve().closestToPointParam(t.getCurve().evaluatePosition(w), []);_(e, t, [O[0] * m, N * m, O[1] * m], [L[0] * E, w * E, L[1] * E], r, l);var F = { cutInfo: p(e, N * m, r, e), cutByInfo: p(t, w * E, r, e) };F.cutInfo.virtualIntersection = !0, F.cutByInfo.virtualIntersection = !0, l.push(F);}}}}x = P;}return l;}(e, t, i, d, a, l.SplineCurveHelper.intersect_xAxis_NonRationalCubicBSpline_XYPlanar3D([0, 0, 0], d, P, V), P, V, o);},A = function A(e, t, r, n) {var o = e.getBoundingBox(),i = [];if (!t.getBoundingBox().intersectsWithTolerance(o, n)) return i;for (var s = t.getCurve().getBezierSegments(), a = s.length, c = 0; c < a; c++) {for (var u = R(e, t, s[c], r, n), l = 0; l < u.length; ++l) {i.push(u[l]);}}return x(i);},P = function P(e, t, r, o, i) {var a = r.getControlPoints(),c = r.getKnotVector(),l = e.getBoundingBox(),d = [];if (!r.getBoundingBox([c[0], c[c.length - 1]]).intersectsWithTolerance(l, i)) return d;for (var v = !0, _ = n.Vector2.createFloat64(), y = n.Vector2.createFloat64(), E = n.Vector2.createFloat64(), x = 0; x < a.length / 3 - 2 && v; ++x) {_[0] = a[3 * x + 0], _[1] = a[3 * x + 1], y[0] = a[3 * x + 3], y[1] = a[3 * x + 4], E[0] = a[3 * x + 6], E[1] = a[3 * x + 7], v = Math.abs((0, h.orient2D)(_, y, E)) < g;}if (v) {var R = new s.Line(),A = n.Vector3.createFloat64FromValues(a[0], a[1], a[2]),P = n.Vector3.createFloat64FromValues(a[a.length - 3], a[a.length - 2], a[a.length - 1]);R.setFromEndpoints(A, P);var V = n.Vector3.distance(P, A),T = m(R, e.getCurve(), i);for (x = 0; x < T.length; ++x) {if (T[x].lineParam >= 0 && T[x].lineParam <= V) {T[x].lineParam = t.getCurve().closestToPointParam(R.evaluatePosition(T[x].lineParam), []);var C = p(e, T[x].circleParam * (e.isReversed() ? -1 : 1), i, t),b = p(t, T[x].lineParam * (t.isReversed() ? -1 : 1), i, e);b && C && d.push({ cutInfo: C, cutByInfo: b });}}return d;}var L = n.Vector2.createFloat64(),O = n.Vector2.createFloat64(),S = n.Vector2.createFloat64(),M = n.Vector2.createFloat64();L[0] = -a[0] + 3 * a[3] - 3 * a[6] + a[9], L[1] = -a[1] + 3 * a[4] - 3 * a[7] + a[10], O[0] = 3 * a[0] - 6 * a[3] + 3 * a[6], O[1] = 3 * a[1] - 6 * a[4] + 3 * a[7], S[0] = -3 * a[0] + 3 * a[3], S[1] = -3 * a[1] + 3 * a[4], M[0] = a[0], M[1] = a[1];var w = e.getCurve().getCenter(),N = e.getCurve().getRadius() * e.getCurve().getRadius(),F = N,I = new Float64Array(7);I[0] = F * L[0] * L[0] + N * L[1] * L[1], I[1] = 2 * F * L[0] * O[0] + 2 * O[1] * N * L[1], I[2] = 2 * S[0] * F * L[0] + O[1] * O[1] * N + F * O[0] * O[0] + 2 * S[1] * N * L[1], I[3] = -2 * w[1] * N * L[1] + 2 * O[1] * S[1] * N + 2 * S[0] * F * O[0] - 2 * F * L[0] * w[0] + 2 * F * L[0] * M[0] + 2 * M[1] * N * L[1], I[4] = -2 * F * w[0] * O[0] + S[1] * S[1] * N - 2 * w[1] * O[1] * N + 2 * F * M[0] * O[0] + S[0] * S[0] * F + 2 * M[1] * O[1] * N, I[5] = -2 * w[1] * S[1] * N - 2 * S[0] * F * w[0] + 2 * S[0] * F * M[0] + 2 * M[1] * S[1] * N, I[6] = F * w[0] * w[0] - 2 * M[1] * w[1] * N - F * N + w[1] * w[1] * N + M[1] * M[1] * N - 2 * F * w[0] * M[0] + F * M[0] * M[0];var D = (0, u.getRealPolynomialRoots)(I);for (x = 0; x < D.length; ++x) {if (D[x] >= 0 && D[x] <= 1) {D[x] = c[0] + (c[c.length - 1] - c[0]) * D[x];var j = t.getCurve().evaluatePosition(D[x]),B = e.getCurve().closestToPointParam(j, []),U = f(e, B * (e.isReversed() ? -1 : 1), t, D[x] * (t.isReversed() ? -1 : 1), i);U && d.push(U);}}return d;},V = function V(e, t, r, n, o) {var i = e.getBoundingBox(),s = [];if (!t.getBoundingBox().intersectsWithTolerance(i, o)) return s;var a = 0;e.isClosed() && n && (a = 1);for (var c = t.getCurve().getBezierSegments(), u = c.length, l = 0; l < u; l++) {for (var h = P(e, t, c[l], 0, o), d = 0; d < h.length; ++d) {for (var g = -a; g <= a; ++g) {s.push({ cutInfo: { atVertex: h[d].cutInfo.atVertex, param: h[d].cutInfo.param + g * Math.PI * 2 }, cutByInfo: h[d].cutByInfo });}}}return x(s);},T = function T(e, t, r, l, d, v, _) {var m = r.getControlPoints(),E = r.getKnotVector(),x = l.getControlPoints(),A = l.getKnotVector(),P = r.getBoundingBox([E[0], E[E.length - 1]]),V = l.getBoundingBox([A[0], A[A.length - 1]]),T = e === t,C = !1,b = !1;T && Math.abs(m[m.length - 3] - x[0]) < v && Math.abs(m[x.length - 2] - x[1]) < v && Math.abs(m[x.length - 1] - x[2]) < v && (C = !0), T && Math.abs(m[0] - x[m.length - 3]) < v && Math.abs(m[1] - x[x.length - 2]) < v && Math.abs(m[2] - x[x.length - 1]) < v && (b = !0);var L = [];if (!P.intersectsWithTolerance(V, v)) return L;var O = !0,S = !0,M = n.Vector2.createFloat64(),w = n.Vector2.createFloat64(),N = n.Vector2.createFloat64();for (we = 0; we < m.length / 3 - 2 && O; ++we) {M[0] = m[3 * we + 0], M[1] = m[3 * we + 1], w[0] = m[3 * we + 3], w[1] = m[3 * we + 4], N[0] = m[3 * we + 6], N[1] = m[3 * we + 7], O = Math.abs((0, h.orient2D)(M, w, N)) < g;}for (we = 0; we < x.length / 3 - 2 && S; ++we) {M[0] = x[3 * we + 0], M[1] = x[3 * we + 1], w[0] = x[3 * we + 3], w[1] = x[3 * we + 4], N[0] = x[3 * we + 6], N[1] = x[3 * we + 7], S = Math.abs((0, h.orient2D)(M, w, N)) < g;}if (O || S) return function (e, t, r, u, l, h, d, g, v) {var _ = l.getControlPoints(),m = h.getControlPoints(),E = [];if (e && !t || !e && t) {var x,A,P = new s.Line();e ? (x = n.Vector3.createFloat64FromValues(_[0], _[1], _[2]), A = n.Vector3.createFloat64FromValues(_[_.length - 3], _[_.length - 2], _[_.length - 1])) : (x = n.Vector3.createFloat64FromValues(m[0], m[1], m[2]), A = n.Vector3.createFloat64FromValues(m[m.length - 3], m[m.length - 2], m[m.length - 1])), P.setFromEndpoints(x, A);var V = new a.Edge(P),T = n.Vector3.distance(A, x);V.setRange([0, T]);var C = new i.Point();C.setPosition(x[0], x[1], x[2]);var b = new i.Point();b.setPosition(A[0], A[1], A[2]);var L,O = new c.Vertex(C),S = new c.Vertex(b);V.setStartVertex(O), V.setEndVertex(S), ee = e ? R(V, u, h, d, g) : R(V, r, l, d, g);for (var M = 0; M < ee.length; ++M) {if (ee[M].hasOwnProperty(\"cutInfo\") && ee[M].hasOwnProperty(\"cutByInfo\")) {if (ee[M].cutInfo.param >= 0 && ee[M].cutInfo.param <= T && (e ? (ee[M].cutInfo.param = r.closestToPointParam(P.evaluatePosition(ee[M].cutInfo.param)), L = f(r, ee[M].cutInfo.param, u, ee[M].cutByInfo.param, g)) : (ee[M].cutInfo.param = u.closestToPointParam(P.evaluatePosition(ee[M].cutInfo.param)), L = f(r, ee[M].cutByInfo.param, u, ee[M].cutInfo.param, g)), L)) if (v) {var w = L.cutInfo.param,N = L.cutByInfo.param;(F = Math.abs(w - N) * n.Vector3.length(r.evaluateDt(w))) > o.KERNEL_TOLERANCE && !ee[M].cutInfo.virtualIntersection && E.push(L);} else E.push(L);} else if (ee[M].hasOwnProperty(\"rangeInfo\") && ee[M].hasOwnProperty(\"rangeByInfo\") && ee[M].rangeInfo[0].param >= 0 && ee[M].rangeInfo[0].param <= T && ee[M].rangeInfo[1].param >= 0 && ee[M].rangeInfo[1].param <= T) if (e ? (ee[M].rangeInfo[0].param = r.closestToPointParam(P.evaluatePosition(ee[M].rangeInfo[0].param)), ee[M].rangeInfo[1].param = r.closestToPointParam(P.evaluatePosition(ee[M].rangeInfo[1].param))) : (ee[M].rangeInfo[0].param = u.closestToPointParam(P.evaluatePosition(ee[M].rangeInfo[0].param)), ee[M].rangeInfo[1].param = u.closestToPointParam(P.evaluatePosition(ee[M].rangeInfo[1].param))), e ? (te = [p(r, ee[M].rangeInfo[0].param, g, u), p(r, ee[M].rangeInfo[1].param, g, u)], re = [p(u, ee[M].rangeByInfo[0].param, g, r), p(u, ee[M].rangeByInfo[1].param, g, r)]) : (te = [p(r, ee[M].rangeByInfo[0].param, g, u), p(r, ee[M].rangeByInfo[1].param, g, u)], re = [p(u, ee[M].rangeInfo[0].param, g, r), p(u, ee[M].rangeInfo[1].param, g, r)]), te[0] && te[1] && re[0] && re[1]) {var F = Math.abs(te[1].param - re[0].param) * n.Vector3.length(r.evaluateDt(te[1]));(!v || v && F > o.KERNEL_TOLERANCE) && E.push({ rangeInfo: te, rangeByInfo: re });} else console.warn(\"Error in intersection computation.\");}} else {var I = new s.Line(),D = new s.Line(),j = n.Vector3.createFloat64FromValues(_[0], _[1], _[2]),B = n.Vector3.createFloat64FromValues(_[_.length - 3], _[_.length - 2], _[_.length - 1]),U = n.Vector3.createFloat64FromValues(m[0], m[1], m[2]),k = n.Vector3.createFloat64FromValues(m[m.length - 3], m[m.length - 2], m[m.length - 1]);I.setFromEndpoints(j, B), D.setFromEndpoints(U, k);var G = new a.Edge(I),z = n.Vector3.distance(B, j),Y = new a.Edge(D),K = n.Vector3.distance(k, U);G.setRange([0, z]), Y.setRange([0, K]);var q = new i.Point();q.setPosition(j[0], j[1], j[2]);var W = new i.Point();W.setPosition(B[0], B[1], B[2]);var H = new i.Point();H.setPosition(U[0], U[1], U[2]);var X = new i.Point();X.setPosition(k[0], k[1], k[2]);var J = new c.Vertex(q),$ = new c.Vertex(W),Z = new c.Vertex(H),Q = new c.Vertex(X);G.setStartVertex(J), G.setEndVertex($), Y.setStartVertex(Z), Y.setEndVertex(Q);var ee = y(G, Y, d, g);for (M = 0; M < ee.length; ++M) {if (ee[M].hasOwnProperty(\"cutInfo\") && ee[M].hasOwnProperty(\"cutByInfo\")) ee[M].cutInfo.param >= 0 && ee[M].cutInfo.param <= z && ee[M].cutByInfo.param >= 0 && ee[M].cutByInfo.param <= K && (ee[M].cutInfo.param = r.closestToPointParam(I.evaluatePosition(ee[M].cutInfo.param)), ee[M].cutByInfo.param = u.closestToPointParam(D.evaluatePosition(ee[M].cutByInfo.param)), L = f(r, ee[M].cutInfo.param, u, ee[M].cutByInfo.param, g)) && (w = L.cutInfo.param, N = L.cutByInfo.param, F = Math.abs(w - N) * n.Vector3.length(r.evaluateDt(w)), (!v || v && F > o.KERNEL_TOLERANCE) && E.push(L));else if (ee[M].hasOwnProperty(\"rangeInfo\") && ee[M].hasOwnProperty(\"rangeByInfo\") && ee[M].rangeInfo[0].param >= 0 && ee[M].rangeInfo[0].param <= z && ee[M].rangeInfo[1].param >= 0 && ee[M].rangeInfo[1].param <= z && ee[M].rangeByInfo[0].param >= 0 && ee[M].rangeByInfo[0].param <= K && ee[M].rangeByInfo[1].param >= 0 && ee[M].rangeByInfo[1].param <= K) {ee[M].rangeInfo[0].param = r.closestToPointParam(I.evaluatePosition(ee[M].rangeInfo[0].param)), ee[M].rangeInfo[1].param = r.closestToPointParam(I.evaluatePosition(ee[M].rangeInfo[1].param)), ee[M].rangeByInfo[0].param = u.closestToPointParam(D.evaluatePosition(ee[M].rangeByInfo[0].param)), ee[M].rangeByInfo[1].param = u.closestToPointParam(D.evaluatePosition(ee[M].rangeByInfo[1].param));var te = [p(r, ee[M].rangeInfo[0].param, g, u), p(r, ee[M].rangeInfo[1].param, g, u)],re = [p(u, ee[M].rangeByInfo[0].param, g, r), p(u, ee[M].rangeByInfo[1].param, g, r)];te[0] && te[1] && re[0] && re[1] ? (F = Math.abs(te[1].param - re[0].param) * n.Vector3.length(r.evaluateDt(te[1])), (!v || v && F > o.KERNEL_TOLERANCE) && E.push({ rangeInfo: te, rangeByInfo: re })) : console.warn(\"Error in intersection computation.\");}}}return E;}(O, S, e, t, r, l, d, v, _);var F = -m[0] + 3 * m[3] - 3 * m[6] + m[9],I = 3 * m[0] - 6 * m[3] + 3 * m[6],D = -3 * m[0] + 3 * m[3],j = m[0],B = -m[1] + 3 * m[4] - 3 * m[7] + m[10],U = 3 * m[1] - 6 * m[4] + 3 * m[7],k = -3 * m[1] + 3 * m[4],G = m[1],z = j * j,Y = D * D,K = I * I,q = F * F,W = j * j * j,H = D * D * D,X = I * I * I,J = F * F * F,$ = G * G,Z = k * k,Q = U * U,ee = B * B,te = G * G * G,re = k * k * k,ne = U * U * U,oe = B * B * B,ie = -x[0] + 3 * x[3] - 3 * x[6] + x[9],se = 3 * x[0] - 6 * x[3] + 3 * x[6],ae = -3 * x[0] + 3 * x[3],ce = x[0],ue = -x[1] + 3 * x[4] - 3 * x[7] + x[10],le = 3 * x[1] - 6 * x[4] + 3 * x[7],he = -3 * x[1] + 3 * x[4],de = x[1],ge = ce * ce,pe = ce * ce * ce,fe = de * de,ve = de * de * de,_e = ae * ae,ye = ae * ae * ae,me = he * he,Ee = he * he * he,xe = se * se,Re = se * se * se,Ae = le * le,Pe = le * le * le,Ve = ie * ie,Te = ue * ue,Ce = new Float64Array(10),be = F * ue - B * ie;Ce[0] = be * be * be, Ce[1] = 3 * (F * le - B * se) * be * be, Ce[2] = 3 * (F * ue - B * ie) * (q * he * ue + q * Ae - F * B * ae * ue - 2 * F * B * se * le - F * B * ie * he + ee * ae * ie + ee * xe), Ce[3] = 3 * j * q * B * Te - 6 * j * F * ee * ie * ue + 3 * j * oe * Ve - 3 * D * I * F * B * Te + 3 * D * I * ee * ie * ue + 2 * D * q * U * Te - D * F * U * B * ie * ue - D * U * ee * Ve + X * B * Te - K * F * U * Te - 2 * K * U * B * ie * ue + I * q * k * Te + I * F * k * B * ie * ue + 2 * I * F * Q * ie * ue - 2 * I * k * ee * Ve + I * Q * B * Ve - 3 * J * G * Te + 3 * J * de * Te + 6 * J * he * le * ue + J * Pe + 6 * q * G * B * ie * ue - 3 * q * k * U * ie * ue - 3 * q * B * ce * Te - 6 * q * B * ae * le * ue - 6 * q * B * se * he * ue - 3 * q * B * se * Ae - 6 * q * B * ie * de * ue - 6 * q * B * ie * he * le - 3 * F * G * ee * Ve + 3 * F * k * U * B * Ve - F * ne * Ve + 6 * F * ee * ce * ie * ue + 6 * F * ee * ae * se * ue + 6 * F * ee * ae * ie * le + 3 * F * ee * xe * le + 6 * F * ee * se * ie * he + 3 * F * ee * Ve * de - 3 * oe * ce * Ve - 6 * oe * ae * se * ie - oe * Re, Ce[4] = 6 * j * q * B * le * ue - 6 * j * F * ee * se * ue - 6 * j * F * ee * ie * le + 6 * j * oe * se * ie - 6 * D * I * F * B * le * ue + 3 * D * I * ee * se * ue + 3 * D * I * ee * ie * le + 4 * D * q * U * le * ue - D * F * U * B * se * ue - D * F * U * B * ie * le - 2 * D * U * ee * se * ie + 2 * X * B * le * ue - 2 * K * F * U * le * ue - 2 * K * U * B * se * ue - 2 * K * U * B * ie * le + 2 * I * q * k * le * ue + I * F * k * B * se * ue + I * F * k * B * ie * le + 2 * I * F * Q * se * ue + 2 * I * F * Q * ie * le - 4 * I * k * ee * se * ie + 2 * I * Q * B * se * ie - 6 * J * G * le * ue + 6 * J * de * le * ue + 3 * J * me * ue + 3 * J * he * Ae + 6 * q * G * B * se * ue + 6 * q * G * B * ie * le - 3 * q * k * U * se * ue - 3 * q * k * U * ie * le - 6 * q * B * ce * le * ue - 6 * q * B * ae * he * ue - 3 * q * B * ae * Ae - 6 * q * B * se * de * ue - 6 * q * B * se * he * le - 6 * q * B * ie * de * le - 3 * q * B * ie * me - 6 * F * G * ee * se * ie + 6 * F * k * U * B * se * ie - 2 * F * ne * se * ie + 6 * F * ee * ce * se * ue + 6 * F * ee * ce * ie * le + 3 * F * ee * _e * ue + 6 * F * ee * ae * se * le + 6 * F * ee * ae * ie * he + 3 * F * ee * xe * he + 6 * F * ee * se * ie * de - 6 * oe * ce * se * ie - 3 * oe * _e * ie - 3 * oe * ae * xe, Ce[5] = 6 * j * q * B * he * ue + 3 * j * q * B * Ae - 6 * j * F * ee * ae * ue - 6 * j * F * ee * se * le - 6 * j * F * ee * ie * he + 6 * j * oe * ae * ie + 3 * j * oe * xe - 6 * D * I * F * B * he * ue - 3 * D * I * F * B * Ae + 3 * D * I * ee * ae * ue + 3 * D * I * ee * se * le + 3 * D * I * ee * ie * he + 4 * D * q * U * he * ue + 2 * D * q * U * Ae - D * F * U * B * ae * ue - D * F * U * B * se * le - D * F * U * B * ie * he - 2 * D * U * ee * ae * ie - D * U * ee * xe + 2 * X * B * he * ue + X * B * Ae - 2 * K * F * U * he * ue - K * F * U * Ae - 2 * K * U * B * ae * ue - 2 * K * U * B * se * le - 2 * K * U * B * ie * he + 2 * I * q * k * he * ue + I * q * k * Ae + I * F * k * B * ae * ue + I * F * k * B * se * le + I * F * k * B * ie * he + 2 * I * F * Q * ae * ue + 2 * I * F * Q * se * le + 2 * I * F * Q * ie * he - 4 * I * k * ee * ae * ie - 2 * I * k * ee * xe + 2 * I * Q * B * ae * ie + I * Q * B * xe - 6 * J * G * he * ue - 3 * J * G * Ae + 6 * J * de * he * ue + 3 * J * de * Ae + 3 * J * me * le + 6 * q * G * B * ae * ue + 6 * q * G * B * se * le + 6 * q * G * B * ie * he - 3 * q * k * U * ae * ue - 3 * q * k * U * se * le - 3 * q * k * U * ie * he - 6 * q * B * ce * he * ue - 3 * q * B * ce * Ae - 6 * q * B * ae * de * ue - 6 * q * B * ae * he * le - 6 * q * B * se * de * le - 3 * q * B * se * me - 6 * q * B * ie * de * he - 6 * F * G * ee * ae * ie - 3 * F * G * ee * xe + 6 * F * k * U * B * ae * ie + 3 * F * k * U * B * xe - 2 * F * ne * ae * ie - F * ne * xe + 6 * F * ee * ce * ae * ue + 6 * F * ee * ce * se * le + 6 * F * ee * ce * ie * he + 3 * F * ee * _e * le + 6 * F * ee * ae * se * he + 6 * F * ee * ae * ie * de + 3 * F * ee * xe * de - 6 * oe * ce * ae * ie - 3 * oe * ce * xe - 3 * oe * _e * se, Ce[6] = 3 * z * F * ee * ue - 3 * z * oe * ie - 3 * j * D * I * ee * ue + j * D * F * U * B * ue + 2 * j * D * U * ee * ie + 2 * j * K * U * B * ue - j * I * F * k * B * ue - 2 * j * I * F * Q * ue + 4 * j * I * k * ee * ie - 2 * j * I * Q * B * ie - 6 * j * q * G * B * ue + 3 * j * q * k * U * ue + 6 * j * q * B * de * ue + 6 * j * q * B * he * le + 6 * j * F * G * ee * ie - 6 * j * F * k * U * B * ie + 2 * j * F * ne * ie - 6 * j * F * ee * ce * ue - 6 * j * F * ee * ae * le - 6 * j * F * ee * se * he - 6 * j * F * ee * ie * de + 6 * j * oe * ce * ie + 6 * j * oe * ae * se + H * ee * ue - Y * I * U * B * ue - 2 * Y * F * k * B * ue + Y * F * Q * ue - Y * k * ee * ie + D * K * k * B * ue + 6 * D * I * F * G * B * ue - D * I * F * k * U * ue - 6 * D * I * F * B * de * ue - 6 * D * I * F * B * he * le - 3 * D * I * G * ee * ie + D * I * k * U * B * ie + 3 * D * I * ee * ce * ue + 3 * D * I * ee * ae * le + 3 * D * I * ee * se * he + 3 * D * I * ee * ie * de - 4 * D * q * G * U * ue + D * q * Z * ue + 4 * D * q * U * de * ue + 4 * D * q * U * he * le + D * F * G * U * B * ie + 2 * D * F * Z * B * ie - D * F * k * Q * ie - D * F * U * B * ce * ue - D * F * U * B * ae * le - D * F * U * B * se * he - D * F * U * B * ie * de - 2 * D * U * ee * ce * ie - 2 * D * U * ee * ae * se - 2 * X * G * B * ue + 2 * X * B * de * ue + 2 * X * B * he * le + 2 * K * F * G * U * ue - 2 * K * F * U * de * ue - 2 * K * F * U * he * le + 2 * K * G * U * B * ie - K * Z * B * ie - 2 * K * U * B * ce * ue - 2 * K * U * B * ae * le - 2 * K * U * B * se * he - 2 * K * U * B * ie * de - 2 * I * q * G * k * ue + 2 * I * q * k * de * ue + 2 * I * q * k * he * le - I * F * G * k * B * ie - 2 * I * F * G * Q * ie + I * F * Z * U * ie + I * F * k * B * ce * ue + I * F * k * B * ae * le + I * F * k * B * se * he + I * F * k * B * ie * de + 2 * I * F * Q * ce * ue + 2 * I * F * Q * ae * le + 2 * I * F * Q * se * he + 2 * I * F * Q * ie * de - 4 * I * k * ee * ce * ie - 4 * I * k * ee * ae * se + 2 * I * Q * B * ce * ie + 2 * I * Q * B * ae * se + 3 * J * $ * ue - 6 * J * G * de * ue - 6 * J * G * he * le + 3 * J * fe * ue + 6 * J * de * he * le + J * Ee - 3 * q * $ * B * ie + 3 * q * G * k * U * ie + 6 * q * G * B * ce * ue + 6 * q * G * B * ae * le + 6 * q * G * B * se * he + 6 * q * G * B * ie * de - q * re * ie - 3 * q * k * U * ce * ue - 3 * q * k * U * ae * le - 3 * q * k * U * se * he - 3 * q * k * U * ie * de - 6 * q * B * ce * de * ue - 6 * q * B * ce * he * le - 6 * q * B * ae * de * le - 3 * q * B * ae * me - 6 * q * B * se * de * he - 3 * q * B * ie * fe - 6 * F * G * ee * ce * ie - 6 * F * G * ee * ae * se + 6 * F * k * U * B * ce * ie + 6 * F * k * U * B * ae * se - 2 * F * ne * ce * ie - 2 * F * ne * ae * se + 3 * F * ee * ge * ue + 6 * F * ee * ce * ae * le + 6 * F * ee * ce * se * he + 6 * F * ee * ce * ie * de + 3 * F * ee * _e * he + 6 * F * ee * ae * se * de - 3 * oe * ge * ie - 6 * oe * ce * ae * se - oe * ye, Ce[7] = 3 * z * F * ee * le - 3 * z * oe * se - 3 * j * D * I * ee * le + j * D * F * U * B * le + 2 * j * D * U * ee * se + 2 * j * K * U * B * le - j * I * F * k * B * le - 2 * j * I * F * Q * le + 4 * j * I * k * ee * se - 2 * j * I * Q * B * se - 6 * j * q * G * B * le + 3 * j * q * k * U * le + 6 * j * q * B * de * le + 3 * j * q * B * me + 6 * j * F * G * ee * se - 6 * j * F * k * U * B * se + 2 * j * F * ne * se - 6 * j * F * ee * ce * le - 6 * j * F * ee * ae * he - 6 * j * F * ee * se * de + 6 * j * oe * ce * se + 3 * j * oe * _e + H * ee * le - Y * I * U * B * le - 2 * Y * F * k * B * le + Y * F * Q * le - Y * k * ee * se + D * K * k * B * le + 6 * D * I * F * G * B * le - D * I * F * k * U * le - 6 * D * I * F * B * de * le - 3 * D * I * F * B * me - 3 * D * I * G * ee * se + D * I * k * U * B * se + 3 * D * I * ee * ce * le + 3 * D * I * ee * ae * he + 3 * D * I * ee * se * de - 4 * D * q * G * U * le + D * q * Z * le + 4 * D * q * U * de * le + 2 * D * q * U * me + D * F * G * U * B * se + 2 * D * F * Z * B * se - D * F * k * Q * se - D * F * U * B * ce * le - D * F * U * B * ae * he - D * F * U * B * se * de - 2 * D * U * ee * ce * se - D * U * ee * _e - 2 * X * G * B * le + 2 * X * B * de * le + X * B * me + 2 * K * F * G * U * le - 2 * K * F * U * de * le - K * F * U * me + 2 * K * G * U * B * se - K * Z * B * se - 2 * K * U * B * ce * le - 2 * K * U * B * ae * he - 2 * K * U * B * se * de - 2 * I * q * G * k * le + 2 * I * q * k * de * le + I * q * k * me - I * F * G * k * B * se - 2 * I * F * G * Q * se + I * F * Z * U * se + I * F * k * B * ce * le + I * F * k * B * ae * he + I * F * k * B * se * de + 2 * I * F * Q * ce * le + 2 * I * F * Q * ae * he + 2 * I * F * Q * se * de - 4 * I * k * ee * ce * se - 2 * I * k * ee * _e + 2 * I * Q * B * ce * se + I * Q * B * _e + 3 * J * $ * le - 6 * J * G * de * le - 3 * J * G * me + 3 * J * fe * le + 3 * J * de * me - 3 * q * $ * B * se + 3 * q * G * k * U * se + 6 * q * G * B * ce * le + 6 * q * G * B * ae * he + 6 * q * G * B * se * de - q * re * se - 3 * q * k * U * ce * le - 3 * q * k * U * ae * he - 3 * q * k * U * se * de - 6 * q * B * ce * de * le - 3 * q * B * ce * me - 6 * q * B * ae * de * he - 3 * q * B * se * fe - 6 * F * G * ee * ce * se - 3 * F * G * ee * _e + 6 * F * k * U * B * ce * se + 3 * F * k * U * B * _e - 2 * F * ne * ce * se - F * ne * _e + 3 * F * ee * ge * le + 6 * F * ee * ce * ae * he + 6 * F * ee * ce * se * de + 3 * F * ee * _e * de - 3 * oe * ge * se - 3 * oe * ce * _e, Ce[8] = 3 * z * F * ee * he - 3 * z * oe * ae - 3 * j * D * I * ee * he + j * D * F * U * B * he + 2 * j * D * U * ee * ae + 2 * j * K * U * B * he - j * I * F * k * B * he - 2 * j * I * F * Q * he + 4 * j * I * k * ee * ae - 2 * j * I * Q * B * ae - 6 * j * q * G * B * he + 3 * j * q * k * U * he + 6 * j * q * B * de * he + 6 * j * F * G * ee * ae - 6 * j * F * k * U * B * ae + 2 * j * F * ne * ae - 6 * j * F * ee * ce * he - 6 * j * F * ee * ae * de + 6 * j * oe * ce * ae + H * ee * he - Y * I * U * B * he - 2 * Y * F * k * B * he + Y * F * Q * he - Y * k * ee * ae + D * K * k * B * he + 6 * D * I * F * G * B * he - D * I * F * k * U * he - 6 * D * I * F * B * de * he - 3 * D * I * G * ee * ae + D * I * k * U * B * ae + 3 * D * I * ee * ce * he + 3 * D * I * ee * ae * de - 4 * D * q * G * U * he + D * q * Z * he + 4 * D * q * U * de * he + D * F * G * U * B * ae + 2 * D * F * Z * B * ae - D * F * k * Q * ae - D * F * U * B * ce * he - D * F * U * B * ae * de - 2 * D * U * ee * ce * ae - 2 * X * G * B * he + 2 * X * B * de * he + 2 * K * F * G * U * he - 2 * K * F * U * de * he + 2 * K * G * U * B * ae - K * Z * B * ae - 2 * K * U * B * ce * he - 2 * K * U * B * ae * de - 2 * I * q * G * k * he + 2 * I * q * k * de * he - I * F * G * k * B * ae - 2 * I * F * G * Q * ae + I * F * Z * U * ae + I * F * k * B * ce * he + I * F * k * B * ae * de + 2 * I * F * Q * ce * he + 2 * I * F * Q * ae * de - 4 * I * k * ee * ce * ae + 2 * I * Q * B * ce * ae + 3 * J * $ * he - 6 * J * G * de * he + 3 * J * fe * he - 3 * q * $ * B * ae + 3 * q * G * k * U * ae + 6 * q * G * B * ce * he + 6 * q * G * B * ae * de - q * re * ae - 3 * q * k * U * ce * he - 3 * q * k * U * ae * de - 6 * q * B * ce * de * he - 3 * q * B * ae * fe - 6 * F * G * ee * ce * ae + 6 * F * k * U * B * ce * ae - 2 * F * ne * ce * ae + 3 * F * ee * ge * he + 6 * F * ee * ce * ae * de - 3 * oe * ge * ae, Ce[9] = W * oe - z * D * U * ee - 2 * z * I * k * ee + z * I * Q * B - 3 * z * F * G * ee + 3 * z * F * k * U * B - z * F * ne + 3 * z * F * ee * de - 3 * z * oe * ce + j * Y * k * ee + 3 * j * D * I * G * ee - j * D * I * k * U * B - 3 * j * D * I * ee * de - j * D * F * G * U * B - 2 * j * D * F * Z * B + j * D * F * k * Q + j * D * F * U * B * de + 2 * j * D * U * ee * ce - 2 * j * K * G * U * B + j * K * Z * B + 2 * j * K * U * B * de + j * I * F * G * k * B + 2 * j * I * F * G * Q - j * I * F * Z * U - j * I * F * k * B * de - 2 * j * I * F * Q * de + 4 * j * I * k * ee * ce - 2 * j * I * Q * B * ce + 3 * j * q * $ * B - 3 * j * q * G * k * U - 6 * j * q * G * B * de + j * q * re + 3 * j * q * k * U * de + 3 * j * q * B * fe + 6 * j * F * G * ee * ce - 6 * j * F * k * U * B * ce + 2 * j * F * ne * ce - 6 * j * F * ee * ce * de + 3 * j * oe * ge - H * G * ee + H * ee * de + Y * I * G * U * B - Y * I * U * B * de + 2 * Y * F * G * k * B - Y * F * G * Q - 2 * Y * F * k * B * de + Y * F * Q * de - Y * k * ee * ce - D * K * G * k * B + D * K * k * B * de - 3 * D * I * F * $ * B + D * I * F * G * k * U + 6 * D * I * F * G * B * de - D * I * F * k * U * de - 3 * D * I * F * B * fe - 3 * D * I * G * ee * ce + D * I * k * U * B * ce + 3 * D * I * ee * ce * de + 2 * D * q * $ * U - D * q * G * Z - 4 * D * q * G * U * de + D * q * Z * de + 2 * D * q * U * fe + D * F * G * U * B * ce + 2 * D * F * Z * B * ce - D * F * k * Q * ce - D * F * U * B * ce * de - D * U * ee * ge + X * $ * B - 2 * X * G * B * de + X * B * fe - K * F * $ * U + 2 * K * F * G * U * de - K * F * U * fe + 2 * K * G * U * B * ce - K * Z * B * ce - 2 * K * U * B * ce * de + I * q * $ * k - 2 * I * q * G * k * de + I * q * k * fe - I * F * G * k * B * ce - 2 * I * F * G * Q * ce + I * F * Z * U * ce + I * F * k * B * ce * de + 2 * I * F * Q * ce * de - 2 * I * k * ee * ge + I * Q * B * ge - J * te + 3 * J * $ * de - 3 * J * G * fe + J * ve - 3 * q * $ * B * ce + 3 * q * G * k * U * ce + 6 * q * G * B * ce * de - q * re * ce - 3 * q * k * U * ce * de - 3 * q * B * ce * fe - 3 * F * G * ee * ge + 3 * F * k * U * B * ge - F * ne * ge + 3 * F * ee * ge * de - oe * pe;var Le = (0, u.getRealPolynomialRoots)(Ce),Oe = l.getApproxParameterSpaceTolerance(),Se = -Oe,Me = 1 + Oe;C && (Se = Oe), b && (Me = 1 - Oe);for (var we = 0; we < Le.length; ++we) {if (Le[we] >= Se && Le[we] <= Me) {Le[we] < 0 ? Le[we] = 0 : Le[we] > 1 && (Le[we] = 1), Le[we] = A[0] + (A[A.length - 1] - A[0]) * Le[we];var Ne = t.getCurve().evaluatePosition(Le[we]);if (P.isPointInsideWithTolerance(Ne)) {var Fe = r.closestToPointParam(Ne, []);if (Fe >= E[0] && Fe <= E[E.length - 1]) {var Ie = e.getCurve().evaluatePosition(Fe);if (n.Vector3.squaredDistance(Ie, Ne) <= v * v) {var De = f(e, Fe * (e.isReversed() ? -1 : 1), t, Le[we] * (t.isReversed() ? -1 : 1), v);De && L.push(De);}}}}}return L;},C = function C(e, t, r, o) {var i = [],a = t.getControlPoints(),c = e.isReversed() ? -1 : 1,u = new s.Line(),h = n.Vector3.createFloat64FromValues(a[0], a[1], a[2]),d = n.Vector3.createFloat64FromValues(a[a.length - 3], a[a.length - 2], a[a.length - 1]);u.setFromEndpoints(h, d);var g = n.Vector3.distance(d, h),p = n.Vector3.createFloat64FromValues(a[3], a[4], a[5]),v = n.Vector3.createFloat64FromValues(a[6], a[7], a[8]);if (u.closestToPointParam(p, []) > 0 && u.closestToPointParam(p, []) < g && u.closestToPointParam(v, []) > 0 && u.closestToPointParam(v, []) < g) return i;var _,y = -a[0] + 3 * a[3] - 3 * a[6] + a[9],m = -a[1] + 3 * a[4] - 3 * a[7] + a[10],E = 3 * a[0] - 6 * a[3] + 3 * a[6],x = 3 * a[1] - 6 * a[4] + 3 * a[7],R = -3 * a[0] + 3 * a[3],A = -3 * a[1] + 3 * a[4],P = E / y,V = R / y,T = x / m,C = A / m;if (Math.abs(P - T) < o || Math.abs(C - V) < o) return i;var b = new Float64Array(4);if (Math.abs(y) < o && Math.abs(m) < o) return i;Math.abs(y) < o ? (_ = -R / E, P = T, V = C) : _ = Math.abs(m) < o ? -A / x : (C - V) / (P - T), b[0] = (-_ * _ * _ - P * _ * _ - V * _) / 2, b[1] = (3 * _ * _ + 2 * _ * P + 2 * V) / 2, b[2] = -1.5 * _, b[3] = 1;var L,O = new Float64Array(3);if (3 !== l.SplineCurveHelper.solve_cubic_uniqueRoots(b, O)) return i;if (O[1] < O[0] && (L = O[0], O[0] = O[1], O[1] = L), O[2] < O[0] && (L = O[0], O[0] = O[2], O[2] = L), O[2] < O[1] && (L = O[1], O[1] = O[2], O[2] = L), O[0] >= 0 && O[0] <= 1 && O[2] >= 0 && O[2] <= 1) {var S = t.getKnotVector();O[0] = S[0] + (S[S.length - 1] - S[0]) * O[0], O[2] = S[0] + (S[S.length - 1] - S[0]) * O[2];var M = f(e, O[0] * c, e, O[2] * c, o);M && i.push(M);}return i;};t.computeCurveCurveIntersections = function (e, t, r, i, s) {s = void 0 === s ? o.KERNEL_TOLERANCE : s;var a = e.getCurveType(),c = a === o.GEOMETRY_TYPES.CIRCLE,u = a === o.GEOMETRY_TYPES.LINE,l = a === o.GEOMETRY_TYPES.BCURVE && !e.getCurve().isRational() && 3 === e.getCurve().getDegree(),g = t.getCurveType(),v = g === o.GEOMETRY_TYPES.CIRCLE,R = g === o.GEOMETRY_TYPES.LINE,P = g === o.GEOMETRY_TYPES.BCURVE && !t.getCurve().isRational() && 3 === t.getCurve().getDegree();return u && v ? function (e, t, r) {for (var n = m(e.getCurve(), t.getCurve(), r), o = [], i = 0; i < n.length; ++i) {var s = (e.isReversed() ? -1 : 1) * n[i].lineParam,a = (t.isReversed() ? -1 : 1) * n[i].circleParam,c = f(e, s, t, a, r);c && o.push(c);}return o;}(e, t, s) : c && R ? function (e, t, r, n) {var o = m(t.getCurve(), e.getCurve(), n),i = [],s = 0;e.isClosed() && r && (s = 1);for (var a = 0; a < o.length; ++a) {var c = (e.isReversed() ? -1 : 1) * o[a].circleParam,u = (t.isReversed() ? -1 : 1) * o[a].lineParam,l = f(e, c, t, u, n);if (l) for (var h = -s; h <= s; ++h) {i.push({ cutInfo: { atVertex: l.cutInfo.atVertex, param: l.cutInfo.param + h * Math.PI * 2 }, cutByInfo: l.cutByInfo });}}return i;}(e, t, i, s) : u && R ? y(e, t, r, s) : c && v ? function (e, t, r, o, i) {var s = [],a = e.getCurve().getCenter(),c = e.getCurve().getRadius(),u = t.getCurve().getCenter(),l = t.getCurve().getRadius(),d = 2 * Math.PI,g = n.Vector3.createFloat64();n.Vector3.sub(g, u, a);var v = n.Vector3.length(g),y = Math.abs(c - l);if (v < y - i) return s;if (v + y < i) {var m = i / c;if (e.getRange()[1] - e.getRange()[0] > d - m && t.getRange()[1] - t.getRange()[0] > d - m) return s.push({ rangeInfo: [p(e, e.getRange()[0], i, t), p(e, e.getRange()[1], i, t)], rangeByInfo: [p(t, t.getRange()[0], i, e), p(t, t.getRange()[1], i, e)] }), s;var x = [],R = e.closestToPointParam(t.evaluatePosition(0), [0, d]),A = n.Vector3.dot(e.evaluateDt(R), t.evaluateDt(0)) < 0,P = e.getRange(),V = t.getRange();V = A ? [R - V[1], R - V[0]] : [R + V[0], R + V[1]];var T = (0, h.foldAbove)(V[0], P[0], d) - V[0];if ((V = [V[0] + T, V[1] + T])[0] < P[1] + m && x.push([Math.min(V[0], P[1]), Math.min(P[1], V[1])]), V[1] > P[0] + d - m && x.push([P[0], Math.max(P[0], Math.min(P[1], V[1] - d))]), P[1] - P[0] > d - m || V[1] - V[0] > d - m) for (var C = x.length - 1; C >= 0 && 1 !== x.length; --C) {x[C][1] - x[C][0] < m && x.splice(C, 1);}for (C = 0; C < x.length; ++C) {var b = x[C],L = A ? [R - b[1], R - b[0]] : [b[0] - R, b[1] - R],O = (0, h.foldAbove)(L[0], t.getRange()[0], d) - L[0];if (L = [L[0] + O, L[1] + O], b[1] - b[0] < m) {var S = .5 * (b[0] + b[1]),M = .5 * (L[0] + L[1]),w = p(e, S, i, t),N = p(t, M, i, e);w && N && s.push({ cutInfo: w, cutByInfo: N });} else {var F = [p(e, b[0], i, t), p(e, b[1], i, t)],I = [p(t, L[0], i, e), p(t, L[1], i, e)];F[0] && F[1] && I[0] && I[1] && s.push({ rangeInfo: F, rangeByInfo: I });}}return s;}var D = (c * c - l * l + v * v) / (2 * v),j = c * c - D * D,B = c - Math.abs(D),U = [],k = [];if (B < -i) ;else {var G = Math.sqrt(Math.max(0, j));if (n.Vector3.scale(g, g, 1 / v), G < 2 * i) U.push(E(0, D, a, g, e, t)), k.push(!1);else if (B < i) {if (k.push(!1), r) {k[k.length - 1] = !0;var z = E(0, D, a, g, e, t),Y = [E(G, D, a, g, e, t), E(-G, D, a, g, e, t)];_(e, t, [Y[0].firstParam, z.firstParam, Y[1].firstParam], [Y[0].secondParam, z.secondParam, Y[1].secondParam], i, s, U);} else U.push(E(0, D, a, g, e, t));} else U.push(E(G, D, a, g, e, t)), U.push(E(-G, D, a, g, e, t));}var K = 0;for (e.isClosed() && o && (K = 1), C = 0; C < U.length; ++C) {var q = f(e, U[C].firstParam, t, U[C].secondParam, i);if (q) for (var W = -K; W <= K; ++W) {s.push({ cutInfo: { atVertex: q.cutInfo.atVertex, param: q.cutInfo.param + W * Math.PI * 2 }, cutByInfo: q.cutByInfo }), k[C] && (s[s.length - 1].cutInfo.virtualIntersection = !0, s[s.length - 1].cutByInfo.virtualIntersection = !0);}}return s;}(e, t, r, i, s) : u && P ? A(e, t, r, s) : l && R ? function (e, t, r, n, o) {var i = A(t, e, r, o),s = [],a = 0,c = 0;n && e.getCurve().isPeriodicUnlimited() && (a = 1, c = e.getCurve().getPeriodUnlimited());for (var u = 0; u < i.length; ++u) {if (i[u].hasOwnProperty(\"cutInfo\") && i[u].hasOwnProperty(\"cutByInfo\")) for (var l = -a; l <= a; ++l) {s.push({ cutInfo: { atVertex: i[u].cutByInfo.atVertex, param: i[u].cutByInfo.param + l * c }, cutByInfo: i[u].cutInfo });} else i[u].hasOwnProperty(\"rangeInfo\") && i[u].hasOwnProperty(\"rangeByInfo\") && s.push({ rangeInfo: i[u].rangeByInfo, rangeByInfo: i[u].rangeInfo });}return s;}(e, t, r, i, s) : c && P ? V(e, t, 0, i, s) : l && v ? function (e, t, r, n, o) {var i = V(t, e, 0, !1, o),s = [],a = 0,c = 0;n && e.getCurve().isPeriodicUnlimited() && (a = 1, c = e.getCurve().getPeriodUnlimited());for (var u = 0; u < i.length; ++u) {if (i[u].hasOwnProperty(\"cutInfo\") && i[u].hasOwnProperty(\"cutByInfo\")) for (var l = -a; l <= a; ++l) {s.push({ cutInfo: { atVertex: i[u].cutByInfo.atVertex, param: i[u].cutByInfo.param + l * c }, cutByInfo: i[u].cutInfo });} else i[u].hasOwnProperty(\"rangeInfo\") && i[u].hasOwnProperty(\"rangeByInfo\") && s.push({ rangeInfo: i[u].rangeByInfo, rangeByInfo: i[u].rangeInfo });}return s;}(e, t, 0, i, s) : l && P ? function (e, t, r, n, o) {var i = e === t,s = e.getBoundingBox(),a = t.getBoundingBox(),c = [];if (!s.intersectsWithTolerance(a, o)) return c;var u,l,h,d,g = e.getCurve().getBezierSegments(),p = g.length,f = t.getCurve().getBezierSegments(),v = f.length,_ = [],y = 0,m = 0,E = 0;for (n && e.getCurve().isPeriodic() && e.isClosed() && (m = 1, E = e.getCurve().getPeriod()), u = 0; u < p; u++) {for (i && (y = u + 1), l = y; l < v; l++) {var R = i && l === u + 1;for (_ = T(e, t, g[u], f[l], r, o, R), h = 0; h < _.length; ++h) {for (d = -m; d <= m; ++d) {_[h].cutInfo && c.push({ cutInfo: { atVertex: _[h].cutInfo.atVertex, param: _[h].cutInfo.param + d * E }, cutByInfo: _[h].cutByInfo }), _[h].rangeInfo && c.push(_[h]);}}}}if (i) for (u = 0; u < p; ++u) {for (_ = C(e, g[u], 0, o), h = 0; h < _.length; ++h) {for (d = -m; d <= m; ++d) {_[h].cutInfo && c.push({ cutInfo: { atVertex: _[h].cutInfo.atVertex, param: _[h].cutInfo.param + d * E }, cutByInfo: _[h].cutByInfo }), _[h].rangeInfo && c.push(_[h]);}}}return x(c);}(e, t, r, i, s) : function (e, t, r, n, i) {var s = e.getBoundingBox(),a = t.getBoundingBox(),c = [];if (!s.intersectsWithTolerance(a, i)) return c;var u = e.isReversed(),l = t.isReversed(),h = e.getRange();u && (h = [-h[1], -h[0]]);var g = t.getRange();l && (g = [-g[1], -g[0]]), c = new d.CCI(e.getCurve(), h, t.getCurve(), g, o.KERNEL_TOLERANCE).intersect();for (var p = 0; p < c.length; ++p) {u && (c[p].cutInfo ? c[p].cutInfo.param *= -1 : c[p].rangeInfo && (c[p].rangeInfo = [c[p].rangeInfo[1], c[p].rangeInfo[0]], c[p].rangeInfo[0].param *= -1, c[p].rangeInfo[1].param *= -1)), l && (c[p].cutByInfo ? c[p].cutByInfo.param *= -1 : c[p].rangeByInfo && (c[p].rangeByInfo[0].param *= -1, c[p].rangeByInfo[1].param *= -1));}return c;}(e, t, 0, 0, s);};}, function (e, t, r) {\"use strict\";Object.defineProperty(t, \"__esModule\", { value: !0 }), t.edgesAreCoincident = t.curvesAreCoincident = void 0;var n = r(1),o = r(0),i = r(2),s = r(8);function a(e, t, r, o, i) {var s = e.evaluatePosition(t),a = r.closestToPointParam(s, o),c = r.evaluatePosition(a);return n.Vector3.squaredDistance(s, c) < i * i;}function c(e, t, r, o, i, s) {var c = [0, 0, 0];if (n.Vector3.isParallel(e, t.getNormal())) return !0;n.Vector3.add(c, t.getCenter(), e);var u = t.closestToPointParam(c, o);if (u > o[0] && u < o[1] && !a(t, u, r, i, s)) return !1;n.Vector3.sub(c, t.getCenter(), e);var l = t.closestToPointParam(c, o);return !(l > o[0] && l < o[1] && !a(t, l, r, i, s));}function u(e, t, r, n, o) {if (!a(e, .5 * (r[0] + r[1]), t, n, o)) return !1;var i = t.closestToPointParam(e.getCenter(), n);return !(i > n[0] && i < n[1] && !a(t, i, e, r, o));}var l = function l(e, t, r, _l, h) {r ? 0 === r.length && (r = e.getRangeUnlimited()) : r = e.getRange(), _l ? 0 === _l.length && (_l = t.getRangeUnlimited()) : _l = t.getRange(), h || (h = o.KERNEL_TOLERANCE);var d = e.getGeometryType(),g = t.getGeometryType();if (!(isFinite(r[0]) && isFinite(r[1]) && isFinite(_l[0]) && isFinite(_l[1]))) {var p = r[0] === Number.NEGATIVE_INFINITY && r[1] === Number.POSITIVE_INFINITY,f = _l[0] === Number.NEGATIVE_INFINITY && _l[1] === Number.POSITIVE_INFINITY;return !(!p || !f) && (i.ConsoleUtils.assert(d === o.GEOMETRY_TYPES.LINE && g === o.GEOMETRY_TYPES.LINE), function (e, t, r) {if (e === t) return !0;if (!a(e, 0, t, [], r) || !a(t, 0, e, [], r)) return !1;var o = e.evaluateDt(0);n.Vector3.normalize(o, o);var i = t.evaluateDt(0);return n.Vector3.normalize(i, i), n.Vector3.dot(o, i) < 0 && n.Vector3.negate(i, i), n.Vector3.equals(o, i, n.FLOAT64_TOLERANCE);}(e, t, h));}return e === t && Math.abs(r[0] - _l[0]) < n.FLOAT64_TOLERANCE && Math.abs(r[1] - _l[1]) < n.FLOAT64_TOLERANCE || !!(a(e, r[0], t, _l, h) && a(e, r[1], t, _l, h) && a(t, _l[0], e, r, h) && a(t, _l[1], e, r, h)) && (d === o.GEOMETRY_TYPES.LINE && g === o.GEOMETRY_TYPES.LINE || (d === o.GEOMETRY_TYPES.CIRCLE && g === o.GEOMETRY_TYPES.CIRCLE ? function (e, t, r, o, i) {var s = .5 * (r[0] + r[1]),u = .5 * (o[0] + o[1]);if (!a(e, s, t, o, i) || !a(t, u, e, r, i)) return !1;var l = n.Vector3.sub([0, 0, 0], t.getCenter(), e.getCenter());if (n.Vector3.squaredLength(l) > n.FLOAT64_TOLERANCE * n.FLOAT64_TOLERANCE) {if (n.Vector3.normalize(l, l), !c(l, e, t, r, o, i)) return !1;if (!c(l, t, e, o, r, i)) return !1;}if (n.Vector3.dot(e.getNormal(), t.getNormal()) < 0 ? n.Vector3.add(l, e.getNormal(), t.getNormal()) : n.Vector3.sub(l, e.getNormal(), t.getNormal()), n.Vector3.squaredLength(l) > n.FLOAT64_TOLERANCE * n.FLOAT64_TOLERANCE) {if (n.Vector3.normalize(l, l), !c(l, e, t, r, o, i)) return !1;if (!c(l, t, e, o, r, i)) return !1;}if (r[1] - r[0] < 2 * Math.PI - n.FLOAT64_TOLERANCE) {var h = e.evaluatePosition(s + Math.PI),d = t.closestToPointParam(h, o);if (d > o[0] && d < o[1] && !a(t, d, e, r, i)) return !1;}if (o[1] - o[0] < 2 * Math.PI - n.FLOAT64_TOLERANCE) {var g = t.evaluatePosition(u + Math.PI),p = e.closestToPointParam(g, r);if (p > r[0] && p < r[1] && !a(e, p, t, o, i)) return !1;}return !0;}(e, t, r, _l, h) : d === o.GEOMETRY_TYPES.CIRCLE && g === o.GEOMETRY_TYPES.LINE ? u(e, t, r, _l, h) : d === o.GEOMETRY_TYPES.LINE && g === o.GEOMETRY_TYPES.CIRCLE ? u(t, e, _l, r, h) : function (e, t, r, o, i) {for (var a = [r[0], r[1]], c = [e.evaluatePosition(r[0]), e.evaluatePosition(r[1])], u = 0; u < 100; ++u) {var l = .5 * (a[0] + a[1]),h = e.evaluatePosition(l),d = t.closestToPointParam(h, o),g = t.evaluatePosition(d),p = n.Vector3.sub([0, 0, 0], g, h);if (n.Vector3.squaredLength(p) > i * i) return !1;if (n.Vector3.distance(c[0], h) + n.Vector3.distance(h, c[1]) < i) return !0;var f = e.evaluateDt(l);n.Vector3.dot(f, p) < 0 ? (a[0] = l, c[0] = h) : (a[1] = l, c[1] = h);}return s.DebugUtils.warn(\"Binary search in coincidence check exceeded maximum iterations\"), !0;}(e, t, r, _l, h)));};t.curvesAreCoincident = l, t.edgesAreCoincident = function (e, t) {if (e === t) return !0;var r = Math.max(o.KERNEL_TOLERANCE, e.getPrecision(), t.getPrecision()),i = e.getCurve(),s = t.getCurve();if (!i || !s) {if (i || s) return !1;var a = e.getStartVertex(),c = t.getStartVertex();r = Math.max(r, a.getPrecision(), c.getPrecision());var u = a.getPosition(),h = c.getPosition();return n.Vector3.squaredDistance(u, h) < r * r;}var d = e.getRange();e.isReversed() && (d = [-d[1], -d[0]]);var g = t.getRange();return t.isReversed() && (g = [-g[1], -g[0]]), l(i, s, d, g, r);};}, function (e, t, r) {\"use strict\";Object.defineProperty(t, \"__esModule\", { value: !0 }), t.extrudeFace = void 0;var n = r(1),o = r(0),i = r(2),s = r(18),a = r(38),c = r(39),u = r(53),l = r(13),h = r(15),d = r(26),g = r(25),p = r(24),f = r(55),v = r(19),_ = r(28);function y(e, t, r) {var i = n.Vector3.length(r),s = n.Vector3.dot(e.getAxisDir(), r) > 0 ? [0, i] : [-i, 0];e.limitRangeU(s), t[1] - t[0] < 2 * Math.PI - o.PARAMETER_SPACE_TOLERANCE && e.limitRangeV(t);}var m = function m(e, t) {var r = e.getEdge().getCurve(),i = e.getRange(),l = !0;e.isReversed() !== e.getEdge().isReversed() && (i = [-i[1], -i[0]], l = !1);var h,d = l ? e.t0() : e.t1(),g = e.evaluateDt(d);if (n.Vector3.cross(g, g, t), n.Vector3.normalize(g, g), n.Vector3.negate(g, g), r.getGeometryType() === o.GEOMETRY_TYPES.LINE) h = function (e, t, r) {var o = new s.Plane(),i = e.evaluateDt(0),a = n.Vector3.createFloat64();n.Vector3.normalize(a, r);var c = n.Vector3.createFloat64();n.Vector3.cross(c, a, i), o.set(e.evaluatePosition(0), c, a);var u = n.Vector3.length(r),l = n.Vector3.dot(a, r) > 0 ? [0, u] : [-u, 0];return o.limitRangeV(t), o.limitRangeU(l), o;}(r, i, t);else if (r.getGeometryType() === o.GEOMETRY_TYPES.CIRCLE) h = function (e, t, r) {var o = e.evaluatePosition(0);n.Vector3.subtract(o, o, e.getCenter());var i = n.Vector3.createFloat64();n.Vector3.negate(i, e.getNormal());var s = new a.Cylinder();return s.set(e.getCenter(), e.getRadius(), i, o, 1), y(s, t, r), s;}(r, i, t);else if (r.getGeometryType() === o.GEOMETRY_TYPES.ELLIPSE) h = function (e, t, r) {var o = e.evaluatePosition(0);n.Vector3.subtract(o, o, e.getCenter());var i = n.Vector3.createFloat64();n.Vector3.negate(i, e.getNormal());var s = new c.EllipticalCylinder();return s.set(e.getCenter(), o, e.getMinorRadius() / e.getMajorRadius(), i, 1), y(s, t, r), s;}(r, i, t);else {if (r.getGeometryType() !== o.GEOMETRY_TYPES.BCURVE) throw new Error(\"createSideFaceRuledSurface: Curve type not supported.\");h = function (e, t, r) {for (var n = new u.BSurface(), o = e.getDegree(), i = e.getKnotVector().slice(0), s = e.getControlPoints().slice(0), a = (s = s.concat(s)).length / 2; a < s.length; a += 3) {s[a] += r[0], s[a + 1] += r[1], s[a + 2] += r[2];}var c = void 0;return e.isRational() && (c = (c = e.getWeights().slice(0)).concat(c)), n.set(1, o, [0, 0, 1, 1], i, s, c), n.limitRangeU([0, 1]), n.limitRangeV(t), n;}(r, i, t);}var p = h.evaluateNormal(0, i[0]);return { surface: h, isReversed: n.Vector3.dot(p, g) < 0 };};t.extrudeFace = function (e, t) {i.ConsoleUtils.assert(e.getSurfaceType() === o.GEOMETRY_TYPES.PLANE);var r = e.evaluateNormal(0, 0);n.Vector3.scale(r, r, t);var s = new f.TopologyCloner().cloneFace(e),a = n.Matrix44.fromTranslation(n.Matrix44.createFloat64(), r);(0, v.transformTopology)(s, a), t > 0 ? (0, v.reverseFace)(e) : (0, v.reverseFace)(s);var c = function (e, t, r) {for (var n = [], o = e.getLoops(), i = t.getLoops(), s = 0; s < o.length; ++s) {for (var a = o[s].getCoedges(), c = i[s].getCoedges(), u = new Array(a.length), d = 0; d < a.length; ++d) {var g = new Array(4),p = a[d],f = c[a.length - 1 - d],v = p.getStartVertex(),y = p.getEndVertex(),E = f.getStartVertex(),x = f.getEndVertex();g[0] = (0, _.createCoedgeOnEdge)(p.getEdge()), 0 === d && (u[d] = (0, _.createLineEdgeBetweenVertices)(v, x)), g[1] = (0, _.createCoedgeOnEdge)(u[d]), g[2] = (0, _.createCoedgeOnEdge)(f.getEdge()), d !== a.length - 1 && (u[d + 1] = (0, _.createLineEdgeBetweenVertices)(E, y)), g[3] = (0, _.createCoedgeOnEdge)(u[(d + 1) % a.length]);var R = new l.Loop();R.addCoedges(g);var A = m(p, r),P = new h.Face(A.surface);P.setReversed(A.isReversed), P.addLoop(R), n.push(P);}}return n;}(e, s, r),u = e.getShell();u || (u = new d.Shell()).addFace(e), i.ConsoleUtils.assert(1 === u.getFaces().length), u.addFaces(c), u.addFace(s);var y = u.getLump();y || (y = new g.Lump()).addShell(u);var E = y.getBody();return E || (E = new p.Body()).addLump(y), E;};}, function (e, t, r) {\"use strict\";Object.defineProperty(t, \"__esModule\", { value: !0 }), t.getBoundedRegionFaces = t.getRegionEdges = t.mergeSketchRegions = void 0;var n = r(0),o = r(19),i = r(80),s = function s(e, t) {var r = e.getProgenitorMap(),o = new Set();return t.forEach(function (e) {r.getDescendants(e).forEach(function (e) {e.getTopologyType() === n.TOPOLOGY_TYPES.EDGE && o.add(e);});}), Array.from(o);},a = function a(e, t) {var r = [];return (0, o.findConnectedFaces)(e, { allowVertexConnections: !1, barrierEdges: t }).forEach(function (e) {(function (e, t) {e = new Set(e), t = new Set(t);var r = new Set();e.forEach(function (e) {e.collectEdges(r);}), r = Array.from(r);for (var n = 0; n < r.length; n++) {var o = r[n];if (!t.has(o)) {var i = o.getCoedges();if (i.length < 2) return !1;for (var s = 0; s < i.length; s++) {if (!e.has(i[s].getFace())) return !1;}}}return !0;})(e, t) && (r = r.concat(e));}), r;},c = function c(e, t) {for (var r = 0; r < e.length; r++) {if (t.indexOf(e[r]) < 0) return !1;}return !0;};t.mergeSketchRegions = function (e) {var t,r,n = [];e.forEach(function (e) {n = n.concat(e.getEdges());});var u = new i.SketchRegionSolver();u.compute(n);var l = u.getFaces(),h = [],d = [];for (t = 0; t < e.length; t++) {var g = s(u, e[t].getEdges());if (0 !== g.length) {var p = a(l, g);0 !== p.length && (d.push(g), h.push(p));}}for (var f = [], v = new Set(l), _ = !0; h.length > 0;) {var y = [];for (t = 0; t < h.length; t++) {var m = !1;for (r = 0; r < h.length; r++) {if (t !== r && c(h[t], h[r])) {m = !0;break;}}y.push(m);}var E = new Set();for (t = h.length - 1; t >= 0; t--) {y[t] ? h[t].forEach(function (e) {E.add(e), v.delete(e);}) : (h.splice(t, 1), d.splice(t, 1));}_ && (f = f.concat(Array.from(v))), v = E, _ = !_;}return (0, o.mergeConnectedFaces)(f);}, t.getRegionEdges = s, t.getBoundedRegionFaces = a;}, function (e, t, r) {\"use strict\";Object.defineProperty(t, \"__esModule\", { value: !0 }), t.propertyToRange = t.GeometrySetters = void 0;var n = r(1),o = function o(e, t, r) {var n = t[r];e[0] = n.x, e[1] = n.y, e[2] = n.z;},i = function i(e, t) {var r = e[t];var n = r.type;return \"infinite\" === n || 0 === n ? [] : [r.low, r.high];},s = function s(e, t) {var r = i(e, \"uRange\");t.unlimitRangeU(), r.length > 0 && t.limitRangeU(r);var n = i(e, \"vRange\");t.unlimitRangeV(), n.length > 0 && t.limitRangeV(n);},a = function a(e, t) {var r = i(e, \"range\");t.unlimitRange(), r.length > 0 && t.limitRange(r);},c = { setBCurveFromProperty: function setBCurveFromProperty(e, t) {var r,n,o = t.degree,i = t.knots,s = t.controlPoints,c = t.weights,u = s.length / 3;if (0 === c.length) for (n = new Array(u), r = 0; r < u; ++r) {n[r] = 1;} else n = c;e.set(s, n, o, i), a(t, e);}, setBSurfaceFromProperty: function setBSurfaceFromProperty(e, t) {var r,n,o = t.uDegree,i = t.vDegree,a = t.uKnots,c = t.vKnots,u = t.controlPoints,l = t.weights;if (0 === l.length) {var h = u.length / 3;for (n = new Array(h), r = 0; r < h; ++r) {n[r] = 1;}} else n = l;e.set(o, i, a, c, u, n), s(t, e);}, setCircleFromProperty: function setCircleFromProperty(e, t) {var r = n.Vector3.createFloat64(),i = n.Vector3.createFloat64(),s = n.Vector3.createFloat64();o(r, t, \"center\"), o(i, t, \"normal\"), o(s, t, \"radius\"), e.set(r, i, s), a(t, e);}, setConeFromProperty: function setConeFromProperty(e, t) {var r = n.Vector3.createFloat64(),i = n.Vector3.createFloat64(),a = n.Vector3.createFloat64();o(r, t, \"center\"), o(i, t, \"axis\"), o(a, t, \"radius\");var c = n.Vector3.length(a);n.Vector3.normalize(a, a);var u = t.angle,l = t.uCoordScale;e.set(r, c, i, u, a, l), s(t, e);}, setCylinderFromProperty: function setCylinderFromProperty(e, t) {var r = n.Vector3.createFloat64(),i = n.Vector3.createFloat64(),a = n.Vector3.createFloat64();o(r, t, \"center\"), o(i, t, \"axis\"), o(a, t, \"radius\");var c = n.Vector3.length(a);n.Vector3.normalize(a, a);var u = t.uCoordScale;e.set(r, c, i, a, u), s(t, e);}, setEllipseFromProperty: function setEllipseFromProperty(e, t) {var r = n.Vector3.createFloat64(),i = n.Vector3.createFloat64(),s = n.Vector3.createFloat64();o(r, t, \"center\"), o(i, t, \"normal\"), o(s, t, \"majorRadius\");var c = t.radiusRatio;e.set(r, i, s, c), a(t, e);}, setEllipticalConeFromProperty: function setEllipticalConeFromProperty(e, t) {var r = n.Vector3.createFloat64(),i = n.Vector3.createFloat64(),a = n.Vector3.createFloat64();o(r, t, \"center\"), o(i, t, \"axis\"), o(a, t, \"majorRadius\");var c = t.angle,u = t.radiusRatio,l = t.uCoordScale;e.set(r, a, u, i, c, l), s(t, e);}, setEllipticalCylinderFromProperty: function setEllipticalCylinderFromProperty(e, t) {var r = n.Vector3.createFloat64(),i = n.Vector3.createFloat64(),a = n.Vector3.createFloat64();o(r, t, \"center\"), o(i, t, \"axis\"), o(a, t, \"majorRadius\");var c = t.radiusRatio,u = t.uCoordScale;e.set(r, a, c, i, u), s(t, e);}, setLineFromProperty: function setLineFromProperty(e, t) {var r = n.Vector3.createFloat64(),i = n.Vector3.createFloat64();o(r, t, \"position\"), o(i, t, \"direction\"), e.set(r, i), a(t, e);}, setPlaneFromProperty: function setPlaneFromProperty(e, t) {var r = n.Vector3.createFloat64(),i = n.Vector3.createFloat64(),a = n.Vector3.createFloat64();o(r, t, \"origin\"), o(i, t, \"normal\"), o(a, t, \"uAxis\"), e.set(r, i, a), s(t, e);}, setPointFromProperty: function setPointFromProperty(e, t) {e.setPosition(t.position.x, t.position.y, t.position.z);}, setSphereFromProperty: function setSphereFromProperty(e, t) {var r = n.Vector3.createFloat64(),i = n.Vector3.createFloat64(),a = n.Vector3.createFloat64();o(r, t, \"center\"), o(i, t, \"radius\"), o(a, t, \"axis\");var c = n.Vector3.length(i);n.Vector3.normalize(i, i), e.set(r, c, a, i), s(t, e);}, setTorusFromProperty: function setTorusFromProperty(e, t) {var r = n.Vector3.createFloat64(),i = n.Vector3.createFloat64(),a = n.Vector3.createFloat64();o(r, t, \"center\"), o(i, t, \"axis\"), o(a, t, \"coordAxis\");var c = t.majorRadius,u = t.minorRadius,l = t.lemon;e.set(r, c, u, i, a, l), s(t, e);}, setHapCurveFromProperty: function setHapCurveFromProperty(e, t) {for (var r = t.spans, n = new Array(r.length), o = 0; o < r.length; ++o) {n[o] = {}, n[o].polyOrder = r[o].polyOrder, n[o].lowParam = r[o].lowParam, n[o].highParam = r[o].highParam, n[o].coefs = r[o].coefs.slice(0);}var i = {};i.spans = n;var s = t.periodic;void 0 === s && (s = !1), i.periodic = s, i.closed = s, e.setHapDefinition(i), a(t, e);}, setCurveRangeFromProperty: a, setSurfaceRangeFromProperty: s };t.GeometrySetters = c, t.propertyToRange = i;}, function (e, t, r) {\"use strict\";Object.defineProperty(t, \"__esModule\", { value: !0 }), t.getBoundedRegionFaces = t.getRegionEdges = t.mergeConnectedFaces = t.getOrderedFacesOnVertex = t.saveToProtoMessage = t.saveToProtoBinary = t.SolidDefSaver = t.SolidDefLoader = t.Path2D = t.DebugUtils = t.svgFromWire = t.transformTopology = t.TopologyStitcher = t.TopologyCloner = t.extrudeFace = t.createEdgeFromCurve = t.createFaceFromPolyline = t.createShellsFromFaces = t.createPolyhedron = t.createLineEdgeBetweenVertices = t.createLineEdge = t.createCylinder = t.createCone = t.createBlock = t.computeCurveCurveIntersections = t.SketchRegionSolver = t.facetPlanarFace = t.checkValidity = t.BoundingBox = t.Attribute = t.Wire = t.WireBody = t.Vertex = t.Edge = t.Coedge = t.Loop = t.Face = t.Shell = t.Lump = t.Body = t.BSurface = t.Torus = t.EllipticalCone = t.Cone = t.Sphere = t.EllipticalCylinder = t.Cylinder = t.Plane = t.BCurve = t.Ellipse = t.Circle = t.Line = t.Point = t.TOPOLOGY_TYPES = t.GEOMETRY_TYPES = t.KERNEL_TOLERANCE = void 0;var n = r(0),o = r(4),i = r(6),s = r(7),a = r(14),c = r(23),u = r(33),l = r(18),h = r(38),d = r(39),g = r(74),p = r(51),f = r(52),v = r(75),_ = r(53),y = r(24),m = r(25),E = r(26),x = r(15),R = r(13),A = r(27),P = r(20),V = r(16),T = r(54),C = r(40),b = r(79),L = r(106),O = r(107),S = r(80),M = r(81),w = r(115),N = r(116),F = r(117),I = r(28),D = r(83),j = r(55),B = r(118),U = r(19),k = r(121),G = r(8),z = r(122),Y = r(123),K = r(126),q = r(84),W = r(78);t.KERNEL_TOLERANCE = n.KERNEL_TOLERANCE, t.GEOMETRY_TYPES = n.GEOMETRY_TYPES, t.TOPOLOGY_TYPES = n.TOPOLOGY_TYPES, t.Point = i.Point, t.Line = s.Line, t.Circle = a.Circle, t.Ellipse = c.Ellipse, t.BCurve = u.BCurve, t.Plane = l.Plane, t.Cylinder = h.Cylinder, t.EllipticalCylinder = d.EllipticalCylinder, t.Sphere = g.Sphere, t.Cone = p.Cone, t.EllipticalCone = f.EllipticalCone, t.Torus = v.Torus, t.BSurface = _.BSurface, t.Body = y.Body, t.Lump = m.Lump, t.Shell = E.Shell, t.Face = x.Face, t.Loop = R.Loop, t.Coedge = A.Coedge, t.Edge = P.Edge, t.Vertex = V.Vertex, t.WireBody = T.WireBody, t.Wire = C.Wire, t.Attribute = b.Attribute, t.BoundingBox = o.BoundingBox, t.checkValidity = L.checkValidity, t.facetPlanarFace = O.facetPlanarFace, t.SketchRegionSolver = S.SketchRegionSolver, t.computeCurveCurveIntersections = M.computeCurveCurveIntersections, t.createBlock = w.createBlock, t.createCone = N.createCone, t.createCylinder = N.createCylinder, t.createLineEdge = I.createLineEdge, t.createLineEdgeBetweenVertices = I.createLineEdgeBetweenVertices, t.createPolyhedron = F.createPolyhedron, t.createShellsFromFaces = I.createShellsFromFaces, t.createFaceFromPolyline = I.createFaceFromPolyline, t.createEdgeFromCurve = I.createEdgeFromCurve, t.extrudeFace = D.extrudeFace, t.TopologyCloner = j.TopologyCloner, t.TopologyStitcher = B.TopologyStitcher, t.transformTopology = U.transformTopology, t.svgFromWire = k.svgFromWire, t.DebugUtils = G.DebugUtils, t.Path2D = z.Path2D, t.SolidDefLoader = Y.SolidDefLoader, t.SolidDefSaver = K.SolidDefSaver, t.saveToProtoBinary = K.saveToProtoBinary, t.saveToProtoMessage = K.saveToProtoMessage, t.getOrderedFacesOnVertex = W.getOrderedFacesOnVertex, t.mergeConnectedFaces = U.mergeConnectedFaces, t.getRegionEdges = q.getRegionEdges, t.getBoundedRegionFaces = q.getBoundedRegionFaces;}, function (e, t, r) {\"use strict\";e.exports = r(88);}, function (e, t, r) {\"use strict\";var n = e.exports = r(89);n.build = \"light\", n.load = function (e, t, r) {return \"function\" == typeof t ? (r = t, t = new n.Root()) : t || (t = new n.Root()), t.load(e, r);}, n.loadSync = function (e, t) {return t || (t = new n.Root()), t.loadSync(e);}, n.encoder = r(62), n.decoder = r(67), n.verifier = r(68), n.converter = r(69), n.ReflectionObject = r(21), n.Namespace = r(30), n.Root = r(71), n.Enum = r(11), n.Type = r(63), n.Field = r(22), n.OneOf = r(48), n.MapField = r(64), n.Service = r(65), n.Method = r(66), n.Message = r(49), n.wrappers = r(70), n.types = r(31), n.util = r(5), n.ReflectionObject._configure(n.Root), n.Namespace._configure(n.Type, n.Service, n.Enum), n.Root._configure(n.Type), n.Field._configure(n.Type);}, function (e, t, r) {\"use strict\";var n = t;function o() {n.Reader._configure(n.BufferReader), n.util._configure();}n.build = \"minimal\", n.Writer = r(46), n.BufferWriter = r(96), n.Reader = r(47), n.BufferReader = r(97), n.util = r(10), n.rpc = r(60), n.roots = r(61), n.configure = o, n.Writer._configure(n.BufferWriter), o();}, function (e, t, r) {\"use strict\";var n = t;n.length = function (e) {var t = e.length;if (!t) return 0;for (var r = 0; --t % 4 > 1 && \"=\" === e.charAt(t);) {++r;}return Math.ceil(3 * e.length) / 4 - r;};for (var o = new Array(64), i = new Array(123), s = 0; s < 64;) {i[o[s] = s < 26 ? s + 65 : s < 52 ? s + 71 : s < 62 ? s - 4 : s - 59 | 43] = s++;}n.encode = function (e, t, r) {for (var n, i = null, s = [], a = 0, c = 0; t < r;) {var u = e[t++];switch (c) {case 0:s[a++] = o[u >> 2], n = (3 & u) << 4, c = 1;break;case 1:s[a++] = o[n | u >> 4], n = (15 & u) << 2, c = 2;break;case 2:s[a++] = o[n | u >> 6], s[a++] = o[63 & u], c = 0;}a > 8191 && ((i || (i = [])).push(String.fromCharCode.apply(String, s)), a = 0);}return c && (s[a++] = o[n], s[a++] = 61, 1 === c && (s[a++] = 61)), i ? (a && i.push(String.fromCharCode.apply(String, s.slice(0, a))), i.join(\"\")) : String.fromCharCode.apply(String, s.slice(0, a));}, n.decode = function (e, t, r) {for (var n, o = r, s = 0, a = 0; a < e.length;) {var c = e.charCodeAt(a++);if (61 === c && s > 1) break;if (void 0 === (c = i[c])) throw Error(\"invalid encoding\");switch (s) {case 0:n = c, s = 1;break;case 1:t[r++] = n << 2 | (48 & c) >> 4, n = c, s = 2;break;case 2:t[r++] = (15 & n) << 4 | (60 & c) >> 2, n = c, s = 3;break;case 3:t[r++] = (3 & n) << 6 | c, s = 0;}}if (1 === s) throw Error(\"invalid encoding\");return r - o;}, n.test = function (e) {return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(e);};}, function (e, t, r) {\"use strict\";function n() {this._listeners = {};}e.exports = n, n.prototype.on = function (e, t, r) {return (this._listeners[e] || (this._listeners[e] = [])).push({ fn: t, ctx: r || this }), this;}, n.prototype.off = function (e, t) {if (void 0 === e) this._listeners = {};else if (void 0 === t) this._listeners[e] = [];else for (var r = this._listeners[e], n = 0; n < r.length;) {r[n].fn === t ? r.splice(n, 1) : ++n;}return this;}, n.prototype.emit = function (e) {var t = this._listeners[e];if (t) {for (var r = [], n = 1; n < arguments.length;) {r.push(arguments[n++]);}for (n = 0; n < t.length;) {t[n].fn.apply(t[n++].ctx, r);}}return this;};}, function (e, t, r) {\"use strict\";function n(e) {return \"undefined\" != typeof Float32Array ? function () {var t = new Float32Array([-0]),r = new Uint8Array(t.buffer),n = 128 === r[3];function o(e, n, o) {t[0] = e, n[o] = r[0], n[o + 1] = r[1], n[o + 2] = r[2], n[o + 3] = r[3];}function i(e, n, o) {t[0] = e, n[o] = r[3], n[o + 1] = r[2], n[o + 2] = r[1], n[o + 3] = r[0];}function s(e, n) {return r[0] = e[n], r[1] = e[n + 1], r[2] = e[n + 2], r[3] = e[n + 3], t[0];}function a(e, n) {return r[3] = e[n], r[2] = e[n + 1], r[1] = e[n + 2], r[0] = e[n + 3], t[0];}e.writeFloatLE = n ? o : i, e.writeFloatBE = n ? i : o, e.readFloatLE = n ? s : a, e.readFloatBE = n ? a : s;}() : function () {function t(e, t, r, n) {var o = t < 0 ? 1 : 0;if (o && (t = -t), 0 === t) e(1 / t > 0 ? 0 : 2147483648, r, n);else if (isNaN(t)) e(2143289344, r, n);else if (t > 34028234663852886e22) e((o << 31 | 2139095040) >>> 0, r, n);else if (t < 11754943508222875e-54) e((o << 31 | Math.round(t / 1401298464324817e-60)) >>> 0, r, n);else {var i = Math.floor(Math.log(t) / Math.LN2);e((o << 31 | i + 127 << 23 | 8388607 & Math.round(t * Math.pow(2, -i) * 8388608)) >>> 0, r, n);}}function r(e, t, r) {var n = e(t, r),o = 2 * (n >> 31) + 1,i = n >>> 23 & 255,s = 8388607 & n;return 255 === i ? s ? NaN : o * (1 / 0) : 0 === i ? 1401298464324817e-60 * o * s : o * Math.pow(2, i - 150) * (s + 8388608);}e.writeFloatLE = t.bind(null, o), e.writeFloatBE = t.bind(null, i), e.readFloatLE = r.bind(null, s), e.readFloatBE = r.bind(null, a);}(), \"undefined\" != typeof Float64Array ? function () {var t = new Float64Array([-0]),r = new Uint8Array(t.buffer),n = 128 === r[7];function o(e, n, o) {t[0] = e, n[o] = r[0], n[o + 1] = r[1], n[o + 2] = r[2], n[o + 3] = r[3], n[o + 4] = r[4], n[o + 5] = r[5], n[o + 6] = r[6], n[o + 7] = r[7];}function i(e, n, o) {t[0] = e, n[o] = r[7], n[o + 1] = r[6], n[o + 2] = r[5], n[o + 3] = r[4], n[o + 4] = r[3], n[o + 5] = r[2], n[o + 6] = r[1], n[o + 7] = r[0];}function s(e, n) {return r[0] = e[n], r[1] = e[n + 1], r[2] = e[n + 2], r[3] = e[n + 3], r[4] = e[n + 4], r[5] = e[n + 5], r[6] = e[n + 6], r[7] = e[n + 7], t[0];}function a(e, n) {return r[7] = e[n], r[6] = e[n + 1], r[5] = e[n + 2], r[4] = e[n + 3], r[3] = e[n + 4], r[2] = e[n + 5], r[1] = e[n + 6], r[0] = e[n + 7], t[0];}e.writeDoubleLE = n ? o : i, e.writeDoubleBE = n ? i : o, e.readDoubleLE = n ? s : a, e.readDoubleBE = n ? a : s;}() : function () {function t(e, t, r, n, o, i) {var s = n < 0 ? 1 : 0;if (s && (n = -n), 0 === n) e(0, o, i + t), e(1 / n > 0 ? 0 : 2147483648, o, i + r);else if (isNaN(n)) e(0, o, i + t), e(2146959360, o, i + r);else if (n > 17976931348623157e292) e(0, o, i + t), e((s << 31 | 2146435072) >>> 0, o, i + r);else {var a;if (n < 22250738585072014e-324) e((a = n / 5e-324) >>> 0, o, i + t), e((s << 31 | a / 4294967296) >>> 0, o, i + r);else {var c = Math.floor(Math.log(n) / Math.LN2);1024 === c && (c = 1023), e(4503599627370496 * (a = n * Math.pow(2, -c)) >>> 0, o, i + t), e((s << 31 | c + 1023 << 20 | 1048576 * a & 1048575) >>> 0, o, i + r);}}}function r(e, t, r, n, o) {var i = e(n, o + t),s = e(n, o + r),a = 2 * (s >> 31) + 1,c = s >>> 20 & 2047,u = 4294967296 * (1048575 & s) + i;return 2047 === c ? u ? NaN : a * (1 / 0) : 0 === c ? 5e-324 * a * u : a * Math.pow(2, c - 1075) * (u + 4503599627370496);}e.writeDoubleLE = t.bind(null, o, 0, 4), e.writeDoubleBE = t.bind(null, i, 4, 0), e.readDoubleLE = r.bind(null, s, 0, 4), e.readDoubleBE = r.bind(null, a, 4, 0);}(), e;}function o(e, t, r) {t[r] = 255 & e, t[r + 1] = e >>> 8 & 255, t[r + 2] = e >>> 16 & 255, t[r + 3] = e >>> 24;}function i(e, t, r) {t[r] = e >>> 24, t[r + 1] = e >>> 16 & 255, t[r + 2] = e >>> 8 & 255, t[r + 3] = 255 & e;}function s(e, t) {return (e[t] | e[t + 1] << 8 | e[t + 2] << 16 | e[t + 3] << 24) >>> 0;}function a(e, t) {return (e[t] << 24 | e[t + 1] << 16 | e[t + 2] << 8 | e[t + 3]) >>> 0;}e.exports = n(n);}, function (e, t, r) {\"use strict\";var n = t;n.length = function (e) {for (var t = 0, r = 0, n = 0; n < e.length; ++n) {(r = e.charCodeAt(n)) < 128 ? t += 1 : r < 2048 ? t += 2 : 55296 == (64512 & r) && 56320 == (64512 & e.charCodeAt(n + 1)) ? (++n, t += 4) : t += 3;}return t;}, n.read = function (e, t, r) {if (r - t < 1) return \"\";for (var n, o = null, i = [], s = 0; t < r;) {(n = e[t++]) < 128 ? i[s++] = n : n > 191 && n < 224 ? i[s++] = (31 & n) << 6 | 63 & e[t++] : n > 239 && n < 365 ? (n = ((7 & n) << 18 | (63 & e[t++]) << 12 | (63 & e[t++]) << 6 | 63 & e[t++]) - 65536, i[s++] = 55296 + (n >> 10), i[s++] = 56320 + (1023 & n)) : i[s++] = (15 & n) << 12 | (63 & e[t++]) << 6 | 63 & e[t++], s > 8191 && ((o || (o = [])).push(String.fromCharCode.apply(String, i)), s = 0);}return o ? (s && o.push(String.fromCharCode.apply(String, i.slice(0, s))), o.join(\"\")) : String.fromCharCode.apply(String, i.slice(0, s));}, n.write = function (e, t, r) {for (var n, o, i = r, s = 0; s < e.length; ++s) {(n = e.charCodeAt(s)) < 128 ? t[r++] = n : n < 2048 ? (t[r++] = n >> 6 | 192, t[r++] = 63 & n | 128) : 55296 == (64512 & n) && 56320 == (64512 & (o = e.charCodeAt(s + 1))) ? (n = 65536 + ((1023 & n) << 10) + (1023 & o), ++s, t[r++] = n >> 18 | 240, t[r++] = n >> 12 & 63 | 128, t[r++] = n >> 6 & 63 | 128, t[r++] = 63 & n | 128) : (t[r++] = n >> 12 | 224, t[r++] = n >> 6 & 63 | 128, t[r++] = 63 & n | 128);}return r - i;};}, function (e, t, r) {\"use strict\";e.exports = function (e, t, r) {var n = r || 8192,o = n >>> 1,i = null,s = n;return function (r) {if (r < 1 || r > o) return e(r);s + r > n && (i = e(n), s = 0);var a = t.call(i, s, s += r);return 7 & s && (s = 1 + (7 | s)), a;};};}, function (e, t, r) {\"use strict\";e.exports = o;var n = r(10);function o(e, t) {this.lo = e >>> 0, this.hi = t >>> 0;}var i = o.zero = new o(0, 0);i.toNumber = function () {return 0;}, i.zzEncode = i.zzDecode = function () {return this;}, i.length = function () {return 1;};var s = o.zeroHash = \"\\0\\0\\0\\0\\0\\0\\0\\0\";o.fromNumber = function (e) {if (0 === e) return i;var t = e < 0;t && (e = -e);var r = e >>> 0,n = (e - r) / 4294967296 >>> 0;return t && (n = ~n >>> 0, r = ~r >>> 0, ++r > 4294967295 && (r = 0, ++n > 4294967295 && (n = 0))), new o(r, n);}, o.from = function (e) {if (\"number\" == typeof e) return o.fromNumber(e);if (n.isString(e)) {if (!n.Long) return o.fromNumber(parseInt(e, 10));e = n.Long.fromString(e);}return e.low || e.high ? new o(e.low >>> 0, e.high >>> 0) : i;}, o.prototype.toNumber = function (e) {if (!e && this.hi >>> 31) {var t = 1 + ~this.lo >>> 0,r = ~this.hi >>> 0;return t || (r = r + 1 >>> 0), -(t + 4294967296 * r);}return this.lo + 4294967296 * this.hi;}, o.prototype.toLong = function (e) {return n.Long ? new n.Long(0 | this.lo, 0 | this.hi, Boolean(e)) : { low: 0 | this.lo, high: 0 | this.hi, unsigned: Boolean(e) };};var a = String.prototype.charCodeAt;o.fromHash = function (e) {return e === s ? i : new o((a.call(e, 0) | a.call(e, 1) << 8 | a.call(e, 2) << 16 | a.call(e, 3) << 24) >>> 0, (a.call(e, 4) | a.call(e, 5) << 8 | a.call(e, 6) << 16 | a.call(e, 7) << 24) >>> 0);}, o.prototype.toHash = function () {return String.fromCharCode(255 & this.lo, this.lo >>> 8 & 255, this.lo >>> 16 & 255, this.lo >>> 24, 255 & this.hi, this.hi >>> 8 & 255, this.hi >>> 16 & 255, this.hi >>> 24);}, o.prototype.zzEncode = function () {var e = this.hi >> 31;return this.hi = ((this.hi << 1 | this.lo >>> 31) ^ e) >>> 0, this.lo = (this.lo << 1 ^ e) >>> 0, this;}, o.prototype.zzDecode = function () {var e = -(1 & this.lo);return this.lo = ((this.lo >>> 1 | this.hi << 31) ^ e) >>> 0, this.hi = (this.hi >>> 1 ^ e) >>> 0, this;}, o.prototype.length = function () {var e = this.lo,t = (this.lo >>> 28 | this.hi << 4) >>> 0,r = this.hi >>> 24;return 0 === r ? 0 === t ? e < 16384 ? e < 128 ? 1 : 2 : e < 2097152 ? 3 : 4 : t < 16384 ? t < 128 ? 5 : 6 : t < 2097152 ? 7 : 8 : r < 128 ? 9 : 10;};}, function (e, t, r) {\"use strict\";e.exports = s;var n = r(46);(s.prototype = Object.create(n.prototype)).constructor = s;var o = r(10),i = o.Buffer;function s() {n.call(this);}s.alloc = function (e) {return (s.alloc = o._Buffer_allocUnsafe)(e);};var a = i && i.prototype instanceof Uint8Array && \"set\" === i.prototype.set.name ? function (e, t, r) {t.set(e, r);} : function (e, t, r) {if (e.copy) e.copy(t, r, 0, e.length);else for (var n = 0; n < e.length;) {t[r++] = e[n++];}};function c(e, t, r) {e.length < 40 ? o.utf8.write(e, t, r) : t.utf8Write(e, r);}s.prototype.bytes = function (e) {o.isString(e) && (e = o._Buffer_from(e, \"base64\"));var t = e.length >>> 0;return this.uint32(t), t && this._push(a, t, e), this;}, s.prototype.string = function (e) {var t = i.byteLength(e);return this.uint32(t), t && this._push(c, t, e), this;};}, function (e, t, r) {\"use strict\";e.exports = i;var n = r(47);(i.prototype = Object.create(n.prototype)).constructor = i;var o = r(10);function i(e) {n.call(this, e);}o.Buffer && (i.prototype._slice = o.Buffer.prototype.slice), i.prototype.string = function () {var e = this.uint32();return this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + e, this.len));};}, function (e, t, r) {\"use strict\";e.exports = o;var n = r(10);function o(e, t, r) {if (\"function\" != typeof e) throw TypeError(\"rpcImpl must be a function\");n.EventEmitter.call(this), this.rpcImpl = e, this.requestDelimited = Boolean(t), this.responseDelimited = Boolean(r);}(o.prototype = Object.create(n.EventEmitter.prototype)).constructor = o, o.prototype.rpcCall = function e(t, r, o, i, s) {if (!i) throw TypeError(\"request must be specified\");var a = this;if (!s) return n.asPromise(e, a, t, r, o, i);if (a.rpcImpl) try {return a.rpcImpl(t, r[a.requestDelimited ? \"encodeDelimited\" : \"encode\"](i).finish(), function (e, r) {if (e) return a.emit(\"error\", e, t), s(e);if (null !== r) {if (!(r instanceof o)) try {r = o[a.responseDelimited ? \"decodeDelimited\" : \"decode\"](r);} catch (e) {return a.emit(\"error\", e, t), s(e);}return a.emit(\"data\", r, t), s(null, r);}a.end(!0);});} catch (e) {return a.emit(\"error\", e, t), void setTimeout(function () {s(e);}, 0);} else setTimeout(function () {s(Error(\"already ended\"));}, 0);}, o.prototype.end = function (e) {return this.rpcImpl && (e || this.rpcImpl(null, null, null), this.rpcImpl = null, this.emit(\"end\").off()), this;};}, function (e, t, r) {\"use strict\";function n(e, t) {\"string\" == typeof e && (t = e, e = void 0);var r = [];function o(e) {if (\"string\" != typeof e) {var t = i();if (n.verbose && console.log(\"codegen: \" + t), t = \"return \" + t, e) {for (var s = Object.keys(e), a = new Array(s.length + 1), c = new Array(s.length), u = 0; u < s.length;) {a[u] = s[u], c[u] = e[s[u++]];}return a[u] = t, Function.apply(null, a).apply(null, c);}return Function(t)();}for (var l = new Array(arguments.length - 1), h = 0; h < l.length;) {l[h] = arguments[++h];}if (h = 0, e = e.replace(/%([%dfijs])/g, function (e, t) {var r = l[h++];switch (t) {case \"d\":case \"f\":return String(Number(r));case \"i\":return String(Math.floor(r));case \"j\":return JSON.stringify(r);case \"s\":return String(r);}return \"%\";}), h !== l.length) throw Error(\"parameter count mismatch\");return r.push(e), o;}function i(n) {return \"function \" + (n || t || \"\") + \"(\" + (e && e.join(\",\") || \"\") + \"){\\n  \" + r.join(\"\\n  \") + \"\\n}\";}return o.toString = i, o;}e.exports = n, n.verbose = !1;}, function (e, t, r) {\"use strict\";e.exports = i;var n = r(58),o = r(59)(\"fs\");function i(e, t, r) {return \"function\" == typeof t ? (r = t, t = {}) : t || (t = {}), r ? !t.xhr && o && o.readFile ? o.readFile(e, function (n, o) {return n && \"undefined\" != typeof XMLHttpRequest ? i.xhr(e, t, r) : n ? r(n) : r(null, t.binary ? o : o.toString(\"utf8\"));}) : i.xhr(e, t, r) : n(i, this, e, t);}i.xhr = function (e, t, r) {var n = new XMLHttpRequest();n.onreadystatechange = function () {if (4 === n.readyState) {if (0 !== n.status && 200 !== n.status) return r(Error(\"status \" + n.status));if (t.binary) {var e = n.response;if (!e) {e = [];for (var o = 0; o < n.responseText.length; ++o) {e.push(255 & n.responseText.charCodeAt(o));}}return r(null, \"undefined\" != typeof Uint8Array ? new Uint8Array(e) : e);}return r(null, n.responseText);}}, t.binary && (\"overrideMimeType\" in n && n.overrideMimeType(\"text/plain; charset=x-user-defined\"), n.responseType = \"arraybuffer\"), n.open(\"GET\", e), n.send();};}, function (e, t, r) {\"use strict\";var n = t,o = n.isAbsolute = function (e) {return /^(?:\\/|\\w+:)/.test(e);},i = n.normalize = function (e) {var t = (e = e.replace(/\\\\/g, \"/\").replace(/\\/{2,}/g, \"/\")).split(\"/\"),r = o(e),n = \"\";r && (n = t.shift() + \"/\");for (var i = 0; i < t.length;) {\"..\" === t[i] ? i > 0 && \"..\" !== t[i - 1] ? t.splice(--i, 2) : r ? t.splice(i, 1) : ++i : \".\" === t[i] ? t.splice(i, 1) : ++i;}return n + t.join(\"/\");};n.resolve = function (e, t, r) {return r || (t = i(t)), o(t) ? t : (r || (e = i(e)), (e = e.replace(/(?:\\/|^)[^/]+$/, \"\")).length ? i(e + \"/\" + t) : t);};}, function (e, t, r) {\"use strict\";Object.defineProperty(t, \"__esModule\", { value: !0 }), t.decomposeBCurveFlags = t.decomposeBCurveToBezier = t.decomposeBCurveControlPoints = void 0;var n = r(17),o = r(2),i = function i(e, t, r) {o.ConsoleUtils.assert(t.length % r == 0);var n,i,s,a = e.length - t.length / r - 1;o.ConsoleUtils.assert(a > 0);var c = e.length - 1,u = a,l = a + 1,h = 0,d = [],g = [];for (g[h] = new Array((a + 1) * r), n = 0; n <= a; ++n) {for (s = 0; s < r; ++s) {g[h][n * r + s] = t[n * r + s];}}for (; l < c;) {for (var p = 1; l < c && e[l + 1] === e[l];) {++l, ++p;}var f = l === c;if (f || (g[h + 1] = new Array((a + 1) * r)), p < a) {var v = e[l] - e[u];for (i = a; i > p; --i) {d[i - p - 1] = v / (e[u + i] - e[u]);}var _ = a - p;for (i = 1; i <= _; ++i) {for (var y = _ - i, m = p + i, E = a; E >= m; --E) {var x = d[E - m];for (s = 0; s < r; ++s) {g[h][E * r + s] = g[h][E * r + s] * x + g[h][(E - 1) * r + s] * (1 - x);}}if (!f) for (s = 0; s < r; ++s) {g[h + 1][y * r + s] = g[h][a * r + s];}}}if (f) break;for (++h, n = a - p; n <= a; ++n) {for (s = 0; s < r; ++s) {g[h][n * r + s] = t[(l - a + n) * r + s];}}u = l, ++l;}return g;};t.decomposeBCurveControlPoints = i, t.decomposeBCurveToBezier = function (e, t, r) {var s,a = r && r.length > 0;o.ConsoleUtils.assert(t.length > 0 && t.length % 3 == 0), o.ConsoleUtils.assert(!a || t.length === 3 * r.length);var c,u,l = e.length - t.length / 3 - 1;if (o.ConsoleUtils.assert(l > 0), a) {var h = (0, n.controlPointsToHomogeneous)(t, r);for (c = i(e, h, 4), u = [], s = 0; s < c.length; ++s) {var d = (0, n.controlPointsFromHomogeneous)(c[s]);c[s] = d.P, u[s] = d.w;}} else c = i(e, t, 3), u = void 0;var g = (0, n.getUniqueKnots)(e);o.ConsoleUtils.assert(g.length === c.length + 1);var p = new Array(g.length - 1);for (s = 0; s < p.length; ++s) {p[s] = new Array(2 * l + 2), p[s].fill(g[s], 0, l + 1), p[s].fill(g[s + 1], l + 1);}return { U: p, P: c, w: u };}, t.decomposeBCurveFlags = function (e, t) {var r,n = e.length - t.length - 1,o = new Array(t.length);o.fill(!1);var i = n - 1;for (r = 0; r < t.length; ++r) {if (t[r]) {var s = Math.max(r - i, 0),a = Math.min(r + i, o.length - 1);o.fill(!0, s, a + 1);}}var c = [],u = e.length - 1,l = n + 1,h = 0;for (c[h] = !1, r = 0; r <= n; ++r) {o[r] && (c[h] = !0);}for (; l < u;) {for (var d = 1; l < u && e[l + 1] === e[l];) {++l, ++d;}if (l === u) break;for (c[++h] = !1, r = n - d; r <= n; ++r) {o[l - n + r] && (c[h] = !0);}++l;}return c;};}, function (e, t, r) {\"use strict\";Object.defineProperty(t, \"__esModule\", { value: !0 }), t.extractBSurfaceParamLineV = t.extractBSurfaceParamLineU = t.insertBSurfaceKnotV = t.insertBSurfaceKnotU = void 0;var n = r(1),o = r(17),i = r(0),s = function s(e, t, r, o, i, _s, a) {var c,u,l = new Array(o);for (u = 0; u < o; ++u) {l[u] = new Array(i - u - r);var h = t - i + u + 1;for (c = 0; c < i - u - r; ++c) {l[u][c] = (e - _s[h + c]) / (_s[c + t + 1] - _s[h + c]);}}for (var d = a.length, g = new Array(d), p = new Array(i - r + 1), f = 0; f < d; ++f) {for (g[f] = new Array(i - r + o - 1), c = 0; c <= i - r; ++c) {p[c] = n.Vector4.clone(a[f][c]);}for (u = 0; u < o; ++u) {for (c = 0; c < i - u - r; ++c) {n.Vector4.lerp(p[c], p[c], p[c + 1], l[u][c]);}g[f][u] = n.Vector4.clone(p[0]), g[f][i + o - r - u - 2] = n.Vector4.clone(p[i - u - r - 1]);}for (c = o; c < i - r - 1; c++) {g[f][c] = n.Vector4.clone(p[c - o + 1]);}}return g;};t.insertBSurfaceKnotU = function (e, t, r, a, c, u, l, h) {t = Math.min(t, r);var d = h && h.length > 0,g = (0, o.findKnotSpanAndMultiplicity)(e, c);e = g.knot;var p = g.span,f = g.multiplicity,v = t - f;if (e < c[0] + i.PARAMETER_SPACE_TOLERANCE || e > c[c.length - 1] - i.PARAMETER_SPACE_TOLERANCE || f >= t) return { uknots: c.slice(), P: l.slice(), weights: d ? h.slice() : void 0 };var _,y,m = c.length - r - 1,E = u.length - a - 1,x = new Array(E),R = p - r,A = p - f;for (y = 0; y < E; ++y) {for (x[y] = new Array(A - R + 1), _ = R; _ <= A; ++_) {var P = _ * E + y,V = d ? h[P] : 1;x[y][_ - R] = n.Vector4.createFloat64FromValues(V * l[3 * P], V * l[3 * P + 1], V * l[3 * P + 2], V);}}var T = s(e, p, f, v, r, c, x),C = c.slice(0, p + 1);for (_ = 0; _ < v; ++_) {C.push(e);}C = C.concat(c.slice(p + 1));var b,L = new Array(3 * (m + v) * E),O = new Array((m + v) * E);for (y = 0; y < E; ++y) {for (_ = 0; _ <= R; ++_) {P = b = _ * E + y, L[3 * b] = l[3 * P], L[3 * b + 1] = l[3 * P + 1], L[3 * b + 2] = l[3 * P + 2], O[b] = h[P];}for (_ = 0; _ < T[y].length; ++_) {b = (_ + R + 1) * E + y;var S = T[y][_];L[3 * b] = S[0] / S[3], L[3 * b + 1] = S[1] / S[3], L[3 * b + 2] = S[2] / S[3], O[b] = S[3];}for (_ = A; _ < m; ++_) {P = _ * E + y, L[3 * (b = (_ + v) * E + y)] = l[3 * P], L[3 * b + 1] = l[3 * P + 1], L[3 * b + 2] = l[3 * P + 2], O[b] = h[P];}}return { uknots: C, P: L, weights: d ? O : void 0 };}, t.insertBSurfaceKnotV = function (e, t, r, a, c, u, l, h) {t = Math.min(t, a);var d = h && h.length > 0,g = (0, o.findKnotSpanAndMultiplicity)(e, u);e = g.knot;var p = g.span,f = g.multiplicity,v = t - f;if (e < u[0] + i.PARAMETER_SPACE_TOLERANCE || e > u[u.length - 1] - i.PARAMETER_SPACE_TOLERANCE || f >= t) return { vknots: u.slice(), P: l.slice(), weights: d ? h.slice() : void 0 };var _,y,m = c.length - r - 1,E = u.length - a - 1,x = new Array(m),R = p - a,A = p - f;for (_ = 0; _ < m; ++_) {for (x[_] = new Array(A - R + 1), y = R; y <= A; ++y) {var P = _ * E + y,V = d ? h[P] : 1;x[_][y - R] = n.Vector4.createFloat64FromValues(V * l[3 * P], V * l[3 * P + 1], V * l[3 * P + 2], V);}}var T = s(e, p, f, v, a, u, x),C = u.slice(0, p + 1);for (y = 0; y < v; ++y) {C.push(e);}C = C.concat(u.slice(p + 1));var b,L = new Array(3 * m * (E + v)),O = new Array(m * (E + v));for (_ = 0; _ < m; ++_) {for (y = 0; y <= R; ++y) {P = _ * E + y, L[3 * (b = _ * (E + v) + y)] = l[3 * P], L[3 * b + 1] = l[3 * P + 1], L[3 * b + 2] = l[3 * P + 2], O[b] = h[P];}for (y = 0; y < T[_].length; ++y) {b = _ * (E + v) + (y + R + 1);var S = T[_][y];L[3 * b] = S[0] / S[3], L[3 * b + 1] = S[1] / S[3], L[3 * b + 2] = S[2] / S[3], O[b] = S[3];}for (y = A; y < E; ++y) {P = _ * E + y, L[3 * (b = _ * (E + v) + (y + v))] = l[3 * P], L[3 * b + 1] = l[3 * P + 1], L[3 * b + 2] = l[3 * P + 2], O[b] = h[P];}}return { vknots: C, P: L, weights: d ? O : void 0 };}, t.extractBSurfaceParamLineU = function (e, t, r, i, a, c, u) {var l = u && u.length > 0,h = (0, o.findKnotSpanAndMultiplicity)(e, a);e = h.knot;var d,g,p,f = h.span,v = e === a[a.length - 1],_ = v ? r + 1 : h.multiplicity,y = r - _,m = i.length - t - 1,E = a.length - r - 1,x = new Array(3 * m),R = new Array(m);if (_ >= r) for (g = v ? E - 1 : f - r, d = 0; d < m; ++d) {p = d * E + g, x[3 * d] = c[3 * p], x[3 * d + 1] = c[3 * p + 1], x[3 * d + 2] = c[3 * p + 2], R[d] = l ? u[p] : 1;} else {var A = new Array(m),P = f - r,V = f - _;for (d = 0; d < m; ++d) {for (A[d] = new Array(V - P + 1), g = P; g <= V; ++g) {p = d * E + g;var T = l ? u[p] : 1;A[d][g - P] = n.Vector4.createFloat64FromValues(T * c[3 * p], T * c[3 * p + 1], T * c[3 * p + 2], T);}}var C = s(e, f, _, y, r, a, A);for (g = y - 1, d = 0; d < m; ++d) {var b = C[d][g];x[3 * d] = b[0] / b[3], x[3 * d + 1] = b[1] / b[3], x[3 * d + 2] = b[2] / b[3], R[d] = b[3];}}return { ctrlPts: x, weights: l ? R : void 0 };}, t.extractBSurfaceParamLineV = function (e, t, r, i, a, c, u) {var l = u && u.length > 0,h = (0, o.findKnotSpanAndMultiplicity)(e, i);e = h.knot;var d,g,p,f = h.span,v = e === i[i.length - 1],_ = v ? t + 1 : h.multiplicity,y = t - _,m = i.length - t - 1,E = a.length - r - 1,x = new Array(3 * E),R = new Array(E);if (_ >= t) for (d = v ? m - 1 : f - t, g = 0; g < E; ++g) {p = d * E + g, x[3 * g] = c[3 * p], x[3 * g + 1] = c[3 * p + 1], x[3 * g + 2] = c[3 * p + 2], R[g] = l ? u[p] : 1;} else {var A = new Array(E),P = f - t,V = f - _;for (g = 0; g < E; ++g) {for (A[g] = new Array(V - P + 1), d = P; d <= V; ++d) {p = d * E + g;var T = l ? u[p] : 1;A[g][d - P] = n.Vector4.createFloat64FromValues(T * c[3 * p], T * c[3 * p + 1], T * c[3 * p + 2], T);}}var C = s(e, f, _, y, t, i, A);for (d = y - 1, g = 0; g < E; ++g) {var b = C[g][d];x[3 * g] = b[0] / b[3], x[3 * g + 1] = b[1] / b[3], x[3 * g + 2] = b[2] / b[3], R[g] = b[3];}}return { ctrlPts: x, weights: l ? R : void 0 };};}, function (e, t, r) {\"use strict\";Object.defineProperty(t, \"__esModule\", { value: !0 }), t.decomposeBSurfaceToBezier = t.decomposeBSurfaceControlPoints = t.decomposeBSurfaceControlPointsV = t.decomposeBSurfaceControlPointsU = void 0;var n = r(17),o = r(2),i = function i(e, t, r, n) {o.ConsoleUtils.assert(r.length % n == 0);var i = t.length - e - 1;o.ConsoleUtils.assert(r.length / n % i == 0);var s,a,c,u,l = r.length / (n * i),h = e + 1,d = l,g = t.length - 1,p = e,f = e + 1,v = 0,_ = [],y = [];for (y[v] = new Array(h * d * n), s = 0; s <= e; ++s) {for (c = 0; c < l; ++c) {for (u = 0; u < n; ++u) {y[v][(s * d + c) * n + u] = r[(s * l + c) * n + u];}}}for (; f < g;) {for (var m = 1; f < g && t[f + 1] === t[f];) {++f, ++m;}var E = f === g;if (E || (y[v + 1] = new Array(h * d * n)), m < e) {var x = t[f] - t[p];for (a = e; a > m; --a) {_[a - m - 1] = x / (t[p + a] - t[p]);}var R = e - m;for (a = 1; a <= R; ++a) {for (var A = R - a, P = m + a, V = e; V >= P; --V) {var T = _[V - P];for (c = 0; c < l; ++c) {for (u = 0; u < n; ++u) {y[v][(V * d + c) * n + u] = y[v][(V * d + c) * n + u] * T + y[v][((V - 1) * d + c) * n + u] * (1 - T);}}}if (!E) for (c = 0; c < l; ++c) {for (u = 0; u < n; ++u) {y[v + 1][(A * d + c) * n + u] = y[v][(e * d + c) * n + u];}}}}if (E) break;for (++v, s = e - m; s <= e; ++s) {for (c = 0; c < l; ++c) {for (u = 0; u < n; ++u) {y[v][(s * d + c) * n + u] = r[((f - e + s) * l + c) * n + u];}}}p = f, ++f;}return y;},s = function s(e, t, r, n) {o.ConsoleUtils.assert(r.length % n == 0);var i = t.length - e - 1;o.ConsoleUtils.assert(r.length / n % i == 0);var s,a,c,u,l = r.length / (n * i),h = l,d = e + 1,g = t.length - 1,p = e,f = e + 1,v = 0,_ = [],y = [];for (y[v] = new Array(h * d * n), s = 0; s <= e; ++s) {for (c = 0; c < l; ++c) {for (u = 0; u < n; ++u) {y[v][(s + c * d) * n + u] = r[(s + c * i) * n + u];}}}for (; f < g;) {for (var m = 1; f < g && t[f + 1] === t[f];) {++f, ++m;}var E = f === g;if (E || (y[v + 1] = new Array(h * d * n)), m < e) {var x = t[f] - t[p];for (a = e; a > m; --a) {_[a - m - 1] = x / (t[p + a] - t[p]);}var R = e - m;for (a = 1; a <= R; ++a) {for (var A = R - a, P = m + a, V = e; V >= P; --V) {var T = _[V - P];for (c = 0; c < l; ++c) {for (u = 0; u < n; ++u) {y[v][(V + c * d) * n + u] = y[v][(V + c * d) * n + u] * T + y[v][(V - 1 + c * d) * n + u] * (1 - T);}}}if (!E) for (c = 0; c < l; ++c) {for (u = 0; u < n; ++u) {y[v + 1][(A + c * d) * n + u] = y[v][(e + c * d) * n + u];}}}}if (E) break;for (++v, s = e - m; s <= e; ++s) {for (c = 0; c < l; ++c) {for (u = 0; u < n; ++u) {y[v][(s + c * d) * n + u] = r[(f - e + s + c * i) * n + u];}}}p = f, ++f;}return y;},a = function a(e, t, r, n, _a, c) {o.ConsoleUtils.assert(_a.length % c == 0), o.ConsoleUtils.assert(_a.length / c == (r.length - e - 1) * (n.length - t - 1));var u,l = r.length > 2 * e + 2,h = n.length > 2 * t + 2;if (!l && !h) return [[_a.slice()]];u = l ? i(e, r, _a, c) : [_a];for (var d = 0; d < u.length; ++d) {u[d] = h ? s(t, n, u[d], c) : [u[d]];}return u;};t.decomposeBSurfaceControlPointsU = i, t.decomposeBSurfaceControlPointsV = s, t.decomposeBSurfaceControlPoints = a, t.decomposeBSurfaceToBezier = function (e, t, r, i, s, c) {var u,l,h,d,g = c && c.length > 0;if (o.ConsoleUtils.assert(s.length > 0 && s.length % 3 == 0), o.ConsoleUtils.assert(!g || s.length === 3 * c.length), g) {var p = (0, n.controlPointsToHomogeneous)(s, c);for (h = a(e, t, r, i, p, 4), d = [], u = 0; u < h.length; ++u) {for (d[u] = [], l = 0; l < h[u].length; ++l) {var f = (0, n.controlPointsFromHomogeneous)(h[u][l]);h[u][l] = f.P, d[u][l] = f.w;}}} else h = a(e, t, r, i, s, 3), d = void 0;var v = (0, n.getUniqueKnots)(r);o.ConsoleUtils.assert(v.length === h.length + 1);var _ = new Array(v.length - 1);for (u = 0; u < _.length; ++u) {_[u] = new Array(2 * e + 2), _[u].fill(v[u], 0, e + 1), _[u].fill(v[u + 1], e + 1);}var y = (0, n.getUniqueKnots)(i);o.ConsoleUtils.assert(y.length === h[0].length + 1);var m = new Array(y.length - 1);for (u = 0; u < m.length; ++u) {m[u] = new Array(2 * t + 2), m[u].fill(y[u], 0, t + 1), m[u].fill(y[u + 1], t + 1);}return { U: _, V: m, P: h, w: d };};}, function (e, t, r) {\"use strict\";Object.defineProperty(t, \"__esModule\", { value: !0 }), t.closestBSurfacePointApprox = t.closestBSurfacePatches = void 0;var n = r(1),o = r(3),i = r(73),s = r(76);t.closestBSurfacePatches = function (e, t, r) {for (var o = Number.POSITIVE_INFINITY, s = [], a = 0; a < t.length; ++a) {for (var c = 0; c < t[a].length; ++c) {var u,l = t[a][c],h = l.getRangeUnlimitedU(),d = l.getRangeUnlimitedV();if (r) {u = !1;for (var g = 0; g < r.length; ++g) {if (h[1] >= r[g][0][0] + n.FLOAT64_TOLERANCE && h[0] <= r[g][0][1] - n.FLOAT64_TOLERANCE && d[1] >= r[g][1][0] + n.FLOAT64_TOLERANCE && d[0] <= r[g][1][1] - n.FLOAT64_TOLERANCE) {u = !0;break;}}} else u = !0;if (u) {var p = l.getControlPoints(),f = (0, i.minDistanceSqrToHull)(e, p, !0);if (f <= o) {var v = (0, i.maxDistanceSqrToHull)(e, p);s.push({ index: [a, c], minDistSqr: f, maxDistSqr: v }), v < o && (o = v);}}}}return (s = s.filter(function (e) {return e.minDistSqr <= o;})).sort(function (e, t) {var r = e.minDistSqr - t.minDistSqr;return 0 === r ? e.maxDistSqr - t.maxDistSqr : r;}), s;}, t.closestBSurfacePointApprox = function (e, t, r, i, a, c, u, l, h) {var d = t > 1 ? 2 * t : 1,g = r > 1 ? 2 * r : 1,p = (l[1] - l[0]) / (i[i.length - 1] - i[0]),f = (h[1] - h[0]) / (a[a.length - 1] - a[0]);d = Math.max(1, Math.round(d * p)), g = Math.max(1, Math.round(g * f));for (var v = (l[1] - l[0]) / d, _ = (h[1] - h[0]) / g, y = Number.POSITIVE_INFINITY, m = { u: void 0, v: void 0 }, E = void 0, x = n.Vector3.createFloat64(), R = 0; R <= g; ++R) {for (var A = h[0] + R * _, P = [], V = 0; V <= d; ++V) {var T,C,b = l[0] + V * v;P[V] = (0, s.evaluateBSurfacePoint)(b, A, t, r, i, a, c, u), V > 0 && R > 0 && (T = (0, o.closestPointToTriangle)(e, E[V - 1], E[V], P[V - 1], x), (C = n.Vector3.squaredDistance(e, x)) < y && (y = C, m.u = b + v * (T.coordA - 1), m.v = A + _ * (T.coordB - 1)), T = (0, o.closestPointToTriangle)(e, P[V], P[V - 1], E[V], x), (C = n.Vector3.squaredDistance(e, x)) < y && (y = C, m.u = b - v * T.coordA, m.v = A - _ * T.coordB));}E = P;}return m;};}, function (e, t, r) {\"use strict\";Object.defineProperty(t, \"__esModule\", { value: !0 }), t.checkValidity = void 0;var n = r(1),o = r(0),i = r(32),s = r(6),a = r(12),c = r(19);function u(e) {var t = [],r = e.getGuid();return r && \"string\" == typeof r || t.push({ error: \"BaseTopology has invalid GUID\", source: [e] }), t;}function l(e) {var t = u(e),r = 0,n = 0,i = 0,s = e.getLumps();if (s.length > 0) {for (var a = new Set(), c = 0; c < s.length; ++c) {var l = s[c];a.add(l), l && l.getTopologyType() === o.TOPOLOGY_TYPES.LUMP ? l.getBody() !== e && t.push({ error: \"Body is not the parent of child Lump\", source: [e, l] }) : t.push({ error: \"Body has invalid element in Lump array\", source: [e, l] }), r += l.collectFaces().size, n += l.collectEdges().size, i += l.collectVertices().size;}a.size !== s.length && t.push({ error: \"Body has non-unique Lumps\", source: [e] });}return r !== e.collectFaces().size && t.push({ error: \"Body has Lumps which share Faces\", source: [e] }), n !== e.collectEdges().size && t.push({ error: \"Body has Lumps which share Edges\", source: [e] }), i !== e.collectVertices().size && t.push({ error: \"Body has Lumps which share Vertices\", source: [e] }), t;}function h(e) {var t = u(e),r = e.getBody();r && r.getTopologyType() !== o.TOPOLOGY_TYPES.BODY && t.push({ error: \"Lump has invalid parent Body\", source: [e] });var n = 0,i = 0,s = 0,a = e.getShells();if (a.length > 0) {for (var c = new Set(), l = 0; l < a.length; ++l) {var h = a[l];c.add(h), h && h.getTopologyType() === o.TOPOLOGY_TYPES.SHELL ? h.getLump() !== e && t.push({ error: \"Lump is not the parent of child Shell\", source: [e, h] }) : t.push({ error: \"Lump has invalid element in Shell array\", source: [e, h] }), n += h.collectFaces().size, i += h.collectEdges().size, s += h.collectVertices().size;}c.size !== a.length && t.push({ error: \"Lump has non-unique Shells\", source: [e] });} else t.push({ error: \"Lump has no Shells\", source: [e] });return n !== e.collectFaces().size && t.push({ error: \"Lump has Shells which share Faces\", source: [e] }), i !== e.collectEdges().size && t.push({ error: \"Lump has Shells which share Edges\", source: [e] }), s !== e.collectVertices().size && t.push({ error: \"Lump has Shells which share Vertices\", source: [e] }), t;}function d(e) {var t = u(e),r = e.getLump();r && r.getTopologyType() !== o.TOPOLOGY_TYPES.LUMP && t.push({ error: \"Shell has invalid parent Lump\", source: [e] });var n = e.getFaces();if (n.length > 0) {for (var i = new Set(), s = 0; s < n.length; ++s) {var a = n[s];i.add(a), a && a.getTopologyType() === o.TOPOLOGY_TYPES.FACE ? a.getShell() !== e && t.push({ error: \"Shell is not the parent of child Face\", source: [e, a] }) : t.push({ error: \"Shell has invalid element in Face array\", source: [e, a] });}i.size !== n.length && t.push({ error: \"Shell has non-unique Faces\", source: [e] });} else t.push({ error: \"Shell has no Faces\", source: [e] });1 !== (0, c.findConnectedFaces)(e.getFaces()).length && t.push({ error: \"Shell is disconnected\", source: [e] });var l = e.collectVertices(),h = e.collectEdges(),d = new Set(),g = new Set();return l.forEach(function (e) {e.collectEdges(d), e.collectFaces(g);}), d.size !== h.size && t.push({ error: \"Shell has rogue edges\", source: [e] }), l.size > 0 && g.size !== e.getFaces().length && t.push({ error: \"Shell has rogue faces\", source: [e] }), t;}function g(e) {var t = u(e),r = e.getShell();r && r.getTopologyType() !== o.TOPOLOGY_TYPES.SHELL && t.push({ error: \"Face has invalid parent Shell\", source: [e] });var n = 0,i = 0,s = e.getLoops(),c = e.getSurface();if (s.length > 0) {for (var l = new Set(), h = 0; h < s.length; ++h) {var d = s[h];l.add(d), d && d.getTopologyType() === o.TOPOLOGY_TYPES.LOOP ? d.getFace() !== e && t.push({ error: \"Face is not the parent of child Loop\", source: [e, d] }) : t.push({ error: \"Face has invalid element in Loop array\", source: [e, d] }), n += d.collectEdges().size, i += d.collectVertices().size;}l.size !== s.length && t.push({ error: \"Face has non-unique Loops\", source: [e] });} else {var g = c.getGeometryType() === o.GEOMETRY_TYPES.SPHERE,p = c.getGeometryType() === o.GEOMETRY_TYPES.TORUS && c.isDoughnut();g || p || t.push({ error: \"Face has no Loops\", source: [e] });}return n !== e.collectEdges().size && t.push({ error: \"Face has Loops which share Edges\", source: [e] }), i !== e.collectVertices().size && t.push({ error: \"Face has Loops which share Vertices\", source: [e] }), c ? c instanceof a.Surface || t.push({ error: \"Face has invalid Surface geometry\", source: [e, c] }) : t.push({ error: \"Face has no Surface geometry\", source: [e] }), t;}function p(e) {var t = u(e),r = e.getFace();r && r.getTopologyType() !== o.TOPOLOGY_TYPES.FACE && t.push({ error: \"Loop has invalid parent Face\", source: [e] });var n = e.getCoedges();if (n.length > 0) {for (var i = new Set(), s = 0; s < n.length; ++s) {var a = n[s];if (i.add(a), a && a.getTopologyType() === o.TOPOLOGY_TYPES.COEDGE) {a.getLoop() !== e && t.push({ error: \"Loop is not the parent of child Coedge\", source: [e, a] });var c = n[(s + 1) % n.length];a.getEndVertex() !== c.getStartVertex() && t.push({ error: \"Loop has disconnected Coedges\", source: [e, a, c] });} else t.push({ error: \"Loop has invalid element in Coedge array\", source: [e, a] });}i.size !== n.length && t.push({ error: \"Loop has non-unique Coedges\", source: [e] });} else t.push({ error: \"Loop has no Coedges\", source: [e] });return t;}function f(e) {var t = u(e),r = e.getLoop();r && r.getTopologyType() !== o.TOPOLOGY_TYPES.LOOP && t.push({ error: \"Coedge has invalid parent Loop\", source: [e] });var n = e.getBody(),i = new Set(),s = e;do {if (i.has(s)) {t.push({ error: \"Coedge partner list does not form a loop\", source: [e] });break;}if (i.add(s), !s.getPartner()) {s !== e && t.push({ error: \"Coedge has no partner\", source: [e, s] });break;}if ((s = s.getPartner()).getTopologyType() !== o.TOPOLOGY_TYPES.COEDGE) {t.push({ error: \"Coedge has invalid entry in partner list\", source: [e, s] });break;}s.getEdge() !== e.getEdge() && t.push({ error: \"Coedge partner refers to a different Edge\", source: [e, s] }), s.getBody() !== n && t.push({ error: \"Coedge partner is part of a different Body\", source: [e, s] });} while (s !== e);var a = e.getEdge();return a ? a.getTopologyType() !== o.TOPOLOGY_TYPES.EDGE ? t.push({ error: \"Coedge has invalid Edge\", source: [e, a] }) : (s = a.getCoedge()) && i.has(s) || t.push({ error: \"Coedge partner list does not include parent of Edge\", source: [e, a] }) : t.push({ error: \"Coedge has no Edge\", source: [e] }), t;}function v(e) {var t = u(e),r = e.getCoedge(),s = e.getWire();s && r ? t.push({ error: \"Edge has too many parents, both Wire and Coedge\", source: [e] }) : s ? s.getTopologyType() !== o.TOPOLOGY_TYPES.WIRE && t.push({ error: \"Edge has invalid parent Wire\", source: [e] }) : r && r.getTopologyType() !== o.TOPOLOGY_TYPES.COEDGE && t.push({ error: \"Edge has invalid parent Coedge\", source: [e] });for (var a = e.getVertices(), c = 0; c < a.length; ++c) {var l = a[c];l && l.getTopologyType() === o.TOPOLOGY_TYPES.VERTEX ? l.isAdjacentEdge(e) || t.push({ error: \"Edge is not adjacent to own Vertex\", source: [e, l] }) : t.push({ error: \"Edge has invalid Vertex\", source: [e, l] });}var h = e.getCurve();return h ? h instanceof i.Curve ? t = t.concat(function (e, t) {var r = [],i = e.isReversed(),s = e.getRange();if (void 0 === s || 2 !== s.length || void 0 === s[0] || void 0 === s[1] || s[1] < s[0]) return r.push({ error: \"Edge range is not defined\", source: [e, s] }), r;var a = e.getStartVertex(),c = i ? -e.t0() : e.t0(),u = t.evaluatePosition(c),l = Math.max(o.KERNEL_TOLERANCE, a.getPrecision());n.Vector3.equals(a.getPosition(), u, l) || r.push({ error: \"Edge start position not consistent with Vertex\", source: [e, a, u] });var h = e.getEndVertex(),d = i ? -e.t1() : e.t1(),g = t.evaluatePosition(d),p = Math.max(o.KERNEL_TOLERANCE, h.getPrecision());return n.Vector3.equals(h.getPosition(), g, p) || r.push({ error: \"Edge end position not consistent with Vertex\", source: [e, h, g] }), e.isClosed() ? (a !== h && r.push({ error: \"Edge is closed but has different start and end Vertices\", source: [e] }), n.Vector3.equals(u, g, o.KERNEL_TOLERANCE) || r.push({ error: \"Edge is closed but has different start and end positions\", source: [e, u, g] }), t.isClosed() || r.push({ error: \"Edge is closed but its curve is not\", source: [e] })) : (a === h && r.push({ error: \"Edge is open but has same start and end Vertices\", source: [e] }), n.Vector3.equals(u, g, o.KERNEL_TOLERANCE) && r.push({ error: \"Edge is open but has same start and end positions\", source: [e, u, g] })), t.isPeriodic() ? Math.abs(d - c) > t.getPeriod() + o.PARAMETER_SPACE_TOLERANCE && r.push({ error: \"Edge parameter range is longer than curve period\", source: [e] }) : ((c + o.PARAMETER_SPACE_TOLERANCE < t.getRange()[0] || c - o.PARAMETER_SPACE_TOLERANCE > t.getRange()[1]) && r.push({ error: \"Edge start parameter is outside of curve range\", source: [e] }), (d + o.PARAMETER_SPACE_TOLERANCE < t.getRange()[0] || d - o.PARAMETER_SPACE_TOLERANCE > t.getRange()[1]) && r.push({ error: \"Edge end parameter is outside of curve range\", source: [e] })), r;}(e, h)) : t.push({ error: \"Edge has invalid Curve geometry\", source: [e, h] }) : t = t.concat(function (e) {if (e.getWire()) return [{ error: \"Degenerate Edge is part of a Wire\", source: [e] }];if (e.getStartVertex() !== e.getEndVertex()) return [{ error: \"Degenerate Edge has different start and end vertices\", source: [e] }];var t = Array.from(e.collectFaces());if (0 === t.length) return [];if (1 !== t.length) return [{ error: \"Degenerate Edge is part of multiple Faces\", source: [e] }];var r = e.getStartVertex().getPosition(),i = t[0].getSurface(),s = i.getGeometryType();if (s === o.GEOMETRY_TYPES.PLANE || s === o.GEOMETRY_TYPES.CYLINDER || s === o.GEOMETRY_TYPES.ELLIPTICAL_CYLINDER || s === o.GEOMETRY_TYPES.SPHERE) return [{ error: \"Degenerate Edge is on a surface with no singularities\", source: [e, i] }];if (s === o.GEOMETRY_TYPES.CONE || s === o.GEOMETRY_TYPES.ELLIPTICAL_CONE) {if (!(l = i.getApexPosition())) return [{ error: \"Degenerate Edge is on a surface with no singularities\", source: [e, i] }];if (!n.Vector3.equals(r, l, o.KERNEL_TOLERANCE)) return [{ error: \"Degenerate Edge is not at a surface singularity\", source: [e, i] }];} else {if (s !== o.GEOMETRY_TYPES.TORUS) return [{ error: \"Degenerate Edge is not on an analytic surface\", source: [e] }];for (var a = !1, c = i.getSingularUParams(), u = 0; u < c.length; ++u) {var l = i.evaluatePosition(c[u], 0);n.Vector3.equals(r, l, o.KERNEL_TOLERANCE) && (a = !0);}if (!a) return [{ error: \"Degenerate Edge is not at a surface singularity\", source: [e, i] }];}return [];}(e)), t;}function _(e) {var t = u(e),r = e.getEdges();if (r.length > 0) for (var n = e.getBody(), i = 0; i < r.length; ++i) {var a = r[i];a && a.getTopologyType() === o.TOPOLOGY_TYPES.EDGE ? a.getStartVertex() !== e && a.getEndVertex() !== e ? t.push({ error: \"Vertex is not an end-point of adjacent Edge\", source: [e, a] }) : a.getBody() !== n && t.push({ error: \"Vertex has adjacent Edge from a different body\", source: [e, a] }) : t.push({ error: \"Vertex has invalid entry in Edge list\", source: [e, a] });} else t.push({ error: \"Vertex has no adjacent Edges\", source: [e] });var c = e.getPoint();return c ? c instanceof s.Point || t.push({ error: \"Vertex has invalid Point geometry\", source: [e, c] }) : t.push({ error: \"Vertex has no Point geometry\", source: [e] }), t;}function y(e) {var t = u(e),r = 0,n = 0,i = e.getWires();if (i.length > 0) {for (var s = new Set(), a = 0; a < i.length; ++a) {var c = i[a];s.add(c), c && c.getTopologyType() === o.TOPOLOGY_TYPES.WIRE ? c.getWireBody() !== e && t.push({ error: \"WireBody is not the parent of child Wire\", source: [e, c] }) : t.push({ error: \"WireBody has invalid element in Wire array\", source: [e, c] }), r += c.collectEdges().size, n += c.collectVertices().size;}s.size !== i.length && t.push({ error: \"WireBody has non-unique Wires\", source: [e] });} else t.push({ error: \"WireBody has no Wires\", source: [e] });return r !== e.collectEdges().size && t.push({ error: \"WireBody has Wires which share Edges\", source: [e] }), n !== e.collectVertices().size && t.push({ error: \"WireBody has Wires which share Vertices\", source: [e] }), t;}function m(e) {var t = u(e),r = e.getWireBody();r && r.getTopologyType() !== o.TOPOLOGY_TYPES.WIREBODY && t.push({ error: \"Wire has invalid parent WireBody\", source: [e] });var n = e.getEdges();if (n.length > 0) {for (var i = new Set(), s = 0; s < n.length; ++s) {var a = n[s];i.add(a), a && a.getTopologyType() === o.TOPOLOGY_TYPES.EDGE ? a.getWire() !== e && t.push({ error: \"Wire is not the parent of child Edge\", source: [e, a] }) : t.push({ error: \"Wire has invalid element in Edge array\", source: [e, a] });}i.size !== n.length && t.push({ error: \"Wire has non-unique Edges\", source: [e] });var l = (0, c.findConnectedEdges)(n);1 !== l.length ? t.push({ error: \"Wire is not a connected set of Edges\", source: [e] }) : l[0].length !== n.length && t.push({ error: \"Wire is connected to other unknown Edges\", source: [e] });} else t.push({ error: \"Wire has no Edges\", source: [e] });return t;}t.checkValidity = function (e) {for (var t, r, n, i = [], s = [e], a = new Set(), c = new Map(); s.length > 0;) {a.clear();var u = new Set();for (t = 0; t < s.length; ++t) {switch ((r = s[t]).getTopologyType()) {case o.TOPOLOGY_TYPES.BODY:i = i.concat(l(r)), r.getLumps().forEach(function (e) {a.add(e);});break;case o.TOPOLOGY_TYPES.LUMP:i = i.concat(h(r)), r.getShells().forEach(function (e) {a.add(e);});break;case o.TOPOLOGY_TYPES.SHELL:i = i.concat(d(r)), r.getFaces().forEach(function (e) {a.add(e);});break;case o.TOPOLOGY_TYPES.FACE:i = i.concat(g(r)), r.getLoops().forEach(function (e) {a.add(e);}), r.getSurface() && u.add(r.getSurface());break;case o.TOPOLOGY_TYPES.LOOP:i = i.concat(p(r)), r.getCoedges().forEach(function (e) {a.add(e);});break;case o.TOPOLOGY_TYPES.COEDGE:i = i.concat(f(r)), a.add(r.getEdge());break;case o.TOPOLOGY_TYPES.EDGE:i = i.concat(v(r)), r.getVertices().forEach(function (e) {e && a.add(e);}), r.getCurve() && u.add(r.getCurve());break;case o.TOPOLOGY_TYPES.VERTEX:i = i.concat(_(r)), r.getPoint() && u.add(r.getPoint());break;case o.TOPOLOGY_TYPES.WIREBODY:i = i.concat(y(r)), r.getWires().forEach(function (e) {a.add(e);});break;case o.TOPOLOGY_TYPES.WIRE:i = i.concat(m(r)), r.getEdges().forEach(function (e) {a.add(e);});}n = r.getGuid(), c.has(n) ? i.push({ error: \"Objects have clashing GUIDs\", source: [r, c.get(n)] }) : c.set(n, r);}for (u = Array.from(u), t = 0; t < u.length; ++t) {n = (r = u[t]).getGuid(), c.has(n) ? i.push({ error: \"Objects have clashing GUIDs\", source: [r, c.get(n)] }) : c.set(n, r);}s = Array.from(a);}return i;};}, function (e, t, r) {\"use strict\";Object.defineProperty(t, \"__esModule\", { value: !0 }), t.facetPlanarFace = void 0;var n = r(1),o = r(0),i = r(108),s = r(3),a = r(109),c = function (e) {return e && e.__esModule ? e : { default: e };}(r(42)),u = r(8),l = 1e-8,h = o.KERNEL_TOLERANCE,d = function d(e, t, r) {var o,i = e[(0, s.modulus)(t - 1, e.length)],a = e[(0, s.modulus)(t + 1, e.length)],c = e[t],u = c[0] - i[0],l = c[1] - i[1],d = a[0] - c[0],g = a[1] - c[1],p = Math.sqrt(u * u + l * l),f = Math.sqrt(d * d + g * g);u * d + l * g < -.95 * p * f ? (u *= -1, l *= -1) : r ? (o = u, u = -l, l = o, o = d, d = -g, g = o) : (o = u, u = l, l = -o, o = d, d = g, g = -o);var v = .5 * (u / p + d / f),_ = .5 * (l / p + g / f),y = Math.sqrt(v * v + _ * _);e[t] = n.Vector3.clone(c), e[t][0] += h * v / y, e[t][1] += h * _ / y;},g = function g(e) {return String(e[0]) + String(e[1]);},p = function p(e) {for (var t = !1, r = {}, n = 0; n < e.length; n++) {var o = g(e[n]);void 0 === r[o] ? r[o] = [] : t = !0, r[o].push(n);}return { table: r, foundSelfIntersection: t };},f = function f(e) {var t = p(e);if (t.foundSelfIntersection) {for (var r = (0, i.isLoopCCW)(e), n = [], o = 0; o < e.length - 1; o++) {n[o] = !1;}var a = [];for (o = 0; o < e.length - 1; o++) {if (!n[o]) {var c = [],u = o;n[u] = !0, c.push(e[u]);var l = g(c[0]),h = e[(0, s.modulus)(u + 1, e.length)],f = g(h),v = [];for (t.table[l].length > 1 && v.push(0); f !== l;) {if (c.push(h), c.length > e.length) throw new Error(\"splitHole failure\");var _ = t.table[f];if (1 === _.length) u++;else {v.push(c.length - 1);for (var y = [], m = 0; m < _.length; m++) {_[m] !== u && y.push(_[m]);}var E = Math.atan2(e[u + 1][1] - e[u][1], e[u + 1][0] - e[u][0]);E = (0, s.normalizeParameterToShiftedRange)(E - Math.PI, [-Math.PI, Math.PI]);var x = -1,R = 0;for (m = 0; m < y.length; m++) {var A = Math.atan2(e[(0, s.modulus)(y[m] + 1, e.length)][1] - e[y[m]][1], e[(0, s.modulus)(y[m] + 1, e.length)][0] - e[y[m]][0]);A < E && r ? A += s.PI2 : A > E && !r && (A -= s.PI2);var P = Math.abs(A - E);P > R && (R = P, x = y[m]);}u = x;}h = e[(0, s.modulus)(u + 1, e.length)], f = g(h), n[u] = !0;}for (m = 0; m < v.length; m++) {d(c, v[m], r);}a.push(c);}}return a;}return [e];},v = function v(e, t) {for (var r = [], n = 0; n < e.length; n++) {r[n] = { index: void 0, loop: void 0 };for (var o = e[n], i = 0; i < t.length; i++) {for (var s = t[i], a = 0; a < s.length; a++) {if (s[a][0] === o[0] && s[a][1] === o[1]) {r[n].index = a, r[n].loop = s;break;}}}}return r;};function _(e, t) {var r,n = !1,o = t.length,i = o - 1;for (r = 0; r < o; r += 2) {t[r][1] > e[1] != t[i][1] > e[1] && e[0] < (t[i][0] - t[r][0]) * (e[1] - t[r][1]) / (t[i][1] - t[r][1]) + t[r][0] && (n = !n), i = r;}return n;}function y(e, t, r) {for (var o, s, a = v(e, [t].concat(r)), c = [], h = [], d = void 0, g = void 0, p = 0; p < 4; ++p) {a[p] && void 0 !== a[p].index && (d ? g || a[p].loop === d || (g = a[p].loop) : d = a[p].loop, a[p].loop === d ? (o = d, s = c) : (o = g, s = h), (P = [a[p].index - 1, a[p].index])[0] < 0 && (P[0] = o.length - 1), s.push(P), s.push([a[p].index, (a[p].index + 1) % o.length]));}g || (g = d, h = c);var f,y,m = void 0,E = d,x = c;for (p = 0; p < 3; ++p) {for (f = 0; f < c.length; ++f) {for (y = 0; y < h.length && (c === h && y >= f || !(m = (0, i.intersectSegments)(d[c[f][0]], d[c[f][1]], g[h[y][0]], g[h[y][1]], 0)) || !m.intersection); ++y) {;}if (m && m.intersection) break;}if (m && m.intersection || d === g) break;0 === p ? (d = g, c = h) : 1 === p && (d = E, c = x, g = E, h = x);}if (void 0 !== m && m.intersection) {var R = n.Vector3.subtract(n.Vector3.createFloat64(), d[c[f][1]], d[c[f][0]]);n.Vector3.scale(R, R, m.solutions[0]);var A = n.Vector3.add(R, R, d[c[f][0]]);if (c[f][0] > c[f][1]) {var P = c[f][1];c[f][1] = c[f][0], c[f][0] = P;}if (0 === c[f][0] && 1 !== c[f][1] && (c[f][0] = c[f][1], c[f][1] = 0), h[y][0] > h[y][1] && 0 !== h[y][1] && (P = h[y][1], h[y][1] = h[y][0], h[y][0] = P), 0 === h[y][0] && 1 !== h[y][1] && (h[y][0] = h[y][1], h[y][1] = 0), d === g) {if (d.length < 4) return void console.error(\"REGION: Failed to fix loop tessellation! [loop too short]\");console.log(\"REGION: Fixing self-intersection\");var V = new Array(4);c[f][0] < h[y][0] ? (V[0] = c[f][0], V[1] = c[f][1], V[2] = h[y][0], V[3] = h[y][1]) : (V[0] = h[y][0], V[1] = h[y][1], V[2] = c[f][0], V[3] = c[f][1]);var T = [];for (p = 0; p <= V[0]; ++p) {T.push(d[p]);}var C = n.Vector3.subtract(n.Vector3.createFloat64(), d[V[0]], d[V[1]]);n.Vector3.normalize(C, C), n.Vector3.scale(C, C, l);var b = n.Vector3.add(n.Vector3.createFloat64(), A, C);for (T.push(b), p = V[2]; p >= V[1]; --p) {T.push(d[p]);}var L = n.Vector3.subtract(n.Vector3.createFloat64(), A, C);if (T.push(L), V[3] > V[2]) for (p = V[3]; p < d.length; ++p) {T.push(d[p]);}for (d.length = T.length, p = 0; p < T.length; ++p) {d[p] = T[p];}} else {console.log(\"REGION: Fixing loop-loop intersection\");var O = d,S = g,M = h[y][0],w = h[y][1],N = c[f][0],F = c[f][1];(t === S || S.length > O.length && t !== O) && (O = g, S = d, M = c[f][0], w = c[f][1], N = h[y][0], F = h[y][1]);var I = 1;t !== S && t !== O && (I = -1);var D = 1;_(S[w], O) && (D = -1, P = M, M = w, w = P), n.Vector3.subtract(S[w], S[M], S[w]), n.Vector3.normalize(S[w], S[w]), n.Vector3.scale(S[w], S[w], I * l), n.Vector3.add(S[w], A, S[w]);var j,B,U = w;do {(w += D) < 0 ? w = S.length - 1 : w %= S.length;} while (w !== M && !_(S[w], O));(M = w - D) < 0 && (M = S.length - 1), F = N;do {j = O[F], B = O[F = ++F % O.length], m = (0, i.intersectSegments)(j, B, S[M], S[w], 0);} while (N !== F && !m.intersection);m.intersection && (n.Vector3.scale(R, n.Vector3.subtract(R, B, j), m.solutions[0]), n.Vector3.add(A, R, j), n.Vector3.subtract(S[M], S[w], S[M]), n.Vector3.normalize(S[M], S[M]), n.Vector3.scale(S[M], S[M], I * l), n.Vector3.add(S[M], A, S[M])), Math.min(Math.abs(U - M), Math.abs(U - M - S.length)) > 1 && console.warn(\"REGION: Remove loop segment! FIXME!\");}} else u.DebugUtils.warn(\"REGION: Failed to fix loop tessellation! [no intersected segments]\");}var m = function m(e, t) {var r = e;for (r < 0 ? r += t.length : r %= t.length; t[r] !== r;) {r = t[r];}return r;},E = function E(e, t, r, o) {return n.Vector3.distance(r[e], r[t]) < 1e-6 ? (o[0] = e, o[1] = e, 1) : 0;},x = function x(e, t, r, o, i) {var s = new Array(2);if (s[0] = o[e], s[1] = o[r], n.Vector3.length(n.Vector3.subtract(n.Vector3.createFloat64(), s[0], s[1])) < 1e-6) return i[0] = e, i[1] = e, i[2] = e, 2;var a = (s[0][0] - s[1][0]) * (o[t][1] - s[1][1]) - (s[0][1] - s[1][1]) * (o[t][0] - s[1][0]);return a > -l * l && a < l * l ? (i[0] = e, i[1] = e, i[2] = r, 1) : 0;},R = function R(e, t, r, n, o, s) {return (0, i.intersectSegments)(o[e], o[t], o[r], o[n]).intersection ? (s[0] = e, s[1] = t, s[2] = t, s[3] = n, 1) : (s[0] = -1, 0);},A = function A(e) {if (e.length < 4) return e;for (var t, r, n, o, i = e.length, s = new Int32Array(i), a = 0; a < i; ++a) {s[a] = a;}var c,u = new Array(3),l = new Array(3);for (l[0] = 0, l[1] = 0, l[2] = 0, a = 0; a < i; ++a) {t = m(a, s), r = m(a + 1, s), (c = E(t, r, e, u)) && (++l[0], s[t] = u[0], s[r] = u[1], t = m(a += c, s), r = m(a + 1, s)), n = m(a + 2, s), (c = x(t, r, n, e, u)) && (++l[1], s[t] = u[0], s[r] = u[1], s[n] = u[2], t = m(a += c, s), r = m(a + 1, s), n = m(a + 2, s)), o = m(a + 3, s), (c = R(t, r, n, o, e, u)) && (++l[2], s[t] = u[0], s[r] = u[1], s[n] = u[2], s[o] = u[3], a += c);}var h = [];for (a = 0; a < e.length; ++a) {s[a] === a && h.push(e[a]);}return h;},P = function P(e, t, r) {for (var n = v(e, [t].concat(r)), o = 0; o < n.length; o++) {d(n[o].loop, n[o].index, (0, i.isLoopCCW)(n[o].loop));}},V = function V(e, t) {var r = !1;!function (e) {var t = p(e);if (t.foundSelfIntersection) for (var r = (0, i.isLoopCCW)(e), n = c.default.keys(t.table), o = 0; o < n.length; o++) {if (t.table[n[o]].length > 1) for (var s = t.table[n[o]], a = 0; a < s.length; a++) {d(e, s[a], r);}}}(e);for (var n = [], o = 0; o < t.length; o++) {n.push.apply(n, f(t[o]));}var s = A(e),l = [];for (o = 0; o < n.length; o++) {l.push(A(n[o]));}var h = 8;do {r = !0;var g = (0, c.default)(s).map(function (e) {return new a.poly2tri.Point(e[0], e[1]);}),v = new a.poly2tri.SweepContext(g);for (o = 0; o < l.length; o++) {var _ = (0, c.default)(l[o]).map(function (e) {return new a.poly2tri.Point(e[0], e[1]);});v.addHole(_);}try {v.triangulate();} catch (e) {if (\"poly2tri Intersecting Constraints\" === e.message.substr(0, 33)) r = !1, y(e.points, s, l);else if (\"poly2tri EdgeEvent: Collinear not supported\" === e.message.substr(0, 43)) r = !1, P(e.points, s, l);else {if (!e.points) throw e;r = !1, y(e.points, s, l);}}} while (!r && h-- > 0);return h <= 0 && u.DebugUtils.warn(\"Computation of region tessellation failed, due to too many intersections.\"), v;};t.facetPlanarFace = function (e, t) {var r = e.getSurface(),o = (0, s.getPlaneTransforms)(r),a = new i.LoopCalculator(e, o.threeSpaceToUV).getRank0Loops();if (1 !== a.length) throw new Error(\"Each region should have exactly one top-loop\");var c = a[0],u = (0, i.tessellateLoop)(c._loop, t);if (o.threeSpaceToUV) for (var l = 0; l < u.length; l++) {n.Vector3.transformMatrix44(u[l], u[l], o.threeSpaceToUV);}for (var h = [], d = c.getImmediatelyInsideLoops(), g = 0; g < d.length; g++) {var p = (0, i.tessellateLoop)(d[g]._loop, t);if (h.push(p), o.threeSpaceToUV) for (l = 0; l < p.length; l++) {n.Vector3.transformMatrix44(p[l], p[l], o.threeSpaceToUV);}}var f = V(u, h),v = f.getTriangles(),_ = new Uint32Array(3 * v.length),y = new Float32Array(3 * f.pointCount()),m = n.Vector3.createFloat64();for (l = 0; l < f.pointCount(); l++) {var E = f.getPoint(l);n.Vector3.set(m, E.x, E.y, 0), o.uvToThreeSpace && n.Vector3.transformMatrix44(m, m, o.uvToThreeSpace), y[3 * l] = m[0], y[3 * l + 1] = m[1], y[3 * l + 2] = m[2], E.index = l;}for (l = 0; l < v.length; l++) {var x = v[l].getPoints();for (e.isReversed() && x.reverse(), g = 0; g < x.length; g++) {var R = x[g];_[3 * l + g] = R.index;}}return { indexBuffer: _, vertexBuffer: y };};}, function (e, t, r) {\"use strict\";Object.defineProperty(t, \"__esModule\", { value: !0 }), t.LoopCalculator = t.intersectSegments = t.isLoopCCW = t.tessellateLoop = void 0;var n = r(1),o = r(0),i = r(3),s = function s(e, t) {this._loop = e, this._enclosureRank = 0, this._isOuterLoop = !1, this._insideLoops = [], this._isOpen = !1, this._coedges = this._loop.getCoedges();for (var r = 0; r < this._coedges.length; ++r) {this._coedges[r].generateUVCurve(t);}};s.prototype.addInsideLoop = function (e) {this._insideLoops.push(e);}, s.prototype.uvAngleSubtended = function (e) {if (!this.isClosedLoop()) throw new Error(\"uvAngleSubtended cannot work with open loops\");for (var t = 0, r = 0; r < this._coedges.length; r++) {t += this._coedges[r].uvAngleSubtended(e);}return t;}, s.prototype.getArbitraryPointOnLoop = function () {if (1 === this._coedges.length) {var e = this._coedges[0].t0();return this._coedges[0].evaluatePosition(e);}var t = this._coedges[0].getStartVertex();if (t) return t.getPosition();}, s.prototype.isInside = function (e) {var t = this.getArbitraryPointOnLoop(),r = Math.abs(e.uvAngleSubtended(t)),n = Math.floor(r / (2 * Math.PI)),i = r - 2 * n * Math.PI;return !!(Math.abs(i) < o.KERNEL_TOLERANCE && n || Math.abs(i - 2 * Math.PI) < o.KERNEL_TOLERANCE);}, s.prototype.getEnclosureRank = function () {return this._enclosureRank;}, s.prototype.resetEnclosureRank = function () {this._enclosureRank = 0;}, s.prototype.decreaseEnclosureRank = function () {this._enclosureRank--;}, s.prototype.setIsOuterLoop = function (e) {this._isOuterLoop = e;}, s.prototype.isOuterLoop = function () {return this._isOuterLoop;}, s.prototype.isClosedLoop = function () {return !this._isOpen;}, s.prototype.addInsideLoop = function (e) {this._insideLoops.push(e);}, s.prototype.getImmediatelyInsideLoops = function () {for (var e = [], t = 0; t < this._insideLoops.length; t++) {this._insideLoops[t].getEnclosureRank() === this._enclosureRank - 1 && e.push(this._insideLoops[t]);}return e;};var a = function a(e, t) {this._face = e, this._loops = [];for (var r = 0; r < this._face.getLoops().length; ++r) {this._loops.push(new s(this._face.getLoops()[r], t));}this._calcSenses();};a.prototype._calcSenses = function () {for (var e = this._loops.length, t = 0; t < e; t++) {this._loops[t].resetEnclosureRank();}for (t = 0; t < e; t++) {if (this._loops[t].isClosedLoop()) for (var r = 0; r < e; r++) {this._loops[r].isClosedLoop() && t !== r && this._loops[t].isInside(this._loops[r]) && !this._loops[r].isInside(this._loops[t]) && (this._loops[t].decreaseEnclosureRank(), this._loops[r].addInsideLoop(this._loops[t]));}}for (t = 0; t < e; t++) {var n = 0 - this._loops[t].getEnclosureRank();this._loops[t].setIsOuterLoop(n % 2 == 0);}}, a.prototype.getRank0Loops = function () {var e = [];return this._loops.forEach(function (t) {0 === t.getEnclosureRank() && e.push(t);}), e;}, t.tessellateLoop = function (e, t) {for (var r = [], o = 0, i = e.getCoedges().length; o < i; ++o) {var s = e.getCoedges()[o],a = s.getEdge(),c = a.tessellate(void 0, t).positions;c = c.slice(1, c.length - 1), (c = [n.Vector3.clone(a.getStartVertex().getPosition())].concat(c)).push(n.Vector3.clone(a.getEndVertex().getPosition())), s.isReversed() && c.reverse(), r = r.concat(c.slice(0, c.length - 1));}return r;}, t.isLoopCCW = function (e) {for (var t = 0, r = 0; r < e.length; r++) {var n = (r + 1) % e.length;t += e[r][0] * e[n][1] - e[r][1] * e[n][0];}return t > 0;}, t.intersectSegments = function (e, t, r, o, s) {var a = [[t[0] - e[0], -(o[0] - r[0]), r[0] - e[0]], [t[1] - e[1], -(o[1] - r[1]), r[1] - e[1]]],c = (0, i.solveTwoEquationsTwoVariables)(a);if (void 0 === c) return !1;var u = n.Vector3.distance(e, t),l = n.Vector3.distance(r, o);return { intersection: -s < c[0] * u && (c[0] - 1) * u < s && -s < c[1] * l && (c[1] - 1) * l < s, solutions: c };}, t.LoopCalculator = a;}, function (e, t, r) {\"use strict\";var n, o;if (Object.defineProperty(t, \"__esModule\", { value: !0 }), void 0 === i) var i = {},s = { exports: {} };!function (a) {\"object\" == _typeof(i) ? s.exports = a() : void 0 === (o = \"function\" == typeof (n = a) ? n.call(t, r, t, e) : n) || (e.exports = o);}(function () {return function e(t, r, n) {function o(s, a) {if (!r[s]) {if (!t[s]) {if (i) return i(s, !0);throw new Error(\"Cannot find module '\" + s + \"'\");}var c = r[s] = { exports: {} };t[s][0].call(c.exports, function (e) {return o(t[s][1][e] || e);}, c, c.exports, e, t, r, n);}return r[s].exports;}for (var i = !1, s = 0; s < n.length; s++) {o(n[s]);}return o;}({ 1: [function (e, t, r) {t.exports = { version: \"1.3.5\" };}, {}], 2: [function (e, t, r) {var n = function n(e, t) {this.head_ = e, this.tail_ = t, this.search_node_ = e;};n.prototype.head = function () {return this.head_;}, n.prototype.setHead = function (e) {this.head_ = e;}, n.prototype.tail = function () {return this.tail_;}, n.prototype.setTail = function (e) {this.tail_ = e;}, n.prototype.search = function () {return this.search_node_;}, n.prototype.setSearch = function (e) {this.search_node_ = e;}, n.prototype.findSearchNode = function () {return this.search_node_;}, n.prototype.locateNode = function (e) {var t = this.search_node_;if (e < t.value) {for (; t = t.prev;) {if (e >= t.value) return this.search_node_ = t, t;}} else for (; t = t.next;) {if (e < t.value) return this.search_node_ = t.prev, t.prev;}return null;}, n.prototype.locatePoint = function (e) {var t = e.x,r = this.findSearchNode(t),n = r.point.x;if (t === n) {if (e !== r.point) if (e === r.prev.point) r = r.prev;else {if (e !== r.next.point) throw new Error(\"poly2tri Invalid AdvancingFront.locatePoint() call\");r = r.next;}} else if (t < n) for (; (r = r.prev) && e !== r.point;) {;} else for (; (r = r.next) && e !== r.point;) {;}return r && (this.search_node_ = r), r;}, t.exports = n, t.exports.Node = function (e, t) {this.point = e, this.triangle = t || null, this.next = null, this.prev = null, this.value = e.x;};}, {}], 3: [function (e, t, r) {t.exports = function (e, t) {if (!e) throw new Error(t || \"Assert Failed\");};}, {}], 4: [function (e, t, r) {var n = e(\"./xy\"),o = function o(e, t) {this.x = +e || 0, this.y = +t || 0, this._p2t_edge_list = null;};o.prototype.toString = function () {return n.toStringBase(this);}, o.prototype.toJSON = function () {return { x: this.x, y: this.y };}, o.prototype.clone = function () {return new o(this.x, this.y);}, o.prototype.set_zero = function () {return this.x = 0, this.y = 0, this;}, o.prototype.set = function (e, t) {return this.x = +e || 0, this.y = +t || 0, this;}, o.prototype.negate = function () {return this.x = -this.x, this.y = -this.y, this;}, o.prototype.add = function (e) {return this.x += e.x, this.y += e.y, this;}, o.prototype.sub = function (e) {return this.x -= e.x, this.y -= e.y, this;}, o.prototype.mul = function (e) {return this.x *= e, this.y *= e, this;}, o.prototype.length = function () {return Math.sqrt(this.x * this.x + this.y * this.y);}, o.prototype.normalize = function () {var e = this.length();return this.x /= e, this.y /= e, e;}, o.prototype.equals = function (e) {return this.x === e.x && this.y === e.y;}, o.negate = function (e) {return new o(-e.x, -e.y);}, o.add = function (e, t) {return new o(e.x + t.x, e.y + t.y);}, o.sub = function (e, t) {return new o(e.x - t.x, e.y - t.y);}, o.mul = function (e, t) {return new o(e * t.x, e * t.y);}, o.cross = function (e, t) {return \"number\" == typeof e ? \"number\" == typeof t ? e * t : new o(-e * t.y, e * t.x) : \"number\" == typeof t ? new o(t * e.y, -t * e.x) : e.x * t.y - e.y * t.x;}, o.toString = n.toString, o.compare = n.compare, o.cmp = n.compare, o.equals = n.equals, o.dot = function (e, t) {return e.x * t.x + e.y * t.y;}, t.exports = o;}, { \"./xy\": 11 }], 5: [function (e, t, r) {var n = e(\"./xy\"),o = function o(e, t) {this.name = \"PointError\", this.points = t = t || [], this.message = e || \"Invalid Points!\";for (var r = 0; r < t.length; r++) {this.message += \" \" + n.toString(t[r]);}};(o.prototype = new Error()).constructor = o, t.exports = o;}, { \"./xy\": 11 }], 6: [function (e, t, r) {(function (t) {var n = t.poly2tri;r.noConflict = function () {return t.poly2tri = n, r;}, r.VERSION = e(\"../dist/version.json\").version, r.PointError = e(\"./pointerror\"), r.Point = e(\"./point\"), r.Triangle = e(\"./triangle\"), r.SweepContext = e(\"./sweepcontext\");var o = e(\"./sweep\");r.triangulate = o.triangulate, r.sweep = { Triangulate: o.triangulate };}).call(this, \"undefined\" != typeof self ? self : \"undefined\" != typeof window ? window : {});}, { \"../dist/version.json\": 1, \"./point\": 4, \"./pointerror\": 5, \"./sweep\": 7, \"./sweepcontext\": 8, \"./triangle\": 9 }], 7: [function (e, t, r) {var n = e(\"./assert\"),o = e(\"./pointerror\"),i = e(\"./triangle\"),s = e(\"./advancingfront\").Node,a = e(\"./utils\"),c = a.EPSILON,u = a.Orientation,l = a.orient2d,h = a.inScanArea,d = a.isAngleObtuse;function g(e, t) {var r = e.locateNode(t),o = function (e, t, r) {var n = new i(t, r.point, r.next.point);n.markNeighbor(r.triangle), e.addToMap(n);var o = new s(t);return o.next = r.next, o.prev = r, r.next.prev = o, r.next = o, y(e, n) || e.mapTriangleToNodes(n), o;}(e, t, r);return t.x <= r.point.x + c && _(e, r), function (e, t) {for (var r = t.next; r.next && !d(r.point, r.next.point, r.prev.point);) {_(e, r), r = r.next;}for (r = t.prev; r.prev && !d(r.point, r.next.point, r.prev.point);) {_(e, r), r = r.prev;}t.next && t.next.next && function (e) {var t = e.point.x - e.next.next.point.x,r = e.point.y - e.next.next.point.y;return n(r >= 0, \"unordered y\"), t >= 0 || Math.abs(t) < r;}(t) && function (e, t) {for (l(t.point, t.next.point, t.next.next.point) === u.CCW ? e.basin.left_node = t.next.next : e.basin.left_node = t.next, e.basin.bottom_node = e.basin.left_node; e.basin.bottom_node.next && e.basin.bottom_node.point.y >= e.basin.bottom_node.next.point.y;) {e.basin.bottom_node = e.basin.bottom_node.next;}if (e.basin.bottom_node !== e.basin.left_node) {for (e.basin.right_node = e.basin.bottom_node; e.basin.right_node.next && e.basin.right_node.point.y < e.basin.right_node.next.point.y;) {e.basin.right_node = e.basin.right_node.next;}e.basin.right_node !== e.basin.bottom_node && (e.basin.width = e.basin.right_node.point.x - e.basin.left_node.point.x, e.basin.left_highest = e.basin.left_node.point.y > e.basin.right_node.point.y, function e(t, r) {if (!function (e, t) {var r;return r = e.basin.left_highest ? e.basin.left_node.point.y - t.point.y : e.basin.right_node.point.y - t.point.y, e.basin.width > r;}(t, r) && (_(t, r), r.prev !== t.basin.left_node || r.next !== t.basin.right_node)) {if (r.prev === t.basin.left_node) {if (l(r.point, r.next.point, r.next.next.point) === u.CW) return;r = r.next;} else if (r.next === t.basin.right_node) {if (l(r.point, r.prev.point, r.prev.prev.point) === u.CCW) return;r = r.prev;} else r = r.prev.point.y < r.next.point.y ? r.prev : r.next;e(t, r);}}(e, e.basin.bottom_node));}}(e, t);}(e, o), o;}function p(e, t, r) {e.edge_event.constrained_edge = t, e.edge_event.right = t.p.x > t.q.x, v(r.triangle, t.p, t.q) || (function (e, t, r) {e.edge_event.right ? function (e, t, r) {for (; r.next.point.x < t.p.x;) {l(t.q, r.next.point, t.p) === u.CCW ? x(e, t, r) : r = r.next;}}(e, t, r) : function (e, t, r) {for (; r.prev.point.x > t.p.x;) {l(t.q, r.prev.point, t.p) === u.CW ? A(e, t, r) : r = r.prev;}}(e, t, r);}(e, t, r), f(e, t.p, t.q, r.triangle, t.q));}function f(e, t, r, n, i) {if (!v(n, t, r)) {var s = n.pointCCW(i),a = l(r, s, t);if (a === u.COLLINEAR) throw new o(\"poly2tri EdgeEvent: Collinear not supported!\", [r, s, t]);var c = n.pointCW(i),h = l(r, c, t);if (h === u.COLLINEAR) throw new o(\"poly2tri EdgeEvent: Collinear not supported!\", [r, c, t]);a === h ? f(e, t, r, n = a === u.CW ? n.neighborCCW(i) : n.neighborCW(i), i) : V(e, t, r, n, i);}}function v(e, t, r) {var n = e.edgeIndex(t, r);if (-1 !== n) {e.markConstrainedEdgeByIndex(n);var o = e.getNeighbor(n);return o && o.markConstrainedEdgeByPoints(t, r), !0;}return !1;}function _(e, t) {var r = new i(t.prev.point, t.point, t.next.point);r.markNeighbor(t.prev.triangle), r.markNeighbor(t.triangle), e.addToMap(r), t.prev.next = t.next, t.next.prev = t.prev, y(e, r) || e.mapTriangleToNodes(r);}function y(e, t) {for (var r = 0; r < 3; ++r) {if (!t.delaunay_edge[r]) {var n = t.getNeighbor(r);if (n) {var o = t.getPoint(r),i = n.oppositePoint(t, o),s = n.index(i);if (n.constrained_edge[s] || n.delaunay_edge[s]) {t.constrained_edge[r] = n.constrained_edge[s];continue;}if (m(o, t.pointCCW(o), t.pointCW(o), i)) {t.delaunay_edge[r] = !0, n.delaunay_edge[s] = !0, E(t, o, n, i);var a = !y(e, t);return a && e.mapTriangleToNodes(t), (a = !y(e, n)) && e.mapTriangleToNodes(n), t.delaunay_edge[r] = !1, n.delaunay_edge[s] = !1, !0;}}}}return !1;}function m(e, t, r, n) {var o = e.x - n.x,i = e.y - n.y,s = t.x - n.x,a = t.y - n.y,c = o * a - s * i;if (c <= 0) return !1;var u = r.x - n.x,l = r.y - n.y,h = u * i - o * l;return !(h <= 0) && (o * o + i * i) * (s * l - u * a) + (s * s + a * a) * h + (u * u + l * l) * c > 0;}function E(e, t, r, n) {var o, i, s, a, c, u, l, h, d, g, p, f;o = e.neighborCCW(t), i = e.neighborCW(t), s = r.neighborCCW(n), a = r.neighborCW(n), c = e.getConstrainedEdgeCCW(t), u = e.getConstrainedEdgeCW(t), l = r.getConstrainedEdgeCCW(n), h = r.getConstrainedEdgeCW(n), d = e.getDelaunayEdgeCCW(t), g = e.getDelaunayEdgeCW(t), p = r.getDelaunayEdgeCCW(n), f = r.getDelaunayEdgeCW(n), e.legalize(t, n), r.legalize(n, t), r.setDelaunayEdgeCCW(t, d), e.setDelaunayEdgeCW(t, g), e.setDelaunayEdgeCCW(n, p), r.setDelaunayEdgeCW(n, f), r.setConstrainedEdgeCCW(t, c), e.setConstrainedEdgeCW(t, u), e.setConstrainedEdgeCCW(n, l), r.setConstrainedEdgeCW(n, h), e.clearNeighbors(), r.clearNeighbors(), o && r.markNeighbor(o), i && e.markNeighbor(i), s && e.markNeighbor(s), a && r.markNeighbor(a), e.markNeighbor(r);}function x(e, t, r) {r.point.x < t.p.x && (l(r.point, r.next.point, r.next.next.point) === u.CCW ? R(e, t, r) : (function e(t, r, n) {l(n.next.point, n.next.next.point, n.next.next.next.point) === u.CCW ? R(t, r, n.next) : l(r.q, n.next.next.point, r.p) === u.CCW && e(t, r, n.next);}(e, t, r), x(e, t, r)));}function R(e, t, r) {_(e, r.next), r.next.point !== t.p && l(t.q, r.next.point, t.p) === u.CCW && l(r.point, r.next.point, r.next.next.point) === u.CCW && R(e, t, r);}function A(e, t, r) {r.point.x > t.p.x && (l(r.point, r.prev.point, r.prev.prev.point) === u.CW ? P(e, t, r) : (function e(t, r, n) {l(n.prev.point, n.prev.prev.point, n.prev.prev.prev.point) === u.CW ? P(t, r, n.prev) : l(r.q, n.prev.prev.point, r.p) === u.CW && e(t, r, n.prev);}(e, t, r), A(e, t, r)));}function P(e, t, r) {_(e, r.prev), r.prev.point !== t.p && l(t.q, r.prev.point, t.p) === u.CW && l(r.point, r.prev.point, r.prev.prev.point) === u.CW && P(e, t, r);}function V(e, t, r, i, s) {var a = i.neighborAcross(s);n(a, \"FLIP failed due to missing triangle!\");var c = a.oppositePoint(i, s);if (i.getConstrainedEdgeAcross(s)) {var d = i.index(s);throw new o(\"poly2tri Intersecting Constraints\", [s, c, i.getPoint((d + 1) % 3), i.getPoint((d + 2) % 3)]);}h(s, i.pointCCW(s), i.pointCW(s), c) ? (E(i, s, a, c), e.mapTriangleToNodes(i), e.mapTriangleToNodes(a), s === r && c === t ? r === e.edge_event.constrained_edge.q && t === e.edge_event.constrained_edge.p && (i.markConstrainedEdgeByPoints(t, r), a.markConstrainedEdgeByPoints(t, r), y(e, i), y(e, a)) : V(e, t, r, i = function (e, t, r, n, o, i) {var s;return t === u.CCW ? (s = n.edgeIndex(o, i), n.delaunay_edge[s] = !0, y(e, n), n.clearDelaunayEdges(), r) : (s = r.edgeIndex(o, i), r.delaunay_edge[s] = !0, y(e, r), r.clearDelaunayEdges(), n);}(e, l(r, c, t), i, a, s, c), s)) : (function e(t, r, o, i, s, a) {var c = s.neighborAcross(a);n(c, \"FLIP failed due to missing triangle\");var u = c.oppositePoint(s, a);h(o, i.pointCCW(o), i.pointCW(o), u) ? V(t, o, u, c, u) : e(t, r, o, i, c, T(r, o, c, u));}(e, t, r, i, a, T(t, r, a, c)), f(e, t, r, i, s));}function T(e, t, r, n) {var i = l(t, n, e);if (i === u.CW) return r.pointCCW(n);if (i === u.CCW) return r.pointCW(n);throw new o(\"poly2tri [Unsupported] nextFlipPoint: opposing point on constrained edge!\", [t, n, e]);}r.triangulate = function (e) {e.initTriangulation(), e.createAdvancingFront(), function (e) {var t,r = e.pointCount();for (t = 1; t < r; ++t) {for (var n = e.getPoint(t), o = g(e, n), i = n._p2t_edge_list, s = 0; i && s < i.length; ++s) {p(e, i[s], o);}}}(e), function (e) {for (var t = e.front().head().next.triangle, r = e.front().head().next.point; !t.getConstrainedEdgeCW(r);) {t = t.neighborCCW(r);}e.meshClean(t);}(e);};}, { \"./advancingfront\": 2, \"./assert\": 3, \"./pointerror\": 5, \"./triangle\": 9, \"./utils\": 10 }], 8: [function (e, t, r) {var n = e(\"./pointerror\"),o = e(\"./point\"),i = e(\"./triangle\"),s = e(\"./sweep\"),a = e(\"./advancingfront\"),c = a.Node,u = function u(e, t) {if (this.p = e, this.q = t, e.y > t.y) this.q = e, this.p = t;else if (e.y === t.y) if (e.x > t.x) this.q = e, this.p = t;else if (e.x === t.x) throw new n(\"poly2tri Invalid Edge constructor: repeated points!\", [e]);this.q._p2t_edge_list || (this.q._p2t_edge_list = []), this.q._p2t_edge_list.push(this);},l = function l() {this.left_node = null, this.bottom_node = null, this.right_node = null, this.width = 0, this.left_highest = !1;};l.prototype.clear = function () {this.left_node = null, this.bottom_node = null, this.right_node = null, this.width = 0, this.left_highest = !1;};var h = function h(e, t) {t = t || {}, this.triangles_ = [], this.map_ = [], this.points_ = t.cloneArrays ? e.slice(0) : e, this.edge_list = [], this.pmin_ = this.pmax_ = null, this.front_ = null, this.head_ = null, this.tail_ = null, this.af_head_ = null, this.af_middle_ = null, this.af_tail_ = null, this.basin = new l(), this.edge_event = new function () {this.constrained_edge = null, this.right = !1;}(), this.initEdges(this.points_);};h.prototype.addHole = function (e) {this.initEdges(e);var t,r = e.length;for (t = 0; t < r; t++) {this.points_.push(e[t]);}return this;}, h.prototype.AddHole = h.prototype.addHole, h.prototype.addHoles = function (e) {var t,r = e.length;for (t = 0; t < r; t++) {this.initEdges(e[t]);}return this.points_ = this.points_.concat.apply(this.points_, e), this;}, h.prototype.addPoint = function (e) {return this.points_.push(e), this;}, h.prototype.AddPoint = h.prototype.addPoint, h.prototype.addPoints = function (e) {return this.points_ = this.points_.concat(e), this;}, h.prototype.triangulate = function () {return s.triangulate(this), this;}, h.prototype.getBoundingBox = function () {return { min: this.pmin_, max: this.pmax_ };}, h.prototype.getTriangles = function () {return this.triangles_;}, h.prototype.GetTriangles = h.prototype.getTriangles, h.prototype.front = function () {return this.front_;}, h.prototype.pointCount = function () {return this.points_.length;}, h.prototype.head = function () {return this.head_;}, h.prototype.setHead = function (e) {this.head_ = e;}, h.prototype.tail = function () {return this.tail_;}, h.prototype.setTail = function (e) {this.tail_ = e;}, h.prototype.getMap = function () {return this.map_;}, h.prototype.initTriangulation = function () {var e,t = this.points_[0].x,r = this.points_[0].x,n = this.points_[0].y,i = this.points_[0].y,s = this.points_.length;for (e = 1; e < s; e++) {var a = this.points_[e];a.x > t && (t = a.x), a.x < r && (r = a.x), a.y > n && (n = a.y), a.y < i && (i = a.y);}this.pmin_ = new o(r, i), this.pmax_ = new o(t, n);var c = .3 * (t - r),u = .3 * (n - i);this.head_ = new o(t + c, i - u), this.tail_ = new o(r - c, i - u), this.points_.sort(o.compare);}, h.prototype.initEdges = function (e, t) {var r,n = e.length,o = t ? e.length - 1 : e.length;for (r = 0; r < o; ++r) {this.edge_list.push(new u(e[r], e[(r + 1) % n]));}}, h.prototype.getPoint = function (e) {return this.points_[e];}, h.prototype.addToMap = function (e) {this.map_.push(e);}, h.prototype.locateNode = function (e) {return this.front_.locateNode(e.x);}, h.prototype.createAdvancingFront = function () {var e,t,r,n = new i(this.points_[0], this.tail_, this.head_);this.map_.push(n), e = new c(n.getPoint(1), n), t = new c(n.getPoint(0), n), r = new c(n.getPoint(2)), this.front_ = new a(e, r), e.next = t, t.next = r, t.prev = e, r.prev = t;}, h.prototype.removeNode = function (e) {}, h.prototype.mapTriangleToNodes = function (e) {for (var t = 0; t < 3; ++t) {if (!e.getNeighbor(t)) {var r = this.front_.locatePoint(e.pointCW(e.getPoint(t)));r && (r.triangle = e);}}}, h.prototype.removeFromMap = function (e) {var t,r = this.map_,n = r.length;for (t = 0; t < n; t++) {if (r[t] === e) {r.splice(t, 1);break;}}}, h.prototype.meshClean = function (e) {for (var t, r, n = [e]; t = n.pop();) {if (!t.isInterior()) for (t.setInterior(!0), this.triangles_.push(t), r = 0; r < 3; r++) {t.constrained_edge[r] || n.push(t.getNeighbor(r));}}}, t.exports = h;}, { \"./advancingfront\": 2, \"./point\": 4, \"./pointerror\": 5, \"./sweep\": 7, \"./triangle\": 9 }], 9: [function (e, t, r) {var n = function n(e, t, r) {this.points_ = [e, t, r], this.neighbors_ = [null, null, null], this.interior_ = !1, this.constrained_edge = [!1, !1, !1], this.delaunay_edge = [!1, !1, !1];},o = e(\"./xy\").toString;n.prototype.toString = function () {return \"[\" + o(this.points_[0]) + o(this.points_[1]) + o(this.points_[2]) + \"]\";}, n.prototype.getPoint = function (e) {return this.points_[e];}, n.prototype.GetPoint = n.prototype.getPoint, n.prototype.getPoints = function () {return this.points_;}, n.prototype.getNeighbor = function (e) {return this.neighbors_[e];}, n.prototype.containsPoint = function (e) {var t = this.points_;return e === t[0] || e === t[1] || e === t[2];}, n.prototype.containsEdge = function (e) {return this.containsPoint(e.p) && this.containsPoint(e.q);}, n.prototype.containsPoints = function (e, t) {return this.containsPoint(e) && this.containsPoint(t);}, n.prototype.isInterior = function () {return this.interior_;}, n.prototype.setInterior = function (e) {return this.interior_ = e, this;}, n.prototype.markNeighborPointers = function (e, t, r) {var n = this.points_;if (e === n[2] && t === n[1] || e === n[1] && t === n[2]) this.neighbors_[0] = r;else if (e === n[0] && t === n[2] || e === n[2] && t === n[0]) this.neighbors_[1] = r;else {if (!(e === n[0] && t === n[1] || e === n[1] && t === n[0])) throw new Error(\"poly2tri Invalid Triangle.markNeighborPointers() call\");this.neighbors_[2] = r;}}, n.prototype.markNeighbor = function (e) {var t = this.points_;e.containsPoints(t[1], t[2]) ? (this.neighbors_[0] = e, e.markNeighborPointers(t[1], t[2], this)) : e.containsPoints(t[0], t[2]) ? (this.neighbors_[1] = e, e.markNeighborPointers(t[0], t[2], this)) : e.containsPoints(t[0], t[1]) && (this.neighbors_[2] = e, e.markNeighborPointers(t[0], t[1], this));}, n.prototype.clearNeighbors = function () {this.neighbors_[0] = null, this.neighbors_[1] = null, this.neighbors_[2] = null;}, n.prototype.clearDelaunayEdges = function () {this.delaunay_edge[0] = !1, this.delaunay_edge[1] = !1, this.delaunay_edge[2] = !1;}, n.prototype.pointCW = function (e) {var t = this.points_;return e === t[0] ? t[2] : e === t[1] ? t[0] : e === t[2] ? t[1] : null;}, n.prototype.pointCCW = function (e) {var t = this.points_;return e === t[0] ? t[1] : e === t[1] ? t[2] : e === t[2] ? t[0] : null;}, n.prototype.neighborCW = function (e) {return e === this.points_[0] ? this.neighbors_[1] : e === this.points_[1] ? this.neighbors_[2] : this.neighbors_[0];}, n.prototype.neighborCCW = function (e) {return e === this.points_[0] ? this.neighbors_[2] : e === this.points_[1] ? this.neighbors_[0] : this.neighbors_[1];}, n.prototype.getConstrainedEdgeCW = function (e) {return e === this.points_[0] ? this.constrained_edge[1] : e === this.points_[1] ? this.constrained_edge[2] : this.constrained_edge[0];}, n.prototype.getConstrainedEdgeCCW = function (e) {return e === this.points_[0] ? this.constrained_edge[2] : e === this.points_[1] ? this.constrained_edge[0] : this.constrained_edge[1];}, n.prototype.getConstrainedEdgeAcross = function (e) {return e === this.points_[0] ? this.constrained_edge[0] : e === this.points_[1] ? this.constrained_edge[1] : this.constrained_edge[2];}, n.prototype.setConstrainedEdgeCW = function (e, t) {e === this.points_[0] ? this.constrained_edge[1] = t : e === this.points_[1] ? this.constrained_edge[2] = t : this.constrained_edge[0] = t;}, n.prototype.setConstrainedEdgeCCW = function (e, t) {e === this.points_[0] ? this.constrained_edge[2] = t : e === this.points_[1] ? this.constrained_edge[0] = t : this.constrained_edge[1] = t;}, n.prototype.getDelaunayEdgeCW = function (e) {return e === this.points_[0] ? this.delaunay_edge[1] : e === this.points_[1] ? this.delaunay_edge[2] : this.delaunay_edge[0];}, n.prototype.getDelaunayEdgeCCW = function (e) {return e === this.points_[0] ? this.delaunay_edge[2] : e === this.points_[1] ? this.delaunay_edge[0] : this.delaunay_edge[1];}, n.prototype.setDelaunayEdgeCW = function (e, t) {e === this.points_[0] ? this.delaunay_edge[1] = t : e === this.points_[1] ? this.delaunay_edge[2] = t : this.delaunay_edge[0] = t;}, n.prototype.setDelaunayEdgeCCW = function (e, t) {e === this.points_[0] ? this.delaunay_edge[2] = t : e === this.points_[1] ? this.delaunay_edge[0] = t : this.delaunay_edge[1] = t;}, n.prototype.neighborAcross = function (e) {return e === this.points_[0] ? this.neighbors_[0] : e === this.points_[1] ? this.neighbors_[1] : this.neighbors_[2];}, n.prototype.oppositePoint = function (e, t) {var r = e.pointCW(t);return this.pointCW(r);}, n.prototype.legalize = function (e, t) {var r = this.points_;if (e === r[0]) r[1] = r[0], r[0] = r[2], r[2] = t;else if (e === r[1]) r[2] = r[1], r[1] = r[0], r[0] = t;else {if (e !== r[2]) throw new Error(\"poly2tri Invalid Triangle.legalize() call\");r[0] = r[2], r[2] = r[1], r[1] = t;}}, n.prototype.index = function (e) {var t = this.points_;if (e === t[0]) return 0;if (e === t[1]) return 1;if (e === t[2]) return 2;throw new Error(\"poly2tri Invalid Triangle.index() call\");}, n.prototype.edgeIndex = function (e, t) {var r = this.points_;if (e === r[0]) {if (t === r[1]) return 2;if (t === r[2]) return 1;} else if (e === r[1]) {if (t === r[2]) return 0;if (t === r[0]) return 2;} else if (e === r[2]) {if (t === r[0]) return 1;if (t === r[1]) return 0;}return -1;}, n.prototype.markConstrainedEdgeByIndex = function (e) {this.constrained_edge[e] = !0;}, n.prototype.markConstrainedEdgeByEdge = function (e) {this.markConstrainedEdgeByPoints(e.p, e.q);}, n.prototype.markConstrainedEdgeByPoints = function (e, t) {var r = this.points_;t === r[0] && e === r[1] || t === r[1] && e === r[0] ? this.constrained_edge[2] = !0 : t === r[0] && e === r[2] || t === r[2] && e === r[0] ? this.constrained_edge[1] = !0 : (t === r[1] && e === r[2] || t === r[2] && e === r[1]) && (this.constrained_edge[0] = !0);}, t.exports = n;}, { \"./xy\": 11 }], 10: [function (e, t, r) {var n = 1e-16;r.EPSILON = n;var o = { CW: 1, CCW: -1, COLLINEAR: 0 };r.Orientation = o, r.orient2d = function (e, t, r) {var i = (e.x - r.x) * (t.y - r.y) - (e.y - r.y) * (t.x - r.x);return i > -n && i < n ? o.COLLINEAR : i > 0 ? o.CCW : o.CW;}, r.inScanArea = function (e, t, r, o) {return !((e.x - t.x) * (o.y - t.y) - (o.x - t.x) * (e.y - t.y) >= -n || (e.x - r.x) * (o.y - r.y) - (o.x - r.x) * (e.y - r.y) <= n);}, r.isAngleObtuse = function (e, t, r) {var n = t.x - e.x,o = t.y - e.y;return n * (r.x - e.x) + o * (r.y - e.y) < 0;};}, {}], 11: [function (e, t, r) {function n(e) {return \"(\" + e.x + \";\" + e.y + \")\";}t.exports = { toString: function toString(e) {var t = e.toString();return \"[object Object]\" === t ? n(e) : t;}, toStringBase: n, compare: function compare(e, t) {return e.y === t.y ? e.x - t.x : e.y - t.y;}, equals: function equals(e, t) {return e.x === t.x && e.y === t.y;} };}, {}] }, {}, [6])(6);});var a = s.exports;t.poly2tri = a;}, function (e, t, r) {\"use strict\";Object.defineProperty(t, \"__esModule\", { value: !0 }), t.CCI = void 0;var n = r(1),o = r(111),i = r(77),s = function s(e, t, r, n, i) {this._cu1 = e, this._range1 = t, this._cu2 = r, this._range2 = n, this._epsilon = i, this._tree = new o.SubCurveTree(e, t, r, n, i);};s.prototype.intersect = function () {var e = [];this._tree.build();for (var t = 0; t < this._tree._overlaps.length; ++t) {var r = this._tree._overlaps[t][0],n = this._tree._overlaps[t][1];e = e.concat(this._solve(r._range, n._range));}return this._merge(e), e;}, s.prototype._distanceSquared = function (e, t) {var r = this._cu1.evaluatePosition(e),o = this._cu2.evaluatePosition(t);return n.Vector3.squaredDistance(r, o);}, s.prototype._solve = function (e, t) {var r = [],n = [.5 * (e[0] + e[1]), .5 * (t[0] + t[1])],o = this._relaxNR(n, [e, t]),s = o === i.RelaxResult.Success;if (o === i.RelaxResult.OutOfRange) {var a = n[0] < e[0] + 1e-12 || n[0] > e[1] - 1e-12,c = n[1] < t[0] + 1e-12 || n[1] > t[1] - 1e-12;(a || c) && this._distanceSquared(n[0], n[1]) < this._epsilon * this._epsilon && (s = !0);}return s && r.push(new function (e, t) {this.cutInfo = e, this.cutByInfo = t;}({ param: n[0], atVertex: void 0 }, { param: n[1], atVertex: void 0 })), r;}, s.prototype._relaxNR = function (e, t) {var r = this,o = (0, i.newtonRaphson2D)(function (e) {var t = r._cu1.evaluatePosition(e[0]),o = r._cu2.evaluatePosition(e[1]),i = [t[0] - o[0], t[1] - o[1]],s = r._cu1.evaluateDt(e[0]),a = r._cu2.evaluateDt(e[1]);return n.Vector3.negate(a, a), { val: i, deriv1: s, deriv2: a };}, e, t);return e[0] = o.param[0], e[1] = o.param[1], o.status;}, s.prototype._merge = function (e) {e.sort(function (e, t) {return e.cutInfo.param - t.cutInfo.param;});for (var t = 0; t < e.length; t++) {if (e[t]) for (var r = e[t].cutInfo.param, n = e[t].cutByInfo.param, o = t + 1; o < e.length; o++) {if (e[o]) {var i = e[o].cutInfo.param,s = e[o].cutByInfo.param;if (i > r + 1e-11) break;if (Math.abs(s - n) <= 1e-11) {e[t] = void 0;break;}}}}for (t = 0; t < e.length; t++) {e[t] || (e.splice(t, 1), t--);}}, t.CCI = s;}, function (e, t, r) {\"use strict\";Object.defineProperty(t, \"__esModule\", { value: !0 }), t.SubCurveTree = void 0;var n = 100 * r(0).KERNEL_TOLERANCE,o = Math.PI / 180 * 10,i = function i(e, t, r) {void 0 === r && (r = 0), this._cu = e, this._range = t, this._bx = e.getBoundingBox(t).clone(), this._simple = void 0, this._split_param = void 0, this._children = [], this._depth = r;};i.prototype.isSimple = function () {if (void 0 === this._simple) {this._simple = !1;var e = [this._range[0] + 1e-8, this._range[1] - 1e-8];if (this._split_param = this._cu.suggestSplittingParam(e), void 0 === this._split_param) {this._split_param = .5 * (this._range[0] + this._range[1]);var t = this._cu.getTangentCone(this._range);(t.isDegenerate() || t.angle < o) && (this._simple = !0);}}return this._simple;}, i.prototype.canDivide = function () {return !(this._depth >= 10 || this._range[1] - this._range[0] < 2e-8 || Math.max(this._bx.getWidth(0), this._bx.getWidth(1), this._bx.getWidth(2)) < n);}, i.prototype.divide = function () {if (0 === this._children.length) {var e = [this._range[0], this._split_param],t = [this._split_param, this._range[1]];this._children = [new i(this._cu, e, this._depth + 1), new i(this._cu, t, this._depth + 1)];}}, i.prototype.fullSubdivision = function () {if (!this.isSimple() && this.canDivide()) {this.divide();for (var e = 0; e < this._children.length; ++e) {this._children[e].fullSubdivision();}}}, i.prototype.toString = function () {if (this._children.length > 0) {for (var e = \"\", t = 0; t < this._children.length; ++t) {e += this._children[t];}return e;}return \"t=[\" + this._range[0] + \" \" + this._range[1] + \"] \" + this._bx + \"\\n\";};var s = function s(e, t, r, n, o) {this._cu1_root_node = new i(e, t), this._cu2_root_node = new i(r, n), this._epsilon = o, this._overlaps = [];};s.prototype.process = function (e, t) {if (e._bx.intersectsWithTolerance(t._bx, this._epsilon)) {var r = e.canDivide(),n = t.canDivide(),o = e.isSimple() || !r,i = t.isSimple() || !n;if (o && i) this._overlaps.push([e, t]);else if (r && n) {e.divide(), t.divide();for (var s = 0; s < e._children.length; ++s) {for (var a = 0; a < t._children.length; ++a) {this.process(e._children[s], t._children[a]);}}} else if (r) for (e.divide(), s = 0; s < e._children.length; ++s) {this.process(e._children[s], t);} else if (n) for (t.divide(), s = 0; s < t._children.length; ++s) {this.process(e, t._children[s]);}}}, s.prototype.build = function () {this.process(this._cu1_root_node, this._cu2_root_node);}, t.SubCurveTree = s;}, function (e, t, r) {\"use strict\";Object.defineProperty(t, \"__esModule\", { value: !0 }), t.RegionTopologyFace = t.RegionTopologyEdge = t.RegionTopologyVertex = void 0;var n = r(1),o = r(16),i = r(20),s = r(15),a = r(0),c = r(2),u = function (e) {return e && e.__esModule ? e : { default: e };}(r(42)),l = function l(e) {o.Vertex.call(this, e), this._associatedVertices = [];};(l.prototype = Object.create(o.Vertex.prototype)).setAssociatedEntities = function (e) {this._associatedVertices = u.default.clone(e);}, l.prototype.getAssociatedEntities = function () {return this._associatedVertices;};var h = function h(e) {i.Edge.call(this, e), this._sourceEdge = void 0, this._associatedEdges = [], this._isDangling = !1;};(h.prototype = Object.create(i.Edge.prototype)).setAssociatedEdges = function (e) {this._associatedEdges = e;}, h.prototype.getAssociatedEntities = function () {return u.default.map(this._associatedEdges, function (e) {return e.edge;});}, h.prototype.getAssociatedEdgeInfo = function () {return this._associatedEdges;}, h.prototype.setToEdgeSegment = function (e, t) {this._sourceEdge = e, this._curve = e.getCurve(), this._reversed = e.isReversed(), this.setRange(t);}, h.prototype.setIsDangling = function (e) {this._isDangling = e;}, h.prototype.isDangling = function () {return this._isDangling;}, h.prototype.getSourceEdge = function () {return this._sourceEdge;};var d = function d(e) {s.Face.call(this, e), this._danglingEdges = [];};(d.prototype = Object.create(s.Face.prototype)).addDanglingEdge = function (e) {this._danglingEdges.push(e);}, d.prototype.isPointInsideFace = function (e) {for (var t = 0, r = 0; r < this.getLoops().length; ++r) {for (var n = this.getLoops()[r], o = 0; o < n.getCoedges().length; ++o) {var i = n.getCoedges()[o];i.getEdge().isDangling() || (t += i.uvAngleSubtended(e));}}t = Math.abs(t);var s = Math.floor(t / (2 * Math.PI)),c = t - 2 * s * Math.PI;return !!(Math.abs(c) < a.PARAMETER_SPACE_TOLERANCE && s || Math.abs(c - 2 * Math.PI) < a.PARAMETER_SPACE_TOLERANCE);}, d.prototype.getRepresentativePoint = function () {var e,t,r = n.Vector3.createFloat64(),o = this.getBoundingBox(),i = (o.max[0] - o.min[0]) / 33,s = (o.max[1] - o.min[1]) / 33;for (e = 1; e < 32; ++e) {for (t = 1; t < 32; ++t) {if (r[0] = o.min[0] + i * e, r[1] = o.min[1] + s * t, this.isPointInsideFace(r)) return r;}}return c.ConsoleUtils.assert(!1), o.getCenter();}, d.prototype.getDanglingEdges = function () {return this._danglingEdges;}, t.RegionTopologyVertex = l, t.RegionTopologyEdge = h, t.RegionTopologyFace = d;}, function (e, t, r) {\"use strict\";Object.defineProperty(t, \"__esModule\", { value: !0 }), t.matchRegionEdgeRecipe = t.deserializeRegionEdgeRecipe = t.serializeRegionEdgeRecipe = t.createRecipeFromRegionEdge = t.matchRegionFaceRecipe = t.deserializeRegionFaceRecipe = t.serializeRegionFaceRecipe = t.createRecipeFromRegionFace = void 0;var n = r(1),o = r(3),i = r(0),s = r(114),a = r(2),c = r(8),u = function (e) {return e && e.__esModule ? e : { default: e };}(r(42)),l = function l(e, t) {var r = u.default.filter(t.regionVertices, function (t) {return u.default.contains(t.getAssociatedEntities(), e.getStartVertex());});a.ConsoleUtils.assert(1 === r.length), r = r[0];var n = [],o = [],i = new Set(),s = r,c = void 0;if (s) do {n.push(s);var l = u.default.filter(s.getEdges(), function (t) {return t !== c && u.default.contains(t.getAssociatedEntities(), e) && !i.has(t);});if (0 === l.length) {a.ConsoleUtils.assert(!e.isClosed()), a.ConsoleUtils.assert(u.default.contains(s.getAssociatedEntities(), e.getEndVertex()));break;}var h = void 0;if (l.length > 1) {l.sort(function (e, t) {return e.t0() - t.t0();});for (var d = 0; d < l.length; d++) {if (l[d].getStartVertex() === s) {h = l[d];break;}}a.ConsoleUtils.assert(h);} else h = l[0];s = h.getOtherVertex(s), a.ConsoleUtils.assert(s), c = h, i.add(c), o.push(c);} while (s !== r);return { edges: o, vertices: n };},h = function h(e, t, r) {var o = [],s = u.default.filter(t, function (t) {return t !== e;});if (0 === s.length) ;else for (var a = r.vertices, c = 0; c < a.length; c++) {for (var l = a[c], h = !1, d = l.getEdges(), g = 0; g < d.length; g++) {if (u.default.intersection(s, d[g].getAssociatedEntities()).length > 0) {h = !0;break;}}h && o.push({ vertex: l, indexInTopology: c });}if (e.isClosed() && 2 === o.length && 1 === s.length) {var p = !1;if (s[0].getCurveType() === i.GEOMETRY_TYPES.LINE) {var f = s[0],v = f.closestToPointParam(o[0].vertex.getPosition());p = f.closestToPointParam(o[1].vertex.getPosition()) < v;} else if (e.getCurveType() === i.GEOMETRY_TYPES.CIRCLE && s[0].getCurveType() === i.GEOMETRY_TYPES.CIRCLE) {var _ = e.getCurve().getCenter(),y = n.Vector3.sub([0, 0, 0], s[0].getCurve().getCenter(), _);if (n.Vector3.length(y) > 0) {n.Vector3.normalize(y, y);var m = n.Vector3.sub([0, 0, 0], o[0].vertex.getPosition(), _),E = n.Vector3.sub([0, 0, 0], o[1].vertex.getPosition(), _),x = m.x * y.y - m.y * y.x,R = E.x * y.y - E.y * y.x;x > 0 && R < 0 && (p = !0);}}if (p) {var A = o[1];o[1] = o[0], o[0] = A;}}return o;},d = function d(e, t, r, n, o) {var i,a = {};a[e.getGuid()] = { dist: 0, prev: null, prevEdge: null, vertex: e, guid: e.getGuid() };var c = new s.BinaryHeap(function (e) {return e.dist;}, function (e) {return e.guid;});for (c.push(a[e.getGuid()]); 0 !== c.size();) {var l = c.pop();if (l === t) break;i = l.vertex.getEdges();for (var h = 0; h < i.length; h++) {var d = i[h].getOtherVertex(l.vertex);if (d && !n[i[h].getGuid()] && (!r[d.getGuid()] || d === t)) {for (var g = i[h].getEndVertex() === d, p = !1, f = i[h].getAssociatedEntities(), v = 0; v < o.length; v++) {if (u.default.contains(f, o[v].edge) && o[v].orientation === g) {p = !0;break;}}var _ = a[l.guid].dist;p || (_ += 1), void 0 === a[d.getGuid()] ? (a[d.getGuid()] = { dist: _, prev: l, prevEdge: i[h], vertex: d, guid: d.getGuid() }, c.push(a[d.getGuid()])) : a[d.getGuid()].dist > _ && (a[d.getGuid()].dist = _, a[d.getGuid()].prev = l, a[d.getGuid()].prevEdge = i[h], c.updated(a[d.getGuid()]));}}}var y = a[t.getGuid()];if (y) {i = [];for (var m = [], E = y, x = t; E.prevEdge;) {var R = E.prevEdge;i.push(R), E = E.prev, m.push(R.getEndVertex() === x), x = R.getOtherVertex(x);}return { dist: y.dist, edges: i.reverse(), orientations: m.reverse(), startVertex: e, endVertex: t };}return { dist: 1 / 0, edges: [] };},g = function g(e, t, r, n, i, s, a) {for (var c = e[i], l = {}, h = 0; h < c.length; h++) {null !== c[h].endVertex && (l[c[h].endVertex.getGuid()] ? l[c[h].endVertex.getGuid()].incomingEdges.push({ edge: c[h].edge, orientation: c[h].edgeOriented }) : l[c[h].endVertex.getGuid()] = { edgeIndex: h, edgeInfo: c[h], vertex: c[h].endVertex, incomingEdges: [{ edge: c[h].edge, orientation: c[h].edgeOriented }] });}if (u.default.values(l).length > 0) {var g = s.vertices,p = s.edges,f = u.default.keys(l),v = { dist: 1 / 0 },_ = n;do {_ = (0, o.modulus)(_ - 1, e.length);for (var y = u.default.keys(a[_]), m = 0; m < y.length; m++) {var E = a[_][y[m]].vertex;if (E) for (var x = 0; x < f.length; x++) {var R = l[f[x]].vertex,A = a[_][y[m]].outgoingEdges.concat(l[f[x]].incomingEdges),P = d(E, R, g, p, A);P.dist < v.dist && ((v = P).startIndex = _);}}} while (_ !== t && v.dist === 1 / 0);if (v.dist < 1 / 0) {var V = a[v.startIndex][v.startVertex.getGuid()],T = a[i][v.endVertex.getGuid()],C = V.cost + v.dist;(!T || C < T.cost || i === t && v.endVertex.getGuid() === r.getGuid() && null === T.previousGuid) && (a[i][v.endVertex.getGuid()] = { previousGuid: v.startVertex.getGuid(), edgeSegment: null, indexRange: [], cost: V.cost + v.dist, vertex: v.endVertex, previousIndex: v.startIndex, connectionEdges: v.edges, connectionOrientation: v.orientations, outgoingEdges: [] });}}},p = function p(e, t, r, n, i) {var s = [],a = e[t][r].endVertex;s[t] = {}, s[t][a.getGuid()] = { previousGuid: null, edgeSegment: null, previousIndex: null, cost: 0, vertex: a, outgoingEdges: [] };var c = t;do {var l = (0, o.modulus)(c + 1, e.length),h = e[l];s[l] = s[l] || {};for (var d = u.default.keys(s[c]), p = 0, f = 0; f < d.length; f++) {for (var v = d[f], _ = 0; _ < h.length; _++) {if (h[_].startVertices[v]) {s[c][v].outgoingEdges.push({ edge: h[_].edge, orientation: h[_].edgeOriented });var y = h[_].endVertex;if (null !== y) {var m = s[c][v].cost;h[_].edge.isClosed() || h[_].endVertexTopologyIndex > h[_].startVertices[v].vertexIndex !== h[_].edgeOriented && (m += 1), (!s[l][y.getGuid()] || s[l][y.getGuid()].cost > m || l === t && y.getGuid() === a.getGuid() && null === s[l][y.getGuid()].previousGuid) && (s[l][y.getGuid()] = { previousGuid: v, edgeSegment: h[_], indexRange: [h[_].startVertices[v].vertexIndex, h[_].endVertexTopologyIndex], cost: m, vertex: y, previousIndex: c, outgoingEdges: [] }, p++);} else m = s[c][v].cost, (!s[l][v] || s[l][v].cost > m) && (s[l][v] = { previousGuid: v, edgeSegment: h[_], indexRange: [], cost: m, previousIndex: c, outgoingEdges: [] });}}}0 === p && g(e, t, a, c, l, n, s), c = l;} while (c !== t);null !== s[t][a.getGuid()].previousGuid && s[t][a.getGuid()].cost < i.cost && (i.cost = s[t][a.getGuid()].cost, i.state = s, i.startGuid = a.getGuid());},f = function f(e, t) {for (var r = function (e, t) {var r = {},n = {},i = {},s = t;do {var a = (0, o.modulus)(s + 1, e.length),c = e[s],u = e[a],l = i;i = {};for (var h = 0; h < u.length; h++) {var d = u[h].topologyAlongEdge.vertices,g = u[h].topologyAlongEdge.edges;u[h].startVertices = {};var p = void 0,f = void 0,v = c.length;void 0 !== l[u[h].edge.getGuid()] && v++;for (var _ = 0; _ < v; _++) {var y = void 0;if (_ === c.length) y = l[u[h].edge.getGuid()];else {if (!c[_].endVertex) continue;y = c[_].endVertex.getGuid();}for (var m = void 0, E = 0; E < d.length; E++) {if (d[E].getGuid() === y) {m = E;break;}}void 0 !== m && (u[h].startVertices[y] = { vertex: d[m], vertexIndex: m }, null !== u[h].endVertex && (u[h].edgeOriented ? (p = void 0 !== p ? Math.min(p, m) : m, f = void 0 !== f ? Math.max(f, u[h].endVertexTopologyIndex) : u[h].endVertexTopologyIndex) : (p = void 0 !== p ? Math.max(p, m) : m, f = void 0 !== f ? Math.min(f, u[h].endVertexTopologyIndex) : u[h].endVertexTopologyIndex)), void 0 === i[u[h].edge.getGuid()] && (i[u[h].edge.getGuid()] = y));}if (void 0 !== p && void 0 !== f) {if (p !== f) {var x;x = u[h].edge.isClosed() ? u[h].edgeOriented ? 1 : -1 : p < f ? 1 : -1;var R = p;do {if (r[d[R].getGuid()] = d[R], x > 0) R !== f && (n[g[R].getGuid()] = g[R]);else {var A = (0, o.modulus)(R - 1, g.length);n[g[A].getGuid()] = g[A];}R = (0, o.modulus)(R + x, d.length);} while (R !== f);}r[d[f].getGuid()] = d[f];}}s = a;} while (s !== t);return { vertices: r, edges: n };}(e, t), n = { cost: 1 / 0, state: void 0, startGuid: void 0 }, i = 0; i < e[t].length; i++) {null !== e[t][i].endVertex && p(e, t, i, r, n);}if (n.cost === 1 / 0) return { edges: void 0, edgeOrientedFlags: void 0, score: 1 / 0 };var s = function (e, t) {var r = [],n = e.startGuid,i = t;do {r.push(e.state[i][n]);var s = e.state[i][n].previousIndex;n = e.state[i][n].previousGuid, i = s;} while (i !== t);r = r.reverse();var a = [],c = [];for (i = 0; i < r.length; i++) {if (0 !== r[i].indexRange.length) {var u,l,h,d,g = r[i].edgeSegment.topologyAlongEdge;r[i].indexRange[0] < r[i].indexRange[1] ? (u = r[i].indexRange[0], l = r[i].indexRange[1], r[i].edgeSegment.edge.isClosed() && !r[i].edgeSegment.edgeOriented ? (h = -1, u = (0, o.modulus)(r[i].indexRange[0] - 1, g.edges.length), l = (0, o.modulus)(r[i].indexRange[1] - 1, g.edges.length), d = !1) : (h = 1, u = (0, o.modulus)(r[i].indexRange[0], g.edges.length), l = (0, o.modulus)(r[i].indexRange[1], g.edges.length), d = !0)) : r[i].edgeSegment.edge.isClosed() && r[i].edgeSegment.edgeOriented ? (h = 1, u = (0, o.modulus)(r[i].indexRange[0], g.edges.length), l = (0, o.modulus)(r[i].indexRange[1], g.edges.length), d = !0) : (h = -1, u = (0, o.modulus)(r[i].indexRange[0] - 1, g.edges.length), l = (0, o.modulus)(r[i].indexRange[1] - 1, g.edges.length), d = !1);var p = u;do {a.push(g.edges[p]), c.push(d), p = (0, o.modulus)(p + h, g.edges.length);} while (p !== l);} else if (r[i].connectionEdges) for (p = 0; p < r[i].connectionEdges.length; p++) {a.push(r[i].connectionEdges[p]), c.push(r[i].connectionOrientation[p]);}}return { topologyEdges: a, edgeOrientedFlags: c };}(n, t);return { edges: s.topologyEdges, edgeOrientedFlags: s.edgeOrientedFlags, score: n.cost };},v = function v(e, t) {var r,n = function (e, t) {for (var r = [], n = 0; n < e.length; n++) {for (var o = e[n], i = [], s = 0; s < o.length; s++) {var a = o[s],c = t.sketchEdges[a.edgeRef];c && i.push({ edgeRef: a.edgeRef, edgeOriented: a.edgeOriented, intersectionNumber: a.intersectionNumber, totalIntersections: a.totalIntersections, edge: c, topologyAlongEdge: l(c, t), endVertex: null, endVertexTopologyIndex: null });}r.push(i);}return r;}(e, t);if (c.DebugUtils.level(\"region_match\") >= 2) {var o = u.default.pluck(u.default.flatten(n), \"edge\");for (r = 0; r < o.length; r++) {c.DebugUtils.drawEdge3D(o[r], { color: 0, render: !1 });}c.DebugUtils.render();}if (function (e) {for (var t = 0; t < e.length; t++) {for (var r = u.default.pluck(e[(t + 1) % e.length], \"edge\"), n = 0; n < e[t].length; n++) {var o = e[t][n],i = h(o.edge, r, o.topologyAlongEdge);if (0 === o.totalIntersections) o.endVertex = null;else if (i.length === o.totalIntersections) {var s = i[o.intersectionNumber];o.endVertexTopologyIndex = s.indexInTopology, o.endVertex = s.vertex;} else 0 === i.length || c.DebugUtils.warn(\"Region matching problem! Intersection counts do not match\"), o.endVertex = null;}}}(n), c.DebugUtils.level(\"region_match\") >= 2) {var i = u.default.pluck(u.default.flatten(n), \"endVertex\");for (r = 0; r < i.length; r++) {null !== i[r] && c.DebugUtils.drawVertex3D(i[r], { color: 65280, render: !1 });}c.DebugUtils.render();}var s = function (e) {for (var t = 1 / 0, r = void 0, n = 0; n < e.length; n++) {var o = e[n];if (0 !== o.length) {for (var i = 0, s = 0; s < o.length; s++) {null !== o[s].endVertex && i++;}var a = o.length - i;if (0 === a) return n;i > 0 && a < t && (t = a, r = n);}}return r;}(n);if (void 0 === s) {for (var a = 0; a < n[0].length; a++) {var d = n[0][a].edge;if (d.isClosed() && u.default.all(n, function (e) {for (var t = 0; t < e.length; t++) {if (e[t].edge === d) return !0;}return !1;})) {var g = n[0][a].topologyAlongEdge.edges,p = new Array(g.length);for (r = 0; r < p.length; r++) {p[r] = n[0][a].edgeOriented;}return n[0][a].edgeOriented || g.reverse(), c.DebugUtils.level(\"region_match\") >= 2 && c.DebugUtils.drawEdge3D(d, { color: 16711680 }), { edges: g, edgeOrientedFlags: p, matchStatus: 2 };}}return { edges: void 0, edgeOrientedFlags: void 0, matchStatus: 0 };}var v,_ = f(n, s);if (c.DebugUtils.level(\"region_match\") >= 2 && void 0 !== _.edges) {for (r = 0; r < _.edges.length; r++) {c.DebugUtils.drawEdge3D(_.edges[r], { color: 16711680, render: !1 });}c.DebugUtils.render();}return v = 0 === _.score ? 2 : _.score === 1 / 0 ? 0 : 1, { edges: _.edges, edgeOrientedFlags: _.edgeOrientedFlags, matchStatus: v };},_ = function _(e, t) {if (!e || !e.edges) return new Set();for (var r = new Set(), n = 0; n < e.edges.length; n++) {var o = e.edgeOrientedFlags[n] === t,i = e.edges[n].getCoedges();a.ConsoleUtils.assert(i.length >= 1 && i.length <= 2);for (var s = void 0, c = 0; c < i.length; c++) {if (i[c].isReversed() === o) {s = i[c].getFace();break;}}s && !r.has(s) && r.add(s);}var u = new Set(e.edges);return r.forEach(function (e) {for (var t = Array.from(e.collectEdges()), n = 0; n < t.length; n++) {var o = t[n];if (!u.has(o)) {var i = void 0,s = o.getFaces();a.ConsoleUtils.assert(s.length >= 1 && s.length <= 2), 1 === s.length ? a.ConsoleUtils.assert(s[0] === e) : 2 === s.length && (a.ConsoleUtils.assert(s[0] === e || s[1] === e), i = s[0] === e ? s[1] : s[0]), i && !r.has(i) && r.add(i);}}}), r;};t.createRecipeFromRegionFace = function (e, t) {for (var r = [], n = e.getLoops(), o = 0; o < n.length; o++) {for (var i = n[o].getCoedges(), s = [], a = 0; a < i.length; a++) {for (var c = i[a], d = c.getEdge().getAssociatedEdgeInfo(), g = c.getEndVertex(), p = i[(a + 1) % i.length].getEdge().getAssociatedEdgeInfo(), f = u.default.pluck(p, \"edge\"), v = [], _ = 0; _ < d.length; _++) {for (var y = l(d[_].edge, t), m = h(d[_].edge, f, y), E = 0, x = 0; x < m.length; x++) {if (m[x].vertex === g) {E = x;break;}}var R = { edgeRef: d[_].edge.getGuid(), edgeOriented: !(c.isReversed() ^ d[_].flipped), intersectionNumber: E, totalIntersections: m.length, edge: d[_].edge };v.push(R);}s.push(v);}r.push(s);}return r;}, t.serializeRegionFaceRecipe = function (e) {for (var t = [], r = 0; r < e.length; r++) {for (var n = [], o = e[r], i = 0; i < o.length; i++) {for (var s = [], a = o[i], c = 0; c < a.length; c++) {var u = a[c];s.push(u.edgeRef + \"_\" + (u.edgeOriented ? \"t\" : \"f\") + \"_\" + u.intersectionNumber + \"_\" + u.totalIntersections);}n.push(s.join(\";\"));}t.push(n.join(\"+\"));}return t.join(\"/\");}, t.deserializeRegionFaceRecipe = function (e) {for (var t = e.split(\"/\"), r = 0; r < t.length; r++) {t[r] = t[r].split(\"+\");for (var n = t[r], o = 0; o < n.length; o++) {n[o] = n[o].split(\";\");for (var i = n[o], s = 0; s < i.length; s++) {var a = i[s].split(\"_\");i[s] = { edgeRef: a[0], edgeOriented: \"t\" === a[1], intersectionNumber: parseInt(a[2], 10), totalIntersections: parseInt(a[3], 10) };}}}return t;}, t.matchRegionFaceRecipe = function (e, t) {var r,n,o,i = 2,s = [];for (r = 0; r < e.length; r++) {var a = v(e[r], t);if (0 === a.matchStatus && 0 === r) return { regions: [], matchStatus: 0 };2 !== a.matchStatus && (i = 1), s.push(a);}if (c.DebugUtils.level(\"region_match\") > 0) {for (c.DebugUtils.clearView(), o = u.default.values(t.sketchEdges), r = 0; r < o.length; r++) {c.DebugUtils.drawEdge3D(o[r], { color: 0, render: !1 });}for (r = 0; r < s.length; r++) {for (n = 0; n < s[r].edges.length; n++) {var l = 0 === r ? 65280 : 16711680;c.DebugUtils.drawEdge3D(s[r].edges[n], { color: l, render: !1 });}}c.DebugUtils.render();}var h = _(s[0], !1);for (n = 1; n < s.length; n++) {_(s[n], !0).forEach(function (e) {h.delete(e);});}if (h = Array.from(h), c.DebugUtils.level(\"region_match\") > 0) {for (r = 0; r < h.length; r++) {for (o = Array.from(h[r].collectEdges()), n = 0; n < o.length; n++) {c.DebugUtils.drawEdge3D(o[n], { color: 13684736, render: !1 });}}c.DebugUtils.render();}return { regions: h, matchStatus: i };}, t.createRecipeFromRegionEdge = function (e, t) {var r,n,o = { startEdgeRefs: [], endEdgeRefs: [], edgeRef: [], edgeOriented: [], intersectionNumberStart: [], totalIntersectionsStart: [], intersectionNumberEnd: [], totalIntersectionsEnd: [] },i = e.getStartVertex(),s = [];i.getOtherEdges(e).forEach(function (e) {var t = u.default.pluck(e.getAssociatedEdgeInfo(), \"edge\");for (r = 0; r < t.length; r++) {s.indexOf(t[r]) < 0 && (s.push(t[r]), o.startEdgeRefs.push(t[r].getGuid()));}});var a = e.getEndVertex(),c = [];a.getOtherEdges(e).forEach(function (e) {var t = u.default.pluck(e.getAssociatedEdgeInfo(), \"edge\");for (r = 0; r < t.length; r++) {c.indexOf(t[r]) < 0 && (c.push(t[r]), o.endEdgeRefs.push(t[r].getGuid()));}});var d = e.getAssociatedEdgeInfo(),g = u.default.pluck(d, \"edge\");for (r = 0; r < d.length; r++) {var p = g[r],f = !d[r].flipped,v = l(p, t),_ = u.default.unique(s.concat(g)),y = h(p, _, v),m = 0;for (n = 0; n < y.length; n++) {if (y[n].vertex === i) {m = n;break;}}var E = u.default.unique(c.concat(g)),x = h(p, E, v),R = 0;for (n = 0; n < x.length; n++) {if (x[n].vertex === a) {R = n;break;}}o.edgeRef.push(p.getGuid()), o.edgeOriented.push(f), o.intersectionNumberStart.push(m), o.totalIntersectionsStart.push(y.length), o.intersectionNumberEnd.push(R), o.totalIntersectionsEnd.push(x.length);}return o;}, t.serializeRegionEdgeRecipe = function (e) {var t = { edge: e.edgeRef, orient: e.edgeOriented, start: e.startEdgeRefs, end: e.endEdgeRefs, sIdx: e.intersectionNumberStart, sNum: e.totalIntersectionsStart, eIdx: e.intersectionNumberEnd, eNum: e.totalIntersectionsEnd };return JSON.stringify(t);}, t.deserializeRegionEdgeRecipe = function (e) {var t = JSON.parse(e);return { edgeRef: t.edge, edgeOriented: t.orient, startEdgeRefs: t.start, endEdgeRefs: t.end, intersectionNumberStart: t.sIdx, totalIntersectionsStart: t.sNum, intersectionNumberEnd: t.eIdx, totalIntersectionsEnd: t.eNum };}, t.matchRegionEdgeRecipe = function (e, t) {var r = [],n = 0,o = [];e.startEdgeRefs.forEach(function (e) {var r = t.sketchEdges[e];r && o.push(r);});var i = [];e.endEdgeRefs.forEach(function (e) {var r = t.sketchEdges[e];r && i.push(r);}), e.edgeRef.forEach(function (e) {var r = t.sketchEdges[e];r && o.indexOf(r) < 0 && o.push(r), r && i.indexOf(r) < 0 && i.push(r);});for (var s = 0; s < e.edgeRef.length; s++) {var a = t.sketchEdges[e.edgeRef[s]];if (a) {var u = l(a, t),d = void 0,g = void 0,p = h(a, o, u);if (0 === e.totalIntersectionsStart[s]) d = u.vertices[0], g = 0;else if (p.length === e.totalIntersectionsStart[s]) {var f = p[e.intersectionNumberStart[s]];d = f.vertex, g = f.indexInTopology;}var v = void 0,_ = void 0,y = h(a, i, u);if (0 === e.totalIntersectionsEnd[s]) v = u.vertices[0], _ = u.vertices.length;else if (y.length === e.totalIntersectionsEnd[s]) {var m = y[e.intersectionNumberEnd[s]];v = m.vertex, 0 === (_ = m.indexInTopology) && a.isClosed() && (_ = u.vertices.length);}if (!e.edgeOriented[s]) {var E = d;d = v, v = E, E = g, g = _, _ = E;}if (d && v) {if (!(g >= _)) {r = u.edges.slice(g, _), n = 2;break;}c.DebugUtils.warn(\"Edge recipe match should find start vertex before end vertex\");}}}return { edges: r, matchStatus: n };};}, function (e, t, r) {\"use strict\";Object.defineProperty(t, \"__esModule\", { value: !0 });var n = function n(e, t) {this.content = [], this.scoreFunction = e, this.lookupFunction = t, this.lookupFunction && (this.nodeDict = {});};n.prototype = { push: function push(e) {this.content.push(e), this.lookupFunction && (this.nodeDict[this.lookupFunction(e)] = this.content.length - 1), this.bubbleUp(this.content.length - 1);}, pop: function pop() {var e = this.content[0],t = this.content.pop();return this.content.length > 0 && (this.content[0] = t, this.lookupFunction && (this.nodeDict[this.lookupFunction(t)] = 0), this.sinkDown(0)), this.lookupFunction && delete this.nodeDict[this.lookupFunction(e)], e;}, peek: function peek() {return this.content[0];}, getNodeIndex: function getNodeIndex(e) {if (this.lookupFunction) return this.nodeDict[this.lookupFunction(e)];for (var t = this.content.length, r = 0; r < t; r++) {if (this.content[r] === e) return r;}throw new Error(\"Node not found.\");}, updated: function updated(e) {var t = this.getNodeIndex(e),r = this.scoreFunction(e),n = Math.floor((t + 1) / 2) - 1,o = this.content[n];if (t > 0 && r < this.scoreFunction(o)) this.bubbleUp(t);else {var i = 2 * (t + 1),s = i - 1,a = this.content[s],c = this.content[i];(a && r > this.scoreFunction(a) || c && r > this.scoreFunction(c)) && this.sinkDown(t);}}, remove: function remove(e) {var t = this.content.length,r = this.getNodeIndex(e),n = this.content.pop();r !== t - 1 && (this.content[r] = n, this.scoreFunction(n) < this.scoreFunction(e) ? this.bubbleUp(r) : this.sinkDown(r));}, size: function size() {return this.content.length;}, bubbleUp: function bubbleUp(e) {for (var t = this.content[e]; e > 0;) {var r = Math.floor((e + 1) / 2) - 1,n = this.content[r];if (!(this.scoreFunction(t) < this.scoreFunction(n))) break;this.content[r] = t, this.content[e] = n, this.lookupFunction && (this.nodeDict[this.lookupFunction(t)] = r, this.nodeDict[this.lookupFunction(n)] = e), e = r;}}, sinkDown: function sinkDown(e) {for (var t = this.content.length, r = this.content[e], n = this.scoreFunction(r);;) {var o = 2 * (e + 1),i = o - 1,s = null;if (i < t) {var a = this.content[i],c = this.scoreFunction(a);c < n && (s = i);}if (o < t) {var u = this.content[o];this.scoreFunction(u) < (null === s ? n : c) && (s = o);}if (null === s) break;this.content[e] = this.content[s], this.content[s] = r, this.lookupFunction && (this.nodeDict[this.lookupFunction(this.content[e])] = e, this.nodeDict[this.lookupFunction(this.content[s])] = s), e = s;}} }, t.BinaryHeap = n;}, function (e, t, r) {\"use strict\";Object.defineProperty(t, \"__esModule\", { value: !0 }), t.createBlock = void 0;var n = r(28),o = r(83),i = r(0),s = r(2);t.createBlock = function (e, t) {var r = [Math.min(e[0], t[0]), Math.min(e[1], t[1]), Math.min(e[2], t[2])],a = [Math.max(e[0], t[0]), Math.max(e[1], t[1]), Math.max(e[2], t[2])];s.ConsoleUtils.assert(a[0] - r[0] > i.KERNEL_TOLERANCE, \"block is degenerate in x axis\"), s.ConsoleUtils.assert(a[1] - r[1] > i.KERNEL_TOLERANCE, \"block is degenerate in y axis\"), s.ConsoleUtils.assert(a[2] - r[2] > i.KERNEL_TOLERANCE, \"block is degenerate in z axis\");var c = [[r[0], r[1], r[2]], [a[0], r[1], r[2]], [a[0], a[1], r[2]], [r[0], a[1], r[2]]],u = (0, n.createFaceFromPolyline)(c),l = a[2] - r[2];return (0, o.extrudeFace)(u, l);};}, function (e, t, r) {\"use strict\";Object.defineProperty(t, \"__esModule\", { value: !0 }), t.createCylinder = t.createCone = void 0;var n = r(1),o = r(28),i = r(0),s = r(18),a = r(51),c = r(38),u = r(39),l = r(52),h = r(13),d = r(15),g = r(26),p = r(25),f = r(24),v = r(2),_ = function _(e, t, r, _2, y, m) {var E = e,x = t,R = Math.abs(r),A = void 0 === _typeof(_2) ? R : Math.abs(_2);if (R < i.KERNEL_TOLERANCE) {E = t, x = e;var P = R;R = A, A = P;}v.ConsoleUtils.assert(R > i.KERNEL_TOLERANCE);var V = n.Vector3.createFloat64();n.Vector3.subtract(V, x, E);var T = n.Vector3.length(V);v.ConsoleUtils.assert(T > i.KERNEL_TOLERANCE), n.Vector3.scale(V, V, 1 / T);var C = A - R,b = Math.abs(C) > i.KERNEL_TOLERANCE,L = 0;b && (L = Math.atan2(C, T));var O,S = n.Vector3.createFloat64();m && n.Vector3.subtract(S, m, n.Vector3.scale(S, V, n.Vector3.dot(m, V))), (!m || n.Vector3.squaredLength(S) < i.KERNEL_TOLERANCE * i.KERNEL_TOLERANCE) && n.Vector3.computeOrthogonal(S, V), n.Vector3.normalize(S, S), n.Vector3.scale(S, S, R);var M = y || 1;v.ConsoleUtils.assert(M > 0 && M <= 1);var w = Math.max(R, A);Math.abs(w * (1 - M)) < i.KERNEL_TOLERANCE ? b ? (O = new a.Cone()).set(E, R, V, L, S, 1) : (O = new c.Cylinder()).set(E, R, V, S, 1) : b ? (O = new l.EllipticalCone()).set(E, S, M, V, L, 1) : (O = new u.EllipticalCylinder()).set(E, S, M, V, 1);var N = [0, T / Math.cos(L)];O.limitRangeU(N);var F = (0, o.makeConeOrCylinderVParamLoop)(O, N[0]),I = (0, o.makeConeOrCylinderVParamLoop)(O, N[1]);F.getCoedges()[0].setReversed(!0);var D = [];D[0] = new d.Face(), D[0].setSurface(O), D[0].addLoops([F, I]);var j = F.getCoedges()[0].getEdge();if (j.getCurve()) {var B = new h.Loop();B.addCoedge((0, o.createCoedgeOnEdge)(j)), (G = new d.Face()).addLoop(B);var U = new s.Plane();U.set(E, V), G.setSurface(U), G.setReversed(!0), D.push(G), v.ConsoleUtils.assert(B.getCoedges()[0].uvAngleSubtended(E) < -i.KERNEL_TOLERANCE);}var k = I.getCoedges()[0].getEdge();if (k.getCurve()) {var G,z = new h.Loop();z.addCoedge((0, o.createCoedgeOnEdge)(k)), (G = new d.Face()).addLoop(z);var Y = new s.Plane();Y.set(x, V), G.setSurface(Y), D.push(G), v.ConsoleUtils.assert(z.getCoedges()[0].uvAngleSubtended(x) < -i.KERNEL_TOLERANCE);}var K = new g.Shell();K.addFaces(D);var q = new p.Lump();q.addShell(K);var W = new f.Body();return W.addLump(q), W;};t.createCone = _, t.createCylinder = function (e, t, r, n, o) {return _(e, t, r, r, n, o);};}, function (e, t, r) {\"use strict\";Object.defineProperty(t, \"__esModule\", { value: !0 }), t.createPolyhedron = void 0;var n = r(24),o = r(25),i = r(15),s = r(13),a = r(16),c = r(18),u = r(6),l = r(28),h = r(3),d = r(2),g = r(8);function p(e, t) {var r,n = e.getCommonEdges(t);d.ConsoleUtils.assert(n.length <= 1), r = 0 === n.length ? (0, l.createLineEdgeBetweenVertices)(e, t) : n[0];var o = (0, l.createCoedgeOnEdge)(r);return d.ConsoleUtils.assert(o.getStartVertex() === e), d.ConsoleUtils.assert(o.getEndVertex() === t), o;}function f(e, t) {var r,n = [];for (r = 0; r < t.length; ++r) {n[r] = e[t[r]];}var o = (0, h.definePlaneThroughPoints)(n);if (o) {var i = new c.Plane();return i.set(o.origin, o.normal, o.uAxis), i.limitRangeU(o.uRange), i.limitRangeV(o.vRange), i;}g.DebugUtils.warn(\"Face is degenerate\");}t.createPolyhedron = function (e, t) {var r,c = [];for (r = 0; r < e.length; ++r) {var h = new a.Vertex(new u.Point(e[r]));c.push(h);}var g = [];for (r = 0; r < t.length; ++r) {var v = t[r];d.ConsoleUtils.assert(v.length >= 3);for (var _ = new s.Loop(), y = [], m = 0; m < v.length; ++m) {var E = v[m],x = v[(m + 1) % v.length];d.ConsoleUtils.assert(E >= 0 && E < e.length), d.ConsoleUtils.assert(x >= 0 && x < e.length);var R = p(c[E], c[x]);y.push(R);}_.addCoedges(y);var A = f(e, v),P = new i.Face(A);P.addLoop(_), g.push(P);}var V = (0, l.createShellsFromFaces)(g),T = [];for (r = 0; r < V.length; ++r) {T[r] = new o.Lump(), T[r].addShell(V[r]);}var C = new n.Body();return C.addLumps(T), C;};}, function (e, t, r) {\"use strict\";Object.defineProperty(t, \"__esModule\", { value: !0 }), t.TopologyStitcher = void 0;var n = r(1),o = r(119),i = r(41),s = r(2),a = function a() {this._shellSet = new Set(), this._lumpSet = new Set(), this._bodySet = new Set(), this._wireSet = new Set(), this._progenitorMap = new i.ProgenitorMap();};a.prototype.initMerge = function () {this._shellSet.clear(), this._lumpSet.clear(), this._bodySet.clear(), this._wireSet.clear();}, a.prototype.getEdgeOwnerToMerge = function (e) {var t = e.getWire();if (t) this._wireSet.add(t);else {var r = function (e) {var t = e.getCoedge();if (t) {var r = t.getFace();if (r) return r.getShell();}}(e);r && this._shellSet.add(r);}}, a.prototype.getVertexOwnerToMerge = function (e) {var t = e.getEdges();t.length > 0 && this.getEdgeOwnerToMerge(t[0]);}, a.prototype.stitchVertices = function (e, t) {var r;this.initMerge();var n = void 0;for (r = 0; r < e.length; ++r) {if (!t || !t.has(e[r])) {n = e[r];break;}}s.ConsoleUtils.assert(n);var o = [];for (r = 0; r < e.length; ++r) {if (this.getVertexOwnerToMerge(e[r]), e[r] !== n) {for (var i = e[r], a = i.getEdges().slice(0), c = 0; c < a.length; ++c) {var u = a[c];u.getStartVertex() === i && u.setStartVertex(n), u.getEndVertex() === i && u.setEndVertex(n);}s.ConsoleUtils.assert(0 === i.getEdges().length), t && t.has(i) || o.push(i);}}o.length > 0 && this._progenitorMap.addEntry(n, o), this.mergeTopology();}, a.prototype.stitchEdges = function (e, t) {var r,o = e[0];for (r = 0; r < e.length; ++r) {if (!t || !t.has(e[r])) {o = e[r];break;}}var i = [],s = [];for (r = 0; r < e.length; ++r) {var a = e[r],c = !1;if (a.getStartVertex() !== o.getStartVertex() && a.getStartVertex() === o.getEndVertex()) {var u = a.evaluateDt(a.t0()),l = o.evaluateDt(o.t1());n.Vector3.dot(u, l) < 0 && (c = !0);}for (var h = a.getCoedge(); h;) {i.push(h), c && h.setReversed(!h.isReversed()), (h = h.getPartner()) === a.getCoedge() && (h = void 0);}a !== o && (a.setStartVertex(null), a.setEndVertex(null), s.push(a));}for (this.initMerge(), r = 0; r < i.length; ++r) {var d = i[r];this.getEdgeOwnerToMerge(d.getEdge()), d.setEdge(o);var g = (r + 1) % i.length;d.setPartner(i[g]);}this.mergeTopology(), this._progenitorMap.addEntry(o, s);}, a.prototype.mergeTopology = function () {if (this._shellSet.size > 1 && this.mergeShells(), this._wireSet.size > 1) throw new Error(\"Merging wires in TopologyStitcher is not yet supported.\");}, a.prototype.mergeShells = function () {var e = new i.ProgenitorMap();if (this._shellSet.size > 1) {var t = Array.from(this._shellSet),r = t[0],n = r.getLump();n && this._lumpSet.add(n);for (var o = 1; o < t.length; ++o) {var s = t[o];r.addFaces(s.getFaces()), s.setFaces([]), (n = s.getLump()) && (n.removeShell(s), this._lumpSet.add(n));}e.addEntry(r, t.slice(1));}if (this._lumpSet.size > 1) {var a = Array.from(this._lumpSet),c = a[0],u = c.getBody();for (u && this._bodySet.add(u), o = 1; o < a.length; ++o) {var l = a[o];c.addShells(l.getShells()), l.setShells([]), (u = l.getBody()) && (u.removeLump(l), this._bodySet.add(u));}e.addEntry(c, a.slice(1));}if (this._bodySet.size > 1) {var h = Array.from(this._bodySet),d = h[0];for (o = 1; o < h.length; ++o) {for (var g = h[o], p = g.getLumps().slice(0), f = 0; f < p.length; ++f) {p[f].getShells().length > 0 && d.addLump(p[f]);}g.setLumps([]);}e.addEntry(d, h.slice(1));}e.size() > 0 && (this._progenitorMap = e.collapseMaps(this._progenitorMap, { keepIntermediates: !0, keepAllDescendants: !0 }));}, a.prototype.getProgenitorMap = function () {return this._progenitorMap;}, a.prototype.stitchTwoEdgeSets = function (e, t) {var r = new o.MatchFinder();r.setEdges(e, t), r.compute();for (var n = r.getVertexMatches(), i = r.getEdgeMatches(), s = r.getNewVertices(), a = new Set(r.getEdgeProgenitors().getAllNewTopology()), c = 0; c < n.length; ++c) {this.stitchVertices(n[c], s);}for (c = 0; c < i.length; ++c) {this.stitchEdges(i[c], a);}this._progenitorMap = this._progenitorMap.collapseMaps(r.getEdgeProgenitors(), { keepIntermediates: !1, keepAllDescendants: !0 });}, a.prototype.stitchTwoTopology = function (e, t) {s.ConsoleUtils.assert(\"function\" == typeof e.collectEdges), s.ConsoleUtils.assert(\"function\" == typeof t.collectEdges);var r = e.collectEdges(),n = t.collectEdges();this.stitchTwoEdgeSets(r, n);}, a.prototype.stitchEdgeSet = function (e) {this.stitchTwoEdgeSets(e, e);}, t.TopologyStitcher = a;}, function (e, t, r) {\"use strict\";Object.defineProperty(t, \"__esModule\", { value: !0 }), t.MatchFinder = void 0;var n = r(1),o = r(0),i = r(120),s = r(82),a = r(41),c = r(2),u = function u() {this._edges1 = [], this._edges2 = [], this._verts1 = [], this._verts2 = [], this._vertexMatchMap = new Map(), this._edgeMatchMap = new Map(), this._sameEdgeLists = !1, this._newVertices = new Set(), this._edgeProgenitors = new a.ProgenitorMap();};u.prototype.addMergeToMap = function (e, t, r) {var n = r.get(e),o = r.get(t);if (n && !o) n.push(t), r.set(t, n);else if (!n && o) o.push(e), r.set(e, o);else if (n || o) {if (n && o && n !== o) for (var i = 0; i < o.length; ++i) {n.push(o[i]), r.set(o[i], n);}} else {var s = [e, t];r.set(e, s), r.set(t, s);}}, u.prototype.addVertexMerge = function (e, t) {this.addMergeToMap(e, t, this._vertexMatchMap);}, u.prototype.addEdgeMerge = function (e, t) {this.addMergeToMap(e, t, this._edgeMatchMap);}, u.prototype.verticesMatch = function (e, t) {var r = Math.max(e.getPrecision(), t.getPrecision(), o.KERNEL_TOLERANCE);return n.Vector3.squaredDistance(e.getPosition(), t.getPosition()) < r * r;}, u.prototype.findEdgeSplitParam = function (e, t) {var r = e.getStartVertex();if (r !== t) {var i = e.getEndVertex();if (i !== t) {var s = this._vertexMatchMap.get(r);if (!s || -1 === s.indexOf(t)) {var a = this._vertexMatchMap.get(i);if (!a || -1 === a.indexOf(t)) {var c = t.getPosition(),u = Math.max(t.getPrecision(), o.KERNEL_TOLERANCE),l = e.closestToPointParam(c);if (void 0 !== l) {var h = e.evaluatePosition(l);if (!(n.Vector3.squaredDistance(c, h) > u * u)) return { param: l, position: h };}}}}}}, u.prototype.matchVertices = function () {for (var e = new Set(), t = 0; t < this._edges1.length; ++t) {this._edges1[t].collectVertices(e);}this._verts1 = Array.from(e);var r = new Set();for (t = 0; t < this._edges2.length; ++t) {this._edges2[t].collectVertices(r);}this._verts2 = Array.from(r);var n = this;e.forEach(function (e) {r.forEach(function (t) {e !== t && n.verticesMatch(e, t) && n.addVertexMerge(e, t);});});}, u.prototype.findVertexOnEdgeSplits = function (e, t) {for (var r = t.length, n = 0; n < r; ++n) {for (var o = t[n], i = [], s = 0; s < e.length; ++s) {var a = e[s],c = this.findEdgeSplitParam(o, a);c && i.push({ vertex: a, param: c.param, position: c.position });}if (i.length > 0) {var u = this.splitEdgeAtParams(o, i);if (u.length > 0) {t[n] = u[0];for (var l = 1; l < u.length; ++l) {t.push(u[l]);}}}}}, u.prototype.doEdgeSplits = function () {this.findVertexOnEdgeSplits(this._verts1, this._edges2), this._sameEdgeLists || this.findVertexOnEdgeSplits(this._verts2, this._edges1);}, u.prototype.splitEdgeAtParams = function (e, t) {t.sort(function (e, t) {return e.param - t.param;});for (var r = [], s = e, a = 0; a < t.length; ++a) {var c = t[a].vertex,u = t[a].param,l = t[a].position,h = s.getStartVertex().getPosition();if (n.Vector3.squaredDistance(l, h) < o.KERNEL_TOLERANCE * o.KERNEL_TOLERANCE) this.addVertexMerge(c, s.getStartVertex());else {0 === r.length && (s = (0, i.replaceEdge)(s), r.push(s), this._edgeProgenitors.addEntry(s, [e]));var d = (0, i.splitEdge)(s, u, l);r.push(d), this._edgeProgenitors.addEntry(d, [e]);var g = d.getStartVertex();this.addVertexMerge(c, g), this._newVertices.add(g), s = d;}}return r;}, u.prototype.edgesMatch = function (e, t) {return (0, s.edgesAreCoincident)(e, t);}, u.prototype.matchEdges = function () {for (var e = 0; e < this._edges1.length; ++e) {for (var t = this._edges1[e], r = t.getStartVertex(), n = t.getEndVertex(), o = 0; o < this._edges2.length; ++o) {var i = this._edges2[o],s = i.getStartVertex(),a = i.getEndVertex();if (!(this._sameEdgeLists && o <= e) && t !== i) {var c,u = r === s || r === a;if (!u) {var l = this._vertexMatchMap.get(r);l && (u = l === this._vertexMatchMap.get(s) || l === this._vertexMatchMap.get(a));}if (u && !(c = n === s || n === a)) {var h = this._vertexMatchMap.get(n);h && (c = h === this._vertexMatchMap.get(s) || h === this._vertexMatchMap.get(a));}u && c && this.edgesMatch(t, i) && this.addEdgeMerge(t, i);}}}}, u.prototype.setEdges = function (e, t) {e instanceof Set ? this._edges1 = Array.from(e) : e instanceof Array && (this._edges1 = e), t && t !== e ? t instanceof Set ? this._edges2 = Array.from(t) : t instanceof Array && (this._edges2 = t) : this._edges2 = this._edges1, this._sameEdgeLists = this._edges1 === this._edges2, c.ConsoleUtils.assert(this._edges1 && this._edges2);}, u.prototype.compute = function () {this.matchVertices(), this.doEdgeSplits(), this.matchEdges();}, u.prototype.getVertexMatches = function () {var e = new Set();return this._vertexMatchMap.forEach(function (t, r) {e.add(t);}), Array.from(e);}, u.prototype.getEdgeMatches = function () {var e = new Set();return this._edgeMatchMap.forEach(function (t, r) {e.add(t);}), Array.from(e);}, u.prototype.getNewVertices = function () {return this._newVertices;}, u.prototype.getEdgeProgenitors = function () {return this._edgeProgenitors;}, t.MatchFinder = u;}, function (e, t, r) {\"use strict\";Object.defineProperty(t, \"__esModule\", { value: !0 }), t.replaceEdge = t.splitEdge = void 0;var n = r(16),o = r(20),i = r(27),s = r(6),a = function a(e, t) {var r = new i.Coedge();r.setEdge(t), e.getEdge().getCoedge() === e && t.setCoedge(r), r.setReversed(e.isReversed()), r.setLoop(e.getLoop());var n = e.getLoop().getCoedges(),o = n.indexOf(e);return r.isReversed() ? n.splice(o, 0, r) : n.splice((o + 1) % n.length, 0, r), r;};t.splitEdge = function (e, t, r) {var i = new n.Vertex(new s.Point(r)),c = [e.getRange()[0], e.getRange()[1]],u = e.getEndVertex();e.setRange([c[0], t]), e.setEndVertex(i);var l = new o.Edge();l.setCurve(e.getCurve()), l.setReversed(e.isReversed()), l.setRange([t, c[1]]), l.setStartVertex(i), l.setEndVertex(u), l.setPrecision(e.getPrecision()), l.setWire(e.getWire());for (var h = [], d = e.getCoedge(); d;) {h.push(a(d, l)), (d = d.getPartner()) === e.getCoedge() && (d = void 0);}for (var g = 0; g < h.length; ++g) {var p = (g + 1) % h.length;h[g].setPartner(h[p]);}if (l.getWire()) {var f = l.getWire().getEdges().slice(),v = f.indexOf(e);f.splice(v + 1, 0, l), l.getWire().setEdges(f);}return l;}, t.replaceEdge = function (e) {var t = new o.Edge();t.setCurve(e.getCurve()), t.setReversed(e.isReversed()), t.setRange([e.getRange()[0], e.getRange()[1]]), t.setStartVertex(e.getStartVertex()), t.setEndVertex(e.getEndVertex()), t.setPrecision(e.getPrecision()), t.setCoedge(e.getCoedge()), t.setWire(e.getWire()), e.setStartVertex(null), e.setEndVertex(null), e.setCoedge(void 0), e.setWire(void 0);for (var r = t.getCoedge(); r;) {r.setEdge(t), (r = r.getPartner()) === t.getCoedge() && (r = void 0);}if (t.getWire()) {var n = t.getWire().getEdges().slice();n[n.indexOf(e)] = t, t.getWire().setEdges(n);}return t;};}, function (e, t, r) {\"use strict\";Object.defineProperty(t, \"__esModule\", { value: !0 }), t.svgFromWire = void 0;var n = r(0),o = r(2);t.svgFromWire = function (e) {e.getTopologyType() === n.TOPOLOGY_TYPES.WIREBODY && console.warn(\"svgFromWire: Pass a wire, not a wire body.\"), o.ConsoleUtils.assert(e.getTopologyType() === n.TOPOLOGY_TYPES.WIRE, \"Input topology is not a Wire\");var t = e.getOrderedEdges();if (0 === t.edges.length) return \"\";for (var r = t.start, i = r.getPosition(), s = \"M \" + i[0] + \" \" + i[1], a = 0; a < t.edges.length; ++a) {var c = t.edges[a];i = (r = r === c.getStartVertex() ? c.getEndVertex() : c.getStartVertex()).getPosition();var u = c.getCurve();if (u) if (u.getGeometryType() === n.GEOMETRY_TYPES.LINE) s += \" L \" + i[0] + \" \" + i[1];else if (u.getGeometryType() !== n.GEOMETRY_TYPES.BCURVE || 3 !== u.getDegree() || u.isRational()) console.warn(\"Unhandled curve type in svgFromWire\");else {for (var l = [], h = u.getBezierSegments(), d = 0; d < h.length; d++) {var g = h[d];if (g) for (var p = g.getControlPoints(), f = 0; f < p.length; f += 3) {l.push([p[f], p[f + 1]]);}}r === c.getStartVertex() !== c.isReversed() && l.reverse(), o.ConsoleUtils.assert(l.length === 4 * h.length, \"Unexpected number of control points\");for (var v = 0; v < h.length; ++v) {s += \" C \" + l[4 * v + 1][0] + \" \" + l[4 * v + 1][1] + \" \" + l[4 * v + 2][0] + \" \" + l[4 * v + 2][1] + \" \", v === h.length - 1 ? s += i[0] + \" \" + i[1] : s += l[4 * v + 3][0] + \" \" + l[4 * v + 3][1];}}}return s;};}, function (e, t, r) {\"use strict\";Object.defineProperty(t, \"__esModule\", { value: !0 }), t.Path2D = void 0;var n = r(1),o = r(0),i = r(54),s = r(40),a = r(33),c = r(14),u = r(23),l = r(7),h = r(28),d = r(84),g = r(2),p = r(8),f = { assert: function assert(e, t) {if (!e) throw { message: t || \"assertion failed\" };}, assert_arg: function assert_arg(e, t, r, n) {var o = \"Invalid argument '\" + t + \"': \" + r + \"\\nUsage: \" + n;this.assert(e, o);}, assert_number: function assert_number(e, t, r) {this.assert_arg(\"number\" == typeof e, t, \"should be a number\", r);}, assert_boolean: function assert_boolean(e, t, r) {this.assert_arg(\"boolean\" == typeof e, t, \"should be a boolean\", r);}, assert_string: function assert_string(e, t, r) {this.assert_arg(\"string\" == typeof e, t, \"should be a string\", r);} },v = function v() {this._wireBody = new i.WireBody(), this._curves = [], this._xy = [0, 0], this._mergeBCurves = !0, this._healPath = !1, this._tangentTol = o.KERNEL_ANGULAR_TOLERANCE;};function _(e, t, r) {var o = 3 * (t - 1),i = [e[o], e[o + 1], e[o + 2]],s = 3 * r,a = [e[s], e[s + 1], e[s + 2]],c = n.Vector3.sub([0, 0, 0], a, i);n.Vector3.scale(c, c, -.1);for (var u = 1; u <= r - t; ++u) {var l = n.Vector3.scaleAndAdd([0, 0, 0], a, c, u);e[s - 3 * u] = l[0], e[s - 3 * u + 1] = l[1], e[s - 3 * u + 2] = l[2];}}function y(e, t, r) {var o = 3 * t,i = [e[o], e[o + 1], e[o + 2]],s = 3 * (r + 1),a = [e[s], e[s + 1], e[s + 2]],c = n.Vector3.sub([0, 0, 0], a, i);n.Vector3.scale(c, c, .1);for (var u = 1; u <= r - t; ++u) {var l = n.Vector3.scaleAndAdd([0, 0, 0], i, c, u);e[o + 3 * u] = l[0], e[o + 3 * u + 1] = l[1], e[o + 3 * u + 2] = l[2];}}function m(e, t) {for (var r, o, i, s = [], a = e.getControlPoints(), c = [a[0], a[1], a[2]], u = a.length / 3, l = 1; l < u; ++l) {r = [a[3 * l], a[3 * l + 1], a[3 * l + 2]];var h = l === u - 1;n.Vector3.squaredDistance(c, r) < t ? (void 0 === o && (o = l - 1), i = l) : h = !0, h && void 0 !== o && void 0 !== i && (s.push([o, i]), h = !1, o = void 0, i = void 0), c = r;}return s;}function E(e, t) {var r = m(e, t);if (1 === r.length && r[0][1] - r[0][0] == 1) {var n = r[0];0 === n[0] ? e.addControlPointOnCurve(e.evaluatePosition(.1)) : n[1] === e.getNumControlPoints() - 1 ? e.addControlPointOnCurve(e.evaluatePosition(.9)) : (e.addControlPointOnCurve(e.evaluatePosition(.45)), e.addControlPointOnCurve(e.evaluatePosition(.55)));}return r.length > 0;}function x(e, t) {for (var r = m(e, t), n = 0; n < r.length; ++n) {var o = r[n],i = e.getControlPoints().slice();o[0] > 0 ? _(i, o[0], o[1]) : o[1] < i.length / 3 - 1 ? y(i, o[0], o[1]) : p.DebugUtils.warn(\"Degenerate BCurve!\"), e.setControlPoints(i);}}function R(e, t) {var r = e.getControlPoints(),o = [r[0], r[1], r[2]],i = [r[3], r[4], r[5]],s = n.Vector3.distance(o, i);r[3] = o[0] + t[0] * s, r[4] = o[1] + t[1] * s, r[5] = o[2] + t[2] * s, e.setControlPoints(r);}function A(e, t) {var r = e.getControlPoints(),o = e.getControlPoints().length,i = [r[o - 6], r[o - 5], r[o - 4]],s = [r[o - 3], r[o - 2], r[o - 1]],a = n.Vector3.distance(i, s);r[o - 6] = s[0] - t[0] * a, r[o - 5] = s[1] - t[1] * a, r[o - 4] = s[2] - t[2] * a, e.setControlPoints(r);}function P(e) {var t = new a.BCurve(),r = e.getRange(),o = e.evaluatePosition(r[0]),i = e.evaluatePosition(r[1]),s = n.Vector3.lerp([0, 0, 0], o, i, 1 / 3),c = n.Vector3.lerp([0, 0, 0], o, i, 2 / 3),u = [o[0], o[1], 0, s[0], s[1], 0, c[0], c[1], 0, i[0], i[1], 0];return t.set(u, [1, 1, 1, 1], 3, [0, 0, 0, 0, 1, 1, 1, 1]), t;}function V(e, t) {for (var r, o = e.getRange(), i = e.evaluatePosition(o[0]), s = e.evaluatePosition(o[1]), a = n.Vector3.distance(i, s), c = 0, u = t.getControlPoints(), l = [u[0], u[1], u[2]], h = u.length / 3, d = 1; d < h; ++d) {r = [u[3 * d], u[3 * d + 1], u[3 * d + 2]], c += n.Vector3.distance(l, r), l = r;}return a < c;}function T(e, t) {var r = e.getControlPoints().concat(t.getControlPoints().slice(3)),o = e.getWeights().concat(t.getWeights().slice(1)),i = e.getKnotVector().slice(0, -1),s = e.evaluateDt(e.getRange()[1]),a = t.evaluateDt(t.getRange()[0]),c = Math.sqrt(n.Vector3.squaredLength(a) / n.Vector3.squaredLength(s)),u = i[i.length - 1] - t.getKnotVector()[0] * c,l = t.getKnotVector().slice(t.getDegree() + 1);return l = l.map(function (e) {return e * c + u;}), i = i.concat(l), e.set(r, o, 3, i), e;}function C(e, t, r, i, s) {var a = n.Vector2.subtract([], s, e),u = n.Vector2.length(a);if (!(u < o.KERNEL_TOLERANCE)) {u > 2 * t && (t = u / 2);var l = n.Vector2.scaleAndAdd([], e, a, .5);if (u < 2 * t - n.FLOAT64_TOLERANCE) {var h = Math.sqrt(t * t - u * u / 4);!0 === i != (!1 === r) && (h = -h);var d = n.Vector2.normalize([], [-a[1], a[0]]);n.Vector2.scaleAndAdd(l, l, d, h);}var g = [0, 0, i ? 1 : -1],p = new c.Circle();p.set([l[0], l[1], 0], g, [t, 0, 0]);var f = p.closestToPointParam([e[0], e[1], 0]),v = p.closestToPointParam([s[0], s[1], 0]);return v <= f && (v += 2 * Math.PI), p.limitRange([f, v]), p;}}function b(e, t) {var r = e.slice(1);r = r.replace(/([^e])-/g, \"$1 -\");for (var n = 0; n < 2; ++n) {r = r.replace(/\\.[0-9]*\\./g, function (e) {return e.slice(0, -1) + \" .\";});}for (var o = r.split(/[,\\s]/), i = [], s = 0; s < o.length; ++s) {if (o[s].length > 0) {var a = Number(o[s]);t(!isNaN(a), \"could not parse command\"), i.push(a);}}return i;}v.prototype.numWires = function () {var e = this._wireBody.getWires().length;return this._curves.length > 0 && (e += 1), e;}, v.prototype.numClosed = function () {for (var e = 0, t = 0; t < this._wireBody.getWires().length; ++t) {this._wireBody.getWires()[t].isClosed() && (e += 1);}return this._areCurvesClosed() && (e += 1), e;}, v.prototype._fixCoincidentControlPoints = function () {for (var e = o.KERNEL_TOLERANCE * o.KERNEL_TOLERANCE, t = 0; t < this._curves.length; ++t) {var r = this._curves[t];r.getGeometryType() === o.GEOMETRY_TYPES.BCURVE && 3 === r.getDegree() && 4 === r.getNumControlPoints() && !1 === r.isRational() && E(r, e) && x(r, e);}}, v.prototype._snapBCurvesTangent = function () {for (var e = 0; e < this._curves.length; ++e) {var t = (e + 1) % this._curves.length;if (0 === t && !this._areCurvesClosed()) break;var r = this._curves[e],i = this._curves[t],s = r.evaluateDt(r.getRange()[1]),a = i.evaluateDt(i.getRange()[0]);n.Vector3.isParallel(s, a, 1, this._tangentTol) && (r.getGeometryType() !== o.GEOMETRY_TYPES.BCURVE && i.getGeometryType() === o.GEOMETRY_TYPES.BCURVE ? (n.Vector3.normalize(s, s), R(i, s)) : r.getGeometryType() === o.GEOMETRY_TYPES.BCURVE && i.getGeometryType() !== o.GEOMETRY_TYPES.BCURVE && (n.Vector3.normalize(a, a), A(r, a)));}}, v.prototype._areCurvesClosed = function () {if (0 === this._curves.length) return !1;var e = this._curves[this._curves.length - 1],t = this._curves[0];return n.Vector3.squaredDistance(e.evaluatePosition(e.getRange()[1]), t.evaluatePosition(t.getRange()[0])) < o.KERNEL_TOLERANCE * o.KERNEL_TOLERANCE;}, v.prototype._mergeShortLinesWithBCurves = function () {for (var e = !1, t = 0; t < this._curves.length; ++t) {var r = (t + 1) % this._curves.length;if (0 === r && !this._areCurvesClosed()) break;var i = this._curves[t],s = this._curves[r],a = i.evaluateDt(i.getRange()[1]),c = s.evaluateDt(s.getRange()[0]);n.Vector3.isParallel(a, c, 1, o.KERNEL_ANGULAR_TOLERANCE) && (i.getGeometryType() === o.GEOMETRY_TYPES.LINE && s.getGeometryType() === o.GEOMETRY_TYPES.BCURVE && V(i, s) ? (this._curves.splice(t, 1, T(P(i), s)), this._curves.splice(r, 1), t -= 1, e = !0) : i.getGeometryType() === o.GEOMETRY_TYPES.BCURVE && s.getGeometryType() === o.GEOMETRY_TYPES.LINE && V(s, i) && (this._curves.splice(t, 1, T(i, P(s))), this._curves.splice(r, 1), t -= 1, e = !0));}return e;}, v.prototype._mergeAdjacentBCurves = function () {for (var e = 0; e < this._curves.length; ++e) {var t = (e + 1) % this._curves.length;if (0 === t && !this._areCurvesClosed()) break;var r = this._curves[e],i = this._curves[t],s = r.evaluateDt(r.getRange()[1]),a = i.evaluateDt(i.getRange()[0]);n.Vector3.isParallel(s, a, 1, this._tangentTol) && r.getGeometryType() === o.GEOMETRY_TYPES.BCURVE && i.getGeometryType() === o.GEOMETRY_TYPES.BCURVE && (n.Vector3.squaredLength(s) < n.Vector3.squaredLength(a) ? (n.Vector3.normalize(s, s), R(i, s)) : (n.Vector3.normalize(a, a), A(r, a)), r !== i && (T(r, i), this._curves.splice(t, 1), e -= 1));}}, v.prototype.setMergeBCurves = function (e) {this._mergeBCurves = e;}, v.prototype.setHealForASM = function (e, t) {this._healPath = e, this._tangentTol = void 0 !== t ? t : .01745240643728351;}, v.prototype._addWire = function () {if (0 !== this._curves.length) {this._healPath && (this._fixCoincidentControlPoints(), this._snapBCurvesTangent()), (this._mergeBCurves || this._healPath) && this._mergeAdjacentBCurves(), this._healPath && this._mergeShortLinesWithBCurves() && this._mergeAdjacentBCurves();var e = (0, h.createWiresFromEdges)((0, h.createEdgesFromCurves)(this._curves));g.ConsoleUtils.assert(1 === e.length), this._wireBody.addWire(e[0]), this._curves = [];}}, v.prototype._discardIfOpen = function () {if (0 !== this._curves.length) {var e = this._curves[0].evaluatePosition(this._curves[0].getRange()[0]),t = [this._xy[0], this._xy[1], 0];n.Vector3.squaredDistance(e, t) >= o.KERNEL_TOLERANCE * o.KERNEL_TOLERANCE && (this._curves = []);}}, v.prototype.moveTo = function (e, t) {var r = \"Path2D.moveTo(x, y)\";return f.assert_number(e, \"x\", r), f.assert_number(t, \"y\", r), this._addWire(), this._xy[0] = e, this._xy[1] = t, this;}, v.prototype.lineTo = function (e, t) {var r = \"Path2D.lineTo(x, y)\";f.assert_number(e, \"x\", r), f.assert_number(t, \"y\", r);var n = e - this._xy[0],i = t - this._xy[1];if (n * n + i * i > o.KERNEL_TOLERANCE * o.KERNEL_TOLERANCE) {var s = new l.Line();s.set([this._xy[0], this._xy[1], 0], [n, i, 0]), s.limitRange([0, 1]), this._curves.push(s);}return this._xy[0] = e, this._xy[1] = t, this;}, v.prototype.quadraticCurveTo = function (e, t, r, n) {var o = \"Path2D.quadraticCurveTo(cpx, cpy, x, y)\";f.assert_number(e, \"cpx\", o), f.assert_number(t, \"cpy\", o), f.assert_number(r, \"x\", o), f.assert_number(n, \"y\", o);var i = new a.BCurve(),s = 1 / 3 * this._xy[0] + 2 / 3 * e,c = 1 / 3 * this._xy[1] + 2 / 3 * t,u = 1 / 3 * r + 2 / 3 * e,l = 1 / 3 * n + 2 / 3 * t,h = [this._xy[0], this._xy[1], 0, s, c, 0, u, l, 0, r, n, 0];return i.set(h, [1, 1, 1, 1], 3, [0, 0, 0, 0, 1, 1, 1, 1]), this._curves.push(i), this._xy[0] = r, this._xy[1] = n, this;}, v.prototype.bezierCurveTo = function (e, t, r, n, o, i) {var s = \"Path2D.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y)\";f.assert_number(e, \"cp1x\", s), f.assert_number(t, \"cp1y\", s), f.assert_number(r, \"cp2x\", s), f.assert_number(n, \"cp2y\", s), f.assert_number(o, \"x\", s), f.assert_number(i, \"y\", s);var c = new a.BCurve(),u = [this._xy[0], this._xy[1], 0, e, t, 0, r, n, 0, o, i, 0];return c.set(u, [1, 1, 1, 1], 3, [0, 0, 0, 0, 1, 1, 1, 1]), this._curves.push(c), this._xy[0] = o, this._xy[1] = i, this;}, v.prototype.circleArcTo = function (e, t, r, n, o) {var i = \"Path2D.circleArcTo(radius, longest, anticlockwise, x, y)\";f.assert_number(e, \"radius\", i), f.assert_arg(e > 0, \"radius\", \"must be positive\", i), f.assert_boolean(t, \"longest\", i), f.assert_boolean(r, \"anticlockwise\", i), f.assert_number(n, \"x\", i), f.assert_number(o, \"y\", i);var s = C(this._xy, e, t, r, [n, o]);return s && (this._curves.push(s), this._xy[0] = n, this._xy[1] = o), this;}, v.prototype.ellipseArcTo = function (e, t, r, o, i, s, a) {var c = \"Path2D.ellipseArcTo(xRadius, yRadius, rotation, longest, anticlockwise, x, y)\";if (f.assert_number(e, \"xRadius\", c), f.assert_arg(e > 0, \"xRadius\", \"must be positive\", c), f.assert_number(t, \"yRadius\", c), f.assert_arg(t > 0, \"yRadius\", \"must be positive\", c), f.assert_number(r, \"rotation\", c), f.assert_boolean(o, \"longest\", c), f.assert_boolean(i, \"anticlockwise\", c), f.assert_number(s, \"x\", c), f.assert_number(a, \"y\", c), e < t) {var l = e;e = t, t = l, r += Math.PI / 2;}var h = Math.cos(r),d = Math.sin(r),g = e / t,p = n.Matrix22.multiply([], [1, 0, 0, g], [h, -d, d, h]),v = C(n.Vector2.transformMatrix22([], this._xy, p), e, o, i, n.Vector2.transformMatrix22([], [s, a], p));if (v) {var _ = [v.getCenter()[0], v.getCenter()[1]];n.Matrix22.invert(p, p), n.Vector2.transformMatrix22(_, _, p), _[2] = 0;var y = v.getRadius(),m = [y * h, y * d, 0],E = new u.Ellipse();E.set(_, v.getNormal(), m, 1 / g), E.limitRange(v.getRange()), this._curves.push(E), this._xy[0] = s, this._xy[1] = a;}return this;}, v.prototype.closePath = function () {if (this._curves.length > 0) {var e = this._curves[0],t = e.evaluatePosition(e.getRange()[0]);this.lineTo(t[0], t[1]), this._addWire();}return this;}, v.prototype.addCircle = function (e, t, r) {var n = \"Path2D.addCircle(x, y, radius)\";f.assert_number(e, \"x\", n), f.assert_number(t, \"y\", n), f.assert_number(r, \"radius\", n), f.assert_arg(r > 0, \"radius\", \"must be positive\", n), this._addWire();var o = new c.Circle();return o.set([e, t, 0], [0, 0, 1], [r, 0, 0]), this._curves.push(o), this._addWire(), this;}, v.prototype.addEllipse = function (e, t, r, n, o) {o = void 0 === o ? 0 : o;var i = \"Path2D.addEllipse(x, y, xRadius, yRadius, rotation)\";if (f.assert_number(e, \"x\", i), f.assert_number(t, \"y\", i), f.assert_number(r, \"xRadius\", i), f.assert_arg(r > 0, \"xRadius\", \"must be positive\", i), f.assert_number(n, \"yRadius\", i), f.assert_arg(n > 0, \"yRadius\", \"must be positive\", i), f.assert_number(o, \"rotation\", i), this._addWire(), r < n) {var s = r;r = n, n = s, o += Math.PI / 2;}var a = new u.Ellipse(),c = Math.cos(o),l = Math.sin(o),h = n / r;return a.set([e, t, 0], [0, 0, 1], [r * c, r * l, 0], h), this._curves.push(a), this._addWire(), this;}, v.prototype.addSVGPath = function (e, t) {t = void 0 !== t && t;var r = \"Path2D.addSVGPath(pathString, [includeOpen])\";f.assert_string(e, \"pathString\", r), f.assert_boolean(t, \"includeOpen\", r), this._addWire(), this._xy[0] = 0, this._xy[1] = 0;var n = function (e) {for (var t = []; e.length > 0;) {var r = e.slice(1).search(/[MmZzLlHhVvCcSsQqTtAa]/) + 1;r <= 0 && (r = e.length);var n = e.slice(0, r).trim();n.length > 0 && t.push(n), e = e.slice(r).trim();}return t;}(e);f.assert_arg(n.length > 0, \"pathString\", \"cannot be empty string\", r);for (var i = [this._xy[0], this._xy[1]], s = [this._xy[0], this._xy[1]], a = 0; a < n.length; ++a) {var c,u,l,h,d,g,p,v = function v(e, t) {f.assert_arg(e, \"pathString\", t + ' \"' + n[a] + '\"', r);},_ = n[a].charAt(0).toUpperCase(),y = _ !== n[a].charAt(0),m = b(n[a], v),E = y ? this._xy : [0, 0];switch (_) {case \"M\":for (v(m.length >= 2, \"insufficient arguments in command\"), v(m.length % 2 == 0, \"command requires pairs of x,y arguments\"), t || this._discardIfOpen(), this.moveTo(m[0] + E[0], m[1] + E[1]), p = 2; p < m.length; p += 2) {this.lineTo(m[p] + E[0], m[p + 1] + E[1]);}break;case \"Z\":v(0 === m.length, \"command should not have arguments\"), this.closePath();break;case \"L\":for (v(m.length >= 2, \"insufficient arguments in command\"), v(m.length % 2 == 0, \"command requires pairs of x,y arguments\"), p = 0; p < m.length; p += 2) {this.lineTo(m[p] + E[0], m[p + 1] + E[1]);}break;case \"H\":for (v(m.length >= 1, \"insufficient arguments in command\"), p = 0; p < m.length; p += 1) {this.lineTo(m[p] + E[0], this._xy[1]);}break;case \"V\":for (v(m.length >= 1, \"insufficient arguments in command\"), p = 0; p < m.length; p += 1) {this.lineTo(this._xy[0], m[p] + E[1]);}break;case \"C\":for (v(m.length >= 6, \"insufficient arguments in command\"), v(m.length % 6 == 0, \"command requires sets of 6 arguments\"), p = 0; p < m.length; p += 6) {c = m[p] + E[0], u = m[p + 1] + E[1], l = m[p + 2] + E[0], h = m[p + 3] + E[1], d = m[p + 4] + E[0], g = m[p + 5] + E[1], this.bezierCurveTo(c, u, l, h, d, g), s[0] = l, s[1] = h;}break;case \"S\":for (v(m.length >= 4, \"insufficient arguments in command\"), v(m.length % 4 == 0, \"command requires sets of 4 arguments\"), p = 0; p < m.length; p += 4) {c = 2 * this._xy[0] - s[0], u = 2 * this._xy[1] - s[1], l = m[p] + E[0], h = m[p + 1] + E[1], d = m[p + 2] + E[0], g = m[p + 3] + E[1], this.bezierCurveTo(c, u, l, h, d, g), s[0] = l, s[1] = h;}break;case \"Q\":for (v(m.length >= 4, \"insufficient arguments in command\"), v(m.length % 4 == 0, \"command requires sets of 4 arguments\"), p = 0; p < m.length; p += 4) {c = m[p] + E[0], u = m[p + 1] + E[1], l = m[p + 2] + E[0], h = m[p + 3] + E[1], this.quadraticCurveTo(c, u, l, h), i[0] = c, i[1] = u;}break;case \"T\":for (v(m.length >= 2, \"insufficient arguments in command\"), v(m.length % 2 == 0, \"command requires pairs of arguments\"), p = 0; p < m.length; p += 2) {c = 2 * this._xy[0] - i[0], u = 2 * this._xy[1] - i[1], l = m[p] + E[0], h = m[p + 1] + E[1], this.quadraticCurveTo(c, u, l, h), i[0] = c, i[1] = u;}break;case \"A\":for (v(m.length >= 7, \"insufficient arguments in command\"), v(m.length % 7 == 0, \"command requires sets of 7 arguments\"), p = 0; p < m.length; p += 7) {var x = Math.abs(m[p]),R = Math.abs(m[p + 1]),A = m[p + 2] * Math.PI / 180,P = 0 !== m[p + 3],V = 0 !== m[p + 4],T = m[p + 5] + E[0],C = m[p + 6] + E[1];x < o.KERNEL_TOLERANCE || R < o.KERNEL_TOLERANCE ? this.lineTo(T, C) : this.ellipseArcTo(x, R, A, P, V, T, C);}break;default:v(!1, \"unrecognised command\");}\"Q\" !== _ && \"T\" !== _ && (i = [this._xy[0], this._xy[1]]), \"C\" !== _ && \"S\" !== _ && (s = [this._xy[0], this._xy[1]]);}return t || this._discardIfOpen(), this._addWire(), this;}, v.prototype.getWireBody = function () {return this._addWire(), this._wireBody;}, v.prototype.computeRegionizedWireBody = function () {this.getWireBody();for (var e = new i.WireBody(), t = (0, d.mergeSketchRegions)(this._wireBody.getWires()), r = 0; r < t.length; ++r) {for (var n = t[r].getLoops(), o = 0; o < n.length; ++o) {var a = n[o],c = new s.Wire();c.addEdges(Array.from(a.collectEdges())), e.addWire(c);}}return e;}, v.prototype.reset = function () {this._wireBody = new i.WireBody(), this._curves = [], this._xy = [0, 0];}, t.Path2D = v;}, function (e, t, r) {\"use strict\";Object.defineProperty(t, \"__esModule\", { value: !0 }), t.SolidDefLoader = t.getTopologyRank = void 0;var n = r(6),o = r(7),i = r(14),s = r(23),a = r(33),c = r(18),u = r(38),l = r(39),h = r(74),d = r(51),g = r(52),p = r(75),f = r(53),v = r(24),_ = r(25),y = r(26),m = r(15),E = r(13),x = r(27),R = r(20),A = r(16),P = r(54),V = r(40),T = r(79),C = r(0),b = r(85),L = r(124),O = r(125),S = r(45),M = function () {var e = {};return e[C.TOPOLOGY_TYPES.BODY] = 10, e[C.TOPOLOGY_TYPES.WIREBODY] = 9, e[C.TOPOLOGY_TYPES.LUMP] = 8, e[C.TOPOLOGY_TYPES.SHELL] = 7, e[C.TOPOLOGY_TYPES.FACE] = 6, e[C.TOPOLOGY_TYPES.WIRE] = 5, e[C.TOPOLOGY_TYPES.LOOP] = 4, e[C.TOPOLOGY_TYPES.COEDGE] = 3, e[C.TOPOLOGY_TYPES.EDGE] = 2, e[C.TOPOLOGY_TYPES.VERTEX] = 1, function (t) {var r = void 0;return \"function\" == typeof t.getTopologyType && (r = e[t.getTopologyType()]), r || 0;};}(),w = function w() {this._runTimeMap = new Map(), this._typeidToFuncMap = {}, this.addLoader(\"body\", L.TopologySetters.setBodyData, v.Body), this.addLoader(\"wirebody\", L.TopologySetters.setWireBodyData, P.WireBody), this.addLoader(\"wire\", L.TopologySetters.setWireData, V.Wire), this.addLoader(\"lump\", L.TopologySetters.setLumpData, _.Lump), this.addLoader(\"shell\", L.TopologySetters.setShellData, y.Shell), this.addLoader(\"face\", L.TopologySetters.setFaceData, m.Face), this.addLoader(\"loop\", L.TopologySetters.setLoopData, E.Loop), this.addLoader(\"coedge\", L.TopologySetters.setCoedgeData, x.Coedge), this.addLoader(\"edge\", L.TopologySetters.setEdgeData, R.Edge), this.addLoader(\"vertex\", L.TopologySetters.setVertexData, A.Vertex), this.addLoader(\"point\", b.GeometrySetters.setPointFromProperty, n.Point), this.addLoader(\"line\", b.GeometrySetters.setLineFromProperty, o.Line), this.addLoader(\"circle\", b.GeometrySetters.setCircleFromProperty, i.Circle), this.addLoader(\"ellipse\", b.GeometrySetters.setEllipseFromProperty, s.Ellipse), this.addLoader(\"bcurve\", b.GeometrySetters.setBCurveFromProperty, a.BCurve), this.addLoader(\"plane\", b.GeometrySetters.setPlaneFromProperty, c.Plane), this.addLoader(\"sphere\", b.GeometrySetters.setSphereFromProperty, h.Sphere), this.addLoader(\"torus\", b.GeometrySetters.setTorusFromProperty, p.Torus), this.addLoader(\"cylinder\", b.GeometrySetters.setCylinderFromProperty, u.Cylinder), this.addLoader(\"cone\", b.GeometrySetters.setConeFromProperty, d.Cone), this.addLoader(\"ellipticalcylinder\", b.GeometrySetters.setEllipticalCylinderFromProperty, l.EllipticalCylinder), this.addLoader(\"ellipticalcone\", b.GeometrySetters.setEllipticalConeFromProperty, g.EllipticalCone), this.addLoader(\"bsurface\", b.GeometrySetters.setBSurfaceFromProperty, f.BSurface), this.addLoader(\"nmiattributestr\", O.AttributeSetters.setNMIAttributeStr, T.Attribute), this.addLoader(\"nmiattributearr\", O.AttributeSetters.setNMIAttributeArr, T.Attribute), this.addLoader(\"textattribute\", O.AttributeSetters.setTextAttribute, T.Attribute);};w.prototype.addLoader = function (e, t, r) {this._typeidToFuncMap[e] = [t, r];}, w.prototype._reset = function () {this._runTimeMap.clear();}, w.prototype.getDataSettingFunction = function (e) {var t = this._typeidToFuncMap[e];if (t) return t[0];}, w.prototype.createRunTimeObject = function (e) {var t = this.getTypeContructor(e);if (t) return new t();}, w.prototype.getTypeContructor = function (e) {var t = this._typeidToFuncMap[e];if (t && 2 === t.length) return t[1];}, w.prototype.setObjectProperties = function (e, t, r) {var n = this.getDataSettingFunction(e, r);var o = this;\"function\" == typeof n && n(t, r, function (e) {if (!e) return;var t = e;return t ? o._runTimeMap.get(t) : void 0;});}, w.prototype.makeGeometryObjectsProto = function (e) {var _this2 = this;Object.keys(e).forEach(function (t) {var r = e[t],n = r[r.geometry],o = _this2.createRunTimeObject(r.geometry);o && (_this2._runTimeMap.set(t, o), _this2.setObjectProperties(r.geometry, o, n), o.setGuid(t));});}, w.prototype.makeGeometryObject = function (e) {var t = e.getTypeid(),r = this.createRunTimeObject(t);return r ? this.setObjectProperties(t, r, e) : console.error(\"No constructor\"), r;}, w.prototype.makeTopologyObject = function (e) {var t = e.getTypeid(),r = this.createRunTimeObject(t);return r || console.error(\"No constructor\"), r;}, w.prototype.makeAttributeObjectsProto = function (e) {var _this3 = this;Object.keys(e).forEach(function (t) {var r = e[t],n = r[r.attribute],o = new T.Attribute();_this3._runTimeMap.set(t, o), _this3.setObjectProperties(r.attribute, o, n), o.setGuid(t);});}, w.prototype.makeTopologyObjectsProto = function (e) {var _this4 = this;var t = [];Object.keys(e).forEach(function (r) {var n = e[r],o = n[n.topology],i = _this4.createRunTimeObject(n.topology);i && (_this4._runTimeMap.set(r, i), t.push({ type: n.topology, obj: i, prop: o }), i.setGuid(r));});for (var r = 0; r < t.length; ++r) {this.setObjectProperties(t[r].type, t[r].obj, t[r].prop);}}, w.prototype._collectGeometries = function (e) {this._runTimeMap.forEach(function (t) {void 0 !== t.getGeometryType && e.set(t.getGuid(), t);});}, w.prototype._collectTopologies = function (e) {this._runTimeMap.forEach(function (t) {void 0 !== t.getTopologyType && e.set(t.getGuid(), t);});}, w.prototype.loadModelPSet = function (e, t, r) {var n = e.get(\"geometries\");if (n) {var o = e.get(\"attributes\"),i = e.get(\"topologies\");if (i) return this.makeGeometryObjects(n), o && this.makeAttributeObjects(o), this.makeTopologyObjects(i), this.getHighestObject(t, r);}}, w.prototype.getHighestObject = function (e, t) {var r = void 0,n = 0;return this._runTimeMap.forEach(function (e) {if (10 !== n) {var t = M(e);t > n && t > 0 && (n = t, r = e);}}), e && this._collectGeometries(e), t && this._collectTopologies(t), this._reset(), r;}, w.prototype.loadModelProtoMessage = function (e, t, r) {var n = e.geometries;if (!n) return;var o = e.attributes,i = e.topologies;return i ? (this.makeGeometryObjectsProto(n), o && this.makeAttributeObjectsProto(o), this.makeTopologyObjectsProto(i), this.getHighestObject(t, r)) : void 0;}, w.prototype.loadProtoBinary = function (e, t, r) {var n = e;n instanceof ArrayBuffer && (n = new Uint8Array(n));var o = S.Autodesk.lookupType(\"SolidDef.model_1_0_0\").decode(n);return this.loadModelProtoMessage(o, t, r);}, t.getTopologyRank = M, t.SolidDefLoader = w;}, function (e, t, r) {\"use strict\";Object.defineProperty(t, \"__esModule\", { value: !0 }), t.TopologySetters = void 0;var n = r(85);var o = {},i = function i(e, t, r) {var n = t.attributes;if (n) {e.removeAllAttributes();for (var o = 0; o < n.length; ++o) {var _t9 = r(n[o]);e.addAttribute(_t9);}}};o.setBodyData = function (e, t, r) {for (var n = t.lumps, o = new Array(n.length), s = 0; s < n.length; ++s) {var a = n[s];o[s] = r(a), o[s].setBody(e);}e.setLumps(o), i(e, t, r);}, o.setLumpData = function (e, t, r) {for (var n = t.shells, o = new Array(n.length), s = 0; s < n.length; ++s) {var a = n[s];o[s] = r(a), o[s].setLump(e);}e.setShells(o), i(e, t, r);}, o.setShellData = function (e, t, r) {for (var n = t.faces, o = new Array(n.length), s = 0; s < n.length; ++s) {var a = n[s];o[s] = r(a), o[s].setShell(e);}e.setFaces(o), i(e, t, r);}, o.setFaceData = function (e, t, r) {for (var n = t.loops, o = new Array(n.length), s = 0; s < n.length; ++s) {var a = n[s];o[s] = r(a), o[s].setFace(e);}e.setLoops(o), e.setReversed(t.reversed), e.setSurface(r(t.geometry)), i(e, t, r);}, o.setLoopData = function (e, t, r) {for (var n = t.coedges, o = new Array(n.length), s = 0; s < n.length; ++s) {var a = n[s];o[s] = r(a), o[s].setLoop(e);}e.setCoedges(o), i(e, t, r);}, o.setCoedgeData = function (e, t, r) {e.setEdge(r(t.edge)), e.setReversed(t.reversed), e.setPartner(r(t.partner)), e.getEdge() && !e.getEdge().getCoedge() && e.getEdge().setCoedge(e), i(e, t, r);}, o.setEdgeData = function (e, t, r) {e.setVertex(0, r(t.vertex0)), e.setVertex(1, r(t.vertex1));var o = (0, n.propertyToRange)(t, \"range\");e.sett0(o[0]), e.sett1(o[1]), e.setReversed(t.reversed), e.setPrecision(t.precision), e.setCurve(r(t.geometry)), i(e, t, r);}, o.setVertexData = function (e, t, r) {e.setPrecision(t.precision), e.setPoint(r(t.geometry)), i(e, t, r);}, o.setWireBodyData = function (e, t, r) {for (var n = t.wires, o = new Array(n.length), s = 0; s < n.length; ++s) {var a = n[s];o[s] = r(a), o[s].setWireBody(e);}e.setWires(o), i(e, t, r);}, o.setWireData = function (e, t, r) {for (var n = t.edges, o = new Array(n.length), s = 0; s < n.length; ++s) {var a = n[s];o[s] = r(a), o[s].setWire(e);}e.setEdges(o), i(e, t, r);}, t.TopologySetters = o;}, function (e, t, r) {\"use strict\";Object.defineProperty(t, \"__esModule\", { value: !0 });var n = { setNMIAttributeStr: function setNMIAttributeStr(e, t) {e.typeid = \"autodesk.brep:nmiattributestr-1.0.0\", e.values = { primaryId: t.primaryId, secondaryId: t.secondaryId, approachId: t.approachId, operationIds: t.operationIds };}, setNMIAttributeArr: function setNMIAttributeArr(e, t) {e.typeid = \"autodesk.brep:nmiattributearr-1.0.0\";for (var r = t.tagInfo, n = new Array(r.length), o = 0; o < r.length; ++o) {var i = r[o];n[o] = { primaryId: i.primaryId, secondaryId: i.secondaryId, approachId: i.approachId, operationIds: i.operationIds };}e.values = { tagInfo: n };}, setTextAttribute: function setTextAttribute(e, t) {e.typeid = \"autodesk.brep:textattribute-1.0.0\", e.values = { text: t.text };} };t.AttributeSetters = n;}, function (e, t, r) {\"use strict\";Object.defineProperty(t, \"__esModule\", { value: !0 }), t.saveToProtoBinary = t.saveToProtoMessage = t.SolidDefSaver = void 0;var n = r(45),o = function o() {};o.prototype.setVersion = function (e) {console.warn(\"SolidDefSaver.prototype.setVersion is deprecated,\");};var i = function i(e) {var t = n.Autodesk.lookupType(\"SolidDef.model_1_0_0\"),r = { topologies: {}, geometries: {}, attributes: {} };return e.addToModelObject(r), t.create(r);};t.SolidDefSaver = o, t.saveToProtoMessage = i, t.saveToProtoBinary = function (e) {var t = n.Autodesk.lookupType(\"SolidDef.model_1_0_0\"),r = i(e);return t.encode(r).finish();};}]);});","exports = module.exports = require(\"../../node_modules/css-loader/lib/css-base.js\")(false);\n// imports\n\n\n// module\nexports.push([module.id, \".adsk-viewing-viewer .edge-gizmo:hover {\\n  background-color: lime; }\\n\\n.adsk-viewing-viewer .edge-gizmo {\\n  position: absolute;\\n  background-color: #009bff;\\n  box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.25);\\n  border-radius: 8px;\\n  cursor: move;\\n  z-index: 1;\\n  /* Place above the viewer but below the measure labels, which are at 2 */\\n  -webkit-tap-highlight-color: rgba(0, 0, 0, 0); }\\n\\n.adsk-viewing-viewer .edge-gizmo.selected {\\n  background-color: lime; }\\n\\n.adsk-viewing-viewer .vertex-gizmo:hover.vertex-gizmo.enable-hover {\\n  border-color: lime; }\\n\\n.adsk-viewing-viewer .vertex-gizmo {\\n  display: inline-block;\\n  position: absolute;\\n  width: 7px;\\n  height: 7px;\\n  left: -2px;\\n  top: -2px;\\n  background-color: #009bff;\\n  border-style: solid;\\n  border-width: 2px;\\n  border-color: #FFFFFF;\\n  border-radius: 100px;\\n  box-shadow: 0 2px 5px 0 #182A3D;\\n  z-index: 1;\\n  /* Place above the viewer but below the measure labels, which are at 2 */\\n  cursor: move; }\\n\\n.adsk-viewing-viewer .ellipse-arc-gizmo {\\n  display: inline-block;\\n  position: absolute;\\n  width: 5px;\\n  height: 5px;\\n  left: -1px;\\n  top: -1px;\\n  background-color: #ff00ff;\\n  border-style: solid;\\n  border-width: 1px;\\n  border-color: #000000;\\n  border-radius: 100px;\\n  box-shadow: 0 2px 5px 0 #182A3D;\\n  z-index: 2;\\n  /* Must always be in front of the EdgeMove gizmo. Otherwise it would become unreachable on low radii.*/\\n  cursor: move; }\\n\\n.adsk-viewing-viewer .vertex-gizmo.selected {\\n  border-color: lime; }\\n\\n.adsk-viewing-viewer .edge-move-gizmo {\\n  width: 20px;\\n  /* width along the edge */\\n  height: 6px;\\n  /* height vertical to the edge */ }\\n\\n.adsk-viewing-viewer .edit2d-label {\\n  display: none;\\n  position: absolute;\\n  height: 19px;\\n  left: 0px;\\n  top: 0px;\\n  padding: 2px 0 2px 0;\\n  background-color: #009bff;\\n  box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.25);\\n  color: #f4f4f4;\\n  font-size: 12px;\\n  text-align: center;\\n  line-height: 1.2;\\n  white-space: nowrap;\\n  border-radius: 8px;\\n  pointer-events: none;\\n  cursor: pointer;\\n  z-index: 2;\\n  -webkit-tap-highlight-color: rgba(0, 0, 0, 0); }\\n\\n.adsk-viewing-viewer .edit2d-label.visible {\\n  display: block; }\\n\\n.adsk-viewing-viewer .edit2d-label-text {\\n  display: inline-block;\\n  margin: 0 5px 0 5px;\\n  vertical-align: middle;\\n  font-size: 16px;\\n  pointer-events: none; }\\n\\n/* Mark area labels for invalid shapes with red background */\\n.adsk-viewing-viewer .edit2d-label.error-indicator {\\n  background-color: red; }\\n\", \"\"]);\n\n// exports\n","/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n// css base code, injected by the css-loader\nmodule.exports = function(useSourceMap) {\n\tvar list = [];\n\n\t// return the list of modules as css string\n\tlist.toString = function toString() {\n\t\treturn this.map(function (item) {\n\t\t\tvar content = cssWithMappingToString(item, useSourceMap);\n\t\t\tif(item[2]) {\n\t\t\t\treturn \"@media \" + item[2] + \"{\" + content + \"}\";\n\t\t\t} else {\n\t\t\t\treturn content;\n\t\t\t}\n\t\t}).join(\"\");\n\t};\n\n\t// import a list of modules into the list\n\tlist.i = function(modules, mediaQuery) {\n\t\tif(typeof modules === \"string\")\n\t\t\tmodules = [[null, modules, \"\"]];\n\t\tvar alreadyImportedModules = {};\n\t\tfor(var i = 0; i < this.length; i++) {\n\t\t\tvar id = this[i][0];\n\t\t\tif(typeof id === \"number\")\n\t\t\t\talreadyImportedModules[id] = true;\n\t\t}\n\t\tfor(i = 0; i < modules.length; i++) {\n\t\t\tvar item = modules[i];\n\t\t\t// skip already imported module\n\t\t\t// this implementation is not 100% perfect for weird media query combinations\n\t\t\t//  when a module is imported multiple times with different media queries.\n\t\t\t//  I hope this will never occur (Hey this way we have smaller bundles)\n\t\t\tif(typeof item[0] !== \"number\" || !alreadyImportedModules[item[0]]) {\n\t\t\t\tif(mediaQuery && !item[2]) {\n\t\t\t\t\titem[2] = mediaQuery;\n\t\t\t\t} else if(mediaQuery) {\n\t\t\t\t\titem[2] = \"(\" + item[2] + \") and (\" + mediaQuery + \")\";\n\t\t\t\t}\n\t\t\t\tlist.push(item);\n\t\t\t}\n\t\t}\n\t};\n\treturn list;\n};\n\nfunction cssWithMappingToString(item, useSourceMap) {\n\tvar content = item[1] || '';\n\tvar cssMapping = item[3];\n\tif (!cssMapping) {\n\t\treturn content;\n\t}\n\n\tif (useSourceMap && typeof btoa === 'function') {\n\t\tvar sourceMapping = toComment(cssMapping);\n\t\tvar sourceURLs = cssMapping.sources.map(function (source) {\n\t\t\treturn '/*# sourceURL=' + cssMapping.sourceRoot + source + ' */'\n\t\t});\n\n\t\treturn [content].concat(sourceURLs).concat([sourceMapping]).join('\\n');\n\t}\n\n\treturn [content].join('\\n');\n}\n\n// Adapted from convert-source-map (MIT)\nfunction toComment(sourceMap) {\n\t// eslint-disable-next-line no-undef\n\tvar base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));\n\tvar data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;\n\n\treturn '/*# ' + data + ' */';\n}\n","/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\nvar stylesInDom = {};\n\nvar\tmemoize = function (fn) {\n\tvar memo;\n\n\treturn function () {\n\t\tif (typeof memo === \"undefined\") memo = fn.apply(this, arguments);\n\t\treturn memo;\n\t};\n};\n\nvar isOldIE = memoize(function () {\n\t// Test for IE <= 9 as proposed by Browserhacks\n\t// @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805\n\t// Tests for existence of standard globals is to allow style-loader\n\t// to operate correctly into non-standard environments\n\t// @see https://github.com/webpack-contrib/style-loader/issues/177\n\treturn window && document && document.all && !window.atob;\n});\n\nvar getTarget = function (target, parent) {\n  if (parent){\n    return parent.querySelector(target);\n  }\n  return document.querySelector(target);\n};\n\nvar getElement = (function (fn) {\n\tvar memo = {};\n\n\treturn function(target, parent) {\n                // If passing function in options, then use it for resolve \"head\" element.\n                // Useful for Shadow Root style i.e\n                // {\n                //   insertInto: function () { return document.querySelector(\"#foo\").shadowRoot }\n                // }\n                if (typeof target === 'function') {\n                        return target();\n                }\n                if (typeof memo[target] === \"undefined\") {\n\t\t\tvar styleTarget = getTarget.call(this, target, parent);\n\t\t\t// Special case to return head of iframe instead of iframe itself\n\t\t\tif (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {\n\t\t\t\ttry {\n\t\t\t\t\t// This will throw an exception if access to iframe is blocked\n\t\t\t\t\t// due to cross-origin restrictions\n\t\t\t\t\tstyleTarget = styleTarget.contentDocument.head;\n\t\t\t\t} catch(e) {\n\t\t\t\t\tstyleTarget = null;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmemo[target] = styleTarget;\n\t\t}\n\t\treturn memo[target]\n\t};\n})();\n\nvar singleton = null;\nvar\tsingletonCounter = 0;\nvar\tstylesInsertedAtTop = [];\n\nvar\tfixUrls = require(\"./urls\");\n\nmodule.exports = function(list, options) {\n\tif (typeof DEBUG !== \"undefined\" && DEBUG) {\n\t\tif (typeof document !== \"object\") throw new Error(\"The style-loader cannot be used in a non-browser environment\");\n\t}\n\n\toptions = options || {};\n\n\toptions.attrs = typeof options.attrs === \"object\" ? options.attrs : {};\n\n\t// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\n\t// tags it will allow on a page\n\tif (!options.singleton && typeof options.singleton !== \"boolean\") options.singleton = isOldIE();\n\n\t// By default, add <style> tags to the <head> element\n        if (!options.insertInto) options.insertInto = \"head\";\n\n\t// By default, add <style> tags to the bottom of the target\n\tif (!options.insertAt) options.insertAt = \"bottom\";\n\n\tvar styles = listToStyles(list, options);\n\n\taddStylesToDom(styles, options);\n\n\treturn function update (newList) {\n\t\tvar mayRemove = [];\n\n\t\tfor (var i = 0; i < styles.length; i++) {\n\t\t\tvar item = styles[i];\n\t\t\tvar domStyle = stylesInDom[item.id];\n\n\t\t\tdomStyle.refs--;\n\t\t\tmayRemove.push(domStyle);\n\t\t}\n\n\t\tif(newList) {\n\t\t\tvar newStyles = listToStyles(newList, options);\n\t\t\taddStylesToDom(newStyles, options);\n\t\t}\n\n\t\tfor (var i = 0; i < mayRemove.length; i++) {\n\t\t\tvar domStyle = mayRemove[i];\n\n\t\t\tif(domStyle.refs === 0) {\n\t\t\t\tfor (var j = 0; j < domStyle.parts.length; j++) domStyle.parts[j]();\n\n\t\t\t\tdelete stylesInDom[domStyle.id];\n\t\t\t}\n\t\t}\n\t};\n};\n\nfunction addStylesToDom (styles, options) {\n\tfor (var i = 0; i < styles.length; i++) {\n\t\tvar item = styles[i];\n\t\tvar domStyle = stylesInDom[item.id];\n\n\t\tif(domStyle) {\n\t\t\tdomStyle.refs++;\n\n\t\t\tfor(var j = 0; j < domStyle.parts.length; j++) {\n\t\t\t\tdomStyle.parts[j](item.parts[j]);\n\t\t\t}\n\n\t\t\tfor(; j < item.parts.length; j++) {\n\t\t\t\tdomStyle.parts.push(addStyle(item.parts[j], options));\n\t\t\t}\n\t\t} else {\n\t\t\tvar parts = [];\n\n\t\t\tfor(var j = 0; j < item.parts.length; j++) {\n\t\t\t\tparts.push(addStyle(item.parts[j], options));\n\t\t\t}\n\n\t\t\tstylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};\n\t\t}\n\t}\n}\n\nfunction listToStyles (list, options) {\n\tvar styles = [];\n\tvar newStyles = {};\n\n\tfor (var i = 0; i < list.length; i++) {\n\t\tvar item = list[i];\n\t\tvar id = options.base ? item[0] + options.base : item[0];\n\t\tvar css = item[1];\n\t\tvar media = item[2];\n\t\tvar sourceMap = item[3];\n\t\tvar part = {css: css, media: media, sourceMap: sourceMap};\n\n\t\tif(!newStyles[id]) styles.push(newStyles[id] = {id: id, parts: [part]});\n\t\telse newStyles[id].parts.push(part);\n\t}\n\n\treturn styles;\n}\n\nfunction insertStyleElement (options, style) {\n\tvar target = getElement(options.insertInto)\n\n\tif (!target) {\n\t\tthrow new Error(\"Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.\");\n\t}\n\n\tvar lastStyleElementInsertedAtTop = stylesInsertedAtTop[stylesInsertedAtTop.length - 1];\n\n\tif (options.insertAt === \"top\") {\n\t\tif (!lastStyleElementInsertedAtTop) {\n\t\t\ttarget.insertBefore(style, target.firstChild);\n\t\t} else if (lastStyleElementInsertedAtTop.nextSibling) {\n\t\t\ttarget.insertBefore(style, lastStyleElementInsertedAtTop.nextSibling);\n\t\t} else {\n\t\t\ttarget.appendChild(style);\n\t\t}\n\t\tstylesInsertedAtTop.push(style);\n\t} else if (options.insertAt === \"bottom\") {\n\t\ttarget.appendChild(style);\n\t} else if (typeof options.insertAt === \"object\" && options.insertAt.before) {\n\t\tvar nextSibling = getElement(options.insertAt.before, target);\n\t\ttarget.insertBefore(style, nextSibling);\n\t} else {\n\t\tthrow new Error(\"[Style Loader]\\n\\n Invalid value for parameter 'insertAt' ('options.insertAt') found.\\n Must be 'top', 'bottom', or Object.\\n (https://github.com/webpack-contrib/style-loader#insertat)\\n\");\n\t}\n}\n\nfunction removeStyleElement (style) {\n\tif (style.parentNode === null) return false;\n\tstyle.parentNode.removeChild(style);\n\n\tvar idx = stylesInsertedAtTop.indexOf(style);\n\tif(idx >= 0) {\n\t\tstylesInsertedAtTop.splice(idx, 1);\n\t}\n}\n\nfunction createStyleElement (options) {\n\tvar style = document.createElement(\"style\");\n\n\tif(options.attrs.type === undefined) {\n\t\toptions.attrs.type = \"text/css\";\n\t}\n\n\tif(options.attrs.nonce === undefined) {\n\t\tvar nonce = getNonce();\n\t\tif (nonce) {\n\t\t\toptions.attrs.nonce = nonce;\n\t\t}\n\t}\n\n\taddAttrs(style, options.attrs);\n\tinsertStyleElement(options, style);\n\n\treturn style;\n}\n\nfunction createLinkElement (options) {\n\tvar link = document.createElement(\"link\");\n\n\tif(options.attrs.type === undefined) {\n\t\toptions.attrs.type = \"text/css\";\n\t}\n\toptions.attrs.rel = \"stylesheet\";\n\n\taddAttrs(link, options.attrs);\n\tinsertStyleElement(options, link);\n\n\treturn link;\n}\n\nfunction addAttrs (el, attrs) {\n\tObject.keys(attrs).forEach(function (key) {\n\t\tel.setAttribute(key, attrs[key]);\n\t});\n}\n\nfunction getNonce() {\n\tif (typeof __webpack_nonce__ === 'undefined') {\n\t\treturn null;\n\t}\n\n\treturn __webpack_nonce__;\n}\n\nfunction addStyle (obj, options) {\n\tvar style, update, remove, result;\n\n\t// If a transform function was defined, run it on the css\n\tif (options.transform && obj.css) {\n\t    result = typeof options.transform === 'function'\n\t\t ? options.transform(obj.css) \n\t\t : options.transform.default(obj.css);\n\n\t    if (result) {\n\t    \t// If transform returns a value, use that instead of the original css.\n\t    \t// This allows running runtime transformations on the css.\n\t    \tobj.css = result;\n\t    } else {\n\t    \t// If the transform function returns a falsy value, don't add this css.\n\t    \t// This allows conditional loading of css\n\t    \treturn function() {\n\t    \t\t// noop\n\t    \t};\n\t    }\n\t}\n\n\tif (options.singleton) {\n\t\tvar styleIndex = singletonCounter++;\n\n\t\tstyle = singleton || (singleton = createStyleElement(options));\n\n\t\tupdate = applyToSingletonTag.bind(null, style, styleIndex, false);\n\t\tremove = applyToSingletonTag.bind(null, style, styleIndex, true);\n\n\t} else if (\n\t\tobj.sourceMap &&\n\t\ttypeof URL === \"function\" &&\n\t\ttypeof URL.createObjectURL === \"function\" &&\n\t\ttypeof URL.revokeObjectURL === \"function\" &&\n\t\ttypeof Blob === \"function\" &&\n\t\ttypeof btoa === \"function\"\n\t) {\n\t\tstyle = createLinkElement(options);\n\t\tupdate = updateLink.bind(null, style, options);\n\t\tremove = function () {\n\t\t\tremoveStyleElement(style);\n\n\t\t\tif(style.href) URL.revokeObjectURL(style.href);\n\t\t};\n\t} else {\n\t\tstyle = createStyleElement(options);\n\t\tupdate = applyToTag.bind(null, style);\n\t\tremove = function () {\n\t\t\tremoveStyleElement(style);\n\t\t};\n\t}\n\n\tupdate(obj);\n\n\treturn function updateStyle (newObj) {\n\t\tif (newObj) {\n\t\t\tif (\n\t\t\t\tnewObj.css === obj.css &&\n\t\t\t\tnewObj.media === obj.media &&\n\t\t\t\tnewObj.sourceMap === obj.sourceMap\n\t\t\t) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tupdate(obj = newObj);\n\t\t} else {\n\t\t\tremove();\n\t\t}\n\t};\n}\n\nvar replaceText = (function () {\n\tvar textStore = [];\n\n\treturn function (index, replacement) {\n\t\ttextStore[index] = replacement;\n\n\t\treturn textStore.filter(Boolean).join('\\n');\n\t};\n})();\n\nfunction applyToSingletonTag (style, index, remove, obj) {\n\tvar css = remove ? \"\" : obj.css;\n\n\tif (style.styleSheet) {\n\t\tstyle.styleSheet.cssText = replaceText(index, css);\n\t} else {\n\t\tvar cssNode = document.createTextNode(css);\n\t\tvar childNodes = style.childNodes;\n\n\t\tif (childNodes[index]) style.removeChild(childNodes[index]);\n\n\t\tif (childNodes.length) {\n\t\t\tstyle.insertBefore(cssNode, childNodes[index]);\n\t\t} else {\n\t\t\tstyle.appendChild(cssNode);\n\t\t}\n\t}\n}\n\nfunction applyToTag (style, obj) {\n\tvar css = obj.css;\n\tvar media = obj.media;\n\n\tif(media) {\n\t\tstyle.setAttribute(\"media\", media)\n\t}\n\n\tif(style.styleSheet) {\n\t\tstyle.styleSheet.cssText = css;\n\t} else {\n\t\twhile(style.firstChild) {\n\t\t\tstyle.removeChild(style.firstChild);\n\t\t}\n\n\t\tstyle.appendChild(document.createTextNode(css));\n\t}\n}\n\nfunction updateLink (link, options, obj) {\n\tvar css = obj.css;\n\tvar sourceMap = obj.sourceMap;\n\n\t/*\n\t\tIf convertToAbsoluteUrls isn't defined, but sourcemaps are enabled\n\t\tand there is no publicPath defined then lets turn convertToAbsoluteUrls\n\t\ton by default.  Otherwise default to the convertToAbsoluteUrls option\n\t\tdirectly\n\t*/\n\tvar autoFixUrls = options.convertToAbsoluteUrls === undefined && sourceMap;\n\n\tif (options.convertToAbsoluteUrls || autoFixUrls) {\n\t\tcss = fixUrls(css);\n\t}\n\n\tif (sourceMap) {\n\t\t// http://stackoverflow.com/a/26603875\n\t\tcss += \"\\n/*# sourceMappingURL=data:application/json;base64,\" + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + \" */\";\n\t}\n\n\tvar blob = new Blob([css], { type: \"text/css\" });\n\n\tvar oldSrc = link.href;\n\n\tlink.href = URL.createObjectURL(blob);\n\n\tif(oldSrc) URL.revokeObjectURL(oldSrc);\n}\n","\n/**\n * When source maps are enabled, `style-loader` uses a link element with a data-uri to\n * embed the css on the page. This breaks all relative urls because now they are relative to a\n * bundle instead of the current page.\n *\n * One solution is to only use full urls, but that may be impossible.\n *\n * Instead, this function \"fixes\" the relative urls to be absolute according to the current page location.\n *\n * A rudimentary test suite is located at `test/fixUrls.js` and can be run via the `npm test` command.\n *\n */\n\nmodule.exports = function (css) {\n  // get current location\n  var location = typeof window !== \"undefined\" && window.location;\n\n  if (!location) {\n    throw new Error(\"fixUrls requires window.location\");\n  }\n\n\t// blank or null?\n\tif (!css || typeof css !== \"string\") {\n\t  return css;\n  }\n\n  var baseUrl = location.protocol + \"//\" + location.host;\n  var currentDir = baseUrl + location.pathname.replace(/\\/[^\\/]*$/, \"/\");\n\n\t// convert each url(...)\n\t/*\n\tThis regular expression is just a way to recursively match brackets within\n\ta string.\n\n\t /url\\s*\\(  = Match on the word \"url\" with any whitespace after it and then a parens\n\t   (  = Start a capturing group\n\t     (?:  = Start a non-capturing group\n\t         [^)(]  = Match anything that isn't a parentheses\n\t         |  = OR\n\t         \\(  = Match a start parentheses\n\t             (?:  = Start another non-capturing groups\n\t                 [^)(]+  = Match anything that isn't a parentheses\n\t                 |  = OR\n\t                 \\(  = Match a start parentheses\n\t                     [^)(]*  = Match anything that isn't a parentheses\n\t                 \\)  = Match a end parentheses\n\t             )  = End Group\n              *\\) = Match anything and then a close parens\n          )  = Close non-capturing group\n          *  = Match anything\n       )  = Close capturing group\n\t \\)  = Match a close parens\n\n\t /gi  = Get all matches, not the first.  Be case insensitive.\n\t */\n\tvar fixedCss = css.replace(/url\\s*\\(((?:[^)(]|\\((?:[^)(]+|\\([^)(]*\\))*\\))*)\\)/gi, function(fullMatch, origUrl) {\n\t\t// strip quotes (if they exist)\n\t\tvar unquotedOrigUrl = origUrl\n\t\t\t.trim()\n\t\t\t.replace(/^\"(.*)\"$/, function(o, $1){ return $1; })\n\t\t\t.replace(/^'(.*)'$/, function(o, $1){ return $1; });\n\n\t\t// already a full url? no change\n\t\tif (/^(#|data:|http:\\/\\/|https:\\/\\/|file:\\/\\/\\/|\\s*$)/i.test(unquotedOrigUrl)) {\n\t\t  return fullMatch;\n\t\t}\n\n\t\t// convert the url to a full url\n\t\tvar newUrl;\n\n\t\tif (unquotedOrigUrl.indexOf(\"//\") === 0) {\n\t\t  \t//TODO: should we add protocol?\n\t\t\tnewUrl = unquotedOrigUrl;\n\t\t} else if (unquotedOrigUrl.indexOf(\"/\") === 0) {\n\t\t\t// path should be relative to the base url\n\t\t\tnewUrl = baseUrl + unquotedOrigUrl; // already starts with '/'\n\t\t} else {\n\t\t\t// path should be relative to current directory\n\t\t\tnewUrl = currentDir + unquotedOrigUrl.replace(/^\\.\\//, \"\"); // Strip leading './'\n\t\t}\n\n\t\t// send back the fixed url(...)\n\t\treturn \"url(\" + JSON.stringify(newUrl) + \")\";\n\t});\n\n\t// send back the fixed css\n\treturn fixedCss;\n};\n","module.exports = function() {\n  return require(\"!!/mnt/data/jenkins/workspace/A360_firefly.js_master/node_modules/worker-loader/dist/workers/InlineWorker.js\")(\"/*!\\n * LMV v7.52.0\\n * \\n * Copyright 2021 Autodesk, Inc.\\n * All rights reserved.\\n * \\n * This computer source code and related instructions and comments are the\\n * unpublished confidential and proprietary information of Autodesk, Inc.\\n * and are protected under Federal copyright and state trade secret law.\\n * They may not be disclosed to, copied or used by any third party without\\n * the prior written consent of Autodesk, Inc.\\n * \\n * Autodesk Forge Viewer Usage Limitations:\\n * \\n * The Autodesk Forge viewer can only be used to view files generated by\\n * Autodesk Forge services. The Autodesk Forge Viewer JavaScript must be\\n * delivered from an Autodesk hosted URL.\\n */\\n/******/ (function(modules) { // webpackBootstrap\\n/******/ \\t// The module cache\\n/******/ \\tvar installedModules = {};\\n/******/\\n/******/ \\t// The require function\\n/******/ \\tfunction __webpack_require__(moduleId) {\\n/******/\\n/******/ \\t\\t// Check if module is in cache\\n/******/ \\t\\tif(installedModules[moduleId]) {\\n/******/ \\t\\t\\treturn installedModules[moduleId].exports;\\n/******/ \\t\\t}\\n/******/ \\t\\t// Create a new module (and put it into the cache)\\n/******/ \\t\\tvar module = installedModules[moduleId] = {\\n/******/ \\t\\t\\ti: moduleId,\\n/******/ \\t\\t\\tl: false,\\n/******/ \\t\\t\\texports: {}\\n/******/ \\t\\t};\\n/******/\\n/******/ \\t\\t// Execute the module function\\n/******/ \\t\\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\\n/******/\\n/******/ \\t\\t// Flag the module as loaded\\n/******/ \\t\\tmodule.l = true;\\n/******/\\n/******/ \\t\\t// Return the exports of the module\\n/******/ \\t\\treturn module.exports;\\n/******/ \\t}\\n/******/\\n/******/\\n/******/ \\t// expose the modules object (__webpack_modules__)\\n/******/ \\t__webpack_require__.m = modules;\\n/******/\\n/******/ \\t// expose the module cache\\n/******/ \\t__webpack_require__.c = installedModules;\\n/******/\\n/******/ \\t// define getter function for harmony exports\\n/******/ \\t__webpack_require__.d = function(exports, name, getter) {\\n/******/ \\t\\tif(!__webpack_require__.o(exports, name)) {\\n/******/ \\t\\t\\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\\n/******/ \\t\\t}\\n/******/ \\t};\\n/******/\\n/******/ \\t// define __esModule on exports\\n/******/ \\t__webpack_require__.r = function(exports) {\\n/******/ \\t\\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\\n/******/ \\t\\t\\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\\n/******/ \\t\\t}\\n/******/ \\t\\tObject.defineProperty(exports, '__esModule', { value: true });\\n/******/ \\t};\\n/******/\\n/******/ \\t// create a fake namespace object\\n/******/ \\t// mode & 1: value is a module id, require it\\n/******/ \\t// mode & 2: merge all properties of value into the ns\\n/******/ \\t// mode & 4: return value when already ns object\\n/******/ \\t// mode & 8|1: behave like require\\n/******/ \\t__webpack_require__.t = function(value, mode) {\\n/******/ \\t\\tif(mode & 1) value = __webpack_require__(value);\\n/******/ \\t\\tif(mode & 8) return value;\\n/******/ \\t\\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\\n/******/ \\t\\tvar ns = Object.create(null);\\n/******/ \\t\\t__webpack_require__.r(ns);\\n/******/ \\t\\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\\n/******/ \\t\\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\\n/******/ \\t\\treturn ns;\\n/******/ \\t};\\n/******/\\n/******/ \\t// getDefaultExport function for compatibility with non-harmony modules\\n/******/ \\t__webpack_require__.n = function(module) {\\n/******/ \\t\\tvar getter = module && module.__esModule ?\\n/******/ \\t\\t\\tfunction getDefault() { return module['default']; } :\\n/******/ \\t\\t\\tfunction getModuleExports() { return module; };\\n/******/ \\t\\t__webpack_require__.d(getter, 'a', getter);\\n/******/ \\t\\treturn getter;\\n/******/ \\t};\\n/******/\\n/******/ \\t// Object.prototype.hasOwnProperty.call\\n/******/ \\t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\\n/******/\\n/******/ \\t// __webpack_public_path__\\n/******/ \\t__webpack_require__.p = \\\"\\\";\\n/******/\\n/******/\\n/******/ \\t// Load entry module and return exports\\n/******/ \\treturn __webpack_require__(__webpack_require__.s = \\\"./node_modules/babel-loader/lib/index.js?!./extensions/Edit2D/SegmentTreeWorker.js\\\");\\n/******/ })\\n/************************************************************************/\\n/******/ ({\\n\\n/***/ \\\"./extensions/MemoryLimited/thirdparty/three.js/three-worker.js\\\":\\n/*!**********************************************************************!*\\\\\\n  !*** ./extensions/MemoryLimited/thirdparty/three.js/three-worker.js ***!\\n  \\\\**********************************************************************/\\n/*! no static exports found */\\n/***/ (function(module, exports, __webpack_require__) {\\n\\n/* WEBPACK VAR INJECTION */(function(module) {function _typeof(obj) {\\\"@babel/helpers - typeof\\\";if (typeof Symbol === \\\"function\\\" && typeof Symbol.iterator === \\\"symbol\\\") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === \\\"function\\\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \\\"symbol\\\" : typeof obj;};}return _typeof(obj);} // File:src/Three.js\\n\\n/**\\n * @author mrdoob / http://mrdoob.com/\\n */\\n\\nvar THREE = { REVISION: '71' };\\n\\n// browserify support\\n\\nif (( false ? undefined : _typeof(module)) === 'object') {\\n\\n  module.exports = THREE;\\n\\n}\\n\\n// polyfills\\n\\nif (Math.sign === undefined) {\\n\\n  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sign\\n\\n  Math.sign = function (x) {\\n\\n    return x < 0 ? -1 : x > 0 ? 1 : +x;\\n\\n  };\\n\\n}\\n\\n\\n// set the default log handlers\\nTHREE.log = function () {console.log.apply(console, arguments);};\\nTHREE.warn = function () {console.warn.apply(console, arguments);};\\nTHREE.error = function () {console.error.apply(console, arguments);};\\n\\n\\n// https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent.button\\n\\nTHREE.MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2 };\\n\\n// GL STATE CONSTANTS\\n\\nTHREE.CullFaceNone = 0;\\nTHREE.CullFaceBack = 1;\\nTHREE.CullFaceFront = 2;\\nTHREE.CullFaceFrontBack = 3;\\n\\nTHREE.FrontFaceDirectionCW = 0;\\nTHREE.FrontFaceDirectionCCW = 1;\\n\\n// SHADOWING TYPES\\n\\nTHREE.BasicShadowMap = 0;\\nTHREE.PCFShadowMap = 1;\\nTHREE.PCFSoftShadowMap = 2;\\n\\n// MATERIAL CONSTANTS\\n\\n// side\\n\\nTHREE.FrontSide = 0;\\nTHREE.BackSide = 1;\\nTHREE.DoubleSide = 2;\\n\\n// shading\\n\\nTHREE.NoShading = 0;\\nTHREE.FlatShading = 1;\\nTHREE.SmoothShading = 2;\\n\\n// colors\\n\\nTHREE.NoColors = 0;\\nTHREE.FaceColors = 1;\\nTHREE.VertexColors = 2;\\n\\n// blending modes\\n\\nTHREE.NoBlending = 0;\\nTHREE.NormalBlending = 1;\\nTHREE.AdditiveBlending = 2;\\nTHREE.SubtractiveBlending = 3;\\nTHREE.MultiplyBlending = 4;\\nTHREE.CustomBlending = 5;\\n\\n// custom blending equations\\n// (numbers start from 100 not to clash with other\\n//  mappings to OpenGL constants defined in Texture.js)\\n\\nTHREE.AddEquation = 100;\\nTHREE.SubtractEquation = 101;\\nTHREE.ReverseSubtractEquation = 102;\\nTHREE.MinEquation = 103;\\nTHREE.MaxEquation = 104;\\n\\n// custom blending destination factors\\n\\nTHREE.ZeroFactor = 200;\\nTHREE.OneFactor = 201;\\nTHREE.SrcColorFactor = 202;\\nTHREE.OneMinusSrcColorFactor = 203;\\nTHREE.SrcAlphaFactor = 204;\\nTHREE.OneMinusSrcAlphaFactor = 205;\\nTHREE.DstAlphaFactor = 206;\\nTHREE.OneMinusDstAlphaFactor = 207;\\n\\n// custom blending source factors\\n\\n//THREE.ZeroFactor = 200;\\n//THREE.OneFactor = 201;\\n//THREE.SrcAlphaFactor = 204;\\n//THREE.OneMinusSrcAlphaFactor = 205;\\n//THREE.DstAlphaFactor = 206;\\n//THREE.OneMinusDstAlphaFactor = 207;\\nTHREE.DstColorFactor = 208;\\nTHREE.OneMinusDstColorFactor = 209;\\nTHREE.SrcAlphaSaturateFactor = 210;\\n\\n\\n// TEXTURE CONSTANTS\\n\\nTHREE.MultiplyOperation = 0;\\nTHREE.MixOperation = 1;\\nTHREE.AddOperation = 2;\\n\\n// Mapping modes\\n\\nTHREE.UVMapping = 300;\\n\\nTHREE.CubeReflectionMapping = 301;\\nTHREE.CubeRefractionMapping = 302;\\n\\nTHREE.EquirectangularReflectionMapping = 303;\\nTHREE.EquirectangularRefractionMapping = 304;\\n\\nTHREE.SphericalReflectionMapping = 305;\\n\\n// Wrapping modes\\n\\nTHREE.RepeatWrapping = 1000;\\nTHREE.ClampToEdgeWrapping = 1001;\\nTHREE.MirroredRepeatWrapping = 1002;\\n\\n// Filters\\n\\nTHREE.NearestFilter = 1003;\\nTHREE.NearestMipMapNearestFilter = 1004;\\nTHREE.NearestMipMapLinearFilter = 1005;\\nTHREE.LinearFilter = 1006;\\nTHREE.LinearMipMapNearestFilter = 1007;\\nTHREE.LinearMipMapLinearFilter = 1008;\\n\\n// Data types\\n\\nTHREE.UnsignedByteType = 1009;\\nTHREE.ByteType = 1010;\\nTHREE.ShortType = 1011;\\nTHREE.UnsignedShortType = 1012;\\nTHREE.IntType = 1013;\\nTHREE.UnsignedIntType = 1014;\\nTHREE.FloatType = 1015;\\nTHREE.HalfFloatType = 1025;\\n\\n// Pixel types\\n\\n//THREE.UnsignedByteType = 1009;\\nTHREE.UnsignedShort4444Type = 1016;\\nTHREE.UnsignedShort5551Type = 1017;\\nTHREE.UnsignedShort565Type = 1018;\\n\\n// Pixel formats\\n\\nTHREE.AlphaFormat = 1019;\\nTHREE.RGBFormat = 1020;\\nTHREE.RGBAFormat = 1021;\\nTHREE.LuminanceFormat = 1022;\\nTHREE.LuminanceAlphaFormat = 1023;\\n// THREE.RGBEFormat handled as THREE.RGBAFormat in shaders\\nTHREE.RGBEFormat = THREE.RGBAFormat; //1024;\\n\\n// DDS / ST3C Compressed texture formats\\n\\nTHREE.RGB_S3TC_DXT1_Format = 2001;\\nTHREE.RGBA_S3TC_DXT1_Format = 2002;\\nTHREE.RGBA_S3TC_DXT3_Format = 2003;\\nTHREE.RGBA_S3TC_DXT5_Format = 2004;\\n\\n\\n// PVRTC compressed texture formats\\n\\nTHREE.RGB_PVRTC_4BPPV1_Format = 2100;\\nTHREE.RGB_PVRTC_2BPPV1_Format = 2101;\\nTHREE.RGBA_PVRTC_4BPPV1_Format = 2102;\\nTHREE.RGBA_PVRTC_2BPPV1_Format = 2103;\\n\\n\\n// DEPRECATED\\n\\nTHREE.Projector = function () {\\n\\n  THREE.error('THREE.Projector has been moved to /examples/js/renderers/Projector.js.');\\n\\n  this.projectVector = function (vector, camera) {\\n\\n    THREE.warn('THREE.Projector: .projectVector() is now vector.project().');\\n    vector.project(camera);\\n\\n  };\\n\\n  this.unprojectVector = function (vector, camera) {\\n\\n    THREE.warn('THREE.Projector: .unprojectVector() is now vector.unproject().');\\n    vector.unproject(camera);\\n\\n  };\\n\\n  this.pickingRay = function (vector, camera) {\\n\\n    THREE.error('THREE.Projector: .pickingRay() is now raycaster.setFromCamera().');\\n\\n  };\\n\\n};\\n\\nTHREE.CanvasRenderer = function () {\\n\\n  THREE.error('THREE.CanvasRenderer has been moved to /examples/js/renderers/CanvasRenderer.js');\\n\\n  this.domElement = document.createElement('canvas');\\n  this.clear = function () {};\\n  this.render = function () {};\\n  this.setClearColor = function () {};\\n  this.setSize = function () {};\\n\\n};\\n\\n// File:src/math/Quaternion.js\\n\\n/**\\n * @author mikael emtinger / http://gomo.se/\\n * @author alteredq / http://alteredqualia.com/\\n * @author WestLangley / http://github.com/WestLangley\\n * @author bhouston / http://exocortex.com\\n */\\n\\nTHREE.Quaternion = function (x, y, z, w) {\\n\\n  this._x = x || 0;\\n  this._y = y || 0;\\n  this._z = z || 0;\\n  this._w = w !== undefined ? w : 1;\\n\\n};\\n\\nTHREE.Quaternion.prototype = {\\n\\n  constructor: THREE.Quaternion,\\n\\n  _x: 0, _y: 0, _z: 0, _w: 0,\\n\\n  get x() {\\n\\n    return this._x;\\n\\n  },\\n\\n  set x(value) {\\n\\n    this._x = value;\\n    this.onChangeCallback();\\n\\n  },\\n\\n  get y() {\\n\\n    return this._y;\\n\\n  },\\n\\n  set y(value) {\\n\\n    this._y = value;\\n    this.onChangeCallback();\\n\\n  },\\n\\n  get z() {\\n\\n    return this._z;\\n\\n  },\\n\\n  set z(value) {\\n\\n    this._z = value;\\n    this.onChangeCallback();\\n\\n  },\\n\\n  get w() {\\n\\n    return this._w;\\n\\n  },\\n\\n  set w(value) {\\n\\n    this._w = value;\\n    this.onChangeCallback();\\n\\n  },\\n\\n  set: function set(x, y, z, w) {\\n\\n    this._x = x;\\n    this._y = y;\\n    this._z = z;\\n    this._w = w;\\n\\n    this.onChangeCallback();\\n\\n    return this;\\n\\n  },\\n\\n  copy: function copy(quaternion) {\\n\\n    this._x = quaternion.x;\\n    this._y = quaternion.y;\\n    this._z = quaternion.z;\\n    this._w = quaternion.w;\\n\\n    this.onChangeCallback();\\n\\n    return this;\\n\\n  },\\n\\n  setFromEuler: function setFromEuler(euler, update) {\\n\\n    if (euler instanceof THREE.Euler === false) {\\n\\n      throw new Error('THREE.Quaternion: .setFromEuler() now expects a Euler rotation rather than a Vector3 and order.');\\n    }\\n\\n    // http://www.mathworks.com/matlabcentral/fileexchange/\\n    // \\t20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/\\n    //\\tcontent/SpinCalc.m\\n\\n    var c1 = Math.cos(euler._x / 2);\\n    var c2 = Math.cos(euler._y / 2);\\n    var c3 = Math.cos(euler._z / 2);\\n    var s1 = Math.sin(euler._x / 2);\\n    var s2 = Math.sin(euler._y / 2);\\n    var s3 = Math.sin(euler._z / 2);\\n\\n    if (euler.order === 'XYZ') {\\n\\n      this._x = s1 * c2 * c3 + c1 * s2 * s3;\\n      this._y = c1 * s2 * c3 - s1 * c2 * s3;\\n      this._z = c1 * c2 * s3 + s1 * s2 * c3;\\n      this._w = c1 * c2 * c3 - s1 * s2 * s3;\\n\\n    } else if (euler.order === 'YXZ') {\\n\\n      this._x = s1 * c2 * c3 + c1 * s2 * s3;\\n      this._y = c1 * s2 * c3 - s1 * c2 * s3;\\n      this._z = c1 * c2 * s3 - s1 * s2 * c3;\\n      this._w = c1 * c2 * c3 + s1 * s2 * s3;\\n\\n    } else if (euler.order === 'ZXY') {\\n\\n      this._x = s1 * c2 * c3 - c1 * s2 * s3;\\n      this._y = c1 * s2 * c3 + s1 * c2 * s3;\\n      this._z = c1 * c2 * s3 + s1 * s2 * c3;\\n      this._w = c1 * c2 * c3 - s1 * s2 * s3;\\n\\n    } else if (euler.order === 'ZYX') {\\n\\n      this._x = s1 * c2 * c3 - c1 * s2 * s3;\\n      this._y = c1 * s2 * c3 + s1 * c2 * s3;\\n      this._z = c1 * c2 * s3 - s1 * s2 * c3;\\n      this._w = c1 * c2 * c3 + s1 * s2 * s3;\\n\\n    } else if (euler.order === 'YZX') {\\n\\n      this._x = s1 * c2 * c3 + c1 * s2 * s3;\\n      this._y = c1 * s2 * c3 + s1 * c2 * s3;\\n      this._z = c1 * c2 * s3 - s1 * s2 * c3;\\n      this._w = c1 * c2 * c3 - s1 * s2 * s3;\\n\\n    } else if (euler.order === 'XZY') {\\n\\n      this._x = s1 * c2 * c3 - c1 * s2 * s3;\\n      this._y = c1 * s2 * c3 - s1 * c2 * s3;\\n      this._z = c1 * c2 * s3 + s1 * s2 * c3;\\n      this._w = c1 * c2 * c3 + s1 * s2 * s3;\\n\\n    }\\n\\n    if (update !== false) this.onChangeCallback();\\n\\n    return this;\\n\\n  },\\n\\n  setFromAxisAngle: function setFromAxisAngle(axis, angle) {\\n\\n    // http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm\\n\\n    // assumes axis is normalized\\n\\n    var halfAngle = angle / 2,s = Math.sin(halfAngle);\\n\\n    this._x = axis.x * s;\\n    this._y = axis.y * s;\\n    this._z = axis.z * s;\\n    this._w = Math.cos(halfAngle);\\n\\n    this.onChangeCallback();\\n\\n    return this;\\n\\n  },\\n\\n  setFromRotationMatrix: function setFromRotationMatrix(m) {\\n\\n    // http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm\\n\\n    // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\\n\\n    var te = m.elements,\\n\\n    m11 = te[0],m12 = te[4],m13 = te[8],\\n    m21 = te[1],m22 = te[5],m23 = te[9],\\n    m31 = te[2],m32 = te[6],m33 = te[10],\\n\\n    trace = m11 + m22 + m33,\\n    s;\\n\\n    if (trace > 0) {\\n\\n      s = 0.5 / Math.sqrt(trace + 1.0);\\n\\n      this._w = 0.25 / s;\\n      this._x = (m32 - m23) * s;\\n      this._y = (m13 - m31) * s;\\n      this._z = (m21 - m12) * s;\\n\\n    } else if (m11 > m22 && m11 > m33) {\\n\\n      s = 2.0 * Math.sqrt(1.0 + m11 - m22 - m33);\\n\\n      this._w = (m32 - m23) / s;\\n      this._x = 0.25 * s;\\n      this._y = (m12 + m21) / s;\\n      this._z = (m13 + m31) / s;\\n\\n    } else if (m22 > m33) {\\n\\n      s = 2.0 * Math.sqrt(1.0 + m22 - m11 - m33);\\n\\n      this._w = (m13 - m31) / s;\\n      this._x = (m12 + m21) / s;\\n      this._y = 0.25 * s;\\n      this._z = (m23 + m32) / s;\\n\\n    } else {\\n\\n      s = 2.0 * Math.sqrt(1.0 + m33 - m11 - m22);\\n\\n      this._w = (m21 - m12) / s;\\n      this._x = (m13 + m31) / s;\\n      this._y = (m23 + m32) / s;\\n      this._z = 0.25 * s;\\n\\n    }\\n\\n    this.onChangeCallback();\\n\\n    return this;\\n\\n  },\\n\\n  setFromUnitVectors: function () {\\n\\n    // http://lolengine.net/blog/2014/02/24/quaternion-from-two-vectors-final\\n\\n    // assumes direction vectors vFrom and vTo are normalized\\n\\n    var v1, r;\\n\\n    var EPS = 0.000001;\\n\\n    return function (vFrom, vTo) {\\n\\n      if (v1 === undefined) v1 = new THREE.Vector3();\\n\\n      r = vFrom.dot(vTo) + 1;\\n\\n      if (r < EPS) {\\n\\n        r = 0;\\n\\n        if (Math.abs(vFrom.x) > Math.abs(vFrom.z)) {\\n\\n          v1.set(-vFrom.y, vFrom.x, 0);\\n\\n        } else {\\n\\n          v1.set(0, -vFrom.z, vFrom.y);\\n\\n        }\\n\\n      } else {\\n\\n        v1.crossVectors(vFrom, vTo);\\n\\n      }\\n\\n      this._x = v1.x;\\n      this._y = v1.y;\\n      this._z = v1.z;\\n      this._w = r;\\n\\n      this.normalize();\\n\\n      return this;\\n\\n    };\\n\\n  }(),\\n\\n  inverse: function inverse() {\\n\\n    this.conjugate().normalize();\\n\\n    return this;\\n\\n  },\\n\\n  conjugate: function conjugate() {\\n\\n    this._x *= -1;\\n    this._y *= -1;\\n    this._z *= -1;\\n\\n    this.onChangeCallback();\\n\\n    return this;\\n\\n  },\\n\\n  dot: function dot(v) {\\n\\n    return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;\\n\\n  },\\n\\n  lengthSq: function lengthSq() {\\n\\n    return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;\\n\\n  },\\n\\n  length: function length() {\\n\\n    return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);\\n\\n  },\\n\\n  normalize: function normalize() {\\n\\n    var l = this.length();\\n\\n    if (l === 0) {\\n\\n      this._x = 0;\\n      this._y = 0;\\n      this._z = 0;\\n      this._w = 1;\\n\\n    } else {\\n\\n      l = 1 / l;\\n\\n      this._x = this._x * l;\\n      this._y = this._y * l;\\n      this._z = this._z * l;\\n      this._w = this._w * l;\\n\\n    }\\n\\n    this.onChangeCallback();\\n\\n    return this;\\n\\n  },\\n\\n  multiply: function multiply(q, p) {\\n\\n    if (p !== undefined) {\\n\\n      THREE.warn('THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.');\\n      return this.multiplyQuaternions(q, p);\\n\\n    }\\n\\n    return this.multiplyQuaternions(this, q);\\n\\n  },\\n\\n  multiplyQuaternions: function multiplyQuaternions(a, b) {\\n\\n    // from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm\\n\\n    var qax = a._x,qay = a._y,qaz = a._z,qaw = a._w;\\n    var qbx = b._x,qby = b._y,qbz = b._z,qbw = b._w;\\n\\n    this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;\\n    this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;\\n    this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;\\n    this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;\\n\\n    this.onChangeCallback();\\n\\n    return this;\\n\\n  },\\n\\n  multiplyVector3: function multiplyVector3(vector) {\\n\\n    THREE.warn('THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.');\\n    return vector.applyQuaternion(this);\\n\\n  },\\n\\n  slerp: function slerp(qb, t) {\\n\\n    if (t === 0) return this;\\n    if (t === 1) return this.copy(qb);\\n\\n    var x = this._x,y = this._y,z = this._z,w = this._w;\\n\\n    // http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/\\n\\n    var cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;\\n\\n    if (cosHalfTheta < 0) {\\n\\n      this._w = -qb._w;\\n      this._x = -qb._x;\\n      this._y = -qb._y;\\n      this._z = -qb._z;\\n\\n      cosHalfTheta = -cosHalfTheta;\\n\\n    } else {\\n\\n      this.copy(qb);\\n\\n    }\\n\\n    if (cosHalfTheta >= 1.0) {\\n\\n      this._w = w;\\n      this._x = x;\\n      this._y = y;\\n      this._z = z;\\n\\n      return this;\\n\\n    }\\n\\n    var halfTheta = Math.acos(cosHalfTheta);\\n    var sinHalfTheta = Math.sqrt(1.0 - cosHalfTheta * cosHalfTheta);\\n\\n    if (Math.abs(sinHalfTheta) < 0.001) {\\n\\n      this._w = 0.5 * (w + this._w);\\n      this._x = 0.5 * (x + this._x);\\n      this._y = 0.5 * (y + this._y);\\n      this._z = 0.5 * (z + this._z);\\n\\n      return this;\\n\\n    }\\n\\n    var ratioA = Math.sin((1 - t) * halfTheta) / sinHalfTheta,\\n    ratioB = Math.sin(t * halfTheta) / sinHalfTheta;\\n\\n    this._w = w * ratioA + this._w * ratioB;\\n    this._x = x * ratioA + this._x * ratioB;\\n    this._y = y * ratioA + this._y * ratioB;\\n    this._z = z * ratioA + this._z * ratioB;\\n\\n    this.onChangeCallback();\\n\\n    return this;\\n\\n  },\\n\\n  equals: function equals(quaternion) {\\n\\n    return quaternion._x === this._x && quaternion._y === this._y && quaternion._z === this._z && quaternion._w === this._w;\\n\\n  },\\n\\n  fromArray: function fromArray(array, offset) {\\n\\n    if (offset === undefined) offset = 0;\\n\\n    this._x = array[offset];\\n    this._y = array[offset + 1];\\n    this._z = array[offset + 2];\\n    this._w = array[offset + 3];\\n\\n    this.onChangeCallback();\\n\\n    return this;\\n\\n  },\\n\\n  toArray: function toArray(array, offset) {\\n\\n    if (array === undefined) array = [];\\n    if (offset === undefined) offset = 0;\\n\\n    array[offset] = this._x;\\n    array[offset + 1] = this._y;\\n    array[offset + 2] = this._z;\\n    array[offset + 3] = this._w;\\n\\n    return array;\\n\\n  },\\n\\n  onChange: function onChange(callback) {\\n\\n    this.onChangeCallback = callback;\\n\\n    return this;\\n\\n  },\\n\\n  onChangeCallback: function onChangeCallback() {},\\n\\n  clone: function clone() {\\n\\n    return new THREE.Quaternion(this._x, this._y, this._z, this._w);\\n\\n  } };\\n\\n\\n\\nTHREE.Quaternion.slerp = function (qa, qb, qm, t) {\\n\\n  return qm.copy(qa).slerp(qb, t);\\n\\n};\\n\\n// File:src/math/Vector2.js\\n\\n/**\\n * @author mrdoob / http://mrdoob.com/\\n * @author philogb / http://blog.thejit.org/\\n * @author egraether / http://egraether.com/\\n * @author zz85 / http://www.lab4games.net/zz85/blog\\n */\\n\\nTHREE.Vector2 = function (x, y) {\\n\\n  this.x = x || 0;\\n  this.y = y || 0;\\n\\n};\\n\\nTHREE.Vector2.prototype = {\\n\\n  constructor: THREE.Vector2,\\n\\n  set: function set(x, y) {\\n\\n    this.x = x;\\n    this.y = y;\\n\\n    return this;\\n\\n  },\\n\\n  setX: function setX(x) {\\n\\n    this.x = x;\\n\\n    return this;\\n\\n  },\\n\\n  setY: function setY(y) {\\n\\n    this.y = y;\\n\\n    return this;\\n\\n  },\\n\\n  setComponent: function setComponent(index, value) {\\n\\n    switch (index) {\\n\\n      case 0:this.x = value;break;\\n      case 1:this.y = value;break;\\n      default:throw new Error('index is out of range: ' + index);}\\n\\n\\n\\n  },\\n\\n  getComponent: function getComponent(index) {\\n\\n    switch (index) {\\n\\n      case 0:return this.x;\\n      case 1:return this.y;\\n      default:throw new Error('index is out of range: ' + index);}\\n\\n\\n\\n  },\\n\\n  copy: function copy(v) {\\n\\n    this.x = v.x;\\n    this.y = v.y;\\n\\n    return this;\\n\\n  },\\n\\n  add: function add(v, w) {\\n\\n    if (w !== undefined) {\\n\\n      THREE.warn('THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.');\\n      return this.addVectors(v, w);\\n\\n    }\\n\\n    this.x += v.x;\\n    this.y += v.y;\\n\\n    return this;\\n\\n  },\\n\\n  addScalar: function addScalar(s) {\\n\\n    this.x += s;\\n    this.y += s;\\n\\n    return this;\\n\\n  },\\n\\n  addVectors: function addVectors(a, b) {\\n\\n    this.x = a.x + b.x;\\n    this.y = a.y + b.y;\\n\\n    return this;\\n\\n  },\\n\\n  sub: function sub(v, w) {\\n\\n    if (w !== undefined) {\\n\\n      THREE.warn('THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.');\\n      return this.subVectors(v, w);\\n\\n    }\\n\\n    this.x -= v.x;\\n    this.y -= v.y;\\n\\n    return this;\\n\\n  },\\n\\n  subScalar: function subScalar(s) {\\n\\n    this.x -= s;\\n    this.y -= s;\\n\\n    return this;\\n\\n  },\\n\\n  subVectors: function subVectors(a, b) {\\n\\n    this.x = a.x - b.x;\\n    this.y = a.y - b.y;\\n\\n    return this;\\n\\n  },\\n\\n  multiply: function multiply(v) {\\n\\n    this.x *= v.x;\\n    this.y *= v.y;\\n\\n    return this;\\n\\n  },\\n\\n  multiplyScalar: function multiplyScalar(s) {\\n\\n    this.x *= s;\\n    this.y *= s;\\n\\n    return this;\\n\\n  },\\n\\n  divide: function divide(v) {\\n\\n    this.x /= v.x;\\n    this.y /= v.y;\\n\\n    return this;\\n\\n  },\\n\\n  divideScalar: function divideScalar(scalar) {\\n\\n    if (scalar !== 0) {\\n\\n      var invScalar = 1 / scalar;\\n\\n      this.x *= invScalar;\\n      this.y *= invScalar;\\n\\n    } else {\\n\\n      this.x = 0;\\n      this.y = 0;\\n\\n    }\\n\\n    return this;\\n\\n  },\\n\\n  min: function min(v) {\\n\\n    if (this.x > v.x) {\\n\\n      this.x = v.x;\\n\\n    }\\n\\n    if (this.y > v.y) {\\n\\n      this.y = v.y;\\n\\n    }\\n\\n    return this;\\n\\n  },\\n\\n  max: function max(v) {\\n\\n    if (this.x < v.x) {\\n\\n      this.x = v.x;\\n\\n    }\\n\\n    if (this.y < v.y) {\\n\\n      this.y = v.y;\\n\\n    }\\n\\n    return this;\\n\\n  },\\n\\n  clamp: function clamp(min, max) {\\n\\n    // This function assumes min < max, if this assumption isn't true it will not operate correctly\\n\\n    if (this.x < min.x) {\\n\\n      this.x = min.x;\\n\\n    } else if (this.x > max.x) {\\n\\n      this.x = max.x;\\n\\n    }\\n\\n    if (this.y < min.y) {\\n\\n      this.y = min.y;\\n\\n    } else if (this.y > max.y) {\\n\\n      this.y = max.y;\\n\\n    }\\n\\n    return this;\\n  },\\n\\n  clampScalar: function () {\\n\\n    var min, max;\\n\\n    return function (minVal, maxVal) {\\n\\n      if (min === undefined) {\\n\\n        min = new THREE.Vector2();\\n        max = new THREE.Vector2();\\n\\n      }\\n\\n      min.set(minVal, minVal);\\n      max.set(maxVal, maxVal);\\n\\n      return this.clamp(min, max);\\n\\n    };\\n\\n  }(),\\n\\n  floor: function floor() {\\n\\n    this.x = Math.floor(this.x);\\n    this.y = Math.floor(this.y);\\n\\n    return this;\\n\\n  },\\n\\n  ceil: function ceil() {\\n\\n    this.x = Math.ceil(this.x);\\n    this.y = Math.ceil(this.y);\\n\\n    return this;\\n\\n  },\\n\\n  round: function round() {\\n\\n    this.x = Math.round(this.x);\\n    this.y = Math.round(this.y);\\n\\n    return this;\\n\\n  },\\n\\n  roundToZero: function roundToZero() {\\n\\n    this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);\\n    this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);\\n\\n    return this;\\n\\n  },\\n\\n  negate: function negate() {\\n\\n    this.x = -this.x;\\n    this.y = -this.y;\\n\\n    return this;\\n\\n  },\\n\\n  dot: function dot(v) {\\n\\n    return this.x * v.x + this.y * v.y;\\n\\n  },\\n\\n  lengthSq: function lengthSq() {\\n\\n    return this.x * this.x + this.y * this.y;\\n\\n  },\\n\\n  length: function length() {\\n\\n    return Math.sqrt(this.x * this.x + this.y * this.y);\\n\\n  },\\n\\n  normalize: function normalize() {\\n\\n    return this.divideScalar(this.length());\\n\\n  },\\n\\n  distanceTo: function distanceTo(v) {\\n\\n    return Math.sqrt(this.distanceToSquared(v));\\n\\n  },\\n\\n  distanceToSquared: function distanceToSquared(v) {\\n\\n    var dx = this.x - v.x,dy = this.y - v.y;\\n    return dx * dx + dy * dy;\\n\\n  },\\n\\n  setLength: function setLength(l) {\\n\\n    var oldLength = this.length();\\n\\n    if (oldLength !== 0 && l !== oldLength) {\\n\\n      this.multiplyScalar(l / oldLength);\\n    }\\n\\n    return this;\\n\\n  },\\n\\n  lerp: function lerp(v, alpha) {\\n\\n    this.x += (v.x - this.x) * alpha;\\n    this.y += (v.y - this.y) * alpha;\\n\\n    return this;\\n\\n  },\\n\\n  lerpVectors: function lerpVectors(v1, v2, alpha) {\\n\\n    this.subVectors(v2, v1).multiplyScalar(alpha).add(v1);\\n\\n    return this;\\n\\n  },\\n\\n  equals: function equals(v) {\\n\\n    return v.x === this.x && v.y === this.y;\\n\\n  },\\n\\n  fromArray: function fromArray(array, offset) {\\n\\n    if (offset === undefined) offset = 0;\\n\\n    this.x = array[offset];\\n    this.y = array[offset + 1];\\n\\n    return this;\\n\\n  },\\n\\n  toArray: function toArray(array, offset) {\\n\\n    if (array === undefined) array = [];\\n    if (offset === undefined) offset = 0;\\n\\n    array[offset] = this.x;\\n    array[offset + 1] = this.y;\\n\\n    return array;\\n\\n  },\\n\\n  fromAttribute: function fromAttribute(attribute, index, offset) {\\n\\n    if (offset === undefined) offset = 0;\\n\\n    index = index * attribute.itemSize + offset;\\n\\n    this.x = attribute.array[index];\\n    this.y = attribute.array[index + 1];\\n\\n    return this;\\n\\n  },\\n\\n  clone: function clone() {\\n\\n    return new THREE.Vector2(this.x, this.y);\\n\\n  } };\\n\\n\\n\\n// File:src/math/Vector3.js\\n\\n/**\\n * @author mrdoob / http://mrdoob.com/\\n * @author *kile / http://kile.stravaganza.org/\\n * @author philogb / http://blog.thejit.org/\\n * @author mikael emtinger / http://gomo.se/\\n * @author egraether / http://egraether.com/\\n * @author WestLangley / http://github.com/WestLangley\\n */\\n\\nTHREE.Vector3 = function (x, y, z) {\\n\\n  this.x = x || 0;\\n  this.y = y || 0;\\n  this.z = z || 0;\\n\\n};\\n\\nTHREE.Vector3.prototype = {\\n\\n  constructor: THREE.Vector3,\\n\\n  set: function set(x, y, z) {\\n\\n    this.x = x;\\n    this.y = y;\\n    this.z = z;\\n\\n    return this;\\n\\n  },\\n\\n  setX: function setX(x) {\\n\\n    this.x = x;\\n\\n    return this;\\n\\n  },\\n\\n  setY: function setY(y) {\\n\\n    this.y = y;\\n\\n    return this;\\n\\n  },\\n\\n  setZ: function setZ(z) {\\n\\n    this.z = z;\\n\\n    return this;\\n\\n  },\\n\\n  setComponent: function setComponent(index, value) {\\n\\n    switch (index) {\\n\\n      case 0:this.x = value;break;\\n      case 1:this.y = value;break;\\n      case 2:this.z = value;break;\\n      default:throw new Error('index is out of range: ' + index);}\\n\\n\\n\\n  },\\n\\n  getComponent: function getComponent(index) {\\n\\n    switch (index) {\\n\\n      case 0:return this.x;\\n      case 1:return this.y;\\n      case 2:return this.z;\\n      default:throw new Error('index is out of range: ' + index);}\\n\\n\\n\\n  },\\n\\n  copy: function copy(v) {\\n\\n    this.x = v.x;\\n    this.y = v.y;\\n    this.z = v.z;\\n\\n    return this;\\n\\n  },\\n\\n  add: function add(v, w) {\\n\\n    if (w !== undefined) {\\n\\n      THREE.warn('THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.');\\n      return this.addVectors(v, w);\\n\\n    }\\n\\n    this.x += v.x;\\n    this.y += v.y;\\n    this.z += v.z;\\n\\n    return this;\\n\\n  },\\n\\n  addScalar: function addScalar(s) {\\n\\n    this.x += s;\\n    this.y += s;\\n    this.z += s;\\n\\n    return this;\\n\\n  },\\n\\n  addVectors: function addVectors(a, b) {\\n\\n    this.x = a.x + b.x;\\n    this.y = a.y + b.y;\\n    this.z = a.z + b.z;\\n\\n    return this;\\n\\n  },\\n\\n  sub: function sub(v, w) {\\n\\n    if (w !== undefined) {\\n\\n      THREE.warn('THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.');\\n      return this.subVectors(v, w);\\n\\n    }\\n\\n    this.x -= v.x;\\n    this.y -= v.y;\\n    this.z -= v.z;\\n\\n    return this;\\n\\n  },\\n\\n  subScalar: function subScalar(s) {\\n\\n    this.x -= s;\\n    this.y -= s;\\n    this.z -= s;\\n\\n    return this;\\n\\n  },\\n\\n  subVectors: function subVectors(a, b) {\\n\\n    this.x = a.x - b.x;\\n    this.y = a.y - b.y;\\n    this.z = a.z - b.z;\\n\\n    return this;\\n\\n  },\\n\\n  multiply: function multiply(v, w) {\\n\\n    if (w !== undefined) {\\n\\n      THREE.warn('THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.');\\n      return this.multiplyVectors(v, w);\\n\\n    }\\n\\n    this.x *= v.x;\\n    this.y *= v.y;\\n    this.z *= v.z;\\n\\n    return this;\\n\\n  },\\n\\n  multiplyScalar: function multiplyScalar(scalar) {\\n\\n    this.x *= scalar;\\n    this.y *= scalar;\\n    this.z *= scalar;\\n\\n    return this;\\n\\n  },\\n\\n  multiplyVectors: function multiplyVectors(a, b) {\\n\\n    this.x = a.x * b.x;\\n    this.y = a.y * b.y;\\n    this.z = a.z * b.z;\\n\\n    return this;\\n\\n  },\\n\\n  applyEuler: function () {\\n\\n    var quaternion;\\n\\n    return function (euler) {\\n\\n      if (euler instanceof THREE.Euler === false) {\\n\\n        THREE.error('THREE.Vector3: .applyEuler() now expects a Euler rotation rather than a Vector3 and order.');\\n\\n      }\\n\\n      if (quaternion === undefined) quaternion = new THREE.Quaternion();\\n\\n      this.applyQuaternion(quaternion.setFromEuler(euler));\\n\\n      return this;\\n\\n    };\\n\\n  }(),\\n\\n  applyAxisAngle: function () {\\n\\n    var quaternion;\\n\\n    return function (axis, angle) {\\n\\n      if (quaternion === undefined) quaternion = new THREE.Quaternion();\\n\\n      this.applyQuaternion(quaternion.setFromAxisAngle(axis, angle));\\n\\n      return this;\\n\\n    };\\n\\n  }(),\\n\\n  applyMatrix3: function applyMatrix3(m) {\\n\\n    var x = this.x;\\n    var y = this.y;\\n    var z = this.z;\\n\\n    var e = m.elements;\\n\\n    this.x = e[0] * x + e[3] * y + e[6] * z;\\n    this.y = e[1] * x + e[4] * y + e[7] * z;\\n    this.z = e[2] * x + e[5] * y + e[8] * z;\\n\\n    return this;\\n\\n  },\\n\\n  applyMatrix4: function applyMatrix4(m) {\\n\\n    // input: THREE.Matrix4 affine matrix\\n\\n    var x = this.x,y = this.y,z = this.z;\\n\\n    var e = m.elements;\\n\\n    this.x = e[0] * x + e[4] * y + e[8] * z + e[12];\\n    this.y = e[1] * x + e[5] * y + e[9] * z + e[13];\\n    this.z = e[2] * x + e[6] * y + e[10] * z + e[14];\\n\\n    return this;\\n\\n  },\\n\\n  applyProjection: function applyProjection(m) {\\n\\n    // input: THREE.Matrix4 projection matrix\\n\\n    var x = this.x,y = this.y,z = this.z;\\n\\n    var e = m.elements;\\n    var d = 1 / (e[3] * x + e[7] * y + e[11] * z + e[15]); // perspective divide\\n\\n    this.x = (e[0] * x + e[4] * y + e[8] * z + e[12]) * d;\\n    this.y = (e[1] * x + e[5] * y + e[9] * z + e[13]) * d;\\n    this.z = (e[2] * x + e[6] * y + e[10] * z + e[14]) * d;\\n\\n    return this;\\n\\n  },\\n\\n  applyQuaternion: function applyQuaternion(q) {\\n\\n    var x = this.x;\\n    var y = this.y;\\n    var z = this.z;\\n\\n    var qx = q.x;\\n    var qy = q.y;\\n    var qz = q.z;\\n    var qw = q.w;\\n\\n    // calculate quat * vector\\n\\n    var ix = qw * x + qy * z - qz * y;\\n    var iy = qw * y + qz * x - qx * z;\\n    var iz = qw * z + qx * y - qy * x;\\n    var iw = -qx * x - qy * y - qz * z;\\n\\n    // calculate result * inverse quat\\n\\n    this.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;\\n    this.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;\\n    this.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;\\n\\n    return this;\\n\\n  },\\n\\n  project: function () {\\n\\n    var matrix;\\n\\n    return function (camera) {\\n\\n      if (matrix === undefined) matrix = new THREE.Matrix4();\\n\\n      matrix.multiplyMatrices(camera.projectionMatrix, matrix.getInverse(camera.matrixWorld));\\n      return this.applyProjection(matrix);\\n\\n    };\\n\\n  }(),\\n\\n  unproject: function () {\\n\\n    var matrix;\\n\\n    return function (camera) {\\n\\n      if (matrix === undefined) matrix = new THREE.Matrix4();\\n\\n      matrix.multiplyMatrices(camera.matrixWorld, matrix.getInverse(camera.projectionMatrix));\\n      return this.applyProjection(matrix);\\n\\n    };\\n\\n  }(),\\n\\n  transformDirection: function transformDirection(m) {\\n\\n    // input: THREE.Matrix4 affine matrix\\n    // vector interpreted as a direction\\n\\n    var x = this.x,y = this.y,z = this.z;\\n\\n    var e = m.elements;\\n\\n    this.x = e[0] * x + e[4] * y + e[8] * z;\\n    this.y = e[1] * x + e[5] * y + e[9] * z;\\n    this.z = e[2] * x + e[6] * y + e[10] * z;\\n\\n    this.normalize();\\n\\n    return this;\\n\\n  },\\n\\n  divide: function divide(v) {\\n\\n    this.x /= v.x;\\n    this.y /= v.y;\\n    this.z /= v.z;\\n\\n    return this;\\n\\n  },\\n\\n  divideScalar: function divideScalar(scalar) {\\n\\n    if (scalar !== 0) {\\n\\n      var invScalar = 1 / scalar;\\n\\n      this.x *= invScalar;\\n      this.y *= invScalar;\\n      this.z *= invScalar;\\n\\n    } else {\\n\\n      this.x = 0;\\n      this.y = 0;\\n      this.z = 0;\\n\\n    }\\n\\n    return this;\\n\\n  },\\n\\n  min: function min(v) {\\n\\n    if (this.x > v.x) {\\n\\n      this.x = v.x;\\n\\n    }\\n\\n    if (this.y > v.y) {\\n\\n      this.y = v.y;\\n\\n    }\\n\\n    if (this.z > v.z) {\\n\\n      this.z = v.z;\\n\\n    }\\n\\n    return this;\\n\\n  },\\n\\n  max: function max(v) {\\n\\n    if (this.x < v.x) {\\n\\n      this.x = v.x;\\n\\n    }\\n\\n    if (this.y < v.y) {\\n\\n      this.y = v.y;\\n\\n    }\\n\\n    if (this.z < v.z) {\\n\\n      this.z = v.z;\\n\\n    }\\n\\n    return this;\\n\\n  },\\n\\n  clamp: function clamp(min, max) {\\n\\n    // This function assumes min < max, if this assumption isn't true it will not operate correctly\\n\\n    if (this.x < min.x) {\\n\\n      this.x = min.x;\\n\\n    } else if (this.x > max.x) {\\n\\n      this.x = max.x;\\n\\n    }\\n\\n    if (this.y < min.y) {\\n\\n      this.y = min.y;\\n\\n    } else if (this.y > max.y) {\\n\\n      this.y = max.y;\\n\\n    }\\n\\n    if (this.z < min.z) {\\n\\n      this.z = min.z;\\n\\n    } else if (this.z > max.z) {\\n\\n      this.z = max.z;\\n\\n    }\\n\\n    return this;\\n\\n  },\\n\\n  clampScalar: function () {\\n\\n    var min, max;\\n\\n    return function (minVal, maxVal) {\\n\\n      if (min === undefined) {\\n\\n        min = new THREE.Vector3();\\n        max = new THREE.Vector3();\\n\\n      }\\n\\n      min.set(minVal, minVal, minVal);\\n      max.set(maxVal, maxVal, maxVal);\\n\\n      return this.clamp(min, max);\\n\\n    };\\n\\n  }(),\\n\\n  floor: function floor() {\\n\\n    this.x = Math.floor(this.x);\\n    this.y = Math.floor(this.y);\\n    this.z = Math.floor(this.z);\\n\\n    return this;\\n\\n  },\\n\\n  ceil: function ceil() {\\n\\n    this.x = Math.ceil(this.x);\\n    this.y = Math.ceil(this.y);\\n    this.z = Math.ceil(this.z);\\n\\n    return this;\\n\\n  },\\n\\n  round: function round() {\\n\\n    this.x = Math.round(this.x);\\n    this.y = Math.round(this.y);\\n    this.z = Math.round(this.z);\\n\\n    return this;\\n\\n  },\\n\\n  roundToZero: function roundToZero() {\\n\\n    this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);\\n    this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);\\n    this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z);\\n\\n    return this;\\n\\n  },\\n\\n  negate: function negate() {\\n\\n    this.x = -this.x;\\n    this.y = -this.y;\\n    this.z = -this.z;\\n\\n    return this;\\n\\n  },\\n\\n  dot: function dot(v) {\\n\\n    return this.x * v.x + this.y * v.y + this.z * v.z;\\n\\n  },\\n\\n  lengthSq: function lengthSq() {\\n\\n    return this.x * this.x + this.y * this.y + this.z * this.z;\\n\\n  },\\n\\n  length: function length() {\\n\\n    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);\\n\\n  },\\n\\n  lengthManhattan: function lengthManhattan() {\\n\\n    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);\\n\\n  },\\n\\n  normalize: function normalize() {\\n\\n    return this.divideScalar(this.length());\\n\\n  },\\n\\n  setLength: function setLength(l) {\\n\\n    var oldLength = this.length();\\n\\n    if (oldLength !== 0 && l !== oldLength) {\\n\\n      this.multiplyScalar(l / oldLength);\\n    }\\n\\n    return this;\\n\\n  },\\n\\n  lerp: function lerp(v, alpha) {\\n\\n    this.x += (v.x - this.x) * alpha;\\n    this.y += (v.y - this.y) * alpha;\\n    this.z += (v.z - this.z) * alpha;\\n\\n    return this;\\n\\n  },\\n\\n  lerpVectors: function lerpVectors(v1, v2, alpha) {\\n\\n    this.subVectors(v2, v1).multiplyScalar(alpha).add(v1);\\n\\n    return this;\\n\\n  },\\n\\n  cross: function cross(v, w) {\\n\\n    if (w !== undefined) {\\n\\n      THREE.warn('THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.');\\n      return this.crossVectors(v, w);\\n\\n    }\\n\\n    var x = this.x,y = this.y,z = this.z;\\n\\n    this.x = y * v.z - z * v.y;\\n    this.y = z * v.x - x * v.z;\\n    this.z = x * v.y - y * v.x;\\n\\n    return this;\\n\\n  },\\n\\n  crossVectors: function crossVectors(a, b) {\\n\\n    var ax = a.x,ay = a.y,az = a.z;\\n    var bx = b.x,by = b.y,bz = b.z;\\n\\n    this.x = ay * bz - az * by;\\n    this.y = az * bx - ax * bz;\\n    this.z = ax * by - ay * bx;\\n\\n    return this;\\n\\n  },\\n\\n  projectOnVector: function () {\\n\\n    var v1, dot;\\n\\n    return function (vector) {\\n\\n      if (v1 === undefined) v1 = new THREE.Vector3();\\n\\n      v1.copy(vector).normalize();\\n\\n      dot = this.dot(v1);\\n\\n      return this.copy(v1).multiplyScalar(dot);\\n\\n    };\\n\\n  }(),\\n\\n  projectOnPlane: function () {\\n\\n    var v1;\\n\\n    return function (planeNormal) {\\n\\n      if (v1 === undefined) v1 = new THREE.Vector3();\\n\\n      v1.copy(this).projectOnVector(planeNormal);\\n\\n      return this.sub(v1);\\n\\n    };\\n\\n  }(),\\n\\n  reflect: function () {\\n\\n    // reflect incident vector off plane orthogonal to normal\\n    // normal is assumed to have unit length\\n\\n    var v1;\\n\\n    return function (normal) {\\n\\n      if (v1 === undefined) v1 = new THREE.Vector3();\\n\\n      return this.sub(v1.copy(normal).multiplyScalar(2 * this.dot(normal)));\\n\\n    };\\n\\n  }(),\\n\\n  angleTo: function angleTo(v) {\\n\\n    var theta = this.dot(v) / (this.length() * v.length());\\n\\n    // clamp, to handle numerical problems\\n\\n    return Math.acos(THREE.Math.clamp(theta, -1, 1));\\n\\n  },\\n\\n  distanceTo: function distanceTo(v) {\\n\\n    return Math.sqrt(this.distanceToSquared(v));\\n\\n  },\\n\\n  distanceToSquared: function distanceToSquared(v) {\\n\\n    var dx = this.x - v.x;\\n    var dy = this.y - v.y;\\n    var dz = this.z - v.z;\\n\\n    return dx * dx + dy * dy + dz * dz;\\n\\n  },\\n\\n  setEulerFromRotationMatrix: function setEulerFromRotationMatrix(m, order) {\\n\\n    THREE.error('THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.');\\n\\n  },\\n\\n  setEulerFromQuaternion: function setEulerFromQuaternion(q, order) {\\n\\n    THREE.error('THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.');\\n\\n  },\\n\\n  getPositionFromMatrix: function getPositionFromMatrix(m) {\\n\\n    THREE.warn('THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().');\\n\\n    return this.setFromMatrixPosition(m);\\n\\n  },\\n\\n  getScaleFromMatrix: function getScaleFromMatrix(m) {\\n\\n    THREE.warn('THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().');\\n\\n    return this.setFromMatrixScale(m);\\n  },\\n\\n  getColumnFromMatrix: function getColumnFromMatrix(index, matrix) {\\n\\n    THREE.warn('THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().');\\n\\n    return this.setFromMatrixColumn(index, matrix);\\n\\n  },\\n\\n  setFromMatrixPosition: function setFromMatrixPosition(m) {\\n\\n    this.x = m.elements[12];\\n    this.y = m.elements[13];\\n    this.z = m.elements[14];\\n\\n    return this;\\n\\n  },\\n\\n  setFromMatrixScale: function setFromMatrixScale(m) {\\n\\n    var sx = this.set(m.elements[0], m.elements[1], m.elements[2]).length();\\n    var sy = this.set(m.elements[4], m.elements[5], m.elements[6]).length();\\n    var sz = this.set(m.elements[8], m.elements[9], m.elements[10]).length();\\n\\n    this.x = sx;\\n    this.y = sy;\\n    this.z = sz;\\n\\n    return this;\\n  },\\n\\n  setFromMatrixColumn: function setFromMatrixColumn(index, matrix) {\\n\\n    var offset = index * 4;\\n\\n    var me = matrix.elements;\\n\\n    this.x = me[offset];\\n    this.y = me[offset + 1];\\n    this.z = me[offset + 2];\\n\\n    return this;\\n\\n  },\\n\\n  equals: function equals(v) {\\n\\n    return v.x === this.x && v.y === this.y && v.z === this.z;\\n\\n  },\\n\\n  fromArray: function fromArray(array, offset) {\\n\\n    if (offset === undefined) offset = 0;\\n\\n    this.x = array[offset];\\n    this.y = array[offset + 1];\\n    this.z = array[offset + 2];\\n\\n    return this;\\n\\n  },\\n\\n  toArray: function toArray(array, offset) {\\n\\n    if (array === undefined) array = [];\\n    if (offset === undefined) offset = 0;\\n\\n    array[offset] = this.x;\\n    array[offset + 1] = this.y;\\n    array[offset + 2] = this.z;\\n\\n    return array;\\n\\n  },\\n\\n  fromAttribute: function fromAttribute(attribute, index, offset) {\\n\\n    if (offset === undefined) offset = 0;\\n\\n    index = index * attribute.itemSize + offset;\\n\\n    this.x = attribute.array[index];\\n    this.y = attribute.array[index + 1];\\n    this.z = attribute.array[index + 2];\\n\\n    return this;\\n\\n  },\\n\\n  clone: function clone() {\\n\\n    return new THREE.Vector3(this.x, this.y, this.z);\\n\\n  } };\\n\\n\\n\\n// File:src/math/Box2.js\\n\\n/**\\n * @author bhouston / http://exocortex.com\\n */\\n\\nTHREE.Box2 = function (min, max) {\\n\\n  this.min = min !== undefined ? min : new THREE.Vector2(Infinity, Infinity);\\n  this.max = max !== undefined ? max : new THREE.Vector2(-Infinity, -Infinity);\\n\\n};\\n\\nTHREE.Box2.prototype = {\\n\\n  constructor: THREE.Box2,\\n\\n  set: function set(min, max) {\\n\\n    this.min.copy(min);\\n    this.max.copy(max);\\n\\n    return this;\\n\\n  },\\n\\n  setFromPoints: function setFromPoints(points) {\\n\\n    this.makeEmpty();\\n\\n    for (var i = 0, il = points.length; i < il; i++) {\\n\\n      this.expandByPoint(points[i]);\\n\\n    }\\n\\n    return this;\\n\\n  },\\n\\n  setFromCenterAndSize: function () {\\n\\n    var v1 = new THREE.Vector2();\\n\\n    return function (center, size) {\\n\\n      var halfSize = v1.copy(size).multiplyScalar(0.5);\\n      this.min.copy(center).sub(halfSize);\\n      this.max.copy(center).add(halfSize);\\n\\n      return this;\\n\\n    };\\n\\n  }(),\\n\\n  copy: function copy(box) {\\n\\n    this.min.copy(box.min);\\n    this.max.copy(box.max);\\n\\n    return this;\\n\\n  },\\n\\n  makeEmpty: function makeEmpty() {\\n\\n    this.min.x = this.min.y = Infinity;\\n    this.max.x = this.max.y = -Infinity;\\n\\n    return this;\\n\\n  },\\n\\n  empty: function empty() {\\n\\n    // https://github.com/mrdoob/three.js/blob/dev/src/math/Box2.js\\n\\n    console.warn('Box2.empty has been deprecated. Use Box2.isEmpty instead');\\n\\n    return this.isEmpty();\\n\\n  },\\n\\n  isEmpty: function isEmpty() {\\n\\n    // this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes\\n\\n    return this.max.x < this.min.x || this.max.y < this.min.y;\\n\\n  },\\n\\n  center: function center(optionalTarget) {\\n\\n    console.warn(\\\"Box2.center() is deprecated. Use Box2.getCenter() instead.\\\");\\n    return this.getCenter(optionalTarget);\\n\\n  },\\n\\n  getCenter: function getCenter(optionalTarget) {\\n\\n    var result = optionalTarget || new THREE.Vector2();\\n    return result.addVectors(this.min, this.max).multiplyScalar(0.5);\\n\\n  },\\n\\n  size: function size(optionalTarget) {\\n\\n    var result = optionalTarget || new THREE.Vector2();\\n    return result.subVectors(this.max, this.min);\\n\\n  },\\n\\n  expandByPoint: function expandByPoint(point) {\\n\\n    this.min.min(point);\\n    this.max.max(point);\\n\\n    return this;\\n  },\\n\\n  expandByVector: function expandByVector(vector) {\\n\\n    this.min.sub(vector);\\n    this.max.add(vector);\\n\\n    return this;\\n  },\\n\\n  expandByScalar: function expandByScalar(scalar) {\\n\\n    this.min.addScalar(-scalar);\\n    this.max.addScalar(scalar);\\n\\n    return this;\\n  },\\n\\n  containsPoint: function containsPoint(point) {\\n\\n    if (point.x < this.min.x || point.x > this.max.x ||\\n    point.y < this.min.y || point.y > this.max.y) {\\n\\n      return false;\\n\\n    }\\n\\n    return true;\\n\\n  },\\n\\n  containsBox: function containsBox(box) {\\n\\n    if (this.min.x <= box.min.x && box.max.x <= this.max.x &&\\n    this.min.y <= box.min.y && box.max.y <= this.max.y) {\\n\\n      return true;\\n\\n    }\\n\\n    return false;\\n\\n  },\\n\\n  getParameter: function getParameter(point, optionalTarget) {\\n\\n    // This can potentially have a divide by zero if the box\\n    // has a size dimension of 0.\\n\\n    var result = optionalTarget || new THREE.Vector2();\\n\\n    return result.set(\\n    (point.x - this.min.x) / (this.max.x - this.min.x),\\n    (point.y - this.min.y) / (this.max.y - this.min.y));\\n\\n\\n  },\\n\\n  isIntersectionBox: function isIntersectionBox(box) {\\n\\n    // using 6 splitting planes to rule out intersections.\\n\\n    if (box.max.x < this.min.x || box.min.x > this.max.x ||\\n    box.max.y < this.min.y || box.min.y > this.max.y) {\\n\\n      return false;\\n\\n    }\\n\\n    return true;\\n\\n  },\\n\\n  clampPoint: function clampPoint(point, optionalTarget) {\\n\\n    var result = optionalTarget || new THREE.Vector2();\\n    return result.copy(point).clamp(this.min, this.max);\\n\\n  },\\n\\n  distanceToPoint: function () {\\n\\n    var v1 = new THREE.Vector2();\\n\\n    return function (point) {\\n\\n      var clampedPoint = v1.copy(point).clamp(this.min, this.max);\\n      return clampedPoint.sub(point).length();\\n\\n    };\\n\\n  }(),\\n\\n  intersect: function intersect(box) {\\n\\n    this.min.max(box.min);\\n    this.max.min(box.max);\\n\\n    return this;\\n\\n  },\\n\\n  union: function union(box) {\\n\\n    this.min.min(box.min);\\n    this.max.max(box.max);\\n\\n    return this;\\n\\n  },\\n\\n  translate: function translate(offset) {\\n\\n    this.min.add(offset);\\n    this.max.add(offset);\\n\\n    return this;\\n\\n  },\\n\\n  equals: function equals(box) {\\n\\n    return box.min.equals(this.min) && box.max.equals(this.max);\\n\\n  },\\n\\n  clone: function clone() {\\n\\n    return new THREE.Box2().copy(this);\\n\\n  } };\\n\\n\\n\\n// File:src/math/Box3.js\\n\\n/**\\n * @author bhouston / http://exocortex.com\\n * @author WestLangley / http://github.com/WestLangley\\n */\\n\\nTHREE.Box3 = function (min, max) {\\n\\n  this.min = min !== undefined ? min : new THREE.Vector3(Infinity, Infinity, Infinity);\\n  this.max = max !== undefined ? max : new THREE.Vector3(-Infinity, -Infinity, -Infinity);\\n\\n};\\n\\nTHREE.Box3.prototype = {\\n\\n  constructor: THREE.Box3,\\n\\n  set: function set(min, max) {\\n\\n    this.min.copy(min);\\n    this.max.copy(max);\\n\\n    return this;\\n\\n  },\\n\\n  setFromPoints: function setFromPoints(points) {\\n\\n    this.makeEmpty();\\n\\n    for (var i = 0, il = points.length; i < il; i++) {\\n\\n      this.expandByPoint(points[i]);\\n\\n    }\\n\\n    return this;\\n\\n  },\\n\\n  setFromCenterAndSize: function () {\\n\\n    var v1 = new THREE.Vector3();\\n\\n    return function (center, size) {\\n\\n      var halfSize = v1.copy(size).multiplyScalar(0.5);\\n\\n      this.min.copy(center).sub(halfSize);\\n      this.max.copy(center).add(halfSize);\\n\\n      return this;\\n\\n    };\\n\\n  }(),\\n\\n  setFromObject: function () {\\n\\n    // Computes the world-axis-aligned bounding box of an object (including its children),\\n    // accounting for both the object's, and childrens', world transforms\\n\\n    var v1 = new THREE.Vector3();\\n\\n    return function (object) {\\n\\n      var scope = this;\\n\\n      object.updateMatrixWorld(true);\\n\\n      this.makeEmpty();\\n\\n      object.traverse(function (node) {\\n\\n        var geometry = node.geometry;\\n\\n        if (geometry !== undefined) {\\n\\n          if (geometry instanceof THREE.Geometry) {\\n\\n            var vertices = geometry.vertices;\\n\\n            for (var i = 0, il = vertices.length; i < il; i++) {\\n\\n              v1.copy(vertices[i]);\\n\\n              v1.applyMatrix4(node.matrixWorld);\\n\\n              scope.expandByPoint(v1);\\n\\n            }\\n\\n          } else if (geometry instanceof THREE.BufferGeometry && geometry.attributes['position'] !== undefined) {\\n\\n            var positions = geometry.attributes['position'].array;\\n\\n            for (var i = 0, il = positions.length; i < il; i += 3) {\\n\\n              v1.set(positions[i], positions[i + 1], positions[i + 2]);\\n\\n              v1.applyMatrix4(node.matrixWorld);\\n\\n              scope.expandByPoint(v1);\\n\\n            }\\n\\n          }\\n\\n        }\\n\\n      });\\n\\n      return this;\\n\\n    };\\n\\n  }(),\\n\\n  copy: function copy(box) {\\n\\n    this.min.copy(box.min);\\n    this.max.copy(box.max);\\n\\n    return this;\\n\\n  },\\n\\n  makeEmpty: function makeEmpty() {\\n\\n    this.min.x = this.min.y = this.min.z = Infinity;\\n    this.max.x = this.max.y = this.max.z = -Infinity;\\n\\n    return this;\\n\\n  },\\n\\n  empty: function empty() {\\n\\n    // https://github.com/mrdoob/three.js/blob/dev/src/math/Box3.js\\n\\n    console.warn('Box3.empty has been deprecated. Use Box3.isEmpty instead');\\n\\n    return this.isEmpty();\\n\\n  },\\n\\n  isEmpty: function isEmpty() {\\n\\n    // this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes\\n\\n    return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;\\n\\n  },\\n\\n  center: function center(optionalTarget) {\\n\\n    console.warn(\\\"Box3.center() is deprecated. Use Box3.getCenter() instead.\\\");\\n    return this.getCenter(optionalTarget);\\n\\n  },\\n\\n  getCenter: function getCenter(optionalTarget) {\\n\\n    var result = optionalTarget || new THREE.Vector3();\\n    return result.addVectors(this.min, this.max).multiplyScalar(0.5);\\n\\n  },\\n\\n  size: function size(optionalTarget) {\\n\\n    var result = optionalTarget || new THREE.Vector3();\\n    return result.subVectors(this.max, this.min);\\n\\n  },\\n\\n  expandByPoint: function expandByPoint(point) {\\n\\n    this.min.min(point);\\n    this.max.max(point);\\n\\n    return this;\\n\\n  },\\n\\n  expandByVector: function expandByVector(vector) {\\n\\n    this.min.sub(vector);\\n    this.max.add(vector);\\n\\n    return this;\\n\\n  },\\n\\n  expandByScalar: function expandByScalar(scalar) {\\n\\n    this.min.addScalar(-scalar);\\n    this.max.addScalar(scalar);\\n\\n    return this;\\n\\n  },\\n\\n  containsPoint: function containsPoint(point) {\\n\\n    if (point.x < this.min.x || point.x > this.max.x ||\\n    point.y < this.min.y || point.y > this.max.y ||\\n    point.z < this.min.z || point.z > this.max.z) {\\n\\n      return false;\\n\\n    }\\n\\n    return true;\\n\\n  },\\n\\n  containsBox: function containsBox(box) {\\n\\n    if (this.min.x <= box.min.x && box.max.x <= this.max.x &&\\n    this.min.y <= box.min.y && box.max.y <= this.max.y &&\\n    this.min.z <= box.min.z && box.max.z <= this.max.z) {\\n\\n      return true;\\n\\n    }\\n\\n    return false;\\n\\n  },\\n\\n  getParameter: function getParameter(point, optionalTarget) {\\n\\n    // This can potentially have a divide by zero if the box\\n    // has a size dimension of 0.\\n\\n    var result = optionalTarget || new THREE.Vector3();\\n\\n    return result.set(\\n    (point.x - this.min.x) / (this.max.x - this.min.x),\\n    (point.y - this.min.y) / (this.max.y - this.min.y),\\n    (point.z - this.min.z) / (this.max.z - this.min.z));\\n\\n\\n  },\\n\\n  isIntersectionBox: function isIntersectionBox(box) {\\n\\n    // using 6 splitting planes to rule out intersections.\\n\\n    if (box.max.x < this.min.x || box.min.x > this.max.x ||\\n    box.max.y < this.min.y || box.min.y > this.max.y ||\\n    box.max.z < this.min.z || box.min.z > this.max.z) {\\n\\n      return false;\\n\\n    }\\n\\n    return true;\\n\\n  },\\n\\n  clampPoint: function clampPoint(point, optionalTarget) {\\n\\n    var result = optionalTarget || new THREE.Vector3();\\n    return result.copy(point).clamp(this.min, this.max);\\n\\n  },\\n\\n  distanceToPoint: function () {\\n\\n    var v1 = new THREE.Vector3();\\n\\n    return function (point) {\\n\\n      var clampedPoint = v1.copy(point).clamp(this.min, this.max);\\n      return clampedPoint.sub(point).length();\\n\\n    };\\n\\n  }(),\\n\\n  getBoundingSphere: function () {\\n\\n    var v1 = new THREE.Vector3();\\n\\n    return function (optionalTarget) {\\n\\n      var result = optionalTarget || new THREE.Sphere();\\n\\n      result.center = this.center();\\n      result.radius = this.size(v1).length() * 0.5;\\n\\n      return result;\\n\\n    };\\n\\n  }(),\\n\\n  intersect: function intersect(box) {\\n\\n    this.min.max(box.min);\\n    this.max.min(box.max);\\n\\n    return this;\\n\\n  },\\n\\n  union: function union(box) {\\n\\n    this.min.min(box.min);\\n    this.max.max(box.max);\\n\\n    return this;\\n\\n  },\\n\\n  applyMatrix4: function () {\\n\\n    var points = [\\n    new THREE.Vector3(),\\n    new THREE.Vector3(),\\n    new THREE.Vector3(),\\n    new THREE.Vector3(),\\n    new THREE.Vector3(),\\n    new THREE.Vector3(),\\n    new THREE.Vector3(),\\n    new THREE.Vector3()];\\n\\n\\n    return function (matrix) {\\n\\n      // NOTE: I am using a binary pattern to specify all 2^3 combinations below\\n      points[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(matrix); // 000\\n      points[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(matrix); // 001\\n      points[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(matrix); // 010\\n      points[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(matrix); // 011\\n      points[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(matrix); // 100\\n      points[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(matrix); // 101\\n      points[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(matrix); // 110\\n      points[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(matrix); // 111\\n\\n      this.makeEmpty();\\n      this.setFromPoints(points);\\n\\n      return this;\\n\\n    };\\n\\n  }(),\\n\\n  translate: function translate(offset) {\\n\\n    this.min.add(offset);\\n    this.max.add(offset);\\n\\n    return this;\\n\\n  },\\n\\n  equals: function equals(box) {\\n\\n    return box.min.equals(this.min) && box.max.equals(this.max);\\n\\n  },\\n\\n  clone: function clone() {\\n\\n    return new THREE.Box3().copy(this);\\n\\n  } };\\n\\n\\n\\n// File:src/math/Matrix3.js\\n\\n/**\\n * @author alteredq / http://alteredqualia.com/\\n * @author WestLangley / http://github.com/WestLangley\\n * @author bhouston / http://exocortex.com\\n */\\n\\nTHREE.Matrix3 = function () {\\n\\n  this.elements = new Float32Array([\\n\\n  1, 0, 0,\\n  0, 1, 0,\\n  0, 0, 1]);\\n\\n\\n\\n  if (arguments.length > 0) {\\n\\n    THREE.error('THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.');\\n\\n  }\\n\\n};\\n\\nTHREE.Matrix3.prototype = {\\n\\n  constructor: THREE.Matrix3,\\n\\n  set: function set(n11, n12, n13, n21, n22, n23, n31, n32, n33) {\\n\\n    var te = this.elements;\\n\\n    te[0] = n11;te[3] = n12;te[6] = n13;\\n    te[1] = n21;te[4] = n22;te[7] = n23;\\n    te[2] = n31;te[5] = n32;te[8] = n33;\\n\\n    return this;\\n\\n  },\\n\\n  identity: function identity() {\\n\\n    this.set(\\n\\n    1, 0, 0,\\n    0, 1, 0,\\n    0, 0, 1);\\n\\n\\n\\n    return this;\\n\\n  },\\n\\n  copy: function copy(m) {\\n\\n    var me = m.elements;\\n\\n    this.set(\\n\\n    me[0], me[3], me[6],\\n    me[1], me[4], me[7],\\n    me[2], me[5], me[8]);\\n\\n\\n\\n    return this;\\n\\n  },\\n\\n  multiplyVector3: function multiplyVector3(vector) {\\n\\n    THREE.warn('THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.');\\n    return vector.applyMatrix3(this);\\n\\n  },\\n\\n  multiplyVector3Array: function multiplyVector3Array(a) {\\n\\n    THREE.warn('THREE.Matrix3: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead.');\\n    return this.applyToVector3Array(a);\\n\\n  },\\n\\n  applyToVector3Array: function () {\\n\\n    var v1 = new THREE.Vector3();\\n\\n    return function (array, offset, length) {\\n\\n      if (offset === undefined) offset = 0;\\n      if (length === undefined) length = array.length;\\n\\n      for (var i = 0, j = offset; i < length; i += 3, j += 3) {\\n\\n        v1.x = array[j];\\n        v1.y = array[j + 1];\\n        v1.z = array[j + 2];\\n\\n        v1.applyMatrix3(this);\\n\\n        array[j] = v1.x;\\n        array[j + 1] = v1.y;\\n        array[j + 2] = v1.z;\\n\\n      }\\n\\n      return array;\\n\\n    };\\n\\n  }(),\\n\\n  multiplyScalar: function multiplyScalar(s) {\\n\\n    var te = this.elements;\\n\\n    te[0] *= s;te[3] *= s;te[6] *= s;\\n    te[1] *= s;te[4] *= s;te[7] *= s;\\n    te[2] *= s;te[5] *= s;te[8] *= s;\\n\\n    return this;\\n\\n  },\\n\\n  determinant: function determinant() {\\n\\n    var te = this.elements;\\n\\n    var a = te[0],b = te[1],c = te[2],\\n    d = te[3],e = te[4],f = te[5],\\n    g = te[6],h = te[7],i = te[8];\\n\\n    return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;\\n\\n  },\\n\\n  getInverse: function getInverse(matrix, throwOnInvertible) {\\n\\n    // input: THREE.Matrix4\\n    // ( based on http://code.google.com/p/webgl-mjs/ )\\n\\n    var me = matrix.elements;\\n    var te = this.elements;\\n\\n    te[0] = me[10] * me[5] - me[6] * me[9];\\n    te[1] = -me[10] * me[1] + me[2] * me[9];\\n    te[2] = me[6] * me[1] - me[2] * me[5];\\n    te[3] = -me[10] * me[4] + me[6] * me[8];\\n    te[4] = me[10] * me[0] - me[2] * me[8];\\n    te[5] = -me[6] * me[0] + me[2] * me[4];\\n    te[6] = me[9] * me[4] - me[5] * me[8];\\n    te[7] = -me[9] * me[0] + me[1] * me[8];\\n    te[8] = me[5] * me[0] - me[1] * me[4];\\n\\n    var det = me[0] * te[0] + me[1] * te[3] + me[2] * te[6];\\n\\n    // no inverse\\n\\n    if (det === 0) {\\n\\n      var msg = \\\"Matrix3.getInverse(): can't invert matrix, determinant is 0\\\";\\n\\n      if (throwOnInvertible || false) {\\n\\n        throw new Error(msg);\\n\\n      } else {\\n\\n        THREE.warn(msg);\\n\\n      }\\n\\n      this.identity();\\n\\n      return this;\\n\\n    }\\n\\n    this.multiplyScalar(1.0 / det);\\n\\n    return this;\\n\\n  },\\n\\n  transpose: function transpose() {\\n\\n    var tmp,m = this.elements;\\n\\n    tmp = m[1];m[1] = m[3];m[3] = tmp;\\n    tmp = m[2];m[2] = m[6];m[6] = tmp;\\n    tmp = m[5];m[5] = m[7];m[7] = tmp;\\n\\n    return this;\\n\\n  },\\n\\n  flattenToArrayOffset: function flattenToArrayOffset(array, offset) {\\n\\n    var te = this.elements;\\n\\n    array[offset] = te[0];\\n    array[offset + 1] = te[1];\\n    array[offset + 2] = te[2];\\n\\n    array[offset + 3] = te[3];\\n    array[offset + 4] = te[4];\\n    array[offset + 5] = te[5];\\n\\n    array[offset + 6] = te[6];\\n    array[offset + 7] = te[7];\\n    array[offset + 8] = te[8];\\n\\n    return array;\\n\\n  },\\n\\n  getNormalMatrix: function getNormalMatrix(m) {\\n\\n    // input: THREE.Matrix4\\n\\n    this.getInverse(m).transpose();\\n\\n    return this;\\n\\n  },\\n\\n  transposeIntoArray: function transposeIntoArray(r) {\\n\\n    var m = this.elements;\\n\\n    r[0] = m[0];\\n    r[1] = m[3];\\n    r[2] = m[6];\\n    r[3] = m[1];\\n    r[4] = m[4];\\n    r[5] = m[7];\\n    r[6] = m[2];\\n    r[7] = m[5];\\n    r[8] = m[8];\\n\\n    return this;\\n\\n  },\\n\\n  fromArray: function fromArray(array) {\\n\\n    this.elements.set(array);\\n\\n    return this;\\n\\n  },\\n\\n  toArray: function toArray() {\\n\\n    var te = this.elements;\\n\\n    return [\\n    te[0], te[1], te[2],\\n    te[3], te[4], te[5],\\n    te[6], te[7], te[8]];\\n\\n\\n  },\\n\\n  clone: function clone() {\\n\\n    return new THREE.Matrix3().fromArray(this.elements);\\n\\n  } };\\n\\n\\n\\n// File:src/math/Matrix4.js\\n\\n/**\\n * @author mrdoob / http://mrdoob.com/\\n * @author supereggbert / http://www.paulbrunt.co.uk/\\n * @author philogb / http://blog.thejit.org/\\n * @author jordi_ros / http://plattsoft.com\\n * @author D1plo1d / http://github.com/D1plo1d\\n * @author alteredq / http://alteredqualia.com/\\n * @author mikael emtinger / http://gomo.se/\\n * @author timknip / http://www.floorplanner.com/\\n * @author bhouston / http://exocortex.com\\n * @author WestLangley / http://github.com/WestLangley\\n */\\n\\nTHREE.Matrix4 = function () {\\n\\n  this.elements = new Float32Array([\\n\\n  1, 0, 0, 0,\\n  0, 1, 0, 0,\\n  0, 0, 1, 0,\\n  0, 0, 0, 1]);\\n\\n\\n\\n  if (arguments.length > 0) {\\n\\n    THREE.error('THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.');\\n\\n  }\\n\\n};\\n\\nTHREE.Matrix4.prototype = {\\n\\n  constructor: THREE.Matrix4,\\n\\n  set: function set(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {\\n\\n    var te = this.elements;\\n\\n    te[0] = n11;te[4] = n12;te[8] = n13;te[12] = n14;\\n    te[1] = n21;te[5] = n22;te[9] = n23;te[13] = n24;\\n    te[2] = n31;te[6] = n32;te[10] = n33;te[14] = n34;\\n    te[3] = n41;te[7] = n42;te[11] = n43;te[15] = n44;\\n\\n    return this;\\n\\n  },\\n\\n  identity: function identity() {\\n\\n    this.set(\\n\\n    1, 0, 0, 0,\\n    0, 1, 0, 0,\\n    0, 0, 1, 0,\\n    0, 0, 0, 1);\\n\\n\\n\\n    return this;\\n\\n  },\\n\\n  copy: function copy(m) {\\n\\n    this.elements.set(m.elements);\\n\\n    return this;\\n\\n  },\\n\\n  extractPosition: function extractPosition(m) {\\n\\n    THREE.warn('THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().');\\n    return this.copyPosition(m);\\n\\n  },\\n\\n  copyPosition: function copyPosition(m) {\\n\\n    var te = this.elements;\\n    var me = m.elements;\\n\\n    te[12] = me[12];\\n    te[13] = me[13];\\n    te[14] = me[14];\\n\\n    return this;\\n\\n  },\\n\\n  extractBasis: function extractBasis(xAxis, yAxis, zAxis) {\\n\\n    var te = this.elements;\\n\\n    xAxis.set(te[0], te[1], te[2]);\\n    yAxis.set(te[4], te[5], te[6]);\\n    zAxis.set(te[8], te[9], te[10]);\\n\\n    return this;\\n\\n  },\\n\\n  makeBasis: function makeBasis(xAxis, yAxis, zAxis) {\\n\\n    this.set(\\n    xAxis.x, yAxis.x, zAxis.x, 0,\\n    xAxis.y, yAxis.y, zAxis.y, 0,\\n    xAxis.z, yAxis.z, zAxis.z, 0,\\n    0, 0, 0, 1);\\n\\n\\n    return this;\\n\\n  },\\n\\n  extractRotation: function () {\\n\\n    var v1 = new THREE.Vector3();\\n\\n    return function (m) {\\n\\n      var te = this.elements;\\n      var me = m.elements;\\n\\n      var scaleX = 1 / v1.set(me[0], me[1], me[2]).length();\\n      var scaleY = 1 / v1.set(me[4], me[5], me[6]).length();\\n      var scaleZ = 1 / v1.set(me[8], me[9], me[10]).length();\\n\\n      te[0] = me[0] * scaleX;\\n      te[1] = me[1] * scaleX;\\n      te[2] = me[2] * scaleX;\\n\\n      te[4] = me[4] * scaleY;\\n      te[5] = me[5] * scaleY;\\n      te[6] = me[6] * scaleY;\\n\\n      te[8] = me[8] * scaleZ;\\n      te[9] = me[9] * scaleZ;\\n      te[10] = me[10] * scaleZ;\\n\\n      return this;\\n\\n    };\\n\\n  }(),\\n\\n  makeRotationFromEuler: function makeRotationFromEuler(euler) {\\n\\n    if (euler instanceof THREE.Euler === false) {\\n\\n      THREE.error('THREE.Matrix: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.');\\n\\n    }\\n\\n    var te = this.elements;\\n\\n    var x = euler.x,y = euler.y,z = euler.z;\\n    var a = Math.cos(x),b = Math.sin(x);\\n    var c = Math.cos(y),d = Math.sin(y);\\n    var e = Math.cos(z),f = Math.sin(z);\\n\\n    if (euler.order === 'XYZ') {\\n\\n      var ae = a * e,af = a * f,be = b * e,bf = b * f;\\n\\n      te[0] = c * e;\\n      te[4] = -c * f;\\n      te[8] = d;\\n\\n      te[1] = af + be * d;\\n      te[5] = ae - bf * d;\\n      te[9] = -b * c;\\n\\n      te[2] = bf - ae * d;\\n      te[6] = be + af * d;\\n      te[10] = a * c;\\n\\n    } else if (euler.order === 'YXZ') {\\n\\n      var ce = c * e,cf = c * f,de = d * e,df = d * f;\\n\\n      te[0] = ce + df * b;\\n      te[4] = de * b - cf;\\n      te[8] = a * d;\\n\\n      te[1] = a * f;\\n      te[5] = a * e;\\n      te[9] = -b;\\n\\n      te[2] = cf * b - de;\\n      te[6] = df + ce * b;\\n      te[10] = a * c;\\n\\n    } else if (euler.order === 'ZXY') {\\n\\n      var ce = c * e,cf = c * f,de = d * e,df = d * f;\\n\\n      te[0] = ce - df * b;\\n      te[4] = -a * f;\\n      te[8] = de + cf * b;\\n\\n      te[1] = cf + de * b;\\n      te[5] = a * e;\\n      te[9] = df - ce * b;\\n\\n      te[2] = -a * d;\\n      te[6] = b;\\n      te[10] = a * c;\\n\\n    } else if (euler.order === 'ZYX') {\\n\\n      var ae = a * e,af = a * f,be = b * e,bf = b * f;\\n\\n      te[0] = c * e;\\n      te[4] = be * d - af;\\n      te[8] = ae * d + bf;\\n\\n      te[1] = c * f;\\n      te[5] = bf * d + ae;\\n      te[9] = af * d - be;\\n\\n      te[2] = -d;\\n      te[6] = b * c;\\n      te[10] = a * c;\\n\\n    } else if (euler.order === 'YZX') {\\n\\n      var ac = a * c,ad = a * d,bc = b * c,bd = b * d;\\n\\n      te[0] = c * e;\\n      te[4] = bd - ac * f;\\n      te[8] = bc * f + ad;\\n\\n      te[1] = f;\\n      te[5] = a * e;\\n      te[9] = -b * e;\\n\\n      te[2] = -d * e;\\n      te[6] = ad * f + bc;\\n      te[10] = ac - bd * f;\\n\\n    } else if (euler.order === 'XZY') {\\n\\n      var ac = a * c,ad = a * d,bc = b * c,bd = b * d;\\n\\n      te[0] = c * e;\\n      te[4] = -f;\\n      te[8] = d * e;\\n\\n      te[1] = ac * f + bd;\\n      te[5] = a * e;\\n      te[9] = ad * f - bc;\\n\\n      te[2] = bc * f - ad;\\n      te[6] = b * e;\\n      te[10] = bd * f + ac;\\n\\n    }\\n\\n    // last column\\n    te[3] = 0;\\n    te[7] = 0;\\n    te[11] = 0;\\n\\n    // bottom row\\n    te[12] = 0;\\n    te[13] = 0;\\n    te[14] = 0;\\n    te[15] = 1;\\n\\n    return this;\\n\\n  },\\n\\n  setRotationFromQuaternion: function setRotationFromQuaternion(q) {\\n\\n    THREE.warn('THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().');\\n\\n    return this.makeRotationFromQuaternion(q);\\n\\n  },\\n\\n  makeRotationFromQuaternion: function makeRotationFromQuaternion(q) {\\n\\n    var te = this.elements;\\n\\n    var x = q.x,y = q.y,z = q.z,w = q.w;\\n    var x2 = x + x,y2 = y + y,z2 = z + z;\\n    var xx = x * x2,xy = x * y2,xz = x * z2;\\n    var yy = y * y2,yz = y * z2,zz = z * z2;\\n    var wx = w * x2,wy = w * y2,wz = w * z2;\\n\\n    te[0] = 1 - (yy + zz);\\n    te[4] = xy - wz;\\n    te[8] = xz + wy;\\n\\n    te[1] = xy + wz;\\n    te[5] = 1 - (xx + zz);\\n    te[9] = yz - wx;\\n\\n    te[2] = xz - wy;\\n    te[6] = yz + wx;\\n    te[10] = 1 - (xx + yy);\\n\\n    // last column\\n    te[3] = 0;\\n    te[7] = 0;\\n    te[11] = 0;\\n\\n    // bottom row\\n    te[12] = 0;\\n    te[13] = 0;\\n    te[14] = 0;\\n    te[15] = 1;\\n\\n    return this;\\n\\n  },\\n\\n  lookAt: function () {\\n\\n    var x = new THREE.Vector3();\\n    var y = new THREE.Vector3();\\n    var z = new THREE.Vector3();\\n\\n    return function (eye, target, up) {\\n\\n      var te = this.elements;\\n\\n      z.subVectors(eye, target).normalize();\\n\\n      if (z.length() === 0) {\\n\\n        z.z = 1;\\n\\n      }\\n\\n      x.crossVectors(up, z).normalize();\\n\\n      if (x.length() === 0) {\\n\\n        z.x += 0.0001;\\n        x.crossVectors(up, z).normalize();\\n\\n      }\\n\\n      y.crossVectors(z, x);\\n\\n\\n      te[0] = x.x;te[4] = y.x;te[8] = z.x;\\n      te[1] = x.y;te[5] = y.y;te[9] = z.y;\\n      te[2] = x.z;te[6] = y.z;te[10] = z.z;\\n\\n      return this;\\n\\n    };\\n\\n  }(),\\n\\n  multiply: function multiply(m, n) {\\n\\n    if (n !== undefined) {\\n\\n      THREE.warn('THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.');\\n      return this.multiplyMatrices(m, n);\\n\\n    }\\n\\n    return this.multiplyMatrices(this, m);\\n\\n  },\\n\\n  multiplyMatrices: function multiplyMatrices(a, b) {\\n\\n    var ae = a.elements;\\n    var be = b.elements;\\n    var te = this.elements;\\n\\n    var a11 = ae[0],a12 = ae[4],a13 = ae[8],a14 = ae[12];\\n    var a21 = ae[1],a22 = ae[5],a23 = ae[9],a24 = ae[13];\\n    var a31 = ae[2],a32 = ae[6],a33 = ae[10],a34 = ae[14];\\n    var a41 = ae[3],a42 = ae[7],a43 = ae[11],a44 = ae[15];\\n\\n    var b11 = be[0],b12 = be[4],b13 = be[8],b14 = be[12];\\n    var b21 = be[1],b22 = be[5],b23 = be[9],b24 = be[13];\\n    var b31 = be[2],b32 = be[6],b33 = be[10],b34 = be[14];\\n    var b41 = be[3],b42 = be[7],b43 = be[11],b44 = be[15];\\n\\n    te[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;\\n    te[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;\\n    te[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;\\n    te[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;\\n\\n    te[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;\\n    te[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;\\n    te[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;\\n    te[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;\\n\\n    te[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;\\n    te[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;\\n    te[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;\\n    te[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;\\n\\n    te[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;\\n    te[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;\\n    te[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;\\n    te[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;\\n\\n    return this;\\n\\n  },\\n\\n  multiplyToArray: function multiplyToArray(a, b, r) {\\n\\n    var te = this.elements;\\n\\n    this.multiplyMatrices(a, b);\\n\\n    r[0] = te[0];r[1] = te[1];r[2] = te[2];r[3] = te[3];\\n    r[4] = te[4];r[5] = te[5];r[6] = te[6];r[7] = te[7];\\n    r[8] = te[8];r[9] = te[9];r[10] = te[10];r[11] = te[11];\\n    r[12] = te[12];r[13] = te[13];r[14] = te[14];r[15] = te[15];\\n\\n    return this;\\n\\n  },\\n\\n  multiplyScalar: function multiplyScalar(s) {\\n\\n    var te = this.elements;\\n\\n    te[0] *= s;te[4] *= s;te[8] *= s;te[12] *= s;\\n    te[1] *= s;te[5] *= s;te[9] *= s;te[13] *= s;\\n    te[2] *= s;te[6] *= s;te[10] *= s;te[14] *= s;\\n    te[3] *= s;te[7] *= s;te[11] *= s;te[15] *= s;\\n\\n    return this;\\n\\n  },\\n\\n  multiplyVector3: function multiplyVector3(vector) {\\n\\n    THREE.warn('THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) or vector.applyProjection( matrix ) instead.');\\n    return vector.applyProjection(this);\\n\\n  },\\n\\n  multiplyVector4: function multiplyVector4(vector) {\\n\\n    THREE.warn('THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.');\\n    return vector.applyMatrix4(this);\\n\\n  },\\n\\n  multiplyVector3Array: function multiplyVector3Array(a) {\\n\\n    THREE.warn('THREE.Matrix4: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead.');\\n    return this.applyToVector3Array(a);\\n\\n  },\\n\\n  applyToVector3Array: function () {\\n\\n    var v1 = new THREE.Vector3();\\n\\n    return function (array, offset, length) {\\n\\n      if (offset === undefined) offset = 0;\\n      if (length === undefined) length = array.length;\\n\\n      for (var i = 0, j = offset; i < length; i += 3, j += 3) {\\n\\n        v1.x = array[j];\\n        v1.y = array[j + 1];\\n        v1.z = array[j + 2];\\n\\n        v1.applyMatrix4(this);\\n\\n        array[j] = v1.x;\\n        array[j + 1] = v1.y;\\n        array[j + 2] = v1.z;\\n\\n      }\\n\\n      return array;\\n\\n    };\\n\\n  }(),\\n\\n  rotateAxis: function rotateAxis(v) {\\n\\n    THREE.warn('THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.');\\n\\n    v.transformDirection(this);\\n\\n  },\\n\\n  crossVector: function crossVector(vector) {\\n\\n    THREE.warn('THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.');\\n    return vector.applyMatrix4(this);\\n\\n  },\\n\\n  determinant: function determinant() {\\n\\n    var te = this.elements;\\n\\n    var n11 = te[0],n12 = te[4],n13 = te[8],n14 = te[12];\\n    var n21 = te[1],n22 = te[5],n23 = te[9],n24 = te[13];\\n    var n31 = te[2],n32 = te[6],n33 = te[10],n34 = te[14];\\n    var n41 = te[3],n42 = te[7],n43 = te[11],n44 = te[15];\\n\\n    //TODO: make this more efficient\\n    //( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )\\n\\n    return (\\n      n41 * (\\n      +n14 * n23 * n32 -\\n      n13 * n24 * n32 -\\n      n14 * n22 * n33 +\\n      n12 * n24 * n33 +\\n      n13 * n22 * n34 -\\n      n12 * n23 * n34) +\\n\\n      n42 * (\\n      +n11 * n23 * n34 -\\n      n11 * n24 * n33 +\\n      n14 * n21 * n33 -\\n      n13 * n21 * n34 +\\n      n13 * n24 * n31 -\\n      n14 * n23 * n31) +\\n\\n      n43 * (\\n      +n11 * n24 * n32 -\\n      n11 * n22 * n34 -\\n      n14 * n21 * n32 +\\n      n12 * n21 * n34 +\\n      n14 * n22 * n31 -\\n      n12 * n24 * n31) +\\n\\n      n44 * (\\n      -n13 * n22 * n31 -\\n      n11 * n23 * n32 +\\n      n11 * n22 * n33 +\\n      n13 * n21 * n32 -\\n      n12 * n21 * n33 +\\n      n12 * n23 * n31));\\n\\n\\n\\n\\n  },\\n\\n  transpose: function transpose() {\\n\\n    var te = this.elements;\\n    var tmp;\\n\\n    tmp = te[1];te[1] = te[4];te[4] = tmp;\\n    tmp = te[2];te[2] = te[8];te[8] = tmp;\\n    tmp = te[6];te[6] = te[9];te[9] = tmp;\\n\\n    tmp = te[3];te[3] = te[12];te[12] = tmp;\\n    tmp = te[7];te[7] = te[13];te[13] = tmp;\\n    tmp = te[11];te[11] = te[14];te[14] = tmp;\\n\\n    return this;\\n\\n  },\\n\\n  flattenToArrayOffset: function flattenToArrayOffset(array, offset) {\\n\\n    var te = this.elements;\\n\\n    array[offset] = te[0];\\n    array[offset + 1] = te[1];\\n    array[offset + 2] = te[2];\\n    array[offset + 3] = te[3];\\n\\n    array[offset + 4] = te[4];\\n    array[offset + 5] = te[5];\\n    array[offset + 6] = te[6];\\n    array[offset + 7] = te[7];\\n\\n    array[offset + 8] = te[8];\\n    array[offset + 9] = te[9];\\n    array[offset + 10] = te[10];\\n    array[offset + 11] = te[11];\\n\\n    array[offset + 12] = te[12];\\n    array[offset + 13] = te[13];\\n    array[offset + 14] = te[14];\\n    array[offset + 15] = te[15];\\n\\n    return array;\\n\\n  },\\n\\n  getPosition: function () {\\n\\n    var v1 = new THREE.Vector3();\\n\\n    return function () {\\n\\n      THREE.warn('THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.');\\n\\n      var te = this.elements;\\n      return v1.set(te[12], te[13], te[14]);\\n\\n    };\\n\\n  }(),\\n\\n  setPosition: function setPosition(v) {\\n\\n    var te = this.elements;\\n\\n    te[12] = v.x;\\n    te[13] = v.y;\\n    te[14] = v.z;\\n\\n    return this;\\n\\n  },\\n\\n  getInverse: function getInverse(m, throwOnInvertible) {\\n\\n    // based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm\\n    var te = this.elements;\\n    var me = m.elements;\\n\\n    var n11 = me[0],n12 = me[4],n13 = me[8],n14 = me[12];\\n    var n21 = me[1],n22 = me[5],n23 = me[9],n24 = me[13];\\n    var n31 = me[2],n32 = me[6],n33 = me[10],n34 = me[14];\\n    var n41 = me[3],n42 = me[7],n43 = me[11],n44 = me[15];\\n\\n    te[0] = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44;\\n    te[4] = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44;\\n    te[8] = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44;\\n    te[12] = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;\\n    te[1] = n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44;\\n    te[5] = n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44;\\n    te[9] = n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44;\\n    te[13] = n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34;\\n    te[2] = n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44;\\n    te[6] = n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44;\\n    te[10] = n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44;\\n    te[14] = n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34;\\n    te[3] = n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43;\\n    te[7] = n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43;\\n    te[11] = n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43;\\n    te[15] = n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33;\\n\\n    var det = n11 * te[0] + n21 * te[4] + n31 * te[8] + n41 * te[12];\\n\\n    if (det == 0) {\\n\\n      var msg = \\\"THREE.Matrix4.getInverse(): can't invert matrix, determinant is 0\\\";\\n\\n      if (throwOnInvertible || false) {\\n\\n        throw new Error(msg);\\n\\n      } else {\\n\\n        THREE.warn(msg);\\n\\n      }\\n\\n      this.identity();\\n\\n      return this;\\n    }\\n\\n    this.multiplyScalar(1 / det);\\n\\n    return this;\\n\\n  },\\n\\n  translate: function translate(v) {\\n\\n    THREE.error('THREE.Matrix4: .translate() has been removed.');\\n\\n  },\\n\\n  rotateX: function rotateX(angle) {\\n\\n    THREE.error('THREE.Matrix4: .rotateX() has been removed.');\\n\\n  },\\n\\n  rotateY: function rotateY(angle) {\\n\\n    THREE.error('THREE.Matrix4: .rotateY() has been removed.');\\n\\n  },\\n\\n  rotateZ: function rotateZ(angle) {\\n\\n    THREE.error('THREE.Matrix4: .rotateZ() has been removed.');\\n\\n  },\\n\\n  rotateByAxis: function rotateByAxis(axis, angle) {\\n\\n    THREE.error('THREE.Matrix4: .rotateByAxis() has been removed.');\\n\\n  },\\n\\n  scale: function scale(v) {\\n\\n    var te = this.elements;\\n    var x = v.x,y = v.y,z = v.z;\\n\\n    te[0] *= x;te[4] *= y;te[8] *= z;\\n    te[1] *= x;te[5] *= y;te[9] *= z;\\n    te[2] *= x;te[6] *= y;te[10] *= z;\\n    te[3] *= x;te[7] *= y;te[11] *= z;\\n\\n    return this;\\n\\n  },\\n\\n  getMaxScaleOnAxis: function getMaxScaleOnAxis() {\\n\\n    var te = this.elements;\\n\\n    var scaleXSq = te[0] * te[0] + te[1] * te[1] + te[2] * te[2];\\n    var scaleYSq = te[4] * te[4] + te[5] * te[5] + te[6] * te[6];\\n    var scaleZSq = te[8] * te[8] + te[9] * te[9] + te[10] * te[10];\\n\\n    return Math.sqrt(Math.max(scaleXSq, Math.max(scaleYSq, scaleZSq)));\\n\\n  },\\n\\n  makeTranslation: function makeTranslation(x, y, z) {\\n\\n    this.set(\\n\\n    1, 0, 0, x,\\n    0, 1, 0, y,\\n    0, 0, 1, z,\\n    0, 0, 0, 1);\\n\\n\\n\\n    return this;\\n\\n  },\\n\\n  makeRotationX: function makeRotationX(theta) {\\n\\n    var c = Math.cos(theta),s = Math.sin(theta);\\n\\n    this.set(\\n\\n    1, 0, 0, 0,\\n    0, c, -s, 0,\\n    0, s, c, 0,\\n    0, 0, 0, 1);\\n\\n\\n\\n    return this;\\n\\n  },\\n\\n  makeRotationY: function makeRotationY(theta) {\\n\\n    var c = Math.cos(theta),s = Math.sin(theta);\\n\\n    this.set(\\n\\n    c, 0, s, 0,\\n    0, 1, 0, 0,\\n    -s, 0, c, 0,\\n    0, 0, 0, 1);\\n\\n\\n\\n    return this;\\n\\n  },\\n\\n  makeRotationZ: function makeRotationZ(theta) {\\n\\n    var c = Math.cos(theta),s = Math.sin(theta);\\n\\n    this.set(\\n\\n    c, -s, 0, 0,\\n    s, c, 0, 0,\\n    0, 0, 1, 0,\\n    0, 0, 0, 1);\\n\\n\\n\\n    return this;\\n\\n  },\\n\\n  makeRotationAxis: function makeRotationAxis(axis, angle) {\\n\\n    // Based on http://www.gamedev.net/reference/articles/article1199.asp\\n\\n    var c = Math.cos(angle);\\n    var s = Math.sin(angle);\\n    var t = 1 - c;\\n    var x = axis.x,y = axis.y,z = axis.z;\\n    var tx = t * x,ty = t * y;\\n\\n    this.set(\\n\\n    tx * x + c, tx * y - s * z, tx * z + s * y, 0,\\n    tx * y + s * z, ty * y + c, ty * z - s * x, 0,\\n    tx * z - s * y, ty * z + s * x, t * z * z + c, 0,\\n    0, 0, 0, 1);\\n\\n\\n\\n    return this;\\n\\n  },\\n\\n  makeScale: function makeScale(x, y, z) {\\n\\n    this.set(\\n\\n    x, 0, 0, 0,\\n    0, y, 0, 0,\\n    0, 0, z, 0,\\n    0, 0, 0, 1);\\n\\n\\n\\n    return this;\\n\\n  },\\n\\n  compose: function compose(position, quaternion, scale) {\\n\\n    this.makeRotationFromQuaternion(quaternion);\\n    this.scale(scale);\\n    this.setPosition(position);\\n\\n    return this;\\n\\n  },\\n\\n  decompose: function () {\\n\\n    var vector = new THREE.Vector3();\\n    var matrix = new THREE.Matrix4();\\n\\n    return function (position, quaternion, scale) {\\n\\n      var te = this.elements;\\n\\n      var sx = vector.set(te[0], te[1], te[2]).length();\\n      var sy = vector.set(te[4], te[5], te[6]).length();\\n      var sz = vector.set(te[8], te[9], te[10]).length();\\n\\n      // if determine is negative, we need to invert one scale\\n      var det = this.determinant();\\n      if (det < 0) {\\n        sx = -sx;\\n      }\\n\\n      position.x = te[12];\\n      position.y = te[13];\\n      position.z = te[14];\\n\\n      // scale the rotation part\\n\\n      matrix.elements.set(this.elements); // at this point matrix is incomplete so we can't use .copy()\\n\\n      var invSX = 1 / sx;\\n      var invSY = 1 / sy;\\n      var invSZ = 1 / sz;\\n\\n      matrix.elements[0] *= invSX;\\n      matrix.elements[1] *= invSX;\\n      matrix.elements[2] *= invSX;\\n\\n      matrix.elements[4] *= invSY;\\n      matrix.elements[5] *= invSY;\\n      matrix.elements[6] *= invSY;\\n\\n      matrix.elements[8] *= invSZ;\\n      matrix.elements[9] *= invSZ;\\n      matrix.elements[10] *= invSZ;\\n\\n      quaternion.setFromRotationMatrix(matrix);\\n\\n      scale.x = sx;\\n      scale.y = sy;\\n      scale.z = sz;\\n\\n      return this;\\n\\n    };\\n\\n  }(),\\n\\n  makeFrustum: function makeFrustum(left, right, bottom, top, near, far) {\\n\\n    var te = this.elements;\\n    var x = 2 * near / (right - left);\\n    var y = 2 * near / (top - bottom);\\n\\n    var a = (right + left) / (right - left);\\n    var b = (top + bottom) / (top - bottom);\\n    var c = -(far + near) / (far - near);\\n    var d = -2 * far * near / (far - near);\\n\\n    te[0] = x;te[4] = 0;te[8] = a;te[12] = 0;\\n    te[1] = 0;te[5] = y;te[9] = b;te[13] = 0;\\n    te[2] = 0;te[6] = 0;te[10] = c;te[14] = d;\\n    te[3] = 0;te[7] = 0;te[11] = -1;te[15] = 0;\\n\\n    return this;\\n\\n  },\\n\\n  makePerspective: function makePerspective(fov, aspect, near, far) {\\n\\n    var ymax = near * Math.tan(THREE.Math.degToRad(fov * 0.5));\\n    var ymin = -ymax;\\n    var xmin = ymin * aspect;\\n    var xmax = ymax * aspect;\\n\\n    return this.makeFrustum(xmin, xmax, ymin, ymax, near, far);\\n\\n  },\\n\\n  makeOrthographic: function makeOrthographic(left, right, top, bottom, near, far) {\\n\\n    var te = this.elements;\\n    var w = right - left;\\n    var h = top - bottom;\\n    var p = far - near;\\n\\n    var x = (right + left) / w;\\n    var y = (top + bottom) / h;\\n    var z = (far + near) / p;\\n\\n    te[0] = 2 / w;te[4] = 0;te[8] = 0;te[12] = -x;\\n    te[1] = 0;te[5] = 2 / h;te[9] = 0;te[13] = -y;\\n    te[2] = 0;te[6] = 0;te[10] = -2 / p;te[14] = -z;\\n    te[3] = 0;te[7] = 0;te[11] = 0;te[15] = 1;\\n\\n    return this;\\n\\n  },\\n\\n  fromArray: function fromArray(array) {\\n\\n    this.elements.set(array);\\n\\n    return this;\\n\\n  },\\n\\n  toArray: function toArray() {\\n\\n    var te = this.elements;\\n\\n    return [\\n    te[0], te[1], te[2], te[3],\\n    te[4], te[5], te[6], te[7],\\n    te[8], te[9], te[10], te[11],\\n    te[12], te[13], te[14], te[15]];\\n\\n\\n  },\\n\\n  clone: function clone() {\\n\\n    return new THREE.Matrix4().fromArray(this.elements);\\n\\n  } };\\n\\n\\n\\n// File:src/math/Sphere.js\\n\\n/**\\n * @author bhouston / http://exocortex.com\\n * @author mrdoob / http://mrdoob.com/\\n */\\n\\nTHREE.Sphere = function (center, radius) {\\n\\n  this.center = center !== undefined ? center : new THREE.Vector3();\\n  this.radius = radius !== undefined ? radius : 0;\\n\\n};\\n\\nTHREE.Sphere.prototype = {\\n\\n  constructor: THREE.Sphere,\\n\\n  set: function set(center, radius) {\\n\\n    this.center.copy(center);\\n    this.radius = radius;\\n\\n    return this;\\n  },\\n\\n  setFromPoints: function () {\\n\\n    var box = new THREE.Box3();\\n\\n    return function (points, optionalCenter) {\\n\\n      var center = this.center;\\n\\n      if (optionalCenter !== undefined) {\\n\\n        center.copy(optionalCenter);\\n\\n      } else {\\n\\n        box.setFromPoints(points).center(center);\\n\\n      }\\n\\n      var maxRadiusSq = 0;\\n\\n      for (var i = 0, il = points.length; i < il; i++) {\\n\\n        maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(points[i]));\\n\\n      }\\n\\n      this.radius = Math.sqrt(maxRadiusSq);\\n\\n      return this;\\n\\n    };\\n\\n  }(),\\n\\n  copy: function copy(sphere) {\\n\\n    this.center.copy(sphere.center);\\n    this.radius = sphere.radius;\\n\\n    return this;\\n\\n  },\\n\\n  empty: function empty() {\\n\\n    return this.radius <= 0;\\n\\n  },\\n\\n  containsPoint: function containsPoint(point) {\\n\\n    return point.distanceToSquared(this.center) <= this.radius * this.radius;\\n\\n  },\\n\\n  distanceToPoint: function distanceToPoint(point) {\\n\\n    return point.distanceTo(this.center) - this.radius;\\n\\n  },\\n\\n  intersectsSphere: function intersectsSphere(sphere) {\\n\\n    var radiusSum = this.radius + sphere.radius;\\n\\n    return sphere.center.distanceToSquared(this.center) <= radiusSum * radiusSum;\\n\\n  },\\n\\n  clampPoint: function clampPoint(point, optionalTarget) {\\n\\n    var deltaLengthSq = this.center.distanceToSquared(point);\\n\\n    var result = optionalTarget || new THREE.Vector3();\\n    result.copy(point);\\n\\n    if (deltaLengthSq > this.radius * this.radius) {\\n\\n      result.sub(this.center).normalize();\\n      result.multiplyScalar(this.radius).add(this.center);\\n\\n    }\\n\\n    return result;\\n\\n  },\\n\\n  getBoundingBox: function getBoundingBox(optionalTarget) {\\n\\n    var box = optionalTarget || new THREE.Box3();\\n\\n    box.set(this.center, this.center);\\n    box.expandByScalar(this.radius);\\n\\n    return box;\\n\\n  },\\n\\n  applyMatrix4: function applyMatrix4(matrix) {\\n\\n    this.center.applyMatrix4(matrix);\\n    this.radius = this.radius * matrix.getMaxScaleOnAxis();\\n\\n    return this;\\n\\n  },\\n\\n  translate: function translate(offset) {\\n\\n    this.center.add(offset);\\n\\n    return this;\\n\\n  },\\n\\n  equals: function equals(sphere) {\\n\\n    return sphere.center.equals(this.center) && sphere.radius === this.radius;\\n\\n  },\\n\\n  clone: function clone() {\\n\\n    return new THREE.Sphere().copy(this);\\n\\n  } };\\n\\n\\n\\n// File:src/math/Frustum.js\\n\\n/**\\n * @author mrdoob / http://mrdoob.com/\\n * @author alteredq / http://alteredqualia.com/\\n * @author bhouston / http://exocortex.com\\n */\\n\\nTHREE.Frustum = function (p0, p1, p2, p3, p4, p5) {\\n\\n  this.planes = [\\n\\n  p0 !== undefined ? p0 : new THREE.Plane(),\\n  p1 !== undefined ? p1 : new THREE.Plane(),\\n  p2 !== undefined ? p2 : new THREE.Plane(),\\n  p3 !== undefined ? p3 : new THREE.Plane(),\\n  p4 !== undefined ? p4 : new THREE.Plane(),\\n  p5 !== undefined ? p5 : new THREE.Plane()];\\n\\n\\n\\n};\\n\\nTHREE.Frustum.prototype = {\\n\\n  constructor: THREE.Frustum,\\n\\n  set: function set(p0, p1, p2, p3, p4, p5) {\\n\\n    var planes = this.planes;\\n\\n    planes[0].copy(p0);\\n    planes[1].copy(p1);\\n    planes[2].copy(p2);\\n    planes[3].copy(p3);\\n    planes[4].copy(p4);\\n    planes[5].copy(p5);\\n\\n    return this;\\n\\n  },\\n\\n  copy: function copy(frustum) {\\n\\n    var planes = this.planes;\\n\\n    for (var i = 0; i < 6; i++) {\\n\\n      planes[i].copy(frustum.planes[i]);\\n\\n    }\\n\\n    return this;\\n\\n  },\\n\\n  setFromMatrix: function setFromMatrix(m) {\\n\\n    var planes = this.planes;\\n    var me = m.elements;\\n    var me0 = me[0],me1 = me[1],me2 = me[2],me3 = me[3];\\n    var me4 = me[4],me5 = me[5],me6 = me[6],me7 = me[7];\\n    var me8 = me[8],me9 = me[9],me10 = me[10],me11 = me[11];\\n    var me12 = me[12],me13 = me[13],me14 = me[14],me15 = me[15];\\n\\n    planes[0].setComponents(me3 - me0, me7 - me4, me11 - me8, me15 - me12).normalize();\\n    planes[1].setComponents(me3 + me0, me7 + me4, me11 + me8, me15 + me12).normalize();\\n    planes[2].setComponents(me3 + me1, me7 + me5, me11 + me9, me15 + me13).normalize();\\n    planes[3].setComponents(me3 - me1, me7 - me5, me11 - me9, me15 - me13).normalize();\\n    planes[4].setComponents(me3 - me2, me7 - me6, me11 - me10, me15 - me14).normalize();\\n    planes[5].setComponents(me3 + me2, me7 + me6, me11 + me10, me15 + me14).normalize();\\n\\n    return this;\\n\\n  },\\n\\n  intersectsObject: function () {\\n\\n    var sphere = new THREE.Sphere();\\n\\n    return function (object) {\\n\\n      var geometry = object.geometry;\\n\\n      if (geometry.boundingSphere === null) geometry.computeBoundingSphere();\\n\\n      sphere.copy(geometry.boundingSphere);\\n      sphere.applyMatrix4(object.matrixWorld);\\n\\n      return this.intersectsSphere(sphere);\\n\\n    };\\n\\n  }(),\\n\\n  intersectsSphere: function intersectsSphere(sphere) {\\n\\n    var planes = this.planes;\\n    var center = sphere.center;\\n    var negRadius = -sphere.radius;\\n\\n    for (var i = 0; i < 6; i++) {\\n\\n      var distance = planes[i].distanceToPoint(center);\\n\\n      if (distance < negRadius) {\\n\\n        return false;\\n\\n      }\\n\\n    }\\n\\n    return true;\\n\\n  },\\n\\n  intersectsBox: function () {\\n\\n    var p1 = new THREE.Vector3(),\\n    p2 = new THREE.Vector3();\\n\\n    return function (box) {\\n\\n      var planes = this.planes;\\n\\n      for (var i = 0; i < 6; i++) {\\n\\n        var plane = planes[i];\\n\\n        p1.x = plane.normal.x > 0 ? box.min.x : box.max.x;\\n        p2.x = plane.normal.x > 0 ? box.max.x : box.min.x;\\n        p1.y = plane.normal.y > 0 ? box.min.y : box.max.y;\\n        p2.y = plane.normal.y > 0 ? box.max.y : box.min.y;\\n        p1.z = plane.normal.z > 0 ? box.min.z : box.max.z;\\n        p2.z = plane.normal.z > 0 ? box.max.z : box.min.z;\\n\\n        var d1 = plane.distanceToPoint(p1);\\n        var d2 = plane.distanceToPoint(p2);\\n\\n        // if both outside plane, no intersection\\n\\n        if (d1 < 0 && d2 < 0) {\\n\\n          return false;\\n\\n        }\\n      }\\n\\n      return true;\\n    };\\n\\n  }(),\\n\\n\\n  containsPoint: function containsPoint(point) {\\n\\n    var planes = this.planes;\\n\\n    for (var i = 0; i < 6; i++) {\\n\\n      if (planes[i].distanceToPoint(point) < 0) {\\n\\n        return false;\\n\\n      }\\n\\n    }\\n\\n    return true;\\n\\n  },\\n\\n  clone: function clone() {\\n\\n    return new THREE.Frustum().copy(this);\\n\\n  } };\\n\\n\\n\\n// File:src/math/Plane.js\\n\\n/**\\n * @author bhouston / http://exocortex.com\\n */\\n\\nTHREE.Plane = function (normal, constant) {\\n\\n  this.normal = normal !== undefined ? normal : new THREE.Vector3(1, 0, 0);\\n  this.constant = constant !== undefined ? constant : 0;\\n\\n};\\n\\nTHREE.Plane.prototype = {\\n\\n  constructor: THREE.Plane,\\n\\n  set: function set(normal, constant) {\\n\\n    this.normal.copy(normal);\\n    this.constant = constant;\\n\\n    return this;\\n\\n  },\\n\\n  setComponents: function setComponents(x, y, z, w) {\\n\\n    this.normal.set(x, y, z);\\n    this.constant = w;\\n\\n    return this;\\n\\n  },\\n\\n  setFromNormalAndCoplanarPoint: function setFromNormalAndCoplanarPoint(normal, point) {\\n\\n    this.normal.copy(normal);\\n    this.constant = -point.dot(this.normal); // must be this.normal, not normal, as this.normal is normalized\\n\\n    return this;\\n\\n  },\\n\\n  setFromCoplanarPoints: function () {\\n\\n    var v1 = new THREE.Vector3();\\n    var v2 = new THREE.Vector3();\\n\\n    return function (a, b, c) {\\n\\n      var normal = v1.subVectors(c, b).cross(v2.subVectors(a, b)).normalize();\\n\\n      // Q: should an error be thrown if normal is zero (e.g. degenerate plane)?\\n\\n      this.setFromNormalAndCoplanarPoint(normal, a);\\n\\n      return this;\\n\\n    };\\n\\n  }(),\\n\\n\\n  copy: function copy(plane) {\\n\\n    this.normal.copy(plane.normal);\\n    this.constant = plane.constant;\\n\\n    return this;\\n\\n  },\\n\\n  normalize: function normalize() {\\n\\n    // Note: will lead to a divide by zero if the plane is invalid.\\n\\n    var inverseNormalLength = 1.0 / this.normal.length();\\n    this.normal.multiplyScalar(inverseNormalLength);\\n    this.constant *= inverseNormalLength;\\n\\n    return this;\\n\\n  },\\n\\n  negate: function negate() {\\n\\n    this.constant *= -1;\\n    this.normal.negate();\\n\\n    return this;\\n\\n  },\\n\\n  distanceToPoint: function distanceToPoint(point) {\\n\\n    return this.normal.dot(point) + this.constant;\\n\\n  },\\n\\n  distanceToSphere: function distanceToSphere(sphere) {\\n\\n    return this.distanceToPoint(sphere.center) - sphere.radius;\\n\\n  },\\n\\n  projectPoint: function projectPoint(point, optionalTarget) {\\n\\n    return this.orthoPoint(point, optionalTarget).sub(point).negate();\\n\\n  },\\n\\n  orthoPoint: function orthoPoint(point, optionalTarget) {\\n\\n    var perpendicularMagnitude = this.distanceToPoint(point);\\n\\n    var result = optionalTarget || new THREE.Vector3();\\n    return result.copy(this.normal).multiplyScalar(perpendicularMagnitude);\\n\\n  },\\n\\n  isIntersectionLine: function isIntersectionLine(line) {\\n\\n    // Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.\\n\\n    var startSign = this.distanceToPoint(line.start);\\n    var endSign = this.distanceToPoint(line.end);\\n\\n    return startSign < 0 && endSign > 0 || endSign < 0 && startSign > 0;\\n\\n  },\\n\\n  intersectLine: function () {\\n\\n    var v1 = new THREE.Vector3();\\n\\n    return function (line, optionalTarget) {\\n\\n      var result = optionalTarget || new THREE.Vector3();\\n\\n      var direction = line.delta(v1);\\n\\n      var denominator = this.normal.dot(direction);\\n\\n      if (denominator == 0) {\\n\\n        // line is coplanar, return origin\\n        if (this.distanceToPoint(line.start) == 0) {\\n\\n          return result.copy(line.start);\\n\\n        }\\n\\n        // Unsure if this is the correct method to handle this case.\\n        return undefined;\\n\\n      }\\n\\n      var t = -(line.start.dot(this.normal) + this.constant) / denominator;\\n\\n      if (t < 0 || t > 1) {\\n\\n        return undefined;\\n\\n      }\\n\\n      return result.copy(direction).multiplyScalar(t).add(line.start);\\n\\n    };\\n\\n  }(),\\n\\n\\n  coplanarPoint: function coplanarPoint(optionalTarget) {\\n\\n    var result = optionalTarget || new THREE.Vector3();\\n    return result.copy(this.normal).multiplyScalar(-this.constant);\\n\\n  },\\n\\n  applyMatrix4: function () {\\n\\n    var v1 = new THREE.Vector3();\\n    var v2 = new THREE.Vector3();\\n    var m1 = new THREE.Matrix3();\\n\\n    return function (matrix, optionalNormalMatrix) {\\n\\n      // compute new normal based on theory here:\\n      // http://www.songho.ca/opengl/gl_normaltransform.html\\n      var normalMatrix = optionalNormalMatrix || m1.getNormalMatrix(matrix);\\n      var newNormal = v1.copy(this.normal).applyMatrix3(normalMatrix);\\n\\n      var newCoplanarPoint = this.coplanarPoint(v2);\\n      newCoplanarPoint.applyMatrix4(matrix);\\n\\n      this.setFromNormalAndCoplanarPoint(newNormal, newCoplanarPoint);\\n\\n      return this;\\n\\n    };\\n\\n  }(),\\n\\n  translate: function translate(offset) {\\n\\n    this.constant = this.constant - offset.dot(this.normal);\\n\\n    return this;\\n\\n  },\\n\\n  equals: function equals(plane) {\\n\\n    return plane.normal.equals(this.normal) && plane.constant == this.constant;\\n\\n  },\\n\\n  clone: function clone() {\\n\\n    return new THREE.Plane().copy(this);\\n\\n  } };\\n\\n\\n\\n// File:src/math/Math.js\\n\\n/**\\n * @author alteredq / http://alteredqualia.com/\\n * @author mrdoob / http://mrdoob.com/\\n */\\n\\nTHREE.Math = {\\n\\n  generateUUID: function () {\\n\\n    // http://www.broofa.com/Tools/Math.uuid.htm\\n\\n    var chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split('');\\n    var uuid = new Array(36);\\n    var rnd = 0,r;\\n\\n    return function () {\\n\\n      for (var i = 0; i < 36; i++) {\\n\\n        if (i == 8 || i == 13 || i == 18 || i == 23) {\\n\\n          uuid[i] = '-';\\n\\n        } else if (i == 14) {\\n\\n          uuid[i] = '4';\\n\\n        } else {\\n\\n          if (rnd <= 0x02) rnd = 0x2000000 + Math.random() * 0x1000000 | 0;\\n          r = rnd & 0xf;\\n          rnd = rnd >> 4;\\n          uuid[i] = chars[i == 19 ? r & 0x3 | 0x8 : r];\\n\\n        }\\n      }\\n\\n      return uuid.join('');\\n\\n    };\\n\\n  }(),\\n\\n  // Clamp value to range <a, b>\\n\\n  clamp: function clamp(x, a, b) {\\n\\n    return x < a ? a : x > b ? b : x;\\n\\n  },\\n\\n  // Clamp value to range <a, inf)\\n\\n  clampBottom: function clampBottom(x, a) {\\n\\n    return x < a ? a : x;\\n\\n  },\\n\\n  // Linear mapping from range <a1, a2> to range <b1, b2>\\n\\n  mapLinear: function mapLinear(x, a1, a2, b1, b2) {\\n\\n    return b1 + (x - a1) * (b2 - b1) / (a2 - a1);\\n\\n  },\\n\\n  // http://en.wikipedia.org/wiki/Smoothstep\\n\\n  smoothstep: function smoothstep(x, min, max) {\\n\\n    if (x <= min) return 0;\\n    if (x >= max) return 1;\\n\\n    x = (x - min) / (max - min);\\n\\n    return x * x * (3 - 2 * x);\\n\\n  },\\n\\n  smootherstep: function smootherstep(x, min, max) {\\n\\n    if (x <= min) return 0;\\n    if (x >= max) return 1;\\n\\n    x = (x - min) / (max - min);\\n\\n    return x * x * x * (x * (x * 6 - 15) + 10);\\n\\n  },\\n\\n  // Random float from <0, 1> with 16 bits of randomness\\n  // (standard Math.random() creates repetitive patterns when applied over larger space)\\n\\n  random16: function random16() {\\n\\n    return (65280 * Math.random() + 255 * Math.random()) / 65535;\\n\\n  },\\n\\n  // Random integer from <low, high> interval\\n\\n  randInt: function randInt(low, high) {\\n\\n    return Math.floor(this.randFloat(low, high));\\n\\n  },\\n\\n  // Random float from <low, high> interval\\n\\n  randFloat: function randFloat(low, high) {\\n\\n    return low + Math.random() * (high - low);\\n\\n  },\\n\\n  // Random float from <-range/2, range/2> interval\\n\\n  randFloatSpread: function randFloatSpread(range) {\\n\\n    return range * (0.5 - Math.random());\\n\\n  },\\n\\n  degToRad: function () {\\n\\n    var degreeToRadiansFactor = Math.PI / 180;\\n\\n    return function (degrees) {\\n\\n      return degrees * degreeToRadiansFactor;\\n\\n    };\\n\\n  }(),\\n\\n  radToDeg: function () {\\n\\n    var radianToDegreesFactor = 180 / Math.PI;\\n\\n    return function (radians) {\\n\\n      return radians * radianToDegreesFactor;\\n\\n    };\\n\\n  }(),\\n\\n  isPowerOfTwo: function isPowerOfTwo(value) {\\n\\n    return (value & value - 1) === 0 && value !== 0;\\n\\n  },\\n\\n  nextPowerOfTwo: function nextPowerOfTwo(value) {\\n\\n    value--;\\n    value |= value >> 1;\\n    value |= value >> 2;\\n    value |= value >> 4;\\n    value |= value >> 8;\\n    value |= value >> 16;\\n    value++;\\n\\n    return value;\\n\\n  } };\\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../node_modules/webpack/buildin/module.js */ \\\"./node_modules/webpack/buildin/module.js\\\")(module)))\\n\\n/***/ }),\\n\\n/***/ \\\"./node_modules/babel-loader/lib/index.js?!./extensions/Edit2D/SegmentTreeWorker.js\\\":\\n/*!****************************************************************************************!*\\\\\\n  !*** ./node_modules/babel-loader/lib??ref--4!./extensions/Edit2D/SegmentTreeWorker.js ***!\\n  \\\\****************************************************************************************/\\n/*! no exports provided */\\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n__webpack_require__.r(__webpack_exports__);\\n/* harmony import */ var _src_wgs_scene_VertexBufferReader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../src/wgs/scene/VertexBufferReader */ \\\"./src/wgs/scene/VertexBufferReader.js\\\");\\n\\n\\nvar primCountPerBatch = 5000; // The number of primitives per batch.\\nvar numOfArgs = 8; // Number of arguments per primitive\\nvar stride = numOfArgs + 1; // Number of arguments plus the position for the primitive type.\\nvar size = stride * primCountPerBatch; // Size for the Float64Array\\n\\n// Allocate the number of arguments per primitive plus a position for the primitive type and multiply it by the batch count.\\n// Float64Array is required because there were float arguments that contained more than 7 digits. \\nvar primitiveBatch = new Float64Array(size);\\n\\nvar numGeoms = 0; // Number of geometries processed\\nvar totalGeoms = 0; // Total number of geometries to process. This is passed in from the main thread.\\nvar batchIndex = 0; // Keeps track of the batch index. When the limit is reached this will be reset.\\n\\n// Integers to write into the TypeArray for each primitive type\\nvar primitiveTypes = {\\n  onLineSegment: 1,\\n  onCircularArc: 2,\\n  onEllipticalArc: 3,\\n  finished: 9 };\\n\\n\\n/**\\n                  * Batches geom primitives and sends it to the main thread once the primCountPerBatch is reached.\\n                  * @param {String} type - Geometry Primitive type string\\n                  * @param {Number[]} args - An array of arguments that are returned from the VertexBufferBuilder callbacks\\n                  */\\nfunction post(type) {var args = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\\n  // The first entry will be the primitive type\\n  primitiveBatch[batchIndex++] = primitiveTypes[type];\\n\\n  // Add the arguments to the batch\\n  for (var i = 0; i < numOfArgs; i++) {\\n    primitiveBatch[batchIndex++] = i < args.length ? args[i] : 0;\\n  }\\n\\n  // Message the main thread once the primitive count was reached or once the number of processed geometries reaches the total number of geometries\\n  if (batchIndex >= primCountPerBatch * stride || numGeoms === totalGeoms) {\\n    // Send existing batch and create a new batch\\n    postMessage(primitiveBatch, [primitiveBatch.buffer]);\\n\\n    primitiveBatch = new Float64Array(size);\\n    batchIndex = 0;\\n  }\\n}\\n\\nonmessage = function onmessage(e) {\\n  // First call from the SegementTree.js\\n  // This will initialize the geometry count and other global variables.\\n  if (e.data.hasOwnProperty('totalGeoms')) {\\n    totalGeoms = e.data.totalGeoms;\\n    primitiveBatch = new Float64Array(size);\\n    numGeoms = 0;\\n    batchIndex = 0;\\n    return;\\n  }\\n\\n  // Iterate over an array of geometry objects.\\n  // A geometry object contains information from the FragmentList that will be used by the VertexBufferReader.\\n  for (var i = 0; i < e.data.length; i++) {\\n    var geom = e.data[i];\\n    var collectSegment = {\\n      onLineSegment: function onLineSegment() {for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {args[_key] = arguments[_key];}return post('onLineSegment', args);},\\n      onCircularArc: function onCircularArc() {for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {args[_key2] = arguments[_key2];}return post('onCircularArc', args);},\\n      onEllipticalArc: function onEllipticalArc() {for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {args[_key3] = arguments[_key3];}return post('onEllipticalArc', args);} };\\n\\n    var vbr = new _src_wgs_scene_VertexBufferReader__WEBPACK_IMPORTED_MODULE_0__[\\\"VertexBufferReader\\\"](geom);\\n\\n    vbr.enumGeoms(null, collectSegment);\\n    numGeoms++;\\n  }\\n\\n  // Notify the main thread that a geometry was processed.\\n  post('finished');\\n};\\n\\n/***/ }),\\n\\n/***/ \\\"./node_modules/webpack/buildin/module.js\\\":\\n/*!***********************************!*\\\\\\n  !*** (webpack)/buildin/module.js ***!\\n  \\\\***********************************/\\n/*! no static exports found */\\n/***/ (function(module, exports) {\\n\\nmodule.exports = function(module) {\\n\\tif (!module.webpackPolyfill) {\\n\\t\\tmodule.deprecate = function() {};\\n\\t\\tmodule.paths = [];\\n\\t\\t// module.parent = undefined by default\\n\\t\\tif (!module.children) module.children = [];\\n\\t\\tObject.defineProperty(module, \\\"loaded\\\", {\\n\\t\\t\\tenumerable: true,\\n\\t\\t\\tget: function() {\\n\\t\\t\\t\\treturn module.l;\\n\\t\\t\\t}\\n\\t\\t});\\n\\t\\tObject.defineProperty(module, \\\"id\\\", {\\n\\t\\t\\tenumerable: true,\\n\\t\\t\\tget: function() {\\n\\t\\t\\t\\treturn module.i;\\n\\t\\t\\t}\\n\\t\\t});\\n\\t\\tmodule.webpackPolyfill = 1;\\n\\t}\\n\\treturn module;\\n};\\n\\n\\n/***/ }),\\n\\n/***/ \\\"./src/wgs/scene/VertexBufferReader.js\\\":\\n/*!*********************************************!*\\\\\\n  !*** ./src/wgs/scene/VertexBufferReader.js ***!\\n  \\\\*********************************************/\\n/*! exports provided: VertexBufferReader, BoundsCallback */\\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n__webpack_require__.r(__webpack_exports__);\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"VertexBufferReader\\\", function() { return VertexBufferReader; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"BoundsCallback\\\", function() { return BoundsCallback; });\\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \\\"./extensions/MemoryLimited/thirdparty/three.js/three-worker.js\\\");\\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(three__WEBPACK_IMPORTED_MODULE_0__);\\n\\n\\n\\n\\n\\nvar TAU = Math.PI * 2;\\n\\n//Constants duplicated from src/lmvtk/VertexBufferBuilder.js\\nvar VBB_GT_TRIANGLE_INDEXED = 0,\\nVBB_GT_LINE_SEGMENT = 1,\\nVBB_GT_ARC_CIRCULAR = 2,\\nVBB_GT_ARC_ELLIPTICAL = 3,\\nVBB_GT_TEX_QUAD = 4,\\nVBB_GT_ONE_TRIANGLE = 5;\\n\\nvar VBB_INSTANCED_FLAG = 0, // this is intentionally 0 for the instancing case!\\nVBB_SEG_START_RIGHT = 0, // this starts intentionally at 0!\\nVBB_SEG_START_LEFT = 1,\\nVBB_SEG_END_RIGHT = 2,\\nVBB_SEG_END_LEFT = 3;\\n\\nvar VBB_COLOR_OFFSET = 6,\\nVBB_DBID_OFFSET = 7,\\nVBB_FLAGS_OFFSET = 8,\\nVBB_LAYER_VP_OFFSET = 9;\\n\\n/**\\n                          * Initializes a \\\"view\\\" into a compacted interleaved vertex buffer array using our custom 2D vertex layout.\\n                          * See src/lmvtk/VertexBufferBuilder.js for more details.\\n                          */\\nfunction VertexBufferReader(geometry)\\n{var _geometry$tIdColor,_geometry$tIdColor$im,_this = this;\\n  this.vb = geometry.vb.buffer;\\n  this.vbf = new Float32Array(this.vb);\\n  this.vbi = new Int32Array(this.vb);\\n  this.vbs = new Uint16Array(this.vb);\\n\\n  this.ib = geometry.ib;\\n\\n  this.stride = geometry.vbstride;\\n  this.vcount = this.vbf.length / this.stride;\\n\\n  this.useInstancing = geometry.numInstances > 0;\\n  this.useCompactBuffers = geometry.unpackXform;\\n  this.texData = this.useCompactBuffers && ((_geometry$tIdColor = geometry.tIdColor) === null || _geometry$tIdColor === void 0 ? void 0 : (_geometry$tIdColor$im = _geometry$tIdColor.image) === null || _geometry$tIdColor$im === void 0 ? void 0 : _geometry$tIdColor$im.data) && new Uint32Array(geometry.tIdColor.image.data.buffer);\\n\\n  // Does the geom use interleaved vb?\\n  // Used by FragmentList.updateVertexBufferForThemingAndGhosting which only\\n  // workes with interleaved vb\\n  this.isInterleavedVb = function () {\\n    var attr = geometry.attributes;\\n    if (!attr) return false;\\n\\n    var atLayerVp = attr.layerVp4b;\\n    var atFlags = attr.flags4b;\\n\\n    if (_this.useCompactBuffers) {\\n      var atIdColors = attr.uvIdColor;\\n      return atIdColors && atLayerVp && atFlags;\\n    } else {\\n      var atColors = attr.color4b;\\n      var atIds = attr.dbId4b;\\n      return atColors && atIds && atLayerVp && atFlags;\\n    }\\n  }();\\n};\\n\\nVertexBufferReader.prototype.getDbIdAt = function (vindex) {\\n  if (this.texData) {\\n    return this.texData[this.vbs[vindex * this.stride * 2 + VBB_DBID_OFFSET]];\\n  }\\n  return this.vbi[vindex * this.stride + VBB_DBID_OFFSET];\\n};\\n\\nVertexBufferReader.prototype.getColorAt = function (vindex) {\\n  if (this.texData) {\\n    return this.texData[this.vbs[vindex * this.stride * 2 + VBB_COLOR_OFFSET]];\\n  }\\n  return this.vbi[vindex * this.stride + VBB_COLOR_OFFSET];\\n};\\n\\nVertexBufferReader.prototype.getVertexFlagsAt = function (vindex) {\\n  if (this.texData) {\\n    return this.vbi[vindex * this.stride + 4];\\n  }\\n  return this.vbi[vindex * this.stride + VBB_FLAGS_OFFSET];\\n};\\n\\nVertexBufferReader.prototype.getLayerIndexAt = function (vindex) {\\n  if (this.texData) {\\n    return this.vbi[vindex * this.stride + 5] & 0xffff;\\n  }\\n  return this.vbi[vindex * this.stride + VBB_LAYER_VP_OFFSET] & 0xffff;\\n};\\n\\nVertexBufferReader.prototype.getViewportIndexAt = function (vindex) {\\n  if (this.texData) {\\n    return this.vbi[vindex * this.stride + 5] >> 16 & 0xffff;\\n  }\\n  return this.vbi[vindex * this.stride + VBB_LAYER_VP_OFFSET] >> 16 & 0xffff;\\n};\\n\\nVertexBufferReader.prototype.decodeLineAt = function (vindex, layer, vpId, callback)\\n{\\n  if (!callback.onLineSegment) {return;}\\n\\n  if (this.useCompactBuffers) {\\n    var vertexOffset = this.stride * vindex * 2;\\n    var x0 = this.useCompactBuffers.x * this.vbs[vertexOffset] / 65535 + this.useCompactBuffers.z;\\n    var y0 = this.useCompactBuffers.y * this.vbs[vertexOffset + 1] / 65535 + this.useCompactBuffers.w;\\n    var angle = this.vbs[vertexOffset + 2] / 65535 * TAU - Math.PI;\\n    var distAlong = this.vbs[vertexOffset + 3] / 65535 * Math.max(this.useCompactBuffers.x, this.useCompactBuffers.y);\\n    var lineWidth = this.vbs[vertexOffset + 4] / 32767 * Math.max(this.useCompactBuffers.x, this.useCompactBuffers.y) * 2.0;\\n  } else {\\n    var baseOffset = this.stride * vindex;\\n    var x0 = this.vbf[baseOffset];\\n    var y0 = this.vbf[baseOffset + 1];\\n    var angle = this.vbf[baseOffset + 2] * TAU - Math.PI; // decode angle: see VertexBufferBuilder.addVertexLine\\n    var distAlong = this.vbf[baseOffset + 3];\\n    var lineWidth = this.vbf[baseOffset + 4] * 2.0;\\n  }\\n\\n  var x1 = x0 + distAlong * Math.cos(angle);\\n  var y1 = y0 + distAlong * Math.sin(angle);\\n\\n  callback.onLineSegment(x0, y0, x1, y1, vpId, lineWidth);\\n};\\n\\nVertexBufferReader.prototype.decodeCircularArcAt = function (vindex, layer, vpId, callback)\\n{\\n  if (!callback.onCircularArc) {return;}\\n\\n  if (this.useCompactBuffers) {\\n    var vertexOffset = this.stride * vindex * 2;\\n    var cx = this.useCompactBuffers.x * this.vbs[vertexOffset] / 65535 + this.useCompactBuffers.z;\\n    var cy = this.useCompactBuffers.y * this.vbs[vertexOffset + 1] / 65535 + this.useCompactBuffers.w;\\n    var start = this.vbs[vertexOffset + 2] / 65535 * TAU;\\n    var end = this.vbs[vertexOffset + 3] / 65535 * TAU;\\n    var radius = this.vbs[vertexOffset + 5] / 65535 * Math.max(this.useCompactBuffers.x, this.useCompactBuffers.y);\\n  } else {\\n    var baseOffset = this.stride * vindex;\\n    var cx = this.vbf[baseOffset];\\n    var cy = this.vbf[baseOffset + 1];\\n    var start = this.vbf[baseOffset + 2] * TAU;\\n    var end = this.vbf[baseOffset + 3] * TAU;\\n    var radius = this.vbf[baseOffset + 5];\\n  }\\n\\n  callback.onCircularArc(cx, cy, start, end, radius, vpId);\\n};\\n\\nVertexBufferReader.prototype.decodeEllipticalArcAt = function (vindex, layer, vpId, callback)\\n{\\n  if (!callback.onEllipticalArc) {return;}\\n\\n  // Note: compaction will not happen for the VBB_GT_ARC_ELLIPTICAL\\n  var baseOffset = this.stride * vindex;\\n  var cx = this.vbf[baseOffset];\\n  var cy = this.vbf[baseOffset + 1];\\n  var start = this.vbf[baseOffset + 2] * TAU;\\n  var end = this.vbf[baseOffset + 3] * TAU;\\n  var major = this.vbf[baseOffset + 5];\\n  var minor = this.vbf[baseOffset + 10];\\n  var tilt = this.vbf[baseOffset + 11];\\n\\n  callback.onEllipticalArc(cx, cy, start, end, major, minor, tilt, vpId);\\n};\\n\\nVertexBufferReader.prototype.decodeTexQuadAt = function (vindex, layer, vpId, callback)\\n{\\n  if (!callback.onTexQuad) {return;}\\n\\n  if (this.useCompactBuffers) {\\n    var vertexOffset = this.stride * vindex * 2;\\n    var centerX = this.useCompactBuffers.x * this.vbs[vertexOffset] / 65535 + this.useCompactBuffers.z;\\n    var centerY = this.useCompactBuffers.y * this.vbs[vertexOffset + 1] / 65535 + this.useCompactBuffers.w;\\n    var rotation = this.vbs[vertexOffset + 2] / 65535 * TAU;\\n    var width = this.vbs[vertexOffset + 3] / 65535 * Math.max(this.useCompactBuffers.x, this.useCompactBuffers.y);\\n    var height = this.vbs[vertexOffset + 4] / 65535 * Math.max(this.useCompactBuffers.x, this.useCompactBuffers.y);\\n  } else {\\n    var baseOffset = this.stride * vindex;\\n    var centerX = this.vbf[baseOffset];\\n    var centerY = this.vbf[baseOffset + 1];\\n    // yes, this is in a different order than output, following VertexBufferBuilder's order\\n    var rotation = this.vbf[baseOffset + 2] * TAU;\\n    var width = this.vbf[baseOffset + 3];\\n    var height = this.vbf[baseOffset + 4];\\n  }\\n\\n  callback.onTexQuad(centerX, centerY, width, height, rotation, vpId);\\n};\\n\\nVertexBufferReader.prototype.decodeOneTriangleAt = function (vindex, layer, vpId, callback)\\n{\\n  if (!callback.onOneTriangle) {return;}\\n\\n  if (this.useCompactBuffers) {\\n    var vertexOffset = this.stride * vindex * 2;\\n    var x1 = this.useCompactBuffers.x * this.vbs[vertexOffset] / 65535 + this.useCompactBuffers.z;\\n    var y1 = this.useCompactBuffers.y * this.vbs[vertexOffset + 1] / 65535 + this.useCompactBuffers.w;\\n    var x2 = this.useCompactBuffers.x * this.vbs[vertexOffset + 2] / 65535 + this.useCompactBuffers.z;\\n    var y2 = this.useCompactBuffers.y * this.vbs[vertexOffset + 3] / 65535 + this.useCompactBuffers.w;\\n    var x3 = this.useCompactBuffers.x * this.vbs[vertexOffset + 4] / 65535 + this.useCompactBuffers.z;\\n    var y3 = this.useCompactBuffers.y * this.vbs[vertexOffset + 5] / 65535 + this.useCompactBuffers.w;\\n  } else {\\n    var baseOffset = this.stride * vindex;\\n    var x1 = this.vbf[baseOffset];\\n    var y1 = this.vbf[baseOffset + 1];\\n    var x2 = this.vbf[baseOffset + 2];\\n    var y2 = this.vbf[baseOffset + 3];\\n    var x3 = this.vbf[baseOffset + 4];\\n    var y3 = this.vbf[baseOffset + 5];\\n  }\\n\\n  callback.onOneTriangle(x1, y1, x2, y2, x3, y3, vpId);\\n};\\n\\n\\nVertexBufferReader.prototype.decodeTriangleIndexed = function (vi0, vi1, vi2, layer, vpId, callback)\\n{\\n  if (!callback.onOneTriangle) {return;}\\n\\n  if (this.useCompactBuffers) {\\n    var vertexOffset = this.stride * vi0 * 2;\\n    var x1 = this.useCompactBuffers.x * this.vbs[vertexOffset] / 65535 + this.useCompactBuffers.z;\\n    var y1 = this.useCompactBuffers.y * this.vbs[vertexOffset + 1] / 65535 + this.useCompactBuffers.w;\\n\\n    vertexOffset = this.stride * vi1 * 2;\\n    var x2 = this.useCompactBuffers.x * this.vbs[vertexOffset] / 65535 + this.useCompactBuffers.z;\\n    var y2 = this.useCompactBuffers.y * this.vbs[vertexOffset + 1] / 65535 + this.useCompactBuffers.w;\\n\\n    vertexOffset = this.stride * vi2 * 2;\\n    var x3 = this.useCompactBuffers.x * this.vbs[vertexOffset] / 65535 + this.useCompactBuffers.z;\\n    var y3 = this.useCompactBuffers.y * this.vbs[vertexOffset + 1] / 65535 + this.useCompactBuffers.w;\\n  } else {\\n    var baseOffset = this.stride * vi0;\\n    var x1 = this.vbf[baseOffset];\\n    var y1 = this.vbf[baseOffset + 1];\\n\\n    baseOffset = this.stride * vi1;\\n    var x2 = this.vbf[baseOffset];\\n    var y2 = this.vbf[baseOffset + 1];\\n\\n    baseOffset = this.stride * vi2;\\n    var x3 = this.vbf[baseOffset];\\n    var y3 = this.vbf[baseOffset + 1];\\n  }\\n\\n  callback.onOneTriangle(x1, y1, x2, y2, x3, y3, vpId);\\n};\\n\\n\\n// used by the snapper and by the bounds finder\\nVertexBufferReader.prototype.enumGeomsForObject = function (dbId, callback)\\n{\\n  if (this.useInstancing) {\\n\\n    //When instancing is used, each geometry primitive is encoded into a single vertex\\n    //and there is no index buffer.\\n\\n    var i = 0;\\n    while (i < this.vcount) {\\n      var flag = this.getVertexFlagsAt(i);\\n\\n      //var vertexId  = (flag >>  0) & 0xff;        //  8 bit\\n      var geomType = flag >> 8 & 0xff; //  8 bit\\n      //var linePattern = (flag >> 16) & 0xff;      //  8 bit\\n      var layerId = this.getLayerIndexAt(i); // 16 bit\\n      var vpId = this.getViewportIndexAt(i); // 16 bit     \\n      var visible = this.getDbIdAt(i) === dbId;\\n      if (visible) {\\n        switch (geomType) {\\n          case VBB_GT_LINE_SEGMENT:this.decodeLineAt(i, layerId, vpId, callback);break;\\n          case VBB_GT_ARC_CIRCULAR:this.decodeCircularArcAt(i, layerId, vpId, callback);break;\\n          case VBB_GT_ARC_ELLIPTICAL:this.decodeEllipticalArcAt(i, layerId, vpId, callback);break; //  compaction is not performed\\n          case VBB_GT_TEX_QUAD:this.decodeTexQuadAt(i, layerId, vpId, callback);break;\\n          case VBB_GT_ONE_TRIANGLE:this.decodeOneTriangleAt(i, layerId, vpId, callback);break;\\n          default:break;}\\n\\n      }\\n\\n      //In the case of instancing, there is no vertex duplication and no index buffer, we just\\n      //move to the next vertex\\n      i += 1;\\n    }\\n  } else {\\n\\n    var i = 0;\\n    while (i < this.ib.length) {\\n      var vi = this.ib[i];\\n      var flag = this.getVertexFlagsAt(vi);\\n\\n      //var vertexId    = (flag >>  0) & 0xff;        //  8 bit\\n      var geomType = flag >> 8 & 0xff; //  8 bit\\n      //var linePattern = (flag >> 16) & 0xff;        //  8 bit\\n      var layerId = this.getLayerIndexAt(vi); // 16 bit\\n      var vpId = this.getViewportIndexAt(vi); // 16 bit\\n\\n      var visible = this.getDbIdAt(vi) === dbId;\\n\\n      if (geomType === VBB_GT_TRIANGLE_INDEXED) {\\n\\n        //Triangles are encoded in three vertices (like a simple mesh) instead of 4 like everything else\\n\\n        if (visible) {\\n          this.decodeTriangleIndexed(this.ib[i], this.ib[i + 1], this.ib[i + 2], layerId, vpId, callback);\\n        }\\n\\n        //Advance to the next primitive\\n        i += 3;\\n\\n      } else {\\n\\n        if (visible) {\\n          switch (geomType) {\\n            case VBB_GT_LINE_SEGMENT:this.decodeLineAt(vi, layerId, vpId, callback);break;\\n            case VBB_GT_ARC_CIRCULAR:this.decodeCircularArcAt(vi, layerId, vpId, callback);break;\\n            case VBB_GT_ARC_ELLIPTICAL:this.decodeEllipticalArcAt(vi, layerId, vpId, callback);break;\\n            case VBB_GT_TEX_QUAD:this.decodeTexQuadAt(vi, layerId, vpId, callback);break;\\n            case VBB_GT_ONE_TRIANGLE:this.decodeOneTriangleAt(vi, layerId, vpId, callback);break;\\n            default:break;}\\n\\n        }\\n\\n        //Skip duplicate vertices (when not using instancing and the geometry is not a simple polytriangle,\\n        //each vertex is listed four times with a different vertexId flag\\n        i += 6;\\n      }\\n\\n\\n    }\\n  }\\n\\n};\\n\\n\\n/**\\n    * Used by the bounds finder.\\n    * @param {array[number]} layerIdsVisible - list of layer ids that are visible\\n    * @param {function} callback\\n    * @private\\n    */\\nVertexBufferReader.prototype.enumGeomsForVisibleLayer = function (layerIdsVisible, callback)\\n{\\n  var filter = function filter(dbId, layerId, viewportId) {\\n    return !layerIdsVisible || layerId !== 0 && layerIdsVisible.indexOf(layerId) !== -1;\\n  };\\n  this.enumGeoms(filter, callback);\\n};\\n\\n\\n/**\\n    * Enumerate all geometric primitives that match the given filter.\\n    * @param {function} [filter] - function(dbId, layerId, viewportId): Filter function to define a subset of primitives to include. By default, all geometry is included.\\n    * @param {function} callback\\n    * @private\\n    */\\nVertexBufferReader.prototype.enumGeoms = function (filter, callback)\\n{\\n  if (this.useInstancing) {\\n\\n    //When instancing is used, each geometry primitive is encoded into a single vertex\\n    //and there is no index buffer.\\n\\n    var i = 0;\\n    while (i < this.vcount) {\\n      var flag = this.getVertexFlagsAt(i);\\n\\n      //var vertexId    = (flag >>  0) & 0xff;        //  8 bit\\n      var geomType = flag >> 8 & 0xff; //  8 bit\\n      //var linePattern = (flag >> 16) & 0xff;        //  8 bit\\n      var layerId = this.getLayerIndexAt(i); // 16 bit\\n      var vpId = this.getViewportIndexAt(i); // 16 bit\\n      var dbId = this.getDbIdAt(i);\\n\\n      // Get the bounds of only the visible layers. Ignore layer 0, which is always the page.\\n      // If layerId visibility is not set, consider the layer visible.\\n      var visible = !filter || filter(dbId, layerId, vpId);\\n      if (visible) {\\n        switch (geomType) {\\n          case VBB_GT_LINE_SEGMENT:this.decodeLineAt(i, layerId, vpId, callback);break;\\n          case VBB_GT_ARC_CIRCULAR:this.decodeCircularArcAt(i, layerId, vpId, callback);break;\\n          case VBB_GT_ARC_ELLIPTICAL:this.decodeEllipticalArcAt(i, layerId, vpId, callback);break;\\n          case VBB_GT_TEX_QUAD:this.decodeTexQuadAt(i, layerId, vpId, callback);break;\\n          case VBB_GT_ONE_TRIANGLE:this.decodeOneTriangleAt(i, layerId, vpId, callback);break;\\n          default:break;}\\n\\n      }\\n\\n      //In the case of instancing, there is no vertex duplication and no index buffer, we just\\n      //move to the next vertex\\n      i += 1;\\n    }\\n  } else {\\n\\n    var i = 0;\\n    while (i < this.ib.length) {\\n      var vi = this.ib[i];\\n      var flag = this.getVertexFlagsAt(vi);\\n\\n      //var vertexId    = (flag >>  0) & 0xff;        //  8 bit\\n      var geomType = flag >> 8 & 0xff; //  8 bit\\n      //var linePattern = (flag >> 16) & 0xff;        //  8 bit\\n      var layerId = this.getLayerIndexAt(vi); // 16 bit\\n      var vpId = this.getViewportIndexAt(vi); // 16 bit\\n      var dbId = this.getDbIdAt(vi);\\n\\n      // Get the bounds of only the visible layers. Ignore layer 0, which is always the page.\\n      // If layerId visibility is not set, consider the layer visible.\\n      var visible = !filter || filter(dbId, layerId, vpId);\\n\\n      if (geomType === VBB_GT_TRIANGLE_INDEXED) {\\n\\n        //Triangles are encoded in three vertices (like a simple mesh) instead of 4 like everything else\\n\\n        if (visible) {\\n          this.decodeTriangleIndexed(this.ib[i], this.ib[i + 1], this.ib[i + 2], layerId, vpId, callback);\\n        }\\n\\n        //Advance to the next primitive\\n        i += 3;\\n\\n      } else {\\n\\n        if (visible) {\\n          switch (geomType) {\\n            case VBB_GT_LINE_SEGMENT:this.decodeLineAt(vi, layerId, vpId, callback);break;\\n            case VBB_GT_ARC_CIRCULAR:this.decodeCircularArcAt(vi, layerId, vpId, callback);break;\\n            case VBB_GT_ARC_ELLIPTICAL:this.decodeEllipticalArcAt(vi, layerId, vpId, callback);break;\\n            case VBB_GT_TEX_QUAD:this.decodeTexQuadAt(vi, layerId, vpId, callback);break;\\n            case VBB_GT_ONE_TRIANGLE:this.decodeOneTriangleAt(vi, layerId, vpId, callback);break;\\n            default:break;}\\n\\n        }\\n\\n        //Skip duplicate vertices (when not using instancing and the geometry is not a simple polytriangle,\\n        //each vertex is listed four times with a different vertexId flag\\n        i += 6;\\n      }\\n\\n    }\\n  }\\n\\n};\\n\\n\\n\\n/**\\n    * Callback class for calculating bounds of 2D objects via VertexBufferReader\\n    * @private\\n    */\\nfunction BoundsCallback(bounds) {\\n  this.bounds = bounds;\\n  // workspace, so we don't reallocate this each time\\n  this.point = new three__WEBPACK_IMPORTED_MODULE_0__[\\\"Vector4\\\"]();\\n  this.point.z = 0.0;\\n  this.point.w = 1.0; // it's a point, not a vector\\n}\\n\\nBoundsCallback.prototype.onVertex = function (cx, cy, vpId) {\\n  this.point.x = cx;\\n  this.point.y = cy;\\n  this.bounds.expandByPoint(this.point);\\n};\\n\\nBoundsCallback.prototype.onLineSegment = function (x1, y1, x2, y2, vpId) {\\n  this.onVertex(x1, y1);\\n  this.onVertex(x2, y2);\\n};\\n\\nBoundsCallback.prototype.onCircularArc = function (cx, cy, start, end, radius, vpId) {\\n  this.onEllipticalArc(cx, cy, start, end, radius, radius, 0.0, vpId);\\n};\\n\\nBoundsCallback.prototype.onEllipticalArc = function (cx, cy, start, end, major, minor, tilt, vpId) {\\n  if (tilt == 0.0) {\\n    // does start and end make a full ellipse?\\n    if (start <= 0 && end >= 2.0 * Math.PI - 0.00001) {\\n      // full way around, simply treat it like a rectangle\\n      this.onTexQuad(cx, cy, 2 * major, 2 * minor, tilt, vpId);\\n    } else {\\n      // Not a full ellipse. We take the start and end points and also figure\\n      // out the four \\\"compass rose\\\" points that are between these two locations.\\n      // The start and end locations often exist as separate vertices so would\\n      // already be included, but for some line types they may not exist, so we\\n      // include them here.\\n      this.point.x = cx + Math.cos(start) * major;\\n      this.point.y = cy + Math.sin(start) * minor;\\n      this.bounds.expandByPoint(this.point);\\n      this.point.x = cx + Math.cos(end) * major;\\n      this.point.y = cy + Math.sin(end) * minor;\\n      this.bounds.expandByPoint(this.point);\\n\\n      // now check each NESW compass point, i.e., middle of each edge\\n      if (start > end) {\\n        // add right edge\\n        this.point.x = cx + major;\\n        this.point.y = cy;\\n        this.bounds.expandByPoint(this.point);\\n        // make start < end for the rest of the tests\\n        start -= 2.0 * Math.PI;\\n      }\\n      if (start < 0.5 * Math.PI && end > 0.5 * Math.PI) {\\n        // add top edge\\n        this.point.x = cx;\\n        this.point.y = cy + minor;\\n        this.bounds.expandByPoint(this.point);\\n      }\\n      if (start < Math.PI && end > Math.PI) {\\n        // add left edge\\n        this.point.x = cx - major;\\n        this.point.y = cy;\\n        this.bounds.expandByPoint(this.point);\\n      }\\n      if (start < 1.5 * Math.PI && end > 1.5 * Math.PI) {\\n        // add bottom edge\\n        this.point.x = cx;\\n        this.point.y = cy - minor;\\n        this.bounds.expandByPoint(this.point);\\n      }\\n    }\\n  } else {\\n    // Has a tilt.\\n    // From what we see, you should never reach here, as tilted ellipses are actually\\n    // always tessellated. So, we do a fallback: call the onTexQuad with the rotation.\\n    // This call will be a pretty good approximation, putting a rotated bounding box\\n    // around the whole ellipse. For more accuracy you would need to tessellate the\\n    // ellipse and get its points (especially if you don't have a full ellipse).\\n    this.onTexQuad(cx, cy, 2 * major, 2 * minor, tilt, vpId);\\n\\n    // does start and end make a full ellipse?\\n    //if ( (start <= 0) && (end >= 2.0 * Math.PI - 0.00001) ) {\\n    //}\\n  }\\n};\\n\\n// Currently this case does not actually come up, as textured quads, i.e., images, are\\n// not something that can be selected, from what data I have tried. So I have not spent\\n// any time on the rotated case.\\n// TODO: this code is only partially tested: I had problems getting a selectable raster\\n// object in a DWG convert to an F2D.\\nBoundsCallback.prototype.onTexQuad = function (centerX, centerY, width, height, rotation, vpId) {\\n  var halfWidth = 0.5 * width;\\n  var halfHeight = 0.5 * width;\\n  if (rotation == 0.0) {\\n    this.onVertex(centerX - halfWidth, centerY - halfHeight);\\n    this.onVertex(centerX + halfWidth, centerY + halfHeight);\\n  } else {\\n    // A more complex rectangle, rotated. Take the four corners and rotate each\\n    // around the center.\\n    var rmtx = new three__WEBPACK_IMPORTED_MODULE_0__[\\\"Matrix4\\\"](); // Matrix3() does not have enough helper methods\\n    var mtx = new three__WEBPACK_IMPORTED_MODULE_0__[\\\"Matrix4\\\"]();\\n    // Take a rectangle centered at the origin, rotate it, translate it to the final\\n    // position. Each corner is added to the bounds.\\n    rmtx.makeRotationZ(rotation);\\n    // put it into the final position:\\n    mtx.makeTranslation(centerX, centerY, 0.0);\\n    mtx.multiply(rmtx);\\n\\n    for (var i = 0; i < 4; i++) {\\n      this.point.x = i % 2 == 1 ? halfWidth : -halfWidth;\\n      this.point.y = i >= 2 ? halfHeight : -halfHeight;\\n      this.point.applyMatrix4(mtx);\\n      this.bounds.expandByPoint(this.point);\\n    }\\n  }\\n};\\n\\nBoundsCallback.prototype.onOneTriangle = function (x1, y1, x2, y2, x3, y3, vpId) {\\n  this.onVertex(x1, y1);\\n  this.onVertex(x2, y2);\\n  this.onVertex(x3, y3);\\n};\\n\\n/***/ })\\n\\n/******/ });\\n//# sourceMappingURL=3a0b2b25113f4709897f.worker.js.map\", __webpack_public_path__ + \"3a0b2b25113f4709897f.worker.js\");\n};","'use strict';\n\n// http://stackoverflow.com/questions/10343913/how-to-create-a-web-worker-from-a-string\n\nvar URL = window.URL || window.webkitURL;\n\nmodule.exports = function (content, url) {\n  try {\n    try {\n      var blob;\n\n      try {\n        // BlobBuilder = Deprecated, but widely implemented\n        var BlobBuilder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder || window.MSBlobBuilder;\n\n        blob = new BlobBuilder();\n\n        blob.append(content);\n\n        blob = blob.getBlob();\n      } catch (e) {\n        // The proposed API\n        blob = new Blob([content]);\n      }\n\n      return new Worker(URL.createObjectURL(blob));\n    } catch (e) {\n      return new Worker('data:application/javascript,' + encodeURIComponent(content));\n    }\n  } catch (e) {\n    if (!url) {\n      throw Error('Inline worker is not supported');\n    }\n\n    return new Worker(url);\n  }\n};"],"mappings":";;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AClFA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC1uBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AClVA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACtGA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACjlBA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACzLA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACtIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACjlCA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACrDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACnBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC1YA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACvQA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACpYA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACjdA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC71DA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC3JA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC7OA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACpRA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC3EA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AChCA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACvSA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACrJA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACzOA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACtPA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC1cA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACzQA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACTA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AChFA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACnLA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC9CA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC7KA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACtwBA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AChPA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC3DA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC/LA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC1QA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC59BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC/iBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACtOA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AChDA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACxbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC3EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC/YA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACxFA;AACA;AACA;;;;;;;;;;;;ACFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;A","sourceRoot":""}