{"version":3,"sources":["webpack://Autodesk.Extensions.[name]/webpack/bootstrap","webpack://Autodesk.Extensions.[name]/./extensions/CompGeom/x-triangle-plane.js","webpack://Autodesk.Extensions.[name]/./extensions/CompGeom/node_modules/poly2tri/src/point.js","webpack://Autodesk.Extensions.[name]/./extensions/CompGeom/node_modules/poly2tri/src/sweep.js","webpack://Autodesk.Extensions.[name]/./extensions/CompGeom/node_modules/poly2tri/src/advancingfront.js","webpack://Autodesk.Extensions.[name]/./extensions/CompGeom/node_modules/earcut/src/earcut.js","webpack://Autodesk.Extensions.[name]/./extensions/CompGeom/x-line-line.js","webpack://Autodesk.Extensions.[name]/./extensions/CompGeom/complex-polygon.js","webpack://Autodesk.Extensions.[name]/./extensions/CompGeom/ThirdParty/lmv_poly2tri.js","webpack://Autodesk.Extensions.[name]/./extensions/CompGeom/index.js","webpack://Autodesk.Extensions.[name]/./extensions/CompGeom/node_modules/poly2tri/src/poly2tri.js","webpack://Autodesk.Extensions.[name]/./extensions/CompGeom/node_modules/poly2tri/src/sweepcontext.js","webpack://Autodesk.Extensions.[name]/./extensions/CompGeom/node_modules/poly2tri/src/assert.js","webpack://Autodesk.Extensions.[name]/./extensions/CompGeom/node_modules/poly2tri/src/utils.js","webpack://Autodesk.Extensions.[name]/./extensions/CompGeom/edge-set.js","webpack://Autodesk.Extensions.[name]/./extensions/CompGeom/dcel.js","webpack://Autodesk.Extensions.[name]/./extensions/CompGeom/x-box-plane.js","webpack://Autodesk.Extensions.[name]/./extensions/CompGeom/x-mesh-plane.js","webpack://Autodesk.Extensions.[name]/./extensions/CompGeom/interval-tree.js","webpack://Autodesk.Extensions.[name]/./extensions/CompGeom/ellipse.js","webpack://Autodesk.Extensions.[name]/./extensions/CompGeom/LmvCanvasContext.js","webpack://Autodesk.Extensions.[name]/./extensions/CompGeom/point-list.js","webpack://Autodesk.Extensions.[name]/./extensions/CompGeom/quad-tree.js","webpack://Autodesk.Extensions.[name]/./extensions/CompGeom/node_modules/clipper-lib-fpoint/clipper.js","webpack://Autodesk.Extensions.[name]/./extensions/CompGeom/contour-set.js","webpack://Autodesk.Extensions.[name]/./extensions/CompGeom/x-plane-segment.js","webpack://Autodesk.Extensions.[name]/./extensions/CompGeom/bezier.js","webpack://Autodesk.Extensions.[name]/./extensions/CompGeom/path2d.js","webpack://Autodesk.Extensions.[name]/(webpack)/buildin/global.js","webpack://Autodesk.Extensions.[name]/./extensions/CompGeom/x-line-box.js","webpack://Autodesk.Extensions.[name]/./extensions/CompGeom/x-box-box.js","webpack://Autodesk.Extensions.[name]/./extensions/CompGeom/node_modules/poly2tri/src/pointerror.js","webpack://Autodesk.Extensions.[name]/./extensions/CompGeom/node_modules/poly2tri/src/xy.js","webpack://Autodesk.Extensions.[name]/./extensions/CompGeom/node_modules/poly2tri/src/triangle.js","webpack://Autodesk.Extensions.[name]/./extensions/CompGeom/fuzzy-math.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","logger","Autodesk","Viewing","Private","Edge","pt1","pt2","id1From","id1To","id2From","id2To","meshId","this","v1","clone","v2","res1","THREE","Vector3","res2","xTrianglePlane","plane","pt0","i0","i1","i2","res","d0","distanceToPoint","d1","d2","TOL","tmp1","tmp2","i1From","i1To","i2From","i2To","s0","Math","sign","s1","s2","numInts","xPlaneSegment","push","warn","distanceTo","xy","require","Point","x","y","_p2t_edge_list","toString","toStringBase","toJSON","set_zero","set","negate","add","sub","mul","length","sqrt","normalize","len","equals","a","b","cross","compare","cmp","dot","assert","PointError","Triangle","Node","utils","EPSILON","Orientation","orient2d","inScanArea","isAngleObtuse","pointEvent","tcx","point","node","locateNode","new_node","triangle","next","markNeighbor","addToMap","prev","legalize","mapTriangleToNodes","newFrontTriangle","fill","ax","ay","abs","isBasinAngleRight","CCW","basin","left_node","bottom_node","right_node","width","left_highest","fillBasinReq","height","isShallow","CW","fillBasin","fillAdvancingFront","edgeEventByEdge","edge","edge_event","constrained_edge","right","q","isEdgeSideOfTriangle","fillRightBelowEdgeEvent","fillRightAboveEdgeEvent","fillLeftBelowEdgeEvent","fillLeftAboveEdgeEvent","fillEdgeEvent","edgeEventByPoints","ep","eq","p1","pointCCW","o1","COLLINEAR","p2","pointCW","o2","neighborCCW","neighborCW","flipEdgeEvent","index","edgeIndex","markConstrainedEdgeByIndex","getNeighbor","markConstrainedEdgeByPoints","delaunay_edge","ot","getPoint","op","oppositePoint","oi","inCircle","rotateTrianglePair","not_legalized","pa","pb","pc","pd","adx","ady","bdx","bdy","oabd","cdx","cdy","ocad","n1","n2","n3","n4","ce1","ce2","ce3","ce4","de1","de2","de3","de4","getConstrainedEdgeCCW","getConstrainedEdgeCW","getDelaunayEdgeCCW","getDelaunayEdgeCW","setDelaunayEdgeCCW","setDelaunayEdgeCW","setConstrainedEdgeCCW","setConstrainedEdgeCW","clearNeighbors","fillRightConcaveEdgeEvent","fillRightConvexEdgeEvent","fillLeftConcaveEdgeEvent","fillLeftConvexEdgeEvent","neighborAcross","getConstrainedEdgeAcross","edge_index","clearDelaunayEdges","nextFlipTriangle","flipScanEdgeEvent","flip_triangle","newP","nextFlipPoint","o2d","triangulate","initTriangulation","createAdvancingFront","pointCount","edges","j","sweepPoints","front","head","meshClean","finalizationPolygon","AdvancingFront","tail","head_","tail_","search_node_","setHead","setTail","search","setSearch","findSearchNode","locatePoint","px","nx","Error","earcut","data","holeIndices","dim","minX","minY","maxX","maxY","invSize","hasHoles","outerLen","outerNode","linkedList","triangles","start","end","list","queue","steiner","getLeftmost","sort","compareX","filterPoints","eliminateHole","eliminateHoles","max","earcutLinked","clockwise","last","signedArea","insertNode","removeNode","again","area","ear","pass","z","zOrder","prevZ","nextZ","e","numMerges","pSize","qSize","inSize","sortLinked","indexCurve","stop","isEarHashed","isEar","cureLocalIntersections","splitEarcut","pointInTriangle","minTX","minTY","maxTX","maxTY","minZ","maxZ","intersects","locallyInside","isValidDiagonal","splitPolygon","hole","bridge","hx","hy","qx","Infinity","tan","mx","my","tanMin","sectorContainsSector","findHoleBridge","bridgeReverse","filteredBridge","leftmost","bx","by","cx","cy","py","intersectsPolygon","inside","middleInside","q1","q2","o3","o4","onSegment","min","num","a2","b2","an","bp","sum","default","deviation","polygonArea","trianglesArea","flatten","result","vertices","holes","dimensions","holeIndex","ABS","EPS","ONE_INTERSECTION","OVERLAP","pointOnLine","checkInsideSegment","precisionDistance","outPt","dx","dy","u","length2","lx","ly","len2","segmentsIntersect","e1","e2","denom","numera","numerb","status","p3_seg1","p4_seg1","p1_seg2","p2_seg2","parallelLinesOverlap","mua","da","db","avp","ComplexPolygon","uniquePoints","customInsidechecker","bbox","pts","contours","customInsideChecker","indices","cntr","yflag0","yflag1","vtx0X","vtx0Y","vtx1X","vtx1Y","inside_flag","jEnd","pointInContour","triangulateInternal","message","indexOf","triangulationFailed","k","it","IntervalTree","build","wantJitter","_pts","sz","size","offsetx","offsety","scale","pts2","iEnd","_triidx","copyPoints","random","jitterPoints","sweepCtx","lmv_poly2tri","SweepContext","points_","isOpen","Array","initEdges","processResult","createPointInPolygonChecker","tris","map_","tpts","p0","filterFace","pointInPolygon","e1x","e1y","e2x","ex1","ey1","ex2","ey2","cachedEdges","x1","y1","x2","y2","etmp","precision","xsect","pt","shift","pop","packNormals","polygonMesh","bg","BufferGeometry","pos","Float32Array","setAttribute","BufferAttribute","normal","Uint16Array","pnx","PI","pny","attributes","bytesPerItem","streamingDraw","streamingIndex","thickness","extrudedMesh","undefined","vb","iblines","vbase","inds","tmp","Box3","expandByPoint","vbp","vbi","vbili","mdata","mesh","vbstride","vblayout","position","offset","itemSize","boundingBox","boundingSphere","center","getCenter","radius","BufferGeometryUtils","meshToGeometry","geometry","polyline","edge_list","av","avecg","AutodeskNamespace","_export","prop","CompGeomExtension","viewer","options","Extension","theExtensionManager","registerExtension","previousPoly2tri","global","poly2tri","noConflict","VERSION","version","sweep","Triangulate","Basin","clear","EdgeEvent","contour","triangles_","cloneArrays","slice","pmin_","pmax_","front_","af_head_","af_middle_","af_tail_","addHole","AddHole","addHoles","concat","apply","addPoint","AddPoint","addPoints","points","getBoundingBox","getTriangles","GetTriangles","getMap","xmax","xmin","ymax","ymin","middle","removeFromMap","map","splice","isInterior","setInterior","condition","val","EdgeSet","precisionTolerance","verts","UniquePointList","polygon","findOrAddPoint","id","getPointIndex","edgeSet","sanitizedEdges","edge_table","cur_cntr","sfrom","cur","parseInt","cur_segs","toPt","openCntrs","didSomething","cntr_edge_table","entry","toerase","c1","c2","reverse","removePt","dx1","dy1","dx2","dy2","len1","Vertex","dbIds","dbIdsChanged","de","idx","v","getOppositeVertex","removeEdge","angle1","angle","angle2","flagFwd","flagRev","_canTraverse","error","isDegenerate","idxNext","eNext","DirectedEdge","swap","atan2","isZero","isEqual","minx","miny","maxx","maxy","dbIdsCached","idv1","idv2","DCEL","boxSize","quadTreeEdges","QuadTree","nextEdgeId","getDbIds","paramAlong","removeDirectedEdge","addDirectedEdge","cb","enumNearItems","skipSplitting","_addVertex","findEdgeTo","addedEdge","addEdge","sourcePts","addItem","myInts","otherInts","_enumNearEdges","ints","splitEdge","dirty","deleteItem","startVertex","endVertex","removeList","forEach","angleDelta","vOther1","vOther2","delete","cleanupFlatEdges","compact","oldid","outerPerimeter","closedAreas","cs","cs2","containsPointFrom","isHole","addContourSet","holeProcessFlag","filteredNonHoles","allAreas","openAreas","cmap","hash","values","csAll","ContourSet","_detectHolesNonZero","useEvenOddFill","_compactLists","sortEdges","polygons","openPolygons","findUntraversedEdge","vNext","findNextCCWEdge","addContour","_detectHolesEvenOdd","stitchContours","v1Tmp","v2Tmp","deTmp","sid","eid","removeDanglingPolyline","enumInBox","dNear","vNear","ptNearest","xBoxPlane","box","VertexEnumerator","mi","Matrix4","pi","Plane","xMeshPlane","baseIndex","matrixWorld","getInverse","copy","applyMatrix4","enumMeshTriangles","vA","vB","vC","fragId","makePlaneBasis","sceneUp","axis","tx","ty","planeBasis","elements","constant","convertToPlaneCoords","edges3d","IntervalNode","Box2","left","node_edges","pipResult","splitNode","split","ne","remaining_node_edges","tmpPt","Vector2","p1y","p2y","boxPtr","root","edge_indices","pointInPolygonRec","nl","nr","getEllipsePoint","rx","ry","rotation","target","cos","sin","getEllipseArcPoint","startAngle","endAngle","deltaAngle","samePoints","Number","wholeEllipse","normalizeAngle","trunc","getAngleDelta","ccw","delta","angleInsideArcCCW","angleInsideArc","insideCCW","svgAngle","ux","uy","vx","vy","ang","acos","tmpVec","EllipseArc","xAxisRotation","largeArcFlag","sweepFlag","x1p","y1p","rxs","rys","x1ps","y1ps","cr","dq","pq","cxp","cyp","theta","isFinite","targetBox","tanPhi","thetaX1","atan","thetaX2","thetaY1","thetaY2","makeEmpty","addEllipsePoint","ctx","maxSegments","minSegmentLength","lastPoint","lineTo","VertexBufferBuilder","_document","getGlobal","document","hijackContextAPI","inContext","lmvContext","fn","_tmpXform","_tmpVec","_tmpBox","_offset","_quat","Quaternion","_scale","_axis","_mtx4","LmvCanvasContext","viewport","toPageUnits","meshCallback","fontEngine","usingTextLayer","fontAtlas","pdfRefMap","canvas","createElement","context","getContext","canvasContext","lineWidthScale","scaleByDPI","clipToViewport","offsetX","offsetY","bounds","Vector4","currentMeshIndex","imageNumber","currentVbb","_curPath","_curClip","first","states","glyphCache","dbId","maxDbId","consecutiveIds","isMobileDevice","Extensions","CompGeom","SetTesselationParams","lineStyle","isScreenSpace","layers","defaultLayerId","currentLayerId","sequencedDbId","taggedId","defaultVPId","currentVpId","viewports","createViewPortData","viewportMap","ocgStack","msdfRender","obj","gen","ref","clip","lineDashedDef","_originalsave","state","_originalrestore","addCount","finalFlush","textureOption","vcount","compositeOperation","globalCompOp","globalCompositeOperation","blendModeChanged","currentCompositeOperation","isFull","toMesh","material","skipEllipticals","numEllipticals","skipCircles","numCirculars","skipTriangleGeoms","numTriangleGeoms","useInstancing","currentImage","hasLineStyles","msdfFontTexture","hasMSDFContent","viewportBounds","imageUVTexture","image","cacheKey","compositeCanvasColor","opacity","globalAlpha","reset","color","layer","antialiasEdges","me","edgeMap","processEdge","iFrom","iTo","adjacentVerts","lastIndexOf","antialiasOneEdge","flushBuffer","addSegment","isNaN","isPattern","imageTransform","count","w1","h1","vbb","xform","getCurrentTransform","isGradient","repetition","addVertexImagePolytriangle","addIndices","addTriangleGeom","addVertexPolytriangle","addAllAntialiasEdges","GradientData","fillStyle","CanvasGradient","gradientData","startPoint","endPoint","tempCanvas","tempCtx","gradient","generateCanvasGradient","fillRect","pattern","createPattern","getGradientFill","console","rgb","lastStrokeStyle","strokeStyle","lastAlpha","lastRgb","mozCurrentTransform","isFontChar","invXform","f","dst","w","h","updateDBId","rect","beginPath","log","character","font","fontSize","mozCurrentTransformInverse","hashKey","charCodeAt","loadedName","cachedGlyph","skipPath","scaleX","scaleY","fontName","distance","x0","y0","charsMap","charIndex","char","chars","page","common","info","flag","inverseYAxis","txoffset","tyoffset","ps","uv","scaleW","scaleH","path","Path2D","moveTo","closePath","subjFlatted","flattened","clipFlatted","precheckResult","preCheckForClipping","needClipping","msdfClipping","x3","y3","addVertexMSDFPolytriangle","getFillColor","pages","needCancel","drawMSDFText","_beginTextChar","setTessParams","tessParams","anticlockwise","arc","arcTo","scaleValue","cp1x","cp1y","quadraticCurveTo","cp2x","cp2y","bezierCurveTo","ellipse","isFillStrokeCombo","lastArg","updateLineDashStyle","stroke","lineWidth","getStrokeColor","param1","param2","text","maxWidth","save","translate","drawText","restore","decompose","flipX","flipY","p3","p4","transform","drawImage","sx","sy","sWidth","sHeight","dWidth","dHeight","group","inlineImageGroups","currentOpIndex","groups","rendered","getRotationAndScale","redrawImage","minScale","imageClip","addTexturedQuad","properties","isRef","refKey","propPrecision","_processProperties","tag","DBID","VP","vp","_getModelToViewportMatrix","UNITS","_getPrecision","PRECISION","viewPortId","ocgId","layerId","previousState","previousTagId","param","lineStyleInitialized","exH","LineStyleDefs","exW","def","createLinePatternTextureData","tex","pw","lineStyleTex","lineStyleIndex","lineStylePw","lineStyleTexData","lineStyleTexture","lineStyleIndexMap","addNewDashedLineStyle","ls","dpi","join","createLinePatternForDef","setLineStyleParam","_originalcreatePattern","def1","parseFloat","toFixed","circleInfo","addVertexLine","finalizeQuad","imageGroups","matrix","units","initGeomMetrics","_originalSave","_originalRestore","_originalRotate","rotate","_originalScale","_originalTranslate","_originalTransform","_originalSetTransform","setTransform","_transformMatrix","_transformStack","ad_bc","bc_ad","old","cosValue","sinValue","self","alpha","hasOpacity","groupChildMeshes","addContextCurrentTransform","parent","isLMVGroupContext","groupMatrix","translateX","translateY","makeTranslation","meshIndex","multiply","vpData","isUnitsDefined","JSON","parse","rawData","type","colorStops","startRadius","endRadius","assign","isValid","tempGradient","createLinearGradient","r0","r1","grad","createRadialGradient","ii","addColorStop","VertexConstructor","useQuadTree","precisionToleranceSq","snapBaseX","snapBaseY","xymap","Map","quadTreeVerts","vertexConstructor","minDist","dist","tmpPoint","extraDistance","itemHandler","items","children","itemCount","overlapCount","whichChild","intersectsItem","subdivide","deleteCount","xBoxBox","intersectsBox","xLineBox","xs","ys","midx","midy","findSplitPoint","keepItems","item","ClipperLib","isNode","window","nav","navigator","userAgent","toLowerCase","appName","browser","chrome","chromium","safari","firefox","firefox17","firefox15","firefox3","opera","msie10","msie9","msie8","msie7","msie","Inherit","ce","getOwnPropertyNames","$baseCtor","props","getOwnPropertyDescriptor","Path","Paths","PolyNode","m_Parent","m_polygon","m_Index","m_jointype","m_endtype","m_Childs","IsOpen","IsHoleNode","ChildCount","Contour","AddChild","Child","cnt","GetNext","GetNextSiblingUp","Childs","Parent","IsHole","PolyTree","m_AllPolys","Clear","ilen","GetFirst","Total","PI2","FPoint","arguments","alen","X","Y","use_xyz","Z","dp","op_Equality","op_Inequality","FPoint0","FPoint1","FPoint1dp","FPoint2","FRect","top","bottom","ir","FRect0","FRect1","FRect4","ClipType","ctIntersection","ctUnion","ctDifference","ctXor","PolyType","ptSubject","ptClip","PolyFillType","pftEvenOdd","pftNonZero","pftPositive","pftNegative","JoinType","jtSquare","jtRound","jtMiter","EndType","etOpenSquare","etOpenRound","etOpenButt","etClosedLine","etClosedPolygon","EdgeSide","esLeft","esRight","Direction","dRightToLeft","dLeftToRight","TEdge","Bot","Curr","Top","Delta","Dx","PolyTyp","Side","WindDelta","WindCnt","WindCnt2","OutIdx","Next","Prev","NextInLML","NextInAEL","PrevInAEL","NextInSEL","PrevInSEL","IntersectNode","Edge1","Edge2","Pt","MyIntersectNodeSort","Compare","node1","node2","LocalMinima","LeftBound","RightBound","Scanbeam","Maxima","OutRec","Idx","FirstLeft","Pts","BottomPt","OutPt","Join","OutPt1","OutPt2","OffPt","ClipperBase","m_MinimaList","m_CurrentLM","m_edges","m_HasOpenPaths","PreserveCollinear","m_Scanbeam","m_PolyOuts","m_ActiveEdges","horizontal","Skip","Unassigned","tolerance","maxValue","MAX_VALUE","minValue","MIN_VALUE","near_zero","IsHorizontal","PointIsVertex","pp","pp2","PointOnLineSegment","linePt1","linePt2","PointOnPolygon","SlopesEqual","pt3","pt4","SlopesEqual3","SlopesEqual4","SlopesEqual5","DisposeLocalMinimaList","jlen","tmpLm","RangeTest","InitEdge","ePrev","InitEdge2","polyType","SetDx","FindNextLocMin","E","E2","ProcessBound","LeftBoundIsForward","EStart","Horz","Result","locMin","InsertLocalMinima","ReverseHorizontal","AddPath","pg","Closed","use_lines","highI","IsFlat","leftBoundIsForward","eStart","eLoopStop","Pt2IsBetweenPt1AndPt3","RemoveEdge","EMin","AddPaths","ppg","closed","newLm","PopLocalMinima","current","Reset","lm","InsertScanbeam","newSb","sb2","newSb1","PopScanbeam","LocalMinimaPending","CreateOutRec","DisposeOutRec","outRec","UpdateEdgeIntoAEL","AelPrev","AelNext","SwapPositionsInAEL","edge1","edge2","next1","prev1","next2","prev2","DeleteFromAEL","Clipper","InitOptions","m_ClipType","m_Maxima","m_SortedEdges","m_IntersectList","m_IntersectNodeComparer","m_ExecuteLocked","m_ClipFillType","m_SubjFillType","m_Joins","m_GhostJoins","m_UsingPolyTree","ReverseSolution","StrictlySimple","ZFillFunction","ioReverseSolution","ioStrictlySimple","ioPreserveCollinear","DisposeAllPolyPts","InsertMaxima","newMax","Execute","ispolytree","clipType","solution","subjFillType","clipFillType","succeeded","ExecuteInternal","BuildResult","polytree","BuildResult2","FixHoleLinkage","orfl","botY","topY","InsertLocalMinimaIntoAEL","ProcessHorizontals","ProcessIntersections","ProcessEdgesAtTopOfScanbeam","Area$1","ReversePolyPtLinks","JoinCommonEdges","FixupOutPolyline","FixupOutPolygon","DoSimplePolygons","AddJoin","Op1","Op2","AddGhostJoin","Op","SetZ","lb","rb","InsertEdgeIntoAEL","SetWindingCount","IsContributing","AddOutPt","AddLocalMinPoly","AddEdgeToSEL","HorzSegmentsOverlap","IntersectEdges","startEdge","E2InsertsBeforeE1","TopX","IsEvenOddFillType","IsEvenOddAltFillType","pft","pft2","Inside","PopEdgeFromSEL","oldE","CopyAELToSEL","SwapPositionsInSEL","AddLocalMaxPoly","AppendPolygon","prevE","xPrev","xE","newOp","SetHoleState","ToFront","GetLastOutPt","SwapPoints","Value","seg1a","seg1b","seg2a","seg2b","eTmp","GetDx","FirstIsBottomPt","btmPt1","btmPt2","dx1p","dx1n","dx2p","dx2n","Area","GetBottomPt","dups","GetLowermostRec","outRec1","outRec2","bPt1","bPt2","OutRec1RightOfOutRec2","GetOutRec","outrec","holeStateRec","p1_lft","p1_rt","p2_lft","p2_rt","OKIdx","ObsoleteIdx","pp1","SwapSides","side","SwapPolyIndexes","outIdx","e1Contributing","e2Contributing","oldE1WindCnt","e1FillType","e2FillType","e1FillType2","e2FillType2","e1Wc","e2Wc","e1Wc2","e2Wc2","DeleteFromSEL","SelPrev","SelNext","horzEdge","ProcessHorizontal","GetHorzDirection","HorzEdge","$var","Left","Right","Dir","dir","horzLeft","horzRight","eLastHorz","eMaxPair","GetMaximaPair","currMax","op1","IsLastHorz","GetNextInAEL","eNextHorz","op2","IsMinima","IsMaxima","IsIntermediate","GetMaximaPairEx","BuildIntersectList","FixupIntersectionOrder","ProcessIntersectList","$$e2","isModified","IntersectPoint","newNode","EdgesAdjacent","inode","IntersectNodeSort","iNode","currentY","ip","b1","IsMaximaEdge","DoMaxima","ePrev2","ReversePaths","polys","poly","PointCount","polyg","pn","lastPP","tmpPP","lastOK","preserveCol","DupOutPt","InsertAfter","GetOverlap","a1","$val","JoinHorz","op1b","op2b","DiscardLeft","Dir1","Dir2","JoinPoints","isHorizontal","reverse1","DiscardLeftSide","Reverse1","Reverse2","GetBounds","paths","GetBounds2","ops","opStart","PointInPolygon","ipNext","startOp","ptx","pty","poly0x","poly0y","poly1x","poly1y","Poly2ContainsPoly1","outPt1","outPt2","FixupFirstLefts1","OldOutRec","NewOutRec","firstLeft","ParseFirstLeft","FixupFirstLefts2","innerOutRec","outerOutRec","FixupFirstLefts3","UpdateOutPtIdxs","op3","op4","outrec2","isArray","opFirst","SimplifyPolygon","fillType","SimplifyPolygons","DistanceSqrd","DistanceFromLineSqrd","ln1","ln2","A","B","C","SlopesNearCollinear","distSqrd","PointsAreClose","ExcludeOp","CleanPolygon","outPts","CleanPolygons","Minkowski","IsSum","IsClosed","polyCnt","pathCnt","quads","quad","MinkowskiSum","path_or_paths","pathIsClosed","TranslatePath","outPath","MinkowskiDiff","poly1","poly2","PolyTreeToPaths","AddPolyNodeToPaths","NodeType","ntAny","polynode","nt","match","ntOpen","ntClosed","$i3","$t3","$l3","OpenPathsFromPolyTree","ClosedPathsFromPolyTree","ClipperOffset","miterLimit","arcTolerance","def_arc_tolerance","m_destPolys","m_srcPoly","m_destPoly","m_normals","m_delta","m_sinA","m_sin","m_cos","m_miterLim","m_StepsPerRad","m_lowest","m_polyNodes","MiterLimit","ArcTolerance","two_pi","joinType","endType","FixOrientations","GetUnitNormal","DoOffset","steps","OffsetPoint","DoSquare","DoRound","X2","clpr","outer","jointype","DoMiter","round","err","alert","JS","AreaOfPolygon","AreaOfPolygons","BoundsOfPath","BoundsOfPaths","Clean","isPolygons","Clone","k_length","results","plen","Lighten","P","rem","addlast","bxax","byay","toleranceSq","PerimeterOfPath","perimeter","p1x","p2x","PerimeterOfPaths","ExPolygons","ExPolygon","AddOuterPolyNodeToExPolygons","expolygons","childs2","childs","ExPolygonsToPaths","PolyTreeToExPolygons","needsClose","total","areas","allPoints","allPointsMap","skipZeroAreas","perimeterMem","cset","ptlist","g","all","vids","stringify","toPolygonMesh","toExtrudedMesh","direction","subVectors","denominator","multiplyScalar","DefaultTessParams","numIterations","minSegLenFraction","num_iterations","min_seg_len_fraction","adjustMaxdim","maxdim","segLength","time","TesselateCubic","px1","py1","px2","py2","px3","py3","px4","py4","isFont","aproximateLength","minSegLen","dt","dt3","pre1","pre2","pre3","pre4","temp1x","temp1y","temp2x","temp2y","fx","fy","dfx","dfy","ddfx","ddfy","dddfx","dddfy","tMax","TesselateQuad","dt2","getCubeBezierPoint","optionalTarget","bp1","bp2","bp3","bp4","_v2","_tmpArc","getTmpArc","segTypes","segData","hasCurves","arcBox","computeBBox","union","forceCloseContours","ret","dataOffset","lastX","lastY","contourStartX","contourStartY","tesselate","applyTransform","loader","clipPathIn","subPath","subPaths","segIndex","clips","toClipperPath","subPreResult","myPath","cpr","strokeClipperContour","strokeClipperSolution","strokeFlattedPath","flatted","st","tmpx","tmpy","isPrevMoveTo","vpId","lastIndex","startIndex","lastx","lasty","isAABB","seg","dxA","dyA","dxC","dyC","lenA","lenC","dxB","dyB","dxD","dyD","lenB","lenD","isAABBContain","clipBox","pathBox","containsBox","bboxOverlap","preResult","needSwapSubject","isFillable","getPolygonFromClipperSolution","appliedTransform","cached","clipProcess","needApplytransform","vertices1","addPolyTriangle","fillPolygon","hasIntersection","box1","box2","strokeOnly","clipBound","subjBound","transformBox","temp","Earcut","Function","ComputeOutCode","code","outcode0","outcode1","accept","outcodeOut","minx1","miny1","maxx1","maxy1","minx2","miny2","maxx2","maxy2","constructor","neighbors_","interior_","p2s","GetPoint","getPoints","containsPoint","containsEdge","containsPoints","interior","markNeighborPointers","cw","opoint","npoint","markConstrainedEdgeByEdge"],"mappings":"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","file":"CompGeom/CompGeom.min.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 550);\n","import { TOL } from \"./fuzzy-math\";\r\nimport { xPlaneSegment } from \"./x-plane-segment\";\r\n\r\nconst avp = Autodesk.Viewing.Private;\r\nconst logger = avp.logger;\r\n\r\nfunction Edge(pt1, pt2, id1From, id1To, id2From, id2To, meshId) {\r\n\r\n    this.v1 = pt1.clone();\r\n    this.v2 = pt2.clone();\r\n\r\n}\r\n\r\n\r\n\r\nlet res1 = new THREE.Vector3();\r\nlet res2 = new THREE.Vector3();\r\n\r\n// res is array containing result segments.\r\n// returns number of intersection point on the plane (0, 1, or 2) with the values of the points stored in the res array\r\nexport function xTrianglePlane(plane, pt0, pt1, pt2, i0, i1, i2, res, meshId) {\r\n\r\n    let d0 = plane.distanceToPoint(pt0);\r\n    let d1 = plane.distanceToPoint(pt1);\r\n    let d2 = plane.distanceToPoint(pt2);\r\n\r\n    // Check if all points are to one side of the plane\r\n    if (d0 < -TOL && d1 < -TOL && d2 < -TOL) {\r\n        return null;\r\n    }\r\n    if (d0 > TOL && d1 > TOL && d2 > TOL) {\r\n        return null;\r\n    }\r\n\r\n    let s0 = Math.sign(d0);\r\n    let s1 = Math.sign(d1);\r\n    let s2 = Math.sign(d2);\r\n\r\n    // Skip coplanar triangles (leave it to the neighbouring triangles to contribute their edges)\r\n    if (s0 === 0 && s1 === 0 && s2 === 0) {\r\n        return null;\r\n    }\r\n\r\n    let tmp1, tmp2;\r\n    let i1From, i1To, i2From, i2To;\r\n\r\n    //There is intersection, compute it\r\n    if (s0 !== s1) {\r\n        let numInts = xPlaneSegment(plane, pt0, pt1, res1, res2);\r\n        if (numInts === 2) {\r\n            res.push(new Edge(pt0, pt1, i0, i0, i1, i1, meshId));\r\n            return;\r\n        } else if (numInts === 1) {\r\n            i1From = i0;\r\n            i1To = i1;\r\n            tmp1 = res1.clone();\r\n        } else {\r\n            logger.warn(\"Unexpected zero intersections where at least one was expected\");\r\n        }\r\n    }\r\n\r\n    if (s1 !== s2) {\r\n        let numInts = xPlaneSegment(plane, pt1, pt2, res1, res2);\r\n        if (numInts === 2) {\r\n            res.push(new Edge(pt1, pt2, i1, i1, i2, i2, meshId));\r\n            return;\r\n        } else if (numInts === 1) {\r\n            if (tmp1) {\r\n                // Avoid the singular scenario where the signs are 0, -1 and +1\r\n                if (res1.distanceTo(tmp1) > TOL) {\r\n                    i2From = i1;\r\n                    i2To = i2;\r\n                    tmp2 = res1.clone();\r\n                }\r\n            }\r\n            else {\r\n                i1From = i1;\r\n                i1To = i2;\r\n                tmp1 = res1.clone();\r\n            }\r\n        } else {\r\n            logger.warn(\"Unexpected zero intersections where at least one was expected\");\r\n        }\r\n    }\r\n\r\n    if (s2 !== s0) {\r\n        let numInts = xPlaneSegment(plane, pt2, pt0, res1, res2);\r\n        if (numInts === 2) {\r\n            res.push(new Edge(pt2, pt0, i2, i2, i0, i0, meshId));\r\n            return;\r\n        } else if (numInts === 1) {\r\n            if (tmp1) {\r\n                // Avoid the singular scenario where the signs are 0, -1 and +1\r\n                if (res1.distanceTo(tmp1) > TOL) {\r\n                    i2From = i2;\r\n                    i2To = i0;\r\n                    tmp2 = res1.clone();\r\n                }\r\n            } else {\r\n                logger.warn(\"Unexpected single intersection point\");\r\n            }\r\n        } else {\r\n            logger.warn(\"Unexpected zero intersections where at least one was expected\");\r\n        }\r\n    }\r\n\r\n\r\n    if (tmp1 && tmp2) {\r\n        res.push(new Edge(tmp1, tmp2, i1From, i1To, i2From, i2To, meshId));\r\n    } else {\r\n        //logger.warn(\"Unexpected one intersection where two were expected\");\r\n    }\r\n\r\n}\r\n","/*\n * Poly2Tri Copyright (c) 2009-2014, Poly2Tri Contributors\n * http://code.google.com/p/poly2tri/\n * \n * poly2tri.js (JavaScript port) (c) 2009-2014, Poly2Tri Contributors\n * https://github.com/r3mi/poly2tri.js\n * \n * All rights reserved.\n * \n * Distributed under the 3-clause BSD License, see LICENSE.txt\n */\n\n\"use strict\";\n\n\n/*\n * Note\n * ====\n * the structure of this JavaScript version of poly2tri intentionally follows\n * as closely as possible the structure of the reference C++ version, to make it \n * easier to keep the 2 versions in sync.\n */\n\nvar xy = require('./xy');\n\n// ------------------------------------------------------------------------Point\n/**\n * Construct a point\n * @example\n *      var point = new poly2tri.Point(150, 150);\n * @public\n * @constructor\n * @struct\n * @param {number=} x    coordinate (0 if undefined)\n * @param {number=} y    coordinate (0 if undefined)\n */\nvar Point = function(x, y) {\n    /**\n     * @type {number}\n     * @expose\n     */\n    this.x = +x || 0;\n    /**\n     * @type {number}\n     * @expose\n     */\n    this.y = +y || 0;\n\n    // All extra fields added to Point are prefixed with _p2t_\n    // to avoid collisions if custom Point class is used.\n\n    /**\n     * The edges this point constitutes an upper ending point\n     * @private\n     * @type {Array.<Edge>}\n     */\n    this._p2t_edge_list = null;\n};\n\n/**\n * For pretty printing\n * @example\n *      \"p=\" + new poly2tri.Point(5,42)\n *      //  \"p=(5;42)\"\n * @returns {string} <code>\"(x;y)\"</code>\n */\nPoint.prototype.toString = function() {\n    return xy.toStringBase(this);\n};\n\n/**\n * JSON output, only coordinates\n * @example\n *      JSON.stringify(new poly2tri.Point(1,2))\n *      //  '{\"x\":1,\"y\":2}'\n */\nPoint.prototype.toJSON = function() {\n    return { x: this.x, y: this.y };\n};\n\n/**\n * Creates a copy of this Point object.\n * @return {Point} new cloned point\n */\nPoint.prototype.clone = function() {\n    return new Point(this.x, this.y);\n};\n\n/**\n * Set this Point instance to the origo. <code>(0; 0)</code>\n * @return {Point} this (for chaining)\n */\nPoint.prototype.set_zero = function() {\n    this.x = 0.0;\n    this.y = 0.0;\n    return this; // for chaining\n};\n\n/**\n * Set the coordinates of this instance.\n * @param {number} x   coordinate\n * @param {number} y   coordinate\n * @return {Point} this (for chaining)\n */\nPoint.prototype.set = function(x, y) {\n    this.x = +x || 0;\n    this.y = +y || 0;\n    return this; // for chaining\n};\n\n/**\n * Negate this Point instance. (component-wise)\n * @return {Point} this (for chaining)\n */\nPoint.prototype.negate = function() {\n    this.x = -this.x;\n    this.y = -this.y;\n    return this; // for chaining\n};\n\n/**\n * Add another Point object to this instance. (component-wise)\n * @param {!Point} n - Point object.\n * @return {Point} this (for chaining)\n */\nPoint.prototype.add = function(n) {\n    this.x += n.x;\n    this.y += n.y;\n    return this; // for chaining\n};\n\n/**\n * Subtract this Point instance with another point given. (component-wise)\n * @param {!Point} n - Point object.\n * @return {Point} this (for chaining)\n */\nPoint.prototype.sub = function(n) {\n    this.x -= n.x;\n    this.y -= n.y;\n    return this; // for chaining\n};\n\n/**\n * Multiply this Point instance by a scalar. (component-wise)\n * @param {number} s   scalar.\n * @return {Point} this (for chaining)\n */\nPoint.prototype.mul = function(s) {\n    this.x *= s;\n    this.y *= s;\n    return this; // for chaining\n};\n\n/**\n * Return the distance of this Point instance from the origo.\n * @return {number} distance\n */\nPoint.prototype.length = function() {\n    return Math.sqrt(this.x * this.x + this.y * this.y);\n};\n\n/**\n * Normalize this Point instance (as a vector).\n * @return {number} The original distance of this instance from the origo.\n */\nPoint.prototype.normalize = function() {\n    var len = this.length();\n    this.x /= len;\n    this.y /= len;\n    return len;\n};\n\n/**\n * Test this Point object with another for equality.\n * @param {!XY} p - any \"Point like\" object with {x,y}\n * @return {boolean} <code>true</code> if same x and y coordinates, <code>false</code> otherwise.\n */\nPoint.prototype.equals = function(p) {\n    return this.x === p.x && this.y === p.y;\n};\n\n\n// -----------------------------------------------------Point (\"static\" methods)\n\n/**\n * Negate a point component-wise and return the result as a new Point object.\n * @param {!XY} p - any \"Point like\" object with {x,y}\n * @return {Point} the resulting Point object.\n */\nPoint.negate = function(p) {\n    return new Point(-p.x, -p.y);\n};\n\n/**\n * Add two points component-wise and return the result as a new Point object.\n * @param {!XY} a - any \"Point like\" object with {x,y}\n * @param {!XY} b - any \"Point like\" object with {x,y}\n * @return {Point} the resulting Point object.\n */\nPoint.add = function(a, b) {\n    return new Point(a.x + b.x, a.y + b.y);\n};\n\n/**\n * Subtract two points component-wise and return the result as a new Point object.\n * @param {!XY} a - any \"Point like\" object with {x,y}\n * @param {!XY} b - any \"Point like\" object with {x,y}\n * @return {Point} the resulting Point object.\n */\nPoint.sub = function(a, b) {\n    return new Point(a.x - b.x, a.y - b.y);\n};\n\n/**\n * Multiply a point by a scalar and return the result as a new Point object.\n * @param {number} s - the scalar\n * @param {!XY} p - any \"Point like\" object with {x,y}\n * @return {Point} the resulting Point object.\n */\nPoint.mul = function(s, p) {\n    return new Point(s * p.x, s * p.y);\n};\n\n/**\n * Perform the cross product on either two points (this produces a scalar)\n * or a point and a scalar (this produces a point).\n * This function requires two parameters, either may be a Point object or a\n * number.\n * @param  {XY|number} a - Point object or scalar.\n * @param  {XY|number} b - Point object or scalar.\n * @return {Point|number} a Point object or a number, depending on the parameters.\n */\nPoint.cross = function(a, b) {\n    if (typeof(a) === 'number') {\n        if (typeof(b) === 'number') {\n            return a * b;\n        } else {\n            return new Point(-a * b.y, a * b.x);\n        }\n    } else {\n        if (typeof(b) === 'number') {\n            return new Point(b * a.y, -b * a.x);\n        } else {\n            return a.x * b.y - a.y * b.x;\n        }\n    }\n};\n\n\n// -----------------------------------------------------------------\"Point-Like\"\n/*\n * The following functions operate on \"Point\" or any \"Point like\" object \n * with {x,y} (duck typing).\n */\n\nPoint.toString = xy.toString;\nPoint.compare = xy.compare;\nPoint.cmp = xy.compare; // backward compatibility\nPoint.equals = xy.equals;\n\n/**\n * Peform the dot product on two vectors.\n * @public\n * @param {!XY} a - any \"Point like\" object with {x,y}\n * @param {!XY} b - any \"Point like\" object with {x,y}\n * @return {number} The dot product\n */\nPoint.dot = function(a, b) {\n    return a.x * b.x + a.y * b.y;\n};\n\n\n// ---------------------------------------------------------Exports (public API)\n\nmodule.exports = Point;\n","/*\n * Poly2Tri Copyright (c) 2009-2014, Poly2Tri Contributors\n * http://code.google.com/p/poly2tri/\n * \n * poly2tri.js (JavaScript port) (c) 2009-2014, Poly2Tri Contributors\n * https://github.com/r3mi/poly2tri.js\n * \n * All rights reserved.\n * \n * Distributed under the 3-clause BSD License, see LICENSE.txt\n */\n\n/* jshint latedef:nofunc, maxcomplexity:9 */\n\n\"use strict\";\n\n/**\n * This 'Sweep' module is present in order to keep this JavaScript version\n * as close as possible to the reference C++ version, even though almost all\n * functions could be declared as methods on the {@linkcode module:sweepcontext~SweepContext} object.\n * @module\n * @private\n */\n\n/*\n * Note\n * ====\n * the structure of this JavaScript version of poly2tri intentionally follows\n * as closely as possible the structure of the reference C++ version, to make it \n * easier to keep the 2 versions in sync.\n */\n\nvar assert = require('./assert');\nvar PointError = require('./pointerror');\nvar Triangle = require('./triangle');\nvar Node = require('./advancingfront').Node;\n\n\n// ------------------------------------------------------------------------utils\n\nvar utils = require('./utils');\n\n/** @const */\nvar EPSILON = utils.EPSILON;\n\n/** @const */\nvar Orientation = utils.Orientation;\n/** @const */\nvar orient2d = utils.orient2d;\n/** @const */\nvar inScanArea = utils.inScanArea;\n/** @const */\nvar isAngleObtuse = utils.isAngleObtuse;\n\n\n// ------------------------------------------------------------------------Sweep\n\n/**\n * Triangulate the polygon with holes and Steiner points.\n * Do this AFTER you've added the polyline, holes, and Steiner points\n * @private\n * @param {!SweepContext} tcx - SweepContext object\n */\nfunction triangulate(tcx) {\n    tcx.initTriangulation();\n    tcx.createAdvancingFront();\n    // Sweep points; build mesh\n    sweepPoints(tcx);\n    // Clean up\n    finalizationPolygon(tcx);\n}\n\n/**\n * Start sweeping the Y-sorted point set from bottom to top\n * @param {!SweepContext} tcx - SweepContext object\n */\nfunction sweepPoints(tcx) {\n    var i, len = tcx.pointCount();\n    for (i = 1; i < len; ++i) {\n        var point = tcx.getPoint(i);\n        var node = pointEvent(tcx, point);\n        var edges = point._p2t_edge_list;\n        for (var j = 0; edges && j < edges.length; ++j) {\n            edgeEventByEdge(tcx, edges[j], node);\n        }\n    }\n}\n\n/**\n * @param {!SweepContext} tcx - SweepContext object\n */\nfunction finalizationPolygon(tcx) {\n    // Get an Internal triangle to start with\n    var t = tcx.front().head().next.triangle;\n    var p = tcx.front().head().next.point;\n    while (!t.getConstrainedEdgeCW(p)) {\n        t = t.neighborCCW(p);\n    }\n\n    // Collect interior triangles constrained by edges\n    tcx.meshClean(t);\n}\n\n/**\n * Find closes node to the left of the new point and\n * create a new triangle. If needed new holes and basins\n * will be filled to.\n * @param {!SweepContext} tcx - SweepContext object\n * @param {!XY} point   Point\n */\nfunction pointEvent(tcx, point) {\n    var node = tcx.locateNode(point);\n    var new_node = newFrontTriangle(tcx, point, node);\n\n    // Only need to check +epsilon since point never have smaller\n    // x value than node due to how we fetch nodes from the front\n    if (point.x <= node.point.x + (EPSILON)) {\n        fill(tcx, node);\n    }\n\n    //tcx.AddNode(new_node);\n\n    fillAdvancingFront(tcx, new_node);\n    return new_node;\n}\n\nfunction edgeEventByEdge(tcx, edge, node) {\n    tcx.edge_event.constrained_edge = edge;\n    tcx.edge_event.right = (edge.p.x > edge.q.x);\n\n    if (isEdgeSideOfTriangle(node.triangle, edge.p, edge.q)) {\n        return;\n    }\n\n    // For now we will do all needed filling\n    // TODO: integrate with flip process might give some better performance\n    //       but for now this avoid the issue with cases that needs both flips and fills\n    fillEdgeEvent(tcx, edge, node);\n    edgeEventByPoints(tcx, edge.p, edge.q, node.triangle, edge.q);\n}\n\nfunction edgeEventByPoints(tcx, ep, eq, triangle, point) {\n    if (isEdgeSideOfTriangle(triangle, ep, eq)) {\n        return;\n    }\n\n    var p1 = triangle.pointCCW(point);\n    var o1 = orient2d(eq, p1, ep);\n    if (o1 === Orientation.COLLINEAR) {\n        // TODO integrate here changes from C++ version\n        // (C++ repo revision 09880a869095 dated March 8, 2011)\n        throw new PointError('poly2tri EdgeEvent: Collinear not supported!', [eq, p1, ep]);\n    }\n\n    var p2 = triangle.pointCW(point);\n    var o2 = orient2d(eq, p2, ep);\n    if (o2 === Orientation.COLLINEAR) {\n        // TODO integrate here changes from C++ version\n        // (C++ repo revision 09880a869095 dated March 8, 2011)\n        throw new PointError('poly2tri EdgeEvent: Collinear not supported!', [eq, p2, ep]);\n    }\n\n    if (o1 === o2) {\n        // Need to decide if we are rotating CW or CCW to get to a triangle\n        // that will cross edge\n        if (o1 === Orientation.CW) {\n            triangle = triangle.neighborCCW(point);\n        } else {\n            triangle = triangle.neighborCW(point);\n        }\n        edgeEventByPoints(tcx, ep, eq, triangle, point);\n    } else {\n        // This triangle crosses constraint so lets flippin start!\n        flipEdgeEvent(tcx, ep, eq, triangle, point);\n    }\n}\n\nfunction isEdgeSideOfTriangle(triangle, ep, eq) {\n    var index = triangle.edgeIndex(ep, eq);\n    if (index !== -1) {\n        triangle.markConstrainedEdgeByIndex(index);\n        var t = triangle.getNeighbor(index);\n        if (t) {\n            t.markConstrainedEdgeByPoints(ep, eq);\n        }\n        return true;\n    }\n    return false;\n}\n\n/**\n * Creates a new front triangle and legalize it\n * @param {!SweepContext} tcx - SweepContext object\n */\nfunction newFrontTriangle(tcx, point, node) {\n    var triangle = new Triangle(point, node.point, node.next.point);\n\n    triangle.markNeighbor(node.triangle);\n    tcx.addToMap(triangle);\n\n    var new_node = new Node(point);\n    new_node.next = node.next;\n    new_node.prev = node;\n    node.next.prev = new_node;\n    node.next = new_node;\n\n    if (!legalize(tcx, triangle)) {\n        tcx.mapTriangleToNodes(triangle);\n    }\n\n    return new_node;\n}\n\n/**\n * Adds a triangle to the advancing front to fill a hole.\n * @param {!SweepContext} tcx - SweepContext object\n * @param node - middle node, that is the bottom of the hole\n */\nfunction fill(tcx, node) {\n    var triangle = new Triangle(node.prev.point, node.point, node.next.point);\n\n    // TODO: should copy the constrained_edge value from neighbor triangles\n    //       for now constrained_edge values are copied during the legalize\n    triangle.markNeighbor(node.prev.triangle);\n    triangle.markNeighbor(node.triangle);\n\n    tcx.addToMap(triangle);\n\n    // Update the advancing front\n    node.prev.next = node.next;\n    node.next.prev = node.prev;\n\n\n    // If it was legalized the triangle has already been mapped\n    if (!legalize(tcx, triangle)) {\n        tcx.mapTriangleToNodes(triangle);\n    }\n\n    //tcx.removeNode(node);\n}\n\n/**\n * Fills holes in the Advancing Front\n * @param {!SweepContext} tcx - SweepContext object\n */\nfunction fillAdvancingFront(tcx, n) {\n    // Fill right holes\n    var node = n.next;\n    while (node.next) {\n        // TODO integrate here changes from C++ version\n        // (C++ repo revision acf81f1f1764 dated April 7, 2012)\n        if (isAngleObtuse(node.point, node.next.point, node.prev.point)) {\n            break;\n        }\n        fill(tcx, node);\n        node = node.next;\n    }\n\n    // Fill left holes\n    node = n.prev;\n    while (node.prev) {\n        // TODO integrate here changes from C++ version\n        // (C++ repo revision acf81f1f1764 dated April 7, 2012)\n        if (isAngleObtuse(node.point, node.next.point, node.prev.point)) {\n            break;\n        }\n        fill(tcx, node);\n        node = node.prev;\n    }\n\n    // Fill right basins\n    if (n.next && n.next.next) {\n        if (isBasinAngleRight(n)) {\n            fillBasin(tcx, n);\n        }\n    }\n}\n\n/**\n * The basin angle is decided against the horizontal line [1,0].\n * @param {Node} node\n * @return {boolean} true if angle < 3*/4\n */\nfunction isBasinAngleRight(node) {\n    var ax = node.point.x - node.next.next.point.x;\n    var ay = node.point.y - node.next.next.point.y;\n    assert(ay >= 0, \"unordered y\");\n    return (ax >= 0 || Math.abs(ax) < ay);\n}\n\n/**\n * Returns true if triangle was legalized\n * @param {!SweepContext} tcx - SweepContext object\n * @return {boolean}\n */\nfunction legalize(tcx, t) {\n    // To legalize a triangle we start by finding if any of the three edges\n    // violate the Delaunay condition\n    for (var i = 0; i < 3; ++i) {\n        if (t.delaunay_edge[i]) {\n            continue;\n        }\n        var ot = t.getNeighbor(i);\n        if (ot) {\n            var p = t.getPoint(i);\n            var op = ot.oppositePoint(t, p);\n            var oi = ot.index(op);\n\n            // If this is a Constrained Edge or a Delaunay Edge(only during recursive legalization)\n            // then we should not try to legalize\n            if (ot.constrained_edge[oi] || ot.delaunay_edge[oi]) {\n                t.constrained_edge[i] = ot.constrained_edge[oi];\n                continue;\n            }\n\n            var inside = inCircle(p, t.pointCCW(p), t.pointCW(p), op);\n            if (inside) {\n                // Lets mark this shared edge as Delaunay\n                t.delaunay_edge[i] = true;\n                ot.delaunay_edge[oi] = true;\n\n                // Lets rotate shared edge one vertex CW to legalize it\n                rotateTrianglePair(t, p, ot, op);\n\n                // We now got one valid Delaunay Edge shared by two triangles\n                // This gives us 4 new edges to check for Delaunay\n\n                // Make sure that triangle to node mapping is done only one time for a specific triangle\n                var not_legalized = !legalize(tcx, t);\n                if (not_legalized) {\n                    tcx.mapTriangleToNodes(t);\n                }\n\n                not_legalized = !legalize(tcx, ot);\n                if (not_legalized) {\n                    tcx.mapTriangleToNodes(ot);\n                }\n                // Reset the Delaunay edges, since they only are valid Delaunay edges\n                // until we add a new triangle or point.\n                // XXX: need to think about this. Can these edges be tried after we\n                //      return to previous recursive level?\n                t.delaunay_edge[i] = false;\n                ot.delaunay_edge[oi] = false;\n\n                // If triangle have been legalized no need to check the other edges since\n                // the recursive legalization will handles those so we can end here.\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\n/**\n * <b>Requirement</b>:<br>\n * 1. a,b and c form a triangle.<br>\n * 2. a and d is know to be on opposite side of bc<br>\n * <pre>\n *                a\n *                +\n *               / \\\n *              /   \\\n *            b/     \\c\n *            +-------+\n *           /    d    \\\n *          /           \\\n * </pre>\n * <b>Fact</b>: d has to be in area B to have a chance to be inside the circle formed by\n *  a,b and c<br>\n *  d is outside B if orient2d(a,b,d) or orient2d(c,a,d) is CW<br>\n *  This preknowledge gives us a way to optimize the incircle test\n * @param pa - triangle point, opposite d\n * @param pb - triangle point\n * @param pc - triangle point\n * @param pd - point opposite a\n * @return {boolean} true if d is inside circle, false if on circle edge\n */\nfunction inCircle(pa, pb, pc, pd) {\n    var adx = pa.x - pd.x;\n    var ady = pa.y - pd.y;\n    var bdx = pb.x - pd.x;\n    var bdy = pb.y - pd.y;\n\n    var adxbdy = adx * bdy;\n    var bdxady = bdx * ady;\n    var oabd = adxbdy - bdxady;\n    if (oabd <= 0) {\n        return false;\n    }\n\n    var cdx = pc.x - pd.x;\n    var cdy = pc.y - pd.y;\n\n    var cdxady = cdx * ady;\n    var adxcdy = adx * cdy;\n    var ocad = cdxady - adxcdy;\n    if (ocad <= 0) {\n        return false;\n    }\n\n    var bdxcdy = bdx * cdy;\n    var cdxbdy = cdx * bdy;\n\n    var alift = adx * adx + ady * ady;\n    var blift = bdx * bdx + bdy * bdy;\n    var clift = cdx * cdx + cdy * cdy;\n\n    var det = alift * (bdxcdy - cdxbdy) + blift * ocad + clift * oabd;\n    return det > 0;\n}\n\n/**\n * Rotates a triangle pair one vertex CW\n *<pre>\n *       n2                    n2\n *  P +-----+             P +-----+\n *    | t  /|               |\\  t |\n *    |   / |               | \\   |\n *  n1|  /  |n3           n1|  \\  |n3\n *    | /   |    after CW   |   \\ |\n *    |/ oT |               | oT \\|\n *    +-----+ oP            +-----+\n *       n4                    n4\n * </pre>\n */\nfunction rotateTrianglePair(t, p, ot, op) {\n    var n1, n2, n3, n4;\n    n1 = t.neighborCCW(p);\n    n2 = t.neighborCW(p);\n    n3 = ot.neighborCCW(op);\n    n4 = ot.neighborCW(op);\n\n    var ce1, ce2, ce3, ce4;\n    ce1 = t.getConstrainedEdgeCCW(p);\n    ce2 = t.getConstrainedEdgeCW(p);\n    ce3 = ot.getConstrainedEdgeCCW(op);\n    ce4 = ot.getConstrainedEdgeCW(op);\n\n    var de1, de2, de3, de4;\n    de1 = t.getDelaunayEdgeCCW(p);\n    de2 = t.getDelaunayEdgeCW(p);\n    de3 = ot.getDelaunayEdgeCCW(op);\n    de4 = ot.getDelaunayEdgeCW(op);\n\n    t.legalize(p, op);\n    ot.legalize(op, p);\n\n    // Remap delaunay_edge\n    ot.setDelaunayEdgeCCW(p, de1);\n    t.setDelaunayEdgeCW(p, de2);\n    t.setDelaunayEdgeCCW(op, de3);\n    ot.setDelaunayEdgeCW(op, de4);\n\n    // Remap constrained_edge\n    ot.setConstrainedEdgeCCW(p, ce1);\n    t.setConstrainedEdgeCW(p, ce2);\n    t.setConstrainedEdgeCCW(op, ce3);\n    ot.setConstrainedEdgeCW(op, ce4);\n\n    // Remap neighbors\n    // XXX: might optimize the markNeighbor by keeping track of\n    //      what side should be assigned to what neighbor after the\n    //      rotation. Now mark neighbor does lots of testing to find\n    //      the right side.\n    t.clearNeighbors();\n    ot.clearNeighbors();\n    if (n1) {\n        ot.markNeighbor(n1);\n    }\n    if (n2) {\n        t.markNeighbor(n2);\n    }\n    if (n3) {\n        t.markNeighbor(n3);\n    }\n    if (n4) {\n        ot.markNeighbor(n4);\n    }\n    t.markNeighbor(ot);\n}\n\n/**\n * Fills a basin that has formed on the Advancing Front to the right\n * of given node.<br>\n * First we decide a left,bottom and right node that forms the\n * boundaries of the basin. Then we do a reqursive fill.\n *\n * @param {!SweepContext} tcx - SweepContext object\n * @param node - starting node, this or next node will be left node\n */\nfunction fillBasin(tcx, node) {\n    if (orient2d(node.point, node.next.point, node.next.next.point) === Orientation.CCW) {\n        tcx.basin.left_node = node.next.next;\n    } else {\n        tcx.basin.left_node = node.next;\n    }\n\n    // Find the bottom and right node\n    tcx.basin.bottom_node = tcx.basin.left_node;\n    while (tcx.basin.bottom_node.next && tcx.basin.bottom_node.point.y >= tcx.basin.bottom_node.next.point.y) {\n        tcx.basin.bottom_node = tcx.basin.bottom_node.next;\n    }\n    if (tcx.basin.bottom_node === tcx.basin.left_node) {\n        // No valid basin\n        return;\n    }\n\n    tcx.basin.right_node = tcx.basin.bottom_node;\n    while (tcx.basin.right_node.next && tcx.basin.right_node.point.y < tcx.basin.right_node.next.point.y) {\n        tcx.basin.right_node = tcx.basin.right_node.next;\n    }\n    if (tcx.basin.right_node === tcx.basin.bottom_node) {\n        // No valid basins\n        return;\n    }\n\n    tcx.basin.width = tcx.basin.right_node.point.x - tcx.basin.left_node.point.x;\n    tcx.basin.left_highest = tcx.basin.left_node.point.y > tcx.basin.right_node.point.y;\n\n    fillBasinReq(tcx, tcx.basin.bottom_node);\n}\n\n/**\n * Recursive algorithm to fill a Basin with triangles\n *\n * @param {!SweepContext} tcx - SweepContext object\n * @param node - bottom_node\n */\nfunction fillBasinReq(tcx, node) {\n    // if shallow stop filling\n    if (isShallow(tcx, node)) {\n        return;\n    }\n\n    fill(tcx, node);\n\n    var o;\n    if (node.prev === tcx.basin.left_node && node.next === tcx.basin.right_node) {\n        return;\n    } else if (node.prev === tcx.basin.left_node) {\n        o = orient2d(node.point, node.next.point, node.next.next.point);\n        if (o === Orientation.CW) {\n            return;\n        }\n        node = node.next;\n    } else if (node.next === tcx.basin.right_node) {\n        o = orient2d(node.point, node.prev.point, node.prev.prev.point);\n        if (o === Orientation.CCW) {\n            return;\n        }\n        node = node.prev;\n    } else {\n        // Continue with the neighbor node with lowest Y value\n        if (node.prev.point.y < node.next.point.y) {\n            node = node.prev;\n        } else {\n            node = node.next;\n        }\n    }\n\n    fillBasinReq(tcx, node);\n}\n\nfunction isShallow(tcx, node) {\n    var height;\n    if (tcx.basin.left_highest) {\n        height = tcx.basin.left_node.point.y - node.point.y;\n    } else {\n        height = tcx.basin.right_node.point.y - node.point.y;\n    }\n\n    // if shallow stop filling\n    if (tcx.basin.width > height) {\n        return true;\n    }\n    return false;\n}\n\nfunction fillEdgeEvent(tcx, edge, node) {\n    if (tcx.edge_event.right) {\n        fillRightAboveEdgeEvent(tcx, edge, node);\n    } else {\n        fillLeftAboveEdgeEvent(tcx, edge, node);\n    }\n}\n\nfunction fillRightAboveEdgeEvent(tcx, edge, node) {\n    while (node.next.point.x < edge.p.x) {\n        // Check if next node is below the edge\n        if (orient2d(edge.q, node.next.point, edge.p) === Orientation.CCW) {\n            fillRightBelowEdgeEvent(tcx, edge, node);\n        } else {\n            node = node.next;\n        }\n    }\n}\n\nfunction fillRightBelowEdgeEvent(tcx, edge, node) {\n    if (node.point.x < edge.p.x) {\n        if (orient2d(node.point, node.next.point, node.next.next.point) === Orientation.CCW) {\n            // Concave\n            fillRightConcaveEdgeEvent(tcx, edge, node);\n        } else {\n            // Convex\n            fillRightConvexEdgeEvent(tcx, edge, node);\n            // Retry this one\n            fillRightBelowEdgeEvent(tcx, edge, node);\n        }\n    }\n}\n\nfunction fillRightConcaveEdgeEvent(tcx, edge, node) {\n    fill(tcx, node.next);\n    if (node.next.point !== edge.p) {\n        // Next above or below edge?\n        if (orient2d(edge.q, node.next.point, edge.p) === Orientation.CCW) {\n            // Below\n            if (orient2d(node.point, node.next.point, node.next.next.point) === Orientation.CCW) {\n                // Next is concave\n                fillRightConcaveEdgeEvent(tcx, edge, node);\n            } else {\n                // Next is convex\n                /* jshint noempty:false */\n            }\n        }\n    }\n}\n\nfunction fillRightConvexEdgeEvent(tcx, edge, node) {\n    // Next concave or convex?\n    if (orient2d(node.next.point, node.next.next.point, node.next.next.next.point) === Orientation.CCW) {\n        // Concave\n        fillRightConcaveEdgeEvent(tcx, edge, node.next);\n    } else {\n        // Convex\n        // Next above or below edge?\n        if (orient2d(edge.q, node.next.next.point, edge.p) === Orientation.CCW) {\n            // Below\n            fillRightConvexEdgeEvent(tcx, edge, node.next);\n        } else {\n            // Above\n            /* jshint noempty:false */\n        }\n    }\n}\n\nfunction fillLeftAboveEdgeEvent(tcx, edge, node) {\n    while (node.prev.point.x > edge.p.x) {\n        // Check if next node is below the edge\n        if (orient2d(edge.q, node.prev.point, edge.p) === Orientation.CW) {\n            fillLeftBelowEdgeEvent(tcx, edge, node);\n        } else {\n            node = node.prev;\n        }\n    }\n}\n\nfunction fillLeftBelowEdgeEvent(tcx, edge, node) {\n    if (node.point.x > edge.p.x) {\n        if (orient2d(node.point, node.prev.point, node.prev.prev.point) === Orientation.CW) {\n            // Concave\n            fillLeftConcaveEdgeEvent(tcx, edge, node);\n        } else {\n            // Convex\n            fillLeftConvexEdgeEvent(tcx, edge, node);\n            // Retry this one\n            fillLeftBelowEdgeEvent(tcx, edge, node);\n        }\n    }\n}\n\nfunction fillLeftConvexEdgeEvent(tcx, edge, node) {\n    // Next concave or convex?\n    if (orient2d(node.prev.point, node.prev.prev.point, node.prev.prev.prev.point) === Orientation.CW) {\n        // Concave\n        fillLeftConcaveEdgeEvent(tcx, edge, node.prev);\n    } else {\n        // Convex\n        // Next above or below edge?\n        if (orient2d(edge.q, node.prev.prev.point, edge.p) === Orientation.CW) {\n            // Below\n            fillLeftConvexEdgeEvent(tcx, edge, node.prev);\n        } else {\n            // Above\n            /* jshint noempty:false */\n        }\n    }\n}\n\nfunction fillLeftConcaveEdgeEvent(tcx, edge, node) {\n    fill(tcx, node.prev);\n    if (node.prev.point !== edge.p) {\n        // Next above or below edge?\n        if (orient2d(edge.q, node.prev.point, edge.p) === Orientation.CW) {\n            // Below\n            if (orient2d(node.point, node.prev.point, node.prev.prev.point) === Orientation.CW) {\n                // Next is concave\n                fillLeftConcaveEdgeEvent(tcx, edge, node);\n            } else {\n                // Next is convex\n                /* jshint noempty:false */\n            }\n        }\n    }\n}\n\nfunction flipEdgeEvent(tcx, ep, eq, t, p) {\n    var ot = t.neighborAcross(p);\n    assert(ot, \"FLIP failed due to missing triangle!\");\n\n    var op = ot.oppositePoint(t, p);\n\n    // Additional check from Java version (see issue #88)\n    if (t.getConstrainedEdgeAcross(p)) {\n        var index = t.index(p);\n        throw new PointError(\"poly2tri Intersecting Constraints\",\n                [p, op, t.getPoint((index + 1) % 3), t.getPoint((index + 2) % 3)]);\n    }\n\n    if (inScanArea(p, t.pointCCW(p), t.pointCW(p), op)) {\n        // Lets rotate shared edge one vertex CW\n        rotateTrianglePair(t, p, ot, op);\n        tcx.mapTriangleToNodes(t);\n        tcx.mapTriangleToNodes(ot);\n\n        // XXX: in the original C++ code for the next 2 lines, we are\n        // comparing point values (and not pointers). In this JavaScript\n        // code, we are comparing point references (pointers). This works\n        // because we can't have 2 different points with the same values.\n        // But to be really equivalent, we should use \"Point.equals\" here.\n        if (p === eq && op === ep) {\n            if (eq === tcx.edge_event.constrained_edge.q && ep === tcx.edge_event.constrained_edge.p) {\n                t.markConstrainedEdgeByPoints(ep, eq);\n                ot.markConstrainedEdgeByPoints(ep, eq);\n                legalize(tcx, t);\n                legalize(tcx, ot);\n            } else {\n                // XXX: I think one of the triangles should be legalized here?\n                /* jshint noempty:false */\n            }\n        } else {\n            var o = orient2d(eq, op, ep);\n            t = nextFlipTriangle(tcx, o, t, ot, p, op);\n            flipEdgeEvent(tcx, ep, eq, t, p);\n        }\n    } else {\n        var newP = nextFlipPoint(ep, eq, ot, op);\n        flipScanEdgeEvent(tcx, ep, eq, t, ot, newP);\n        edgeEventByPoints(tcx, ep, eq, t, p);\n    }\n}\n\n/**\n * After a flip we have two triangles and know that only one will still be\n * intersecting the edge. So decide which to contiune with and legalize the other\n *\n * @param {!SweepContext} tcx - SweepContext object\n * @param o - should be the result of an orient2d( eq, op, ep )\n * @param t - triangle 1\n * @param ot - triangle 2\n * @param p - a point shared by both triangles\n * @param op - another point shared by both triangles\n * @return returns the triangle still intersecting the edge\n */\nfunction nextFlipTriangle(tcx, o, t, ot, p, op) {\n    var edge_index;\n    if (o === Orientation.CCW) {\n        // ot is not crossing edge after flip\n        edge_index = ot.edgeIndex(p, op);\n        ot.delaunay_edge[edge_index] = true;\n        legalize(tcx, ot);\n        ot.clearDelaunayEdges();\n        return t;\n    }\n\n    // t is not crossing edge after flip\n    edge_index = t.edgeIndex(p, op);\n\n    t.delaunay_edge[edge_index] = true;\n    legalize(tcx, t);\n    t.clearDelaunayEdges();\n    return ot;\n}\n\n/**\n * When we need to traverse from one triangle to the next we need\n * the point in current triangle that is the opposite point to the next\n * triangle.\n */\nfunction nextFlipPoint(ep, eq, ot, op) {\n    var o2d = orient2d(eq, op, ep);\n    if (o2d === Orientation.CW) {\n        // Right\n        return ot.pointCCW(op);\n    } else if (o2d === Orientation.CCW) {\n        // Left\n        return ot.pointCW(op);\n    } else {\n        throw new PointError(\"poly2tri [Unsupported] nextFlipPoint: opposing point on constrained edge!\", [eq, op, ep]);\n    }\n}\n\n/**\n * Scan part of the FlipScan algorithm<br>\n * When a triangle pair isn't flippable we will scan for the next\n * point that is inside the flip triangle scan area. When found\n * we generate a new flipEdgeEvent\n *\n * @param {!SweepContext} tcx - SweepContext object\n * @param ep - last point on the edge we are traversing\n * @param eq - first point on the edge we are traversing\n * @param {!Triangle} flip_triangle - the current triangle sharing the point eq with edge\n * @param t\n * @param p\n */\nfunction flipScanEdgeEvent(tcx, ep, eq, flip_triangle, t, p) {\n    var ot = t.neighborAcross(p);\n    assert(ot, \"FLIP failed due to missing triangle\");\n\n    var op = ot.oppositePoint(t, p);\n\n    if (inScanArea(eq, flip_triangle.pointCCW(eq), flip_triangle.pointCW(eq), op)) {\n        // flip with new edge op.eq\n        flipEdgeEvent(tcx, eq, op, ot, op);\n    } else {\n        var newP = nextFlipPoint(ep, eq, ot, op);\n        flipScanEdgeEvent(tcx, ep, eq, flip_triangle, ot, newP);\n    }\n}\n\n\n// ----------------------------------------------------------------------Exports\n\nexports.triangulate = triangulate;\n","/*\n * Poly2Tri Copyright (c) 2009-2014, Poly2Tri Contributors\n * http://code.google.com/p/poly2tri/\n * \n * poly2tri.js (JavaScript port) (c) 2009-2014, Poly2Tri Contributors\n * https://github.com/r3mi/poly2tri.js\n * \n * All rights reserved.\n * \n * Distributed under the 3-clause BSD License, see LICENSE.txt\n */\n\n/* jshint maxcomplexity:11 */\n\n\"use strict\";\n\n\n/*\n * Note\n * ====\n * the structure of this JavaScript version of poly2tri intentionally follows\n * as closely as possible the structure of the reference C++ version, to make it \n * easier to keep the 2 versions in sync.\n */\n\n\n// -------------------------------------------------------------------------Node\n\n/**\n * Advancing front node\n * @constructor\n * @private\n * @struct\n * @param {!XY} p - Point\n * @param {Triangle=} t triangle (optional)\n */\nvar Node = function(p, t) {\n    /** @type {XY} */\n    this.point = p;\n\n    /** @type {Triangle|null} */\n    this.triangle = t || null;\n\n    /** @type {Node|null} */\n    this.next = null;\n    /** @type {Node|null} */\n    this.prev = null;\n\n    /** @type {number} */\n    this.value = p.x;\n};\n\n// ---------------------------------------------------------------AdvancingFront\n/**\n * @constructor\n * @private\n * @struct\n * @param {Node} head\n * @param {Node} tail\n */\nvar AdvancingFront = function(head, tail) {\n    /** @type {Node} */\n    this.head_ = head;\n    /** @type {Node} */\n    this.tail_ = tail;\n    /** @type {Node} */\n    this.search_node_ = head;\n};\n\n/** @return {Node} */\nAdvancingFront.prototype.head = function() {\n    return this.head_;\n};\n\n/** @param {Node} node */\nAdvancingFront.prototype.setHead = function(node) {\n    this.head_ = node;\n};\n\n/** @return {Node} */\nAdvancingFront.prototype.tail = function() {\n    return this.tail_;\n};\n\n/** @param {Node} node */\nAdvancingFront.prototype.setTail = function(node) {\n    this.tail_ = node;\n};\n\n/** @return {Node} */\nAdvancingFront.prototype.search = function() {\n    return this.search_node_;\n};\n\n/** @param {Node} node */\nAdvancingFront.prototype.setSearch = function(node) {\n    this.search_node_ = node;\n};\n\n/** @return {Node} */\nAdvancingFront.prototype.findSearchNode = function(/*x*/) {\n    // TODO: implement BST index\n    return this.search_node_;\n};\n\n/**\n * @param {number} x value\n * @return {Node}\n */\nAdvancingFront.prototype.locateNode = function(x) {\n    var node = this.search_node_;\n\n    /* jshint boss:true */\n    if (x < node.value) {\n        while (node = node.prev) {\n            if (x >= node.value) {\n                this.search_node_ = node;\n                return node;\n            }\n        }\n    } else {\n        while (node = node.next) {\n            if (x < node.value) {\n                this.search_node_ = node.prev;\n                return node.prev;\n            }\n        }\n    }\n    return null;\n};\n\n/**\n * @param {!XY} point - Point\n * @return {Node}\n */\nAdvancingFront.prototype.locatePoint = function(point) {\n    var px = point.x;\n    var node = this.findSearchNode(px);\n    var nx = node.point.x;\n\n    if (px === nx) {\n        // Here we are comparing point references, not values\n        if (point !== node.point) {\n            // We might have two nodes with same x value for a short time\n            if (point === node.prev.point) {\n                node = node.prev;\n            } else if (point === node.next.point) {\n                node = node.next;\n            } else {\n                throw new Error('poly2tri Invalid AdvancingFront.locatePoint() call');\n            }\n        }\n    } else if (px < nx) {\n        /* jshint boss:true */\n        while (node = node.prev) {\n            if (point === node.point) {\n                break;\n            }\n        }\n    } else {\n        while (node = node.next) {\n            if (point === node.point) {\n                break;\n            }\n        }\n    }\n\n    if (node) {\n        this.search_node_ = node;\n    }\n    return node;\n};\n\n\n// ----------------------------------------------------------------------Exports\n\nmodule.exports = AdvancingFront;\nmodule.exports.Node = Node;\n\n","'use strict';\n\nmodule.exports = earcut;\nmodule.exports.default = earcut;\n\nfunction earcut(data, holeIndices, dim) {\n\n    dim = dim || 2;\n\n    var hasHoles = holeIndices && holeIndices.length,\n        outerLen = hasHoles ? holeIndices[0] * dim : data.length,\n        outerNode = linkedList(data, 0, outerLen, dim, true),\n        triangles = [];\n\n    if (!outerNode || outerNode.next === outerNode.prev) return triangles;\n\n    var minX, minY, maxX, maxY, x, y, invSize;\n\n    if (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim);\n\n    // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox\n    if (data.length > 80 * dim) {\n        minX = maxX = data[0];\n        minY = maxY = data[1];\n\n        for (var i = dim; i < outerLen; i += dim) {\n            x = data[i];\n            y = data[i + 1];\n            if (x < minX) minX = x;\n            if (y < minY) minY = y;\n            if (x > maxX) maxX = x;\n            if (y > maxY) maxY = y;\n        }\n\n        // minX, minY and invSize are later used to transform coords into integers for z-order calculation\n        invSize = Math.max(maxX - minX, maxY - minY);\n        invSize = invSize !== 0 ? 1 / invSize : 0;\n    }\n\n    earcutLinked(outerNode, triangles, dim, minX, minY, invSize);\n\n    return triangles;\n}\n\n// create a circular doubly linked list from polygon points in the specified winding order\nfunction linkedList(data, start, end, dim, clockwise) {\n    var i, last;\n\n    if (clockwise === (signedArea(data, start, end, dim) > 0)) {\n        for (i = start; i < end; i += dim) last = insertNode(i, data[i], data[i + 1], last);\n    } else {\n        for (i = end - dim; i >= start; i -= dim) last = insertNode(i, data[i], data[i + 1], last);\n    }\n\n    if (last && equals(last, last.next)) {\n        removeNode(last);\n        last = last.next;\n    }\n\n    return last;\n}\n\n// eliminate colinear or duplicate points\nfunction filterPoints(start, end) {\n    if (!start) return start;\n    if (!end) end = start;\n\n    var p = start,\n        again;\n    do {\n        again = false;\n\n        if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {\n            removeNode(p);\n            p = end = p.prev;\n            if (p === p.next) break;\n            again = true;\n\n        } else {\n            p = p.next;\n        }\n    } while (again || p !== end);\n\n    return end;\n}\n\n// main ear slicing loop which triangulates a polygon (given as a linked list)\nfunction earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {\n    if (!ear) return;\n\n    // interlink polygon nodes in z-order\n    if (!pass && invSize) indexCurve(ear, minX, minY, invSize);\n\n    var stop = ear,\n        prev, next;\n\n    // iterate through ears, slicing them one by one\n    while (ear.prev !== ear.next) {\n        prev = ear.prev;\n        next = ear.next;\n\n        if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {\n            // cut off the triangle\n            triangles.push(prev.i / dim);\n            triangles.push(ear.i / dim);\n            triangles.push(next.i / dim);\n\n            removeNode(ear);\n\n            // skipping the next vertex leads to less sliver triangles\n            ear = next.next;\n            stop = next.next;\n\n            continue;\n        }\n\n        ear = next;\n\n        // if we looped through the whole remaining polygon and can't find any more ears\n        if (ear === stop) {\n            // try filtering points and slicing again\n            if (!pass) {\n                earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);\n\n            // if this didn't work, try curing all small self-intersections locally\n            } else if (pass === 1) {\n                ear = cureLocalIntersections(filterPoints(ear), triangles, dim);\n                earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);\n\n            // as a last resort, try splitting the remaining polygon into two\n            } else if (pass === 2) {\n                splitEarcut(ear, triangles, dim, minX, minY, invSize);\n            }\n\n            break;\n        }\n    }\n}\n\n// check whether a polygon node forms a valid ear with adjacent nodes\nfunction isEar(ear) {\n    var a = ear.prev,\n        b = ear,\n        c = ear.next;\n\n    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear\n\n    // now make sure we don't have other points inside the potential ear\n    var p = ear.next.next;\n\n    while (p !== ear.prev) {\n        if (pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&\n            area(p.prev, p, p.next) >= 0) return false;\n        p = p.next;\n    }\n\n    return true;\n}\n\nfunction isEarHashed(ear, minX, minY, invSize) {\n    var a = ear.prev,\n        b = ear,\n        c = ear.next;\n\n    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear\n\n    // triangle bbox; min & max are calculated like this for speed\n    var minTX = a.x < b.x ? (a.x < c.x ? a.x : c.x) : (b.x < c.x ? b.x : c.x),\n        minTY = a.y < b.y ? (a.y < c.y ? a.y : c.y) : (b.y < c.y ? b.y : c.y),\n        maxTX = a.x > b.x ? (a.x > c.x ? a.x : c.x) : (b.x > c.x ? b.x : c.x),\n        maxTY = a.y > b.y ? (a.y > c.y ? a.y : c.y) : (b.y > c.y ? b.y : c.y);\n\n    // z-order range for the current triangle bbox;\n    var minZ = zOrder(minTX, minTY, minX, minY, invSize),\n        maxZ = zOrder(maxTX, maxTY, minX, minY, invSize);\n\n    var p = ear.prevZ,\n        n = ear.nextZ;\n\n    // look for points inside the triangle in both directions\n    while (p && p.z >= minZ && n && n.z <= maxZ) {\n        if (p !== ear.prev && p !== ear.next &&\n            pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&\n            area(p.prev, p, p.next) >= 0) return false;\n        p = p.prevZ;\n\n        if (n !== ear.prev && n !== ear.next &&\n            pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) &&\n            area(n.prev, n, n.next) >= 0) return false;\n        n = n.nextZ;\n    }\n\n    // look for remaining points in decreasing z-order\n    while (p && p.z >= minZ) {\n        if (p !== ear.prev && p !== ear.next &&\n            pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&\n            area(p.prev, p, p.next) >= 0) return false;\n        p = p.prevZ;\n    }\n\n    // look for remaining points in increasing z-order\n    while (n && n.z <= maxZ) {\n        if (n !== ear.prev && n !== ear.next &&\n            pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) &&\n            area(n.prev, n, n.next) >= 0) return false;\n        n = n.nextZ;\n    }\n\n    return true;\n}\n\n// go through all polygon nodes and cure small local self-intersections\nfunction cureLocalIntersections(start, triangles, dim) {\n    var p = start;\n    do {\n        var a = p.prev,\n            b = p.next.next;\n\n        if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {\n\n            triangles.push(a.i / dim);\n            triangles.push(p.i / dim);\n            triangles.push(b.i / dim);\n\n            // remove two nodes involved\n            removeNode(p);\n            removeNode(p.next);\n\n            p = start = b;\n        }\n        p = p.next;\n    } while (p !== start);\n\n    return filterPoints(p);\n}\n\n// try splitting polygon into two and triangulate them independently\nfunction splitEarcut(start, triangles, dim, minX, minY, invSize) {\n    // look for a valid diagonal that divides the polygon into two\n    var a = start;\n    do {\n        var b = a.next.next;\n        while (b !== a.prev) {\n            if (a.i !== b.i && isValidDiagonal(a, b)) {\n                // split the polygon in two by the diagonal\n                var c = splitPolygon(a, b);\n\n                // filter colinear points around the cuts\n                a = filterPoints(a, a.next);\n                c = filterPoints(c, c.next);\n\n                // run earcut on each half\n                earcutLinked(a, triangles, dim, minX, minY, invSize);\n                earcutLinked(c, triangles, dim, minX, minY, invSize);\n                return;\n            }\n            b = b.next;\n        }\n        a = a.next;\n    } while (a !== start);\n}\n\n// link every hole into the outer loop, producing a single-ring polygon without holes\nfunction eliminateHoles(data, holeIndices, outerNode, dim) {\n    var queue = [],\n        i, len, start, end, list;\n\n    for (i = 0, len = holeIndices.length; i < len; i++) {\n        start = holeIndices[i] * dim;\n        end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;\n        list = linkedList(data, start, end, dim, false);\n        if (list === list.next) list.steiner = true;\n        queue.push(getLeftmost(list));\n    }\n\n    queue.sort(compareX);\n\n    // process holes from left to right\n    for (i = 0; i < queue.length; i++) {\n        outerNode = eliminateHole(queue[i], outerNode);\n        outerNode = filterPoints(outerNode, outerNode.next);\n    }\n\n    return outerNode;\n}\n\nfunction compareX(a, b) {\n    return a.x - b.x;\n}\n\n// find a bridge between vertices that connects hole with an outer ring and and link it\nfunction eliminateHole(hole, outerNode) {\n    var bridge = findHoleBridge(hole, outerNode);\n    if (!bridge) {\n        return outerNode;\n    }\n\n    var bridgeReverse = splitPolygon(bridge, hole);\n\n    // filter collinear points around the cuts\n    var filteredBridge = filterPoints(bridge, bridge.next);\n    filterPoints(bridgeReverse, bridgeReverse.next);\n\n    // Check if input node was removed by the filtering\n    return outerNode === bridge ? filteredBridge : outerNode;\n}\n\n// David Eberly's algorithm for finding a bridge between hole and outer polygon\nfunction findHoleBridge(hole, outerNode) {\n    var p = outerNode,\n        hx = hole.x,\n        hy = hole.y,\n        qx = -Infinity,\n        m;\n\n    // find a segment intersected by a ray from the hole's leftmost point to the left;\n    // segment's endpoint with lesser x will be potential connection point\n    do {\n        if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {\n            var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);\n            if (x <= hx && x > qx) {\n                qx = x;\n                if (x === hx) {\n                    if (hy === p.y) return p;\n                    if (hy === p.next.y) return p.next;\n                }\n                m = p.x < p.next.x ? p : p.next;\n            }\n        }\n        p = p.next;\n    } while (p !== outerNode);\n\n    if (!m) return null;\n\n    if (hx === qx) return m; // hole touches outer segment; pick leftmost endpoint\n\n    // look for points inside the triangle of hole point, segment intersection and endpoint;\n    // if there are no points found, we have a valid connection;\n    // otherwise choose the point of the minimum angle with the ray as connection point\n\n    var stop = m,\n        mx = m.x,\n        my = m.y,\n        tanMin = Infinity,\n        tan;\n\n    p = m;\n\n    do {\n        if (hx >= p.x && p.x >= mx && hx !== p.x &&\n                pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {\n\n            tan = Math.abs(hy - p.y) / (hx - p.x); // tangential\n\n            if (locallyInside(p, hole) &&\n                (tan < tanMin || (tan === tanMin && (p.x > m.x || (p.x === m.x && sectorContainsSector(m, p)))))) {\n                m = p;\n                tanMin = tan;\n            }\n        }\n\n        p = p.next;\n    } while (p !== stop);\n\n    return m;\n}\n\n// whether sector in vertex m contains sector in vertex p in the same coordinates\nfunction sectorContainsSector(m, p) {\n    return area(m.prev, m, p.prev) < 0 && area(p.next, m, m.next) < 0;\n}\n\n// interlink polygon nodes in z-order\nfunction indexCurve(start, minX, minY, invSize) {\n    var p = start;\n    do {\n        if (p.z === null) p.z = zOrder(p.x, p.y, minX, minY, invSize);\n        p.prevZ = p.prev;\n        p.nextZ = p.next;\n        p = p.next;\n    } while (p !== start);\n\n    p.prevZ.nextZ = null;\n    p.prevZ = null;\n\n    sortLinked(p);\n}\n\n// Simon Tatham's linked list merge sort algorithm\n// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html\nfunction sortLinked(list) {\n    var i, p, q, e, tail, numMerges, pSize, qSize,\n        inSize = 1;\n\n    do {\n        p = list;\n        list = null;\n        tail = null;\n        numMerges = 0;\n\n        while (p) {\n            numMerges++;\n            q = p;\n            pSize = 0;\n            for (i = 0; i < inSize; i++) {\n                pSize++;\n                q = q.nextZ;\n                if (!q) break;\n            }\n            qSize = inSize;\n\n            while (pSize > 0 || (qSize > 0 && q)) {\n\n                if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {\n                    e = p;\n                    p = p.nextZ;\n                    pSize--;\n                } else {\n                    e = q;\n                    q = q.nextZ;\n                    qSize--;\n                }\n\n                if (tail) tail.nextZ = e;\n                else list = e;\n\n                e.prevZ = tail;\n                tail = e;\n            }\n\n            p = q;\n        }\n\n        tail.nextZ = null;\n        inSize *= 2;\n\n    } while (numMerges > 1);\n\n    return list;\n}\n\n// z-order of a point given coords and inverse of the longer side of data bbox\nfunction zOrder(x, y, minX, minY, invSize) {\n    // coords are transformed into non-negative 15-bit integer range\n    x = 32767 * (x - minX) * invSize;\n    y = 32767 * (y - minY) * invSize;\n\n    x = (x | (x << 8)) & 0x00FF00FF;\n    x = (x | (x << 4)) & 0x0F0F0F0F;\n    x = (x | (x << 2)) & 0x33333333;\n    x = (x | (x << 1)) & 0x55555555;\n\n    y = (y | (y << 8)) & 0x00FF00FF;\n    y = (y | (y << 4)) & 0x0F0F0F0F;\n    y = (y | (y << 2)) & 0x33333333;\n    y = (y | (y << 1)) & 0x55555555;\n\n    return x | (y << 1);\n}\n\n// find the leftmost node of a polygon ring\nfunction getLeftmost(start) {\n    var p = start,\n        leftmost = start;\n    do {\n        if (p.x < leftmost.x || (p.x === leftmost.x && p.y < leftmost.y)) leftmost = p;\n        p = p.next;\n    } while (p !== start);\n\n    return leftmost;\n}\n\n// check if a point lies within a convex triangle\nfunction pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {\n    return (cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 &&\n           (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 &&\n           (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0;\n}\n\n// check if a diagonal between two polygon nodes is valid (lies in polygon interior)\nfunction isValidDiagonal(a, b) {\n    return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && // dones't intersect other edges\n           (locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b) && // locally visible\n            (area(a.prev, a, b.prev) || area(a, b.prev, b)) || // does not create opposite-facing sectors\n            equals(a, b) && area(a.prev, a, a.next) > 0 && area(b.prev, b, b.next) > 0); // special zero-length case\n}\n\n// signed area of a triangle\nfunction area(p, q, r) {\n    return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);\n}\n\n// check if two points are equal\nfunction equals(p1, p2) {\n    return p1.x === p2.x && p1.y === p2.y;\n}\n\n// check if two segments intersect\nfunction intersects(p1, q1, p2, q2) {\n    var o1 = sign(area(p1, q1, p2));\n    var o2 = sign(area(p1, q1, q2));\n    var o3 = sign(area(p2, q2, p1));\n    var o4 = sign(area(p2, q2, q1));\n\n    if (o1 !== o2 && o3 !== o4) return true; // general case\n\n    if (o1 === 0 && onSegment(p1, p2, q1)) return true; // p1, q1 and p2 are collinear and p2 lies on p1q1\n    if (o2 === 0 && onSegment(p1, q2, q1)) return true; // p1, q1 and q2 are collinear and q2 lies on p1q1\n    if (o3 === 0 && onSegment(p2, p1, q2)) return true; // p2, q2 and p1 are collinear and p1 lies on p2q2\n    if (o4 === 0 && onSegment(p2, q1, q2)) return true; // p2, q2 and q1 are collinear and q1 lies on p2q2\n\n    return false;\n}\n\n// for collinear points p, q, r, check if point q lies on segment pr\nfunction onSegment(p, q, r) {\n    return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);\n}\n\nfunction sign(num) {\n    return num > 0 ? 1 : num < 0 ? -1 : 0;\n}\n\n// check if a polygon diagonal intersects any polygon segments\nfunction intersectsPolygon(a, b) {\n    var p = a;\n    do {\n        if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i &&\n                intersects(p, p.next, a, b)) return true;\n        p = p.next;\n    } while (p !== a);\n\n    return false;\n}\n\n// check if a polygon diagonal is locally inside the polygon\nfunction locallyInside(a, b) {\n    return area(a.prev, a, a.next) < 0 ?\n        area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 :\n        area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;\n}\n\n// check if the middle point of a polygon diagonal is inside the polygon\nfunction middleInside(a, b) {\n    var p = a,\n        inside = false,\n        px = (a.x + b.x) / 2,\n        py = (a.y + b.y) / 2;\n    do {\n        if (((p.y > py) !== (p.next.y > py)) && p.next.y !== p.y &&\n                (px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x))\n            inside = !inside;\n        p = p.next;\n    } while (p !== a);\n\n    return inside;\n}\n\n// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;\n// if one belongs to the outer ring and another to a hole, it merges it into a single ring\nfunction splitPolygon(a, b) {\n    var a2 = new Node(a.i, a.x, a.y),\n        b2 = new Node(b.i, b.x, b.y),\n        an = a.next,\n        bp = b.prev;\n\n    a.next = b;\n    b.prev = a;\n\n    a2.next = an;\n    an.prev = a2;\n\n    b2.next = a2;\n    a2.prev = b2;\n\n    bp.next = b2;\n    b2.prev = bp;\n\n    return b2;\n}\n\n// create a node and optionally link it with previous one (in a circular doubly linked list)\nfunction insertNode(i, x, y, last) {\n    var p = new Node(i, x, y);\n\n    if (!last) {\n        p.prev = p;\n        p.next = p;\n\n    } else {\n        p.next = last.next;\n        p.prev = last;\n        last.next.prev = p;\n        last.next = p;\n    }\n    return p;\n}\n\nfunction removeNode(p) {\n    p.next.prev = p.prev;\n    p.prev.next = p.next;\n\n    if (p.prevZ) p.prevZ.nextZ = p.nextZ;\n    if (p.nextZ) p.nextZ.prevZ = p.prevZ;\n}\n\nfunction Node(i, x, y) {\n    // vertex index in coordinates array\n    this.i = i;\n\n    // vertex coordinates\n    this.x = x;\n    this.y = y;\n\n    // previous and next vertex nodes in a polygon ring\n    this.prev = null;\n    this.next = null;\n\n    // z-order curve value\n    this.z = null;\n\n    // previous and next nodes in z-order\n    this.prevZ = null;\n    this.nextZ = null;\n\n    // indicates whether this is a steiner point\n    this.steiner = false;\n}\n\n// return a percentage difference between the polygon area and its triangulation area;\n// used to verify correctness of triangulation\nearcut.deviation = function (data, holeIndices, dim, triangles) {\n    var hasHoles = holeIndices && holeIndices.length;\n    var outerLen = hasHoles ? holeIndices[0] * dim : data.length;\n\n    var polygonArea = Math.abs(signedArea(data, 0, outerLen, dim));\n    if (hasHoles) {\n        for (var i = 0, len = holeIndices.length; i < len; i++) {\n            var start = holeIndices[i] * dim;\n            var end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;\n            polygonArea -= Math.abs(signedArea(data, start, end, dim));\n        }\n    }\n\n    var trianglesArea = 0;\n    for (i = 0; i < triangles.length; i += 3) {\n        var a = triangles[i] * dim;\n        var b = triangles[i + 1] * dim;\n        var c = triangles[i + 2] * dim;\n        trianglesArea += Math.abs(\n            (data[a] - data[c]) * (data[b + 1] - data[a + 1]) -\n            (data[a] - data[b]) * (data[c + 1] - data[a + 1]));\n    }\n\n    return polygonArea === 0 && trianglesArea === 0 ? 0 :\n        Math.abs((trianglesArea - polygonArea) / polygonArea);\n};\n\nfunction signedArea(data, start, end, dim) {\n    var sum = 0;\n    for (var i = start, j = end - dim; i < end; i += dim) {\n        sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);\n        j = i;\n    }\n    return sum;\n}\n\n// turn a polygon in a multi-dimensional array form (e.g. as in GeoJSON) into a form Earcut accepts\nearcut.flatten = function (data) {\n    var dim = data[0][0].length,\n        result = {vertices: [], holes: [], dimensions: dim},\n        holeIndex = 0;\n\n    for (var i = 0; i < data.length; i++) {\n        for (var j = 0; j < data[i].length; j++) {\n            for (var d = 0; d < dim; d++) result.vertices.push(data[i][j][d]);\n        }\n        if (i > 0) {\n            holeIndex += data[i - 1].length;\n            result.holes.push(holeIndex);\n        }\n    }\n    return result;\n};\n","\r\nimport { TOL } from  \"./fuzzy-math\";\r\n\r\nfunction ABS(x) {\r\n    return Math.abs(x);\r\n}\r\n\r\nconst EPS = TOL;\r\n\r\nexport const ONE_INTERSECTION = 4;\r\nexport const OVERLAP = 5;\r\n\r\n\r\n//Returns true if the given point lies on and inside the given line segment\r\nexport function pointOnLine(x, y, e, checkInsideSegment, precisionDistance, outPt) {\r\n\r\n    if (e.length < EPS) {\r\n        return false;\r\n    }\r\n\r\n    let dot = (x - e.v1.x) * e.dx + (y - e.v1.y) * e.dy;\r\n\r\n    if (!precisionDistance)\r\n        precisionDistance = EPS * e.length;\r\n\r\n    let u = dot / e.length2;\r\n        \r\n    if (checkInsideSegment) {\r\n        if (u * e.length < -precisionDistance || u * e.length > e.length + precisionDistance)\r\n            return false;\r\n    }\r\n\r\n    let lx = e.v1.x + u * e.dx;\r\n    let ly = e.v1.y + u * e.dy;\r\n    \r\n    let len2 = (lx - x) * (lx - x) + (ly - y) * (ly - y);\r\n\r\n    if (outPt) {\r\n        outPt.x = lx;\r\n        outPt.y = ly;\r\n        outPt.d = Math.sqrt(len2);\r\n        outPt.u = u;\r\n    }\r\n    \r\n    if (len2 < precisionDistance * precisionDistance)\r\n        return true;\r\n\r\n    return false;\r\n}\r\n\r\n\r\nfunction parallelLinesOverlap(e1, e2, precisionDistance) {\r\n\r\n    //Check of the segments are parallel but not on the same infinite line\r\n    if (!pointOnLine(e2.v1.x, e2.v1.y, e1, false, precisionDistance)) {\r\n        return null;\r\n    }\r\n\r\n    let res = {\r\n        status: OVERLAP,\r\n        e1: [],\r\n        e2: []\r\n    };\r\n\r\n    //They are on the same line. Find overlap points.\r\n    //TODO: There is probably a more efficient way to do this\r\n    let p3_seg1 = pointOnLine(e2.v1.x, e2.v1.y, e1, true, precisionDistance);\r\n    let p4_seg1 = pointOnLine(e2.v2.x, e2.v2.y, e1, true, precisionDistance);\r\n\r\n    //If both points of the second segment are inside the first\r\n    //then the reverse cannot be true...\r\n    if (p3_seg1 && p4_seg1) {\r\n        res.e1.push(e2.v1.x, e2.v1.y, e2.v2.x, e2.v2.y);\r\n        return res;\r\n    }\r\n\r\n    let p1_seg2 = pointOnLine(e1.v1.x, e1.v1.y, e2, true, precisionDistance);\r\n    let p2_seg2 = pointOnLine(e1.v2.x, e1.v2.y, e2, true, precisionDistance);\r\n\r\n    if (p3_seg1)\r\n        res.e1.push(e2.v1.x, e2.v1.y);\r\n    if (p4_seg1)\r\n        res.e1.push(e2.v2.x, e2.v2.y);\r\n    if (p1_seg2)\r\n        res.e2.push(e1.v1.x, e1.v1.y);\r\n    if (p2_seg2)\r\n        res.e2.push(e1.v2.x, e1.v2.y);\r\n\r\n    return res;\r\n}\r\n\r\n\r\n/*\r\n   Determine the intersection point of two line segments\r\n   Modified source from here:\r\n   http://www.paulbourke.net/geometry/pointlineplane/\r\n*/\r\nexport function segmentsIntersect(e1, e2, precisionDistance)\r\n{\r\n    let denom  = e2.dy * e1.dx - e2.dx * e1.dy;\r\n    let numera = e2.dx * (e1.v1.y - e2.v1.y) - e2.dy * (e1.v1.x - e2.v1.x);\r\n    let numerb = e1.dx * (e1.v1.y - e2.v1.y) - e1.dy * (e1.v1.x - e2.v1.x);\r\n\r\n    /* Are the lines coincident? */\r\n    if (ABS(numera) < EPS && ABS(numerb) < EPS && ABS(denom) < EPS) {\r\n        return null;\r\n    }\r\n\r\n    /* Are the lines parallel */\r\n    if (ABS(denom) < EPS) {\r\n        /* check for overlap */\r\n        return parallelLinesOverlap(e1, e2, precisionDistance);\r\n    }\r\n\r\n    /* Is the intersection along the segments */\r\n    let mua = numera / denom;\r\n    let da = mua * e1.length;\r\n    if (da < -precisionDistance || da > e1.length + precisionDistance) {\r\n        return null;\r\n    }\r\n\r\n    let mub = numerb / denom;\r\n    let db = mub * e2.length;\r\n    if (db < -precisionDistance || db > e2.length + precisionDistance) {\r\n        return null;\r\n    }\r\n\r\n    let x = e1.v1.x + mua * e1.dx;\r\n    let y = e1.v1.y + mua * e1.dy;\r\n\r\n    return {\r\n        status: ONE_INTERSECTION,\r\n        e1: [x, y],\r\n        e2: [x, y]\r\n    };\r\n}","import lmv_poly2tri from \"./ThirdParty/lmv_poly2tri\";\nimport { IntervalTree } from \"./interval-tree\";\nimport { segmentsIntersect, ONE_INTERSECTION } from \"./x-line-line\";\n\nconst avp = Autodesk.Viewing.Private;\n\nfunction jitterPoints(pts) {\n\n    for (let i=0, iEnd=pts.length; i<iEnd; i++) {\n        pts[i].x += (Math.random()-0.5) * 1e-9;\n        pts[i].y += (Math.random()-0.5) * 1e-9;\n    }\n\n}\n\nfunction copyPoints(pts, bbox) {\n\n    //Moving poiints to be centered on the origin\n    //seems to improve triangulation success rate, or\n    //at least avoids some bugs in poly2yti\n\n    let sz = bbox.size();\n    let offsetx = bbox.min.x + sz.x * 0.5;\n    let offsety = bbox.min.y + sz.y * 0.5;\n    let scale = 2.0 / sz.length();\n\n    let pts2 = [];\n\n    for (let i=0, iEnd=pts.length; i<iEnd; i++) {\n        pts2.push({\n            x: (pts[i].x - offsetx) * scale,// + (Math.random()-0.5) * 1e-9,\n            y: (pts[i].y - offsety) * scale,// + (Math.random()-0.5) * 1e-9,\n            _triidx: i+1\n        });\n    }\n\n    return pts2;\n\n}\n\n\n//Represents a polygon with holes, and provides triangulation and mesh conversion utilities\nexport class ComplexPolygon {\n\n    constructor(uniquePoints, customInsidechecker, bbox) {\n        this.pts = uniquePoints;\n        this.contours = [];\n        this.customInsideChecker = customInsidechecker;\n        this.bbox = bbox;\n    }\n\n    addContour(indices) {\n        this.contours.push(indices);\n    }\n\n    pointInContour(x, y, cntr) {\n        var yflag0, yflag1;\n        var vtx0X, vtx0Y, vtx1X, vtx1Y;\n\n        var inside_flag = false;\n\n        var pts = this.pts;\n\n        // get the last point in the polygon\n        vtx0X = pts[cntr[cntr.length-1]].x;\n        vtx0Y = pts[cntr[cntr.length-1]].y;\n\n        // get test bit for above/below X axis\n        yflag0 = (vtx0Y >= y);\n\n        for (var j= 0, jEnd=cntr.length; j<jEnd; ++j)\n        {\n            vtx1X = pts[cntr[j]].x;\n            vtx1Y = pts[cntr[j]].y;\n\n            yflag1 = (vtx1Y >= y);\n\n            // Check if endpoints straddle (are on opposite sides) of X axis\n            // (i.e. the Y's differ); if so, +X ray could intersect this edge.\n            // The old test also checked whether the endpoints are both to the\n            // right or to the left of the test point.  However, given the faster\n            // intersection point computation used below, this test was found to\n            // be a break-even proposition for most polygons and a loser for\n            // triangles (where 50% or more of the edges which survive this test\n            // will cross quadrants and so have to have the X intersection computed\n            // anyway).  I credit Joseph Samosky with inspiring me to try dropping\n            // the \"both left or both right\" part of my code.\n            if (yflag0 != yflag1)\n            {\n                // Check intersection of pgon segment with +X ray.\n                // Note if >= point's X; if so, the ray hits it.\n                // The division operation is avoided for the \">=\" test by checking\n                // the sign of the first vertex wrto the test point; idea inspired\n                // by Joseph Samosky's and Mark Haigh-Hutchinson's different\n                // polygon inclusion tests.\n                if (((vtx1Y-y)*(vtx0X-vtx1X) >=\n                        (vtx1X-x)*(vtx0Y-vtx1Y)) == yflag1)\n                {\n                    inside_flag = !inside_flag;\n                }\n            }\n\n            // move to the next pair of vertices, retaining info as possible\n            yflag0 = yflag1;\n            vtx0X = vtx1X;\n            vtx0Y = vtx1Y;\n        }\n\n        return inside_flag;\n    }\n\n\n    pointInPolygon(x, y) {\n        var inside = false;\n\n        for (var i=0; i<this.contours.length; i++) {\n\n            if (this.pointInContour(x, y, this.contours[i]))\n                inside = !inside;\n        }\n\n        return inside;\n    }\n\n    triangulate() {\n        try {\n            this.triangulateInternal();\n        } catch (e) {\n\n            if (e.message.indexOf(\"Collinear not supported!\") !== -1) {\n                try {\n                    this.triangulateInternal(true);\n                    //logger.log(\"Triangulation retry success.\");\n                } catch (e) {\n                    //logger.warn(\"Triangulation retry failed\", e);\n                    this.triangulationFailed = true;\n                }\n            } else {\n                //logger.warn(\"Triangulation failed\", e);\n                this.triangulationFailed = true;\n            }\n        }\n    }\n\n    createPointInPolygonChecker() {\n\n        let edges = [];\n\n        for (let i=0; i<this.contours.length; i++) {\n            let cntr = this.contours[i];\n\n            var len = cntr.length;\n            for (let k=0; k<len-1; k++) {\n                let e = {\n                    p1: cntr[k],\n                    p2: cntr[k+1]\n                };\n                edges.push(e);\n            }\n        }\n\n        let it = new IntervalTree(this.pts, edges, this.bbox);\n        it.build();\n        this.customInsideChecker = it;\n    }\n\n    triangulateInternal(wantJitter) {\n\n        if (!this.contours.length) {\n            this.triangulationFailed = true;\n            this.indices = null;\n            return;\n        }\n\n        this.indices = [];\n\n        var _pts = copyPoints(this.pts, this.bbox);\n\n        if (wantJitter) {\n            jitterPoints(_pts);\n        }\n\n        var sweepCtx = new lmv_poly2tri.SweepContext([]);\n\n        sweepCtx.points_  = _pts;\n\n        for (let i=0; i<this.contours.length; i++) {\n            let cntr = this.contours[i];\n\n            //Contour is not closed\n            var isOpen = (cntr[0] !== cntr[cntr.length-1]);\n\n            //if (isOpen)\n            //    continue;\n\n            var len = isOpen ? cntr.length : cntr.length - 1;\n            var edge = new Array(len);\n            for (var k=0; k<len; k++) {\n                edge[k] = _pts[cntr[k]];\n            }\n\n            sweepCtx.initEdges(edge, isOpen);\n        }\n\n        sweepCtx.triangulate();\n\n        this.processResult(sweepCtx);\n\n        this.triangulationFailed = !this.indices || !this.indices.length;\n\n    }\n\n    processResult(sweepCtx) {\n\n        //If the polygon has a lot of vertices, create\n        //an acceleration structure for point-in-polygon checks\n        //so we can filter the triangles faster.\n        if (this.pts.length > 10 && !this.customInsideChecker)\n            this.createPointInPolygonChecker();\n\n        let tris = sweepCtx.map_;\n        for (var i=0; i<tris.length; i++) {\n            var tpts = tris[i].points_;\n            var p0 = tpts[0];\n            var p1 = tpts[1];\n            var p2 = tpts[2];\n\n            var i0 = p0._triidx;\n            var i1 = p1._triidx;\n            var i2 = p2._triidx;\n\n            if (i0 && i1 && i2)\n                this.filterFace(i0-1, i1-1, i2-1);\n\n        }\n    }\n\n\n    filterFace(i0, i1, i2) {\n\n        var p0 = this.pts[i0];\n        var p1 = this.pts[i1];\n        var p2 = this.pts[i2];\n\n        var cx = (p0.x + p1.x + p2.x) / 3;\n        var cy = (p0.y + p1.y + p2.y) / 3;\n\n        let inside = this.customInsideChecker ? this.customInsideChecker.pointInPolygon(cx, cy) : this.pointInPolygon(cx, cy);\n\n        if (inside) {\n\n            var e1x = p1.x - p0.x;\n            var e1y = p1.y - p0.y;\n            var e2x = p2.x - p0.x;\n            var e2y = p2.y - p0.y;\n\n            var cross = e1x * e2y - e2x * e1y;\n\n            if (cross > 0) {\n                this.indices.push(i0, i1, i2);\n            } else {\n                this.indices.push(i0, i2, i1);\n            }\n\n        }\n    }\n\n    //Returns intersection points between the given line\n    //segment and the polygon's contours\n    findSegmentIntersections(ex1, ey1, ex2, ey2) {\n\n        if (!this.cachedEdges) {\n\n            this.cachedEdges = [];\n\n            for (let j=0; j<this.contours.length; j++) {\n                let cntr = this.contours[j];\n\n                for (let i=0; i<cntr.length-1; i++) {\n\n                    //Add quad for each face formed by the extruded contour\n                    let x1 = this.pts[cntr[i]].x;\n                    let y1 = this.pts[cntr[i]].y;\n                    let x2 = this.pts[cntr[i+1]].x;\n                    let y2 = this.pts[cntr[i+1]].y;\n\n                    let etmp = {\n                        v1 : { x:x1, y:y1 },\n                        v2 : { x:x2, y:y2 },\n                        dx: x2 - x1,\n                        dy: y2 - y1,\n                        length: Math.sqrt((x1-x2)**2 + (y1-y2)**2)\n                    };\n\n                    this.cachedEdges.push(etmp);\n                }\n            }\n        }\n\n        let e = {\n            v1 : { x:ex1, y:ey1 },\n            v2 : { x:ex2, y:ey2 },\n            dx: ex2 - ex1,\n            dy: ey2 - ey1,\n            length: Math.sqrt((ex1-ex2)**2 + (ey1-ey2)**2)\n        };\n\n        let precision = this.bbox.size().length() * 1e-4;\n\n        let res = [];\n\n        for (let i=0; i<this.cachedEdges.length; i++) {\n            let etmp = this.cachedEdges[i];\n            let xsect = segmentsIntersect(e, etmp, precision);\n\n            if (xsect && xsect.status === ONE_INTERSECTION) {\n                let pt = { x: xsect.e1[0], y : xsect.e1[1] };\n                pt.d = Math.sqrt((pt.x - ex1)**2 + (pt.y - ey1)**2);\n                res.push(pt);\n            }\n        }\n\n        if (res.length) {\n            //Sort in order along the input segment\n            res.sort((a, b) => a.d - b.d);\n\n            //Drop start and/or end points if they coincide with the segment start/end\n            if (res[0].d < precision) {\n                res.shift();\n            }\n\n            if (res.length && Math.abs(res[res.length-1].d - e.length) < precision) {\n                res.pop();\n            }\n        }\n\n        return res.length ? res : null;\n    }\n\n    //creates a vertex buffer containing a filled 2D polygon for visualization on the cut plane\n    //as 2D polygon mesh in the 3D model space\n    toPolygonMesh(packNormals) {\n\n        if (this.polygonMesh)\n            return this.polygonMesh;\n\n        var pts = this.pts;\n\n        var bg = new THREE.BufferGeometry();\n\n        var pos = new Float32Array(3*pts.length);\n        for (let j=0; j<pts.length; j++) {\n            pos[3*j] = pts[j].x;\n            pos[3*j+1] = pts[j].y;\n            pos[3*j+2] = 0;\n        }\n        bg.setAttribute(\"position\", new THREE.BufferAttribute(pos, 3));\n\n        var normal = packNormals ? new Uint16Array(2*pts.length) : new Float32Array(3*pts.length);\n\n        for (let j=0; j<pts.length; j++) {\n\n            if (packNormals) {\n                var pnx = (0/*Math.atan2(0, 0)*/ / Math.PI + 1.0) * 0.5;\n                var pny = (1.0 + 1.0) * 0.5;\n\n                normal[j*2] = (pnx * 65535)|0;\n                normal[j*2+1] = (pny * 65535)|0;\n            } else {\n                normal[3*j] = 0;\n                normal[3*j+1] = 0;\n                normal[3*j+2] = 1;\n            }\n        }\n\n        bg.setAttribute(\"normal\", new THREE.BufferAttribute(normal, packNormals ? 2 : 3));\n        if (packNormals) {\n            bg.attributes.normal.bytesPerItem = 2;\n            bg.attributes.normal.normalize = true;\n        }\n\n        var index = new Uint16Array(this.indices.length);\n        index.set(this.indices);\n\n        bg.setAttribute(\"index\", new THREE.BufferAttribute(index, 1));\n\n        bg.streamingDraw = true;\n        bg.streamingIndex = true;\n\n        this.polygonMesh = bg;\n\n        return bg;\n    }\n\n\n    //creates an extruded polygon 3d mesh\n    //with the given thickness (maxZ=0, minZ=-thickness)\n    toExtrudedMesh(thickness) {\n\n        if (this.extrudedMesh)\n            return this.extrudedMesh;\n\n        if (thickness === undefined)\n            thickness = 1;\n\n        //TODO: in case of failed triangulation\n        //we can still generate a tube mesh with just the sides, without top and bottom caps\n        if (!this.indices)\n            return null;\n\n        let vb = [];\n        let indices = [];\n        let iblines = [];\n        let vbase = 0;\n\n        //TODO: for better performance we can allocate ArrayBuffers up front with known\n        //sizes... once the logic works.\n\n        //Add the top and bottom polygons\n\n        //The top is just the already triangulated 2D polygon\n        //same as toPolygonMesh\n\n        let pts = this.pts;\n        for (let i=0; i<pts.length; i++) {\n            vb.push(pts[i].x, pts[i].y, 0);\n            vb.push(0,0,1);\n        }\n\n        let inds = this.indices;\n\n        for (let i=0; i<inds.length; i+=3) {\n            indices.push(inds[i], inds[i+1], inds[i+2]);\n        }\n\n        vbase += pts.length;\n\n        //The bottom is like the top, but mirrored.\n\n        for (let i=0; i<pts.length; i++) {\n            vb.push(pts[i].x, pts[i].y, -thickness);\n            vb.push(0,0,-1);\n        }\n\n        for (let i=0; i<inds.length; i+=3) {\n            indices.push(vbase + inds[i], vbase + inds[i+2], vbase + inds[i+1]);\n        }\n\n        vbase += pts.length;\n\n        //The sides -- each segment of the contours becomes a quad\n\n        let tmp = new THREE.Vector3();\n        let bbox = new THREE.Box3();\n\n        for (let j=0; j<this.contours.length; j++) {\n            let cntr = this.contours[j];\n\n            for (let i=0; i<cntr.length-1; i++) {\n\n                //Add quad for each face formed by the extruded contour\n                let x1 = this.pts[cntr[i]].x;\n                let y1 = this.pts[cntr[i]].y;\n                let z1 = 0;\n\n                tmp.set(x1, y1, z1);\n                bbox.expandByPoint(tmp);\n\n                let x2 = this.pts[cntr[i+1]].x;\n                let y2 = this.pts[cntr[i+1]].y;\n                let z2 = 0;\n\n                tmp.set(x2, y2, z2);\n                bbox.expandByPoint(tmp);\n\n                tmp.set(x1, y1, z1 - thickness);\n                bbox.expandByPoint(tmp);\n\n                //orthogonal to the face, will use for the normals\n                tmp.set(y1 - y2, x2 - x1, 0).normalize();\n\n                iblines.push(vbase, vbase+1, vbase, vbase+2, vbase+1, vbase+3, vbase+2, vbase+3);\n\n                //If it's a hole, normals and faces are inverted\n                if (j > 0) {\n\n                    vb.push(x1, y1, z1,             -tmp.x, -tmp.y, -tmp.z,\n                            x2, y2, z2, -tmp.x,     -tmp.y, -tmp.z,\n                            x1, y1, z1 - thickness, -tmp.x, -tmp.y, -tmp.z,\n                            x2, y2, z2 - thickness, -tmp.x, -tmp.y, -tmp.z);\n\n                    indices.push(vbase, vbase+3, vbase+2,  vbase, vbase+1, vbase+3);\n                } else {\n                    vb.push(x1, y1, z1,             tmp.x, tmp.y, tmp.z,\n                            x2, y2, z2,             tmp.x, tmp.y, tmp.z,\n                            x1, y1, z1 - thickness, tmp.x, tmp.y, tmp.z,\n                            x2, y2, z2 - thickness, tmp.x, tmp.y, tmp.z);\n\n                    indices.push(vbase, vbase+2, vbase+3,  vbase+0, vbase+3, vbase+1);\n                }\n\n                vbase += 4;\n            }\n        }\n\n        //Convert to mesh suitable for rendering\n        //TODO: As mentioned above, we can do this directly in the loop above\n        //for better performance.\n\n        let vbp = new Float32Array(vb.length);\n        vbp.set(vb);\n\n        let vbi = new Uint16Array(indices.length);\n        vbi.set(indices);\n\n        let vbili = new Uint16Array(iblines.length);\n        vbili.set(iblines);\n\n        let mdata = {\n            mesh: {\n                vb: vbp,\n                indices: vbi,\n                iblines: vbili,\n\n                vbstride: 6,\n                vblayout : {\n                    position : { offset: 0, itemSize: 3, bytesPerItem: 4},\n                    normal: { offset: 3, itemSize: 3, bytesPerItem: 4 },\n                },\n                boundingBox: bbox,\n                boundingSphere: { center: bbox.getCenter(), radius: bbox.size().length * 0.5 }\n            }\n        };\n\n        avp.BufferGeometryUtils.meshToGeometry(mdata);\n\n        mdata.geometry.streamingDraw = true;\n        mdata.geometry.streamingIndex = true;\n\n        this.extrudedMesh = mdata.geometry;\n\n        return this.extrudedMesh;\n    }\n\n\n}","var lmv_poly2tri = require('poly2tri');\n\n// -------------------------------------------------------------------------Edge\n/**\n * Represents a simple polygon's edge\n * @constructor\n * @struct\n * @private\n * @param {Point} p1\n * @param {Point} p2\n * @throw {PointError} if p1 is same as p2\n */\nvar Edge = function Edge(p1, p2) {\n  this.p = p1;\n  this.q = p2;\n\n  if (p1.y > p2.y) {\n    this.q = p1;\n    this.p = p2;\n  } else if (p1.y === p2.y) {\n    if (p1.x > p2.x) {\n      this.q = p1;\n      this.p = p2;\n    } else if (p1.x === p2.x) {\n      throw new Error('poly2tri Invalid Edge constructor: repeated points!', [p1]);\n    }\n  }\n\n  if (!this.q._p2t_edge_list) {\n    this.q._p2t_edge_list = [];\n  }\n  this.q._p2t_edge_list.push(this);\n};\n\nlmv_poly2tri.SweepContext.prototype.initEdges = function(polyline, isOpen) {\n    var i, len = polyline.length, iEnd = isOpen ? polyline.length-1 : polyline.length;\n    for (i = 0; i < iEnd; ++i) {\n        this.edge_list.push(new Edge(polyline[i], polyline[(i + 1) % len]));\n    }\n};\n\nmodule.exports = lmv_poly2tri;","\nvar av = Autodesk.Viewing;\nvar avecg = AutodeskNamespace('Autodesk.Viewing.Extensions.CompGeom');\n\nfunction _export(m, ns) {\n    for (var prop in m) {\n        if (Object.prototype.hasOwnProperty.call(m, prop)) {\n            //Export directly into the module (e.g. for node.js use, where LMV is used via require instead from global namespace)\n            module.exports[prop] = m[prop];\n\n            //Export into the desired viewer namespace\n            ns[prop] = m[prop];\n        }\n    }\n}\n\n_export(require(\"./contour-set\"), avecg);\n_export(require(\"./edge-set\"), avecg);\n_export(require(\"./dcel\"), avecg);\n_export(require(\"./fuzzy-math\"), avecg);\n_export(require(\"./quad-tree\"), avecg);\n_export(require(\"./x-box-box\"), avecg);\n_export(require(\"./x-box-plane\"), avecg);\n_export(require(\"./x-line-box\"), avecg);\n_export(require(\"./x-line-line\"), avecg);\n_export(require(\"./x-mesh-plane\"), avecg);\n_export(require(\"./x-plane-segment\"), avecg);\n_export(require(\"./x-triangle-plane\"), avecg);\n_export(require(\"./interval-tree\"), avecg);\n_export(require(\"./complex-polygon\"), avecg);\n_export(require(\"./point-list\"), avecg);\n_export(require(\"./ThirdParty/lmv_poly2tri\"), avecg);\n_export(require(\"./ellipse\"), avecg);\n_export(require(\"./bezier\"), avecg);\n_export(require(\"./LmvCanvasContext\"), avecg);\n_export(require(\"./path2d\"), avecg);\n\n/**\n * Computational geometry library extension\n */\nclass  CompGeomExtension extends av.Extension {\n\n    constructor(viewer, options) {\n        super(viewer, options);\n    }\n\n    load() { return true; }\n    unload() { return true; }\n    activate() { return true; }\n    deactivate() { return false; }\n}\n\n// The ExtensionManager requires an extension to be registered.\nav.theExtensionManager.registerExtension('Autodesk.CompGeom', CompGeomExtension);\n\n","/*\n * Poly2Tri Copyright (c) 2009-2014, Poly2Tri Contributors\n * http://code.google.com/p/poly2tri/\n * \n * poly2tri.js (JavaScript port) (c) 2009-2014, Poly2Tri Contributors\n * https://github.com/r3mi/poly2tri.js\n *\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *\n * * Redistributions of source code must retain the above copyright notice,\n *   this list of conditions and the following disclaimer.\n * * Redistributions in binary form must reproduce the above copyright notice,\n *   this list of conditions and the following disclaimer in the documentation\n *   and/or other materials provided with the distribution.\n * * Neither the name of Poly2Tri nor the names of its contributors may be\n *   used to endorse or promote products derived from this software without specific\n *   prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR\n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n\"use strict\";\n\n/**\n * Public API for poly2tri.js\n * @module poly2tri\n */\n\n\n/**\n * If you are not using a module system (e.g. CommonJS, RequireJS), you can access this library\n * as a global variable <code>poly2tri</code> i.e. <code>window.poly2tri</code> in a browser.\n * @name poly2tri\n * @global\n * @public\n * @type {module:poly2tri}\n */\nvar previousPoly2tri = global.poly2tri;\n/**\n * For Browser + &lt;script&gt; :\n * reverts the {@linkcode poly2tri} global object to its previous value,\n * and returns a reference to the instance called.\n *\n * @example\n *              var p = poly2tri.noConflict();\n * @public\n * @return {module:poly2tri} instance called\n */\n// (this feature is not automatically provided by browserify).\nexports.noConflict = function() {\n    global.poly2tri = previousPoly2tri;\n    return exports;\n};\n\n/**\n * poly2tri library version\n * @public\n * @const {string}\n */\nexports.VERSION = require('../dist/version.json').version;\n\n/**\n * Exports the {@linkcode PointError} class.\n * @public\n * @typedef {PointError} module:poly2tri.PointError\n * @function\n */\nexports.PointError = require('./pointerror');\n/**\n * Exports the {@linkcode Point} class.\n * @public\n * @typedef {Point} module:poly2tri.Point\n * @function\n */\nexports.Point = require('./point');\n/**\n * Exports the {@linkcode Triangle} class.\n * @public\n * @typedef {Triangle} module:poly2tri.Triangle\n * @function\n */\nexports.Triangle = require('./triangle');\n/**\n * Exports the {@linkcode SweepContext} class.\n * @public\n * @typedef {SweepContext} module:poly2tri.SweepContext\n * @function\n */\nexports.SweepContext = require('./sweepcontext');\n\n\n// Backward compatibility\nvar sweep = require('./sweep');\n/**\n * @function\n * @deprecated use {@linkcode SweepContext#triangulate} instead\n */\nexports.triangulate = sweep.triangulate;\n/**\n * @deprecated use {@linkcode SweepContext#triangulate} instead\n * @property {function} Triangulate - use {@linkcode SweepContext#triangulate} instead\n */\nexports.sweep = {Triangulate: sweep.triangulate};\n","/*\n * Poly2Tri Copyright (c) 2009-2014, Poly2Tri Contributors\n * http://code.google.com/p/poly2tri/\n * \n * poly2tri.js (JavaScript port) (c) 2009-2014, Poly2Tri Contributors\n * https://github.com/r3mi/poly2tri.js\n * \n * All rights reserved.\n * \n * Distributed under the 3-clause BSD License, see LICENSE.txt\n */\n\n/* jshint maxcomplexity:6 */\n\n\"use strict\";\n\n\n/*\n * Note\n * ====\n * the structure of this JavaScript version of poly2tri intentionally follows\n * as closely as possible the structure of the reference C++ version, to make it \n * easier to keep the 2 versions in sync.\n */\n\nvar PointError = require('./pointerror');\nvar Point = require('./point');\nvar Triangle = require('./triangle');\nvar sweep = require('./sweep');\nvar AdvancingFront = require('./advancingfront');\nvar Node = AdvancingFront.Node;\n\n\n// ------------------------------------------------------------------------utils\n\n/**\n * Initial triangle factor, seed triangle will extend 30% of\n * PointSet width to both left and right.\n * @private\n * @const\n */\nvar kAlpha = 0.3;\n\n\n// -------------------------------------------------------------------------Edge\n/**\n * Represents a simple polygon's edge\n * @constructor\n * @struct\n * @private\n * @param {Point} p1\n * @param {Point} p2\n * @throw {PointError} if p1 is same as p2\n */\nvar Edge = function(p1, p2) {\n    this.p = p1;\n    this.q = p2;\n\n    if (p1.y > p2.y) {\n        this.q = p1;\n        this.p = p2;\n    } else if (p1.y === p2.y) {\n        if (p1.x > p2.x) {\n            this.q = p1;\n            this.p = p2;\n        } else if (p1.x === p2.x) {\n            throw new PointError('poly2tri Invalid Edge constructor: repeated points!', [p1]);\n        }\n    }\n\n    if (!this.q._p2t_edge_list) {\n        this.q._p2t_edge_list = [];\n    }\n    this.q._p2t_edge_list.push(this);\n};\n\n\n// ------------------------------------------------------------------------Basin\n/**\n * @constructor\n * @struct\n * @private\n */\nvar Basin = function() {\n    /** @type {Node} */\n    this.left_node = null;\n    /** @type {Node} */\n    this.bottom_node = null;\n    /** @type {Node} */\n    this.right_node = null;\n    /** @type {number} */\n    this.width = 0.0;\n    /** @type {boolean} */\n    this.left_highest = false;\n};\n\nBasin.prototype.clear = function() {\n    this.left_node = null;\n    this.bottom_node = null;\n    this.right_node = null;\n    this.width = 0.0;\n    this.left_highest = false;\n};\n\n// --------------------------------------------------------------------EdgeEvent\n/**\n * @constructor\n * @struct\n * @private\n */\nvar EdgeEvent = function() {\n    /** @type {Edge} */\n    this.constrained_edge = null;\n    /** @type {boolean} */\n    this.right = false;\n};\n\n// ----------------------------------------------------SweepContext (public API)\n/**\n * SweepContext constructor option\n * @typedef {Object} SweepContextOptions\n * @property {boolean=} cloneArrays - if <code>true</code>, do a shallow copy of the Array parameters\n *                  (contour, holes). Points inside arrays are never copied.\n *                  Default is <code>false</code> : keep a reference to the array arguments,\n *                  who will be modified in place.\n */\n/**\n * Constructor for the triangulation context.\n * It accepts a simple polyline (with non repeating points), \n * which defines the constrained edges.\n *\n * @example\n *          var contour = [\n *              new poly2tri.Point(100, 100),\n *              new poly2tri.Point(100, 300),\n *              new poly2tri.Point(300, 300),\n *              new poly2tri.Point(300, 100)\n *          ];\n *          var swctx = new poly2tri.SweepContext(contour, {cloneArrays: true});\n * @example\n *          var contour = [{x:100, y:100}, {x:100, y:300}, {x:300, y:300}, {x:300, y:100}];\n *          var swctx = new poly2tri.SweepContext(contour, {cloneArrays: true});\n * @constructor\n * @public\n * @struct\n * @param {Array.<XY>} contour - array of point objects. The points can be either {@linkcode Point} instances,\n *          or any \"Point like\" custom class with <code>{x, y}</code> attributes.\n * @param {SweepContextOptions=} options - constructor options\n */\nvar SweepContext = function(contour, options) {\n    options = options || {};\n    this.triangles_ = [];\n    this.map_ = [];\n    this.points_ = (options.cloneArrays ? contour.slice(0) : contour);\n    this.edge_list = [];\n\n    // Bounding box of all points. Computed at the start of the triangulation, \n    // it is stored in case it is needed by the caller.\n    this.pmin_ = this.pmax_ = null;\n\n    /**\n     * Advancing front\n     * @private\n     * @type {AdvancingFront}\n     */\n    this.front_ = null;\n\n    /**\n     * head point used with advancing front\n     * @private\n     * @type {Point}\n     */\n    this.head_ = null;\n\n    /**\n     * tail point used with advancing front\n     * @private\n     * @type {Point}\n     */\n    this.tail_ = null;\n\n    /**\n     * @private\n     * @type {Node}\n     */\n    this.af_head_ = null;\n    /**\n     * @private\n     * @type {Node}\n     */\n    this.af_middle_ = null;\n    /**\n     * @private\n     * @type {Node}\n     */\n    this.af_tail_ = null;\n\n    this.basin = new Basin();\n    this.edge_event = new EdgeEvent();\n\n    this.initEdges(this.points_);\n};\n\n\n/**\n * Add a hole to the constraints\n * @example\n *      var swctx = new poly2tri.SweepContext(contour);\n *      var hole = [\n *          new poly2tri.Point(200, 200),\n *          new poly2tri.Point(200, 250),\n *          new poly2tri.Point(250, 250)\n *      ];\n *      swctx.addHole(hole);\n * @example\n *      var swctx = new poly2tri.SweepContext(contour);\n *      swctx.addHole([{x:200, y:200}, {x:200, y:250}, {x:250, y:250}]);\n * @public\n * @param {Array.<XY>} polyline - array of \"Point like\" objects with {x,y}\n */\nSweepContext.prototype.addHole = function(polyline) {\n    this.initEdges(polyline);\n    var i, len = polyline.length;\n    for (i = 0; i < len; i++) {\n        this.points_.push(polyline[i]);\n    }\n    return this; // for chaining\n};\n\n/**\n * For backward compatibility\n * @function\n * @deprecated use {@linkcode SweepContext#addHole} instead\n */\nSweepContext.prototype.AddHole = SweepContext.prototype.addHole;\n\n\n/**\n * Add several holes to the constraints\n * @example\n *      var swctx = new poly2tri.SweepContext(contour);\n *      var holes = [\n *          [ new poly2tri.Point(200, 200), new poly2tri.Point(200, 250), new poly2tri.Point(250, 250) ],\n *          [ new poly2tri.Point(300, 300), new poly2tri.Point(300, 350), new poly2tri.Point(350, 350) ]\n *      ];\n *      swctx.addHoles(holes);\n * @example\n *      var swctx = new poly2tri.SweepContext(contour);\n *      var holes = [\n *          [{x:200, y:200}, {x:200, y:250}, {x:250, y:250}],\n *          [{x:300, y:300}, {x:300, y:350}, {x:350, y:350}]\n *      ];\n *      swctx.addHoles(holes);\n * @public\n * @param {Array.<Array.<XY>>} holes - array of array of \"Point like\" objects with {x,y}\n */\n// Method added in the JavaScript version (was not present in the c++ version)\nSweepContext.prototype.addHoles = function(holes) {\n    var i, len = holes.length;\n    for (i = 0; i < len; i++) {\n        this.initEdges(holes[i]);\n    }\n    this.points_ = this.points_.concat.apply(this.points_, holes);\n    return this; // for chaining\n};\n\n\n/**\n * Add a Steiner point to the constraints\n * @example\n *      var swctx = new poly2tri.SweepContext(contour);\n *      var point = new poly2tri.Point(150, 150);\n *      swctx.addPoint(point);\n * @example\n *      var swctx = new poly2tri.SweepContext(contour);\n *      swctx.addPoint({x:150, y:150});\n * @public\n * @param {XY} point - any \"Point like\" object with {x,y}\n */\nSweepContext.prototype.addPoint = function(point) {\n    this.points_.push(point);\n    return this; // for chaining\n};\n\n/**\n * For backward compatibility\n * @function\n * @deprecated use {@linkcode SweepContext#addPoint} instead\n */\nSweepContext.prototype.AddPoint = SweepContext.prototype.addPoint;\n\n\n/**\n * Add several Steiner points to the constraints\n * @example\n *      var swctx = new poly2tri.SweepContext(contour);\n *      var points = [\n *          new poly2tri.Point(150, 150),\n *          new poly2tri.Point(200, 250),\n *          new poly2tri.Point(250, 250)\n *      ];\n *      swctx.addPoints(points);\n * @example\n *      var swctx = new poly2tri.SweepContext(contour);\n *      swctx.addPoints([{x:150, y:150}, {x:200, y:250}, {x:250, y:250}]);\n * @public\n * @param {Array.<XY>} points - array of \"Point like\" object with {x,y}\n */\n// Method added in the JavaScript version (was not present in the c++ version)\nSweepContext.prototype.addPoints = function(points) {\n    this.points_ = this.points_.concat(points);\n    return this; // for chaining\n};\n\n\n/**\n * Triangulate the polygon with holes and Steiner points.\n * Do this AFTER you've added the polyline, holes, and Steiner points\n * @example\n *      var swctx = new poly2tri.SweepContext(contour);\n *      swctx.triangulate();\n *      var triangles = swctx.getTriangles();\n * @public\n */\n// Shortcut method for sweep.triangulate(SweepContext).\n// Method added in the JavaScript version (was not present in the c++ version)\nSweepContext.prototype.triangulate = function() {\n    sweep.triangulate(this);\n    return this; // for chaining\n};\n\n\n/**\n * Get the bounding box of the provided constraints (contour, holes and \n * Steinter points). Warning : these values are not available if the triangulation \n * has not been done yet.\n * @public\n * @returns {{min:Point,max:Point}} object with 'min' and 'max' Point\n */\n// Method added in the JavaScript version (was not present in the c++ version)\nSweepContext.prototype.getBoundingBox = function() {\n    return {min: this.pmin_, max: this.pmax_};\n};\n\n/**\n * Get result of triangulation.\n * The output triangles have vertices which are references\n * to the initial input points (not copies): any custom fields in the\n * initial points can be retrieved in the output triangles.\n * @example\n *      var swctx = new poly2tri.SweepContext(contour);\n *      swctx.triangulate();\n *      var triangles = swctx.getTriangles();\n * @example\n *      var contour = [{x:100, y:100, id:1}, {x:100, y:300, id:2}, {x:300, y:300, id:3}];\n *      var swctx = new poly2tri.SweepContext(contour);\n *      swctx.triangulate();\n *      var triangles = swctx.getTriangles();\n *      typeof triangles[0].getPoint(0).id\n *      //  \"number\"\n * @public\n * @returns {array<Triangle>}   array of triangles\n */\nSweepContext.prototype.getTriangles = function() {\n    return this.triangles_;\n};\n\n/**\n * For backward compatibility\n * @function\n * @deprecated use {@linkcode SweepContext#getTriangles} instead\n */\nSweepContext.prototype.GetTriangles = SweepContext.prototype.getTriangles;\n\n\n// ---------------------------------------------------SweepContext (private API)\n\n/** @private */\nSweepContext.prototype.front = function() {\n    return this.front_;\n};\n\n/** @private */\nSweepContext.prototype.pointCount = function() {\n    return this.points_.length;\n};\n\n/** @private */\nSweepContext.prototype.head = function() {\n    return this.head_;\n};\n\n/** @private */\nSweepContext.prototype.setHead = function(p1) {\n    this.head_ = p1;\n};\n\n/** @private */\nSweepContext.prototype.tail = function() {\n    return this.tail_;\n};\n\n/** @private */\nSweepContext.prototype.setTail = function(p1) {\n    this.tail_ = p1;\n};\n\n/** @private */\nSweepContext.prototype.getMap = function() {\n    return this.map_;\n};\n\n/** @private */\nSweepContext.prototype.initTriangulation = function() {\n    var xmax = this.points_[0].x;\n    var xmin = this.points_[0].x;\n    var ymax = this.points_[0].y;\n    var ymin = this.points_[0].y;\n\n    // Calculate bounds\n    var i, len = this.points_.length;\n    for (i = 1; i < len; i++) {\n        var p = this.points_[i];\n        /* jshint expr:true */\n        (p.x > xmax) && (xmax = p.x);\n        (p.x < xmin) && (xmin = p.x);\n        (p.y > ymax) && (ymax = p.y);\n        (p.y < ymin) && (ymin = p.y);\n    }\n    this.pmin_ = new Point(xmin, ymin);\n    this.pmax_ = new Point(xmax, ymax);\n\n    var dx = kAlpha * (xmax - xmin);\n    var dy = kAlpha * (ymax - ymin);\n    this.head_ = new Point(xmax + dx, ymin - dy);\n    this.tail_ = new Point(xmin - dx, ymin - dy);\n\n    // Sort points along y-axis\n    this.points_.sort(Point.compare);\n};\n\n/** @private */\nSweepContext.prototype.initEdges = function(polyline) {\n    var i, len = polyline.length;\n    for (i = 0; i < len; ++i) {\n        this.edge_list.push(new Edge(polyline[i], polyline[(i + 1) % len]));\n    }\n};\n\n/** @private */\nSweepContext.prototype.getPoint = function(index) {\n    return this.points_[index];\n};\n\n/** @private */\nSweepContext.prototype.addToMap = function(triangle) {\n    this.map_.push(triangle);\n};\n\n/** @private */\nSweepContext.prototype.locateNode = function(point) {\n    return this.front_.locateNode(point.x);\n};\n\n/** @private */\nSweepContext.prototype.createAdvancingFront = function() {\n    var head;\n    var middle;\n    var tail;\n    // Initial triangle\n    var triangle = new Triangle(this.points_[0], this.tail_, this.head_);\n\n    this.map_.push(triangle);\n\n    head = new Node(triangle.getPoint(1), triangle);\n    middle = new Node(triangle.getPoint(0), triangle);\n    tail = new Node(triangle.getPoint(2));\n\n    this.front_ = new AdvancingFront(head, tail);\n\n    head.next = middle;\n    middle.next = tail;\n    middle.prev = head;\n    tail.prev = middle;\n};\n\n/** @private */\nSweepContext.prototype.removeNode = function(node) {\n    // do nothing\n    /* jshint unused:false */\n};\n\n/** @private */\nSweepContext.prototype.mapTriangleToNodes = function(t) {\n    for (var i = 0; i < 3; ++i) {\n        if (!t.getNeighbor(i)) {\n            var n = this.front_.locatePoint(t.pointCW(t.getPoint(i)));\n            if (n) {\n                n.triangle = t;\n            }\n        }\n    }\n};\n\n/** @private */\nSweepContext.prototype.removeFromMap = function(triangle) {\n    var i, map = this.map_, len = map.length;\n    for (i = 0; i < len; i++) {\n        if (map[i] === triangle) {\n            map.splice(i, 1);\n            break;\n        }\n    }\n};\n\n/**\n * Do a depth first traversal to collect triangles\n * @private\n * @param {Triangle} triangle start\n */\nSweepContext.prototype.meshClean = function(triangle) {\n    // New implementation avoids recursive calls and use a loop instead.\n    // Cf. issues # 57, 65 and 69.\n    var triangles = [triangle], t, i;\n    /* jshint boss:true */\n    while (t = triangles.pop()) {\n        if (!t.isInterior()) {\n            t.setInterior(true);\n            this.triangles_.push(t);\n            for (i = 0; i < 3; i++) {\n                if (!t.constrained_edge[i]) {\n                    triangles.push(t.getNeighbor(i));\n                }\n            }\n        }\n    }\n};\n\n// ----------------------------------------------------------------------Exports\n\nmodule.exports = SweepContext;\n","/*\n * Poly2Tri Copyright (c) 2009-2014, Poly2Tri Contributors\n * http://code.google.com/p/poly2tri/\n *\n * poly2tri.js (JavaScript port) (c) 2009-2014, Poly2Tri Contributors\n * https://github.com/r3mi/poly2tri.js\n *\n * All rights reserved.\n *\n * Distributed under the 3-clause BSD License, see LICENSE.txt\n */\n\n\"use strict\";\n\n/*\n * Function added in the JavaScript version (was not present in the c++ version)\n */\n\n/**\n * assert and throw an exception.\n *\n * @private\n * @param {boolean} condition   the condition which is asserted\n * @param {string} message      the message which is display is condition is falsy\n */\nfunction assert(condition, message) {\n    if (!condition) {\n        throw new Error(message || \"Assert Failed\");\n    }\n}\nmodule.exports = assert;\n\n\n","/*\n * Poly2Tri Copyright (c) 2009-2014, Poly2Tri Contributors\n * http://code.google.com/p/poly2tri/\n * \n * poly2tri.js (JavaScript port) (c) 2009-2014, Poly2Tri Contributors\n * https://github.com/r3mi/poly2tri.js\n * \n * All rights reserved.\n * \n * Distributed under the 3-clause BSD License, see LICENSE.txt\n */\n\n\"use strict\";\n\n/**\n * Precision to detect repeated or collinear points\n * @private\n * @const {number}\n * @default\n */\nvar EPSILON = 1e-12;\nexports.EPSILON = EPSILON;\n\n/**\n * @private\n * @enum {number}\n * @readonly\n */\nvar Orientation = {\n    \"CW\": 1,\n    \"CCW\": -1,\n    \"COLLINEAR\": 0\n};\nexports.Orientation = Orientation;\n\n\n/**\n * Formula to calculate signed area<br>\n * Positive if CCW<br>\n * Negative if CW<br>\n * 0 if collinear<br>\n * <pre>\n * A[P1,P2,P3]  =  (x1*y2 - y1*x2) + (x2*y3 - y2*x3) + (x3*y1 - y3*x1)\n *              =  (x1-x3)*(y2-y3) - (y1-y3)*(x2-x3)\n * </pre>\n *\n * @private\n * @param {!XY} pa  point object with {x,y}\n * @param {!XY} pb  point object with {x,y}\n * @param {!XY} pc  point object with {x,y}\n * @return {Orientation}\n */\nfunction orient2d(pa, pb, pc) {\n    var detleft = (pa.x - pc.x) * (pb.y - pc.y);\n    var detright = (pa.y - pc.y) * (pb.x - pc.x);\n    var val = detleft - detright;\n    if (val > -(EPSILON) && val < (EPSILON)) {\n        return Orientation.COLLINEAR;\n    } else if (val > 0) {\n        return Orientation.CCW;\n    } else {\n        return Orientation.CW;\n    }\n}\nexports.orient2d = orient2d;\n\n\n/**\n *\n * @private\n * @param {!XY} pa  point object with {x,y}\n * @param {!XY} pb  point object with {x,y}\n * @param {!XY} pc  point object with {x,y}\n * @param {!XY} pd  point object with {x,y}\n * @return {boolean}\n */\nfunction inScanArea(pa, pb, pc, pd) {\n    var oadb = (pa.x - pb.x) * (pd.y - pb.y) - (pd.x - pb.x) * (pa.y - pb.y);\n    if (oadb >= -EPSILON) {\n        return false;\n    }\n\n    var oadc = (pa.x - pc.x) * (pd.y - pc.y) - (pd.x - pc.x) * (pa.y - pc.y);\n    if (oadc <= EPSILON) {\n        return false;\n    }\n    return true;\n}\nexports.inScanArea = inScanArea;\n\n\n/**\n * Check if the angle between (pa,pb) and (pa,pc) is obtuse i.e. (angle > /2 || angle < -/2)\n *\n * @private\n * @param {!XY} pa  point object with {x,y}\n * @param {!XY} pb  point object with {x,y}\n * @param {!XY} pc  point object with {x,y}\n * @return {boolean} true if angle is obtuse\n */\nfunction isAngleObtuse(pa, pb, pc) {\n    var ax = pb.x - pa.x;\n    var ay = pb.y - pa.y;\n    var bx = pc.x - pa.x;\n    var by = pc.y - pa.y;\n    return (ax * bx + ay * by) < 0;\n}\nexports.isAngleObtuse = isAngleObtuse;\n\n","import { IntervalTree } from \"./interval-tree\";\r\nimport { UniquePointList } from \"./point-list\";\r\nimport { ComplexPolygon } from \"./complex-polygon\";\r\n\r\n    var avp = Autodesk.Viewing.Private;\r\n\r\n    //Functionality for converting a list of two-point line segments into a connected\r\n    //set of (hopefully) closed contour lines. The contour set is then used\r\n    //for triangulation.\r\n    //This data structure assumes there are no intersecting edges (use the DCEL if there are, or you need fully-connected topology).\r\n    export class EdgeSet {\r\n\r\n            constructor(edges, bbox, precisionTolerance) {\r\n\r\n            this.edges = edges;\r\n            this.bbox = bbox;\r\n\r\n            this.verts = new UniquePointList(bbox, precisionTolerance);\r\n            this.polygon = null;\r\n        }\r\n\r\n\r\n        getPointIndex(px, py) {\r\n\r\n            let v = this.verts.findOrAddPoint(px, py);\r\n\r\n            return v.id;\r\n        }\r\n\r\n        snapEdges() {\r\n\r\n            for (var i=0; i<this.edges.length; i++) {\r\n\r\n                var e = this.edges[i];\r\n\r\n                e.p1 = this.getPointIndex(e.v1.x, e.v1.y);\r\n                e.p2 = this.getPointIndex(e.v2.x, e.v2.y);\r\n            }\r\n        }\r\n\r\n        sanitizeEdges() {\r\n            var edgeSet = {};\r\n            var sanitizedEdges = [];\r\n\r\n            for (var i = 0, len = this.edges.length; i < len; i++) {\r\n                var e = this.edges[i];\r\n                if (e.p1 === e.p2) {\r\n                    continue;\r\n                }\r\n\r\n                var key = Math.min(e.p1, e.p2) + ':' + Math.max(e.p1, e.p2);\r\n                if (edgeSet[key] !== true) {\r\n                    edgeSet[key] = true;\r\n                    sanitizedEdges.push(e);\r\n                }\r\n            }\r\n\r\n            this.edges = sanitizedEdges;\r\n        }\r\n\r\n\r\n        stitchContours() {\r\n\r\n            this.contours = [];\r\n\r\n            //Create jump table from edge to edge\r\n            //and back\r\n            var edge_table = {};\r\n\r\n            for (var i=0; i<this.edges.length; i++) {\r\n                var e = this.edges[i];\r\n\r\n                if (e.p1 === e.p2)\r\n                    continue;\r\n\r\n                if (edge_table[e.p1] !== undefined)\r\n                    edge_table[e.p1].push(e.p2);\r\n                else\r\n                    edge_table[e.p1] = [e.p2];\r\n\r\n                if (edge_table[e.p2] !== undefined)\r\n                    edge_table[e.p2].push(e.p1);\r\n                else\r\n                    edge_table[e.p2] = [e.p1];\r\n            }\r\n\r\n            var cur_cntr = [];\r\n\r\n            for (var p in edge_table) {\r\n                if (edge_table[p].length !== 2) {\r\n                    avp.logger.warn(\"Incomplete edge table\");\r\n                    break;\r\n                }\r\n            }\r\n\r\n            //Start with the first edge, and stitch until we can no longer\r\n            // eslint-disable-next-line no-constant-condition\r\n            while (true) {\r\n\r\n                var sfrom = undefined;\r\n\r\n                //Look for doubly connected point first\r\n                for (let p in edge_table) {\r\n                    if (edge_table[p].length > 1) {\r\n                        sfrom = p;\r\n                        break;\r\n                    }\r\n                }\r\n\r\n                //If no double-connected point found, we know\r\n                //the it will be an open contour, but stitch as much\r\n                //as we can anyway.\r\n                if (!sfrom) {\r\n                    for (let p in edge_table) {\r\n                        if (edge_table[p].length > 0) {\r\n                            sfrom = p;\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n\r\n                if (!sfrom)\r\n                    break;\r\n\r\n                var prev = -1;\r\n                var cur = parseInt(sfrom);\r\n                var cur_segs = edge_table[sfrom];\r\n\r\n                //start a new contour\r\n                cur_cntr.push(cur);\r\n\r\n                while (cur_segs && cur_segs.length) {\r\n\r\n                    var toPt = cur_segs.shift();\r\n\r\n                    //skip backpointer if we hit it\r\n                    if (toPt === prev)\r\n                        toPt = cur_segs.shift();\r\n\r\n                    if (toPt === undefined) {\r\n                        delete edge_table[cur];\r\n                        break;\r\n                    }\r\n\r\n                    cur_cntr.push(toPt);\r\n\r\n                    if (cur_segs.length == 0)\r\n                        delete edge_table[cur];\r\n                    else if (cur_segs[0] === prev)\r\n                        delete edge_table[cur];\r\n\r\n                    prev = cur;\r\n                    cur = toPt;\r\n                    cur_segs = edge_table[toPt];\r\n                }\r\n\r\n                if (cur_cntr.length) {\r\n                    this.contours.push(cur_cntr);\r\n                    cur_cntr = [];\r\n                }\r\n            }\r\n\r\n            var openCntrs = [];\r\n            for (let i=0; i<this.contours.length; i++) {\r\n                var cntr = this.contours[i];\r\n                if (cntr[0] !== cntr[cntr.length-1])\r\n                    openCntrs.push(cntr);\r\n            }\r\n\r\n\r\n            if (openCntrs.length) {\r\n                //avp.logger.warn(\"Incomplete stitch\");\r\n\r\n                var didSomething = true;\r\n                while (didSomething) {\r\n\r\n                    didSomething = false;\r\n\r\n                    //Try to combine contours\r\n                    var cntr_edge_table = {};\r\n                    var contours = this.contours;\r\n\r\n                    for (let i=0; i<contours.length; i++) {\r\n                        const cntr = contours[i];\r\n                        var start = cntr[0];\r\n                        var end = cntr[cntr.length-1];\r\n\r\n                        if (start === end)\r\n                            continue;\r\n\r\n                        if (!cntr_edge_table[start])\r\n                            cntr_edge_table[start] = [-i-1];\r\n                        else\r\n                            cntr_edge_table[start].push(-i-1);\r\n\r\n\r\n                        if (!cntr_edge_table[end])\r\n                            cntr_edge_table[end] = [i];\r\n                        else\r\n                            cntr_edge_table[end].push(i);\r\n                    }\r\n\r\n                    for (let p in cntr_edge_table) {\r\n                        var entry = cntr_edge_table[p];\r\n\r\n                        if (entry.length == 2) {\r\n                            var toerase = undefined;\r\n\r\n                            if (entry[0] < 0 && entry[1] < 0) {\r\n                                var c1 = -entry[0]-1; var c2 = -entry[1]-1;\r\n                                //join start point to startpoint\r\n                                contours[c2].shift();\r\n                                Array.prototype.push.apply(contours[c1].reverse(),contours[c2]);\r\n                                toerase = c2;\r\n                            }\r\n\r\n                            if (entry[0] < 0 && entry[1] > 0) {\r\n                                const c1 = -entry[0]-1;\r\n                                const c2 = entry[1];\r\n                                //join start point to endpoint\r\n                                contours[c2].pop();\r\n                                Array.prototype.push.apply(contours[c2], contours[c1]);\r\n                                toerase = c1;\r\n                            }\r\n\r\n                            if (entry[0] > 0 && entry[1] < 0) {\r\n                                const c1 = entry[0];\r\n                                const c2 = -entry[1]-1;\r\n                                //join end point to startpoint\r\n                                contours[c1].pop();\r\n                                Array.prototype.push.apply(contours[c1], contours[c2]);\r\n                                toerase = c2;\r\n                            }\r\n\r\n                            if (entry[0] > 0 && entry[1] > 0) {\r\n                                const c1 = entry[0];\r\n                                const c2 = entry[1];\r\n                                //join end point to endpoint\r\n                                contours[c1].pop();\r\n                                Array.prototype.push.apply(contours[c1], contours[c2].reverse());\r\n                                toerase = c2;\r\n                            }\r\n\r\n                            if (toerase !== undefined) {\r\n                                contours.splice(toerase, 1);\r\n                                didSomething = true;\r\n                            }\r\n                            break;\r\n                        }\r\n                    }\r\n\r\n                }\r\n\r\n            }\r\n        }\r\n\r\n\r\n        cleanupFlatEdges() {\r\n\r\n            let pts = this.verts.pts;\r\n            let TOL = this.verts.precisionTolerance;\r\n\r\n            for (let i=0; i<this.contours.length; i++) {\r\n\r\n                let cntr = this.contours[i];\r\n\r\n                // eslint-disable-next-line no-constant-condition\r\n                while (true) {\r\n                    let removePt = -1;\r\n\r\n                    for (let j=1; j<cntr.length-1; j++) {\r\n                        let prev = cntr[j-1];\r\n                        let cur = cntr[j];\r\n                        let next = cntr[j+1];\r\n\r\n                        let p0 = pts[prev];\r\n                        let p1 = pts[cur];\r\n                        let p2 = pts[next];\r\n\r\n                        let dx1 = p1.x - p0.x;\r\n                        let dy1 = p1.y - p0.y;\r\n                        let dx2 = p2.x - p1.x;\r\n                        let dy2 = p2.y - p1.y;\r\n\r\n                        let len1 = Math.sqrt(dx1*dx1 + dy1*dy1);\r\n                        if (len1 < TOL) {\r\n                            removePt = j;\r\n                            break;\r\n                        }\r\n\r\n                        let len2 = Math.sqrt(dx2*dx2 + dy2*dy2);\r\n                        if (len2 < TOL) {\r\n                            removePt = j;\r\n                            break;\r\n                        }\r\n\r\n                        dx1 /= len1;\r\n                        dy1 /= len1;\r\n                        dx2 /= len2;\r\n                        dy2 /= len2;\r\n\r\n                        let dot = dx1*dx2 + dy1*dy2;\r\n\r\n                        if (Math.abs(dot - 1.0) < 1e-2) {\r\n                            removePt = j;\r\n                            break;\r\n                        }\r\n                    }\r\n\r\n                    if (removePt < 0)\r\n                        break;\r\n\r\n                    cntr.splice(removePt, 1);\r\n                }\r\n\r\n            }\r\n\r\n        }\r\n\r\n\r\n        triangulate() {\r\n\r\n            //this.cleanupFlatEdges();\r\n\r\n            //The interval tree is a faster and more tolerant\r\n            //way of checking if a point is inside the complex polygon defined\r\n            //by a set of edges. We use that in preference to the built-in\r\n            //ComplexPolygon inside checker.\r\n            let it = new IntervalTree(this.verts.pts, this.edges, this.bbox);\r\n            it.build();\r\n\r\n            let polygon = new ComplexPolygon(this.verts.pts, it, this.bbox);\r\n            polygon.contours = this.contours;\r\n            polygon.triangulate();\r\n            return polygon;\r\n\r\n        }\r\n\r\n\r\n    }\r\n","import { segmentsIntersect, pointOnLine } from \"./x-line-line\";\r\nimport { isZero, isEqual, TOL } from \"./fuzzy-math\";\r\nimport { ContourSet } from \"./contour-set\";\r\nimport { QuadTree } from \"./quad-tree\";\r\nimport { UniquePointList } from \"./point-list\";\r\n\r\nconst avp = Autodesk.Viewing.Private;\r\nconst logger = avp.logger;\r\n\r\nclass Vertex {\r\n\r\n    constructor(x, y) {\r\n        this.x = x;\r\n        this.y = y;\r\n\r\n        this.edges = [];\r\n        this.dbIds = [];\r\n        this.dbIdsChanged = false;\r\n    }\r\n\r\n    isDegenerate() {\r\n        return this.edges.length < 2;\r\n    }\r\n\r\n    addEdge(de) {\r\n\r\n        //Make sure the same edge doesn't already exist\r\n        for (let i=0; i<this.edges.length; i++) {\r\n\r\n            let e = this.edges[i];\r\n\r\n            //We already have the exact same edge, return existing id\r\n            if (e.v1 === de.v1 && e.v2 === de.v2)\r\n                return e;\r\n        }\r\n\r\n        //Add the edge\r\n        this.edges.push(de);\r\n        return de;\r\n    }\r\n\r\n    removeEdge(de) {\r\n        let idx = this.edges.indexOf(de);\r\n        if (idx >= 0)\r\n            this.edges.splice(idx, 1);\r\n        else\r\n            logger.warn(\"Failed to find edge in vertex list\");\r\n    }\r\n\r\n    findEdgeTo(v) {\r\n        for (let i=0; i<this.edges.length; i++) {\r\n            let e = this.edges[i];\r\n            if (e.getOppositeVertex(this) ===  v)\r\n                return e;\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    //TODO: make use of this when removing redundant vertices\r\n    disconnect() {\r\n        for (let i=0; i<this.edges.length; i++) {\r\n            let e = this.edges[i];\r\n            e.getOppositeVertex(this).removeEdge(e);\r\n        }\r\n\r\n        let res = this.edges;\r\n        this.edges = [];\r\n\r\n        //Return the edges that got orphaned and need deletion \r\n        //from the parent structure\r\n        return res;\r\n    }\r\n\r\n    sortEdges() {\r\n\r\n        this.edges.sort((a, b) => {\r\n            let angle1 = a.angle;\r\n            if (a.v1 !== this) {\r\n                angle1 -= Math.PI;\r\n            }\r\n\r\n            let angle2 = b.angle;\r\n            if (b.v1 !== this) {\r\n                angle2 -= Math.PI;\r\n            }\r\n\r\n            return angle1 - angle2;    \r\n        });\r\n\r\n    }\r\n\r\n    _canTraverse(e) {\r\n        //forward edge\r\n        if (e.v1 === this && !e.flagFwd) {\r\n            e.flagFwd = 1;\r\n            return true;\r\n        }\r\n\r\n        //reverse edge (points into this vertex)\r\n        if (e.v2 === this && !e.flagRev) {\r\n            e.flagRev = 1;\r\n            return true;    \r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    //Returns an edge that's not yet traversed during\r\n    //area finding\r\n    findUntraversedEdge() {\r\n        for (let i=0; i<this.edges.length; i++) {\r\n            let e = this.edges[i];\r\n\r\n            if (this._canTraverse(e))\r\n                return e;    \r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    //Assuming edges are already sorted,\r\n    //returns the edge that's immediately CCW to \r\n    //the given edge\r\n    findNextCCWEdge(e) {\r\n        \r\n        let idx = this.edges.indexOf(e);\r\n\r\n        if (idx === -1) {\r\n            logger.error(\"This edge isn't mine.\");\r\n            return null;\r\n        }\r\n\r\n        //Dangling vertex\r\n        if (this.isDegenerate()) {\r\n            return null;\r\n        }\r\n/*        \r\n        let idxNext = idx - 1;\r\n        if (idxNext < 0)\r\n            idxNext = this.edges.length -1;\r\n            */\r\n        let idxNext = (idx + 1) % this.edges.length;\r\n \r\n        let eNext = this.edges[idxNext];\r\n\r\n        if (this._canTraverse(eNext))\r\n            return eNext;\r\n\r\n        //logger.warn(\"Hmmm... Didn't find an edge to continue from here.\");\r\n        return null;\r\n    }\r\n\r\n}\r\n\r\n\r\nclass DirectedEdge {\r\n\r\n    constructor(v1, v2, id) {\r\n        let swap = false;\r\n\r\n        //Orient the edge so it has increasing dy and dx\r\n        if (v2.y < v1.y)\r\n            swap = true;\r\n        else if (v2.y === v1.y)\r\n            swap = (v2.x < v1.x);\r\n\r\n        //the coordinates stored in the edge\r\n        //might be slightly different from the vertex coordinates\r\n        //of the v1 and v2 vertices. The vertices are \"snapped\" to \r\n        //the nearest snap positin, while the edge coordinates are the \"original\" ones\r\n        //from the 3d mesh that generated the edge.\r\n        if (swap) {\r\n            this.v1 = v2;\r\n            this.v2 = v1;\r\n        } else {\r\n            this.v1 = v1;\r\n            this.v2 = v2;\r\n        }\r\n\r\n        this.dx = this.v2.x - this.v1.x;\r\n        this.dy = this.v2.y - this.v1.y;\r\n        this.length2 = this.dx * this.dx + this.dy * this.dy;\r\n        this.length = Math.sqrt(this.length2);\r\n        this.angle = Math.atan2(this.dy, this.dx);\r\n\r\n        if (this.angle < 0) {\r\n            if (isZero(this.angle))\r\n                this.angle = 0;\r\n            else if (isEqual(this.angle, -Math.PI))\r\n                this.angle = Math.PI;\r\n\r\n            if (this.angle < 0)    \r\n                logger.warn(\"Unexpected edge slope <0 :\", this.angle);\r\n        }\r\n\r\n        //the edge index in the edge list of the parent data structure\r\n        this.id = id;\r\n\r\n        this.minx = Math.min(this.v1.x, this.v2.x);\r\n        this.miny = Math.min(this.v1.y, this.v2.y);\r\n        this.maxx = Math.max(this.v1.x, this.v2.x);\r\n        this.maxy = Math.max(this.v1.y, this.v2.y);\r\n\r\n\r\n        //traversal flags, set temporarily \r\n        //during graph tarversal\r\n        this.flagFwd = 0;\r\n        this.flagRev = 0;\r\n\r\n        this.dbIdsCached = null;\r\n    }\r\n\r\n    paramAlong(x, y) {\r\n        let dot = (x - this.v1.x) * this.dx + (y - this.v1.y) * this.dy;\r\n        return dot / this.length2;\r\n    }\r\n\r\n    getOppositeVertex(v) {\r\n        if (this.v1 === v)\r\n            return this.v2;\r\n        else if (this.v2 === v)\r\n            return this.v1;\r\n        else\r\n            logger.warn(\"Edge does not own this vertex.\");\r\n    }\r\n\r\n    getDbIds() {\r\n        //Return all dbIds that are common between the two \r\n        //vertices of the edge. Used when splitting edges\r\n        //to pass the information to new vertices\r\n\r\n        if (!this.v1.dbIdsChanged && !this.v2.dbIdsChanged) {\r\n            return this.dbIdsCached;\r\n        }\r\n\r\n        //Calculate intersection of the dbId arrays of\r\n        //the two vertices.\r\n        let res = [];\r\n        let idv1 = this.v1.dbIds;\r\n        let idv2 = this.v2.dbIds;\r\n        for (let i=0; i<idv1.length; i++) {\r\n            if (idv2.indexOf(idv1[i]) !== -1)\r\n                res.push(idv1[i]);\r\n        }\r\n\r\n        //Cache the result so we don't recompute unnecessarily\r\n        //This requires cooperation by the vertex object change flag.\r\n        this.dbIdsCached = res;\r\n        this.v1.dbIdsChanged = false;\r\n        this.v2.dbIdsChanged = false;\r\n\r\n        return res;\r\n    }\r\n}\r\n\r\n\r\n\r\n//doubly connected edge list\r\nexport class DCEL {\r\n\r\n\r\n    constructor(bbox, precisionTolerance) {\r\n\r\n        this.bbox = bbox;\r\n        this.boxSize = this.bbox.size().length();\r\n\r\n        if (typeof precisionTolerance === \"number\") {\r\n            //Input is in model units, e.g. if model is in feet,\r\n            //precision tolerance has to be in feet\r\n            this.precisionTolerance = precisionTolerance;\r\n        } else {\r\n            this.precisionTolerance = TOL * this.boxSize;\r\n        }\r\n\r\n        this.edges = [];\r\n        this.verts = new UniquePointList(this.bbox, this.precisionTolerance, Vertex, true);\r\n\r\n        this.quadTreeEdges = new QuadTree(this.bbox.min.x, this.bbox.min.y, this.bbox.max.x, this.bbox.max.y, this.precisionTolerance);\r\n\r\n        this.nextEdgeId = 1;\r\n    }\r\n\r\n    _addVertex(px, py, dbIds) {\r\n        return this.verts.findOrAddPoint(px, py, dbIds);\r\n    }\r\n\r\n\r\n    splitEdge(de, points) {\r\n\r\n        let pts = [];\r\n\r\n        pts.push({\r\n            x: de.v1.x,\r\n            y:de.v1.y,\r\n            u:0\r\n        });\r\n\r\n        //Remember the originating objects for this edge, to set them on the\r\n        //resulting split edges\r\n        let dbIds = de.getDbIds();\r\n\r\n        for (let i=0; i<points.length; i+=2) {\r\n\r\n            let p = {\r\n                x: points[i],\r\n                y: points[i+1],\r\n                u: de.paramAlong(points[i], points[i+1])\r\n            };\r\n\r\n            if (isZero(p.u) || isEqual(p.u, 1))\r\n                continue;\r\n\r\n            pts.push(p);\r\n        }\r\n\r\n        //The intersection points were either on the beginning or on the end\r\n        //vertex of the edge, so splitting is not needed as it will result\r\n        //in a zero length edge.\r\n        if (pts.length === 1)\r\n            return;\r\n        \r\n        pts.push({\r\n            x: de.v2.x,\r\n            y: de.v2.y,\r\n            u:1\r\n        });\r\n\r\n        pts.sort((a, b) => {\r\n            return a.u - b.u;\r\n        });\r\n\r\n        //Remove the source edge\r\n        this.removeDirectedEdge(de);\r\n\r\n        //Add all the pieces that the edge was split into\r\n        for (let i=1; i<pts.length; i++) {\r\n            this.addDirectedEdge(pts[i-1].x, pts[i-1].y, pts[i].x, pts[i].y, true, dbIds);\r\n        }\r\n    }\r\n\r\n    _enumNearEdges(de, cb) {\r\n\r\n        this.quadTreeEdges.enumNearItems(de, cb);\r\n    }\r\n\r\n    addDirectedEdge(x1, y1, x2, y2, skipSplitting, dbIds) {\r\n        let v1 = this._addVertex(x1, y1, dbIds);\r\n        let v2 = this._addVertex(x2, y2, dbIds);\r\n\r\n        if (v1 === v2) {\r\n            //logger.warn(\"zero length edge\");\r\n            return;\r\n        }\r\n\r\n        if (v1.findEdgeTo(v2)) {\r\n            //edge already exists\r\n            return;\r\n        }\r\n\r\n        let de = new DirectedEdge(v1, v2, this.nextEdgeId++);\r\n\r\n        let addedEdge = de.v1.addEdge(de);\r\n\r\n        //If the edge did not already exist...\r\n        if (addedEdge === de) {\r\n            de.v2.addEdge(de);\r\n\r\n            //Remember the unsnapped positions used for this edge\r\n            de.sourcePts = [x1, y1, x2, y2];\r\n\r\n            this.edges[de.id] = de;\r\n\r\n            this.quadTreeEdges.addItem(de);\r\n        } else {\r\n            //Edge is already in the graph, nothing to do\r\n            return addedEdge;\r\n        }\r\n\r\n        if (skipSplitting)\r\n            return addedEdge;\r\n\r\n        //Now make sure the new edge doesn't overlap or intersect existing edges\r\n        //by finding and splitting any intersecting edges\r\n        let myInts = [];\r\n        let otherInts = {};\r\n\r\n        this._enumNearEdges(de, (e) => {\r\n            let ints = segmentsIntersect(e, de, this.precisionTolerance);\r\n\r\n            if (!ints)\r\n                return;\r\n\r\n            //Existing edge was crossed by new edge -- split it\r\n            if (ints.e1 && ints.e1.length) {\r\n                otherInts[e.id] = ints.e1;\r\n            }\r\n\r\n            //New edge crossed existing edge -- remember the intersection point for later\r\n            if (ints.e2 && ints.e2.length) {\r\n                myInts.push.apply(myInts, ints.e2);\r\n            }\r\n\r\n        });\r\n\r\n        for (let id in otherInts) {\r\n            this.splitEdge(this.edges[parseInt(id)], otherInts[id]);\r\n        }\r\n\r\n        if (myInts.length)\r\n            this.splitEdge(de, myInts);\r\n\r\n        this.dirty = true;            \r\n\r\n        return addedEdge;\r\n    }\r\n\r\n    removeDirectedEdge(de) {\r\n\r\n        de.v1.removeEdge(de);\r\n        de.v2.removeEdge(de);\r\n\r\n        this.edges[de.id] = undefined;\r\n\r\n        this.quadTreeEdges.deleteItem(de);\r\n    }\r\n\r\n    removeDanglingPolyline(startVertex) {\r\n\r\n        while (startVertex.edges.length === 1) {\r\n\r\n            let de = startVertex.edges[0];\r\n            let endVertex = de.getOppositeVertex(startVertex);\r\n            this.removeDirectedEdge(de);\r\n            startVertex = endVertex;\r\n        }\r\n\r\n    }\r\n\r\n    cleanupFlatEdges() {\r\n        //get rid of vertices that only have two parallel edges going into them\r\n\r\n        let removeList = [];\r\n\r\n        this.verts.forEach(v => {\r\n\r\n            if (!v)\r\n                return;\r\n\r\n            if (v.edges.length !== 2)\r\n                return;\r\n\r\n            let e1 = v.edges[0];\r\n            let e2 = v.edges[1];\r\n\r\n            //Detect co-linear edges\r\n            let angleDelta = Math.abs(e1.angle - e2.angle);\r\n            const ANGLE_TOLERANCE = 2e-3;\r\n            if (angleDelta < ANGLE_TOLERANCE || Math.abs(angleDelta - Math.PI) < ANGLE_TOLERANCE) {\r\n                removeList.push(v);\r\n            }\r\n\r\n            //Detect degenerate triangles\r\n            let v1 = e1.getOppositeVertex(v);\r\n            let v2 = e2.getOppositeVertex(v);\r\n            let eShared = v1.findEdgeTo(v2);\r\n\r\n            if (eShared) {\r\n                let area = 0.5 * Math.abs((e1.dx * e2.dy - e2.dx * e1.dy));\r\n                if (area < 1e-3) {\r\n                    removeList.push(v);\r\n                }\r\n            }\r\n\r\n            //TODO: more generic co-linearity and degeneracy heuristics...\r\n\r\n        });\r\n\r\n\r\n        //if (removeList.length)\r\n        //    logger.log(\"Redundant edges\", removeList.length);\r\n\r\n        for (let i=0; i<removeList.length; i++) {\r\n            \r\n            let v = removeList[i];\r\n\r\n            if (v.edges.length !== 2) {\r\n                //logger.warn(\"Number of edges changed\");\r\n                continue;\r\n            }\r\n\r\n            let e1 = v.edges[0];\r\n            let e2 = v.edges[1];\r\n\r\n            let vOther1 = e1.getOppositeVertex(v);\r\n            let vOther2 = e2.getOppositeVertex(v);\r\n\r\n            this.removeDirectedEdge(e1);\r\n            this.removeDirectedEdge(e2);\r\n\r\n            this.verts.delete(v);\r\n\r\n            this.addDirectedEdge(vOther1.x, vOther1.y, vOther2.x, vOther2.y, true);\r\n        }\r\n\r\n        //Clean up again, until no more redundant vertices exist\r\n        if (removeList.length)\r\n            return this.cleanupFlatEdges();\r\n    }\r\n\r\n\r\n\r\n    _compactLists() {\r\n\r\n        this.verts.compact();\r\n\r\n\r\n        let edges = [];\r\n\r\n        for (let i=0, len=this.edges.length; i<len; i++) {\r\n            let e = this.edges[i];\r\n            if (!e)\r\n                continue;\r\n\r\n            e.oldid = e.id;\r\n            e.flagFwd = 0;\r\n            e.flagRev = 0;\r\n            e.id = edges.length;\r\n            edges.push(e);\r\n        }\r\n\r\n        this.edges = edges;\r\n    }\r\n\r\n\r\n    //converts closed areas to polygons with holes, in a way where\r\n    //holes themseves are also marked as separate polygons in their own\r\n    //right, thus filling the whole area (i.e. non-zero fill method).\r\n    _detectHolesNonZero(customInsideChecker) {\r\n\r\n        this.holes = [];\r\n\r\n        //Skip the very largest polygon, because that is\r\n        //the overall model perimeter\r\n        //TODO: This logic is Location Breakdown specific\r\n        this.outerPerimeter = this.closedAreas[this.closedAreas.length-1];\r\n        if (this.outerPerimeter)\r\n            this.outerPerimeter.triangulate();\r\n\r\n        for (let i=0, len=this.closedAreas.length-1; i<len; i++) {\r\n\r\n            let cs = this.closedAreas[i];\r\n\r\n            //detect if the polygon is actually a hole in a\r\n            //bigger exterior polygon\r\n            //The logic we use here: if a polygon contains\r\n            //any of the smaller polygons inside it, it is a hole of a bigger polygon\r\n            //If a polygon contains a polygon marked as a hole, then add the hole to it\r\n            //before triangulating.\r\n            //TODO: this can be optimized via spatial index if number of polygons becomes large\r\n            for (let j=i-1; j>=0; j--) {\r\n                let cs2 = this.closedAreas[j];\r\n\r\n                //Only need to check a single point from the interior of the\r\n                //potential hole. Make sure it's inside the triangulation and not on the edge\r\n                //to avoid numeric noise.\r\n                if (cs.containsPointFrom(cs2)) {\r\n                    if (cs2.isHole) {\r\n                        cs.addContourSet(cs2);\r\n                    } else {\r\n                        cs.isHole = true;\r\n                        this.holes.push(cs);\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n\r\n            //We added all the holes, now triangulate again with the holes in mind\r\n            if (!cs.isHole) {\r\n                cs.triangulate(customInsideChecker);\r\n            }\r\n\r\n        }\r\n\r\n\r\n        //Do a second pass over just the holes\r\n        //and convert each hole that contains a hole\r\n        //to a real polygon area.\r\n        //TODO: I don't really know if this is mathematically correct...\r\n        for (let i=0, len=this.holes.length; i<len; i++) {\r\n\r\n            let cs = this.holes[i];\r\n\r\n            cs.triangulate(customInsideChecker);\r\n\r\n            //If a hole contains a hole inside it, then it is\r\n            //no longer hole, mark both as processed\r\n            for (let j=i-1; j>=0; j--) {\r\n\r\n                let cs2 = this.holes[j];\r\n\r\n                if (cs2.holeProcessFlag)\r\n                    continue;\r\n\r\n                //Only need to check a single point from the interior of the\r\n                //potential hole. Make sure it's inside the triangulation and not on the edge\r\n                //to avoid numeric noise.\r\n                if (cs.containsPointFrom(cs2)) {\r\n                    cs.addContourSet(cs2);\r\n                    cs.isHole = false;\r\n                    cs2.holeProcessFlag = true;\r\n                }\r\n            }\r\n\r\n            //We added all the holes, now triangulate again with the holes in mind\r\n            if (!cs.isHole) {\r\n                cs.triangulate(customInsideChecker);\r\n            }\r\n\r\n        }\r\n\r\n        //Remove all holes from the list of polygons\r\n        let filteredNonHoles = [];\r\n        for (let i=0; i<this.closedAreas.length-1; i++) {\r\n            let cs = this.closedAreas[i];\r\n            if (cs.isHole)\r\n                continue;\r\n\r\n            cs.id = filteredNonHoles.length;\r\n            filteredNonHoles.push(cs);\r\n        }\r\n\r\n        this.closedAreas = filteredNonHoles;\r\n\r\n\r\n    }\r\n\r\n    _detectHolesEvenOdd(customInsideChecker) {\r\n\r\n        let allAreas = this.closedAreas;\r\n        if (this.openAreas && this.openAreas.length)\r\n            allAreas = allAreas.concat(this.openAreas);\r\n\r\n        if (!allAreas.length) {\r\n            this.closedAreas = [];\r\n            this.openAreas = null;\r\n            return;\r\n        }\r\n\r\n        //In the DCEL, each polygon outline or hole contour\r\n        //appears twice (due to the structure being doubly connected), so\r\n        //here we drop the twin polygon.\r\n        let cmap = {};\r\n        for (let i=0; i<allAreas.length; i++) {\r\n            let a = allAreas[i];\r\n            let hash = a.hash();\r\n            if (!cmap[hash])\r\n                cmap[hash] = a;\r\n        }\r\n\r\n        allAreas = Object.values(cmap);\r\n\r\n        //Make one giant complex polygon out of all the contours, and let\r\n        //it triangulate itself using its default even-odd fill rule\r\n        let csAll = new ContourSet();\r\n\r\n        for (let i=0; i<allAreas.length; i++) {\r\n            csAll.addContourSet(allAreas[i]);\r\n        }\r\n\r\n        csAll.triangulate(customInsideChecker || this.quadTreeEdges);\r\n\r\n        if (csAll.triangulationFailed) {\r\n            //OK, now we get desperate -- the above triangulation attempt\r\n            //of the whole thing as one failed, so we triangulate each\r\n            //area separately (together with areas that are roughly inside it),\r\n            //and filter that result based on even-odd inside checker.\r\n            this._detectHolesNonZero(customInsideChecker || this.quadTreeEdges);\r\n        } else {\r\n            this.closedAreas = [csAll];\r\n            this.openAreas = [];\r\n        }\r\n    }\r\n\r\n\r\n    finalize(useEvenOddFill, customInsideChecker) {\r\n\r\n        //Remove useless vertices\r\n        this.cleanupFlatEdges();\r\n\r\n        this._compactLists();\r\n\r\n        //Sort the edges of each vertex according to direction\r\n        this.verts.forEach(v => v.sortEdges());\r\n\r\n        //traverse the graph and build closed polygons \r\n        //by following the edges in a counterclockwise direction\r\n        \r\n        let polygons = [];\r\n        let openPolygons = [];\r\n\r\n        this.verts.forEach(v => {\r\n            let e = v.findUntraversedEdge();\r\n\r\n            if (!e)\r\n                return;\r\n\r\n            let polygon = [v];\r\n\r\n            let vNext = e.getOppositeVertex(v);\r\n            do {\r\n                polygon.push(vNext);\r\n                e = vNext.findNextCCWEdge(e);\r\n                if (!e)\r\n                    break;\r\n                vNext = e.getOppositeVertex(vNext);\r\n            } while (vNext && vNext !== v);\r\n\r\n            if (vNext === v) {\r\n                polygon.push(v);\r\n                polygons.push(polygon);\r\n            } else {\r\n                openPolygons.push(polygon);\r\n            }\r\n        });\r\n\r\n        //logger.log(\"closed polygons:\", polygons.length);\r\n        //if (openPolygons.length)\r\n          //  logger.log(\"open polygons:\", openPolygons.length);\r\n\r\n        this.closedAreas = [];\r\n        for (let i=0, len=polygons.length; i<len; i++) {\r\n            let cs = new ContourSet();\r\n            cs.addContour(polygons[i]);\r\n            this.closedAreas.push(cs);\r\n        }\r\n\r\n        //Sort by increasing area, so that\r\n        //we discover potential polygon holes before we\r\n        //triangulate their bigger exterior outlines\r\n        this.closedAreas.sort((a, b) => {\r\n            return a.area() - b.area();\r\n        });\r\n\r\n\r\n        if (useEvenOddFill) {\r\n            this._detectHolesEvenOdd(customInsideChecker);\r\n        } else {\r\n            this._detectHolesNonZero(customInsideChecker);\r\n        }\r\n\r\n\r\n        //Put all open polygons into a single set of contours\r\n        //and combine as many as possible end to end to get\r\n        //a minimal number of open contours.\r\n        this.openAreas = [];\r\n        if (openPolygons.length) {\r\n            let openAreas = [];\r\n            let cs = new ContourSet();\r\n            for (let i=0, len=openPolygons.length; i<len; i++) {\r\n                cs.addContour(openPolygons[i]);\r\n            }\r\n            cs.stitchContours();\r\n            cs.triangulate();\r\n            openAreas.push(cs); \r\n            //logger.log(\"Stitched open polygons\", cs.contours.length);\r\n\r\n            this.openAreas = openAreas;\r\n        }\r\n        \r\n    }\r\n\r\n\r\n    deleteEdgesOnLine(x1, y1, x2, y2) {\r\n\r\n        let v1Tmp = new Vertex(x1, y1);\r\n        let v2Tmp = new Vertex(x2, y2);\r\n        let deTmp = new DirectedEdge(v1Tmp, v2Tmp, -1);\r\n\r\n        //Find edges crossed by the given segment\r\n        let otherInts = {};\r\n\r\n        this._enumNearEdges(deTmp, e => {\r\n\r\n            let ints = segmentsIntersect(e, deTmp, this.precisionTolerance);\r\n\r\n            if (!ints)\r\n                return;\r\n\r\n            //Existing edge was crossed by new edge\r\n            if (ints.e1 && ints.e1.length) {\r\n                otherInts[e.id] = ints.e1;\r\n            }\r\n        });\r\n\r\n        //Remove the intersected edges, effectively\r\n        //joining all areas defined by those edges.\r\n        //This is brute force, in theory we can find all\r\n        //contour sets that own the intersected edges\r\n        //and update the triangulations, but it doesn't seem worth it\r\n        for (let sid in otherInts) {\r\n            let eid = parseInt(sid);\r\n            let edge = this.edges[eid];\r\n            this.removeDirectedEdge(edge);\r\n\r\n            //clean up any \"dangling\" vertices left by the edge removal.\r\n            //those are edges that are only connected to the deleted edge and nothing else\r\n            this.removeDanglingPolyline(edge.v1);\r\n            this.removeDanglingPolyline(edge.v2);\r\n        }\r\n\r\n        this.dirty = true;\r\n    }\r\n\r\n    //Given a rectangle, join all areas that intersect the rectangle\r\n    deleteEdgesInRectangle(x1, y1, x2, y2) {\r\n\r\n        let minx = Math.min(x1, x2);\r\n        let miny = Math.min(y1, y2);\r\n        let maxx = Math.max(x1, x2);\r\n        let maxy = Math.max(y1, y2);\r\n\r\n        let otherInts = {};\r\n\r\n        //find edges completely inside the rectangle\r\n        this.quadTreeEdges.enumInBox(minx, miny, maxx, maxy, e => {\r\n            otherInts[e.id] = e;\r\n        });\r\n\r\n        //Remove the intersected edges, effectively\r\n        //joining all areas defined by those edges.\r\n        //This is brute force, in theory we can find all\r\n        //contour sets that own the intersected edges\r\n        //and update the triangulations, but it doesn't seem worth it\r\n        for (let sid in otherInts) {\r\n            let eid = parseInt(sid);\r\n            let edge = this.edges[eid];\r\n\r\n            if (!edge)\r\n                continue;\r\n\r\n            this.removeDirectedEdge(edge);\r\n\r\n            //clean up any \"dangling\" vertices left by the edge removal.\r\n            //those are edges that are only connected to the deleted edge and nothing else\r\n            this.removeDanglingPolyline(edge.v1);\r\n            this.removeDanglingPolyline(edge.v2);\r\n        }\r\n\r\n\r\n        this.dirty = true;\r\n    }\r\n\r\n    findNearestVertex(x, y, radius) {\r\n        \r\n        if (typeof radius !== \"number\")\r\n            radius = this.precisionTolerance;\r\n\r\n        let dNear = Infinity;\r\n        let vNear = null;\r\n\r\n        this.verts.enumInBox(x-radius, y-radius, x+radius, y+radius, v => {\r\n\r\n            let d = (v.x - x) * (v.x - x) + (v.y - y) * (v.y - y);\r\n            if (d < dNear) {\r\n                dNear = d;\r\n                vNear = v;\r\n            }\r\n\r\n        });\r\n\r\n        return (dNear <= radius * radius) ? vNear : null;\r\n    }\r\n\r\n    findNearestPointOnEdge(x, y, radius) {\r\n\r\n        if (typeof radius !== \"number\")\r\n            radius = this.precisionTolerance;\r\n\r\n        let tmp = { x:0, y:0, u:0, d:-1 };\r\n        let ptNearest = { x:0, y:0, d: Infinity, e:null };\r\n\r\n        this.quadTreeEdges.enumInBox(x-radius, y-radius, x+radius, y+radius, e => {\r\n\r\n            let result = pointOnLine(x, y, e, true, radius, tmp);\r\n\r\n            if (result) {\r\n                if (tmp.d < ptNearest.d) {\r\n                    ptNearest.x = tmp.x;\r\n                    ptNearest.y = tmp.y;\r\n                    ptNearest.d = tmp.d;\r\n                    ptNearest.e = e;\r\n                }\r\n            }\r\n        });\r\n\r\n        return (ptNearest.d <= radius) ? ptNearest : null;\r\n            \r\n    }\r\n\r\n}","\r\nvar point = new THREE.Vector3();\r\n\r\nexport function xBoxPlane(plane, box) {\r\n\r\n    point.set( box.min.x, box.min.y, box.min.z ); // 000\r\n    var d = plane.distanceToPoint(point);\r\n    var s = Math.sign(d);\r\n\r\n    point.set( box.min.x, box.min.y, box.max.z ); // 001\r\n    var d2 = plane.distanceToPoint(point);\r\n    if (Math.sign(d2) !== s)\r\n        return true;\r\n\r\n    point.set( box.min.x, box.max.y, box.min.z ); // 010\r\n    d2 = plane.distanceToPoint(point);\r\n    if (Math.sign(d2) !== s)\r\n        return true;\r\n\r\n    point.set( box.min.x, box.max.y, box.max.z ); // 011\r\n    d2 = plane.distanceToPoint(point);\r\n    if (Math.sign(d2) !== s)\r\n        return true;\r\n\r\n    point.set( box.max.x, box.min.y, box.min.z ); // 100\r\n    d2 = plane.distanceToPoint(point);\r\n    if (Math.sign(d2) !== s)\r\n        return true;\r\n\r\n    point.set( box.max.x, box.min.y, box.max.z ); // 101\r\n    d2 = plane.distanceToPoint(point);\r\n    if (Math.sign(d2) !== s)\r\n        return true;\r\n\r\n    point.set( box.max.x, box.max.y, box.min.z ); // 110\r\n    d2 = plane.distanceToPoint(point);\r\n    if (Math.sign(d2) !== s)\r\n        return true;\r\n\r\n    point.set( box.max.x, box.max.y, box.max.z ); // 111\r\n    d2 = plane.distanceToPoint(point);\r\n    if (Math.sign(d2) !== s)\r\n        return true;\r\n\r\n    return false;\r\n}\r\n","\r\n\"use strict\";\r\n\r\n//const THREE = THREE;\r\nconst avp = Autodesk.Viewing.Private;\r\nconst VertexEnumerator = avp.VertexEnumerator;\r\n\r\nimport { isZero } from \"./fuzzy-math\";\r\nimport { xTrianglePlane } from \"./x-triangle-plane\";\r\n\r\n\r\nvar mi = new THREE.Matrix4();\r\nvar pi = new THREE.Plane();\r\n\r\nexport function xMeshPlane( plane, mesh, intersects ) {\r\n\r\n    let geometry = mesh.geometry;\r\n\r\n    if (!geometry)\r\n        return;\r\n\r\n    let baseIndex = intersects.length;\r\n\r\n    let matrixWorld = mesh.matrixWorld;\r\n    mi.getInverse(matrixWorld);\r\n    pi.copy(plane).applyMatrix4(mi);\r\n\r\n    VertexEnumerator.enumMeshTriangles(geometry, function(vA, vB, vC, a, b, c) {\r\n\r\n        xTrianglePlane(pi, vA, vB, vC, a, b, c, intersects, mesh.fragId);\r\n\r\n    });\r\n\r\n    //Put the points into world space. It should actually be possible to do\r\n    //the entire math in object space -- but we have to check if all fragments\r\n    //that belong to the same dbId have the same world transform.\r\n    for (let i=baseIndex, iEnd=intersects.length; i<iEnd; i++) {\r\n        intersects[i].v1.applyMatrix4(matrixWorld);\r\n        intersects[i].v2.applyMatrix4(matrixWorld);\r\n    }\r\n\r\n}\r\n\r\n\r\nfunction makeRotationAxis( axis, cosa, m ) {\r\n\r\n    // Based on http://www.gamedev.net/reference/articles/article1199.asp\r\n\r\n    let c = cosa;\r\n    let s = Math.sqrt(1.0 - c*c);\r\n    let t = 1 - c;\r\n    let x = axis.x, y = axis.y, z = axis.z;\r\n    let tx = t * x, ty = t * y;\r\n\r\n    m.set(\r\n\r\n        tx * x + c, tx * y - s * z, tx * z + s * y, 0,\r\n        tx * y + s * z, ty * y + c, ty * z - s * x, 0,\r\n        tx * z - s * y, ty * z + s * x, t * z * z + c, 0,\r\n        0, 0, 0, 1\r\n\r\n    );\r\n\r\n}\r\n\r\n\r\nexport function makePlaneBasis(plane) {\r\n\r\n    //var origin = plane.coplanarPoint();\r\n\r\n    let sceneUp = new THREE.Vector3(0,0,1);\r\n    let cross = plane.normal.clone().cross(sceneUp);\r\n    cross = cross.normalize();\r\n    let dot = sceneUp.dot(plane.normal);\r\n\r\n    //We are ignoring the translation here, since\r\n    //we will drop the Z coord for the 2D processing steps anyway.\r\n    let planeBasis = new THREE.Matrix4();\r\n\r\n    if (!(isZero(cross.x) && isZero(cross.y) && isZero(cross.z))) {\r\n        makeRotationAxis(cross, dot, planeBasis);\r\n        planeBasis.elements[14] = plane.constant;\r\n    } else {\r\n        planeBasis.elements[14] = dot * plane.constant;\r\n    }\r\n\r\n    return planeBasis;\r\n}\r\n\r\n\r\nexport function convertToPlaneCoords(planeBasis, edges3d, bbox) {\r\n\r\n    for (let i=0; i<edges3d.length; i++) {\r\n        let e = edges3d[i];\r\n\r\n        e.v1.applyMatrix4(planeBasis);\r\n        e.v2.applyMatrix4(planeBasis);\r\n\r\n        bbox.expandByPoint(e.v1);\r\n        bbox.expandByPoint(e.v2);\r\n    }\r\n}\r\n\r\n","    function IntervalNode() {\n\n        this.bbox = new THREE.Box2();\n        this.left = null;\n        this.right = null;\n        this.node_edges = [];\n    }\n\n    //Acceleration structure for point-in-polygon checking.\n    //Takes in a list of points and edges indexing into those points.\n    //The Point-in-polygon check is a simple even-odd test based on counting\n    //number of edges intersected by a ray from the input point to infinity.\n    export function IntervalTree(pts, edges, bbox) {\n\n        this.pts = pts;\n        this.edges = edges;\n        this.bbox = bbox;\n        this.pipResult = false;\n\n    }\n\n\n\n    IntervalTree.prototype.splitNode = function(node) {\n\n        if (node.bbox.min.y >= node.bbox.max.y)\n            return;\n\n        if (node.node_edges.length < 3)\n            return;\n\n        var split = 0.5 * (node.bbox.min.y + node.bbox.max.y);\n\n        //node.bbox.makeEmpty();\n\n        node.left = new IntervalNode();\n        node.right = new IntervalNode();\n\n        var pts = this.pts;\n        var ne = node.node_edges;\n        var remaining_node_edges = [];\n        var tmpPt = new THREE.Vector2();\n\n        for (var i=0; i<ne.length; i++) {\n\n            var e = this.edges[ne[i]];\n\n            var p1y = pts[e.p1].y;\n            var p2y = pts[e.p2].y;\n\n            if (p1y > p2y) {\n                var tmp = p1y;\n                p1y = p2y;\n                p2y = tmp;\n            }\n\n            var boxPtr = null;\n\n            if (p2y < split) {\n                node.left.node_edges.push(ne[i]);\n                boxPtr = node.left.bbox;\n            } else if (p1y > split) {\n                node.right.node_edges.push(ne[i]);\n                boxPtr = node.right.bbox;\n            } else {\n                remaining_node_edges.push(ne[i]);\n                //boxPtr = node.bbox;\n            }\n\n            if (boxPtr) {\n                tmpPt.set(pts[e.p1].x, pts[e.p1].y);\n                boxPtr.expandByPoint(tmpPt);\n                tmpPt.set(pts[e.p2].x, pts[e.p2].y);\n                boxPtr.expandByPoint(tmpPt);\n            }\n        }\n\n        node.node_edges = remaining_node_edges;\n\n        if (node.left.node_edges.length)\n            this.splitNode(node.left);\n        if (node.right.node_edges.length)\n            this.splitNode(node.right);\n    };\n\n\n    IntervalTree.prototype.build = function() {\n\n        this.root = new IntervalNode();\n\n        var edge_indices = this.root.node_edges;\n        for (var i=0; i<this.edges.length; i++)\n            edge_indices.push(i);\n\n        this.root.bbox.copy(this.bbox);\n\n        //split recursively\n        this.splitNode(this.root);\n    };\n\n\n\n\n    IntervalTree.prototype.pointInPolygonRec = function(node, x, y) {\n\n        if (node.bbox.min.y <= y && node.bbox.max.y >= y) {\n\n            var pts = this.pts;\n            var ne = node.node_edges;\n\n            for (var i=0, iEnd=ne.length; i<iEnd; i++) {\n\n                var e = this.edges[ne[i]];\n\n                // get the last point in the polygon\n                var p1 = pts[e.p1];\n                var vtx0X = p1.x;\n                var vtx0Y = p1.y;\n\n                // get test bit for above/below X axis\n                var yflag0 = (vtx0Y >= y);\n\n                var p2 = pts[e.p2];\n                var vtx1X = p2.x;\n                var vtx1Y = p2.y;\n\n                var yflag1 = (vtx1Y >= y);\n\n                // Check if endpoints straddle (are on opposite sides) of X axis\n                // (i.e. the Y's differ); if so, +X ray could intersect this edge.\n                // The old test also checked whether the endpoints are both to the\n                // right or to the left of the test point.  However, given the faster\n                // intersection point computation used below, this test was found to\n                // be a break-even proposition for most polygons and a loser for\n                // triangles (where 50% or more of the edges which survive this test\n                // will cross quadrants and so have to have the X intersection computed\n                // anyway).  I credit Joseph Samosky with inspiring me to try dropping\n                // the \"both left or both right\" part of my code.\n                if (yflag0 != yflag1)\n                {\n                    // Check intersection of pgon segment with +X ray.\n                    // Note if >= point's X; if so, the ray hits it.\n                    // The division operation is avoided for the \">=\" test by checking\n                    // the sign of the first vertex wrto the test point; idea inspired\n                    // by Joseph Samosky's and Mark Haigh-Hutchinson's different\n                    // polygon inclusion tests.\n                    if (((vtx1Y-y)*(vtx0X-vtx1X) >=\n                            (vtx1X-x)*(vtx0Y-vtx1Y)) == yflag1)\n                    {\n                        this.pipResult = !this.pipResult;\n                    }\n                }\n\n            }\n\n        }\n\n        var nl = node.left;\n        if (nl && nl.bbox.min.y <= y && nl.bbox.max.y >= y) {\n            this.pointInPolygonRec(nl, x, y);\n        }\n\n        var nr = node.right;\n        if (nr && nr.bbox.min.y <= y && nr.bbox.max.y >= y) {\n            this.pointInPolygonRec(nr, x, y);\n        }\n\n    };\n\n    IntervalTree.prototype.pointInPolygon = function(x, y) {\n\n          this.pipResult = false;\n\n          this.pointInPolygonRec(this.root, x, y);\n\n          return this.pipResult;\n\n    };\n","// Sample ellipse at a given angle.\n//  @param {number} angle    - ccw angle along the ellipse in radians. 0 = point is ellipse x-axis.\n//  @param {number} cx, cy   - ellipse center\n//  @param {number} rx, ry   - ellipse radii\n//  @param {number} rotation - ccw in radians\n//  @param {Vector2} [target]\n//  @returns {Vector2}\nexport const getEllipsePoint = (angle, cx, cy, rx, ry, rotation = 0.0, target = null) => {\n\n    const point = target || new THREE.Vector2();\n\n    // compute point from unrotated ellipse equation\n    let x = cx + rx * Math.cos(angle);\n    let y = cy + ry * Math.sin(angle);\n\n    // apply this.rotation: (x,y) around center (cx, cy)\n    if (rotation !== 0) {\n\n        const cos = Math.cos(rotation);\n        const sin = Math.sin(rotation);\n\n        const tx = x - cx;\n        const ty = y - cy;\n\n        // Rotate the point about the center of the ellipse.\n        x = tx * cos - ty * sin + cx;\n        y = tx * sin + ty * cos + cy;\n    }\n\n    return point.set(x, y);\n};\n\n// Sample a single point from an ellipse arc that runs counterclockwise from startAngle to endAngle.\n//  @param {number} cx, cy               - center\n//  @param {number} rx, ry               - radii in x/y axis\n//  @param {number} startAngle, endAngle - ccw angles in radians. 0 corresponds to (xRadius, 0)\n//  @param {number} rotation             - ellipse axis rotation, ccw in radians\n//  @param {number} t                    - sampling position along ellipse. 0 => startAngle, 1 = endAngle\n//  @param {Vector2} [target]\n//  @returns {Vector2}\nexport const getEllipseArcPoint = (t, cx, cy, rx, ry, startAngle, endAngle, rotation = 0.0, target = null) => {\n\n    let deltaAngle = endAngle - startAngle;        \n\n    // If start/end angle are approximately the same, just sample at start angle\n    const samePoints = Math.abs(deltaAngle) < Number.EPSILON;\n    if (samePoints) {\n        return getEllipsePoint(0.0, cx, cy, rx, ry, rotation, target);\n    }\n\n    // ensures that deltaAngle is [0,2 PI[\n    deltaAngle = normalizeAngle(deltaAngle);\n\n    // Since samePoints was false, but deltaAngle is close to 0 after normalization, \n    // deltaAngle must be close to a multiple of 2*Pi.\n    const wholeEllipse = (deltaAngle < Number.EPSILON);\n    if (wholeEllipse) {\n        deltaAngle = 2.0 * Math.PI;\n    }\n\n    // Sample ellipse point at that angle\n    const angle = startAngle + t * deltaAngle;\n    return getEllipsePoint(angle, cx, cy, rx, ry, rotation, target);\n};\n\n// Force angle to be within [0, 2Pi[\nexport const normalizeAngle = (angle) => {\n    // Scale [0, 2Pi] to [0,1]\n    angle /= 2.0 * Math.PI;\n\n    // Remove integer part\n    angle -= Math.trunc(angle);\n\n    // Angle is either in [0,1] or was negative. In the latter case,\n    // it is in [-1, 0] now and we add 1 to bring it to [0,1] as well.\n    if (angle < 0) {\n        angle += 1.0;\n    }\n\n    // Scale back to [0, 2Pi] range\n    return angle * 2.0 * Math.PI;\n};\n\n// Compute the arc angle difference of an arc running from startAngle to endAngle.\n//  @param {number} startAngle - in radians\n//  @param {number} endAngle   - in radians\n//  @param {bool}   ccw        - whether the arc runs counterclockwise (true) or clockwise (false)\nexport const getAngleDelta = (startAngle, endAngle, ccw) => { \n\n    // get angle difference\n    let delta = endAngle - startAngle;\n\n    // Force to [0, 2Pi] range\n    delta = normalizeAngle(delta);\n\n    // invert if arc is clockwise\n    return ccw ? delta : 2.0 * Math.PI - delta;\n};\n\n// Given start/end angle of an arc, this function checks whether angle is within the arc. \n// All angles are ccw in radians. We assume the arc to be running ccw. Note that start may be > end if the arc range contains a 2*Pi mulitple.\nexport const angleInsideArcCCW = (angle, start, end) => {\n\n    // ensure 0 <= a < 2Pi for all angles\n    angle = normalizeAngle(angle);\n    start = normalizeAngle(start);\n    end   = normalizeAngle(end);\n\n    if (start < end) {\n        return angle >= start && angle <= end;\n    }\n\n    // If start > end, we are crossing a full-circle boundary. So, the range between [start, end] is actually\n    // the circle part outside the arc.\n    // For start = end, the arc is the whole circle and the result will always be true.\n    return angle >= start || angle <= end;\n};\n\n// Like angleInsideCCW, but adding an option param to support clockwise arcs.\nexport const angleInsideArc = (angle, start, end, ccw = true) => {\n    const insideCCW = angleInsideArcCCW(angle, start, end);\n    return ccw ? insideCCW : !insideCCW;\n};\n\nconst svgAngle = (ux, uy, vx, vy) => {\n\n    var dot = ux * vx + uy * vy;\n    var len = Math.sqrt( ux * ux + uy * uy ) * Math.sqrt( vx * vx + vy * vy );\n    var ang = Math.acos( Math.max( - 1, Math.min( 1, dot / len ) ) ); // floating point precision, slightly over values appear\n    if ( ( ux * vy - uy * vx ) < 0 ) ang = - ang;\n    return ang;\n};\n\nconst tmpVec = new THREE.Vector2();\n\n// Parameters to describe ellipse arc\nexport class EllipseArc {\n\n    constructor(cx, cy, rx, ry, rotation, startAngle, endAngle, ccw) {\n        this.set(cx, cy, rx, ry, rotation, startAngle, endAngle, ccw);\n    }\n\n    set(cx, cy, rx, ry, rotation, startAngle, endAngle, ccw) {\n        // center\n        this.cx = cx;\n        this.cy = cy;\n\n        // radii\n        this.rx = rx;\n        this.ry = ry;\n\n        // angle in radians\n        this.startAngle = startAngle;\n        this.endAngle = endAngle;\n\n        // If true, arc runs from startAngle in counterclockwise direction, otherwise clockwise\n        this.ccw = ccw;\n\n        // ellipse rotation in radians\n        this.rotation = rotation;\n\n        return this;\n    }\n\n    /**\n     * Convert SVG-style specification of an ellipse arc into an ellipse arc with center and start/end angle that is easier to sample.\n     * Implementation is based on parseArcCommand() helper function in THREE.SVGLoader. All output angles in radians.\n     * \n     * https://www.w3.org/TR/SVG/implnote.html#ArcImplementationNotes\n     * https://mortoray.com/2017/02/16/rendering-an-svg-elliptical-arc-as-bezier-curves/ Appendix: Endpoint to center arc conversion\n     * \n     * @param {number}   rx, ry        - radii in x/y axis (before xAxisRoation)\n     * @param {number}   xAxisRotation - ccw rotation of the ellipse axes in degrees\n     * @param {bool}     largeArcFlag  - whether to use short or long path along the ellipse\n     * @param {bool}     sweepFlag     - whether to run counterclockwise around the arc from the startPoint\n     * @param {Vector2}  start, end    - startPoint and endPoint of the arc\n     */\n    setFromSvgArc(rx, ry, xAxisRotation, largeArcFlag, sweepFlag, start, end) {\n\n        // get rotation in radians\n        const rotation = xAxisRotation * Math.PI / 180;\n\n        // Ensure radii are positive\n        rx = Math.abs( rx );\n        ry = Math.abs( ry );\n\n        // To avoid NaNs and for consistency with browser SVG behavior:\n        // If any radius is 0, fall back to a straight segment. An EllipseCurve is not able to represent a straight line segment.\n        // However, we can resemble this using an arc whose radius is large enough so that the angle difference is hardly noticeable.\n        if (rx == 0 || ry == 0) {\n            // Choose radius large enough so that 0.01 degrees correspond to the (start, end) distance.\n            const minAngleDelta = 0.01;\n            const dist      = tmpVec.copy(start).distanceTo(end); // still works if start/end are just {x,y} pairs\n            const perimeter = dist * 360 / minAngleDelta;\n            const radius    = perimeter / (2.0 * Math.PI);\n            rx = radius;\n            ry = radius;\n        }\n\n        // Compute (x1, y1)\n        const dx2 = ( start.x - end.x ) / 2.0;\n        const dy2 = ( start.y - end.y ) / 2.0;\n        const x1p =   Math.cos( rotation ) * dx2 + Math.sin( rotation ) * dy2;\n        const y1p = - Math.sin( rotation ) * dx2 + Math.cos( rotation ) * dy2;\n\n        // Compute (cx, cy)\n        let rxs = rx * rx;\n        let rys = ry * ry;\n        const x1ps = x1p * x1p;\n        const y1ps = y1p * y1p;\n\n        // Ensure radii are large enough\n        const cr = x1ps / rxs + y1ps / rys;\n\n        if ( cr > 1 ) {\n            // scale up rx,ry equally so cr == 1\n            const s = Math.sqrt( cr );\n            rx = s * rx;\n            ry = s * ry;\n            rxs = rx * rx;\n            rys = ry * ry;\n        }\n\n        const dq = ( rxs * y1ps + rys * x1ps );\n        const pq = ( rxs * rys - dq ) / dq;\n        let q = Math.sqrt( Math.max( 0, pq ) );\n        if ( largeArcFlag === sweepFlag ) q = - q;\n        const cxp = q * rx * y1p / ry;\n        const cyp = - q * ry * x1p / rx;\n\n        // Step 3: Compute (cx, cy) from (cx, cy)\n        const cx = Math.cos( rotation ) * cxp - Math.sin( rotation ) * cyp + ( start.x + end.x ) / 2;\n        const cy = Math.sin( rotation ) * cxp + Math.cos( rotation ) * cyp + ( start.y + end.y ) / 2;\n\n        // Step 4: Compute 1 and \n        const theta = svgAngle( 1, 0, ( x1p - cxp ) / rx, ( y1p - cyp ) / ry );\n        const delta = svgAngle( ( x1p - cxp ) / rx, ( y1p - cyp ) / ry, ( - x1p - cxp ) / rx, ( - y1p - cyp ) / ry ) % ( Math.PI * 2 );\n\n        // Set curve params\n        this.cx = cx;\n        this.cy = cy;\n        this.rx = rx;\n        this.ry = ry;\n        this.rotation = rotation;\n        this.startAngle = theta;\n        this.endAngle   = theta + delta;\n        this.ccw = sweepFlag;\n\n        return this;\n    }\n\n    // Sample point along arc. \n    //  @param {number}  t - 0: startPoint, 1: endPoint\n    //  @param {Vector2} [target]\n    //  @returns Vector2\n    getPoint(t, target) {\n        \n        let start = this.startAngle;\n        let end   = this.endAngle;\n\n        // In case the arc is clockwise...\n        if (!this.ccw) {\n            // Swap start/end to get opposite ccw arc and sample it at position 1-t instead.\n            start = this.endAngle;\n            end   = this.startAngle;\n            t     = 1.0 - t;\n        }\n\n        return getEllipseArcPoint(t, this.cx, this.cy, this.rx, this.ry, start, end, this.rotation, target);\n    }\n\n    isValid() {\n        return isFinite(this.cx) && isFinite(this.cy) && isFinite(this.rx) && isFinite(this.ry) && isFinite(this.rotation) && \n               isFinite(this.startAngle) && isFinite(this.endAngle);\n    }\n\n    // @param {Box2} [targetBox]\n    // returns {Box2}\n    computeBBox(targetBox) {\n\n        // compute extreme points of ellipse equation\n        const tanPhi = Math.tan(this.rotation);\n        const thetaX1 =          - Math.atan(this.ry*tanPhi / this.rx);\n        const thetaX2 =  Math.PI - Math.atan(this.ry*tanPhi / this.rx);\n        const thetaY1 =            Math.atan(this.ry        / (tanPhi*this.rx));\n        const thetaY2 =  Math.PI + Math.atan(this.ry        / (tanPhi*this.rx));\n\n        // Clear targetBox or create a new one\n        const box = targetBox ? targetBox.makeEmpty() : new THREE.Box2();\n    \n        // Helper function to add an ellipse point that we obtain at angle theta in the ellipse equation\n        const addEllipsePoint = (theta) => {\n             const p = getEllipsePoint(theta, this.cx, this.cy, this.rx, this.ry, this.rotation);\n             box.expandByPoint(p);\n        };\n\n        addEllipsePoint(this.startAngle);\n        addEllipsePoint(this.endAngle);\n\n        // Add all extreme points to the bbox that are inside the arc\n        angleInsideArc(thetaX1, this.startAngle, this.endAngle, this.ccw) && addEllipsePoint(thetaX1);\n        angleInsideArc(thetaX2, this.startAngle, this.endAngle, this.ccw) && addEllipsePoint(thetaX2);\n        angleInsideArc(thetaY1, this.startAngle, this.endAngle, this.ccw) && addEllipsePoint(thetaY1);\n        angleInsideArc(thetaY2, this.startAngle, this.endAngle, this.ccw) && addEllipsePoint(thetaY2);\n\n        return box;\n    }\n\n    // Samples an ellipse arc as lineTo segments that are added a canvas context object.\n    // Note: lineTo() is not called with the arc starting point. ctx is expected to end at the arc start point already.\n    //\n    //  @param {Path2D|LmvCanvasContext|CanvasContext} ctx - line segment are added by ctx.lineTo(x,y) calls.\n    //  @param {number} maxSegmentCount  - Maximum number of line segments\n    //  @param {number} minSegmentLength - Skip small segments below this length\n    tesselate(ctx, maxSegments, minSegmentLength) {\n\n        // Init lastX/lastY\n        const lastPoint = this.getPoint(0);\n\n        // Note that we only iterate over inner points.\n        // Start point is not added by this function and endpoint is added separately below\n        for (var i=1; i<maxSegments; i++) {\n\n            // get next point along arc\n            const t = i / maxSegments;\n            const p = this.getPoint(t, tmpVec);\n            \n            // Skip point if too close to previous point\n            const dist = p.distanceTo(lastPoint);\n            if (dist < minSegmentLength) {\n                continue;\n            }\n\n            // add line segment\n            ctx.lineTo(p.x, p.y);\n            lastPoint.copy(p);\n        }\n\n        // Always add end point (without minSegmentLength-check)\n        const p = this.getPoint(1.0, tmpVec);\n        ctx.lineTo(p.x, p.y);\n    }\n\n    getAngleDelta() {\n        return getAngleDelta(this.startAngle, this.endAngle, this.ccw);\n    }\n}\n","\nimport { Path2D } from \"./path2d\";\n\nvar av = Autodesk.Viewing,\n    avp = av.Private;\n\nconst VertexBufferBuilder = avp.VertexBufferBuilder;\n\nconst _document = av.getGlobal().document;\n//Custom implementation of HTML Canvas API used for rendering PDF geometry using the WebGL accelerated F2D renderer\n\n\n//A custom context object that overloads standard HMTL Canvas 2D context to intercept draw\n//calls and pipe them into LMV vertex buffers\nexport function hijackContextAPI(inContext, lmvContext) {\n\n    let fnList = [\n        \"fillRect\",\n        \"strokeRect\",\n        \"clearRect\",\n        \"beginPath\",\n        \"closePath\",\n        \"moveTo\",\n        \"lineTo\",\n        \"arc\",\n        \"arcTo\",\n        \"quadraticCurveTo\",\n        \"bezierCurveTo\",\n        \"rect\",\n        \"fill\",\n        \"stroke\",\n        \"clip\",\n        \"strokeText\",\n        \"fillText\",\n        \"drawImage\",\n        \"save\",\n        \"restore\",\n        \"setLineDash\",\n        \"createPattern\",\n\n        // OCG related\n        \"beginMarkedContent\",\n        \"beginMarkedContentProps\",\n        \"endMarkedContent\",\n        \"setCurrentOperatorIndex\",\n\n        //Inject this function into canvas context so we can batch process inlineImageGroup related calls\n        \"needDelegateInlineImageGroup\",\n        \"isLMVCanvasContext\",\n        \"createChildGroupContext\",\n        \"endChildGroupContext\"\n    ];\n\n    fnList.forEach(fn => {\n        inContext[\"_original\" + fn] = inContext[fn];\n        inContext[fn] = lmvContext[fn].bind(lmvContext);\n    });\n\n}\n\nconst QUAD_TEXTURE = 1;\nconst IMAGE_TEXTURE = 2;\n\nlet _tmpXform = new Array(6);\nlet _tmpVec = new THREE.Vector2();\nlet _tmpBox = new THREE.Box2();\n\n\n//Used for matrix decomposition in drawImage\nvar _offset = new THREE.Vector3();\nvar _quat   = new THREE.Quaternion();\nvar _scale  = new THREE.Vector3();\nvar _axis  = new THREE.Vector3();\nvar _mtx4 = new THREE.Matrix4();\n\nexport class LmvCanvasContext {\n\n    /**\n     * Check is a PDF Ref object\n     * @param {PDF.Ref} obj \n     */\n    static isRef(obj) {\n        return obj != null && typeof(obj.num) === \"number\" && typeof(obj.gen) === \"number\";\n    }\n\n    /**\n     * generate a simple string works as a key for the ref.\n     * @param {PDF.Ref} ref \n     */\n    static refKey(ref) {\n        return `${ref.num}-${ref.gen}`;\n    }\n\n    constructor(viewport, toPageUnits, meshCallback, fontEngine, usingTextLayer, fontAtlas, pdfRefMap) {\n\n        //\n        // Prepare canvas using PDF page dimensions\n        //\n        //TODO: Do we need that or can we just overload the entire CanvasContext API and skip the HTML element creation completely?\n        var canvas = _document.createElement('canvas');\n        var context = canvas.getContext('2d');\n        canvas.height = viewport.height;\n        canvas.width = viewport.width;\n\n        this.canvasContext = context; //REQUIRED for PDF.js interface\n        this.viewport = viewport; //REQUIRED for PDF.js interface\n        this.toPageUnits = toPageUnits;\n\n        // LMV-5812: This constant is required to calculate the line width\n        // Usually the viewport is scaled by a value greater than 1, but for some PDFs (ultra wide) the scale value will be less than 1.\n        // The line width should be downscaled with the same factor as the viewport, otherwise lines would look too large\n        // The default line width is 1 for canvas context 2d.\n        this.lineWidthScale = this.viewport.scale < 1 ? this.viewport.scale / this.viewport.scaleByDPI : 1;\n\n        this.meshCallback = meshCallback;\n        // Only set bounds for PDF, because Edit2d is using LmvCanvasContext for drawing, and doesn't require clipping\n        if(viewport.clipToViewport == true) {\n            let offsetX = viewport.offsetX || 0;\n            let offsetY = viewport.offsetY || 0;\n            this.bounds = new THREE.Vector4( offsetX * toPageUnits, offsetY * toPageUnits, \n                (viewport.width + offsetX) * toPageUnits, (viewport.height + offsetY) * toPageUnits);\n        }\n     \n        this.currentMeshIndex = 0;\n        this.imageNumber = 0;\n        this.currentVbb = new VertexBufferBuilder(false);\n        this._curPath = null;\n        this._curClip = null;\n        this.first = true;\n        this.states = [];\n        this.glyphCache = {};\n        this.usingTextLayer = usingTextLayer;\n\n        //Fixed precision tolerance assuming the input is in typographic \"point\" units.\n        this.precisionTolerance = 0.1;\n\n        this.dbId = -1;\n        this.maxDbId = 0;\n\n        // If true, dbId is automatically increased on each beginPath call.\n        this.consecutiveIds = false;\n\n        if (av.isMobileDevice()) {\n            Autodesk.Extensions.CompGeom.SetTesselationParams(undefined, 0.1);\n        }\n\n        this.fontEngine = fontEngine;\n\n        // Use solid lines by default. See LineStyleDef.js for other line types (dashed etc.)\n        this.lineStyle = 0;\n\n        // If true, lines widths are applied in screen-space\n        this.isScreenSpace = false; \n\n        hijackContextAPI(context, this);\n\n        this.layers = {};\n        this.defaultLayerId = 0;\n        this.currentLayerId = this.defaultLayerId;\n        this.sequencedDbId = -1;\n        this.taggedId = null;\n        this.defaultVPId = 0;\n        this.currentVpId = this.defaultVPId;\n        this.viewports = [this.createViewPortData(new THREE.Matrix4().elements)];\n        this.viewportMap = {};\n\n        this.ocgStack = [];\n\n        this.msdfRender = true;\n        this.fontAtlas = fontAtlas;\n        this.pdfRefMap = pdfRefMap || {} ;\n    }\n\n    destroy() {\n        this.canvasContext = null;\n        this.meshCallback = null;\n    }\n\n    updateDBId() {\n        if(this.taggedId != null) {\n            this.dbId = this.taggedId;\n        } else {\n            if(this.consecutiveIds) {\n                this.sequencedDbId++;\n                this.dbId = this.sequencedDbId;\n            }\n        }\n\n        this.maxDbId = Math.max(this.maxDbId, this.dbId);\n    }\n\n    save() {\n        //console.log(\"save\");\n        this.states.push({\n            clip: this._curClip,\n            consecutiveIds: this.consecutiveIds,\n            lineDashedDef: this.lineDashedDef,\n            lineStyle: this.lineStyle\n        });\n\n        this.canvasContext._originalsave();\n    }\n\n    restore() {\n\n        let state = this.states.pop();\n\n        if (state) {\n            this._curClip = state.clip;\n            this.consecutiveIds = state.consecutiveIds;\n            this.lineDashedDef = state.lineDashedDef;\n            this.lineStyle = state.lineStyle;\n        }\n\n        //console.log(\"restore\");\n        this.canvasContext._originalrestore();\n    }\n\n    flushBuffer(addCount, finalFlush, textureOption) {\n        if (!this.currentVbb.vcount && !finalFlush) {\n            return;\n        }\n\n        // LMV-5542 - support blend modes for fill colors\n        // Limit the number of times that meshes are split up.\n        // When adding support for a new compositeOperation, add it to the if condition.\n        let compositeOperation = 'source-over';\n        const globalCompOp = this.canvasContext.globalCompositeOperation;\n        if (globalCompOp === 'multiply' || globalCompOp === 'min' || globalCompOp === 'darken' || globalCompOp === 'lighten') {\n            compositeOperation = globalCompOp;\n        }\n\n        // When the blending mode has changed, we have to flush the shapes that were added with the blending mode that\n        // was current until now, that's why we use this.currentCompositeOperation below when setting material.compositeOperation.\n        const blendModeChanged = this.currentCompositeOperation !== compositeOperation;\n        const flush = finalFlush || this.currentVbb.isFull(addCount) || blendModeChanged;\n\n        if (flush) {\n            if (this.currentVbb.vcount) {\n                const mesh = this.currentVbb.toMesh();\n                mesh.material = {\n                                    skipEllipticals : !this.currentVbb.numEllipticals,\n                                    skipCircles: !this.currentVbb.numCirculars,\n                                    skipTriangleGeoms : !this.currentVbb.numTriangleGeoms,\n                                    useInstancing : this.currentVbb.useInstancing,\n                                    isScreenSpace: !this.currentImage,\n                                    hasLineStyles: this.currentVbb.hasLineStyles,\n                                    msdfFontTexture: !!this.hasMSDFContent,\n                                    viewportBounds: this.bounds,\n                                    imageUVTexture: textureOption === IMAGE_TEXTURE\n                                };\n\n                if (this.currentImage) {\n                    mesh.material.image = this.currentImage;\n                    mesh.material.image.name = this.currentImage.cacheKey || this.imageNumber++;\n                    // Assume the background of PDF page is white, when use it to do multiply, white is better then black color\n                    // And it should be correct for most cases\n                    mesh.material.compositeCanvasColor = \"#ffffff\";\n                    mesh.material.opacity = this.canvasContext.globalAlpha;\n                    this.currentImage = null;\n                }\n\n                mesh.material.compositeOperation = this.currentCompositeOperation;\n\n                this.meshCallback(mesh, this.currentMeshIndex++);\n                this.currentVbb.reset(0);\n                this.hasMSDFContent = false;\n            }\n        }\n\n        this.currentCompositeOperation = compositeOperation;\n    }\n\n    //Polytriangle requires some post-processing depending on wheter instancing is used or not\n    //TODO: This is copy-pasted from the same function in F2D.js. It's purely used to\n    //add half width outline to polytriangles so that they look antialiased.\n    addPolyTriangle(points, inds, color, dbId, layer, antialiasEdges) {\n        var me = this;\n        var edgeMap = null;\n\n        var currentVpId = this.currentVpId;\n\n        var aaLineWeight = -0.5; //negative = in pixel units\n\n        function processEdge(iFrom, iTo) {\n            if (iFrom > iTo) {\n                var tmp = iFrom;\n                iFrom = iTo;\n                iTo = tmp;\n            }\n\n            if (!edgeMap[iFrom])\n                edgeMap[iFrom] = [iTo];\n            else {\n                var adjacentVerts = edgeMap[iFrom];\n                var idx = adjacentVerts.lastIndexOf(iTo);\n                if (idx == -1)\n                    adjacentVerts.push(iTo); //first time we see this edge, so remember it as exterior edge\n                else\n                    adjacentVerts[idx] = -1; //the second time we see an edge mark it as interior edge\n            }\n        }\n\n\n        function addAllAntialiasEdges() {\n\n            for (var i = 0, iEnd = edgeMap.length; i<iEnd; i++) {\n\n                var adjacentVerts = edgeMap[i];\n                if (!adjacentVerts)\n                    continue;\n\n                for (var j=0; j<adjacentVerts.length; j++) {\n                    var iTo = adjacentVerts[j];\n                    if (iTo == -1)\n                        continue; //an interior edge was here -- skip\n                    else {\n                        //exterior edge -- add an antialiasing line for it\n                        me.flushBuffer(4);\n                        me.currentVbb.addSegment(points[2*i], points[2*i+1],\n                                                 points[2*iTo], points[2*iTo+1],\n                                                 me.currentLayerId,\n                                                 aaLineWeight,\n                                                 color,\n                                                 dbId, layer, currentVpId, me.lineStyle);\n                    }\n                }\n            }\n        }\n\n        function antialiasOneEdge(iFrom, iTo) {\n            if (iFrom > iTo) {\n                var tmp = iFrom;\n                iFrom = iTo;\n                iTo = tmp;\n            }\n\n            var adjacentVerts = edgeMap[iFrom];\n            if (!adjacentVerts)\n                return;\n\n            var idx = adjacentVerts.indexOf(iTo);\n            if (idx != -1) {\n                //exterior edge -- add an antialiasing line for it\n                me.flushBuffer(4);\n                me.currentVbb.addSegment(points[2*iFrom], points[2*iFrom+1],\n                                         points[2*iTo], points[2*iTo+1],\n                                         me.currentLayerId,\n                                         aaLineWeight,\n                                         color,\n                                         dbId, layer, currentVpId, me.lineStyle);\n            }\n        }\n\n        if (antialiasEdges) {\n            edgeMap = new Array(points.length/2);\n\n            for (var i= 0, iEnd = inds.length; i<iEnd; i+= 3) {\n                var i0 = inds[i];\n                var i1 = inds[i+1];\n                var i2 = inds[i+2];\n\n                processEdge(i0, i1);\n                processEdge(i1, i2);\n                processEdge(i2, i0);\n            }\n        }\n\n        if(isNaN(color) && (color.isPattern === true || color.imageTransform)) {\n            this.flushBuffer(0, true);\n            var image = color.image;\n            var count = points.length / 2; // number of vertices\n    \n            this.flushBuffer(count);\n            var vbb = this.currentVbb;\n            var vbase = vbb.vcount;\n\n            // need to apply the transformation to the UV\n            var xform = this.getCurrentTransform();\n            var x1, y1, w1, h1;\n            if(color.isGradient) {\n                x1 = this._curPath.bbox.min.x;\n                y1 = this._curPath.bbox.min.y;\n                w1 = this._curPath.bbox.max.x - x1;\n                h1 = this._curPath.bbox.max.y - y1;\n            } else {\n                x1 = this.tx(0, 0, xform);\n                y1 = this.ty(0, 0, xform);\n                w1 = Math.abs(this.tx(image.width, image.height, xform) - x1);\n                h1 = Math.abs(this.ty(image.width, image.height, xform) - y1);\n            }\n\n            //LMV-5353\n            if(color.repetition === \"no-repeat\" && !color.isGradient) {\n                var x2 = this.tx(image.width, image.height, xform);\n                var y2 = this.ty(image.width, image.height, xform);\n                vbb.addVertexImagePolytriangle(x1, y1, 0, 0, 0xFFFFFFFF, dbId, layer, currentVpId);\n                vbb.addVertexImagePolytriangle(x1, y2, 0, -1, 0xFFFFFFFF, dbId, layer, currentVpId);\n                vbb.addVertexImagePolytriangle(x2, y2, 1, -1, 0xFFFFFFFF, dbId, layer, currentVpId);\n                vbb.addVertexImagePolytriangle(x2, y1, 1, 0, 0xFFFFFFFF, dbId, layer, currentVpId);\n\n                inds = [0, 1, 2, 0, 2, 3];\n            } else if (color.imageTransform) {\n                for (let i = 0; i < count; ++i) {\n                    var x = points[2*i];\n                    var y = points[2*i+1];\n\n                    var u = (image.width * (x - x1) / w1 + color.imageTransform.x) / color.imageTransform.width;\n                    var v = (image.height * (y - y1) / h1 + color.imageTransform.y) / color.imageTransform.height;\n\n                    vbb.addVertexImagePolytriangle(x, y, u, v, 0xFFFFFFFF, dbId, layer, currentVpId);\n                }\n            } else {\n                for (let i = 0; i < count; ++i) {\n                    const x = points[2*i];\n                    const y = points[2*i+1];\n\n                    const u = (x - x1) / w1 ;\n                    let v = (y - y1) / h1 ;\n\n                    if(color.isGradient) {\n                        v = 1 - v;\n                    }\n                    vbb.addVertexImagePolytriangle(x, y, u, v, 0xFFFFFFFF, dbId, layer, currentVpId);\n                }\n            }\n\n            this.currentImage = image;\n            vbb.addIndices(inds, vbase);\n            this.flushBuffer(0, true, IMAGE_TEXTURE);\n        } else {\n            if (this.currentVbb.useInstancing) {\n                const count = inds.length;\n                for (let i = 0; i < count; i+=3) {\n                    let i0 = inds[i];\n                    let i1 = inds[i+1];\n                    let i2 = inds[i+2];\n    \n                    this.flushBuffer(4);\n    \n                    this.currentVbb.addTriangleGeom(points[2*i0], points[2*i0+1],\n                                                    points[2*i1], points[2*i1+1],\n                                                    points[2*i2], points[2*i2+1],\n                                                    color, dbId, layer, currentVpId);\n    \n                    if (antialiasEdges) {\n                        antialiasOneEdge(i0, i1);\n                        antialiasOneEdge(i1, i2);\n                        antialiasOneEdge(i2, i0);\n                    }\n                }\n            }\n            else {\n                const count = points.length / 2; // number of vertices\n    \n                this.flushBuffer(count);\n                const vbb = this.currentVbb;\n                const vbase = vbb.vcount;\n    \n                for (let i = 0; i < count; ++i) {\n                    const x = points[2*i];\n                    const y = points[2*i+1];\n                    vbb.addVertexPolytriangle(x, y, color, dbId, layer, currentVpId);\n                }\n    \n                vbb.addIndices(inds, vbase);\n    \n                if (antialiasEdges) {\n                    addAllAntialiasEdges();\n                }\n    \n            }\n        }\n    }\n\n    /**\n     * Returns a new GradientData instance.\n     * @param {Object} data - contains the raw data to create the GradientData.\n     * @returns {GradientData}\n     */\n    createGradientData(data) {\n        return new GradientData(data);\n    }\n\n    //Extract colors from HTML Canvas state\n    getFillColor() {\n        // Create a pattern from a CanvasGradient\n        const getGradientFill = (gradientData) => {\n            \n            const startPoint = gradientData.startPoint.slice();\n            const endPoint = gradientData.endPoint.slice();\n\n            const scale = this.viewport.scale || 1;\n            // Take into account the path's bounding box\n            const width = (this._curPath.bbox.max.x - this._curPath.bbox.min.x) / this.toPageUnits / scale;\n            const height = (this._curPath.bbox.max.y - this._curPath.bbox.min.y) / this.toPageUnits / scale;\n\n            // Get the offset from the bounding box\n            const offsetX = this._curPath.bbox.min.x / this.toPageUnits / scale;\n            const offsetY = this._curPath.bbox.min.y / this.toPageUnits / scale;\n\n            startPoint[0] -= offsetX;\n            startPoint[1] -= offsetY;\n            endPoint[0] -= offsetX;\n            endPoint[1] -= offsetY;\n\n            const tempCanvas = document.createElement('canvas');\n            tempCanvas.width = width;\n            tempCanvas.height = height;\n\n            const tempCtx = tempCanvas.getContext('2d');\n            // Create the gradient with the paths bounding box offset applied\n            // var gradient = createGradient(tempCtx, gradientData);\n            const gradient = gradientData.generateCanvasGradient(tempCtx, startPoint, endPoint);\n            tempCtx.fillStyle = gradient;\n            tempCtx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);\n\n            const pattern = this.createPattern(tempCanvas, 'no-repeat');\n            pattern.isGradient = true;\n            return pattern;\n        };\n\n        \n        const fillStyle = this.canvasContext.fillStyle;\n        if (fillStyle && fillStyle.isPattern === true) {\n            return fillStyle;\n        } else if (fillStyle instanceof CanvasGradient) {\n            const gradientData = new GradientData(fillStyle);\n            return getGradientFill(gradientData);\n        } else if (typeof fillStyle !== \"string\") {\n            console.warn(\"Unsupported fill style.\");\n            return 0x00000000;\n        }\n    \n        var rgb = parseInt(fillStyle.slice(1), 16);\n        var a = (255 * this.canvasContext.globalAlpha) << 24;\n        var c = a | ((rgb & 0xff) << 16) | (rgb & 0xff00) | ((rgb >> 16) & 0xff);\n        return c;\n    }\n\n    getStrokeColor() {\n\n        let ctx = this.canvasContext;\n    \n        if (this.lastStrokeStyle === ctx.strokeStyle && ctx.globalAlpha === this.lastAlpha) {\n            return this.lastRgb;\n        } else {\n            let rgb = parseInt(ctx.strokeStyle.slice(1), 16);\n            var a = (255 * ctx.globalAlpha) << 24;\n            var c = a | ((rgb & 0xff) << 16) | (rgb & 0xff00) | ((rgb >> 16) & 0xff);\n\n            this.lastRgb = c;\n            this.lastStrokeStyle = ctx.strokeStyle;\n            this.lastAlpha = ctx.globalAlpha;\n\n            return c;\n        }\n\n    }\n\n    getCurrentTransform() {\n        let xform = this.canvasContext.mozCurrentTransform;\n\n        //Pay attention here: In case we are processing the path of a character and we want to\n        //cache it for later use, we have to neutralize the part of the canvas transform that positions\n        //the character in the page, but we need to keep the rest of the transform (that positions parts\n        //of the character in its own em-box). This is what the inverse transform multiplication here does.\n        //TODO: we can optimize this to only compute the multiplication in case mozCurrentTransform changes.\n        if (this.isFontChar) {\n            let m = this.invXform;\n            let a = xform[0], b=xform[1], c = xform[2], d = xform[3], e = xform[4], f = xform[5];\n            _tmpXform[0] = m[0] * a + m[2] * b;\n            _tmpXform[1] = m[1] * a + m[3] * b;\n            _tmpXform[2] = m[0] * c + m[2] * d;\n            _tmpXform[3] = m[1] * c + m[3] * d;\n            _tmpXform[4] = m[0] * e + m[2] * f + m[4];\n            _tmpXform[5] = m[1] * e + m[3] * f + m[5];\n            return _tmpXform;\n        }\n        return xform;\n    }\n\n    tx(x, y, xform) {\n        xform = xform || this.getCurrentTransform();\n        return (x * xform[0] + y * xform[2] + xform[4]) * (this.isFontChar ? 1 : this.toPageUnits);\n    }\n\n    ty(x, y, xform) {\n        xform = xform || this.getCurrentTransform();\n        return (x * xform[1] + y * xform[3] + xform[5]) * (this.isFontChar ? 1 : this.toPageUnits);\n    }\n\n    scaleValue(v, xform) {\n        xform = xform || this.getCurrentTransform();\n        return this.toPageUnits * Math.sqrt(Math.abs(xform[0]*xform[3] - xform[1]*xform[2])) * v; //assumes uniform;\n    }\n\n    transformBox(bbox, xform, dst) {\n        xform = xform || this.getCurrentTransform();\n\n        _tmpBox.makeEmpty();\n\n        _tmpVec.set(this.tx(bbox.min.x, bbox.min.y, xform), this.ty(bbox.min.x, bbox.min.y, xform));\n        _tmpBox.expandByPoint(_tmpVec);\n\n        _tmpVec.set(this.tx(bbox.max.x, bbox.min.y, xform), this.ty(bbox.max.x, bbox.min.y, xform));\n        _tmpBox.expandByPoint(_tmpVec);\n\n        _tmpVec.set(this.tx(bbox.max.x, bbox.max.y, xform), this.ty(bbox.max.x, bbox.max.y, xform));\n        _tmpBox.expandByPoint(_tmpVec);\n\n        _tmpVec.set(this.tx(bbox.min.x, bbox.max.y, xform), this.ty(bbox.min.x, bbox.max.y, xform));\n        _tmpBox.expandByPoint(_tmpVec);\n\n        if (dst) {\n            dst.copy(_tmpBox);\n            return dst;\n        } else {\n            return _tmpBox.clone();\n        }\n    }\n\n\n    fillRect(x, y, w, h) {\n        this.updateDBId();\n\n        // Hack: Assumption here is that the first fillRect call is for the white background quad.\n        //       For this, we don't want a dbI and use -1 instead. Unfortunately, this fillRect call happens\n        //       inside PDF.js (see beginDrawing in display/canvas.js), so we cannot easily set this id from outside.\n        this.rect(x, y, w, h);\n        \n        this.dbId = this.first ? -1 : this.dbId;\n        this.first = false;\n        this.fill();\n        this.beginPath();\n    }\n\n    strokeRect(x, y, w, h) {\n        //TODO:\n        console.log(\"strokeRect\");\n    }\n\n    clearRect(x, y, w, h) {\n        console.log(\"clearRect\");\n        //TODO:\n    }\n\n    _beginTextChar(character, x, y, font, fontSize) {\n        this.isFontChar = true;\n        this.invXform = this.canvasContext.mozCurrentTransformInverse;\n        this.hashKey = character.charCodeAt(0) + \"/\" + font.loadedName + \"/\" + fontSize;\n        this.cachedGlyph = this.glyphCache[this.hashKey];\n\n        if (this.cachedGlyph) {\n            this.skipPath = true;\n        } else {\n            this.skipPath = false;\n        }\n        //console.log(character, x, y, font, fontSize);\n    }\n\n    drawMSDFText(character, scaleX, scaleY, font, fontSize) {\n        scaleX = 0;\n        var fontName = font.name;\n\n        function distance(x0, y0, x1, y1, x2, y2) {\n            return Math.abs((y2 - y1) * x0 - (x2 - x1) * y0 + x2 * y1 - y2 * x1) / Math.sqrt((y2 - y1) * (y2 - y1) + (x2 - x1) * (x2 - x1));\n        }\n        \n        if(this.fontAtlas && this.fontAtlas.charsMap && this.fontAtlas.charsMap[fontName]) {\n            var charIndex = this.fontAtlas.charsMap[fontName][character.charCodeAt(0)];\n            if(charIndex == undefined) {\n                return false;\n            } else {\n                if(this.currentVbb.isFull(4)) {\n                    this.flushBuffer(0, true);\n                }\n\n                this.hasMSDFContent = true;\n                var char = this.fontAtlas.chars[charIndex];\n                if(char.page > 0) {\n                    // Now only support 1 page of font texture, need to add extra logic for multiple font texture in the shader pipeline\n                    return false;\n                }\n                var common = this.fontAtlas.common[char.common];\n                var info = this.fontAtlas.info[char.info];\n\n                // need to consider the font size\n                var scale = fontSize/info.size;\n                var w = char.width * (scale + scaleX);\n                let flag = char.inverseYAxis ? -1 : 1;\n                var h = char.height* (scale + scaleY) * flag;\n                var x = char.txoffset * (scale + scaleX) , \n                    y = char.tyoffset * (scale + scaleY) * (-flag);\n\n                var points = [\n                    x, y,\n                    x, y + h,\n                    x + w, y + h,\n                    x + w, y\n                ];\n\n                var ps = [];\n                for(let i = 0; i < points.length; i+=2) {\n                    ps.push(this.tx(points[i], points[i+1]));\n                    ps.push(this.ty(points[i], points[i+1]));\n                }\n                let uv = [];\n\n                if(char.inverseYAxis) {\n                    uv = [\n                        char.x/common.scaleW, 1- char.y/common.scaleH,               \n                        char.x/common.scaleW, 1- (char.y + char.height)/common.scaleH,\n                        (char.x + char.width)/common.scaleW, 1- (char.y + char.height)/common.scaleH,\n                        (char.x + char.width)/common.scaleW, 1- char.y/common.scaleH,\n                    ];\n                } else {\n                    uv = [\n                        char.x/common.scaleW, 1- (char.y + char.height)/common.scaleH,\n                        char.x/common.scaleW, 1- char.y/common.scaleH,\n                        (char.x + char.width)/common.scaleW, 1- char.y/common.scaleH,\n                        (char.x + char.width)/common.scaleW, 1- (char.y + char.height)/common.scaleH,\n                    ];\n                }\n\n                // do a fast clipping for MSDF text, if the text is clipped out any part, will not show the text to make it simple\n                // otherwise it requires to do a whole UV mapping for each part left, which is overhead at this moment.\n                if(this._curClip) {\n                    var path = new Path2D(this.precisionTolerance);\n                    let index = 0;\n                    path.moveTo(ps[index++], ps[index++]);\n                    path.lineTo(ps[index++], ps[index++]);\n                    path.lineTo(ps[index++], ps[index++]);\n                    path.lineTo(ps[index++], ps[index++]);\n                    path.closePath();\n\n                    var subjFlatted = path.flattened || path.flatten(true);\n                    var clipFlatted = this._curClip.flattened || this._curClip.flatten(true);\n                    var precheckResult = path.preCheckForClipping(this, clipFlatted, subjFlatted, false, false);\n                    if(precheckResult.needClipping) {\n                        var polygons = path.msdfClipping(clipFlatted);\n                        let x1 = ps[0], y1 = ps[1];\n                        let x2 = ps[6], y2 = ps[7];\n                        let x3 = ps[2], y3 = ps[3];\n\n                        let w1 = Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));\n                        let h1 = Math.sqrt((x3 - x1) * (x3 - x1) + (y3 - y1) * (y3 - y1));\n                        // need to get the corresponding UV value\n                        for(var j = 0; j < polygons.length; j++) {\n                            let polygon = polygons[j];\n                            if(this.currentVbb.isFull(polygon.vertices.length)) {\n                                this.flushBuffer(0, true);\n                            }\n                            let vbase = this.currentVbb.vcount;\n                            for(var i = 0; i < polygon.vertices.length; i+=2) {\n                                let x0 = polygon.vertices[i];\n                                let y0 = polygon.vertices[i+1];\n                                let dy = distance(x0, y0, x1, y1, x2, y2);\n                                let dx = distance(x0, y0, x1, y1, x3, y3);\n    \n                                let u = uv[0] + (uv[4] - uv[0]) * (dx / w1);\n                                let v = uv[1] + (uv[5] - uv[1]) * (dy / h1);\n                                this.currentVbb.addVertexMSDFPolytriangle(x0, y0, u, v, this.getFillColor(), this.dbId, this.currentLayerId, 0);\n                            }\n                            this.currentVbb.addIndices(polygon.indices, vbase);\n                        }\n                        \n                        this.currentImage = this.fontAtlas.pages[char.page];\n                        return true;\n                    } else if (precheckResult.needCancel) {\n                        return true;\n                    }\n                }\n\n                if(this.currentVbb.isFull(4)) {\n                    this.flushBuffer(0, true);\n                }\n                let vbase = this.currentVbb.vcount;\n                var count =  points.length/2;\n                for(let i = 0; i < count; i++) {\n                    this.currentVbb.addVertexMSDFPolytriangle(ps[i*2], ps[i*2+1],uv[i*2], uv[i*2+1], this.getFillColor(), this.dbId, this.currentLayerId, 0);\n                }\n\n                this.currentVbb.addIndices([0,2,1, 0,2,3], vbase);\n                this.currentImage = this.fontAtlas.pages[char.page];\n\n                return true;\n            }\n            \n        } else {\n            return false;\n        }\n    }\n\n    beginPath(character, x, y, font, fontSize) {\n        this.updateDBId();\n\n        if (typeof character === \"string\" && font && fontSize) {\n            if(this.fontAtlas && this.drawMSDFText(character, x, y, font, fontSize)) {\n                this.skipPath = true;\n            } else {\n                if(this.usingTextLayer === true) {\n                    this.skipPath = true;\n                } else {\n                    this._beginTextChar(character, x, y, font, fontSize);\n                }\n            }\n        } else {\n            this.skipPath = false;\n            this.isFontChar = false;\n            this.cachedGlyph = null;\n        }\n\n        if (this.skipPath)\n            this._curPath = null;\n        else {\n            this._curPath = new Path2D(this.isFontChar ? 0.0001 : this.precisionTolerance);\n\n            // Apply custom tess params (if specified)\n            this._curPath.setTessParams(this.tessParams);\n        }\n    }\n\n    closePath() {\n\n        if (this.skipPath)\n            return;\n\n        this._curPath.closePath();\n        this.cachedGlyph = null;\n    }\n\n    moveTo(x, y) {\n\n        if (this.skipPath)\n            return;\n\n        if (!this._curPath)\n            this.beginPath();\n\n        let xform = this.getCurrentTransform();\n\n        this._curPath.moveTo(this.tx(x, y, xform), this.ty(x, y, xform));\n    }\n\n    lineTo(x, y) {\n\n        if (this.skipPath)\n            return;\n\n        let xform = this.getCurrentTransform();\n\n        this._curPath.lineTo(this.tx(x, y, xform), this.ty(x, y, xform));\n    }\n\n    arc(x, y, radius, startAngle, endAngle, anticlockwise) {\n\n        if (this.skipPath)\n            return;\n\n        //TODO: transform\n\n        this._curPath.arc(x, y, radius, startAngle, endAngle, anticlockwise);\n    }\n\n    arcTo(x1, y1, x2, y2, radius) {\n\n        if (this.skipPath)\n            return;\n\n        let xform = this.getCurrentTransform();\n\n        this._curPath.arcTo(this.tx(x1, y1, xform), this.ty(x1, y1, xform),\n                            this.tx(x2, y2, xform), this.ty(x2, y2, xform),\n                            this.scaleValue(radius, xform));\n    }\n\n    quadraticCurveTo(cp1x, cp1y, x, y) {\n\n        if (this.skipPath)\n            return;\n\n        let xform = this.getCurrentTransform();\n\n        this._curPath.quadraticCurveTo(this.tx(cp1x, cp1y, xform), this.ty(cp1x, cp1y, xform),\n                                       this.tx(x, y, xform), this.ty(x, y, xform));\n    }\n\n    bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y) {\n\n        if (this.skipPath)\n            return;\n\n        let xform = this.getCurrentTransform();\n\n        this._curPath.bezierCurveTo(this.tx(cp1x, cp1y, xform), this.ty(cp1x, cp1y, xform),\n                                    this.tx(cp2x, cp2y, xform), this.ty(cp2x, cp2y, xform),\n                                    this.tx(x, y, xform),       this.ty(x, y, xform) );\n    }\n\n    ellipse(cx, cy, rx, ry, rotation, startAngle, endAngle, ccw) {\n\n        if (this.skipPath) {\n            return;\n        }\n \n        // TODO: We currently don't use ellipse() with a transform.\n        //       The current code only works for translation and uniform scale.\n        //       For rotation, startAngle/endAngle would change.\n        //       For flipping, ccw may change.\n        //       For skew, it gets really fun: \n        //        see https://math.stackexchange.com/questions/2068583/when-you-skew-an-ellipse-how-do-you-calculate-the-angle-of-rotation-and-the-new\n        let xform = this.getCurrentTransform();\n        \n        this._curPath.ellipse(\n            this.tx(cx, cy, xform), this.ty(cx, cy, xform),\n            this.scaleValue(rx, xform),\n            this.scaleValue(ry, xform),\n            rotation,\n            startAngle, \n            endAngle,\n            ccw\n        );\n    }\n\n    rect(x, y, w, h) {\n\n        if (this.skipPath)\n            return;\n\n        let xform = this.getCurrentTransform();\n\n        if (!this._curPath)\n            this.beginPath();\n\n        this._curPath.moveTo(this.tx(x,   y,   xform), this.ty(x,   y,   xform));\n        this._curPath.lineTo(this.tx(x+w, y,   xform), this.ty(x+w, y,   xform));\n        this._curPath.lineTo(this.tx(x+w, y+h, xform), this.ty(x+w, y+h, xform));\n        this._curPath.lineTo(this.tx(x, y+h,   xform), this.ty(x, y+h,   xform));\n        this._curPath.closePath();\n    }\n\n    fill(...args) {\n\n        //Special flag passed to us by customization in the pdf.js library,\n        //telling us to skip the antialiasing for polygons that are both filled and stroked\n        let isFillStrokeCombo = false;\n        if (args.length) {\n            let lastArg = args[args.length-1];\n            if (typeof lastArg === \"boolean\") {\n                isFillStrokeCombo = lastArg;\n            }\n        }\n\n        if (this.isFontChar && !this.cachedGlyph) {\n            this.glyphCache[this.hashKey] = this._curPath;\n            this.cachedGlyph = this._curPath;\n            this.cachedGlyph.isFontChar = true;\n        }\n\n        this.isFontChar = false;\n\n        if (this.cachedGlyph) {\n            this.cachedGlyph.fill(this, this.getFillColor(), this.dbId, this.currentLayerId, this._curClip, true);\n        } else {\n            this._curPath && this._curPath.fill(this, this.getFillColor(), this.dbId, this.currentLayerId, this._curClip, false, isFillStrokeCombo);\n        }\n\n        this.skipPath = false;\n\n        //this._curClip = null;\n        //lmvContext._curPath = null;\n    }\n\n    stroke() {\n        if (this.isFontChar && !this.cachedGlyph) {\n            this.glyphCache[this.hashKey] = this._curPath;\n            this.cachedGlyph = this._curPath;\n            this.cachedGlyph.isFontChar = true;\n        }\n\n        this.updateLineDashStyle();\n        this.isFontChar = false;\n\n        // LineShader uses negative lineWidths to indicate screen-space line widths. Note that this.canvasContext.lineWidth does not allow negative values.\n        // Therefore, we apply the sign separately.\n        const sign = this.isScreenSpace ? -1.0 : 1.0;\n\n        if (this.cachedGlyph) {\n            this.cachedGlyph.stroke(this, sign * this.scaleValue(this.canvasContext.lineWidth * this.lineWidthScale), this.getStrokeColor(), this.dbId, this.currentLayerId, this._curClip, true, this.lineStyle);\n        } else {\n            this._curPath && this._curPath.stroke(this, sign * this.scaleValue(this.canvasContext.lineWidth * this.lineWidthScale), this.getStrokeColor(), this.dbId, this.currentLayerId, this._curClip, false, this.lineStyle);\n        }\n\n        this.skipPath = false;\n\n        //lmvContext._curPath = null;\n    }\n\n    clip(param1, param2) {\n\n        if (param2 !== undefined && param1 !== undefined) {\n            this._curClip = param1;\n            console.log(\"Probably unsupported use case\");\n        } else {\n\n            //The clip region is also affected by any existing clip region,\n            //i.e. we have to clip the clip.\n            if (this._curClip) {\n                this._curClip = this._curClip.clip(this._curPath, param1);\n            } else {\n                this._curClip = this._curPath;\n            }\n\n            this._curPath = null;\n        }\n\n        //console.log(\"CLIP\", param1, param2);\n    }\n\n    strokeText(text, x, y, maxWidth, font, fontSize) {\n\n        let ctx = this.canvasContext;\n        ctx.save();\n        ctx.translate(x, y);\n\n        this.fontEngine.drawText(this, text, 0, 0, font, fontSize);\n        this.stroke();\n\n        ctx.restore();\n    }\n\n    fillText(text, x, y, maxWidth, font, fontSize) {\n\n        let ctx = this.canvasContext;\n        ctx.save();\n        ctx.translate(x, y);\n\n        this.fontEngine.drawText(this, text, 0, 0, font, fontSize);\n        this.fill();\n        //this.stroke();\n\n        ctx.restore();\n    }\n\n    getRotationAndScale(xform) {\n        _mtx4.elements[0] = xform[0];\n        _mtx4.elements[1] = xform[1];\n        _mtx4.elements[4] = xform[2];\n        _mtx4.elements[5] = xform[3];\n        _mtx4.elements[12] = xform[4];\n        _mtx4.elements[13] = xform[5];\n        _mtx4.decompose(_offset, _quat, _scale);\n\n        //Derive the rotation angle by converting the quaternion to axis-angle.\n        let s = Math.sqrt(1.0 - _quat.w * _quat.w);\n        _axis.set(_quat.x / s, _quat.y / s, _quat.z / s);\n        let angle = 2.0 * Math.acos(Math.max(Math.min(1,_quat.w), -1));\n        //Take care to negate the angle if the rotation axis is into the page.\n        if (_quat.z < 0) {\n            angle = -angle;\n        }\n\n        //Angle needs to be in the range 0-2pi for use by addTextureQuad below,\n        //while input has domain [-pi, pi].\n        if (angle < 0) {\n            angle += 2 * Math.PI;\n        }\n\n        return {\n            angle,\n            scale: _scale\n        };\n    }\n\n    redrawImage(image, flipX, flipY, angle) {\n        const xform = [\n          flipX * Math.cos(angle),\n          flipY * Math.sin(angle),\n          -flipX * Math.sin(angle),\n          flipY * Math.cos(angle),\n          0,\n          0\n        ];\n\n        const [a,b,c,d,e,f] = xform;\n        const [p1, p2, p3, p4] = [\n          [0, 0],\n          [image.width, 0],\n          [image.width, image.height],\n          [0, image.height]\n        ].map(([x, y]) => [a * x + b * y + e, c * x + d * y + f]);\n\n        // new bounds\n        const [x1, y1, x2, y2] = [\n          Math.min(p1[0], p2[0], p3[0], p4[0]),\n          Math.min(p1[1], p2[1], p3[1], p4[1]),\n          Math.max(p1[0], p2[0], p3[0], p4[0]),\n          Math.max(p1[1], p2[1], p3[1], p4[1])\n        ];\n\n        const canvas = document.createElement('canvas');\n        canvas.width = x2 - x1;\n        canvas.height = y2 - y1;\n        const ctx = canvas.getContext('2d');\n        ctx.transform(...xform);\n\n        ctx.drawImage(image, x1, y1);\n        \n        // release memory\n        image.width = 0;\n        image.height = 0;\n\n        return canvas;\n    }\n\n    drawImage(image, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight) {\n\n        let group;\n        let clip = this._curClip;\n\n        if (this.inlineImageGroups && this.inlineImageGroups.map[this.currentOpIndex] != undefined) {\n          // means this is an inline image call, we have already have solution for it\n          const index = this.inlineImageGroups.map[this.currentOpIndex];\n          group = this.inlineImageGroups.groups[index];\n          // if the group has already been rendered, ignore that\n          if (group.rendered === true) {\n            return;\n          } else {\n            // mark it as rendered\n            group.rendered = true;\n            image = group.canvas;\n            clip = undefined; // improvement: consider clipping when merging images\n          }\n        }\n\n        if (image.width === 0 || image.height === 0) {\n            console.warn(\"Zero size image, skipping\");\n            return;\n        }\n\n        const xform = this.getCurrentTransform();\n        const { angle, scale } = this.getRotationAndScale(xform);\n\n        if (group) {\n\n            let [flipX, flipY] = [Math.sign(scale.x), Math.sign(scale.y)];\n\n            // redraw image if the current transform flips the image\n            if (flipX < 0 || flipY < 0) {\n                image = this.redrawImage(image, flipX, flipY, -angle);\n            }\n\n            // If the current transform rotates the image by 90 or 180-deg, \n            // it already adjusts for Y offset\n            let offsetY = group.flipY ? image.height : 0;\n            const MIN = 1e-10;\n            if (Math.abs(Math.cos(angle) - 1) > MIN) {\n                offsetY = 0;\n            }\n\n            // need to revert the scale\n            offsetY *= group.minScale;\n\n            dx = group.bounds.min.x;\n            dy = group.bounds.min.y + offsetY;\n            dWidth = image.width * group.minScale;\n            dHeight = image.height * group.minScale;\n        }\n\n        if (dx === undefined) {\n            dx = sx;\n            dy = sy;\n            dWidth = sWidth;\n            dHeight = sHeight;\n        }\n\n        if (dWidth === undefined) {\n            dWidth = image.width;\n            dHeight = image.height;\n        }\n\n        if (!dWidth) {\n            console.warn(\"Zero size image, skipping\");\n            return;\n        }\n\n//console.log(\"Draw image\", dWidth, dHeight);\n\n        //Get the transformed page space image center\n        let cx = this.tx(dx + dWidth/2, dy + dHeight/2);\n        let cy = this.ty(dx + dWidth/2, dy + dHeight/2);\n\n        //Get scaled width/height. Note these scalings can result in negative numbers\n        let w = dWidth * scale.x * this.toPageUnits;\n        let h = -dHeight * scale.y * this.toPageUnits; //Image input is y-down, so we build in a y-inversion\n\n        if (clip) {\n            // if a clipping path is specified we will render the image with the clipping polygon and\n            // not with a quad\n            let color = {\n                image: image,\n                imageTransform: {\n                    width: dWidth,\n                    height: Math.sign(xform[3]) * -dHeight, // LMV-5840 flip the Y\n                    x: dx,\n                    y: dy\n                }\n            };\n\n            // the clipping path might be larger than the image so we need to clip it with the image quad\n            // to avoid repetition\n            let imageClip = new Path2D(this.precisionTolerance);\n            imageClip.moveTo(this.tx(dx, dy), this.ty(dx, dy));\n            imageClip.lineTo(this.tx(dx + dWidth, dy), this.ty(dx + dWidth, dy));\n            imageClip.lineTo(this.tx(dx + dWidth, dy + dHeight), this.ty(dx + dWidth, dy + dHeight));\n            imageClip.lineTo(this.tx(dx, dy + dHeight), this.ty(dx, dy + dHeight));\n            imageClip.closePath();\n\n            clip.fill(this, color, this.dbId, this.currentLayerId, imageClip, false, false);\n        } else {\n\t        this.flushBuffer(0, true);\n\t        this.currentVbb.addTexturedQuad(cx, cy, w, h, angle, 0xffff00ff, 0, this.currentLayerId, 0);\n\t        this.currentImage = image;\n\t        this.flushBuffer(0, true, QUAD_TEXTURE);\n        }\n    }\n\n    /**\n     * Mapping back the reference object to its value, and loop 1 level in\n     * @param {Object} properties \n     */\n    _processProperties(properties) {\n        if(LmvCanvasContext.isRef(properties)) {\n            properties = this.pdfRefMap[LmvCanvasContext.refKey(properties)];\n        }\n\n        for(let key in properties) {\n            if(LmvCanvasContext.isRef(properties[key])) {\n                properties[key] = this.pdfRefMap[LmvCanvasContext.refKey(properties[key])];\n            }\n        }\n        return properties;\n    }\n\n    _getPrecision(propPrecision) {\n        return propPrecision !== undefined ? propPrecision : 5;\n    }\n\n    beginMarkedContent(properties) {\n        if(properties) {\n            properties = this._processProperties(properties);\n        }\n\n        // Revit will provided tag as number\n        let tag = properties.name || properties.DBID;\n        if(!isNaN(tag)) {\n            this.taggedId = parseInt(tag);\n        } else {\n            this.taggedId = null;\n        }\n\n        if(this.taggedId !== null && this.dbId !== this.taggedId) {\n            this.updateDBId();\n        }\n\n        if(properties.VP) {\n            this.currentVpId = this.viewports.length;\n            const vp = this._getModelToViewportMatrix(properties.VP, !!properties.UNITS);\n\n            const precision = this._getPrecision(properties.PRECISION);\n            this.viewports.push(this.createViewPortData(vp, properties.UNITS, precision));\n        }\n\n        this.ocgStack.push({\n            taggedId: this.taggedId,\n            viewPortId: this.currentVpId\n        });\n    }\n\n    beginMarkedContentProps(tag, properties) {\n        if(properties) {\n            properties = this._processProperties(properties);\n        }\n\n        if(tag === \"OC\") {\n            let ocgId = properties.ocgId;\n            var layerId = this.layers[ocgId];\n            if(layerId === undefined) {\n                layerId = this.defaultLayerId;\n            }\n            this.currentLayerId = layerId;\n\n            this.ocgStack.push({\n                layerId: this.currentLayerId,\n            });\n        } else {\n            if(!isNaN(tag)) {\n                this.taggedId = parseInt(tag);\n                if(this.dbId !== this.taggedId) {\n                    this.updateDBId();\n                }\n            }\n            if(properties ) {\n                if(properties.VP) {\n                    this.currentVpId = this.viewports.length;\n                    const vp = this._getModelToViewportMatrix(properties.VP, !!properties.UNITS);\n                    const precision = this._getPrecision(properties.PRECISION);\n                    this.viewports.push(this.createViewPortData(vp, properties.UNITS, precision));\n                }\n\n                this.ocgStack.push({\n                    viewPortId: this.currentVpId,\n                    taggedId: this.taggedId,\n                });\n            } else {\n                this.ocgStack.push({\n                });  \n            }\n        }\n    }\n\n    endMarkedContent() {\n        var previousState = this.ocgStack.pop();\n        var previousTagId = this.taggedId;\n        if(previousState) {\n            // reset the state\n            if(previousState.taggedId != null) {\n                this.taggedId = null;\n            }\n            if (previousState.layerId) {\n                this.currentLayerId = this.defaultLayerId;\n            }\n            if (previousState.viewPortId) {\n                this.currentVpId = this.defaultVPId;\n            }\n        }\n\n        if(this.ocgStack.length > 0) {\n            let state = this.ocgStack[this.ocgStack.length - 1];\n            if(state.taggedId != null) {\n                this.taggedId = state.taggedId;\n            }\n            if (state.currentLayerId != null) {\n                this.currentLayerId = state.currentLayerId;\n            }\n            if (state.viewPortId != null) {\n                this.currentVpId = state.viewPortId;\n            }\n        } else {\n            this.currentLayerId = this.defaultLayerId;\n            this.taggedId = null;\n            this.currentVpId = this.defaultVPId;\n        }\n\n        if(previousTagId !== this.taggedId) {\n            this.updateDBId();\n        }\n    }\n\n    setLineStyleParam(param) {\n        if(!this.lineStyleInitialized) {\n            // Add those default definition in, to keep the app constent.\n            let exH = avp.LineStyleDefs.length;\n            let exW = 1;\n            for(var i = 0; i < avp.LineStyleDefs.length; i++) {\n                exW = Math.max(avp.LineStyleDefs[i].def.length, exW);\n            }\n\n            let {tex, pw, lineStyleTex} = avp.createLinePatternTextureData(Math.max(param.width, exW), param.height + exH + 1);\n            this.lineStyleIndex = 0;\n            this.lineStylePw = pw;\n            this.lineStyleTexData = tex;\n            this.lineStyleTexture = lineStyleTex;\n            this.lineStyleIndexMap = {};\n    \n            for(let i = 0; i < avp.LineStyleDefs.length; i++) {\n                this.addNewDashedLineStyle(avp.LineStyleDefs[i], 96);\n            }\n\n            // set the default value\n            this.lineStyle = 0;\n            this.lineStyleInitialized = true;\n        }\n    }\n\n    addNewDashedLineStyle(ls, dpi) {\n        let key = ls.def.join(\"/\");\n        if(this.lineStyleIndexMap[key] != undefined) {\n            return this.lineStyleIndexMap[key];\n        } else {\n            avp.createLinePatternForDef(ls, this.lineStyleTexData, this.lineStyleIndex, this.lineStylePw, dpi);\n            let index = this.lineStyleIndex;\n            this.lineStyleIndexMap[key] = index;\n            this.lineStyleIndex++;\n\n            return index;\n        }\n    }\n\n    setLineDash(def) {\n        if(!this.lineStyleInitialized) {\n            this.setLineStyleParam({width: 5, height: 4});\n        }\n\n        this.lineDashedDef = def;\n    }\n\n    createPattern(image, repetition) {\n        var pattern = this.canvasContext._originalcreatePattern(image, repetition);\n        pattern.image = image;\n        pattern.repetition = repetition;\n        pattern.isPattern = true;\n        return  pattern;\n    }\n\n    updateLineDashStyle() {\n        // need apply the transformation matrix to the dashed value\n        let def = this.lineDashedDef;\n\n        if(def) {\n            if(def.length > 0) {\n                let xform = this.getCurrentTransform();\n                let def1 = [];\n                for(var i = 0; i < def.length; i++) {\n                    let x = (def[i] * xform[0] + def[i] * xform[2]) * this.toPageUnits;\n                    x = parseFloat(x.toFixed(6));\n                    def1.push(x);\n                }\n                // 96 DPI was defined for lineStyleDef.js, and shader were expecting that value\n                // when we parse the pdf, the effective dpi need to be ==> 96 / 72 / this.toPageUnits\n                this.lineStyle = this.addNewDashedLineStyle({def: def1}, 96 / 72 / this.toPageUnits);\n            } else {\n                this.lineStyle = 0;\n            }\n        }\n        // In case of user directly controlled the line style\n        // Do not set lineStyle to 0 here.\n    }\n\n    setCircleInfo(circleInfo) {\n        this.circleInfo = circleInfo;\n    }\n\n    setCurrentOperatorIndex(index) {\n        this.currentOpIndex = index;\n        if(this.circleInfo && this.circleInfo[index]) {\n            let xform = this.getCurrentTransform();\n            let x = this.tx(this.circleInfo[index][0], this.circleInfo[index][1], xform);\n            let y = this.ty(this.circleInfo[index][0], this.circleInfo[index][1], xform);\n\n            // Inject the center of the circle\n            const hiddenColor = 0x01ffffff; // Note that lineShader discards fully transparent fragments. Therefore, we use a white here with very small, but nonzero alpha.\n            let c = this.currentVbb.addVertexLine(x, y, 0, 0.0001, 0, 0, hiddenColor, this.dbId, this.currentLayerId, this.currentVpId);\n            this.currentVbb.finalizeQuad(c);\n        }\n    }\n\n    /**\n     * We have fuge performance issue when the PDF contains inline image group\n     * And each line will call a drawImage, with the whole texture enabled\n     * It causes OOM and slow down the whole rendering\n     * In order to boost the performance, we need to do a preprocess to combine those scane line images\n     * Once, we have that information, we ignore the draw call for those images,\n     * this function is the entry point to pass those preprocessed image in to the drawing context\n     * LMV-5175\n     * \n     * @param {Object} imageGroups \n     */\n    setInlineImageGroups(imageGroups) {\n        if(imageGroups && imageGroups.groups.length > 0) {\n            this.inlineImageGroups = imageGroups;\n        }\n    }\n\n    needDelegateInlineImageGroup() {\n        var hasGroup = this.inlineImageGroups && this.inlineImageGroups.map[this.currentOpIndex] != undefined;\n        return hasGroup;\n    }\n\n    // Set custom tesselation params for bezier arcs (see Bezier.h)\n    // If undefined, we use the default settings.\n    setTessParams(tessParams) {\n        this.tessParams = tessParams;\n    }\n\n    finish() {\n        this.flushBuffer(0, true);\n        this.fontAtlas = null;\n    }\n\n    createViewPortData(matrix, units, precision) {\n\n        precision = precision !== undefined ? precision : 5; // LMV-5701: Default precision will be set to 5.\n\n        return {\n            \"units\": units || \"feet and inches\",\n            \"transform\": matrix,\n            \"geom_metrics\": this.initGeomMetrics(),\n            \"precision\": precision \n        };\n    }\n\n    isLMVCanvasContext() {\n        return true;\n    }\n\n    //Initializes a structure of counters used for statistical purposes and sheet content hash\n     initGeomMetrics() {\n        return {\n            \"arcs\": 0,\n            \"circles\": 0,\n            \"circ_arcs\": 0,\n            \"viewports\": 0,\n            \"clips\": 0,\n            \"colors\": 0,\n            \"db_ids\": 0,\n            \"dots\": 0,\n            \"fills\": 0,\n            \"layers\": 0,\n            \"line_caps\": 0,\n            \"line_joins\": 0,\n            \"line_patterns\": 0,\n            \"line_pat_refs\": 0,\n            \"plines\": 0,\n            \"pline_points\": 0,\n            \"line_weights\": 0,\n            \"links\": 0,\n            \"miters\": 0,\n            \"ptris\": 0,\n            \"ptri_indices\": 0,\n            \"ptri_points\": 0,\n            \"rasters\": 0,\n            \"texts\": 0,\n            \"strings\": []\n        };\n    }\n\n    // Needs to be called when using \n    //Copied from pdf.js, because our 2D renderer relies on mozCurrentTransform being available\n    addContextCurrentTransform() {\n\n        const ctx = this.canvasContext;\n\n        if (!ctx.mozCurrentTransform) {\n            ctx._originalSave = ctx.save;\n            ctx._originalRestore = ctx.restore;\n            ctx._originalRotate = ctx.rotate;\n            ctx._originalScale = ctx.scale;\n            ctx._originalTranslate = ctx.translate;\n            ctx._originalTransform = ctx.transform;\n            ctx._originalSetTransform = ctx.setTransform;\n            ctx._transformMatrix = ctx._transformMatrix || [1, 0, 0, 1, 0, 0];\n            ctx._transformStack = [];\n            Object.defineProperty(ctx, 'mozCurrentTransform', {\n            get: function getCurrentTransform() {\n                return this._transformMatrix;\n            }\n            });\n            Object.defineProperty(ctx, 'mozCurrentTransformInverse', {\n            get: function getCurrentTransformInverse() {\n                var m = this._transformMatrix;\n                var a = m[0],\n                    b = m[1],\n                    c = m[2],\n                    d = m[3],\n                    e = m[4],\n                    f = m[5];\n                var ad_bc = a * d - b * c;\n                var bc_ad = b * c - a * d;\n                return [d / ad_bc, b / bc_ad, c / bc_ad, a / ad_bc, (d * e - c * f) / bc_ad, (b * e - a * f) / ad_bc];\n            }\n            });\n            ctx.save = function ctxSave() {\n            var old = this._transformMatrix;\n            this._transformStack.push(old);\n            this._transformMatrix = old.slice(0, 6);\n            this._originalSave();\n            };\n            ctx.restore = function ctxRestore() {\n            var prev = this._transformStack.pop();\n            if (prev) {\n                this._transformMatrix = prev;\n                this._originalRestore();\n            }\n            };\n            ctx.translate = function ctxTranslate(x, y) {\n            var m = this._transformMatrix;\n            m[4] = m[0] * x + m[2] * y + m[4];\n            m[5] = m[1] * x + m[3] * y + m[5];\n            this._originalTranslate(x, y);\n            };\n            ctx.scale = function ctxScale(x, y) {\n            var m = this._transformMatrix;\n            m[0] = m[0] * x;\n            m[1] = m[1] * x;\n            m[2] = m[2] * y;\n            m[3] = m[3] * y;\n            this._originalScale(x, y);\n            };\n            ctx.transform = function ctxTransform(a, b, c, d, e, f) {\n            var m = this._transformMatrix;\n            this._transformMatrix = [m[0] * a + m[2] * b, m[1] * a + m[3] * b, m[0] * c + m[2] * d, m[1] * c + m[3] * d, m[0] * e + m[2] * f + m[4], m[1] * e + m[3] * f + m[5]];\n            ctx._originalTransform(a, b, c, d, e, f);\n            };\n            ctx.setTransform = function ctxSetTransform(a, b, c, d, e, f) {\n            this._transformMatrix = [a, b, c, d, e, f];\n            ctx._originalSetTransform(a, b, c, d, e, f);\n            };\n            ctx.rotate = function ctxRotate(angle) {\n            var cosValue = Math.cos(angle);\n            var sinValue = Math.sin(angle);\n            var m = this._transformMatrix;\n            this._transformMatrix = [m[0] * cosValue + m[2] * sinValue, m[1] * cosValue + m[3] * sinValue, m[0] * -sinValue + m[2] * cosValue, m[1] * -sinValue + m[3] * cosValue, m[4], m[5]];\n            this._originalRotate(angle);\n            };\n        }\n    }\n\n    createChildGroupContext() {\n        this.flushBuffer(0, true);\n        var self;\n\n        const alpha = this.canvasContext?.globalAlpha;\n        function meshCallback(mesh) {\n            // LMV-5840: Apply the global alpha to the meshes in the group.\n            if (typeof alpha === 'number' && mesh.material.opacity !== alpha) {\n                mesh.material.hasOpacity = !!alpha;\n                mesh.material.opacity = alpha;\n            }\n            self.groupChildMeshes.push(mesh);\n        }\n\n        var ctx = new LmvCanvasContext(this.viewport, this.toPageUnits, meshCallback, this.fontEngine, this.usingTextLayer, this.fontAtlas, this.pdfRefMap);\n        // Assign different dbids to geometry in the child group context. LMV-5515\n        ctx.consecutiveIds = true;\n\n        ctx.groupChildMeshes = [];\n\n        ctx.sequencedDbId = this.sequencedDbId;\n        ctx.dbId = this.dbId;\n        ctx.imageNumber = this.imageNumber;\n        self = ctx;\n\n        ctx.addContextCurrentTransform();\n        ctx.parent = this;\n        ctx.canvasContext.isLMVGroupContext = true;\n        return ctx.canvasContext;\n    }\n\n    endChildGroupContext() {\n        this.flushBuffer(0, true);\n\n        if(this.groupChildMeshes && this.groupChildMeshes.length > 0) {\n            var self = this;\n            // mesh's matrix has already been converted to pageUnit, for this group matrix\n            // we need to conver the translation matrix back to pageUnit\n            var groupMatrix = self.parent.getCurrentTransform();\n            var translateX = groupMatrix[4] * self.toPageUnits;\n            var translateY = groupMatrix[5] * self.toPageUnits;\n\n            var matrix = new THREE.Matrix4();\n            matrix.makeTranslation(translateX, translateY, 0);\n\n            var meshIndex = 0;\n            this.groupChildMeshes.map(mesh => {\n                switch (self.parent.canvasContext.globalCompositeOperation) {\n                    case 'darken':\n                        mesh.material.compositeOperation = 'min';\n                        break;\n                    case 'lighten':\n                        mesh.material.compositeOperation = 'max';\n                        break;\n                    case 'multiply':\n                        mesh.material.compositeOperation = 'multiply';\n                        break;\n                }\n                // If we have nested stack of group\n                // we need multiply the matrix, Kevin: I do not have any test pdf for this assumption\n                // in future if we see something wrong, we need try to revisit this part\n                if (mesh.groupMatrix) {\n                    mesh.groupMatrix.multiply(matrix);\n                } else {\n                    // make a clone to avoid the matrix was modified multiple times when it was nested\n                    mesh.groupMatrix = matrix.clone();\n                }\n\n                self.parent.meshCallback(mesh, meshIndex + this.parent.currentMeshIndex) ;\n                meshIndex++;\n            });\n\n            this.parent.sequencedDbId = this.sequencedDbId;\n            this.parent.currentMeshIndex += meshIndex;\n            this.parent.dbId = this.dbId;\n            this.parent.imageNumber = this.imageNumber;\n            this.groupChildMeshes.length = 0;\n        }\n    }\n\n    _getModelToViewportMatrix(vpData, isUnitsDefined) {\n        // This is the model to vp matrix without 300 / 72 viewport scaling\n        const vp = typeof vpData === 'string' ? JSON.parse(vpData) : vpData;\n        // Apply the viewport scale\n        if (isUnitsDefined) {\n            vp[0] *= this.viewport.scale;\n            vp[5] *= this.viewport.scale;\n        }\n        return vp;\n    }\n\n}\n\n/**\n * Class used to normalize gradient data.\n */\nclass GradientData {\n    constructor(color) {\n        // RawData comes from PDFjs.\n        if (Object.prototype.hasOwnProperty.call(color, 'rawData')) {\n            const data = color.rawData;\n            this.type = data[1];\n            this.colorStops = data[3];\n            this.startPoint = data[4];\n            this.endPoint = data[5];\n            this.startRadius = data[6];\n            this.endRadius = data[7];\n        } else {\n            Object.assign(this, color);\n        }\n    }\n\n    /**\n     * Check if the GradientData is valid.\n     * @return {boolean} - true if valid.\n     */\n    isValid() {\n        if (!this.type || !this.startPoint || !this.endPoint || !this.colorStops) {\n            return false;\n        }\n\n        if (this.type === 'radial' && (this.startRadius === undefined || this.endRadius === undefined)) {\n            return false;\n        }\n\n        return true;\n    }\n\n    /**\n     * Creates a temporary canvasGradient with all of the GradientData properties assigned to it.\n     * This is required when assigning a context's fillstyle.\n     * @param {CanvasRenderingContext2D} ctx - 2d render context.\n     * @returns {CanvasGradient} - containing the GradientData's properties\n     */\n    getFillStyle(ctx) {\n        if (!this.isValid()) {\n            return;\n        }\n        // This is a temporary gradient. It is only used to pass the gradient data's properties to the fillStyle.\n        const tempGradient = ctx.createLinearGradient(0, 0, 1, 1);\n        Object.assign(tempGradient, this);\n        return tempGradient;\n    }\n\n    /**\n     * Generate a CanvasGradient.\n     * @param {CanvasRenderingContext2D} ctx - 2d render context.\n     * @param {number[]} [startPoint] - modified start position\n     * @param {number[]} [endPoint] - modified end position\n     * @returns {CanvasGradient} - Canvas Gradient\n     */\n    generateCanvasGradient(ctx, startPoint, endPoint) {\n        if (!this.isValid()) {\n            return;\n        }\n        const type = this.type;\n        const colorStops = this.colorStops;\n        const p0 = startPoint || this.startPoint;\n        const p1 = endPoint || this.endPoint;\n        const r0 = this.startRadius;\n        const r1 = this.endRadius;\n        let grad = null;\n\n        if (type === 'axial' || type === 'linear') {\n            grad = ctx.createLinearGradient(p0[0], p0[1], p1[0], p1[1]);\n        } else if (type === 'radial') {\n            grad = ctx.createRadialGradient(p0[0], p0[1], r0, p1[0], p1[1], r1);\n        }\n        for (let i = 0, ii = colorStops.length; i < ii; ++i) {\n            const c = colorStops[i];\n            grad.addColorStop(c[0], c[1]);\n        }\n\n        return grad;\n    }\n}","\nimport {TOL} from \"./fuzzy-math\";\nimport { QuadTree } from \"./quad-tree\";\nimport lmv_poly2tri from \"./ThirdParty/lmv_poly2tri\";\n\nexport class UniquePointList {\n\n    constructor(bbox, precisionTolerance, VertexConstructor, useQuadTree) {\n\n        this.bbox = bbox;\n        this.boxSize = this.bbox.size().length();\n\n        if (typeof precisionTolerance === \"number\") {\n            //Input is in model units, e.g. if model is in feet,\n            //precision tolerance has to be in feet\n            this.precisionTolerance = precisionTolerance;\n            this.scale = 1.0 / this.precisionTolerance;\n        } else {\n            this.precisionTolerance = TOL * this.boxSize;\n            this.scale = 1.0 / this.precisionTolerance;\n        }\n\n        this.precisionToleranceSq = this.precisionTolerance * this.precisionTolerance;\n\n        this.snapBaseX = (this.bbox.min.x); ///- 0.5 * this.precisionTolerance;\n        this.snapBaseY = (this.bbox.min.y); //- 0.5 * this.precisionTolerance;\n\n\n        this.pts = [];\n        this.xymap = new Map();\n\n        if (useQuadTree)\n            this.quadTreeVerts = new QuadTree(bbox.min.x, bbox.min.y, bbox.max.x, bbox.max.y, precisionTolerance);\n\n        this.vertexConstructor = VertexConstructor;\n    }\n\n    findOrAddPoint(px, py, dbIds) {\n\n        //Snap the vertex to our desired granularity\n        let x = 0 | /*Math.round*/((px - this.snapBaseX) * this.scale);\n        let y = 0 | /*Math.round*/((py - this.snapBaseY) * this.scale);\n\n        //Find the nearest snapped vertex or create new\n        let v;\n        let minDist = Infinity;\n        //Look in the 9 square area surrounding the vertex\n        for (let i=x-1; i<=x+1; i++) {\n            let mx = this.xymap.get(i);\n            if (!mx)\n                continue;\n\n            for (let j=y-1; j<=y+1; j++) {\n                let tmp = mx.get(j);\n                if (!tmp)\n                    continue;\n\n                let dist = (tmp.x - px) * (tmp.x - px) + (tmp.y - py) * (tmp.y - py);\n\n                if (dist < minDist) {\n                    v = tmp;\n                    minDist = dist;\n                }\n            }\n        }\n\n        if (minDist > this.precisionToleranceSq)\n            v = undefined;\n\n        if (v === undefined) {\n            let mx = this.xymap.get(x);\n\n            if (!mx) {\n                mx = new Map();\n                this.xymap.set(x, mx);\n            }\n\n            v = this.vertexConstructor ? new this.vertexConstructor(px, py) : new lmv_poly2tri.Point(px, py);\n            mx.set(y, v);\n            v.id = this.pts.length;\n            this.pts.push(v);\n\n            if (this.quadTreeVerts)\n                this.quadTreeVerts.addItem(v);\n        }\n\n        //Remember the source object that's adding this vertex\n        if (typeof dbIds !== \"undefined\") {\n            if (typeof dbIds === \"number\") {\n                if (v.dbIds.indexOf(dbIds) === -1)\n                    v.dbIds.push(dbIds);\n            } else if (dbIds) {\n                for (let i=0; i<dbIds.length; i++) {\n                    let dbId = dbIds[i];\n                    if (v.dbIds.indexOf(dbId) === -1)\n                        v.dbIds.push(dbId);\n                }\n            }\n            v.dbIdsChanged = true;\n        }\n\n        return v;\n    }\n\n\n    forEach(f) {\n        this.pts.forEach(f);\n    }\n\n    delete(v) {\n        this.pts[v.id] = undefined;\n\n        if (this.quadTreeVerts)\n            this.quadTreeVerts.deleteItem(v);\n    }\n\n    //filters out null entries from the point list\n    compact() {\n\n        let pts = [];\n\n        for (let i=0, len=this.pts.length; i<len; i++) {\n            let v = this.pts[i];\n            if (!v)\n                continue;\n\n            v.oldid = v.id;\n            v.id = pts.length;\n            pts.push(v);\n        }\n\n        this.pts = pts;\n\n    }\n\n    enumInBox(minx, miny, maxx, maxy, f) {\n        this.quadTreeVerts.enumInBox(minx, miny, maxx, maxy, f);\n    }\n\n}","import { xLineBox } from \"./x-line-box\";\r\nimport { xBoxBox } from \"./x-box-box\";\r\n\r\n//Spatial index data structure for fast lookup of line segments or points.\r\n//\r\n// It can also be used for other kinds of items. For this, you can specify an itemHandler, which tells the quadtree \r\n// how to work with the items. It must provide two functions:\r\n//\r\n// itemHandler = {\r\n//    // Check wheter the (bbox of) this item intersects with the given one\r\n//    insersectsBox: function(item, xmin, ymin, xmax, ymax) {...},\r\n// \r\n//    // Set 'outPoint' to a point on or close to the item, e.g. bbox center. outPoint is a {x, y} pair.\r\n//    getPoint: function(item, outPoint) {...}\r\n//  }\r\n\r\n\r\n\r\nconst ITEMS_PER_NODE = 16;\r\nconst EPS = 1e-20;\r\nconst avp = Autodesk.Viewing.Private;\r\nconst logger = avp.logger;\r\n\r\nconst tmpPoint = {x:0, y:0};\r\n\r\nexport class QuadTree {\r\n\r\n    constructor(minx, miny, maxx, maxy, extraDistance, itemHandler) {\r\n\r\n        this.items = [];\r\n        this.children = null;\r\n        this.itemCount = 0;\r\n\r\n        this.extraDistance = extraDistance;\r\n\r\n        this.minx = minx;\r\n        this.miny = miny;\r\n        this.maxx = maxx;\r\n        this.maxy = maxy;\r\n\r\n        this.itemHandler = itemHandler;\r\n    }\r\n\r\n\r\n    addItem(e) {\r\n\r\n        //TODO: must check if item fits inside our total bbox\r\n        //before adding. In such case we may have to expand the\r\n        //tree somehow\r\n\r\n        this.itemCount++;\r\n\r\n        if (this.children) {\r\n            let overlapCount = 0;\r\n            let whichChild = null;\r\n\r\n            for (let i=0; i<4; i++) {\r\n                if (this.children[i].intersectsItem(e)) {\r\n                    whichChild = this.children[i];\r\n                    overlapCount++;\r\n                }\r\n            }\r\n\r\n            if (overlapCount === 1) {\r\n                whichChild.addItem(e);\r\n            } else if (overlapCount !== 0) {\r\n                this.items.push(e);\r\n            }\r\n\r\n        } else {\r\n            this.items.push(e);\r\n\r\n            if (this.items.length > ITEMS_PER_NODE)\r\n                this.subdivide();\r\n        }\r\n\r\n        return this.itemCount;\r\n    }\r\n\r\n    deleteItem(e) {\r\n\r\n        if (!this.intersectsItem(e))\r\n            return 0;\r\n\r\n        if (this.items) {\r\n            let idx = this.items.indexOf(e);\r\n            if (idx >=0) {\r\n                this.items.splice(idx, 1);\r\n                this.itemCount--;\r\n                return 1;\r\n            }\r\n        }\r\n\r\n        if (this.children) {\r\n            let deleteCount = 0;\r\n            let remainingItemsCount = 0;\r\n            for (let i=0; i<4; i++) {\r\n                deleteCount += this.children[i].deleteItem(e);\r\n                remainingItemsCount += this.children[i].itemCount;\r\n            }\r\n\r\n            if (remainingItemsCount < ITEMS_PER_NODE) {\r\n                //TODO: un-split the node here\r\n            }\r\n\r\n            if (deleteCount === 1) {\r\n                this.itemCount--;\r\n                return 1;\r\n            } else {\r\n                logger.warn(\"Did not find item to delete. Something is wrong.\", deleteCount);\r\n                return 0;\r\n            }\r\n        }\r\n\r\n        return 0;\r\n    }\r\n\r\n    intersectsBox(minx, miny, maxx, maxy) {\r\n\r\n        let d = this.extraDistance;\r\n\r\n        return xBoxBox(minx, miny, maxx, maxy,\r\n            this.minx - d, this.miny - d, this.maxx + d, this.maxy + d);\r\n    }\r\n\r\n    intersectsItem(e) {\r\n\r\n        if (this.itemHandler) {\r\n            return this.itemHandler.intersectsBox(e, \r\n                this.minx - this.extraDistance, this.miny - this.extraDistance,\r\n                this.maxx + this.extraDistance, this.maxy + this.extraDistance\r\n            );\r\n        } else if (e.v1) {\r\n            //Edge\r\n            return xLineBox(e.v1.x, e.v1.y, e.v2.x, e.v2.y,\r\n                            this.minx - this.extraDistance, this.miny - this.extraDistance,\r\n                            this.maxx + this.extraDistance, this.maxy + this.extraDistance);\r\n        } else {\r\n            //Vertex\r\n            return this.intersectsBox(e.x, e.y, e.x, e.y);\r\n        }\r\n    }\r\n\r\n    findSplitPoint() {\r\n        //determine split location -- we split along the\r\n        //midpoint of actual data inside the node\r\n        let xs = [];\r\n        let ys = [];\r\n\r\n        if (this.itemHandler) {\r\n            for (let i=0; i<this.items.length; i++) {\r\n                this.itemHandler.getPoint(this.items[i], tmpPoint);\r\n                xs.push(tmpPoint.x);\r\n                ys.push(tmpPoint.y);\r\n            }\r\n        } else if (this.items[0].v1) {\r\n            for (let i=0; i<this.items.length; i++) {\r\n                xs.push(this.items[i].v1.x);\r\n                ys.push(this.items[i].v1.y);\r\n            }\r\n        } else {\r\n            for (let i=0; i<this.items.length; i++) {\r\n                xs.push(this.items[i].x);\r\n                ys.push(this.items[i].y);\r\n            }\r\n        }\r\n\r\n        xs.sort((a,b) => { return a-b;});\r\n        ys.sort((a,b) => { return a-b;});\r\n\r\n        //Split slightly to the left of the median min point for all edge items\r\n        let midx = xs[0 | ((xs.length+1) / 2)] - this.extraDistance - EPS;\r\n        let midy = ys[0 | ((ys.length+1) / 2)] - this.extraDistance - EPS;\r\n\r\n        if (midx <= this.minx || midx >= this.maxx || midy <= this.miny || midy >= this.maxy) {\r\n            //logger.warn(\"Failed to split quad tree node. Something is wrong with the split choice.\");\r\n            return null;\r\n        }\r\n\r\n        return { midx, midy };\r\n    }\r\n\r\n\r\n    subdivide() {\r\n\r\n        if (this.children) {\r\n            logger.error(\"Attempt to subdivide already split node\");\r\n            return;\r\n        }\r\n\r\n        if (!this.items.length) {\r\n            logger.error(\"Attempt to subdivide empty node\");\r\n            return;\r\n        }\r\n\r\n        let minx = this.minx;\r\n        let miny = this.miny;\r\n        let maxx = this.maxx;\r\n        let maxy = this.maxy;\r\n\r\n        //determine split location -- we split along the\r\n        //midpoint of actual data inside the node\r\n        let split = this.findSplitPoint();\r\n\r\n        if (!split) {\r\n            //logger.warn(\"Failed to split node\");\r\n            return;\r\n        }\r\n\r\n        let { midx, midy } = split;\r\n\r\n        this.children = new Array(4);\r\n        this.children[0] = new QuadTree(minx, miny, midx, midy, this.extraDistance, this.itemHandler);\r\n        this.children[1] = new QuadTree(midx, miny, maxx, midy, this.extraDistance, this.itemHandler);\r\n        this.children[2] = new QuadTree(midx, midy, maxx, maxy, this.extraDistance, this.itemHandler);\r\n        this.children[3] = new QuadTree(minx, midy, midx, maxy, this.extraDistance, this.itemHandler);\r\n\r\n        let keepItems = [];\r\n\r\n        for (let i=0, iEnd = this.items.length; i<iEnd; i++) {\r\n\r\n            let overlapCount = 0;\r\n            let whichChild = null;\r\n\r\n            for (let j=0; j<4; j++) {\r\n                if (this.children[j].intersectsItem(this.items[i])) {\r\n                    whichChild = this.children[j];\r\n                    overlapCount++;\r\n                }\r\n            }\r\n\r\n            if (overlapCount === 0) {\r\n                logger.error(\"Expected at least one overlap\");\r\n            } else if (overlapCount === 1) {\r\n                whichChild.addItem(this.items[i]);\r\n            } else {\r\n                keepItems.push(this.items[i]);\r\n            }\r\n        }\r\n\r\n        this.items = keepItems;\r\n    }\r\n\r\n    enumNearItems(e, cb) {\r\n\r\n        if (!this.intersectsItem(e))\r\n            return;\r\n\r\n        if (this.items) {\r\n            for (let i=0; i<this.items.length; i++) {\r\n                cb(this.items[i]);\r\n            }\r\n        }\r\n\r\n        if (this.children) {\r\n            for (let i=0; i<4; i++) {\r\n                this.children[i].enumNearItems(e, cb);\r\n            }\r\n        }\r\n\r\n    }\r\n\r\n    enumInBox(minx, miny, maxx, maxy, cb) {\r\n\r\n        if (!this.intersectsBox(minx, miny, maxx, maxy))\r\n            return;\r\n\r\n        if (this.items) {\r\n            for (let i=0; i<this.items.length; i++) {\r\n                let e = this.items[i];\r\n\r\n                if (this.itemHandler) {\r\n                    if (this.itemHandler.intersectsBox(e, minx, miny, maxx, maxy)) {\r\n                        cb(e);\r\n                    }\r\n                } else if (e.v1) {\r\n                    if (xLineBox(e.v1.x, e.v1.y, e.v2.x, e.v2.y, minx, miny, maxx, maxy))\r\n                        cb(e);\r\n                } else {\r\n                    if (xBoxBox(e.x, e.y, e.x, e.y, minx, miny, maxx, maxy))\r\n                        cb(e);\r\n                }\r\n            }\r\n        }\r\n\r\n        if (this.children) {\r\n            for (let i=0; i<4; i++) {\r\n                this.children[i].enumInBox(minx, miny, maxx, maxy, cb);\r\n            }\r\n        }\r\n\r\n    }\r\n\r\n\r\n    pointInPolygonRec(e, x, y) {\r\n\r\n        // get the last point in the polygon\r\n        var vtx0X = e.v1.x;\r\n        var vtx0Y = e.v1.y;\r\n\r\n        // get test bit for above/below X axis\r\n        var yflag0 = (vtx0Y >= y);\r\n\r\n        var vtx1X = e.v2.x;\r\n        var vtx1Y = e.v2.y;\r\n\r\n        var yflag1 = (vtx1Y >= y);\r\n\r\n        // Check if endpoints straddle (are on opposite sides) of X axis\r\n        // (i.e. the Y's differ); if so, +X ray could intersect this edge.\r\n        // The old test also checked whether the endpoints are both to the\r\n        // right or to the left of the test point.  However, given the faster\r\n        // intersection point computation used below, this test was found to\r\n        // be a break-even proposition for most polygons and a loser for\r\n        // triangles (where 50% or more of the edges which survive this test\r\n        // will cross quadrants and so have to have the X intersection computed\r\n        // anyway).  I credit Joseph Samosky with inspiring me to try dropping\r\n        // the \"both left or both right\" part of my code.\r\n        if (yflag0 != yflag1)\r\n        {\r\n            // Check intersection of pgon segment with +X ray.\r\n            // Note if >= point's X; if so, the ray hits it.\r\n            // The division operation is avoided for the \">=\" test by checking\r\n            // the sign of the first vertex wrto the test point; idea inspired\r\n            // by Joseph Samosky's and Mark Haigh-Hutchinson's different\r\n            // polygon inclusion tests.\r\n            if (((vtx1Y-y)*(vtx0X-vtx1X) >=\r\n                    (vtx1X-x)*(vtx0Y-vtx1Y)) == yflag1)\r\n            {\r\n                this.pipResult = !this.pipResult;\r\n            }\r\n        }\r\n\r\n    }\r\n\r\n    pointInPolygon(x, y) {\r\n\r\n        this.pipResult = false;\r\n\r\n        this.enumInBox(-Infinity, y, Infinity, y, item => {\r\n\r\n            this.pointInPolygonRec(item, x, y);\r\n\r\n        });\r\n\r\n        return this.pipResult;\r\n\r\n    }\r\n\r\n\r\n}\r\n\r\n","/*******************************************************************************\n *                                                                              *\n * Author    :  Angus Johnson                                                   *\n * Version   :  6.4.2                                                           *\n * Date      :  27 February 2017                                                *\n * Website   :  http://www.angusj.com                                           *\n * Copyright :  Angus Johnson 2010-2017                                         *\n *                                                                              *\n * License:                                                                     *\n * Use, modification & distribution is subject to Boost Software License Ver 1. *\n * http://www.boost.org/LICENSE_1_0.txt                                         *\n *                                                                              *\n * Attributions:                                                                *\n * The code in this library is an extension of Bala Vatti's clipping algorithm: *\n * \"A generic solution to polygon clipping\"                                     *\n * Communications of the ACM, Vol 35, Issue 7 (July 1992) pp 56-63.             *\n * http://portal.acm.org/citation.cfm?id=129906                                 *\n *                                                                              *\n * Computer graphics and geometric modeling: implementation and algorithms      *\n * By Max K. Agoston                                                            *\n * Springer; 1 edition (January 4, 2005)                                        *\n * http://books.google.com/books?q=vatti+clipping+agoston                       *\n *                                                                              *\n * See also:                                                                    *\n * \"Polygon Offsetting by Computing Winding Numbers\"                            *\n * Paper no. DETC2005-85513 pp. 565-575                                         *\n * ASME 2005 International Design Engineering Technical Conferences             *\n * and Computers and Information in Engineering Conference (IDETC/CIE2005)      *\n * September 24-28, 2005 , Long Beach, California, USA                          *\n * http://www.me.berkeley.edu/~mcmains/pubs/DAC05OffsetPolygon.pdf              *\n *                                                                              *\n *******************************************************************************/\n/*******************************************************************************\n *                                                                              *\n * Author    :  Timo                                                            *\n * Version   :  6.4.2.2 (FPoint)                                                *\n * Date      :  8 September 2017                                                *\n *                                                                              *\n * This is a translation of the C# Clipper library to Javascript.               *\n *                                                                              *\n *******************************************************************************/\n(function ()\n{\n\t\"use strict\";\n\tvar ClipperLib = {};\n\tClipperLib.version = '6.4.2.2';\n\n\t//UseLines: Enables open path clipping. Adds a very minor cost to performance.\n\tClipperLib.use_lines = true;\n\n\t//ClipperLib.use_xyz: adds a Z member to FPoint. Adds a minor cost to performance.\n\tClipperLib.use_xyz = false;\n\n\tvar isNode = false;\n\tif (typeof module !== 'undefined' && module.exports)\n\t{\n\t\tmodule.exports = ClipperLib;\n\t\tisNode = true;\n\t}\n\telse\n\t{\n\t\tif (typeof (document) !== \"undefined\") window.ClipperLib = ClipperLib;\n\t\telse self['ClipperLib'] = ClipperLib;\n\t}\n\tvar navigator_appName;\n\tif (!isNode)\n\t{\n\t\tvar nav = navigator.userAgent.toString().toLowerCase();\n\t\tnavigator_appName = navigator.appName;\n\t}\n\telse\n\t{\n\t\tvar nav = \"chrome\"; // Node.js uses Chrome's V8 engine\n\t\tnavigator_appName = \"Netscape\"; // Firefox, Chrome and Safari returns \"Netscape\", so Node.js should also\n\t}\n\t// Browser test to speedup performance critical functions\n\tvar browser = {};\n\n\tif (nav.indexOf(\"chrome\") != -1 && nav.indexOf(\"chromium\") == -1) browser.chrome = 1;\n\telse browser.chrome = 0;\n\tif (nav.indexOf(\"chromium\") != -1) browser.chromium = 1;\n\telse browser.chromium = 0;\n\tif (nav.indexOf(\"safari\") != -1 && nav.indexOf(\"chrome\") == -1 && nav.indexOf(\"chromium\") == -1) browser.safari = 1;\n\telse browser.safari = 0;\n\tif (nav.indexOf(\"firefox\") != -1) browser.firefox = 1;\n\telse browser.firefox = 0;\n\tif (nav.indexOf(\"firefox/17\") != -1) browser.firefox17 = 1;\n\telse browser.firefox17 = 0;\n\tif (nav.indexOf(\"firefox/15\") != -1) browser.firefox15 = 1;\n\telse browser.firefox15 = 0;\n\tif (nav.indexOf(\"firefox/3\") != -1) browser.firefox3 = 1;\n\telse browser.firefox3 = 0;\n\tif (nav.indexOf(\"opera\") != -1) browser.opera = 1;\n\telse browser.opera = 0;\n\tif (nav.indexOf(\"msie 10\") != -1) browser.msie10 = 1;\n\telse browser.msie10 = 0;\n\tif (nav.indexOf(\"msie 9\") != -1) browser.msie9 = 1;\n\telse browser.msie9 = 0;\n\tif (nav.indexOf(\"msie 8\") != -1) browser.msie8 = 1;\n\telse browser.msie8 = 0;\n\tif (nav.indexOf(\"msie 7\") != -1) browser.msie7 = 1;\n\telse browser.msie7 = 0;\n\tif (nav.indexOf(\"msie \") != -1) browser.msie = 1;\n\telse browser.msie = 0;\n\n\t// Here starts the actual Clipper library:\n\t// Helper function to support Inheritance in Javascript\n\tvar Inherit = function (ce, ce2)\n\t{\n\t\tvar p;\n\t\tif (typeof (Object.getOwnPropertyNames) === 'undefined')\n\t\t{\n\t\t\tfor (p in ce2.prototype)\n\t\t\t\tif (typeof (ce.prototype[p]) === 'undefined' || ce.prototype[p] === Object.prototype[p]) ce.prototype[p] = ce2.prototype[p];\n\t\t\tfor (p in ce2)\n\t\t\t\tif (typeof (ce[p]) === 'undefined') ce[p] = ce2[p];\n\t\t\tce.$baseCtor = ce2;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvar props = Object.getOwnPropertyNames(ce2.prototype);\n\t\t\tfor (var i = 0; i < props.length; i++)\n\t\t\t\tif (typeof (Object.getOwnPropertyDescriptor(ce.prototype, props[i])) === 'undefined') Object.defineProperty(ce.prototype, props[i], Object.getOwnPropertyDescriptor(ce2.prototype, props[i]));\n\t\t\tfor (p in ce2)\n\t\t\t\tif (typeof (ce[p]) === 'undefined') ce[p] = ce2[p];\n\t\t\tce.$baseCtor = ce2;\n\t\t}\n\t};\n\n\t/**\n\t* @constructor\n\t*/\n\tClipperLib.Path = function ()\n\t{\n\t\treturn [];\n\t};\n\n\tClipperLib.Path.prototype.push = Array.prototype.push;\n\n\t/**\n\t* @constructor\n\t*/\n\tClipperLib.Paths = function ()\n\t{\n\t\treturn []; // Was previously [[]], but caused problems when pushed\n\t};\n\n\tClipperLib.Paths.prototype.push = Array.prototype.push;\n\n\t// PolyTree & PolyNode start\n\t/**\n\t* @suppress {missingProperties}\n\t*/\n\tClipperLib.PolyNode = function ()\n\t{\n\t\tthis.m_Parent = null;\n\t\tthis.m_polygon = new ClipperLib.Path();\n\t\tthis.m_Index = 0;\n\t\tthis.m_jointype = 0;\n\t\tthis.m_endtype = 0;\n\t\tthis.m_Childs = [];\n\t\tthis.IsOpen = false;\n\t};\n\n\tClipperLib.PolyNode.prototype.IsHoleNode = function ()\n\t{\n\t\tvar result = true;\n\t\tvar node = this.m_Parent;\n\t\twhile (node !== null)\n\t\t{\n\t\t\tresult = !result;\n\t\t\tnode = node.m_Parent;\n\t\t}\n\t\treturn result;\n\t};\n\n\tClipperLib.PolyNode.prototype.ChildCount = function ()\n\t{\n\t\treturn this.m_Childs.length;\n\t};\n\n\tClipperLib.PolyNode.prototype.Contour = function ()\n\t{\n\t\treturn this.m_polygon;\n\t};\n\n\tClipperLib.PolyNode.prototype.AddChild = function (Child)\n\t{\n\t\tvar cnt = this.m_Childs.length;\n\t\tthis.m_Childs.push(Child);\n\t\tChild.m_Parent = this;\n\t\tChild.m_Index = cnt;\n\t};\n\n\tClipperLib.PolyNode.prototype.GetNext = function ()\n\t{\n\t\tif (this.m_Childs.length > 0)\n\t\t\treturn this.m_Childs[0];\n\t\telse\n\t\t\treturn this.GetNextSiblingUp();\n\t};\n\n\tClipperLib.PolyNode.prototype.GetNextSiblingUp = function ()\n\t{\n\t\tif (this.m_Parent === null)\n\t\t\treturn null;\n\t\telse if (this.m_Index === this.m_Parent.m_Childs.length - 1)\n\t\t\treturn this.m_Parent.GetNextSiblingUp();\n\t\telse\n\t\t\treturn this.m_Parent.m_Childs[this.m_Index + 1];\n\t};\n\n\tClipperLib.PolyNode.prototype.Childs = function ()\n\t{\n\t\treturn this.m_Childs;\n\t};\n\n\tClipperLib.PolyNode.prototype.Parent = function ()\n\t{\n\t\treturn this.m_Parent;\n\t};\n\n\tClipperLib.PolyNode.prototype.IsHole = function ()\n\t{\n\t\treturn this.IsHoleNode();\n\t};\n\n\t// PolyTree : PolyNode\n\t/**\n\t * @suppress {missingProperties}\n\t * @constructor\n\t */\n\tClipperLib.PolyTree = function ()\n\t{\n\t\tthis.m_AllPolys = [];\n\t\tClipperLib.PolyNode.call(this);\n\t};\n\n\tClipperLib.PolyTree.prototype.Clear = function ()\n\t{\n\t\tfor (var i = 0, ilen = this.m_AllPolys.length; i < ilen; i++)\n\t\t\tthis.m_AllPolys[i] = null;\n\t\tthis.m_AllPolys.length = 0;\n\t\tthis.m_Childs.length = 0;\n\t};\n\n\tClipperLib.PolyTree.prototype.GetFirst = function ()\n\t{\n\t\tif (this.m_Childs.length > 0)\n\t\t\treturn this.m_Childs[0];\n\t\telse\n\t\t\treturn null;\n\t};\n\n\tClipperLib.PolyTree.prototype.Total = function ()\n\t{\n\t\tvar result = this.m_AllPolys.length;\n\t\t//with negative offsets, ignore the hidden outer polygon ...\n\t\tif (result > 0 && this.m_Childs[0] !== this.m_AllPolys[0]) result--;\n\t\treturn result;\n\t};\n\n\tInherit(ClipperLib.PolyTree, ClipperLib.PolyNode);\n\n\t// PolyTree & PolyNode end\n\n\tClipperLib.Clear = function (a)\n\t{\n\t\ta.length = 0;\n\t};\n\n\t//ClipperLib.MaxSteps = 64; // How many steps at maximum in arc in BuildArc() function\n\tClipperLib.PI = 3.141592653589793;\n\tClipperLib.PI2 = 2 * 3.141592653589793;\n\t/**\n\t* @constructor\n\t*/\n\tClipperLib.FPoint = function ()\n\t{\n\t\tvar a = arguments,\n\t\t\talen = a.length;\n\t\tthis.X = 0;\n\t\tthis.Y = 0;\n\t\tif (ClipperLib.use_xyz)\n\t\t{\n\t\t\tthis.Z = 0;\n\t\t\tif (alen === 3) // public FPoint(cInt x, cInt y, cInt z = 0)\n\t\t\t{\n\t\t\t\tthis.X = a[0];\n\t\t\t\tthis.Y = a[1];\n\t\t\t\tthis.Z = a[2];\n\t\t\t}\n\t\t\telse if (alen === 2) // public FPoint(cInt x, cInt y)\n\t\t\t{\n\t\t\t\tthis.X = a[0];\n\t\t\t\tthis.Y = a[1];\n\t\t\t\tthis.Z = 0;\n\t\t\t}\n\t\t\telse if (alen === 1)\n\t\t\t{\n\t\t\t\tif (a[0] instanceof ClipperLib.FPoint) // public FPoint(FPoint dp)\n\t\t\t\t{\n\t\t\t\t\tvar dp = a[0];\n\t\t\t\t\tthis.X = dp.X;\n\t\t\t\t\tthis.Y = dp.Y;\n\t\t\t\t\tthis.Z = 0;\n\t\t\t\t}\n\t\t\t\telse // public FPoint(FPoint pt)\n\t\t\t\t{\n\t\t\t\t\tvar pt = a[0];\n\t\t\t\t\tif (typeof (pt.Z) === \"undefined\") pt.Z = 0;\n\t\t\t\t\tthis.X = pt.X;\n\t\t\t\t\tthis.Y = pt.Y;\n\t\t\t\t\tthis.Z = pt.Z;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse // public FPoint()\n\t\t\t{\n\t\t\t\tthis.X = 0;\n\t\t\t\tthis.Y = 0;\n\t\t\t\tthis.Z = 0;\n\t\t\t}\n\t\t}\n\t\telse // if (!ClipperLib.use_xyz)\n\t\t{\n\t\t\tif (alen === 2) // public FPoint(cInt X, cInt Y)\n\t\t\t{\n\t\t\t\tthis.X = a[0];\n\t\t\t\tthis.Y = a[1];\n\t\t\t}\n\t\t\telse if (alen === 1)\n\t\t\t{\n\t\t\t\tif (a[0] instanceof ClipperLib.FPoint) // public FPoint(FPoint dp)\n\t\t\t\t{\n\t\t\t\t\tvar dp = a[0];\n\t\t\t\t\tthis.X = dp.X;\n\t\t\t\t\tthis.Y = dp.Y;\n\t\t\t\t}\n\t\t\t\telse // public FPoint(FPoint pt)\n\t\t\t\t{\n\t\t\t\t\tvar pt = a[0];\n\t\t\t\t\tthis.X = pt.X;\n\t\t\t\t\tthis.Y = pt.Y;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse // public FPoint(FPoint pt)\n\t\t\t{\n\t\t\t\tthis.X = 0;\n\t\t\t\tthis.Y = 0;\n\t\t\t}\n\t\t}\n\t};\n\n\tClipperLib.FPoint.op_Equality = function (a, b)\n\t{\n\t\t//return a == b;\n\t\treturn a.X === b.X && a.Y === b.Y;\n\t};\n\n\tClipperLib.FPoint.op_Inequality = function (a, b)\n\t{\n\t\t//return a !== b;\n\t\treturn a.X !== b.X || a.Y !== b.Y;\n\t};\n\n\t/*\n  ClipperLib.FPoint.prototype.Equals = function (obj)\n  {\n    if (obj === null)\n        return false;\n    if (obj instanceof ClipperLib.FPoint)\n    {\n        var a = Cast(obj, ClipperLib.FPoint);\n        return (this.X == a.X) && (this.Y == a.Y);\n    }\n    else\n        return false;\n  };\n\n\t*/\n\n\t/**\n\t* @constructor\n\t*/\n\tClipperLib.FPoint0 = function ()\n\t{\n\t\tthis.X = 0;\n\t\tthis.Y = 0;\n\t\tif (ClipperLib.use_xyz)\n\t\t\tthis.Z = 0;\n\t};\n\n\tClipperLib.FPoint0.prototype = ClipperLib.FPoint.prototype;\n\n\t/**\n\t* @constructor\n\t*/\n\tClipperLib.FPoint1 = function (pt)\n\t{\n\t\tthis.X = pt.X;\n\t\tthis.Y = pt.Y;\n\t\tif (ClipperLib.use_xyz)\n\t\t{\n\t\t\tif (typeof pt.Z === \"undefined\") this.Z = 0;\n\t\t\telse this.Z = pt.Z;\n\t\t}\n\t};\n\n\tClipperLib.FPoint1.prototype = ClipperLib.FPoint.prototype;\n\n\t/**\n\t* @constructor\n\t*/\n\tClipperLib.FPoint1dp = function (dp)\n\t{\n\t\tthis.X = dp.X;\n\t\tthis.Y = dp.Y;\n\t\tif (ClipperLib.use_xyz)\n\t\t\tthis.Z = 0;\n\t};\n\n\tClipperLib.FPoint1dp.prototype = ClipperLib.FPoint.prototype;\n\n\t/**\n\t* @constructor\n\t*/\n\tClipperLib.FPoint2 = function (x, y, z)\n\t{\n\t\tthis.X = x;\n\t\tthis.Y = y;\n\t\tif (ClipperLib.use_xyz)\n\t\t{\n\t\t\tif (typeof z === \"undefined\") this.Z = 0;\n\t\t\telse this.Z = z;\n\t\t}\n\t};\n\n\tClipperLib.FPoint2.prototype = ClipperLib.FPoint.prototype;\n\n\t/**\n\t* @constructor\n\t*/\n\tClipperLib.FRect = function ()\n\t{\n\t\tvar a = arguments,\n\t\t\talen = a.length;\n\t\tif (alen === 4) // function (l, t, r, b)\n\t\t{\n\t\t\tthis.left = a[0];\n\t\t\tthis.top = a[1];\n\t\t\tthis.right = a[2];\n\t\t\tthis.bottom = a[3];\n\t\t}\n\t\telse if (alen === 1) // function (ir)\n\t\t{\n\t\t\tvar ir = a[0];\n\t\t\tthis.left = ir.left;\n\t\t\tthis.top = ir.top;\n\t\t\tthis.right = ir.right;\n\t\t\tthis.bottom = ir.bottom;\n\t\t}\n\t\telse // function ()\n\t\t{\n\t\t\tthis.left = 0;\n\t\t\tthis.top = 0;\n\t\t\tthis.right = 0;\n\t\t\tthis.bottom = 0;\n\t\t}\n\t};\n\n\t/**\n\t* @constructor\n\t*/\n\tClipperLib.FRect0 = function ()\n\t{\n\t\tthis.left = 0;\n\t\tthis.top = 0;\n\t\tthis.right = 0;\n\t\tthis.bottom = 0;\n\t};\n\n\tClipperLib.FRect0.prototype = ClipperLib.FRect.prototype;\n\n\t/**\n\t* @constructor\n\t*/\n\tClipperLib.FRect1 = function (ir)\n\t{\n\t\tthis.left = ir.left;\n\t\tthis.top = ir.top;\n\t\tthis.right = ir.right;\n\t\tthis.bottom = ir.bottom;\n\t};\n\n\tClipperLib.FRect1.prototype = ClipperLib.FRect.prototype;\n\n\t/**\n\t* @constructor\n\t*/\n\tClipperLib.FRect4 = function (l, t, r, b)\n\t{\n\t\tthis.left = l;\n\t\tthis.top = t;\n\t\tthis.right = r;\n\t\tthis.bottom = b;\n\t};\n\n\tClipperLib.FRect4.prototype = ClipperLib.FRect.prototype;\n\n\tClipperLib.ClipType = {\n\t\tctIntersection: 0,\n\t\tctUnion: 1,\n\t\tctDifference: 2,\n\t\tctXor: 3\n\t};\n\n\tClipperLib.PolyType = {\n\t\tptSubject: 0,\n\t\tptClip: 1\n\t};\n\n\tClipperLib.PolyFillType = {\n\t\tpftEvenOdd: 0,\n\t\tpftNonZero: 1,\n\t\tpftPositive: 2,\n\t\tpftNegative: 3\n\t};\n\n\tClipperLib.JoinType = {\n\t\tjtSquare: 0,\n\t\tjtRound: 1,\n\t\tjtMiter: 2\n\t};\n\n\tClipperLib.EndType = {\n\t\tetOpenSquare: 0,\n\t\tetOpenRound: 1,\n\t\tetOpenButt: 2,\n\t\tetClosedLine: 3,\n\t\tetClosedPolygon: 4\n\t};\n\n\tClipperLib.EdgeSide = {\n\t\tesLeft: 0,\n\t\tesRight: 1\n\t};\n\n\tClipperLib.Direction = {\n\t\tdRightToLeft: 0,\n\t\tdLeftToRight: 1\n\t};\n\n\t/**\n\t* @constructor\n\t*/\n\tClipperLib.TEdge = function ()\n\t{\n\t\tthis.Bot = new ClipperLib.FPoint0();\n\t\tthis.Curr = new ClipperLib.FPoint0(); //current (updated for every new scanbeam)\n\t\tthis.Top = new ClipperLib.FPoint0();\n\t\tthis.Delta = new ClipperLib.FPoint0();\n\t\tthis.Dx = 0;\n\t\tthis.PolyTyp = ClipperLib.PolyType.ptSubject;\n\t\tthis.Side = ClipperLib.EdgeSide.esLeft; //side only refers to current side of solution poly\n\t\tthis.WindDelta = 0; //1 or -1 depending on winding direction\n\t\tthis.WindCnt = 0;\n\t\tthis.WindCnt2 = 0; //winding count of the opposite polytype\n\t\tthis.OutIdx = 0;\n\t\tthis.Next = null;\n\t\tthis.Prev = null;\n\t\tthis.NextInLML = null;\n\t\tthis.NextInAEL = null;\n\t\tthis.PrevInAEL = null;\n\t\tthis.NextInSEL = null;\n\t\tthis.PrevInSEL = null;\n\t};\n\n\t/**\n\t* @constructor\n\t*/\n\tClipperLib.IntersectNode = function ()\n\t{\n\t\tthis.Edge1 = null;\n\t\tthis.Edge2 = null;\n\t\tthis.Pt = new ClipperLib.FPoint0();\n\t};\n\n\tClipperLib.MyIntersectNodeSort = function () {};\n\n\tClipperLib.MyIntersectNodeSort.Compare = function (node1, node2)\n\t{\n\t\tvar i = node2.Pt.Y - node1.Pt.Y;\n\t\tif (i > 0) return 1;\n\t\telse if (i < 0) return -1;\n\t\telse return 0;\n\t};\n\n\t/**\n\t* @constructor\n\t*/\n\tClipperLib.LocalMinima = function ()\n\t{\n\t\tthis.Y = 0;\n\t\tthis.LeftBound = null;\n\t\tthis.RightBound = null;\n\t\tthis.Next = null;\n\t};\n\n\t/**\n\t* @constructor\n\t*/\n\tClipperLib.Scanbeam = function ()\n\t{\n\t\tthis.Y = 0;\n\t\tthis.Next = null;\n\t};\n\n\t/**\n\t* @constructor\n\t*/\n\tClipperLib.Maxima = function ()\n\t{\n\t\tthis.X = 0;\n\t\tthis.Next = null;\n\t\tthis.Prev = null;\n\t};\n\n\t//OutRec: contains a path in the clipping solution. Edges in the AEL will\n\t//carry a pointer to an OutRec when they are part of the clipping solution.\n\t/**\n\t* @constructor\n\t*/\n\tClipperLib.OutRec = function ()\n\t{\n\t\tthis.Idx = 0;\n\t\tthis.IsHole = false;\n\t\tthis.IsOpen = false;\n\t\tthis.FirstLeft = null; //see comments in clipper.pas\n\t\tthis.Pts = null;\n\t\tthis.BottomPt = null;\n\t\tthis.PolyNode = null;\n\t};\n\n\t/**\n\t* @constructor\n\t*/\n\tClipperLib.OutPt = function ()\n\t{\n\t\tthis.Idx = 0;\n\t\tthis.Pt = new ClipperLib.FPoint0();\n\t\tthis.Next = null;\n\t\tthis.Prev = null;\n\t};\n\n\t/**\n\t* @constructor\n\t*/\n\tClipperLib.Join = function ()\n\t{\n\t\tthis.OutPt1 = null;\n\t\tthis.OutPt2 = null;\n\t\tthis.OffPt = new ClipperLib.FPoint0();\n\t};\n\n\tClipperLib.ClipperBase = function ()\n\t{\n\t\tthis.m_MinimaList = null;\n\t\tthis.m_CurrentLM = null;\n\t\tthis.m_edges = new Array();\n\t\tthis.m_HasOpenPaths = false;\n\t\tthis.PreserveCollinear = false;\n\t\tthis.m_Scanbeam = null;\n\t\tthis.m_PolyOuts = null;\n\t\tthis.m_ActiveEdges = null;\n\t};\n\n\tClipperLib.ClipperBase.horizontal = -3.4E+38;\n\tClipperLib.ClipperBase.Skip = -2;\n\tClipperLib.ClipperBase.Unassigned = -1;\n\tClipperLib.ClipperBase.tolerance = 1E-20;\n\n\t// The MAX_VALUE property has a value of 1.7976931348623157e+308. Values larger than MAX_VALUE are represented as \"Infinity\".\n\t//MIN_VALUE has a value of 5e-324. Values smaller than MIN_VALUE (\"underflow values\") are converted to 0.\n\tClipperLib.ClipperBase.maxValue = Math.sqrt(Number.MAX_VALUE); // 1.3407807929942596e+154\n\tClipperLib.ClipperBase.minValue = Math.sqrt(Number.MIN_VALUE); // 2.2227587494850775e-162\n\n\tClipperLib.ClipperBase.near_zero = function (val)\n\t{\n\t\treturn (val > -ClipperLib.ClipperBase.tolerance) && (val < ClipperLib.ClipperBase.tolerance);\n\t};\n\n\tClipperLib.ClipperBase.IsHorizontal = function (e)\n\t{\n\t\treturn e.Delta.Y === 0;\n\t};\n\n\tClipperLib.ClipperBase.prototype.PointIsVertex = function (pt, pp)\n\t{\n\t\tvar pp2 = pp;\n\t\tdo {\n\t\t\tif (ClipperLib.FPoint.op_Equality(pp2.Pt, pt))\n\t\t\t\treturn true;\n\t\t\tpp2 = pp2.Next;\n\t\t}\n\t\twhile (pp2 !== pp)\n\t\treturn false;\n\t};\n\n\tClipperLib.ClipperBase.prototype.PointOnLineSegment = function (pt, linePt1, linePt2)\n\t{\n\t\t\treturn ((pt.X === linePt1.X) && (pt.Y === linePt1.Y)) || ((pt.X === linePt2.X) && (pt.Y === linePt2.Y)) || (((pt.X > linePt1.X) === (pt.X < linePt2.X)) && ((pt.Y > linePt1.Y) === (pt.Y < linePt2.Y)) && ((pt.X - linePt1.X) * (linePt2.Y - linePt1.Y) === (linePt2.X - linePt1.X) * (pt.Y - linePt1.Y)));\n\t};\n\n\tClipperLib.ClipperBase.prototype.PointOnPolygon = function (pt, pp)\n\t{\n\t\tvar pp2 = pp;\n\t\twhile (true)\n\t\t{\n\t\t\tif (this.PointOnLineSegment(pt, pp2.Pt, pp2.Next.Pt))\n\t\t\t\treturn true;\n\t\t\tpp2 = pp2.Next;\n\t\t\tif (pp2 === pp)\n\t\t\t\tbreak;\n\t\t}\n\t\treturn false;\n\t};\n\n\tClipperLib.ClipperBase.prototype.SlopesEqual = ClipperLib.ClipperBase.SlopesEqual = function ()\n\t{\n\t\tvar a = arguments,\n\t\t\talen = a.length;\n\t\tvar e1, e2, pt1, pt2, pt3, pt4;\n\t\tif (alen === 2) // function (e1, e2)\n\t\t{\n\t\t\te1 = a[0];\n\t\t\te2 = a[1];\n\t\t\treturn e1.Delta.Y * e2.Delta.X === e1.Delta.X * e2.Delta.Y;\n\t\t}\n\t\telse if (alen === 3) // function (pt1, pt2, pt3)\n\t\t{\n\t\t\tpt1 = a[0];\n\t\t\tpt2 = a[1];\n\t\t\tpt3 = a[2];\n\t\t\treturn (pt1.Y - pt2.Y) * (pt2.X - pt3.X) - (pt1.X - pt2.X) * (pt2.Y - pt3.Y) === 0;\n\t\t}\n\t\telse // function (pt1, pt2, pt3, pt4)\n\t\t{\n\t\t\tpt1 = a[0];\n\t\t\tpt2 = a[1];\n\t\t\tpt3 = a[2];\n\t\t\tpt4 = a[3];\n\t\t\treturn (pt1.Y - pt2.Y) * (pt3.X - pt4.X) - (pt1.X - pt2.X) * (pt3.Y - pt4.Y) === 0;\n\t\t}\n\t};\n\n\tClipperLib.ClipperBase.SlopesEqual3 = function (e1, e2)\n\t{\n\t\treturn e1.Delta.Y * e2.Delta.X === e1.Delta.X * e2.Delta.Y;\n\t};\n\n\tClipperLib.ClipperBase.SlopesEqual4 = function (pt1, pt2, pt3)\n\t{\n\t\treturn (pt1.Y - pt2.Y) * (pt2.X - pt3.X) - (pt1.X - pt2.X) * (pt2.Y - pt3.Y) === 0;\n\t};\n\n\tClipperLib.ClipperBase.SlopesEqual5 = function (pt1, pt2, pt3, pt4)\n\t{\n\t\treturn (pt1.Y - pt2.Y) * (pt3.X - pt4.X) - (pt1.X - pt2.X) * (pt3.Y - pt4.Y) === 0;\n\t};\n\n\tClipperLib.ClipperBase.prototype.Clear = function ()\n\t{\n\t\tthis.DisposeLocalMinimaList();\n\t\tfor (var i = 0, ilen = this.m_edges.length; i < ilen; ++i)\n\t\t{\n\t\t\tfor (var j = 0, jlen = this.m_edges[i].length; j < jlen; ++j)\n\t\t\t\tthis.m_edges[i][j] = null;\n\t\t\tClipperLib.Clear(this.m_edges[i]);\n\t\t}\n\t\tClipperLib.Clear(this.m_edges);\n\t\tthis.m_HasOpenPaths = false;\n\t};\n\n\tClipperLib.ClipperBase.prototype.DisposeLocalMinimaList = function ()\n\t{\n\t\twhile (this.m_MinimaList !== null)\n\t\t{\n\t\t\tvar tmpLm = this.m_MinimaList.Next;\n\t\t\tthis.m_MinimaList = null;\n\t\t\tthis.m_MinimaList = tmpLm;\n\t\t}\n\t\tthis.m_CurrentLM = null;\n\t};\n\n\tClipperLib.ClipperBase.prototype.RangeTest = function (pt)\n\t{\n\t\tif(pt.X > ClipperLib.ClipperBase.maxValue || pt.X < -ClipperLib.ClipperBase.maxValue\n\t\t|| pt.Y > ClipperLib.ClipperBase.maxValue || pt.Y < -ClipperLib.ClipperBase.maxValue\n|| (pt.X > 0 && pt.X < ClipperLib.ClipperBase.minValue)\n|| (pt.Y > 0 && pt.Y < ClipperLib.ClipperBase.minValue)\n|| (pt.X < 0 && pt.X > -ClipperLib.ClipperBase.minValue)\n|| (pt.Y < 0 && pt.Y > -ClipperLib.ClipperBase.minValue))\n\t\t\tClipperLib.Error(\"Coordinate outside allowed range in RangeTest().\");\n\t};\n\n\tClipperLib.ClipperBase.prototype.InitEdge = function (e, eNext, ePrev, pt)\n\t{\n\t\te.Next = eNext;\n\t\te.Prev = ePrev;\n\t\t//e.Curr = pt;\n\t\te.Curr.X = pt.X;\n\t\te.Curr.Y = pt.Y;\n\t\tif (ClipperLib.use_xyz) e.Curr.Z = pt.Z;\n\t\te.OutIdx = -1;\n\t};\n\n\tClipperLib.ClipperBase.prototype.InitEdge2 = function (e, polyType)\n\t{\n\t\tif (e.Curr.Y >= e.Next.Curr.Y)\n\t\t{\n\t\t\t//e.Bot = e.Curr;\n\t\t\te.Bot.X = e.Curr.X;\n\t\t\te.Bot.Y = e.Curr.Y;\n\t\t\tif (ClipperLib.use_xyz) e.Bot.Z = e.Curr.Z;\n\t\t\t//e.Top = e.Next.Curr;\n\t\t\te.Top.X = e.Next.Curr.X;\n\t\t\te.Top.Y = e.Next.Curr.Y;\n\t\t\tif (ClipperLib.use_xyz) e.Top.Z = e.Next.Curr.Z;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t//e.Top = e.Curr;\n\t\t\te.Top.X = e.Curr.X;\n\t\t\te.Top.Y = e.Curr.Y;\n\t\t\tif (ClipperLib.use_xyz) e.Top.Z = e.Curr.Z;\n\t\t\t//e.Bot = e.Next.Curr;\n\t\t\te.Bot.X = e.Next.Curr.X;\n\t\t\te.Bot.Y = e.Next.Curr.Y;\n\t\t\tif (ClipperLib.use_xyz) e.Bot.Z = e.Next.Curr.Z;\n\t\t}\n\t\tthis.SetDx(e);\n\t\te.PolyTyp = polyType;\n\t};\n\n\tClipperLib.ClipperBase.prototype.FindNextLocMin = function (E)\n\t{\n\t\tvar E2;\n\t\tfor (;;)\n\t\t{\n\t\t\twhile (ClipperLib.FPoint.op_Inequality(E.Bot, E.Prev.Bot) || ClipperLib.FPoint.op_Equality(E.Curr, E.Top))\n\t\t\t\tE = E.Next;\n\t\t\tif (E.Dx !== ClipperLib.ClipperBase.horizontal && E.Prev.Dx !== ClipperLib.ClipperBase.horizontal)\n\t\t\t\tbreak;\n\t\t\twhile (E.Prev.Dx === ClipperLib.ClipperBase.horizontal)\n\t\t\t\tE = E.Prev;\n\t\t\tE2 = E;\n\t\t\twhile (E.Dx === ClipperLib.ClipperBase.horizontal)\n\t\t\t\tE = E.Next;\n\t\t\tif (E.Top.Y === E.Prev.Bot.Y)\n\t\t\t\tcontinue;\n\t\t\t//ie just an intermediate horz.\n\t\t\tif (E2.Prev.Bot.X < E.Bot.X)\n\t\t\t\tE = E2;\n\t\t\tbreak;\n\t\t}\n\t\treturn E;\n\t};\n\n\tClipperLib.ClipperBase.prototype.ProcessBound = function (E, LeftBoundIsForward)\n\t{\n\t\tvar EStart;\n\t\tvar Result = E;\n\t\tvar Horz;\n\n\t\tif (Result.OutIdx === ClipperLib.ClipperBase.Skip)\n\t\t{\n\t\t\t//check if there are edges beyond the skip edge in the bound and if so\n\t\t\t//create another LocMin and calling ProcessBound once more ...\n\t\t\tE = Result;\n\t\t\tif (LeftBoundIsForward)\n\t\t\t{\n\t\t\t\twhile (E.Top.Y === E.Next.Bot.Y) E = E.Next;\n\t\t\t\twhile (E !== Result && E.Dx === ClipperLib.ClipperBase.horizontal) E = E.Prev;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\twhile (E.Top.Y === E.Prev.Bot.Y) E = E.Prev;\n\t\t\t\twhile (E !== Result && E.Dx === ClipperLib.ClipperBase.horizontal) E = E.Next;\n\t\t\t}\n\t\t\tif (E === Result)\n\t\t\t{\n\t\t\t\tif (LeftBoundIsForward) Result = E.Next;\n\t\t\t\telse Result = E.Prev;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t//there are more edges in the bound beyond result starting with E\n\t\t\t\tif (LeftBoundIsForward)\n\t\t\t\t\tE = Result.Next;\n\t\t\t\telse\n\t\t\t\t\tE = Result.Prev;\n\t\t\t\tvar locMin = new ClipperLib.LocalMinima();\n\t\t\t\tlocMin.Next = null;\n\t\t\t\tlocMin.Y = E.Bot.Y;\n\t\t\t\tlocMin.LeftBound = null;\n\t\t\t\tlocMin.RightBound = E;\n\t\t\t\tE.WindDelta = 0;\n\t\t\t\tResult = this.ProcessBound(E, LeftBoundIsForward);\n\t\t\t\tthis.InsertLocalMinima(locMin);\n\t\t\t}\n\t\t\treturn Result;\n\t\t}\n\n\t\tif (E.Dx === ClipperLib.ClipperBase.horizontal)\n\t\t{\n\t\t\t//We need to be careful with open paths because this may not be a\n\t\t\t//true local minima (ie E may be following a skip edge).\n\t\t\t//Also, consecutive horz. edges may start heading left before going right.\n\t\t\tif (LeftBoundIsForward) EStart = E.Prev;\n\t\t\telse EStart = E.Next;\n\n\t\t\tif (EStart.Dx === ClipperLib.ClipperBase.horizontal) //ie an adjoining horizontal skip edge\n\t\t\t{\n\t\t\t\tif (EStart.Bot.X !== E.Bot.X && EStart.Top.X !== E.Bot.X)\n\t\t\t\t\tthis.ReverseHorizontal(E);\n\t\t\t}\n\t\t\telse if (EStart.Bot.X !== E.Bot.X)\n\t\t\t\tthis.ReverseHorizontal(E);\n\t\t}\n\n\t\tEStart = E;\n\t\tif (LeftBoundIsForward)\n\t\t{\n\t\t\twhile (Result.Top.Y === Result.Next.Bot.Y && Result.Next.OutIdx !== ClipperLib.ClipperBase.Skip)\n\t\t\t\tResult = Result.Next;\n\t\t\tif (Result.Dx === ClipperLib.ClipperBase.horizontal && Result.Next.OutIdx !== ClipperLib.ClipperBase.Skip)\n\t\t\t{\n\t\t\t\t//nb: at the top of a bound, horizontals are added to the bound\n\t\t\t\t//only when the preceding edge attaches to the horizontal's left vertex\n\t\t\t\t//unless a Skip edge is encountered when that becomes the top divide\n\t\t\t\tHorz = Result;\n\t\t\t\twhile (Horz.Prev.Dx === ClipperLib.ClipperBase.horizontal)\n\t\t\t\t\tHorz = Horz.Prev;\n\t\t\t\tif (Horz.Prev.Top.X > Result.Next.Top.X)\n\t\t\t\t\tResult = Horz.Prev;\n\t\t\t}\n\t\t\twhile (E !== Result)\n\t\t\t{\n\t\t\t\tE.NextInLML = E.Next;\n\t\t\t\tif (E.Dx === ClipperLib.ClipperBase.horizontal && E !== EStart && E.Bot.X !== E.Prev.Top.X)\n\t\t\t\t\tthis.ReverseHorizontal(E);\n\t\t\t\tE = E.Next;\n\t\t\t}\n\t\t\tif (E.Dx === ClipperLib.ClipperBase.horizontal && E !== EStart && E.Bot.X !== E.Prev.Top.X)\n\t\t\t\tthis.ReverseHorizontal(E);\n\t\t\tResult = Result.Next;\n\t\t\t//move to the edge just beyond current bound\n\t\t}\n\t\telse\n\t\t{\n\t\t\twhile (Result.Top.Y === Result.Prev.Bot.Y && Result.Prev.OutIdx !== ClipperLib.ClipperBase.Skip)\n\t\t\t\tResult = Result.Prev;\n\t\t\tif (Result.Dx === ClipperLib.ClipperBase.horizontal && Result.Prev.OutIdx !== ClipperLib.ClipperBase.Skip)\n\t\t\t{\n\t\t\t\tHorz = Result;\n\t\t\t\twhile (Horz.Next.Dx === ClipperLib.ClipperBase.horizontal)\n\t\t\t\t\tHorz = Horz.Next;\n\t\t\t\tif (Horz.Next.Top.X === Result.Prev.Top.X || Horz.Next.Top.X > Result.Prev.Top.X)\n\t\t\t\t{\n\t\t\t\t\tResult = Horz.Next;\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile (E !== Result)\n\t\t\t{\n\t\t\t\tE.NextInLML = E.Prev;\n\t\t\t\tif (E.Dx === ClipperLib.ClipperBase.horizontal && E !== EStart && E.Bot.X !== E.Next.Top.X)\n\t\t\t\t\tthis.ReverseHorizontal(E);\n\t\t\t\tE = E.Prev;\n\t\t\t}\n\t\t\tif (E.Dx === ClipperLib.ClipperBase.horizontal && E !== EStart && E.Bot.X !== E.Next.Top.X)\n\t\t\t\tthis.ReverseHorizontal(E);\n\t\t\tResult = Result.Prev;\n\t\t\t//move to the edge just beyond current bound\n\t\t}\n\n\t\treturn Result;\n\t};\n\n\tClipperLib.ClipperBase.prototype.AddPath = function (pg, polyType, Closed)\n\t{\n\t\tif (ClipperLib.use_lines)\n\t\t{\n\t\t\tif (!Closed && polyType === ClipperLib.PolyType.ptClip)\n\t\t\t\tClipperLib.Error(\"AddPath: Open paths must be subject.\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (!Closed)\n\t\t\t\tClipperLib.Error(\"AddPath: Open paths have been disabled.\");\n\t\t}\n\t\tvar highI = pg.length - 1;\n\t\tif (Closed)\n\t\t\twhile (highI > 0 && (ClipperLib.FPoint.op_Equality(pg[highI], pg[0])))\n\t\t\t\t--highI;\n\t\twhile (highI > 0 && (ClipperLib.FPoint.op_Equality(pg[highI], pg[highI - 1])))\n\t\t\t--highI;\n\t\tif ((Closed && highI < 2) || (!Closed && highI < 1))\n\t\t\treturn false;\n\t\t//create a new edge array ...\n\t\tvar edges = new Array();\n\t\tfor (var i = 0; i <= highI; i++)\n\t\t\tedges.push(new ClipperLib.TEdge());\n\t\tvar IsFlat = true;\n\t\t//1. Basic (first) edge initialization ...\n\n\t\t//edges[1].Curr = pg[1];\n\t\tedges[1].Curr.X = pg[1].X;\n\t\tedges[1].Curr.Y = pg[1].Y;\n\t\tif (ClipperLib.use_xyz) edges[1].Curr.Z = pg[1].Z;\n\n\t\tthis.RangeTest(pg[0]);\n\n\t\tthis.RangeTest(pg[highI]);\n\n\t\tthis.InitEdge(edges[0], edges[1], edges[highI], pg[0]);\n\t\tthis.InitEdge(edges[highI], edges[0], edges[highI - 1], pg[highI]);\n\t\tfor (var i = highI - 1; i >= 1; --i)\n\t\t{\n\t\t\tthis.RangeTest(pg[i]);\n\n\t\t\tthis.InitEdge(edges[i], edges[i + 1], edges[i - 1], pg[i]);\n\t\t}\n\n\t\tvar eStart = edges[0];\n\t\t//2. Remove duplicate vertices, and (when closed) collinear edges ...\n\t\tvar E = eStart,\n\t\t\teLoopStop = eStart;\n\t\tfor (;;)\n\t\t{\n\t\t\t//console.log(E.Next, eStart);\n\t\t\t//nb: allows matching start and end points when not Closed ...\n\t\t\tif (E.Curr === E.Next.Curr && (Closed || E.Next !== eStart))\n\t\t\t{\n\t\t\t\tif (E === E.Next)\n\t\t\t\t\tbreak;\n\t\t\t\tif (E === eStart)\n\t\t\t\t\teStart = E.Next;\n\t\t\t\tE = this.RemoveEdge(E);\n\t\t\t\teLoopStop = E;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (E.Prev === E.Next)\n\t\t\t\tbreak;\n\t\t\telse if (Closed && ClipperLib.ClipperBase.SlopesEqual4(E.Prev.Curr, E.Curr, E.Next.Curr) && (!this.PreserveCollinear || !this.Pt2IsBetweenPt1AndPt3(E.Prev.Curr, E.Curr, E.Next.Curr)))\n\t\t\t{\n\t\t\t\t//Collinear edges are allowed for open paths but in closed paths\n\t\t\t\t//the default is to merge adjacent collinear edges into a single edge.\n\t\t\t\t//However, if the PreserveCollinear property is enabled, only overlapping\n\t\t\t\t//collinear edges (ie spikes) will be removed from closed paths.\n\t\t\t\tif (E === eStart)\n\t\t\t\t\teStart = E.Next;\n\t\t\t\tE = this.RemoveEdge(E);\n\t\t\t\tE = E.Prev;\n\t\t\t\teLoopStop = E;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tE = E.Next;\n\t\t\tif ((E === eLoopStop) || (!Closed && E.Next === eStart)) break;\n\t\t}\n\t\tif ((!Closed && (E === E.Next)) || (Closed && (E.Prev === E.Next)))\n\t\t\treturn false;\n\t\tif (!Closed)\n\t\t{\n\t\t\tthis.m_HasOpenPaths = true;\n\t\t\teStart.Prev.OutIdx = ClipperLib.ClipperBase.Skip;\n\t\t}\n\t\t//3. Do second stage of edge initialization ...\n\t\tE = eStart;\n\t\tdo {\n\t\t\tthis.InitEdge2(E, polyType);\n\t\t\tE = E.Next;\n\t\t\tif (IsFlat && E.Curr.Y !== eStart.Curr.Y)\n\t\t\t\tIsFlat = false;\n\t\t}\n\t\twhile (E !== eStart)\n\t\t//4. Finally, add edge bounds to LocalMinima list ...\n\t\t//Totally flat paths must be handled differently when adding them\n\t\t//to LocalMinima list to avoid endless loops etc ...\n\t\tif (IsFlat)\n\t\t{\n\t\t\tif (Closed)\n\t\t\t\treturn false;\n\n\t\t\tE.Prev.OutIdx = ClipperLib.ClipperBase.Skip;\n\n\t\t\tvar locMin = new ClipperLib.LocalMinima();\n\t\t\tlocMin.Next = null;\n\t\t\tlocMin.Y = E.Bot.Y;\n\t\t\tlocMin.LeftBound = null;\n\t\t\tlocMin.RightBound = E;\n\t\t\tlocMin.RightBound.Side = ClipperLib.EdgeSide.esRight;\n\t\t\tlocMin.RightBound.WindDelta = 0;\n\n\t\t\tfor (;;)\n\t\t\t{\n\t\t\t\tif (E.Bot.X !== E.Prev.Top.X) this.ReverseHorizontal(E);\n\t\t\t\tif (E.Next.OutIdx === ClipperLib.ClipperBase.Skip) break;\n\t\t\t\tE.NextInLML = E.Next;\n\t\t\t\tE = E.Next;\n\t\t\t}\n\t\t\tthis.InsertLocalMinima(locMin);\n\t\t\tthis.m_edges.push(edges);\n\t\t\treturn true;\n\t\t}\n\t\tthis.m_edges.push(edges);\n\t\tvar leftBoundIsForward;\n\t\tvar EMin = null;\n\n\t\t//workaround to avoid an endless loop in the while loop below when\n\t\t//open paths have matching start and end points ...\n\t\tif (ClipperLib.FPoint.op_Equality(E.Prev.Bot, E.Prev.Top))\n\t\t\tE = E.Next;\n\n\t\tfor (;;)\n\t\t{\n\t\t\tE = this.FindNextLocMin(E);\n\t\t\tif (E === EMin)\n\t\t\t\tbreak;\n\t\t\telse if (EMin === null)\n\t\t\t\tEMin = E;\n\t\t\t//E and E.Prev now share a local minima (left aligned if horizontal).\n\t\t\t//Compare their slopes to find which starts which bound ...\n\t\t\tvar locMin = new ClipperLib.LocalMinima();\n\t\t\tlocMin.Next = null;\n\t\t\tlocMin.Y = E.Bot.Y;\n\t\t\tif (E.Dx < E.Prev.Dx)\n\t\t\t{\n\t\t\t\tlocMin.LeftBound = E.Prev;\n\t\t\t\tlocMin.RightBound = E;\n\t\t\t\tleftBoundIsForward = false;\n\t\t\t\t//Q.nextInLML = Q.prev\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tlocMin.LeftBound = E;\n\t\t\t\tlocMin.RightBound = E.Prev;\n\t\t\t\tleftBoundIsForward = true;\n\t\t\t\t//Q.nextInLML = Q.next\n\t\t\t}\n\t\t\tlocMin.LeftBound.Side = ClipperLib.EdgeSide.esLeft;\n\t\t\tlocMin.RightBound.Side = ClipperLib.EdgeSide.esRight;\n\t\t\tif (!Closed)\n\t\t\t\tlocMin.LeftBound.WindDelta = 0;\n\t\t\telse if (locMin.LeftBound.Next === locMin.RightBound)\n\t\t\t\tlocMin.LeftBound.WindDelta = -1;\n\t\t\telse\n\t\t\t\tlocMin.LeftBound.WindDelta = 1;\n\t\t\tlocMin.RightBound.WindDelta = -locMin.LeftBound.WindDelta;\n\t\t\tE = this.ProcessBound(locMin.LeftBound, leftBoundIsForward);\n\t\t\tif (E.OutIdx === ClipperLib.ClipperBase.Skip)\n\t\t\t\tE = this.ProcessBound(E, leftBoundIsForward);\n\t\t\tvar E2 = this.ProcessBound(locMin.RightBound, !leftBoundIsForward);\n\t\t\tif (E2.OutIdx === ClipperLib.ClipperBase.Skip) E2 = this.ProcessBound(E2, !leftBoundIsForward);\n\t\t\tif (locMin.LeftBound.OutIdx === ClipperLib.ClipperBase.Skip)\n\t\t\t\tlocMin.LeftBound = null;\n\t\t\telse if (locMin.RightBound.OutIdx === ClipperLib.ClipperBase.Skip)\n\t\t\t\tlocMin.RightBound = null;\n\t\t\tthis.InsertLocalMinima(locMin);\n\t\t\tif (!leftBoundIsForward)\n\t\t\t\tE = E2;\n\t\t}\n\t\treturn true;\n\t};\n\n\tClipperLib.ClipperBase.prototype.AddPaths = function (ppg, polyType, closed)\n\t{\n\t\t//  console.log(\"-------------------------------------------\");\n\t\t//  console.log(JSON.stringify(ppg));\n\t\tvar result = false;\n\t\tfor (var i = 0, ilen = ppg.length; i < ilen; ++i)\n\t\t\tif (this.AddPath(ppg[i], polyType, closed))\n\t\t\t\tresult = true;\n\t\treturn result;\n\t};\n\n\tClipperLib.ClipperBase.prototype.Pt2IsBetweenPt1AndPt3 = function (pt1, pt2, pt3)\n\t{\n\t\tif ((ClipperLib.FPoint.op_Equality(pt1, pt3)) || (ClipperLib.FPoint.op_Equality(pt1, pt2)) || (ClipperLib.FPoint.op_Equality(pt3, pt2)))\n\n\t\t\t//if ((pt1 == pt3) || (pt1 == pt2) || (pt3 == pt2))\n\t\t\treturn false;\n\n\t\telse if (pt1.X !== pt3.X)\n\t\t\treturn (pt2.X > pt1.X) === (pt2.X < pt3.X);\n\t\telse\n\t\t\treturn (pt2.Y > pt1.Y) === (pt2.Y < pt3.Y);\n\t};\n\n\tClipperLib.ClipperBase.prototype.RemoveEdge = function (e)\n\t{\n\t\t//removes e from double_linked_list (but without removing from memory)\n\t\te.Prev.Next = e.Next;\n\t\te.Next.Prev = e.Prev;\n\t\tvar result = e.Next;\n\t\te.Prev = null; //flag as removed (see ClipperBase.Clear)\n\t\treturn result;\n\t};\n\n\tClipperLib.ClipperBase.prototype.SetDx = function (e)\n\t{\n\t\te.Delta.X = (e.Top.X - e.Bot.X);\n\t\te.Delta.Y = (e.Top.Y - e.Bot.Y);\n\t\tif (e.Delta.Y === 0) e.Dx = ClipperLib.ClipperBase.horizontal;\n\t\telse e.Dx = (e.Delta.X) / (e.Delta.Y);\n\t};\n\n\tClipperLib.ClipperBase.prototype.InsertLocalMinima = function (newLm)\n\t{\n\t\tif (this.m_MinimaList === null)\n\t\t{\n\t\t\tthis.m_MinimaList = newLm;\n\t\t}\n\t\telse if (newLm.Y >= this.m_MinimaList.Y)\n\t\t{\n\t\t\tnewLm.Next = this.m_MinimaList;\n\t\t\tthis.m_MinimaList = newLm;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvar tmpLm = this.m_MinimaList;\n\t\t\twhile (tmpLm.Next !== null && (newLm.Y < tmpLm.Next.Y))\n\t\t\t\ttmpLm = tmpLm.Next;\n\t\t\tnewLm.Next = tmpLm.Next;\n\t\t\ttmpLm.Next = newLm;\n\t\t}\n\t};\n\n\tClipperLib.ClipperBase.prototype.PopLocalMinima = function (Y, current)\n\t{\n\t\tcurrent.v = this.m_CurrentLM;\n\t\tif (this.m_CurrentLM !== null && this.m_CurrentLM.Y === Y)\n\t\t{\n\t\t\tthis.m_CurrentLM = this.m_CurrentLM.Next;\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t};\n\n\tClipperLib.ClipperBase.prototype.ReverseHorizontal = function (e)\n\t{\n\t\t//swap horizontal edges' top and bottom x's so they follow the natural\n\t\t//progression of the bounds - ie so their xbots will align with the\n\t\t//adjoining lower edge. [Helpful in the ProcessHorizontal() method.]\n\t\tvar tmp = e.Top.X;\n\t\te.Top.X = e.Bot.X;\n\t\te.Bot.X = tmp;\n\t\tif (ClipperLib.use_xyz)\n\t\t{\n\t\t\ttmp = e.Top.Z;\n\t\t\te.Top.Z = e.Bot.Z;\n\t\t\te.Bot.Z = tmp;\n\t\t}\n\t};\n\n\tClipperLib.ClipperBase.prototype.Reset = function ()\n\t{\n\t\tthis.m_CurrentLM = this.m_MinimaList;\n\t\tif (this.m_CurrentLM === null) //ie nothing to process\n\t\t\treturn;\n\t\t//reset all edges ...\n\t\tthis.m_Scanbeam = null;\n\t\tvar lm = this.m_MinimaList;\n\t\twhile (lm !== null)\n\t\t{\n\t\t\tthis.InsertScanbeam(lm.Y);\n\t\t\tvar e = lm.LeftBound;\n\t\t\tif (e !== null)\n\t\t\t{\n\t\t\t\t//e.Curr = e.Bot;\n\t\t\t\te.Curr.X = e.Bot.X;\n\t\t\t\te.Curr.Y = e.Bot.Y;\n\t\t\t\tif (ClipperLib.use_xyz) e.Curr.Z = e.Bot.Z;\n\t\t\t\te.OutIdx = ClipperLib.ClipperBase.Unassigned;\n\t\t\t}\n\t\t\te = lm.RightBound;\n\t\t\tif (e !== null)\n\t\t\t{\n\t\t\t\t//e.Curr = e.Bot;\n\t\t\t\te.Curr.X = e.Bot.X;\n\t\t\t\te.Curr.Y = e.Bot.Y;\n\t\t\t\tif (ClipperLib.use_xyz) e.Curr.Z = e.Bot.Z;\n\t\t\t\te.OutIdx = ClipperLib.ClipperBase.Unassigned;\n\t\t\t}\n\t\t\tlm = lm.Next;\n\t\t}\n\t\tthis.m_ActiveEdges = null;\n\t};\n\n\tClipperLib.ClipperBase.prototype.InsertScanbeam = function (Y)\n\t{\n\t\t//single-linked list: sorted descending, ignoring dups.\n\t\tif (this.m_Scanbeam === null)\n\t\t{\n\t\t\tthis.m_Scanbeam = new ClipperLib.Scanbeam();\n\t\t\tthis.m_Scanbeam.Next = null;\n\t\t\tthis.m_Scanbeam.Y = Y;\n\t\t}\n\t\telse if (Y > this.m_Scanbeam.Y)\n\t\t{\n\t\t\tvar newSb = new ClipperLib.Scanbeam();\n\t\t\tnewSb.Y = Y;\n\t\t\tnewSb.Next = this.m_Scanbeam;\n\t\t\tthis.m_Scanbeam = newSb;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvar sb2 = this.m_Scanbeam;\n\t\t\twhile (sb2.Next !== null && Y <= sb2.Next.Y)\n\t\t\t{\n\t\t\t\tsb2 = sb2.Next;\n\t\t\t}\n\t\t\tif (Y === sb2.Y)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t} //ie ignores duplicates\n\t\t\tvar newSb1 = new ClipperLib.Scanbeam();\n\t\t\tnewSb1.Y = Y;\n\t\t\tnewSb1.Next = sb2.Next;\n\t\t\tsb2.Next = newSb1;\n\t\t}\n\t};\n\n\tClipperLib.ClipperBase.prototype.PopScanbeam = function (Y)\n\t{\n\t\tif (this.m_Scanbeam === null)\n\t\t{\n\t\t\tY.v = 0;\n\t\t\treturn false;\n\t\t}\n\t\tY.v = this.m_Scanbeam.Y;\n\t\tthis.m_Scanbeam = this.m_Scanbeam.Next;\n\t\treturn true;\n\t};\n\n\tClipperLib.ClipperBase.prototype.LocalMinimaPending = function ()\n\t{\n\t\treturn (this.m_CurrentLM !== null);\n\t};\n\n\tClipperLib.ClipperBase.prototype.CreateOutRec = function ()\n\t{\n\t\tvar result = new ClipperLib.OutRec();\n\t\tresult.Idx = ClipperLib.ClipperBase.Unassigned;\n\t\tresult.IsHole = false;\n\t\tresult.IsOpen = false;\n\t\tresult.FirstLeft = null;\n\t\tresult.Pts = null;\n\t\tresult.BottomPt = null;\n\t\tresult.PolyNode = null;\n\t\tthis.m_PolyOuts.push(result);\n\t\tresult.Idx = this.m_PolyOuts.length - 1;\n\t\treturn result;\n\t};\n\n\tClipperLib.ClipperBase.prototype.DisposeOutRec = function (index)\n\t{\n\t\tvar outRec = this.m_PolyOuts[index];\n\t\toutRec.Pts = null;\n\t\toutRec = null;\n\t\tthis.m_PolyOuts[index] = null;\n\t};\n\n\tClipperLib.ClipperBase.prototype.UpdateEdgeIntoAEL = function (e)\n\t{\n\t\tif (e.NextInLML === null)\n\t\t{\n\t\t\tClipperLib.Error(\"UpdateEdgeIntoAEL: invalid call\");\n\t\t}\n\t\tvar AelPrev = e.PrevInAEL;\n\t\tvar AelNext = e.NextInAEL;\n\t\te.NextInLML.OutIdx = e.OutIdx;\n\t\tif (AelPrev !== null)\n\t\t{\n\t\t\tAelPrev.NextInAEL = e.NextInLML;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.m_ActiveEdges = e.NextInLML;\n\t\t}\n\t\tif (AelNext !== null)\n\t\t{\n\t\t\tAelNext.PrevInAEL = e.NextInLML;\n\t\t}\n\t\te.NextInLML.Side = e.Side;\n\t\te.NextInLML.WindDelta = e.WindDelta;\n\t\te.NextInLML.WindCnt = e.WindCnt;\n\t\te.NextInLML.WindCnt2 = e.WindCnt2;\n\t\te = e.NextInLML;\n\t\te.Curr.X = e.Bot.X;\n\t\te.Curr.Y = e.Bot.Y;\n\t\te.PrevInAEL = AelPrev;\n\t\te.NextInAEL = AelNext;\n\t\tif (!ClipperLib.ClipperBase.IsHorizontal(e))\n\t\t{\n\t\t\tthis.InsertScanbeam(e.Top.Y);\n\t\t}\n\t\treturn e;\n\t};\n\n\tClipperLib.ClipperBase.prototype.SwapPositionsInAEL = function (edge1, edge2)\n\t{\n\t\t//check that one or other edge hasn't already been removed from AEL ...\n\t\tif (edge1.NextInAEL === edge1.PrevInAEL || edge2.NextInAEL === edge2.PrevInAEL)\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\tif (edge1.NextInAEL === edge2)\n\t\t{\n\t\t\tvar next = edge2.NextInAEL;\n\t\t\tif (next !== null)\n\t\t\t{\n\t\t\t\tnext.PrevInAEL = edge1;\n\t\t\t}\n\t\t\tvar prev = edge1.PrevInAEL;\n\t\t\tif (prev !== null)\n\t\t\t{\n\t\t\t\tprev.NextInAEL = edge2;\n\t\t\t}\n\t\t\tedge2.PrevInAEL = prev;\n\t\t\tedge2.NextInAEL = edge1;\n\t\t\tedge1.PrevInAEL = edge2;\n\t\t\tedge1.NextInAEL = next;\n\t\t}\n\t\telse if (edge2.NextInAEL === edge1)\n\t\t{\n\t\t\tvar next1 = edge1.NextInAEL;\n\t\t\tif (next1 !== null)\n\t\t\t{\n\t\t\t\tnext1.PrevInAEL = edge2;\n\t\t\t}\n\t\t\tvar prev1 = edge2.PrevInAEL;\n\t\t\tif (prev1 !== null)\n\t\t\t{\n\t\t\t\tprev1.NextInAEL = edge1;\n\t\t\t}\n\t\t\tedge1.PrevInAEL = prev1;\n\t\t\tedge1.NextInAEL = edge2;\n\t\t\tedge2.PrevInAEL = edge1;\n\t\t\tedge2.NextInAEL = next1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvar next2 = edge1.NextInAEL;\n\t\t\tvar prev2 = edge1.PrevInAEL;\n\t\t\tedge1.NextInAEL = edge2.NextInAEL;\n\t\t\tif (edge1.NextInAEL !== null)\n\t\t\t{\n\t\t\t\tedge1.NextInAEL.PrevInAEL = edge1;\n\t\t\t}\n\t\t\tedge1.PrevInAEL = edge2.PrevInAEL;\n\t\t\tif (edge1.PrevInAEL !== null)\n\t\t\t{\n\t\t\t\tedge1.PrevInAEL.NextInAEL = edge1;\n\t\t\t}\n\t\t\tedge2.NextInAEL = next2;\n\t\t\tif (edge2.NextInAEL !== null)\n\t\t\t{\n\t\t\t\tedge2.NextInAEL.PrevInAEL = edge2;\n\t\t\t}\n\t\t\tedge2.PrevInAEL = prev2;\n\t\t\tif (edge2.PrevInAEL !== null)\n\t\t\t{\n\t\t\t\tedge2.PrevInAEL.NextInAEL = edge2;\n\t\t\t}\n\t\t}\n\n\t\tif (edge1.PrevInAEL === null)\n\t\t{\n\t\t\tthis.m_ActiveEdges = edge1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (edge2.PrevInAEL === null)\n\t\t\t{\n\t\t\t\tthis.m_ActiveEdges = edge2;\n\t\t\t}\n\t\t}\n\t};\n\n\tClipperLib.ClipperBase.prototype.DeleteFromAEL = function (e)\n\t{\n\t\tvar AelPrev = e.PrevInAEL;\n\t\tvar AelNext = e.NextInAEL;\n\t\tif (AelPrev === null && AelNext === null && e !== this.m_ActiveEdges)\n\t\t{\n\t\t\treturn;\n\t\t} //already deleted\n\t\tif (AelPrev !== null)\n\t\t{\n\t\t\tAelPrev.NextInAEL = AelNext;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.m_ActiveEdges = AelNext;\n\t\t}\n\t\tif (AelNext !== null)\n\t\t{\n\t\t\tAelNext.PrevInAEL = AelPrev;\n\t\t}\n\t\te.NextInAEL = null;\n\t\te.PrevInAEL = null;\n\t}\n\n\t// public Clipper(int InitOptions = 0)\n\t/**\n\t * @suppress {missingProperties}\n\t */\n\tClipperLib.Clipper = function (InitOptions)\n\t{\n\t\tif (typeof (InitOptions) === \"undefined\") InitOptions = 0;\n\t\tthis.m_PolyOuts = null;\n\t\tthis.m_ClipType = ClipperLib.ClipType.ctIntersection;\n\t\tthis.m_Scanbeam = null;\n\t\tthis.m_Maxima = null;\n\t\tthis.m_ActiveEdges = null;\n\t\tthis.m_SortedEdges = null;\n\t\tthis.m_IntersectList = null;\n\t\tthis.m_IntersectNodeComparer = null;\n\t\tthis.m_ExecuteLocked = false;\n\t\tthis.m_ClipFillType = ClipperLib.PolyFillType.pftEvenOdd;\n\t\tthis.m_SubjFillType = ClipperLib.PolyFillType.pftEvenOdd;\n\t\tthis.m_Joins = null;\n\t\tthis.m_GhostJoins = null;\n\t\tthis.m_UsingPolyTree = false;\n\t\tthis.ReverseSolution = false;\n\t\tthis.StrictlySimple = false;\n\n\t\tClipperLib.ClipperBase.call(this);\n\n\t\tthis.m_Scanbeam = null;\n\t\tthis.m_Maxima = null;\n\t\tthis.m_ActiveEdges = null;\n\t\tthis.m_SortedEdges = null;\n\t\tthis.m_IntersectList = new Array();\n\t\tthis.m_IntersectNodeComparer = ClipperLib.MyIntersectNodeSort.Compare;\n\t\tthis.m_ExecuteLocked = false;\n\t\tthis.m_UsingPolyTree = false;\n\t\tthis.m_PolyOuts = new Array();\n\t\tthis.m_Joins = new Array();\n\t\tthis.m_GhostJoins = new Array();\n\t\tthis.ReverseSolution = (1 & InitOptions) !== 0;\n\t\tthis.StrictlySimple = (2 & InitOptions) !== 0;\n\t\tthis.PreserveCollinear = (4 & InitOptions) !== 0;\n\t\tif (ClipperLib.use_xyz)\n\t\t{\n\t\t\tthis.ZFillFunction = null; // function (FPoint bot1, FPoint top1, FPoint bot2, FPoint top2, ref FPoint intersectPt);\n\t\t}\n\t};\n\n\tClipperLib.Clipper.ioReverseSolution = 1;\n\tClipperLib.Clipper.ioStrictlySimple = 2;\n\tClipperLib.Clipper.ioPreserveCollinear = 4;\n\n\tClipperLib.Clipper.prototype.Clear = function ()\n\t{\n\t\tif (this.m_edges.length === 0)\n\t\t\treturn;\n\t\t//avoids problems with ClipperBase destructor\n\t\tthis.DisposeAllPolyPts();\n\t\tClipperLib.ClipperBase.prototype.Clear.call(this);\n\t};\n\n\tClipperLib.Clipper.prototype.InsertMaxima = function (X)\n\t{\n\t\t//double-linked list: sorted ascending, ignoring dups.\n\t\tvar newMax = new ClipperLib.Maxima();\n\t\tnewMax.X = X;\n\t\tif (this.m_Maxima === null)\n\t\t{\n\t\t\tthis.m_Maxima = newMax;\n\t\t\tthis.m_Maxima.Next = null;\n\t\t\tthis.m_Maxima.Prev = null;\n\t\t}\n\t\telse if (X < this.m_Maxima.X)\n\t\t{\n\t\t\tnewMax.Next = this.m_Maxima;\n\t\t\tnewMax.Prev = null;\n\t\t\tthis.m_Maxima = newMax;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvar m = this.m_Maxima;\n\t\t\twhile (m.Next !== null && X >= m.Next.X)\n\t\t\t{\n\t\t\t\tm = m.Next;\n\t\t\t}\n\t\t\tif (X === m.X)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t} //ie ignores duplicates (& CG to clean up newMax)\n\t\t\t//insert newMax between m and m.Next ...\n\t\t\tnewMax.Next = m.Next;\n\t\t\tnewMax.Prev = m;\n\t\t\tif (m.Next !== null)\n\t\t\t{\n\t\t\t\tm.Next.Prev = newMax;\n\t\t\t}\n\t\t\tm.Next = newMax;\n\t\t}\n\t};\n\n\t// ************************************\n\tClipperLib.Clipper.prototype.Execute = function ()\n\t{\n\t\tvar a = arguments,\n\t\t\talen = a.length,\n\t\t\tispolytree = a[1] instanceof ClipperLib.PolyTree;\n\t\tif (alen === 4 && !ispolytree) // function (clipType, solution, subjFillType, clipFillType)\n\t\t{\n\t\t\tvar clipType = a[0],\n\t\t\t\tsolution = a[1],\n\t\t\t\tsubjFillType = a[2],\n\t\t\t\tclipFillType = a[3];\n\t\t\tif (this.m_ExecuteLocked)\n\t\t\t\treturn false;\n\t\t\tif (this.m_HasOpenPaths)\n\t\t\t\tClipperLib.Error(\"Error: PolyTree struct is needed for open path clipping.\");\n\t\t\tthis.m_ExecuteLocked = true;\n\t\t\tClipperLib.Clear(solution);\n\t\t\tthis.m_SubjFillType = subjFillType;\n\t\t\tthis.m_ClipFillType = clipFillType;\n\t\t\tthis.m_ClipType = clipType;\n\t\t\tthis.m_UsingPolyTree = false;\n\t\t\ttry\n\t\t\t{\n\t\t\t\tvar succeeded = this.ExecuteInternal();\n\t\t\t\t//build the return polygons ...\n\t\t\t\tif (succeeded) this.BuildResult(solution);\n\t\t\t}\n\t\t\tfinally\n\t\t\t{\n\t\t\t\tthis.DisposeAllPolyPts();\n\t\t\t\tthis.m_ExecuteLocked = false;\n\t\t\t}\n\t\t\treturn succeeded;\n\t\t}\n\t\telse if (alen === 4 && ispolytree) // function (clipType, polytree, subjFillType, clipFillType)\n\t\t{\n\t\t\tvar clipType = a[0],\n\t\t\t\tpolytree = a[1],\n\t\t\t\tsubjFillType = a[2],\n\t\t\t\tclipFillType = a[3];\n\t\t\tif (this.m_ExecuteLocked)\n\t\t\t\treturn false;\n\t\t\tthis.m_ExecuteLocked = true;\n\t\t\tthis.m_SubjFillType = subjFillType;\n\t\t\tthis.m_ClipFillType = clipFillType;\n\t\t\tthis.m_ClipType = clipType;\n\t\t\tthis.m_UsingPolyTree = true;\n\t\t\ttry\n\t\t\t{\n\t\t\t\tvar succeeded = this.ExecuteInternal();\n\t\t\t\t//build the return polygons ...\n\t\t\t\tif (succeeded) this.BuildResult2(polytree);\n\t\t\t}\n\t\t\tfinally\n\t\t\t{\n\t\t\t\tthis.DisposeAllPolyPts();\n\t\t\t\tthis.m_ExecuteLocked = false;\n\t\t\t}\n\t\t\treturn succeeded;\n\t\t}\n\t\telse if (alen === 2 && !ispolytree) // function (clipType, solution)\n\t\t{\n\t\t\tvar clipType = a[0],\n\t\t\t\tsolution = a[1];\n\t\t\treturn this.Execute(clipType, solution, ClipperLib.PolyFillType.pftEvenOdd, ClipperLib.PolyFillType.pftEvenOdd);\n\t\t}\n\t\telse if (alen === 2 && ispolytree) // function (clipType, polytree)\n\t\t{\n\t\t\tvar clipType = a[0],\n\t\t\t\tpolytree = a[1];\n\t\t\treturn this.Execute(clipType, polytree, ClipperLib.PolyFillType.pftEvenOdd, ClipperLib.PolyFillType.pftEvenOdd);\n\t\t}\n\t};\n\n\tClipperLib.Clipper.prototype.FixHoleLinkage = function (outRec)\n\t{\n\t\t//skip if an outermost polygon or\n\t\t//already already points to the correct FirstLeft ...\n\t\tif (outRec.FirstLeft === null || (outRec.IsHole !== outRec.FirstLeft.IsHole && outRec.FirstLeft.Pts !== null))\n\t\t\treturn;\n\t\tvar orfl = outRec.FirstLeft;\n\t\twhile (orfl !== null && ((orfl.IsHole === outRec.IsHole) || orfl.Pts === null))\n\t\t\torfl = orfl.FirstLeft;\n\t\toutRec.FirstLeft = orfl;\n\t};\n\n\tClipperLib.Clipper.prototype.ExecuteInternal = function ()\n\t{\n\t\ttry\n\t\t{\n\t\t\tthis.Reset();\n\t\t\tthis.m_SortedEdges = null;\n\t\t\tthis.m_Maxima = null;\n\n\t\t\tvar botY = {},\n\t\t\t\ttopY = {};\n\n\t\t\tif (!this.PopScanbeam(botY))\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tthis.InsertLocalMinimaIntoAEL(botY.v);\n\t\t\twhile (this.PopScanbeam(topY) || this.LocalMinimaPending())\n\t\t\t{\n\t\t\t\tthis.ProcessHorizontals();\n\t\t\t\tthis.m_GhostJoins.length = 0;\n\t\t\t\tif (!this.ProcessIntersections(topY.v))\n\t\t\t\t{\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tthis.ProcessEdgesAtTopOfScanbeam(topY.v);\n\t\t\t\tbotY.v = topY.v;\n\t\t\t\tthis.InsertLocalMinimaIntoAEL(botY.v);\n\t\t\t}\n\n\t\t\t//fix orientations ...\n\t\t\tvar outRec, i, ilen;\n\t\t\t//fix orientations ...\n\t\t\tfor (i = 0, ilen = this.m_PolyOuts.length; i < ilen; i++)\n\t\t\t{\n\t\t\t\toutRec = this.m_PolyOuts[i];\n\t\t\t\tif (outRec.Pts === null || outRec.IsOpen) continue;\n\t\t\t\tif ((outRec.IsHole ^ this.ReverseSolution) == (this.Area$1(outRec) > 0))\n\t\t\t\t\tthis.ReversePolyPtLinks(outRec.Pts);\n\t\t\t}\n\n\t\t\tthis.JoinCommonEdges();\n\n\t\t\tfor (i = 0, ilen = this.m_PolyOuts.length; i < ilen; i++)\n\t\t\t{\n\t\t\t\toutRec = this.m_PolyOuts[i];\n\t\t\t\tif (outRec.Pts === null)\n\t\t\t\t\tcontinue;\n\t\t\t\telse if (outRec.IsOpen)\n\t\t\t\t\tthis.FixupOutPolyline(outRec);\n\t\t\t\telse\n\t\t\t\t\tthis.FixupOutPolygon(outRec);\n\t\t\t}\n\n\t\t\tif (this.StrictlySimple) this.DoSimplePolygons();\n\t\t\treturn true;\n\t\t}\n\t\t//catch { return false; }\n\t\tfinally\n\t\t{\n\t\t\tthis.m_Joins.length = 0;\n\t\t\tthis.m_GhostJoins.length = 0;\n\t\t}\n\t};\n\n\tClipperLib.Clipper.prototype.DisposeAllPolyPts = function ()\n\t{\n\t\tfor (var i = 0, ilen = this.m_PolyOuts.length; i < ilen; ++i)\n\t\t\tthis.DisposeOutRec(i);\n\t\tClipperLib.Clear(this.m_PolyOuts);\n\t};\n\n\tClipperLib.Clipper.prototype.AddJoin = function (Op1, Op2, OffPt)\n\t{\n\t\tvar j = new ClipperLib.Join();\n\t\tj.OutPt1 = Op1;\n\t\tj.OutPt2 = Op2;\n\t\t//j.OffPt = OffPt;\n\t\tj.OffPt.X = OffPt.X;\n\t\tj.OffPt.Y = OffPt.Y;\n\t\tif (ClipperLib.use_xyz) j.OffPt.Z = OffPt.Z;\n\t\tthis.m_Joins.push(j);\n\t};\n\n\tClipperLib.Clipper.prototype.AddGhostJoin = function (Op, OffPt)\n\t{\n\t\tvar j = new ClipperLib.Join();\n\t\tj.OutPt1 = Op;\n\t\t//j.OffPt = OffPt;\n\t\tj.OffPt.X = OffPt.X;\n\t\tj.OffPt.Y = OffPt.Y;\n\t\tif (ClipperLib.use_xyz) j.OffPt.Z = OffPt.Z;\n\t\tthis.m_GhostJoins.push(j);\n\t};\n\n\t//if (ClipperLib.use_xyz)\n\t//{\n\tClipperLib.Clipper.prototype.SetZ = function (pt, e1, e2)\n\t{\n\t\tif (this.ZFillFunction !== null)\n\t\t{\n\t\t\tif (pt.Z !== 0 || this.ZFillFunction === null) return;\n\t\t\telse if (ClipperLib.FPoint.op_Equality(pt, e1.Bot)) pt.Z = e1.Bot.Z;\n\t\t\telse if (ClipperLib.FPoint.op_Equality(pt, e1.Top)) pt.Z = e1.Top.Z;\n\t\t\telse if (ClipperLib.FPoint.op_Equality(pt, e2.Bot)) pt.Z = e2.Bot.Z;\n\t\t\telse if (ClipperLib.FPoint.op_Equality(pt, e2.Top)) pt.Z = e2.Top.Z;\n\t\t\telse this.ZFillFunction(e1.Bot, e1.Top, e2.Bot, e2.Top, pt);\n\t\t}\n\t};\n\t//}\n\n\tClipperLib.Clipper.prototype.InsertLocalMinimaIntoAEL = function (botY)\n\t{\n\t\tvar lm = {};\n\n\t\tvar lb;\n\t\tvar rb;\n\t\twhile (this.PopLocalMinima(botY, lm))\n\t\t{\n\t\t\tlb = lm.v.LeftBound;\n\t\t\trb = lm.v.RightBound;\n\n\t\t\tvar Op1 = null;\n\t\t\tif (lb === null)\n\t\t\t{\n\t\t\t\tthis.InsertEdgeIntoAEL(rb, null);\n\t\t\t\tthis.SetWindingCount(rb);\n\t\t\t\tif (this.IsContributing(rb))\n\t\t\t\t\tOp1 = this.AddOutPt(rb, rb.Bot);\n\t\t\t}\n\t\t\telse if (rb === null)\n\t\t\t{\n\t\t\t\tthis.InsertEdgeIntoAEL(lb, null);\n\t\t\t\tthis.SetWindingCount(lb);\n\t\t\t\tif (this.IsContributing(lb))\n\t\t\t\t\tOp1 = this.AddOutPt(lb, lb.Bot);\n\t\t\t\tthis.InsertScanbeam(lb.Top.Y);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthis.InsertEdgeIntoAEL(lb, null);\n\t\t\t\tthis.InsertEdgeIntoAEL(rb, lb);\n\t\t\t\tthis.SetWindingCount(lb);\n\t\t\t\trb.WindCnt = lb.WindCnt;\n\t\t\t\trb.WindCnt2 = lb.WindCnt2;\n\t\t\t\tif (this.IsContributing(lb))\n\t\t\t\t\tOp1 = this.AddLocalMinPoly(lb, rb, lb.Bot);\n\t\t\t\tthis.InsertScanbeam(lb.Top.Y);\n\t\t\t}\n\t\t\tif (rb !== null)\n\t\t\t{\n\t\t\t\tif (ClipperLib.ClipperBase.IsHorizontal(rb))\n\t\t\t\t{\n\t\t\t\t\tif (rb.NextInLML !== null)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.InsertScanbeam(rb.NextInLML.Top.Y);\n\t\t\t\t\t}\n\t\t\t\t\tthis.AddEdgeToSEL(rb);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tthis.InsertScanbeam(rb.Top.Y);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (lb === null || rb === null) continue;\n\t\t\t//if output polygons share an Edge with a horizontal rb, they'll need joining later ...\n\t\t\tif (Op1 !== null && ClipperLib.ClipperBase.IsHorizontal(rb) && this.m_GhostJoins.length > 0 && rb.WindDelta !== 0)\n\t\t\t{\n\t\t\t\tfor (var i = 0, ilen = this.m_GhostJoins.length; i < ilen; i++)\n\t\t\t\t{\n\t\t\t\t\t//if the horizontal Rb and a 'ghost' horizontal overlap, then convert\n\t\t\t\t\t//the 'ghost' join to a real join ready for later ...\n\t\t\t\t\tvar j = this.m_GhostJoins[i];\n\n\t\t\t\t\tif (this.HorzSegmentsOverlap(j.OutPt1.Pt.X, j.OffPt.X, rb.Bot.X, rb.Top.X))\n\t\t\t\t\t\tthis.AddJoin(j.OutPt1, Op1, j.OffPt);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (lb.OutIdx >= 0 && lb.PrevInAEL !== null &&\n\t\t\t\tlb.PrevInAEL.Curr.X === lb.Bot.X &&\n\t\t\t\tlb.PrevInAEL.OutIdx >= 0 &&\n\t\t\t\tClipperLib.ClipperBase.SlopesEqual5(lb.PrevInAEL.Curr, lb.PrevInAEL.Top, lb.Curr, lb.Top) &&\n\t\t\t\tlb.WindDelta !== 0 && lb.PrevInAEL.WindDelta !== 0)\n\t\t\t{\n\t\t\t\tvar Op2 = this.AddOutPt(lb.PrevInAEL, lb.Bot);\n\t\t\t\tthis.AddJoin(Op1, Op2, lb.Top);\n\t\t\t}\n\t\t\tif (lb.NextInAEL !== rb)\n\t\t\t{\n\t\t\t\tif (rb.OutIdx >= 0 && rb.PrevInAEL.OutIdx >= 0 &&\n\t\t\t\t\tClipperLib.ClipperBase.SlopesEqual5(rb.PrevInAEL.Curr, rb.PrevInAEL.Top, rb.Curr, rb.Top) &&\n\t\t\t\t\trb.WindDelta !== 0 && rb.PrevInAEL.WindDelta !== 0)\n\t\t\t\t{\n\t\t\t\t\tvar Op2 = this.AddOutPt(rb.PrevInAEL, rb.Bot);\n\t\t\t\t\tthis.AddJoin(Op1, Op2, rb.Top);\n\t\t\t\t}\n\t\t\t\tvar e = lb.NextInAEL;\n\t\t\t\tif (e !== null)\n\t\t\t\t\twhile (e !== rb)\n\t\t\t\t\t{\n\t\t\t\t\t\t//nb: For calculating winding counts etc, IntersectEdges() assumes\n\t\t\t\t\t\t//that param1 will be to the right of param2 ABOVE the intersection ...\n\t\t\t\t\t\tthis.IntersectEdges(rb, e, lb.Curr);\n\t\t\t\t\t\t//order important here\n\t\t\t\t\t\te = e.NextInAEL;\n\t\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\n\tClipperLib.Clipper.prototype.InsertEdgeIntoAEL = function (edge, startEdge)\n\t{\n\t\tif (this.m_ActiveEdges === null)\n\t\t{\n\t\t\tedge.PrevInAEL = null;\n\t\t\tedge.NextInAEL = null;\n\t\t\tthis.m_ActiveEdges = edge;\n\t\t}\n\t\telse if (startEdge === null && this.E2InsertsBeforeE1(this.m_ActiveEdges, edge))\n\t\t{\n\t\t\tedge.PrevInAEL = null;\n\t\t\tedge.NextInAEL = this.m_ActiveEdges;\n\t\t\tthis.m_ActiveEdges.PrevInAEL = edge;\n\t\t\tthis.m_ActiveEdges = edge;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (startEdge === null)\n\t\t\t\tstartEdge = this.m_ActiveEdges;\n\t\t\twhile (startEdge.NextInAEL !== null && !this.E2InsertsBeforeE1(startEdge.NextInAEL, edge))\n\t\t\t\tstartEdge = startEdge.NextInAEL;\n\t\t\tedge.NextInAEL = startEdge.NextInAEL;\n\t\t\tif (startEdge.NextInAEL !== null)\n\t\t\t\tstartEdge.NextInAEL.PrevInAEL = edge;\n\t\t\tedge.PrevInAEL = startEdge;\n\t\t\tstartEdge.NextInAEL = edge;\n\t\t}\n\t};\n\n\tClipperLib.Clipper.prototype.E2InsertsBeforeE1 = function (e1, e2)\n\t{\n\t\tif (e2.Curr.X === e1.Curr.X)\n\t\t{\n\t\t\tif (e2.Top.Y > e1.Top.Y)\n\t\t\t\treturn e2.Top.X < ClipperLib.Clipper.TopX(e1, e2.Top.Y);\n\t\t\telse\n\t\t\t\treturn e1.Top.X > ClipperLib.Clipper.TopX(e2, e1.Top.Y);\n\t\t}\n\t\telse\n\t\t\treturn e2.Curr.X < e1.Curr.X;\n\t};\n\n\tClipperLib.Clipper.prototype.IsEvenOddFillType = function (edge)\n\t{\n\t\tif (edge.PolyTyp === ClipperLib.PolyType.ptSubject)\n\t\t\treturn this.m_SubjFillType === ClipperLib.PolyFillType.pftEvenOdd;\n\t\telse\n\t\t\treturn this.m_ClipFillType === ClipperLib.PolyFillType.pftEvenOdd;\n\t};\n\n\tClipperLib.Clipper.prototype.IsEvenOddAltFillType = function (edge)\n\t{\n\t\tif (edge.PolyTyp === ClipperLib.PolyType.ptSubject)\n\t\t\treturn this.m_ClipFillType === ClipperLib.PolyFillType.pftEvenOdd;\n\t\telse\n\t\t\treturn this.m_SubjFillType === ClipperLib.PolyFillType.pftEvenOdd;\n\t};\n\n\tClipperLib.Clipper.prototype.IsContributing = function (edge)\n\t{\n\t\tvar pft, pft2;\n\t\tif (edge.PolyTyp === ClipperLib.PolyType.ptSubject)\n\t\t{\n\t\t\tpft = this.m_SubjFillType;\n\t\t\tpft2 = this.m_ClipFillType;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpft = this.m_ClipFillType;\n\t\t\tpft2 = this.m_SubjFillType;\n\t\t}\n\t\tswitch (pft)\n\t\t{\n\t\tcase ClipperLib.PolyFillType.pftEvenOdd:\n\t\t\tif (edge.WindDelta === 0 && edge.WindCnt !== 1)\n\t\t\t\treturn false;\n\t\t\tbreak;\n\t\tcase ClipperLib.PolyFillType.pftNonZero:\n\t\t\tif (Math.abs(edge.WindCnt) !== 1)\n\t\t\t\treturn false;\n\t\t\tbreak;\n\t\tcase ClipperLib.PolyFillType.pftPositive:\n\t\t\tif (edge.WindCnt !== 1)\n\t\t\t\treturn false;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (edge.WindCnt !== -1)\n\t\t\t\treturn false;\n\t\t\tbreak;\n\t\t}\n\t\tswitch (this.m_ClipType)\n\t\t{\n\t\tcase ClipperLib.ClipType.ctIntersection:\n\t\t\tswitch (pft2)\n\t\t\t{\n\t\t\tcase ClipperLib.PolyFillType.pftEvenOdd:\n\t\t\tcase ClipperLib.PolyFillType.pftNonZero:\n\t\t\t\treturn (edge.WindCnt2 !== 0);\n\t\t\tcase ClipperLib.PolyFillType.pftPositive:\n\t\t\t\treturn (edge.WindCnt2 > 0);\n\t\t\tdefault:\n\t\t\t\treturn (edge.WindCnt2 < 0);\n\t\t\t}\n\t\tcase ClipperLib.ClipType.ctUnion:\n\t\t\tswitch (pft2)\n\t\t\t{\n\t\t\tcase ClipperLib.PolyFillType.pftEvenOdd:\n\t\t\tcase ClipperLib.PolyFillType.pftNonZero:\n\t\t\t\treturn (edge.WindCnt2 === 0);\n\t\t\tcase ClipperLib.PolyFillType.pftPositive:\n\t\t\t\treturn (edge.WindCnt2 <= 0);\n\t\t\tdefault:\n\t\t\t\treturn (edge.WindCnt2 >= 0);\n\t\t\t}\n\t\tcase ClipperLib.ClipType.ctDifference:\n\t\t\tif (edge.PolyTyp === ClipperLib.PolyType.ptSubject)\n\t\t\t\tswitch (pft2)\n\t\t\t\t{\n\t\t\t\tcase ClipperLib.PolyFillType.pftEvenOdd:\n\t\t\t\tcase ClipperLib.PolyFillType.pftNonZero:\n\t\t\t\t\treturn (edge.WindCnt2 === 0);\n\t\t\t\tcase ClipperLib.PolyFillType.pftPositive:\n\t\t\t\t\treturn (edge.WindCnt2 <= 0);\n\t\t\t\tdefault:\n\t\t\t\t\treturn (edge.WindCnt2 >= 0);\n\t\t\t\t}\n\t\t\telse\n\t\t\t\tswitch (pft2)\n\t\t\t\t{\n\t\t\t\tcase ClipperLib.PolyFillType.pftEvenOdd:\n\t\t\t\tcase ClipperLib.PolyFillType.pftNonZero:\n\t\t\t\t\treturn (edge.WindCnt2 !== 0);\n\t\t\t\tcase ClipperLib.PolyFillType.pftPositive:\n\t\t\t\t\treturn (edge.WindCnt2 > 0);\n\t\t\t\tdefault:\n\t\t\t\t\treturn (edge.WindCnt2 < 0);\n\t\t\t\t}\n\t\tcase ClipperLib.ClipType.ctXor:\n\t\t\tif (edge.WindDelta === 0)\n\t\t\t\tswitch (pft2)\n\t\t\t\t{\n\t\t\t\tcase ClipperLib.PolyFillType.pftEvenOdd:\n\t\t\t\tcase ClipperLib.PolyFillType.pftNonZero:\n\t\t\t\t\treturn (edge.WindCnt2 === 0);\n\t\t\t\tcase ClipperLib.PolyFillType.pftPositive:\n\t\t\t\t\treturn (edge.WindCnt2 <= 0);\n\t\t\t\tdefault:\n\t\t\t\t\treturn (edge.WindCnt2 >= 0);\n\t\t\t\t}\n\t\t\telse\n\t\t\t\treturn true;\n\t\t}\n\t\treturn true;\n\t};\n\n\tClipperLib.Clipper.prototype.SetWindingCount = function (edge)\n\t{\n\t\tvar e = edge.PrevInAEL;\n\t\t//find the edge of the same polytype that immediately preceeds 'edge' in AEL\n\t\twhile (e !== null && ((e.PolyTyp !== edge.PolyTyp) || (e.WindDelta === 0)))\n\t\t\te = e.PrevInAEL;\n\t\tif (e === null)\n\t\t{\n\t\t\tvar pft = (edge.PolyTyp === ClipperLib.PolyType.ptSubject ? this.m_SubjFillType : this.m_ClipFillType);\n\t\t\tif (edge.WindDelta === 0)\n\t\t\t{\n\t\t\t\tedge.WindCnt = (pft === ClipperLib.PolyFillType.pftNegative ? -1 : 1);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tedge.WindCnt = edge.WindDelta;\n\t\t\t}\n\t\t\tedge.WindCnt2 = 0;\n\t\t\te = this.m_ActiveEdges;\n\t\t\t//ie get ready to calc WindCnt2\n\t\t}\n\t\telse if (edge.WindDelta === 0 && this.m_ClipType !== ClipperLib.ClipType.ctUnion)\n\t\t{\n\t\t\tedge.WindCnt = 1;\n\t\t\tedge.WindCnt2 = e.WindCnt2;\n\t\t\te = e.NextInAEL;\n\t\t\t//ie get ready to calc WindCnt2\n\t\t}\n\t\telse if (this.IsEvenOddFillType(edge))\n\t\t{\n\t\t\t//EvenOdd filling ...\n\t\t\tif (edge.WindDelta === 0)\n\t\t\t{\n\t\t\t\t//are we inside a subj polygon ...\n\t\t\t\tvar Inside = true;\n\t\t\t\tvar e2 = e.PrevInAEL;\n\t\t\t\twhile (e2 !== null)\n\t\t\t\t{\n\t\t\t\t\tif (e2.PolyTyp === e.PolyTyp && e2.WindDelta !== 0)\n\t\t\t\t\t\tInside = !Inside;\n\t\t\t\t\te2 = e2.PrevInAEL;\n\t\t\t\t}\n\t\t\t\tedge.WindCnt = (Inside ? 0 : 1);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tedge.WindCnt = edge.WindDelta;\n\t\t\t}\n\t\t\tedge.WindCnt2 = e.WindCnt2;\n\t\t\te = e.NextInAEL;\n\t\t\t//ie get ready to calc WindCnt2\n\t\t}\n\t\telse\n\t\t{\n\t\t\t//nonZero, Positive or Negative filling ...\n\t\t\tif (e.WindCnt * e.WindDelta < 0)\n\t\t\t{\n\t\t\t\t//prev edge is 'decreasing' WindCount (WC) toward zero\n\t\t\t\t//so we're outside the previous polygon ...\n\t\t\t\tif (Math.abs(e.WindCnt) > 1)\n\t\t\t\t{\n\t\t\t\t\t//outside prev poly but still inside another.\n\t\t\t\t\t//when reversing direction of prev poly use the same WC\n\t\t\t\t\tif (e.WindDelta * edge.WindDelta < 0)\n\t\t\t\t\t\tedge.WindCnt = e.WindCnt;\n\t\t\t\t\telse\n\t\t\t\t\t\tedge.WindCnt = e.WindCnt + edge.WindDelta;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tedge.WindCnt = (edge.WindDelta === 0 ? 1 : edge.WindDelta);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t//prev edge is 'increasing' WindCount (WC) away from zero\n\t\t\t\t//so we're inside the previous polygon ...\n\t\t\t\tif (edge.WindDelta === 0)\n\t\t\t\t\tedge.WindCnt = (e.WindCnt < 0 ? e.WindCnt - 1 : e.WindCnt + 1);\n\t\t\t\telse if (e.WindDelta * edge.WindDelta < 0)\n\t\t\t\t\tedge.WindCnt = e.WindCnt;\n\t\t\t\telse\n\t\t\t\t\tedge.WindCnt = e.WindCnt + edge.WindDelta;\n\t\t\t}\n\t\t\tedge.WindCnt2 = e.WindCnt2;\n\t\t\te = e.NextInAEL;\n\t\t\t//ie get ready to calc WindCnt2\n\t\t}\n\t\t//update WindCnt2 ...\n\t\tif (this.IsEvenOddAltFillType(edge))\n\t\t{\n\t\t\t//EvenOdd filling ...\n\t\t\twhile (e !== edge)\n\t\t\t{\n\t\t\t\tif (e.WindDelta !== 0)\n\t\t\t\t\tedge.WindCnt2 = (edge.WindCnt2 === 0 ? 1 : 0);\n\t\t\t\te = e.NextInAEL;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\t//nonZero, Positive or Negative filling ...\n\t\t\twhile (e !== edge)\n\t\t\t{\n\t\t\t\tedge.WindCnt2 += e.WindDelta;\n\t\t\t\te = e.NextInAEL;\n\t\t\t}\n\t\t}\n\t};\n\n\tClipperLib.Clipper.prototype.AddEdgeToSEL = function (edge)\n\t{\n\t\t//SEL pointers in PEdge are use to build transient lists of horizontal edges.\n\t\t//However, since we don't need to worry about processing order, all additions\n\t\t//are made to the front of the list ...\n\t\tif (this.m_SortedEdges === null)\n\t\t{\n\t\t\tthis.m_SortedEdges = edge;\n\t\t\tedge.PrevInSEL = null;\n\t\t\tedge.NextInSEL = null;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tedge.NextInSEL = this.m_SortedEdges;\n\t\t\tedge.PrevInSEL = null;\n\t\t\tthis.m_SortedEdges.PrevInSEL = edge;\n\t\t\tthis.m_SortedEdges = edge;\n\t\t}\n\t};\n\n\tClipperLib.Clipper.prototype.PopEdgeFromSEL = function (e)\n\t{\n\t\t//Pop edge from front of SEL (ie SEL is a FILO list)\n\t\te.v = this.m_SortedEdges;\n\t\tif (e.v === null)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tvar oldE = e.v;\n\t\tthis.m_SortedEdges = e.v.NextInSEL;\n\t\tif (this.m_SortedEdges !== null)\n\t\t{\n\t\t\tthis.m_SortedEdges.PrevInSEL = null;\n\t\t}\n\t\toldE.NextInSEL = null;\n\t\toldE.PrevInSEL = null;\n\t\treturn true;\n\t};\n\n\tClipperLib.Clipper.prototype.CopyAELToSEL = function ()\n\t{\n\t\tvar e = this.m_ActiveEdges;\n\t\tthis.m_SortedEdges = e;\n\t\twhile (e !== null)\n\t\t{\n\t\t\te.PrevInSEL = e.PrevInAEL;\n\t\t\te.NextInSEL = e.NextInAEL;\n\t\t\te = e.NextInAEL;\n\t\t}\n\t};\n\n\tClipperLib.Clipper.prototype.SwapPositionsInSEL = function (edge1, edge2)\n\t{\n\t\tif (edge1.NextInSEL === null && edge1.PrevInSEL === null)\n\t\t\treturn;\n\t\tif (edge2.NextInSEL === null && edge2.PrevInSEL === null)\n\t\t\treturn;\n\t\tif (edge1.NextInSEL === edge2)\n\t\t{\n\t\t\tvar next = edge2.NextInSEL;\n\t\t\tif (next !== null)\n\t\t\t\tnext.PrevInSEL = edge1;\n\t\t\tvar prev = edge1.PrevInSEL;\n\t\t\tif (prev !== null)\n\t\t\t\tprev.NextInSEL = edge2;\n\t\t\tedge2.PrevInSEL = prev;\n\t\t\tedge2.NextInSEL = edge1;\n\t\t\tedge1.PrevInSEL = edge2;\n\t\t\tedge1.NextInSEL = next;\n\t\t}\n\t\telse if (edge2.NextInSEL === edge1)\n\t\t{\n\t\t\tvar next = edge1.NextInSEL;\n\t\t\tif (next !== null)\n\t\t\t\tnext.PrevInSEL = edge2;\n\t\t\tvar prev = edge2.PrevInSEL;\n\t\t\tif (prev !== null)\n\t\t\t\tprev.NextInSEL = edge1;\n\t\t\tedge1.PrevInSEL = prev;\n\t\t\tedge1.NextInSEL = edge2;\n\t\t\tedge2.PrevInSEL = edge1;\n\t\t\tedge2.NextInSEL = next;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvar next = edge1.NextInSEL;\n\t\t\tvar prev = edge1.PrevInSEL;\n\t\t\tedge1.NextInSEL = edge2.NextInSEL;\n\t\t\tif (edge1.NextInSEL !== null)\n\t\t\t\tedge1.NextInSEL.PrevInSEL = edge1;\n\t\t\tedge1.PrevInSEL = edge2.PrevInSEL;\n\t\t\tif (edge1.PrevInSEL !== null)\n\t\t\t\tedge1.PrevInSEL.NextInSEL = edge1;\n\t\t\tedge2.NextInSEL = next;\n\t\t\tif (edge2.NextInSEL !== null)\n\t\t\t\tedge2.NextInSEL.PrevInSEL = edge2;\n\t\t\tedge2.PrevInSEL = prev;\n\t\t\tif (edge2.PrevInSEL !== null)\n\t\t\t\tedge2.PrevInSEL.NextInSEL = edge2;\n\t\t}\n\t\tif (edge1.PrevInSEL === null)\n\t\t\tthis.m_SortedEdges = edge1;\n\t\telse if (edge2.PrevInSEL === null)\n\t\t\tthis.m_SortedEdges = edge2;\n\t};\n\n\tClipperLib.Clipper.prototype.AddLocalMaxPoly = function (e1, e2, pt)\n\t{\n\t\tthis.AddOutPt(e1, pt);\n\t\tif (e2.WindDelta === 0) this.AddOutPt(e2, pt);\n\t\tif (e1.OutIdx === e2.OutIdx)\n\t\t{\n\t\t\te1.OutIdx = -1;\n\t\t\te2.OutIdx = -1;\n\t\t}\n\t\telse if (e1.OutIdx < e2.OutIdx)\n\t\t\tthis.AppendPolygon(e1, e2);\n\t\telse\n\t\t\tthis.AppendPolygon(e2, e1);\n\t};\n\n\tClipperLib.Clipper.prototype.AddLocalMinPoly = function (e1, e2, pt)\n\t{\n\t\tvar result;\n\t\tvar e, prevE;\n\t\tif (ClipperLib.ClipperBase.IsHorizontal(e2) || (e1.Dx > e2.Dx))\n\t\t{\n\t\t\tresult = this.AddOutPt(e1, pt);\n\t\t\te2.OutIdx = e1.OutIdx;\n\t\t\te1.Side = ClipperLib.EdgeSide.esLeft;\n\t\t\te2.Side = ClipperLib.EdgeSide.esRight;\n\t\t\te = e1;\n\t\t\tif (e.PrevInAEL === e2)\n\t\t\t\tprevE = e2.PrevInAEL;\n\t\t\telse\n\t\t\t\tprevE = e.PrevInAEL;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tresult = this.AddOutPt(e2, pt);\n\t\t\te1.OutIdx = e2.OutIdx;\n\t\t\te1.Side = ClipperLib.EdgeSide.esRight;\n\t\t\te2.Side = ClipperLib.EdgeSide.esLeft;\n\t\t\te = e2;\n\t\t\tif (e.PrevInAEL === e1)\n\t\t\t\tprevE = e1.PrevInAEL;\n\t\t\telse\n\t\t\t\tprevE = e.PrevInAEL;\n\t\t}\n\n\t\tif (prevE !== null && prevE.OutIdx >= 0 && prevE.Top.Y < pt.Y && e.Top.Y < pt.Y)\n\t\t{\n\t\t\tvar xPrev = ClipperLib.Clipper.TopX(prevE, pt.Y);\n\t\t\tvar xE = ClipperLib.Clipper.TopX(e, pt.Y);\n\t\t\tif ((xPrev === xE) && (e.WindDelta !== 0) && (prevE.WindDelta !== 0) && ClipperLib.ClipperBase.SlopesEqual5(new ClipperLib.FPoint2(xPrev, pt.Y), prevE.Top, new ClipperLib.FPoint2(xE, pt.Y), e.Top))\n\t\t\t{\n\t\t\t\tvar outPt = this.AddOutPt(prevE, pt);\n\t\t\t\tthis.AddJoin(result, outPt, e.Top);\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t};\n\n\tClipperLib.Clipper.prototype.AddOutPt = function (e, pt)\n\t{\n\t\tif (e.OutIdx < 0)\n\t\t{\n\t\t\tvar outRec = this.CreateOutRec();\n\t\t\toutRec.IsOpen = (e.WindDelta === 0);\n\t\t\tvar newOp = new ClipperLib.OutPt();\n\t\t\toutRec.Pts = newOp;\n\t\t\tnewOp.Idx = outRec.Idx;\n\t\t\t//newOp.Pt = pt;\n\t\t\tnewOp.Pt.X = pt.X;\n\t\t\tnewOp.Pt.Y = pt.Y;\n\t\t\tif (ClipperLib.use_xyz) newOp.Pt.Z = pt.Z;\n\t\t\tnewOp.Next = newOp;\n\t\t\tnewOp.Prev = newOp;\n\t\t\tif (!outRec.IsOpen)\n\t\t\t\tthis.SetHoleState(e, outRec);\n\t\t\te.OutIdx = outRec.Idx;\n\t\t\t//nb: do this after SetZ !\n\t\t\treturn newOp;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvar outRec = this.m_PolyOuts[e.OutIdx];\n\t\t\t//OutRec.Pts is the 'Left-most' point & OutRec.Pts.Prev is the 'Right-most'\n\t\t\tvar op = outRec.Pts;\n\t\t\tvar ToFront = (e.Side === ClipperLib.EdgeSide.esLeft);\n\t\t\tif (ToFront && ClipperLib.FPoint.op_Equality(pt, op.Pt))\n\t\t\t\treturn op;\n\t\t\telse if (!ToFront && ClipperLib.FPoint.op_Equality(pt, op.Prev.Pt))\n\t\t\t\treturn op.Prev;\n\t\t\tvar newOp = new ClipperLib.OutPt();\n\t\t\tnewOp.Idx = outRec.Idx;\n\t\t\t//newOp.Pt = pt;\n\t\t\tnewOp.Pt.X = pt.X;\n\t\t\tnewOp.Pt.Y = pt.Y;\n\t\t\tif (ClipperLib.use_xyz) newOp.Pt.Z = pt.Z;\n\t\t\tnewOp.Next = op;\n\t\t\tnewOp.Prev = op.Prev;\n\t\t\tnewOp.Prev.Next = newOp;\n\t\t\top.Prev = newOp;\n\t\t\tif (ToFront)\n\t\t\t\toutRec.Pts = newOp;\n\t\t\treturn newOp;\n\t\t}\n\t};\n\n\tClipperLib.Clipper.prototype.GetLastOutPt = function (e)\n\t{\n\t\tvar outRec = this.m_PolyOuts[e.OutIdx];\n\t\tif (e.Side === ClipperLib.EdgeSide.esLeft)\n\t\t{\n\t\t\treturn outRec.Pts;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn outRec.Pts.Prev;\n\t\t}\n\t};\n\n\tClipperLib.Clipper.prototype.SwapPoints = function (pt1, pt2)\n\t{\n\t\tvar tmp = new ClipperLib.FPoint1(pt1.Value);\n\t\t//pt1.Value = pt2.Value;\n\t\tpt1.Value.X = pt2.Value.X;\n\t\tpt1.Value.Y = pt2.Value.Y;\n\t\tif (ClipperLib.use_xyz) pt1.Value.Z = pt2.Value.Z;\n\t\t//pt2.Value = tmp;\n\t\tpt2.Value.X = tmp.X;\n\t\tpt2.Value.Y = tmp.Y;\n\t\tif (ClipperLib.use_xyz) pt2.Value.Z = tmp.Z;\n\t};\n\n\tClipperLib.Clipper.prototype.HorzSegmentsOverlap = function (seg1a, seg1b, seg2a, seg2b)\n\t{\n\t\tvar tmp;\n\t\tif (seg1a > seg1b)\n\t\t{\n\t\t\ttmp = seg1a;\n\t\t\tseg1a = seg1b;\n\t\t\tseg1b = tmp;\n\t\t}\n\t\tif (seg2a > seg2b)\n\t\t{\n\t\t\ttmp = seg2a;\n\t\t\tseg2a = seg2b;\n\t\t\tseg2b = tmp;\n\t\t}\n\t\treturn (seg1a < seg2b) && (seg2a < seg1b);\n\t}\n\n\tClipperLib.Clipper.prototype.SetHoleState = function (e, outRec)\n\t{\n\t\tvar e2 = e.PrevInAEL;\n\t\tvar eTmp = null;\n\t\twhile (e2 !== null)\n\t\t{\n\t\t\tif (e2.OutIdx >= 0 && e2.WindDelta !== 0)\n\t\t\t{\n\t\t\t\tif (eTmp === null)\n\t\t\t\t\teTmp = e2;\n\t\t\t\telse if (eTmp.OutIdx === e2.OutIdx)\n\t\t\t\t\teTmp = null; //paired\n\t\t\t}\n\t\t\te2 = e2.PrevInAEL;\n\t\t}\n\n\t\tif (eTmp === null)\n\t\t{\n\t\t\toutRec.FirstLeft = null;\n\t\t\toutRec.IsHole = false;\n\t\t}\n\t\telse\n\t\t{\n\t\t\toutRec.FirstLeft = this.m_PolyOuts[eTmp.OutIdx];\n\t\t\toutRec.IsHole = !outRec.FirstLeft.IsHole;\n\t\t}\n\t};\n\n\tClipperLib.Clipper.prototype.GetDx = function (pt1, pt2)\n\t{\n\t\tif (pt1.Y === pt2.Y)\n\t\t\treturn ClipperLib.ClipperBase.horizontal;\n\t\telse\n\t\t\treturn (pt2.X - pt1.X) / (pt2.Y - pt1.Y);\n\t};\n\n\tClipperLib.Clipper.prototype.FirstIsBottomPt = function (btmPt1, btmPt2)\n\t{\n\t\tvar p = btmPt1.Prev;\n\t\twhile ((ClipperLib.FPoint.op_Equality(p.Pt, btmPt1.Pt)) && (p !== btmPt1))\n\t\t\tp = p.Prev;\n\t\tvar dx1p = Math.abs(this.GetDx(btmPt1.Pt, p.Pt));\n\t\tp = btmPt1.Next;\n\t\twhile ((ClipperLib.FPoint.op_Equality(p.Pt, btmPt1.Pt)) && (p !== btmPt1))\n\t\t\tp = p.Next;\n\t\tvar dx1n = Math.abs(this.GetDx(btmPt1.Pt, p.Pt));\n\t\tp = btmPt2.Prev;\n\t\twhile ((ClipperLib.FPoint.op_Equality(p.Pt, btmPt2.Pt)) && (p !== btmPt2))\n\t\t\tp = p.Prev;\n\t\tvar dx2p = Math.abs(this.GetDx(btmPt2.Pt, p.Pt));\n\t\tp = btmPt2.Next;\n\t\twhile ((ClipperLib.FPoint.op_Equality(p.Pt, btmPt2.Pt)) && (p !== btmPt2))\n\t\t\tp = p.Next;\n\t\tvar dx2n = Math.abs(this.GetDx(btmPt2.Pt, p.Pt));\n\n\t\tif (Math.max(dx1p, dx1n) === Math.max(dx2p, dx2n) && Math.min(dx1p, dx1n) === Math.min(dx2p, dx2n))\n\t\t{\n\t\t\treturn this.Area(btmPt1) > 0; //if otherwise identical use orientation\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn (dx1p >= dx2p && dx1p >= dx2n) || (dx1n >= dx2p && dx1n >= dx2n);\n\t\t}\n\t};\n\n\tClipperLib.Clipper.prototype.GetBottomPt = function (pp)\n\t{\n\t\tvar dups = null;\n\t\tvar p = pp.Next;\n\t\twhile (p !== pp)\n\t\t{\n\t\t\tif (p.Pt.Y > pp.Pt.Y)\n\t\t\t{\n\t\t\t\tpp = p;\n\t\t\t\tdups = null;\n\t\t\t}\n\t\t\telse if (p.Pt.Y === pp.Pt.Y && p.Pt.X <= pp.Pt.X)\n\t\t\t{\n\t\t\t\tif (p.Pt.X < pp.Pt.X)\n\t\t\t\t{\n\t\t\t\t\tdups = null;\n\t\t\t\t\tpp = p;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (p.Next !== pp && p.Prev !== pp)\n\t\t\t\t\t\tdups = p;\n\t\t\t\t}\n\t\t\t}\n\t\t\tp = p.Next;\n\t\t}\n\t\tif (dups !== null)\n\t\t{\n\t\t\t//there appears to be at least 2 vertices at bottomPt so ...\n\t\t\twhile (dups !== p)\n\t\t\t{\n\t\t\t\tif (!this.FirstIsBottomPt(p, dups))\n\t\t\t\t\tpp = dups;\n\t\t\t\tdups = dups.Next;\n\t\t\t\twhile (ClipperLib.FPoint.op_Inequality(dups.Pt, pp.Pt))\n\t\t\t\t\tdups = dups.Next;\n\t\t\t}\n\t\t}\n\t\treturn pp;\n\t};\n\n\tClipperLib.Clipper.prototype.GetLowermostRec = function (outRec1, outRec2)\n\t{\n\t\t//work out which polygon fragment has the correct hole state ...\n\t\tif (outRec1.BottomPt === null)\n\t\t\toutRec1.BottomPt = this.GetBottomPt(outRec1.Pts);\n\t\tif (outRec2.BottomPt === null)\n\t\t\toutRec2.BottomPt = this.GetBottomPt(outRec2.Pts);\n\t\tvar bPt1 = outRec1.BottomPt;\n\t\tvar bPt2 = outRec2.BottomPt;\n\t\tif (bPt1.Pt.Y > bPt2.Pt.Y)\n\t\t\treturn outRec1;\n\t\telse if (bPt1.Pt.Y < bPt2.Pt.Y)\n\t\t\treturn outRec2;\n\t\telse if (bPt1.Pt.X < bPt2.Pt.X)\n\t\t\treturn outRec1;\n\t\telse if (bPt1.Pt.X > bPt2.Pt.X)\n\t\t\treturn outRec2;\n\t\telse if (bPt1.Next === bPt1)\n\t\t\treturn outRec2;\n\t\telse if (bPt2.Next === bPt2)\n\t\t\treturn outRec1;\n\t\telse if (this.FirstIsBottomPt(bPt1, bPt2))\n\t\t\treturn outRec1;\n\t\telse\n\t\t\treturn outRec2;\n\t};\n\n\tClipperLib.Clipper.prototype.OutRec1RightOfOutRec2 = function (outRec1, outRec2)\n\t{\n\t\tdo {\n\t\t\toutRec1 = outRec1.FirstLeft;\n\t\t\tif (outRec1 === outRec2)\n\t\t\t\treturn true;\n\t\t}\n\t\twhile (outRec1 !== null)\n\t\treturn false;\n\t};\n\n\tClipperLib.Clipper.prototype.GetOutRec = function (idx)\n\t{\n\t\tvar outrec = this.m_PolyOuts[idx];\n\t\twhile (outrec !== this.m_PolyOuts[outrec.Idx])\n\t\t\toutrec = this.m_PolyOuts[outrec.Idx];\n\t\treturn outrec;\n\t};\n\n\tClipperLib.Clipper.prototype.AppendPolygon = function (e1, e2)\n\t{\n\t\t//get the start and ends of both output polygons ...\n\t\tvar outRec1 = this.m_PolyOuts[e1.OutIdx];\n\t\tvar outRec2 = this.m_PolyOuts[e2.OutIdx];\n\t\tvar holeStateRec;\n\t\tif (this.OutRec1RightOfOutRec2(outRec1, outRec2))\n\t\t\tholeStateRec = outRec2;\n\t\telse if (this.OutRec1RightOfOutRec2(outRec2, outRec1))\n\t\t\tholeStateRec = outRec1;\n\t\telse\n\t\t\tholeStateRec = this.GetLowermostRec(outRec1, outRec2);\n\n\t\t//get the start and ends of both output polygons and\n\t\t//join E2 poly onto E1 poly and delete pointers to E2 ...\n\n\t\tvar p1_lft = outRec1.Pts;\n\t\tvar p1_rt = p1_lft.Prev;\n\t\tvar p2_lft = outRec2.Pts;\n\t\tvar p2_rt = p2_lft.Prev;\n\t\t//join e2 poly onto e1 poly and delete pointers to e2 ...\n\t\tif (e1.Side === ClipperLib.EdgeSide.esLeft)\n\t\t{\n\t\t\tif (e2.Side === ClipperLib.EdgeSide.esLeft)\n\t\t\t{\n\t\t\t\t//z y x a b c\n\t\t\t\tthis.ReversePolyPtLinks(p2_lft);\n\t\t\t\tp2_lft.Next = p1_lft;\n\t\t\t\tp1_lft.Prev = p2_lft;\n\t\t\t\tp1_rt.Next = p2_rt;\n\t\t\t\tp2_rt.Prev = p1_rt;\n\t\t\t\toutRec1.Pts = p2_rt;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t//x y z a b c\n\t\t\t\tp2_rt.Next = p1_lft;\n\t\t\t\tp1_lft.Prev = p2_rt;\n\t\t\t\tp2_lft.Prev = p1_rt;\n\t\t\t\tp1_rt.Next = p2_lft;\n\t\t\t\toutRec1.Pts = p2_lft;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (e2.Side === ClipperLib.EdgeSide.esRight)\n\t\t\t{\n\t\t\t\t//a b c z y x\n\t\t\t\tthis.ReversePolyPtLinks(p2_lft);\n\t\t\t\tp1_rt.Next = p2_rt;\n\t\t\t\tp2_rt.Prev = p1_rt;\n\t\t\t\tp2_lft.Next = p1_lft;\n\t\t\t\tp1_lft.Prev = p2_lft;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t//a b c x y z\n\t\t\t\tp1_rt.Next = p2_lft;\n\t\t\t\tp2_lft.Prev = p1_rt;\n\t\t\t\tp1_lft.Prev = p2_rt;\n\t\t\t\tp2_rt.Next = p1_lft;\n\t\t\t}\n\t\t}\n\t\toutRec1.BottomPt = null;\n\t\tif (holeStateRec === outRec2)\n\t\t{\n\t\t\tif (outRec2.FirstLeft !== outRec1)\n\t\t\t\toutRec1.FirstLeft = outRec2.FirstLeft;\n\t\t\toutRec1.IsHole = outRec2.IsHole;\n\t\t}\n\t\toutRec2.Pts = null;\n\t\toutRec2.BottomPt = null;\n\t\toutRec2.FirstLeft = outRec1;\n\t\tvar OKIdx = e1.OutIdx;\n\t\tvar ObsoleteIdx = e2.OutIdx;\n\t\te1.OutIdx = -1;\n\t\t//nb: safe because we only get here via AddLocalMaxPoly\n\t\te2.OutIdx = -1;\n\t\tvar e = this.m_ActiveEdges;\n\t\twhile (e !== null)\n\t\t{\n\t\t\tif (e.OutIdx === ObsoleteIdx)\n\t\t\t{\n\t\t\t\te.OutIdx = OKIdx;\n\t\t\t\te.Side = e1.Side;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\te = e.NextInAEL;\n\t\t}\n\t\toutRec2.Idx = outRec1.Idx;\n\t};\n\n\tClipperLib.Clipper.prototype.ReversePolyPtLinks = function (pp)\n\t{\n\t\tif (pp === null)\n\t\t\treturn;\n\t\tvar pp1;\n\t\tvar pp2;\n\t\tpp1 = pp;\n\t\tdo {\n\t\t\tpp2 = pp1.Next;\n\t\t\tpp1.Next = pp1.Prev;\n\t\t\tpp1.Prev = pp2;\n\t\t\tpp1 = pp2;\n\t\t}\n\t\twhile (pp1 !== pp)\n\t};\n\n\tClipperLib.Clipper.SwapSides = function (edge1, edge2)\n\t{\n\t\tvar side = edge1.Side;\n\t\tedge1.Side = edge2.Side;\n\t\tedge2.Side = side;\n\t};\n\n\tClipperLib.Clipper.SwapPolyIndexes = function (edge1, edge2)\n\t{\n\t\tvar outIdx = edge1.OutIdx;\n\t\tedge1.OutIdx = edge2.OutIdx;\n\t\tedge2.OutIdx = outIdx;\n\t};\n\n\tClipperLib.Clipper.prototype.IntersectEdges = function (e1, e2, pt)\n\t{\n\t\t//e1 will be to the left of e2 BELOW the intersection. Therefore e1 is before\n\t\t//e2 in AEL except when e1 is being inserted at the intersection point ...\n\t\tvar e1Contributing = (e1.OutIdx >= 0);\n\t\tvar e2Contributing = (e2.OutIdx >= 0);\n\n\t\tif (ClipperLib.use_xyz)\n\t\t\tthis.SetZ(pt, e1, e2);\n\n\t\tif (ClipperLib.use_lines)\n\t\t{\n\t\t\t//if either edge is on an OPEN path ...\n\t\t\tif (e1.WindDelta === 0 || e2.WindDelta === 0)\n\t\t\t{\n\t\t\t\t//ignore subject-subject open path intersections UNLESS they\n\t\t\t\t//are both open paths, AND they are both 'contributing maximas' ...\n\t\t\t\tif (e1.WindDelta === 0 && e2.WindDelta === 0) return;\n\t\t\t\t//if intersecting a subj line with a subj poly ...\n\t\t\t\telse if (e1.PolyTyp === e2.PolyTyp &&\n\t\t\t\t\te1.WindDelta !== e2.WindDelta && this.m_ClipType === ClipperLib.ClipType.ctUnion)\n\t\t\t\t{\n\t\t\t\t\tif (e1.WindDelta === 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (e2Contributing)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tthis.AddOutPt(e1, pt);\n\t\t\t\t\t\t\tif (e1Contributing)\n\t\t\t\t\t\t\t\te1.OutIdx = -1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tif (e1Contributing)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tthis.AddOutPt(e2, pt);\n\t\t\t\t\t\t\tif (e2Contributing)\n\t\t\t\t\t\t\t\te2.OutIdx = -1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (e1.PolyTyp !== e2.PolyTyp)\n\t\t\t\t{\n\t\t\t\t\tif ((e1.WindDelta === 0) && Math.abs(e2.WindCnt) === 1 &&\n\t\t\t\t\t\t(this.m_ClipType !== ClipperLib.ClipType.ctUnion || e2.WindCnt2 === 0))\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.AddOutPt(e1, pt);\n\t\t\t\t\t\tif (e1Contributing)\n\t\t\t\t\t\t\te1.OutIdx = -1;\n\t\t\t\t\t}\n\t\t\t\t\telse if ((e2.WindDelta === 0) && (Math.abs(e1.WindCnt) === 1) &&\n\t\t\t\t\t\t(this.m_ClipType !== ClipperLib.ClipType.ctUnion || e1.WindCnt2 === 0))\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.AddOutPt(e2, pt);\n\t\t\t\t\t\tif (e2Contributing)\n\t\t\t\t\t\t\te2.OutIdx = -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t//update winding counts...\n\t\t//assumes that e1 will be to the Right of e2 ABOVE the intersection\n\t\tif (e1.PolyTyp === e2.PolyTyp)\n\t\t{\n\t\t\tif (this.IsEvenOddFillType(e1))\n\t\t\t{\n\t\t\t\tvar oldE1WindCnt = e1.WindCnt;\n\t\t\t\te1.WindCnt = e2.WindCnt;\n\t\t\t\te2.WindCnt = oldE1WindCnt;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (e1.WindCnt + e2.WindDelta === 0)\n\t\t\t\t\te1.WindCnt = -e1.WindCnt;\n\t\t\t\telse\n\t\t\t\t\te1.WindCnt += e2.WindDelta;\n\t\t\t\tif (e2.WindCnt - e1.WindDelta === 0)\n\t\t\t\t\te2.WindCnt = -e2.WindCnt;\n\t\t\t\telse\n\t\t\t\t\te2.WindCnt -= e1.WindDelta;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (!this.IsEvenOddFillType(e2))\n\t\t\t\te1.WindCnt2 += e2.WindDelta;\n\t\t\telse\n\t\t\t\te1.WindCnt2 = (e1.WindCnt2 === 0) ? 1 : 0;\n\t\t\tif (!this.IsEvenOddFillType(e1))\n\t\t\t\te2.WindCnt2 -= e1.WindDelta;\n\t\t\telse\n\t\t\t\te2.WindCnt2 = (e2.WindCnt2 === 0) ? 1 : 0;\n\t\t}\n\t\tvar e1FillType, e2FillType, e1FillType2, e2FillType2;\n\t\tif (e1.PolyTyp === ClipperLib.PolyType.ptSubject)\n\t\t{\n\t\t\te1FillType = this.m_SubjFillType;\n\t\t\te1FillType2 = this.m_ClipFillType;\n\t\t}\n\t\telse\n\t\t{\n\t\t\te1FillType = this.m_ClipFillType;\n\t\t\te1FillType2 = this.m_SubjFillType;\n\t\t}\n\t\tif (e2.PolyTyp === ClipperLib.PolyType.ptSubject)\n\t\t{\n\t\t\te2FillType = this.m_SubjFillType;\n\t\t\te2FillType2 = this.m_ClipFillType;\n\t\t}\n\t\telse\n\t\t{\n\t\t\te2FillType = this.m_ClipFillType;\n\t\t\te2FillType2 = this.m_SubjFillType;\n\t\t}\n\t\tvar e1Wc, e2Wc;\n\t\tswitch (e1FillType)\n\t\t{\n\t\tcase ClipperLib.PolyFillType.pftPositive:\n\t\t\te1Wc = e1.WindCnt;\n\t\t\tbreak;\n\t\tcase ClipperLib.PolyFillType.pftNegative:\n\t\t\te1Wc = -e1.WindCnt;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\te1Wc = Math.abs(e1.WindCnt);\n\t\t\tbreak;\n\t\t}\n\t\tswitch (e2FillType)\n\t\t{\n\t\tcase ClipperLib.PolyFillType.pftPositive:\n\t\t\te2Wc = e2.WindCnt;\n\t\t\tbreak;\n\t\tcase ClipperLib.PolyFillType.pftNegative:\n\t\t\te2Wc = -e2.WindCnt;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\te2Wc = Math.abs(e2.WindCnt);\n\t\t\tbreak;\n\t\t}\n\t\tif (e1Contributing && e2Contributing)\n\t\t{\n\t\t\tif ((e1Wc !== 0 && e1Wc !== 1) || (e2Wc !== 0 && e2Wc !== 1) ||\n\t\t\t\t(e1.PolyTyp !== e2.PolyTyp && this.m_ClipType !== ClipperLib.ClipType.ctXor))\n\t\t\t{\n\t\t\t\tthis.AddLocalMaxPoly(e1, e2, pt);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthis.AddOutPt(e1, pt);\n\t\t\t\tthis.AddOutPt(e2, pt);\n\t\t\t\tClipperLib.Clipper.SwapSides(e1, e2);\n\t\t\t\tClipperLib.Clipper.SwapPolyIndexes(e1, e2);\n\t\t\t}\n\t\t}\n\t\telse if (e1Contributing)\n\t\t{\n\t\t\tif (e2Wc === 0 || e2Wc === 1)\n\t\t\t{\n\t\t\t\tthis.AddOutPt(e1, pt);\n\t\t\t\tClipperLib.Clipper.SwapSides(e1, e2);\n\t\t\t\tClipperLib.Clipper.SwapPolyIndexes(e1, e2);\n\t\t\t}\n\t\t}\n\t\telse if (e2Contributing)\n\t\t{\n\t\t\tif (e1Wc === 0 || e1Wc === 1)\n\t\t\t{\n\t\t\t\tthis.AddOutPt(e2, pt);\n\t\t\t\tClipperLib.Clipper.SwapSides(e1, e2);\n\t\t\t\tClipperLib.Clipper.SwapPolyIndexes(e1, e2);\n\t\t\t}\n\t\t}\n\t\telse if ((e1Wc === 0 || e1Wc === 1) && (e2Wc === 0 || e2Wc === 1))\n\t\t{\n\t\t\t//neither edge is currently contributing ...\n\t\t\tvar e1Wc2, e2Wc2;\n\t\t\tswitch (e1FillType2)\n\t\t\t{\n\t\t\tcase ClipperLib.PolyFillType.pftPositive:\n\t\t\t\te1Wc2 = e1.WindCnt2;\n\t\t\t\tbreak;\n\t\t\tcase ClipperLib.PolyFillType.pftNegative:\n\t\t\t\te1Wc2 = -e1.WindCnt2;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\te1Wc2 = Math.abs(e1.WindCnt2);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tswitch (e2FillType2)\n\t\t\t{\n\t\t\tcase ClipperLib.PolyFillType.pftPositive:\n\t\t\t\te2Wc2 = e2.WindCnt2;\n\t\t\t\tbreak;\n\t\t\tcase ClipperLib.PolyFillType.pftNegative:\n\t\t\t\te2Wc2 = -e2.WindCnt2;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\te2Wc2 = Math.abs(e2.WindCnt2);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (e1.PolyTyp !== e2.PolyTyp)\n\t\t\t{\n\t\t\t\tthis.AddLocalMinPoly(e1, e2, pt);\n\t\t\t}\n\t\t\telse if (e1Wc === 1 && e2Wc === 1)\n\t\t\t\tswitch (this.m_ClipType)\n\t\t\t\t{\n\t\t\t\tcase ClipperLib.ClipType.ctIntersection:\n\t\t\t\t\tif (e1Wc2 > 0 && e2Wc2 > 0)\n\t\t\t\t\t\tthis.AddLocalMinPoly(e1, e2, pt);\n\t\t\t\t\tbreak;\n\t\t\t\tcase ClipperLib.ClipType.ctUnion:\n\t\t\t\t\tif (e1Wc2 <= 0 && e2Wc2 <= 0)\n\t\t\t\t\t\tthis.AddLocalMinPoly(e1, e2, pt);\n\t\t\t\t\tbreak;\n\t\t\t\tcase ClipperLib.ClipType.ctDifference:\n\t\t\t\t\tif (((e1.PolyTyp === ClipperLib.PolyType.ptClip) && (e1Wc2 > 0) && (e2Wc2 > 0)) ||\n\t\t\t\t\t\t((e1.PolyTyp === ClipperLib.PolyType.ptSubject) && (e1Wc2 <= 0) && (e2Wc2 <= 0)))\n\t\t\t\t\t\tthis.AddLocalMinPoly(e1, e2, pt);\n\t\t\t\t\tbreak;\n\t\t\t\tcase ClipperLib.ClipType.ctXor:\n\t\t\t\t\tthis.AddLocalMinPoly(e1, e2, pt);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\telse\n\t\t\t\tClipperLib.Clipper.SwapSides(e1, e2);\n\t\t}\n\t};\n\n\tClipperLib.Clipper.prototype.DeleteFromSEL = function (e)\n\t{\n\t\tvar SelPrev = e.PrevInSEL;\n\t\tvar SelNext = e.NextInSEL;\n\t\tif (SelPrev === null && SelNext === null && (e !== this.m_SortedEdges))\n\t\t\treturn;\n\t\t//already deleted\n\t\tif (SelPrev !== null)\n\t\t\tSelPrev.NextInSEL = SelNext;\n\t\telse\n\t\t\tthis.m_SortedEdges = SelNext;\n\t\tif (SelNext !== null)\n\t\t\tSelNext.PrevInSEL = SelPrev;\n\t\te.NextInSEL = null;\n\t\te.PrevInSEL = null;\n\t};\n\n\tClipperLib.Clipper.prototype.ProcessHorizontals = function ()\n\t{\n\t\tvar horzEdge = {}; //m_SortedEdges;\n\t\twhile (this.PopEdgeFromSEL(horzEdge))\n\t\t{\n\t\t\tthis.ProcessHorizontal(horzEdge.v);\n\t\t}\n\t};\n\n\tClipperLib.Clipper.prototype.GetHorzDirection = function (HorzEdge, $var)\n\t{\n\t\tif (HorzEdge.Bot.X < HorzEdge.Top.X)\n\t\t{\n\t\t\t$var.Left = HorzEdge.Bot.X;\n\t\t\t$var.Right = HorzEdge.Top.X;\n\t\t\t$var.Dir = ClipperLib.Direction.dLeftToRight;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t$var.Left = HorzEdge.Top.X;\n\t\t\t$var.Right = HorzEdge.Bot.X;\n\t\t\t$var.Dir = ClipperLib.Direction.dRightToLeft;\n\t\t}\n\t};\n\n\tClipperLib.Clipper.prototype.ProcessHorizontal = function (horzEdge)\n\t{\n\t\tvar $var = {\n\t\t\tDir: null,\n\t\t\tLeft: null,\n\t\t\tRight: null\n\t\t};\n\n\t\tthis.GetHorzDirection(horzEdge, $var);\n\t\tvar dir = $var.Dir;\n\t\tvar horzLeft = $var.Left;\n\t\tvar horzRight = $var.Right;\n\n\t\tvar IsOpen = horzEdge.WindDelta === 0;\n\n\t\tvar eLastHorz = horzEdge,\n\t\t\teMaxPair = null;\n\t\twhile (eLastHorz.NextInLML !== null && ClipperLib.ClipperBase.IsHorizontal(eLastHorz.NextInLML))\n\t\t\teLastHorz = eLastHorz.NextInLML;\n\t\tif (eLastHorz.NextInLML === null)\n\t\t\teMaxPair = this.GetMaximaPair(eLastHorz);\n\n\t\tvar currMax = this.m_Maxima;\n\t\tif (currMax !== null)\n\t\t{\n\t\t\t//get the first maxima in range (X) ...\n\t\t\tif (dir === ClipperLib.Direction.dLeftToRight)\n\t\t\t{\n\t\t\t\twhile (currMax !== null && currMax.X <= horzEdge.Bot.X)\n\t\t\t\t{\n\t\t\t\t\tcurrMax = currMax.Next;\n\t\t\t\t}\n\t\t\t\tif (currMax !== null && currMax.X >= eLastHorz.Top.X)\n\t\t\t\t{\n\t\t\t\t\tcurrMax = null;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\twhile (currMax.Next !== null && currMax.Next.X < horzEdge.Bot.X)\n\t\t\t\t{\n\t\t\t\t\tcurrMax = currMax.Next;\n\t\t\t\t}\n\t\t\t\tif (currMax.X <= eLastHorz.Top.X)\n\t\t\t\t{\n\t\t\t\t\tcurrMax = null;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvar op1 = null;\n\t\tfor (;;) //loop through consec. horizontal edges\n\t\t{\n\t\t\tvar IsLastHorz = (horzEdge === eLastHorz);\n\t\t\tvar e = this.GetNextInAEL(horzEdge, dir);\n\t\t\twhile (e !== null)\n\t\t\t{\n\t\t\t\t//this code block inserts extra coords into horizontal edges (in output\n\t\t\t\t//polygons) whereever maxima touch these horizontal edges. This helps\n\t\t\t\t//'simplifying' polygons (ie if the Simplify property is set).\n\t\t\t\tif (currMax !== null)\n\t\t\t\t{\n\t\t\t\t\tif (dir === ClipperLib.Direction.dLeftToRight)\n\t\t\t\t\t{\n\t\t\t\t\t\twhile (currMax !== null && currMax.X < e.Curr.X)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (horzEdge.OutIdx >= 0 && !IsOpen)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tthis.AddOutPt(horzEdge, new ClipperLib.FPoint2(currMax.X, horzEdge.Bot.Y));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcurrMax = currMax.Next;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\twhile (currMax !== null && currMax.X > e.Curr.X)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (horzEdge.OutIdx >= 0 && !IsOpen)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tthis.AddOutPt(horzEdge, new ClipperLib.FPoint2(currMax.X, horzEdge.Bot.Y));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcurrMax = currMax.Prev;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif ((dir === ClipperLib.Direction.dLeftToRight && e.Curr.X > horzRight) || (dir === ClipperLib.Direction.dRightToLeft && e.Curr.X < horzLeft))\n\t\t\t\t{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t//Also break if we've got to the end of an intermediate horizontal edge ...\n\t\t\t\t//nb: Smaller Dx's are to the right of larger Dx's ABOVE the horizontal.\n\t\t\t\tif (e.Curr.X === horzEdge.Top.X && horzEdge.NextInLML !== null && e.Dx < horzEdge.NextInLML.Dx)\n\t\t\t\t\tbreak;\n\n\t\t\t\tif (horzEdge.OutIdx >= 0 && !IsOpen) //note: may be done multiple times\n\t\t\t\t{\n\t\t\t\t\tif (ClipperLib.use_xyz)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (dir === ClipperLib.Direction.dLeftToRight)\n\t\t\t\t\t\t\tthis.SetZ(e.Curr, horzEdge, e);\n\t\t\t\t\t\telse this.SetZ(e.Curr, e, horzEdge);\n\t\t\t\t\t}\n\n\t\t\t\t\top1 = this.AddOutPt(horzEdge, e.Curr);\n\t\t\t\t\tvar eNextHorz = this.m_SortedEdges;\n\t\t\t\t\twhile (eNextHorz !== null)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (eNextHorz.OutIdx >= 0 && this.HorzSegmentsOverlap(horzEdge.Bot.X, horzEdge.Top.X, eNextHorz.Bot.X, eNextHorz.Top.X))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvar op2 = this.GetLastOutPt(eNextHorz);\n\t\t\t\t\t\t\tthis.AddJoin(op2, op1, eNextHorz.Top);\n\t\t\t\t\t\t}\n\t\t\t\t\t\teNextHorz = eNextHorz.NextInSEL;\n\t\t\t\t\t}\n\t\t\t\t\tthis.AddGhostJoin(op1, horzEdge.Bot);\n\t\t\t\t}\n\n\t\t\t\t//OK, so far we're still in range of the horizontal Edge  but make sure\n\t\t\t\t//we're at the last of consec. horizontals when matching with eMaxPair\n\t\t\t\tif (e === eMaxPair && IsLastHorz)\n\t\t\t\t{\n\t\t\t\t\tif (horzEdge.OutIdx >= 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.AddLocalMaxPoly(horzEdge, eMaxPair, horzEdge.Top);\n\t\t\t\t\t}\n\t\t\t\t\tthis.DeleteFromAEL(horzEdge);\n\t\t\t\t\tthis.DeleteFromAEL(eMaxPair);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (dir === ClipperLib.Direction.dLeftToRight)\n\t\t\t\t{\n\t\t\t\t\tvar Pt = new ClipperLib.FPoint2(e.Curr.X, horzEdge.Curr.Y);\n\t\t\t\t\tthis.IntersectEdges(horzEdge, e, Pt);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tvar Pt = new ClipperLib.FPoint2(e.Curr.X, horzEdge.Curr.Y);\n\t\t\t\t\tthis.IntersectEdges(e, horzEdge, Pt);\n\t\t\t\t}\n\t\t\t\tvar eNext = this.GetNextInAEL(e, dir);\n\t\t\t\tthis.SwapPositionsInAEL(horzEdge, e);\n\t\t\t\te = eNext;\n\t\t\t} //end while(e !== null)\n\n\t\t\t//Break out of loop if HorzEdge.NextInLML is not also horizontal ...\n\t\t\tif (horzEdge.NextInLML === null || !ClipperLib.ClipperBase.IsHorizontal(horzEdge.NextInLML))\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\thorzEdge = this.UpdateEdgeIntoAEL(horzEdge);\n\t\t\tif (horzEdge.OutIdx >= 0)\n\t\t\t{\n\t\t\t\tthis.AddOutPt(horzEdge, horzEdge.Bot);\n\t\t\t}\n\n\t\t\t$var = {\n\t\t\t\tDir: dir,\n\t\t\t\tLeft: horzLeft,\n\t\t\t\tRight: horzRight\n\t\t\t};\n\n\t\t\tthis.GetHorzDirection(horzEdge, $var);\n\t\t\tdir = $var.Dir;\n\t\t\thorzLeft = $var.Left;\n\t\t\thorzRight = $var.Right;\n\n\t\t} //end for (;;)\n\n\t\tif (horzEdge.OutIdx >= 0 && op1 === null)\n\t\t{\n\t\t\top1 = this.GetLastOutPt(horzEdge);\n\t\t\tvar eNextHorz = this.m_SortedEdges;\n\t\t\twhile (eNextHorz !== null)\n\t\t\t{\n\t\t\t\tif (eNextHorz.OutIdx >= 0 && this.HorzSegmentsOverlap(horzEdge.Bot.X, horzEdge.Top.X, eNextHorz.Bot.X, eNextHorz.Top.X))\n\t\t\t\t{\n\t\t\t\t\tvar op2 = this.GetLastOutPt(eNextHorz);\n\t\t\t\t\tthis.AddJoin(op2, op1, eNextHorz.Top);\n\t\t\t\t}\n\t\t\t\teNextHorz = eNextHorz.NextInSEL;\n\t\t\t}\n\t\t\tthis.AddGhostJoin(op1, horzEdge.Top);\n\t\t}\n\n\t\tif (horzEdge.NextInLML !== null)\n\t\t{\n\t\t\tif (horzEdge.OutIdx >= 0)\n\t\t\t{\n\t\t\t\top1 = this.AddOutPt(horzEdge, horzEdge.Top);\n\n\t\t\t\thorzEdge = this.UpdateEdgeIntoAEL(horzEdge);\n\t\t\t\tif (horzEdge.WindDelta === 0)\n\t\t\t\t{\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t//nb: HorzEdge is no longer horizontal here\n\t\t\t\tvar ePrev = horzEdge.PrevInAEL;\n\t\t\t\tvar eNext = horzEdge.NextInAEL;\n\t\t\t\tif (ePrev !== null && ePrev.Curr.X === horzEdge.Bot.X && ePrev.Curr.Y === horzEdge.Bot.Y && ePrev.WindDelta === 0 && (ePrev.OutIdx >= 0 && ePrev.Curr.Y > ePrev.Top.Y && ClipperLib.ClipperBase.SlopesEqual3(horzEdge, ePrev)))\n\t\t\t\t{\n\t\t\t\t\tvar op2 = this.AddOutPt(ePrev, horzEdge.Bot);\n\t\t\t\t\tthis.AddJoin(op1, op2, horzEdge.Top);\n\t\t\t\t}\n\t\t\t\telse if (eNext !== null && eNext.Curr.X === horzEdge.Bot.X && eNext.Curr.Y === horzEdge.Bot.Y && eNext.WindDelta !== 0 && eNext.OutIdx >= 0 && eNext.Curr.Y > eNext.Top.Y && ClipperLib.ClipperBase.SlopesEqual3(horzEdge, eNext))\n\t\t\t\t{\n\t\t\t\t\tvar op2 = this.AddOutPt(eNext, horzEdge.Bot);\n\t\t\t\t\tthis.AddJoin(op1, op2, horzEdge.Top);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\thorzEdge = this.UpdateEdgeIntoAEL(horzEdge);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (horzEdge.OutIdx >= 0)\n\t\t\t{\n\t\t\t\tthis.AddOutPt(horzEdge, horzEdge.Top);\n\t\t\t}\n\t\t\tthis.DeleteFromAEL(horzEdge);\n\t\t}\n\t};\n\n\tClipperLib.Clipper.prototype.GetNextInAEL = function (e, Direction)\n\t{\n\t\treturn Direction === ClipperLib.Direction.dLeftToRight ? e.NextInAEL : e.PrevInAEL;\n\t};\n\n\tClipperLib.Clipper.prototype.IsMinima = function (e)\n\t{\n\t\treturn e !== null && (e.Prev.NextInLML !== e) && (e.Next.NextInLML !== e);\n\t};\n\n\tClipperLib.Clipper.prototype.IsMaxima = function (e, Y)\n\t{\n\t\treturn (e !== null && e.Top.Y === Y && e.NextInLML === null);\n\t};\n\n\tClipperLib.Clipper.prototype.IsIntermediate = function (e, Y)\n\t{\n\t\treturn (e.Top.Y === Y && e.NextInLML !== null);\n\t};\n\n\tClipperLib.Clipper.prototype.GetMaximaPair = function (e)\n\t{\n\t\tif ((ClipperLib.FPoint.op_Equality(e.Next.Top, e.Top)) && e.Next.NextInLML === null)\n\t\t{\n\t\t\treturn e.Next;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif ((ClipperLib.FPoint.op_Equality(e.Prev.Top, e.Top)) && e.Prev.NextInLML === null)\n\t\t\t{\n\t\t\t\treturn e.Prev;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t};\n\n\tClipperLib.Clipper.prototype.GetMaximaPairEx = function (e)\n\t{\n\t\t//as above but returns null if MaxPair isn't in AEL (unless it's horizontal)\n\t\tvar result = this.GetMaximaPair(e);\n\t\tif (result === null || result.OutIdx === ClipperLib.ClipperBase.Skip ||\n\t\t\t((result.NextInAEL === result.PrevInAEL) && !ClipperLib.ClipperBase.IsHorizontal(result)))\n\t\t{\n\t\t\treturn null;\n\t\t}\n\t\treturn result;\n\t};\n\n\tClipperLib.Clipper.prototype.ProcessIntersections = function (topY)\n\t{\n\t\tif (this.m_ActiveEdges === null)\n\t\t\treturn true;\n\t\ttry\n\t\t{\n\t\t\tthis.BuildIntersectList(topY);\n\t\t\tif (this.m_IntersectList.length === 0)\n\t\t\t\treturn true;\n\t\t\tif (this.m_IntersectList.length === 1 || this.FixupIntersectionOrder())\n\t\t\t\tthis.ProcessIntersectList();\n\t\t\telse\n\t\t\t\treturn false;\n\t\t}\n\t\tcatch ($$e2)\n\t\t{\n\t\t\tthis.m_SortedEdges = null;\n\t\t\tthis.m_IntersectList.length = 0;\n\t\t\tClipperLib.Error(\"ProcessIntersections error\");\n\t\t}\n\t\tthis.m_SortedEdges = null;\n\t\treturn true;\n\t};\n\n\tClipperLib.Clipper.prototype.BuildIntersectList = function (topY)\n\t{\n\t\tif (this.m_ActiveEdges === null)\n\t\t\treturn;\n\t\t//prepare for sorting ...\n\t\tvar e = this.m_ActiveEdges;\n\t\t//console.log(JSON.stringify(JSON.decycle( e )));\n\t\tthis.m_SortedEdges = e;\n\t\twhile (e !== null)\n\t\t{\n\t\t\te.PrevInSEL = e.PrevInAEL;\n\t\t\te.NextInSEL = e.NextInAEL;\n\t\t\te.Curr.X = ClipperLib.Clipper.TopX(e, topY);\n\t\t\te = e.NextInAEL;\n\t\t}\n\t\t//bubblesort ...\n\t\tvar isModified = true;\n\t\twhile (isModified && this.m_SortedEdges !== null)\n\t\t{\n\t\t\tisModified = false;\n\t\t\te = this.m_SortedEdges;\n\t\t\twhile (e.NextInSEL !== null)\n\t\t\t{\n\t\t\t\tvar eNext = e.NextInSEL;\n\t\t\t\tvar pt = new ClipperLib.FPoint0();\n\t\t\t\t//console.log(\"e.Curr.X: \" + e.Curr.X + \" eNext.Curr.X\" + eNext.Curr.X);\n\t\t\t\tif (e.Curr.X > eNext.Curr.X)\n\t\t\t\t{\n\t\t\t\t\tthis.IntersectPoint(e, eNext, pt);\n\t\t\t\t\tif (pt.Y < topY)\n\t\t\t\t\t{\n\t\t\t\t\t\tpt = new ClipperLib.FPoint2(ClipperLib.Clipper.TopX(e, topY), topY);\n\t\t\t\t\t}\n\t\t\t\t\tvar newNode = new ClipperLib.IntersectNode();\n\t\t\t\t\tnewNode.Edge1 = e;\n\t\t\t\t\tnewNode.Edge2 = eNext;\n\t\t\t\t\t//newNode.Pt = pt;\n\t\t\t\t\tnewNode.Pt.X = pt.X;\n\t\t\t\t\tnewNode.Pt.Y = pt.Y;\n\t\t\t\t\tif (ClipperLib.use_xyz) newNode.Pt.Z = pt.Z;\n\t\t\t\t\tthis.m_IntersectList.push(newNode);\n\t\t\t\t\tthis.SwapPositionsInSEL(e, eNext);\n\t\t\t\t\tisModified = true;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\te = eNext;\n\t\t\t}\n\t\t\tif (e.PrevInSEL !== null)\n\t\t\t\te.PrevInSEL.NextInSEL = null;\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\t\tthis.m_SortedEdges = null;\n\t};\n\n\tClipperLib.Clipper.prototype.EdgesAdjacent = function (inode)\n\t{\n\t\treturn (inode.Edge1.NextInSEL === inode.Edge2) || (inode.Edge1.PrevInSEL === inode.Edge2);\n\t};\n\n\tClipperLib.Clipper.IntersectNodeSort = function (node1, node2)\n\t{\n\t\t//the following typecast is safe because the differences in Pt.Y will\n\t\t//be limited to the height of the scanbeam.\n\t\treturn (node2.Pt.Y - node1.Pt.Y);\n\t};\n\n\tClipperLib.Clipper.prototype.FixupIntersectionOrder = function ()\n\t{\n\t\t//pre-condition: intersections are sorted bottom-most first.\n\t\t//Now it's crucial that intersections are made only between adjacent edges,\n\t\t//so to ensure this the order of intersections may need adjusting ...\n\t\tthis.m_IntersectList.sort(this.m_IntersectNodeComparer);\n\t\tthis.CopyAELToSEL();\n\t\tvar cnt = this.m_IntersectList.length;\n\t\tfor (var i = 0; i < cnt; i++)\n\t\t{\n\t\t\tif (!this.EdgesAdjacent(this.m_IntersectList[i]))\n\t\t\t{\n\t\t\t\tvar j = i + 1;\n\t\t\t\twhile (j < cnt && !this.EdgesAdjacent(this.m_IntersectList[j]))\n\t\t\t\t\tj++;\n\t\t\t\tif (j === cnt)\n\t\t\t\t\treturn false;\n\t\t\t\tvar tmp = this.m_IntersectList[i];\n\t\t\t\tthis.m_IntersectList[i] = this.m_IntersectList[j];\n\t\t\t\tthis.m_IntersectList[j] = tmp;\n\t\t\t}\n\t\t\tthis.SwapPositionsInSEL(this.m_IntersectList[i].Edge1, this.m_IntersectList[i].Edge2);\n\t\t}\n\t\treturn true;\n\t};\n\n\tClipperLib.Clipper.prototype.ProcessIntersectList = function ()\n\t{\n\t\tfor (var i = 0, ilen = this.m_IntersectList.length; i < ilen; i++)\n\t\t{\n\t\t\tvar iNode = this.m_IntersectList[i];\n\t\t\tthis.IntersectEdges(iNode.Edge1, iNode.Edge2, iNode.Pt);\n\t\t\tthis.SwapPositionsInAEL(iNode.Edge1, iNode.Edge2);\n\t\t}\n\t\tthis.m_IntersectList.length = 0;\n\t};\n\n\tClipperLib.Clipper.TopX = function (edge, currentY)\n\t{\n\t\t//if (edge.Bot == edge.Curr) alert (\"edge.Bot = edge.Curr\");\n\t\t//if (edge.Bot == edge.Top) alert (\"edge.Bot = edge.Top\");\n\t\tif (currentY === edge.Top.Y)\n\t\t\treturn edge.Top.X;\n\t\treturn edge.Bot.X + edge.Dx * (currentY - edge.Bot.Y);\n\t};\n\n\tClipperLib.Clipper.prototype.IntersectPoint = function (edge1, edge2, ip)\n\t{\n\t\tip.X = 0;\n\t\tip.Y = 0;\n\t\tvar b1, b2;\n\t\t//nb: with very large coordinate values, it's possible for SlopesEqual() to\n\t\t//return false but for the edge.Dx value be equal due to double precision rounding.\n\t\tif (edge1.Dx === edge2.Dx)\n\t\t{\n\t\t\tip.Y = edge1.Curr.Y;\n\t\t\tip.X = ClipperLib.Clipper.TopX(edge1, ip.Y);\n\t\t\treturn;\n\t\t}\n\t\tif (edge1.Delta.X === 0)\n\t\t{\n\t\t\tip.X = edge1.Bot.X;\n\t\t\tif (ClipperLib.ClipperBase.IsHorizontal(edge2))\n\t\t\t{\n\t\t\t\tip.Y = edge2.Bot.Y;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tb2 = edge2.Bot.Y - (edge2.Bot.X / edge2.Dx);\n\t\t\t\tip.Y = ip.X / edge2.Dx + b2;\n\t\t\t}\n\t\t}\n\t\telse if (edge2.Delta.X === 0)\n\t\t{\n\t\t\tip.X = edge2.Bot.X;\n\t\t\tif (ClipperLib.ClipperBase.IsHorizontal(edge1))\n\t\t\t{\n\t\t\t\tip.Y = edge1.Bot.Y;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tb1 = edge1.Bot.Y - (edge1.Bot.X / edge1.Dx);\n\t\t\t\tip.Y = ip.X / edge1.Dx + b1;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tb1 = edge1.Bot.X - edge1.Bot.Y * edge1.Dx;\n\t\t\tb2 = edge2.Bot.X - edge2.Bot.Y * edge2.Dx;\n\t\t\tvar q = (b2 - b1) / (edge1.Dx - edge2.Dx);\n\t\t\tip.Y = q;\n\t\t\tif (Math.abs(edge1.Dx) < Math.abs(edge2.Dx))\n\t\t\t\tip.X = edge1.Dx * q + b1;\n\t\t\telse\n\t\t\t\tip.X = edge2.Dx * q + b2;\n\t\t}\n\t\tif (ip.Y < edge1.Top.Y || ip.Y < edge2.Top.Y)\n\t\t{\n\t\t\tif (edge1.Top.Y > edge2.Top.Y)\n\t\t\t{\n\t\t\t\tip.Y = edge1.Top.Y;\n\t\t\t\tip.X = ClipperLib.Clipper.TopX(edge2, edge1.Top.Y);\n\t\t\t\treturn ip.X < edge1.Top.X;\n\t\t\t}\n\t\t\telse\n\t\t\t\tip.Y = edge2.Top.Y;\n\t\t\tif (Math.abs(edge1.Dx) < Math.abs(edge2.Dx))\n\t\t\t\tip.X = ClipperLib.Clipper.TopX(edge1, ip.Y);\n\t\t\telse\n\t\t\t\tip.X = ClipperLib.Clipper.TopX(edge2, ip.Y);\n\t\t}\n\t\t//finally, don't allow 'ip' to be BELOW curr.Y (ie bottom of scanbeam) ...\n\t\tif (ip.Y > edge1.Curr.Y)\n\t\t{\n\t\t\tip.Y = edge1.Curr.Y;\n\t\t\t//better to use the more vertical edge to derive X ...\n\t\t\tif (Math.abs(edge1.Dx) > Math.abs(edge2.Dx))\n\t\t\t\tip.X = ClipperLib.Clipper.TopX(edge2, ip.Y);\n\t\t\telse\n\t\t\t\tip.X = ClipperLib.Clipper.TopX(edge1, ip.Y);\n\t\t}\n\t};\n\n\tClipperLib.Clipper.prototype.ProcessEdgesAtTopOfScanbeam = function (topY)\n\t{\n\t\tvar e = this.m_ActiveEdges;\n\n\t\twhile (e !== null)\n\t\t{\n\t\t\t//1. process maxima, treating them as if they're 'bent' horizontal edges,\n\t\t\t//   but exclude maxima with horizontal edges. nb: e can't be a horizontal.\n\t\t\tvar IsMaximaEdge = this.IsMaxima(e, topY);\n\t\t\tif (IsMaximaEdge)\n\t\t\t{\n\t\t\t\tvar eMaxPair = this.GetMaximaPairEx(e);\n\t\t\t\tIsMaximaEdge = (eMaxPair === null || !ClipperLib.ClipperBase.IsHorizontal(eMaxPair));\n\t\t\t}\n\t\t\tif (IsMaximaEdge)\n\t\t\t{\n\t\t\t\tif (this.StrictlySimple)\n\t\t\t\t{\n\t\t\t\t\tthis.InsertMaxima(e.Top.X);\n\t\t\t\t}\n\t\t\t\tvar ePrev = e.PrevInAEL;\n\t\t\t\tthis.DoMaxima(e);\n\t\t\t\tif (ePrev === null)\n\t\t\t\t\te = this.m_ActiveEdges;\n\t\t\t\telse\n\t\t\t\t\te = ePrev.NextInAEL;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t//2. promote horizontal edges, otherwise update Curr.X and Curr.Y ...\n\t\t\t\tif (this.IsIntermediate(e, topY) && ClipperLib.ClipperBase.IsHorizontal(e.NextInLML))\n\t\t\t\t{\n\t\t\t\t\te = this.UpdateEdgeIntoAEL(e);\n\t\t\t\t\tif (e.OutIdx >= 0)\n\t\t\t\t\t\tthis.AddOutPt(e, e.Bot);\n\t\t\t\t\tthis.AddEdgeToSEL(e);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\te.Curr.X = ClipperLib.Clipper.TopX(e, topY);\n\t\t\t\t\te.Curr.Y = topY;\n\t\t\t\t}\n\n\t\t\t\tif (ClipperLib.use_xyz)\n\t\t\t\t{\n\t\t\t\t\tif (e.Top.Y === topY) e.Curr.Z = e.Top.Z;\n\t\t\t\t\telse if (e.Bot.Y === topY) e.Curr.Z = e.Bot.Z;\n\t\t\t\t\telse e.Curr.Z = 0;\n\t\t\t\t}\n\n\t\t\t\t//When StrictlySimple and 'e' is being touched by another edge, then\n\t\t\t\t//make sure both edges have a vertex here ...\n\t\t\t\tif (this.StrictlySimple)\n\t\t\t\t{\n\t\t\t\t\tvar ePrev = e.PrevInAEL;\n\t\t\t\t\tif ((e.OutIdx >= 0) && (e.WindDelta !== 0) && ePrev !== null &&\n\t\t\t\t\t\t(ePrev.OutIdx >= 0) && (ePrev.Curr.X === e.Curr.X) &&\n\t\t\t\t\t\t(ePrev.WindDelta !== 0))\n\t\t\t\t\t{\n\t\t\t\t\t\tvar ip = new ClipperLib.FPoint1(e.Curr);\n\n\t\t\t\t\t\tif (ClipperLib.use_xyz)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tthis.SetZ(ip, ePrev, e);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvar op = this.AddOutPt(ePrev, ip);\n\t\t\t\t\t\tvar op2 = this.AddOutPt(e, ip);\n\t\t\t\t\t\tthis.AddJoin(op, op2, ip); //StrictlySimple (type-3) join\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\te = e.NextInAEL;\n\t\t\t}\n\t\t}\n\t\t//3. Process horizontals at the Top of the scanbeam ...\n\t\tthis.ProcessHorizontals();\n\t\tthis.m_Maxima = null;\n\t\t//4. Promote intermediate vertices ...\n\t\te = this.m_ActiveEdges;\n\t\twhile (e !== null)\n\t\t{\n\t\t\tif (this.IsIntermediate(e, topY))\n\t\t\t{\n\t\t\t\tvar op = null;\n\t\t\t\tif (e.OutIdx >= 0)\n\t\t\t\t\top = this.AddOutPt(e, e.Top);\n\t\t\t\te = this.UpdateEdgeIntoAEL(e);\n\t\t\t\t//if output polygons share an edge, they'll need joining later ...\n\t\t\t\tvar ePrev = e.PrevInAEL;\n\t\t\t\tvar eNext = e.NextInAEL;\n\n\t\t\t\tif (ePrev !== null && ePrev.Curr.X === e.Bot.X && ePrev.Curr.Y === e.Bot.Y && op !== null && ePrev.OutIdx >= 0 && ePrev.Curr.Y === ePrev.Top.Y && ClipperLib.ClipperBase.SlopesEqual5(e.Curr, e.Top, ePrev.Curr, ePrev.Top) && (e.WindDelta !== 0) && (ePrev.WindDelta !== 0))\n\t\t\t\t{\n\t\t\t\t\tvar op2 = this.AddOutPt(ePrev2, e.Bot);\n\t\t\t\t\tthis.AddJoin(op, op2, e.Top);\n\t\t\t\t}\n\t\t\t\telse if (eNext !== null && eNext.Curr.X === e.Bot.X && eNext.Curr.Y === e.Bot.Y && op !== null && eNext.OutIdx >= 0 && eNext.Curr.Y === eNext.Top.Y && ClipperLib.ClipperBase.SlopesEqual5(e.Curr, e.Top, eNext.Curr, eNext.Top) && (e.WindDelta !== 0) && (eNext.WindDelta !== 0))\n\t\t\t\t{\n\t\t\t\t\tvar op2 = this.AddOutPt(eNext, e.Bot);\n\t\t\t\t\tthis.AddJoin(op, op2, e.Top);\n\t\t\t\t}\n\t\t\t}\n\t\t\te = e.NextInAEL;\n\t\t}\n\t};\n\n\tClipperLib.Clipper.prototype.DoMaxima = function (e)\n\t{\n\t\tvar eMaxPair = this.GetMaximaPairEx(e);\n\t\tif (eMaxPair === null)\n\t\t{\n\t\t\tif (e.OutIdx >= 0)\n\t\t\t\tthis.AddOutPt(e, e.Top);\n\t\t\tthis.DeleteFromAEL(e);\n\t\t\treturn;\n\t\t}\n\t\tvar eNext = e.NextInAEL;\n\t\twhile (eNext !== null && eNext !== eMaxPair)\n\t\t{\n\t\t\tthis.IntersectEdges(e, eNext, e.Top);\n\t\t\tthis.SwapPositionsInAEL(e, eNext);\n\t\t\teNext = e.NextInAEL;\n\t\t}\n\t\tif (e.OutIdx === -1 && eMaxPair.OutIdx === -1)\n\t\t{\n\t\t\tthis.DeleteFromAEL(e);\n\t\t\tthis.DeleteFromAEL(eMaxPair);\n\t\t}\n\t\telse if (e.OutIdx >= 0 && eMaxPair.OutIdx >= 0)\n\t\t{\n\t\t\tif (e.OutIdx >= 0) this.AddLocalMaxPoly(e, eMaxPair, e.Top);\n\t\t\tthis.DeleteFromAEL(e);\n\t\t\tthis.DeleteFromAEL(eMaxPair);\n\t\t}\n\t\telse if (ClipperLib.use_lines && e.WindDelta === 0)\n\t\t{\n\t\t\tif (e.OutIdx >= 0)\n\t\t\t{\n\t\t\t\tthis.AddOutPt(e, e.Top);\n\t\t\t\te.OutIdx = ClipperLib.ClipperBase.Unassigned;\n\t\t\t}\n\t\t\tthis.DeleteFromAEL(e);\n\t\t\tif (eMaxPair.OutIdx >= 0)\n\t\t\t{\n\t\t\t\tthis.AddOutPt(eMaxPair, e.Top);\n\t\t\t\teMaxPair.OutIdx = ClipperLib.ClipperBase.Unassigned;\n\t\t\t}\n\t\t\tthis.DeleteFromAEL(eMaxPair);\n\t\t}\n\t\telse\n\t\t\tClipperLib.Error(\"DoMaxima error\");\n\t};\n\n\tClipperLib.Clipper.ReversePaths = function (polys)\n\t{\n\t\tfor (var i = 0, len = polys.length; i < len; i++)\n\t\t\tpolys[i].reverse();\n\t};\n\n\tClipperLib.Clipper.Orientation = function (poly)\n\t{\n\t\treturn ClipperLib.Clipper.Area(poly) >= 0;\n\t};\n\n\tClipperLib.Clipper.prototype.PointCount = function (pts)\n\t{\n\t\tif (pts === null)\n\t\t\treturn 0;\n\t\tvar result = 0;\n\t\tvar p = pts;\n\t\tdo {\n\t\t\tresult++;\n\t\t\tp = p.Next;\n\t\t}\n\t\twhile (p !== pts)\n\t\treturn result;\n\t};\n\n\tClipperLib.Clipper.prototype.BuildResult = function (polyg)\n\t{\n\t\tClipperLib.Clear(polyg);\n\t\tfor (var i = 0, ilen = this.m_PolyOuts.length; i < ilen; i++)\n\t\t{\n\t\t\tvar outRec = this.m_PolyOuts[i];\n\t\t\tif (outRec.Pts === null)\n\t\t\t\tcontinue;\n\t\t\tvar p = outRec.Pts.Prev;\n\t\t\tvar cnt = this.PointCount(p);\n\t\t\tif (cnt < 2)\n\t\t\t\tcontinue;\n\t\t\tvar pg = new Array(cnt);\n\t\t\tfor (var j = 0; j < cnt; j++)\n\t\t\t{\n\t\t\t\tpg[j] = p.Pt;\n\t\t\t\tp = p.Prev;\n\t\t\t}\n\t\t\tpolyg.push(pg);\n\t\t}\n\t};\n\n\tClipperLib.Clipper.prototype.BuildResult2 = function (polytree)\n\t{\n\t\tpolytree.Clear();\n\t\t//add each output polygon/contour to polytree ...\n\t\t//polytree.m_AllPolys.set_Capacity(this.m_PolyOuts.length);\n\t\tfor (var i = 0, ilen = this.m_PolyOuts.length; i < ilen; i++)\n\t\t{\n\t\t\tvar outRec = this.m_PolyOuts[i];\n\t\t\tvar cnt = this.PointCount(outRec.Pts);\n\t\t\tif ((outRec.IsOpen && cnt < 2) || (!outRec.IsOpen && cnt < 3))\n\t\t\t\tcontinue;\n\t\t\tthis.FixHoleLinkage(outRec);\n\t\t\tvar pn = new ClipperLib.PolyNode();\n\t\t\tpolytree.m_AllPolys.push(pn);\n\t\t\toutRec.PolyNode = pn;\n\t\t\tpn.m_polygon.length = cnt;\n\t\t\tvar op = outRec.Pts.Prev;\n\t\t\tfor (var j = 0; j < cnt; j++)\n\t\t\t{\n\t\t\t\tpn.m_polygon[j] = op.Pt;\n\t\t\t\top = op.Prev;\n\t\t\t}\n\t\t}\n\t\t//fixup PolyNode links etc ...\n\t\t//polytree.m_Childs.set_Capacity(this.m_PolyOuts.length);\n\t\tfor (var i = 0, ilen = this.m_PolyOuts.length; i < ilen; i++)\n\t\t{\n\t\t\tvar outRec = this.m_PolyOuts[i];\n\t\t\tif (outRec.PolyNode === null)\n\t\t\t\tcontinue;\n\t\t\telse if (outRec.IsOpen)\n\t\t\t{\n\t\t\t\toutRec.PolyNode.IsOpen = true;\n\t\t\t\tpolytree.AddChild(outRec.PolyNode);\n\t\t\t}\n\t\t\telse if (outRec.FirstLeft !== null && outRec.FirstLeft.PolyNode !== null)\n\t\t\t\toutRec.FirstLeft.PolyNode.AddChild(outRec.PolyNode);\n\t\t\telse\n\t\t\t\tpolytree.AddChild(outRec.PolyNode);\n\t\t}\n\t};\n\n\tClipperLib.Clipper.prototype.FixupOutPolyline = function (outRec)\n\t{\n\t\tvar pp = outRec.Pts;\n\t\tvar lastPP = pp.Prev;\n\t\twhile (pp !== lastPP)\n\t\t{\n\t\t\tpp = pp.Next;\n\t\t\tif (ClipperLib.FPoint.op_Equality(pp.Pt, pp.Prev.Pt))\n\t\t\t{\n\t\t\t\tif (pp === lastPP)\n\t\t\t\t{\n\t\t\t\t\tlastPP = pp.Prev;\n\t\t\t\t}\n\t\t\t\tvar tmpPP = pp.Prev;\n\t\t\t\ttmpPP.Next = pp.Next;\n\t\t\t\tpp.Next.Prev = tmpPP;\n\t\t\t\tpp = tmpPP;\n\t\t\t}\n\t\t}\n\t\tif (pp === pp.Prev)\n\t\t{\n\t\t\toutRec.Pts = null;\n\t\t}\n\t};\n\n\tClipperLib.Clipper.prototype.FixupOutPolygon = function (outRec)\n\t{\n\t\t//FixupOutPolygon() - removes duplicate points and simplifies consecutive\n\t\t//parallel edges by removing the middle vertex.\n\t\tvar lastOK = null;\n\t\toutRec.BottomPt = null;\n\t\tvar pp = outRec.Pts;\n\t\tvar preserveCol = this.PreserveCollinear || this.StrictlySimple;\n\t\tfor (;;)\n\t\t{\n\t\t\tif (pp.Prev === pp || pp.Prev === pp.Next)\n\t\t\t{\n\t\t\t\toutRec.Pts = null;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t//test for duplicate points and collinear edges ...\n\t\t\tif ((ClipperLib.FPoint.op_Equality(pp.Pt, pp.Next.Pt)) || (ClipperLib.FPoint.op_Equality(pp.Pt, pp.Prev.Pt)) || (ClipperLib.ClipperBase.SlopesEqual4(pp.Prev.Pt, pp.Pt, pp.Next.Pt) && (!preserveCol || !this.Pt2IsBetweenPt1AndPt3(pp.Prev.Pt, pp.Pt, pp.Next.Pt))))\n\t\t\t{\n\t\t\t\tlastOK = null;\n\t\t\t\tpp.Prev.Next = pp.Next;\n\t\t\t\tpp.Next.Prev = pp.Prev;\n\t\t\t\tpp = pp.Prev;\n\t\t\t}\n\t\t\telse if (pp === lastOK)\n\t\t\t\tbreak;\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (lastOK === null)\n\t\t\t\t\tlastOK = pp;\n\t\t\t\tpp = pp.Next;\n\t\t\t}\n\t\t}\n\t\toutRec.Pts = pp;\n\t};\n\n\tClipperLib.Clipper.prototype.DupOutPt = function (outPt, InsertAfter)\n\t{\n\t\tvar result = new ClipperLib.OutPt();\n\t\t//result.Pt = outPt.Pt;\n\t\tresult.Pt.X = outPt.Pt.X;\n\t\tresult.Pt.Y = outPt.Pt.Y;\n\t\tif (ClipperLib.use_xyz) result.Pt.Z = outPt.Pt.Z;\n\t\tresult.Idx = outPt.Idx;\n\t\tif (InsertAfter)\n\t\t{\n\t\t\tresult.Next = outPt.Next;\n\t\t\tresult.Prev = outPt;\n\t\t\toutPt.Next.Prev = result;\n\t\t\toutPt.Next = result;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tresult.Prev = outPt.Prev;\n\t\t\tresult.Next = outPt;\n\t\t\toutPt.Prev.Next = result;\n\t\t\toutPt.Prev = result;\n\t\t}\n\t\treturn result;\n\t};\n\n\tClipperLib.Clipper.prototype.GetOverlap = function (a1, a2, b1, b2, $val)\n\t{\n\t\tif (a1 < a2)\n\t\t{\n\t\t\tif (b1 < b2)\n\t\t\t{\n\t\t\t\t$val.Left = Math.max(a1, b1);\n\t\t\t\t$val.Right = Math.min(a2, b2);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t$val.Left = Math.max(a1, b2);\n\t\t\t\t$val.Right = Math.min(a2, b1);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (b1 < b2)\n\t\t\t{\n\t\t\t\t$val.Left = Math.max(a2, b1);\n\t\t\t\t$val.Right = Math.min(a1, b2);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t$val.Left = Math.max(a2, b2);\n\t\t\t\t$val.Right = Math.min(a1, b1);\n\t\t\t}\n\t\t}\n\t\treturn $val.Left < $val.Right;\n\t};\n\n\tClipperLib.Clipper.prototype.JoinHorz = function (op1, op1b, op2, op2b, Pt, DiscardLeft)\n\t{\n\t\tvar Dir1 = (op1.Pt.X > op1b.Pt.X ? ClipperLib.Direction.dRightToLeft : ClipperLib.Direction.dLeftToRight);\n\t\tvar Dir2 = (op2.Pt.X > op2b.Pt.X ? ClipperLib.Direction.dRightToLeft : ClipperLib.Direction.dLeftToRight);\n\t\tif (Dir1 === Dir2)\n\t\t\treturn false;\n\t\t//When DiscardLeft, we want Op1b to be on the Left of Op1, otherwise we\n\t\t//want Op1b to be on the Right. (And likewise with Op2 and Op2b.)\n\t\t//So, to facilitate this while inserting Op1b and Op2b ...\n\t\t//when DiscardLeft, make sure we're AT or RIGHT of Pt before adding Op1b,\n\t\t//otherwise make sure we're AT or LEFT of Pt. (Likewise with Op2b.)\n\t\tif (Dir1 === ClipperLib.Direction.dLeftToRight)\n\t\t{\n\t\t\twhile (op1.Next.Pt.X <= Pt.X &&\n\t\t\t\top1.Next.Pt.X >= op1.Pt.X && op1.Next.Pt.Y === Pt.Y)\n\t\t\t\top1 = op1.Next;\n\t\t\tif (DiscardLeft && (op1.Pt.X !== Pt.X))\n\t\t\t\top1 = op1.Next;\n\t\t\top1b = this.DupOutPt(op1, !DiscardLeft);\n\t\t\tif (ClipperLib.FPoint.op_Inequality(op1b.Pt, Pt))\n\t\t\t{\n\t\t\t\top1 = op1b;\n\t\t\t\t//op1.Pt = Pt;\n\t\t\t\top1.Pt.X = Pt.X;\n\t\t\t\top1.Pt.Y = Pt.Y;\n\t\t\t\tif (ClipperLib.use_xyz) op1.Pt.Z = Pt.Z;\n\t\t\t\top1b = this.DupOutPt(op1, !DiscardLeft);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\twhile (op1.Next.Pt.X >= Pt.X &&\n\t\t\t\top1.Next.Pt.X <= op1.Pt.X && op1.Next.Pt.Y === Pt.Y)\n\t\t\t\top1 = op1.Next;\n\t\t\tif (!DiscardLeft && (op1.Pt.X !== Pt.X))\n\t\t\t\top1 = op1.Next;\n\t\t\top1b = this.DupOutPt(op1, DiscardLeft);\n\t\t\tif (ClipperLib.FPoint.op_Inequality(op1b.Pt, Pt))\n\t\t\t{\n\t\t\t\top1 = op1b;\n\t\t\t\t//op1.Pt = Pt;\n\t\t\t\top1.Pt.X = Pt.X;\n\t\t\t\top1.Pt.Y = Pt.Y;\n\t\t\t\tif (ClipperLib.use_xyz) op1.Pt.Z = Pt.Z;\n\t\t\t\top1b = this.DupOutPt(op1, DiscardLeft);\n\t\t\t}\n\t\t}\n\t\tif (Dir2 === ClipperLib.Direction.dLeftToRight)\n\t\t{\n\t\t\twhile (op2.Next.Pt.X <= Pt.X &&\n\t\t\t\top2.Next.Pt.X >= op2.Pt.X && op2.Next.Pt.Y === Pt.Y)\n\t\t\t\top2 = op2.Next;\n\t\t\tif (DiscardLeft && (op2.Pt.X !== Pt.X))\n\t\t\t\top2 = op2.Next;\n\t\t\top2b = this.DupOutPt(op2, !DiscardLeft);\n\t\t\tif (ClipperLib.FPoint.op_Inequality(op2b.Pt, Pt))\n\t\t\t{\n\t\t\t\top2 = op2b;\n\t\t\t\t//op2.Pt = Pt;\n\t\t\t\top2.Pt.X = Pt.X;\n\t\t\t\top2.Pt.Y = Pt.Y;\n\t\t\t\tif (ClipperLib.use_xyz) op2.Pt.Z = Pt.Z;\n\t\t\t\top2b = this.DupOutPt(op2, !DiscardLeft);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\twhile (op2.Next.Pt.X >= Pt.X &&\n\t\t\t\top2.Next.Pt.X <= op2.Pt.X && op2.Next.Pt.Y === Pt.Y)\n\t\t\t\top2 = op2.Next;\n\t\t\tif (!DiscardLeft && (op2.Pt.X !== Pt.X))\n\t\t\t\top2 = op2.Next;\n\t\t\top2b = this.DupOutPt(op2, DiscardLeft);\n\t\t\tif (ClipperLib.FPoint.op_Inequality(op2b.Pt, Pt))\n\t\t\t{\n\t\t\t\top2 = op2b;\n\t\t\t\t//op2.Pt = Pt;\n\t\t\t\top2.Pt.X = Pt.X;\n\t\t\t\top2.Pt.Y = Pt.Y;\n\t\t\t\tif (ClipperLib.use_xyz) op2.Pt.Z = Pt.Z;\n\t\t\t\top2b = this.DupOutPt(op2, DiscardLeft);\n\t\t\t}\n\t\t}\n\t\tif ((Dir1 === ClipperLib.Direction.dLeftToRight) === DiscardLeft)\n\t\t{\n\t\t\top1.Prev = op2;\n\t\t\top2.Next = op1;\n\t\t\top1b.Next = op2b;\n\t\t\top2b.Prev = op1b;\n\t\t}\n\t\telse\n\t\t{\n\t\t\top1.Next = op2;\n\t\t\top2.Prev = op1;\n\t\t\top1b.Prev = op2b;\n\t\t\top2b.Next = op1b;\n\t\t}\n\t\treturn true;\n\t};\n\n\tClipperLib.Clipper.prototype.JoinPoints = function (j, outRec1, outRec2)\n\t{\n\t\tvar op1 = j.OutPt1,\n\t\t\top1b = new ClipperLib.OutPt();\n\t\tvar op2 = j.OutPt2,\n\t\t\top2b = new ClipperLib.OutPt();\n\t\t//There are 3 kinds of joins for output polygons ...\n\t\t//1. Horizontal joins where Join.OutPt1 & Join.OutPt2 are vertices anywhere\n\t\t//along (horizontal) collinear edges (& Join.OffPt is on the same horizontal).\n\t\t//2. Non-horizontal joins where Join.OutPt1 & Join.OutPt2 are at the same\n\t\t//location at the Bottom of the overlapping segment (& Join.OffPt is above).\n\t\t//3. StrictlySimple joins where edges touch but are not collinear and where\n\t\t//Join.OutPt1, Join.OutPt2 & Join.OffPt all share the same point.\n\t\tvar isHorizontal = (j.OutPt1.Pt.Y === j.OffPt.Y);\n\t\tif (isHorizontal && (ClipperLib.FPoint.op_Equality(j.OffPt, j.OutPt1.Pt)) && (ClipperLib.FPoint.op_Equality(j.OffPt, j.OutPt2.Pt)))\n\t\t{\n\t\t\t//Strictly Simple join ...\n\t\t\tif (outRec1 !== outRec2) return false;\n\n\t\t\top1b = j.OutPt1.Next;\n\t\t\twhile (op1b !== op1 && (ClipperLib.FPoint.op_Equality(op1b.Pt, j.OffPt)))\n\t\t\t\top1b = op1b.Next;\n\t\t\tvar reverse1 = (op1b.Pt.Y > j.OffPt.Y);\n\t\t\top2b = j.OutPt2.Next;\n\t\t\twhile (op2b !== op2 && (ClipperLib.FPoint.op_Equality(op2b.Pt, j.OffPt)))\n\t\t\t\top2b = op2b.Next;\n\t\t\tvar reverse2 = (op2b.Pt.Y > j.OffPt.Y);\n\t\t\tif (reverse1 === reverse2)\n\t\t\t\treturn false;\n\t\t\tif (reverse1)\n\t\t\t{\n\t\t\t\top1b = this.DupOutPt(op1, false);\n\t\t\t\top2b = this.DupOutPt(op2, true);\n\t\t\t\top1.Prev = op2;\n\t\t\t\top2.Next = op1;\n\t\t\t\top1b.Next = op2b;\n\t\t\t\top2b.Prev = op1b;\n\t\t\t\tj.OutPt1 = op1;\n\t\t\t\tj.OutPt2 = op1b;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\top1b = this.DupOutPt(op1, true);\n\t\t\t\top2b = this.DupOutPt(op2, false);\n\t\t\t\top1.Next = op2;\n\t\t\t\top2.Prev = op1;\n\t\t\t\top1b.Prev = op2b;\n\t\t\t\top2b.Next = op1b;\n\t\t\t\tj.OutPt1 = op1;\n\t\t\t\tj.OutPt2 = op1b;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\telse if (isHorizontal)\n\t\t{\n\t\t\t//treat horizontal joins differently to non-horizontal joins since with\n\t\t\t//them we're not yet sure where the overlapping is. OutPt1.Pt & OutPt2.Pt\n\t\t\t//may be anywhere along the horizontal edge.\n\t\t\top1b = op1;\n\t\t\twhile (op1.Prev.Pt.Y === op1.Pt.Y && op1.Prev !== op1b && op1.Prev !== op2)\n\t\t\t\top1 = op1.Prev;\n\t\t\twhile (op1b.Next.Pt.Y === op1b.Pt.Y && op1b.Next !== op1 && op1b.Next !== op2)\n\t\t\t\top1b = op1b.Next;\n\t\t\tif (op1b.Next === op1 || op1b.Next === op2)\n\t\t\t\treturn false;\n\t\t\t//a flat 'polygon'\n\t\t\top2b = op2;\n\t\t\twhile (op2.Prev.Pt.Y === op2.Pt.Y && op2.Prev !== op2b && op2.Prev !== op1b)\n\t\t\t\top2 = op2.Prev;\n\t\t\twhile (op2b.Next.Pt.Y === op2b.Pt.Y && op2b.Next !== op2 && op2b.Next !== op1)\n\t\t\t\top2b = op2b.Next;\n\t\t\tif (op2b.Next === op2 || op2b.Next === op1)\n\t\t\t\treturn false;\n\t\t\t//a flat 'polygon'\n\t\t\t//Op1 -. Op1b & Op2 -. Op2b are the extremites of the horizontal edges\n\n\t\t\tvar $val = {\n\t\t\t\tLeft: null,\n\t\t\t\tRight: null\n\t\t\t};\n\n\t\t\tif (!this.GetOverlap(op1.Pt.X, op1b.Pt.X, op2.Pt.X, op2b.Pt.X, $val))\n\t\t\t\treturn false;\n\t\t\tvar Left = $val.Left;\n\t\t\tvar Right = $val.Right;\n\n\t\t\t//DiscardLeftSide: when overlapping edges are joined, a spike will created\n\t\t\t//which needs to be cleaned up. However, we don't want Op1 or Op2 caught up\n\t\t\t//on the discard Side as either may still be needed for other joins ...\n\t\t\tvar Pt = new ClipperLib.FPoint0();\n\t\t\tvar DiscardLeftSide;\n\t\t\tif (op1.Pt.X >= Left && op1.Pt.X <= Right)\n\t\t\t{\n\t\t\t\t//Pt = op1.Pt;\n\t\t\t\tPt.X = op1.Pt.X;\n\t\t\t\tPt.Y = op1.Pt.Y;\n\t\t\t\tif (ClipperLib.use_xyz) Pt.Z = op1.Pt.Z;\n\t\t\t\tDiscardLeftSide = (op1.Pt.X > op1b.Pt.X);\n\t\t\t}\n\t\t\telse if (op2.Pt.X >= Left && op2.Pt.X <= Right)\n\t\t\t{\n\t\t\t\t//Pt = op2.Pt;\n\t\t\t\tPt.X = op2.Pt.X;\n\t\t\t\tPt.Y = op2.Pt.Y;\n\t\t\t\tif (ClipperLib.use_xyz) Pt.Z = op2.Pt.Z;\n\t\t\t\tDiscardLeftSide = (op2.Pt.X > op2b.Pt.X);\n\t\t\t}\n\t\t\telse if (op1b.Pt.X >= Left && op1b.Pt.X <= Right)\n\t\t\t{\n\t\t\t\t//Pt = op1b.Pt;\n\t\t\t\tPt.X = op1b.Pt.X;\n\t\t\t\tPt.Y = op1b.Pt.Y;\n\t\t\t\tif (ClipperLib.use_xyz) Pt.Z = op1b.Pt.Z;\n\t\t\t\tDiscardLeftSide = op1b.Pt.X > op1.Pt.X;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t//Pt = op2b.Pt;\n\t\t\t\tPt.X = op2b.Pt.X;\n\t\t\t\tPt.Y = op2b.Pt.Y;\n\t\t\t\tif (ClipperLib.use_xyz) Pt.Z = op2b.Pt.Z;\n\t\t\t\tDiscardLeftSide = (op2b.Pt.X > op2.Pt.X);\n\t\t\t}\n\t\t\tj.OutPt1 = op1;\n\t\t\tj.OutPt2 = op2;\n\t\t\treturn this.JoinHorz(op1, op1b, op2, op2b, Pt, DiscardLeftSide);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t//nb: For non-horizontal joins ...\n\t\t\t//    1. Jr.OutPt1.Pt.Y == Jr.OutPt2.Pt.Y\n\t\t\t//    2. Jr.OutPt1.Pt > Jr.OffPt.Y\n\t\t\t//make sure the polygons are correctly oriented ...\n\t\t\top1b = op1.Next;\n\t\t\twhile ((ClipperLib.FPoint.op_Equality(op1b.Pt, op1.Pt)) && (op1b !== op1))\n\t\t\t\top1b = op1b.Next;\n\t\t\tvar Reverse1 = ((op1b.Pt.Y > op1.Pt.Y) || !ClipperLib.ClipperBase.SlopesEqual4(op1.Pt, op1b.Pt, j.OffPt));\n\t\t\tif (Reverse1)\n\t\t\t{\n\t\t\t\top1b = op1.Prev;\n\t\t\t\twhile ((ClipperLib.FPoint.op_Equality(op1b.Pt, op1.Pt)) && (op1b !== op1))\n\t\t\t\t\top1b = op1b.Prev;\n\n\t\t\t\tif ((op1b.Pt.Y > op1.Pt.Y) || !ClipperLib.ClipperBase.SlopesEqual4(op1.Pt, op1b.Pt, j.OffPt))\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t\top2b = op2.Next;\n\t\t\twhile ((ClipperLib.FPoint.op_Equality(op2b.Pt, op2.Pt)) && (op2b !== op2))\n\t\t\t\top2b = op2b.Next;\n\n\t\t\tvar Reverse2 = ((op2b.Pt.Y > op2.Pt.Y) || !ClipperLib.ClipperBase.SlopesEqual4(op2.Pt, op2b.Pt, j.OffPt));\n\t\t\tif (Reverse2)\n\t\t\t{\n\t\t\t\top2b = op2.Prev;\n\t\t\t\twhile ((ClipperLib.FPoint.op_Equality(op2b.Pt, op2.Pt)) && (op2b !== op2))\n\t\t\t\t\top2b = op2b.Prev;\n\n\t\t\t\tif ((op2b.Pt.Y > op2.Pt.Y) || !ClipperLib.ClipperBase.SlopesEqual4(op2.Pt, op2b.Pt, j.OffPt))\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif ((op1b === op1) || (op2b === op2) || (op1b === op2b) ||\n\t\t\t\t((outRec1 === outRec2) && (Reverse1 === Reverse2)))\n\t\t\t\treturn false;\n\t\t\tif (Reverse1)\n\t\t\t{\n\t\t\t\top1b = this.DupOutPt(op1, false);\n\t\t\t\top2b = this.DupOutPt(op2, true);\n\t\t\t\top1.Prev = op2;\n\t\t\t\top2.Next = op1;\n\t\t\t\top1b.Next = op2b;\n\t\t\t\top2b.Prev = op1b;\n\t\t\t\tj.OutPt1 = op1;\n\t\t\t\tj.OutPt2 = op1b;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\top1b = this.DupOutPt(op1, true);\n\t\t\t\top2b = this.DupOutPt(op2, false);\n\t\t\t\top1.Next = op2;\n\t\t\t\top2.Prev = op1;\n\t\t\t\top1b.Prev = op2b;\n\t\t\t\top2b.Next = op1b;\n\t\t\t\tj.OutPt1 = op1;\n\t\t\t\tj.OutPt2 = op1b;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t};\n\n\tClipperLib.Clipper.GetBounds = function (paths)\n\t{\n\t\tvar i = 0,\n\t\t\tcnt = paths.length;\n\t\twhile (i < cnt && paths[i].length === 0) i++;\n\t\tif (i === cnt) return new ClipperLib.FRect(0, 0, 0, 0);\n\t\tvar result = new ClipperLib.FRect();\n\t\tresult.left = paths[i][0].X;\n\t\tresult.right = result.left;\n\t\tresult.top = paths[i][0].Y;\n\t\tresult.bottom = result.top;\n\t\tfor (; i < cnt; i++)\n\t\t\tfor (var j = 0, jlen = paths[i].length; j < jlen; j++)\n\t\t\t{\n\t\t\t\tif (paths[i][j].X < result.left) result.left = paths[i][j].X;\n\t\t\t\telse if (paths[i][j].X > result.right) result.right = paths[i][j].X;\n\t\t\t\tif (paths[i][j].Y < result.top) result.top = paths[i][j].Y;\n\t\t\t\telse if (paths[i][j].Y > result.bottom) result.bottom = paths[i][j].Y;\n\t\t\t}\n\t\treturn result;\n\t}\n\tClipperLib.Clipper.prototype.GetBounds2 = function (ops)\n\t{\n\t\tvar opStart = ops;\n\t\tvar result = new ClipperLib.FRect();\n\t\tresult.left = ops.Pt.X;\n\t\tresult.right = ops.Pt.X;\n\t\tresult.top = ops.Pt.Y;\n\t\tresult.bottom = ops.Pt.Y;\n\t\tops = ops.Next;\n\t\twhile (ops !== opStart)\n\t\t{\n\t\t\tif (ops.Pt.X < result.left)\n\t\t\t\tresult.left = ops.Pt.X;\n\t\t\tif (ops.Pt.X > result.right)\n\t\t\t\tresult.right = ops.Pt.X;\n\t\t\tif (ops.Pt.Y < result.top)\n\t\t\t\tresult.top = ops.Pt.Y;\n\t\t\tif (ops.Pt.Y > result.bottom)\n\t\t\t\tresult.bottom = ops.Pt.Y;\n\t\t\tops = ops.Next;\n\t\t}\n\t\treturn result;\n\t};\n\n\tClipperLib.Clipper.PointInPolygon = function (pt, path)\n\t{\n\t\t//returns 0 if false, +1 if true, -1 if pt ON polygon boundary\n\t\t//See \"The Point in Polygon Problem for Arbitrary Polygons\" by Hormann & Agathos\n\t\t//http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.88.5498&rep=rep1&type=pdf\n\t\tvar result = 0,\n\t\t\tcnt = path.length;\n\t\tif (cnt < 3)\n\t\t\treturn 0;\n\t\tvar ip = path[0];\n\t\tfor (var i = 1; i <= cnt; ++i)\n\t\t{\n\t\t\tvar ipNext = (i === cnt ? path[0] : path[i]);\n\t\t\tif (ipNext.Y === pt.Y)\n\t\t\t{\n\t\t\t\tif ((ipNext.X === pt.X) || (ip.Y === pt.Y && ((ipNext.X > pt.X) === (ip.X < pt.X))))\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif ((ip.Y < pt.Y) !== (ipNext.Y < pt.Y))\n\t\t\t{\n\t\t\t\tif (ip.X >= pt.X)\n\t\t\t\t{\n\t\t\t\t\tif (ipNext.X > pt.X)\n\t\t\t\t\t\tresult = 1 - result;\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tvar d = (ip.X - pt.X) * (ipNext.Y - pt.Y) - (ipNext.X - pt.X) * (ip.Y - pt.Y);\n\t\t\t\t\t\tif (d === 0)\n\t\t\t\t\t\t\treturn -1;\n\t\t\t\t\t\telse if ((d > 0) === (ipNext.Y > ip.Y))\n\t\t\t\t\t\t\tresult = 1 - result;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (ipNext.X > pt.X)\n\t\t\t\t\t{\n\t\t\t\t\t\tvar d = (ip.X - pt.X) * (ipNext.Y - pt.Y) - (ipNext.X - pt.X) * (ip.Y - pt.Y);\n\t\t\t\t\t\tif (d === 0)\n\t\t\t\t\t\t\treturn -1;\n\t\t\t\t\t\telse if ((d > 0) === (ipNext.Y > ip.Y))\n\t\t\t\t\t\t\tresult = 1 - result;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tip = ipNext;\n\t\t}\n\t\treturn result;\n\t};\n\n\tClipperLib.Clipper.prototype.PointInPolygon = function (pt, op)\n\t{\n\t\t//returns 0 if false, +1 if true, -1 if pt ON polygon boundary\n\t\tvar result = 0;\n\t\tvar startOp = op;\n\t\tvar ptx = pt.X,\n\t\t\tpty = pt.Y;\n\t\tvar poly0x = op.Pt.X,\n\t\t\tpoly0y = op.Pt.Y;\n\t\tdo {\n\t\t\top = op.Next;\n\t\t\tvar poly1x = op.Pt.X,\n\t\t\t\tpoly1y = op.Pt.Y;\n\t\t\tif (poly1y === pty)\n\t\t\t{\n\t\t\t\tif ((poly1x === ptx) || (poly0y === pty && ((poly1x > ptx) === (poly0x < ptx))))\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif ((poly0y < pty) !== (poly1y < pty))\n\t\t\t{\n\t\t\t\tif (poly0x >= ptx)\n\t\t\t\t{\n\t\t\t\t\tif (poly1x > ptx)\n\t\t\t\t\t\tresult = 1 - result;\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tvar d = (poly0x - ptx) * (poly1y - pty) - (poly1x - ptx) * (poly0y - pty);\n\t\t\t\t\t\tif (d === 0)\n\t\t\t\t\t\t\treturn -1;\n\t\t\t\t\t\tif ((d > 0) === (poly1y > poly0y))\n\t\t\t\t\t\t\tresult = 1 - result;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (poly1x > ptx)\n\t\t\t\t\t{\n\t\t\t\t\t\tvar d = (poly0x - ptx) * (poly1y - pty) - (poly1x - ptx) * (poly0y - pty);\n\t\t\t\t\t\tif (d === 0)\n\t\t\t\t\t\t\treturn -1;\n\t\t\t\t\t\tif ((d > 0) === (poly1y > poly0y))\n\t\t\t\t\t\t\tresult = 1 - result;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tpoly0x = poly1x;\n\t\t\tpoly0y = poly1y;\n\t\t} while (startOp !== op);\n\n\t\treturn result;\n\t};\n\n\tClipperLib.Clipper.prototype.Poly2ContainsPoly1 = function (outPt1, outPt2)\n\t{\n\t\tvar op = outPt1;\n\t\tdo {\n\t\t\t//nb: PointInPolygon returns 0 if false, +1 if true, -1 if pt on polygon\n\t\t\tvar res = this.PointInPolygon(op.Pt, outPt2);\n\t\t\tif (res >= 0)\n\t\t\t\treturn res > 0;\n\t\t\top = op.Next;\n\t\t}\n\t\twhile (op !== outPt1)\n\t\treturn true;\n\t};\n\n\tClipperLib.Clipper.prototype.FixupFirstLefts1 = function (OldOutRec, NewOutRec)\n\t{\n\t\tvar outRec, firstLeft;\n\t\tfor (var i = 0, ilen = this.m_PolyOuts.length; i < ilen; i++)\n\t\t{\n\t\t\toutRec = this.m_PolyOuts[i];\n\t\t\tfirstLeft = ClipperLib.Clipper.ParseFirstLeft(outRec.FirstLeft);\n\t\t\tif (outRec.Pts !== null && firstLeft === OldOutRec)\n\t\t\t{\n\t\t\t\tif (this.Poly2ContainsPoly1(outRec.Pts, NewOutRec.Pts))\n\t\t\t\t\toutRec.FirstLeft = NewOutRec;\n\t\t\t}\n\t\t}\n\t}\n\n\tClipperLib.Clipper.prototype.FixupFirstLefts2 = function (innerOutRec, outerOutRec)\n\t{\n\t\t//A polygon has split into two such that one is now the inner of the other.\n\t\t//It's possible that these polygons now wrap around other polygons, so check\n\t\t//every polygon that's also contained by OuterOutRec's FirstLeft container\n\t\t//(including nil) to see if they've become inner to the new inner polygon ...\n\t\tvar orfl = outerOutRec.FirstLeft;\n\t\tvar outRec, firstLeft;\n\t\tfor (var i = 0, ilen = this.m_PolyOuts.length; i < ilen; i++)\n\t\t{\n\t\t\toutRec = this.m_PolyOuts[i];\n\t\t\tif (outRec.Pts === null || outRec === outerOutRec || outRec === innerOutRec)\n\t\t\t\tcontinue;\n\t\t\tfirstLeft = ClipperLib.Clipper.ParseFirstLeft(outRec.FirstLeft);\n\t\t\tif (firstLeft !== orfl && firstLeft !== innerOutRec && firstLeft !== outerOutRec)\n\t\t\t\tcontinue;\n\t\t\tif (this.Poly2ContainsPoly1(outRec.Pts, innerOutRec.Pts))\n\t\t\t\toutRec.FirstLeft = innerOutRec;\n\t\t\telse if (this.Poly2ContainsPoly1(outRec.Pts, outerOutRec.Pts))\n\t\t\t\toutRec.FirstLeft = outerOutRec;\n\t\t\telse if (outRec.FirstLeft === innerOutRec || outRec.FirstLeft === outerOutRec)\n\t\t\t\toutRec.FirstLeft = orfl;\n\t\t}\n\t}\n\n\tClipperLib.Clipper.prototype.FixupFirstLefts3 = function (OldOutRec, NewOutRec)\n\t{\n\t\t//same as FixupFirstLefts1 but doesn't call Poly2ContainsPoly1()\n\t\tvar outRec;\n\t\tvar firstLeft;\n\t\tfor (var i = 0, ilen = this.m_PolyOuts.length; i < ilen; i++)\n\t\t{\n\t\t\toutRec = this.m_PolyOuts[i];\n\t\t\tfirstLeft = ClipperLib.Clipper.ParseFirstLeft(outRec.FirstLeft);\n\t\t\tif (outRec.Pts !== null && firstLeft === OldOutRec)\n\t\t\t\toutRec.FirstLeft = NewOutRec;\n\t\t}\n\t}\n\n\tClipperLib.Clipper.ParseFirstLeft = function (FirstLeft)\n\t{\n\t\twhile (FirstLeft !== null && FirstLeft.Pts === null)\n\t\t\tFirstLeft = FirstLeft.FirstLeft;\n\t\treturn FirstLeft;\n\t};\n\n\tClipperLib.Clipper.prototype.JoinCommonEdges = function ()\n\t{\n\t\tfor (var i = 0, ilen = this.m_Joins.length; i < ilen; i++)\n\t\t{\n\t\t\tvar join = this.m_Joins[i];\n\t\t\tvar outRec1 = this.GetOutRec(join.OutPt1.Idx);\n\t\t\tvar outRec2 = this.GetOutRec(join.OutPt2.Idx);\n\t\t\tif (outRec1.Pts === null || outRec2.Pts === null)\n\t\t\t\tcontinue;\n\n\t\t\tif (outRec1.IsOpen || outRec2.IsOpen)\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t//get the polygon fragment with the correct hole state (FirstLeft)\n\t\t\t//before calling JoinPoints() ...\n\t\t\tvar holeStateRec;\n\t\t\tif (outRec1 === outRec2)\n\t\t\t\tholeStateRec = outRec1;\n\t\t\telse if (this.OutRec1RightOfOutRec2(outRec1, outRec2))\n\t\t\t\tholeStateRec = outRec2;\n\t\t\telse if (this.OutRec1RightOfOutRec2(outRec2, outRec1))\n\t\t\t\tholeStateRec = outRec1;\n\t\t\telse\n\t\t\t\tholeStateRec = this.GetLowermostRec(outRec1, outRec2);\n\n\t\t\tif (!this.JoinPoints(join, outRec1, outRec2)) continue;\n\n\t\t\tif (outRec1 === outRec2)\n\t\t\t{\n\t\t\t\t//instead of joining two polygons, we've just created a new one by\n\t\t\t\t//splitting one polygon into two.\n\t\t\t\toutRec1.Pts = join.OutPt1;\n\t\t\t\toutRec1.BottomPt = null;\n\t\t\t\toutRec2 = this.CreateOutRec();\n\t\t\t\toutRec2.Pts = join.OutPt2;\n\t\t\t\t//update all OutRec2.Pts Idx's ...\n\t\t\t\tthis.UpdateOutPtIdxs(outRec2);\n\n\t\t\t\tif (this.Poly2ContainsPoly1(outRec2.Pts, outRec1.Pts))\n\t\t\t\t{\n\t\t\t\t\t//outRec1 contains outRec2 ...\n\t\t\t\t\toutRec2.IsHole = !outRec1.IsHole;\n\t\t\t\t\toutRec2.FirstLeft = outRec1;\n\t\t\t\t\tif (this.m_UsingPolyTree)\n\t\t\t\t\t\tthis.FixupFirstLefts2(outRec2, outRec1);\n\t\t\t\t\tif ((outRec2.IsHole ^ this.ReverseSolution) == (this.Area$1(outRec2) > 0))\n\t\t\t\t\t\tthis.ReversePolyPtLinks(outRec2.Pts);\n\t\t\t\t}\n\t\t\t\telse if (this.Poly2ContainsPoly1(outRec1.Pts, outRec2.Pts))\n\t\t\t\t{\n\t\t\t\t\t//outRec2 contains outRec1 ...\n\t\t\t\t\toutRec2.IsHole = outRec1.IsHole;\n\t\t\t\t\toutRec1.IsHole = !outRec2.IsHole;\n\t\t\t\t\toutRec2.FirstLeft = outRec1.FirstLeft;\n\t\t\t\t\toutRec1.FirstLeft = outRec2;\n\t\t\t\t\tif (this.m_UsingPolyTree)\n\t\t\t\t\t\tthis.FixupFirstLefts2(outRec1, outRec2);\n\n\t\t\t\t\tif ((outRec1.IsHole ^ this.ReverseSolution) == (this.Area$1(outRec1) > 0))\n\t\t\t\t\t\tthis.ReversePolyPtLinks(outRec1.Pts);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t//the 2 polygons are completely separate ...\n\t\t\t\t\toutRec2.IsHole = outRec1.IsHole;\n\t\t\t\t\toutRec2.FirstLeft = outRec1.FirstLeft;\n\t\t\t\t\t//fixup FirstLeft pointers that may need reassigning to OutRec2\n\t\t\t\t\tif (this.m_UsingPolyTree)\n\t\t\t\t\t\tthis.FixupFirstLefts1(outRec1, outRec2);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t//joined 2 polygons together ...\n\t\t\t\toutRec2.Pts = null;\n\t\t\t\toutRec2.BottomPt = null;\n\t\t\t\toutRec2.Idx = outRec1.Idx;\n\t\t\t\toutRec1.IsHole = holeStateRec.IsHole;\n\t\t\t\tif (holeStateRec === outRec2)\n\t\t\t\t\toutRec1.FirstLeft = outRec2.FirstLeft;\n\t\t\t\toutRec2.FirstLeft = outRec1;\n\t\t\t\t//fixup FirstLeft pointers that may need reassigning to OutRec1\n\t\t\t\tif (this.m_UsingPolyTree)\n\t\t\t\t\tthis.FixupFirstLefts3(outRec2, outRec1);\n\t\t\t}\n\t\t}\n\t};\n\n\tClipperLib.Clipper.prototype.UpdateOutPtIdxs = function (outrec)\n\t{\n\t\tvar op = outrec.Pts;\n\t\tdo {\n\t\t\top.Idx = outrec.Idx;\n\t\t\top = op.Prev;\n\t\t}\n\t\twhile (op !== outrec.Pts)\n\t};\n\n\tClipperLib.Clipper.prototype.DoSimplePolygons = function ()\n\t{\n\t\tvar i = 0;\n\t\twhile (i < this.m_PolyOuts.length)\n\t\t{\n\t\t\tvar outrec = this.m_PolyOuts[i++];\n\t\t\tvar op = outrec.Pts;\n\t\t\tif (op === null || outrec.IsOpen)\n\t\t\t\tcontinue;\n\t\t\tdo //for each Pt in Polygon until duplicate found do ...\n\t\t\t{\n\t\t\t\tvar op2 = op.Next;\n\t\t\t\twhile (op2 !== outrec.Pts)\n\t\t\t\t{\n\t\t\t\t\tif ((ClipperLib.FPoint.op_Equality(op.Pt, op2.Pt)) && op2.Next !== op && op2.Prev !== op)\n\t\t\t\t\t{\n\t\t\t\t\t\t//split the polygon into two ...\n\t\t\t\t\t\tvar op3 = op.Prev;\n\t\t\t\t\t\tvar op4 = op2.Prev;\n\t\t\t\t\t\top.Prev = op4;\n\t\t\t\t\t\top4.Next = op;\n\t\t\t\t\t\top2.Prev = op3;\n\t\t\t\t\t\top3.Next = op2;\n\t\t\t\t\t\toutrec.Pts = op;\n\t\t\t\t\t\tvar outrec2 = this.CreateOutRec();\n\t\t\t\t\t\toutrec2.Pts = op2;\n\t\t\t\t\t\tthis.UpdateOutPtIdxs(outrec2);\n\t\t\t\t\t\tif (this.Poly2ContainsPoly1(outrec2.Pts, outrec.Pts))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t//OutRec2 is contained by OutRec1 ...\n\t\t\t\t\t\t\toutrec2.IsHole = !outrec.IsHole;\n\t\t\t\t\t\t\toutrec2.FirstLeft = outrec;\n\t\t\t\t\t\t\tif (this.m_UsingPolyTree) this.FixupFirstLefts2(outrec2, outrec);\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (this.Poly2ContainsPoly1(outrec.Pts, outrec2.Pts))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t//OutRec1 is contained by OutRec2 ...\n\t\t\t\t\t\t\toutrec2.IsHole = outrec.IsHole;\n\t\t\t\t\t\t\toutrec.IsHole = !outrec2.IsHole;\n\t\t\t\t\t\t\toutrec2.FirstLeft = outrec.FirstLeft;\n\t\t\t\t\t\t\toutrec.FirstLeft = outrec2;\n\t\t\t\t\t\t\tif (this.m_UsingPolyTree) this.FixupFirstLefts2(outrec, outrec2);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t//the 2 polygons are separate ...\n\t\t\t\t\t\t\toutrec2.IsHole = outrec.IsHole;\n\t\t\t\t\t\t\toutrec2.FirstLeft = outrec.FirstLeft;\n\t\t\t\t\t\t\tif (this.m_UsingPolyTree) this.FixupFirstLefts1(outrec, outrec2);\n\t\t\t\t\t\t}\n\t\t\t\t\t\top2 = op;\n\t\t\t\t\t\t//ie get ready for the next iteration\n\t\t\t\t\t}\n\t\t\t\t\top2 = op2.Next;\n\t\t\t\t}\n\t\t\t\top = op.Next;\n\t\t\t}\n\t\t\twhile (op !== outrec.Pts)\n\t\t}\n\t};\n\n\tClipperLib.Clipper.Area = function (poly)\n\t{\n\t\tif (!Array.isArray(poly))\n\t\t\treturn 0;\n\t\tvar cnt = poly.length;\n\t\tif (cnt < 3)\n\t\t\treturn 0;\n\t\tvar a = 0;\n\t\tfor (var i = 0, j = cnt - 1; i < cnt; ++i)\n\t\t{\n\t\t\ta += (poly[j].X + poly[i].X) * (poly[j].Y - poly[i].Y);\n\t\t\tj = i;\n\t\t}\n\t\treturn -a * 0.5;\n\t};\n\n\tClipperLib.Clipper.prototype.Area = function (op)\n\t{\n\t\tvar opFirst = op;\n\t\tif (op === null) return 0;\n\t\tvar a = 0;\n\t\tdo {\n\t\t\ta = a + (op.Prev.Pt.X + op.Pt.X) * (op.Prev.Pt.Y - op.Pt.Y);\n\t\t\top = op.Next;\n\t\t} while (op !== opFirst); // && typeof op !== 'undefined');\n\t\treturn a * 0.5;\n\t}\n\n\tClipperLib.Clipper.prototype.Area$1 = function (outRec)\n\t{\n\t\treturn this.Area(outRec.Pts);\n\t};\n\n\tClipperLib.Clipper.SimplifyPolygon = function (poly, fillType)\n\t{\n\t\tvar result = new Array();\n\t\tvar c = new ClipperLib.Clipper(0);\n\t\tc.StrictlySimple = true;\n\t\tc.AddPath(poly, ClipperLib.PolyType.ptSubject, true);\n\t\tc.Execute(ClipperLib.ClipType.ctUnion, result, fillType, fillType);\n\t\treturn result;\n\t};\n\n\tClipperLib.Clipper.SimplifyPolygons = function (polys, fillType)\n\t{\n\t\tif (typeof (fillType) === \"undefined\") fillType = ClipperLib.PolyFillType.pftEvenOdd;\n\t\tvar result = new Array();\n\t\tvar c = new ClipperLib.Clipper(0);\n\t\tc.StrictlySimple = true;\n\t\tc.AddPaths(polys, ClipperLib.PolyType.ptSubject, true);\n\t\tc.Execute(ClipperLib.ClipType.ctUnion, result, fillType, fillType);\n\t\treturn result;\n\t};\n\n\tClipperLib.Clipper.DistanceSqrd = function (pt1, pt2)\n\t{\n\t\tvar dx = (pt1.X - pt2.X);\n\t\tvar dy = (pt1.Y - pt2.Y);\n\t\treturn (dx * dx + dy * dy);\n\t};\n\n\tClipperLib.Clipper.DistanceFromLineSqrd = function (pt, ln1, ln2)\n\t{\n\t\t//The equation of a line in general form (Ax + By + C = 0)\n\t\t//given 2 points (x,y) & (x,y) is ...\n\t\t//(y - y)x + (x - x)y + (y - y)x - (x - x)y = 0\n\t\t//A = (y - y); B = (x - x); C = (y - y)x - (x - x)y\n\t\t//perpendicular distance of point (x,y) = (Ax + By + C)/Sqrt(A + B)\n\t\t//see http://en.wikipedia.org/wiki/Perpendicular_distance\n\t\tvar A = ln1.Y - ln2.Y;\n\t\tvar B = ln2.X - ln1.X;\n\t\tvar C = A * ln1.X + B * ln1.Y;\n\t\tC = A * pt.X + B * pt.Y - C;\n\t\treturn (C * C) / (A * A + B * B);\n\t};\n\n\tClipperLib.Clipper.SlopesNearCollinear = function (pt1, pt2, pt3, distSqrd)\n\t{\n\t\t//this function is more accurate when the point that's GEOMETRICALLY\n\t\t//between the other 2 points is the one that's tested for distance.\n\t\t//nb: with 'spikes', either pt1 or pt3 is geometrically between the other pts\n\t\tif (Math.abs(pt1.X - pt2.X) > Math.abs(pt1.Y - pt2.Y))\n\t\t{\n\t\t\tif ((pt1.X > pt2.X) === (pt1.X < pt3.X))\n\t\t\t\treturn ClipperLib.Clipper.DistanceFromLineSqrd(pt1, pt2, pt3) < distSqrd;\n\t\t\telse if ((pt2.X > pt1.X) === (pt2.X < pt3.X))\n\t\t\t\treturn ClipperLib.Clipper.DistanceFromLineSqrd(pt2, pt1, pt3) < distSqrd;\n\t\t\telse\n\t\t\t\treturn ClipperLib.Clipper.DistanceFromLineSqrd(pt3, pt1, pt2) < distSqrd;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif ((pt1.Y > pt2.Y) === (pt1.Y < pt3.Y))\n\t\t\t\treturn ClipperLib.Clipper.DistanceFromLineSqrd(pt1, pt2, pt3) < distSqrd;\n\t\t\telse if ((pt2.Y > pt1.Y) === (pt2.Y < pt3.Y))\n\t\t\t\treturn ClipperLib.Clipper.DistanceFromLineSqrd(pt2, pt1, pt3) < distSqrd;\n\t\t\telse\n\t\t\t\treturn ClipperLib.Clipper.DistanceFromLineSqrd(pt3, pt1, pt2) < distSqrd;\n\t\t}\n\t}\n\n\tClipperLib.Clipper.PointsAreClose = function (pt1, pt2, distSqrd)\n\t{\n\t\tvar dx = pt1.X - pt2.X;\n\t\tvar dy = pt1.Y - pt2.Y;\n\t\treturn ((dx * dx) + (dy * dy) <= distSqrd);\n\t};\n\n\tClipperLib.Clipper.ExcludeOp = function (op)\n\t{\n\t\tvar result = op.Prev;\n\t\tresult.Next = op.Next;\n\t\top.Next.Prev = result;\n\t\tresult.Idx = 0;\n\t\treturn result;\n\t};\n\n\tClipperLib.Clipper.CleanPolygon = function (path, distance)\n\t{\n\t\tif (typeof (distance) === \"undefined\") distance = 1.415;\n\t\t//distance = proximity in units/pixels below which vertices will be stripped.\n\t\t//Default ~= sqrt(2) so when adjacent vertices or semi-adjacent vertices have\n\t\t//both x & y coords within 1 unit, then the second vertex will be stripped.\n\t\tvar cnt = path.length;\n\t\tif (cnt === 0)\n\t\t\treturn new Array();\n\t\tvar outPts = new Array(cnt);\n\t\tfor (var i = 0; i < cnt; ++i)\n\t\t\toutPts[i] = new ClipperLib.OutPt();\n\t\tfor (var i = 0; i < cnt; ++i)\n\t\t{\n\t\t\toutPts[i].Pt = path[i];\n\t\t\toutPts[i].Next = outPts[(i + 1) % cnt];\n\t\t\toutPts[i].Next.Prev = outPts[i];\n\t\t\toutPts[i].Idx = 0;\n\t\t}\n\t\tvar distSqrd = distance * distance;\n\t\tvar op = outPts[0];\n\t\twhile (op.Idx === 0 && op.Next !== op.Prev)\n\t\t{\n\t\t\tif (ClipperLib.Clipper.PointsAreClose(op.Pt, op.Prev.Pt, distSqrd))\n\t\t\t{\n\t\t\t\top = ClipperLib.Clipper.ExcludeOp(op);\n\t\t\t\tcnt--;\n\t\t\t}\n\t\t\telse if (ClipperLib.Clipper.PointsAreClose(op.Prev.Pt, op.Next.Pt, distSqrd))\n\t\t\t{\n\t\t\t\tClipperLib.Clipper.ExcludeOp(op.Next);\n\t\t\t\top = ClipperLib.Clipper.ExcludeOp(op);\n\t\t\t\tcnt -= 2;\n\t\t\t}\n\t\t\telse if (ClipperLib.Clipper.SlopesNearCollinear(op.Prev.Pt, op.Pt, op.Next.Pt, distSqrd))\n\t\t\t{\n\t\t\t\top = ClipperLib.Clipper.ExcludeOp(op);\n\t\t\t\tcnt--;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\top.Idx = 1;\n\t\t\t\top = op.Next;\n\t\t\t}\n\t\t}\n\t\tif (cnt < 3)\n\t\t\tcnt = 0;\n\t\tvar result = new Array(cnt);\n\t\tfor (var i = 0; i < cnt; ++i)\n\t\t{\n\t\t\tresult[i] = new ClipperLib.FPoint1(op.Pt);\n\t\t\top = op.Next;\n\t\t}\n\t\toutPts = null;\n\t\treturn result;\n\t};\n\n\tClipperLib.Clipper.CleanPolygons = function (polys, distance)\n\t{\n\t\tvar result = new Array(polys.length);\n\t\tfor (var i = 0, ilen = polys.length; i < ilen; i++)\n\t\t\tresult[i] = ClipperLib.Clipper.CleanPolygon(polys[i], distance);\n\t\treturn result;\n\t};\n\n\tClipperLib.Clipper.Minkowski = function (pattern, path, IsSum, IsClosed)\n\t{\n\t\tvar delta = (IsClosed ? 1 : 0);\n\t\tvar polyCnt = pattern.length;\n\t\tvar pathCnt = path.length;\n\t\tvar result = new Array();\n\t\tif (IsSum)\n\t\t\tfor (var i = 0; i < pathCnt; i++)\n\t\t\t{\n\t\t\t\tvar p = new Array(polyCnt);\n\t\t\t\tfor (var j = 0, jlen = pattern.length, ip = pattern[j]; j < jlen; j++, ip = pattern[j])\n\t\t\t\t\tp[j] = new ClipperLib.FPoint2(path[i].X + ip.X, path[i].Y + ip.Y);\n\t\t\t\tresult.push(p);\n\t\t\t}\n\t\telse\n\t\t\tfor (var i = 0; i < pathCnt; i++)\n\t\t\t{\n\t\t\t\tvar p = new Array(polyCnt);\n\t\t\t\tfor (var j = 0, jlen = pattern.length, ip = pattern[j]; j < jlen; j++, ip = pattern[j])\n\t\t\t\t\tp[j] = new ClipperLib.FPoint2(path[i].X - ip.X, path[i].Y - ip.Y);\n\t\t\t\tresult.push(p);\n\t\t\t}\n\t\tvar quads = new Array();\n\t\tfor (var i = 0; i < pathCnt - 1 + delta; i++)\n\t\t\tfor (var j = 0; j < polyCnt; j++)\n\t\t\t{\n\t\t\t\tvar quad = new Array();\n\t\t\t\tquad.push(result[i % pathCnt][j % polyCnt]);\n\t\t\t\tquad.push(result[(i + 1) % pathCnt][j % polyCnt]);\n\t\t\t\tquad.push(result[(i + 1) % pathCnt][(j + 1) % polyCnt]);\n\t\t\t\tquad.push(result[i % pathCnt][(j + 1) % polyCnt]);\n\t\t\t\tif (!ClipperLib.Clipper.Orientation(quad))\n\t\t\t\t\tquad.reverse();\n\t\t\t\tquads.push(quad);\n\t\t\t}\n\t\treturn quads;\n\t};\n\n\tClipperLib.Clipper.MinkowskiSum = function (pattern, path_or_paths, pathIsClosed)\n\t{\n\t\tif (!(path_or_paths[0] instanceof Array))\n\t\t{\n\t\t\tvar path = path_or_paths;\n\t\t\tvar paths = ClipperLib.Clipper.Minkowski(pattern, path, true, pathIsClosed);\n\t\t\tvar c = new ClipperLib.Clipper();\n\t\t\tc.AddPaths(paths, ClipperLib.PolyType.ptSubject, true);\n\t\t\tc.Execute(ClipperLib.ClipType.ctUnion, paths, ClipperLib.PolyFillType.pftNonZero, ClipperLib.PolyFillType.pftNonZero);\n\t\t\treturn paths;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvar paths = path_or_paths;\n\t\t\tvar solution = new ClipperLib.Paths();\n\t\t\tvar c = new ClipperLib.Clipper();\n\t\t\tfor (var i = 0; i < paths.length; ++i)\n\t\t\t{\n\t\t\t\tvar tmp = ClipperLib.Clipper.Minkowski(pattern, paths[i], true, pathIsClosed);\n\t\t\t\tc.AddPaths(tmp, ClipperLib.PolyType.ptSubject, true);\n\t\t\t\tif (pathIsClosed)\n\t\t\t\t{\n\t\t\t\t\tvar path = ClipperLib.Clipper.TranslatePath(paths[i], pattern[0]);\n\t\t\t\t\tc.AddPath(path, ClipperLib.PolyType.ptClip, true);\n\t\t\t\t}\n\t\t\t}\n\t\t\tc.Execute(ClipperLib.ClipType.ctUnion, solution,\n\t\t\t\tClipperLib.PolyFillType.pftNonZero, ClipperLib.PolyFillType.pftNonZero);\n\t\t\treturn solution;\n\t\t}\n\t}\n\n\tClipperLib.Clipper.TranslatePath = function (path, delta)\n\t{\n\t\tvar outPath = new ClipperLib.Path();\n\t\tfor (var i = 0; i < path.length; i++)\n\t\t\toutPath.push(new ClipperLib.FPoint2(path[i].X + delta.X, path[i].Y + delta.Y));\n\t\treturn outPath;\n\t}\n\n\tClipperLib.Clipper.MinkowskiDiff = function (poly1, poly2)\n\t{\n\t\tvar paths = ClipperLib.Clipper.Minkowski(poly1, poly2, false, true);\n\t\tvar c = new ClipperLib.Clipper();\n\t\tc.AddPaths(paths, ClipperLib.PolyType.ptSubject, true);\n\t\tc.Execute(ClipperLib.ClipType.ctUnion, paths, ClipperLib.PolyFillType.pftNonZero, ClipperLib.PolyFillType.pftNonZero);\n\t\treturn paths;\n\t}\n\n\tClipperLib.Clipper.PolyTreeToPaths = function (polytree)\n\t{\n\t\tvar result = new Array();\n\t\t//result.set_Capacity(polytree.get_Total());\n\t\tClipperLib.Clipper.AddPolyNodeToPaths(polytree, ClipperLib.Clipper.NodeType.ntAny, result);\n\t\treturn result;\n\t};\n\n\tClipperLib.Clipper.AddPolyNodeToPaths = function (polynode, nt, paths)\n\t{\n\t\tvar match = true;\n\t\tswitch (nt)\n\t\t{\n\t\t\tcase ClipperLib.Clipper.NodeType.ntOpen:\n\t\t\t\treturn;\n\t\t\tcase ClipperLib.Clipper.NodeType.ntClosed:\n\t\t\t\tmatch = !polynode.IsOpen;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t}\n\t\tif (polynode.m_polygon.length > 0 && match)\n\t\t\tpaths.push(polynode.m_polygon);\n\t\tfor (var $i3 = 0, $t3 = polynode.Childs(), $l3 = $t3.length, pn = $t3[$i3]; $i3 < $l3; $i3++, pn = $t3[$i3])\n\t\t\tClipperLib.Clipper.AddPolyNodeToPaths(pn, nt, paths);\n\t};\n\n\tClipperLib.Clipper.OpenPathsFromPolyTree = function (polytree)\n\t{\n\t\tvar result = new ClipperLib.Paths();\n\t\t//result.set_Capacity(polytree.ChildCount());\n\t\tfor (var i = 0, ilen = polytree.ChildCount(); i < ilen; i++)\n\t\t\tif (polytree.Childs()[i].IsOpen)\n\t\t\t\tresult.push(polytree.Childs()[i].m_polygon);\n\t\treturn result;\n\t};\n\n\tClipperLib.Clipper.ClosedPathsFromPolyTree = function (polytree)\n\t{\n\t\tvar result = new ClipperLib.Paths();\n\t\t//result.set_Capacity(polytree.Total());\n\t\tClipperLib.Clipper.AddPolyNodeToPaths(polytree, ClipperLib.Clipper.NodeType.ntClosed, result);\n\t\treturn result;\n\t};\n\n\tInherit(ClipperLib.Clipper, ClipperLib.ClipperBase);\n\tClipperLib.Clipper.NodeType = {\n\t\tntAny: 0,\n\t\tntOpen: 1,\n\t\tntClosed: 2\n\t};\n\n\t/**\n\t* @constructor\n\t*/\n\tClipperLib.ClipperOffset = function (miterLimit, arcTolerance)\n\t{\n\t\tif (typeof (miterLimit) === \"undefined\") miterLimit = 2;\n\t\tif (typeof (arcTolerance) === \"undefined\") arcTolerance = ClipperLib.ClipperOffset.def_arc_tolerance;\n\t\tthis.m_destPolys = new ClipperLib.Paths();\n\t\tthis.m_srcPoly = new ClipperLib.Path();\n\t\tthis.m_destPoly = new ClipperLib.Path();\n\t\tthis.m_normals = new Array();\n\t\tthis.m_delta = 0;\n\t\tthis.m_sinA = 0;\n\t\tthis.m_sin = 0;\n\t\tthis.m_cos = 0;\n\t\tthis.m_miterLim = 0;\n\t\tthis.m_StepsPerRad = 0;\n\t\tthis.m_lowest = new ClipperLib.FPoint0();\n\t\tthis.m_polyNodes = new ClipperLib.PolyNode();\n\t\tthis.MiterLimit = miterLimit;\n\t\tthis.ArcTolerance = arcTolerance;\n\t\tthis.m_lowest.X = -1;\n\t};\n\n\tClipperLib.ClipperOffset.two_pi = 6.28318530717959;\n\tClipperLib.ClipperOffset.def_arc_tolerance = 0.25;\n\tClipperLib.ClipperOffset.prototype.Clear = function ()\n\t{\n\t\tClipperLib.Clear(this.m_polyNodes.Childs());\n\t\tthis.m_lowest.X = -1;\n\t};\n\n\tClipperLib.ClipperOffset.prototype.AddPath = function (path, joinType, endType)\n\t{\n\t\tvar highI = path.length - 1;\n\t\tif (highI < 0)\n\t\t\treturn;\n\t\tvar newNode = new ClipperLib.PolyNode();\n\t\tnewNode.m_jointype = joinType;\n\t\tnewNode.m_endtype = endType;\n\t\t//strip duplicate points from path and also get index to the lowest point ...\n\t\tif (endType === ClipperLib.EndType.etClosedLine || endType === ClipperLib.EndType.etClosedPolygon)\n\t\t\twhile (highI > 0 && ClipperLib.FPoint.op_Equality(path[0], path[highI]))\n\t\t\t\thighI--;\n\t\t//newNode.m_polygon.set_Capacity(highI + 1);\n\t\tnewNode.m_polygon.push(path[0]);\n\t\tvar j = 0,\n\t\t\tk = 0;\n\t\tfor (var i = 1; i <= highI; i++)\n\t\t\tif (ClipperLib.FPoint.op_Inequality(newNode.m_polygon[j], path[i]))\n\t\t\t{\n\t\t\t\tj++;\n\t\t\t\tnewNode.m_polygon.push(path[i]);\n\t\t\t\tif (path[i].Y > newNode.m_polygon[k].Y || (path[i].Y === newNode.m_polygon[k].Y && path[i].X < newNode.m_polygon[k].X))\n\t\t\t\t\tk = j;\n\t\t\t}\n\t\tif (endType === ClipperLib.EndType.etClosedPolygon && j < 2) return;\n\n\t\tthis.m_polyNodes.AddChild(newNode);\n\t\t//if this path's lowest pt is lower than all the others then update m_lowest\n\t\tif (endType !== ClipperLib.EndType.etClosedPolygon)\n\t\t\treturn;\n\t\tif (this.m_lowest.X < 0)\n\t\t\tthis.m_lowest = new ClipperLib.FPoint2(this.m_polyNodes.ChildCount() - 1, k);\n\t\telse\n\t\t{\n\t\t\tvar ip = this.m_polyNodes.Childs()[this.m_lowest.X].m_polygon[this.m_lowest.Y];\n\t\t\tif (newNode.m_polygon[k].Y > ip.Y || (newNode.m_polygon[k].Y === ip.Y && newNode.m_polygon[k].X < ip.X))\n\t\t\t\tthis.m_lowest = new ClipperLib.FPoint2(this.m_polyNodes.ChildCount() - 1, k);\n\t\t}\n\t};\n\n\tClipperLib.ClipperOffset.prototype.AddPaths = function (paths, joinType, endType)\n\t{\n\t\tfor (var i = 0, ilen = paths.length; i < ilen; i++)\n\t\t\tthis.AddPath(paths[i], joinType, endType);\n\t};\n\n\tClipperLib.ClipperOffset.prototype.FixOrientations = function ()\n\t{\n\t\t//fixup orientations of all closed paths if the orientation of the\n\t\t//closed path with the lowermost vertex is wrong ...\n\t\tif (this.m_lowest.X >= 0 && !ClipperLib.Clipper.Orientation(this.m_polyNodes.Childs()[this.m_lowest.X].m_polygon))\n\t\t{\n\t\t\tfor (var i = 0; i < this.m_polyNodes.ChildCount(); i++)\n\t\t\t{\n\t\t\t\tvar node = this.m_polyNodes.Childs()[i];\n\t\t\t\tif (node.m_endtype === ClipperLib.EndType.etClosedPolygon || (node.m_endtype === ClipperLib.EndType.etClosedLine && ClipperLib.Clipper.Orientation(node.m_polygon)))\n\t\t\t\t\tnode.m_polygon.reverse();\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfor (var i = 0; i < this.m_polyNodes.ChildCount(); i++)\n\t\t\t{\n\t\t\t\tvar node = this.m_polyNodes.Childs()[i];\n\t\t\t\tif (node.m_endtype === ClipperLib.EndType.etClosedLine && !ClipperLib.Clipper.Orientation(node.m_polygon))\n\t\t\t\t\tnode.m_polygon.reverse();\n\t\t\t}\n\t\t}\n\t};\n\n\tClipperLib.ClipperOffset.GetUnitNormal = function (pt1, pt2)\n\t{\n\t\tvar dx = (pt2.X - pt1.X);\n\t\tvar dy = (pt2.Y - pt1.Y);\n\t\tif ((dx === 0) && (dy === 0))\n\t\t\treturn new ClipperLib.FPoint2(0, 0);\n\t\tvar f = 1 / Math.sqrt(dx * dx + dy * dy);\n\t\tdx *= f;\n\t\tdy *= f;\n\t\treturn new ClipperLib.FPoint2(dy, -dx);\n\t};\n\n\tClipperLib.ClipperOffset.prototype.DoOffset = function (delta)\n\t{\n\t\tthis.m_destPolys = new Array();\n\t\tthis.m_delta = delta;\n\t\t//if Zero offset, just copy any CLOSED polygons to m_p and return ...\n\t\tif (ClipperLib.ClipperBase.near_zero(delta))\n\t\t{\n\t\t\t//this.m_destPolys.set_Capacity(this.m_polyNodes.ChildCount);\n\t\t\tfor (var i = 0; i < this.m_polyNodes.ChildCount(); i++)\n\t\t\t{\n\t\t\t\tvar node = this.m_polyNodes.Childs()[i];\n\t\t\t\tif (node.m_endtype === ClipperLib.EndType.etClosedPolygon)\n\t\t\t\t\tthis.m_destPolys.push(node.m_polygon);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\t//see offset_triginometry3.svg in the documentation folder ...\n\t\tif (this.MiterLimit > 2)\n\t\t\tthis.m_miterLim = 2 / (this.MiterLimit * this.MiterLimit);\n\t\telse\n\t\t\tthis.m_miterLim = 0.5;\n\t\tvar y;\n\t\tif (this.ArcTolerance <= 0)\n\t\t\ty = ClipperLib.ClipperOffset.def_arc_tolerance;\n\t\telse if (this.ArcTolerance > Math.abs(delta) * ClipperLib.ClipperOffset.def_arc_tolerance)\n\t\t\ty = Math.abs(delta) * ClipperLib.ClipperOffset.def_arc_tolerance;\n\t\telse\n\t\t\ty = this.ArcTolerance;\n\t\t//see offset_triginometry2.svg in the documentation folder ...\n\t\tvar steps = 3.14159265358979 / Math.acos(1 - y / Math.abs(delta));\n\t\tthis.m_sin = Math.sin(ClipperLib.ClipperOffset.two_pi / steps);\n\t\tthis.m_cos = Math.cos(ClipperLib.ClipperOffset.two_pi / steps);\n\t\tthis.m_StepsPerRad = steps / ClipperLib.ClipperOffset.two_pi;\n\t\tif (delta < 0)\n\t\t\tthis.m_sin = -this.m_sin;\n\t\t//this.m_destPolys.set_Capacity(this.m_polyNodes.ChildCount * 2);\n\t\tfor (var i = 0; i < this.m_polyNodes.ChildCount(); i++)\n\t\t{\n\t\t\tvar node = this.m_polyNodes.Childs()[i];\n\t\t\tthis.m_srcPoly = node.m_polygon;\n\t\t\tvar len = this.m_srcPoly.length;\n\t\t\tif (len === 0 || (delta <= 0 && (len < 3 || node.m_endtype !== ClipperLib.EndType.etClosedPolygon)))\n\t\t\t\tcontinue;\n\t\t\tthis.m_destPoly = new Array();\n\t\t\tif (len === 1)\n\t\t\t{\n\t\t\t\tif (node.m_jointype === ClipperLib.JoinType.jtRound)\n\t\t\t\t{\n\t\t\t\t\tvar X = 1,\n\t\t\t\t\t\tY = 0;\n\t\t\t\t\tfor (var j = 1; j <= steps; j++)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.m_destPoly.push(new ClipperLib.FPoint2(this.m_srcPoly[0].X + X * delta, this.m_srcPoly[0].Y + Y * delta));\n\t\t\t\t\t\tvar X2 = X;\n\t\t\t\t\t\tX = X * this.m_cos - this.m_sin * Y;\n\t\t\t\t\t\tY = X2 * this.m_sin + Y * this.m_cos;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tvar X = -1,\n\t\t\t\t\t\tY = -1;\n\t\t\t\t\tfor (var j = 0; j < 4; ++j)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.m_destPoly.push(new ClipperLib.FPoint2(this.m_srcPoly[0].X + X * delta, this.m_srcPoly[0].Y + Y * delta));\n\t\t\t\t\t\tif (X < 0)\n\t\t\t\t\t\t\tX = 1;\n\t\t\t\t\t\telse if (Y < 0)\n\t\t\t\t\t\t\tY = 1;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tX = -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tthis.m_destPolys.push(this.m_destPoly);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t//build m_normals ...\n\t\t\tthis.m_normals.length = 0;\n\t\t\t//this.m_normals.set_Capacity(len);\n\t\t\tfor (var j = 0; j < len - 1; j++)\n\t\t\t\tthis.m_normals.push(ClipperLib.ClipperOffset.GetUnitNormal(this.m_srcPoly[j], this.m_srcPoly[j + 1]));\n\t\t\tif (node.m_endtype === ClipperLib.EndType.etClosedLine || node.m_endtype === ClipperLib.EndType.etClosedPolygon)\n\t\t\t\tthis.m_normals.push(ClipperLib.ClipperOffset.GetUnitNormal(this.m_srcPoly[len - 1], this.m_srcPoly[0]));\n\t\t\telse\n\t\t\t\tthis.m_normals.push(new ClipperLib.FPoint1(this.m_normals[len - 2]));\n\t\t\tif (node.m_endtype === ClipperLib.EndType.etClosedPolygon)\n\t\t\t{\n\t\t\t\tvar k = len - 1;\n\t\t\t\tfor (var j = 0; j < len; j++)\n\t\t\t\t\tk = this.OffsetPoint(j, k, node.m_jointype);\n\t\t\t\tthis.m_destPolys.push(this.m_destPoly);\n\t\t\t}\n\t\t\telse if (node.m_endtype === ClipperLib.EndType.etClosedLine)\n\t\t\t{\n\t\t\t\tvar k = len - 1;\n\t\t\t\tfor (var j = 0; j < len; j++)\n\t\t\t\t\tk = this.OffsetPoint(j, k, node.m_jointype);\n\t\t\t\tthis.m_destPolys.push(this.m_destPoly);\n\t\t\t\tthis.m_destPoly = new Array();\n\t\t\t\t//re-build m_normals ...\n\t\t\t\tvar n = this.m_normals[len - 1];\n\t\t\t\tfor (var j = len - 1; j > 0; j--)\n\t\t\t\t\tthis.m_normals[j] = new ClipperLib.FPoint2(-this.m_normals[j - 1].X, -this.m_normals[j - 1].Y);\n\t\t\t\tthis.m_normals[0] = new ClipperLib.FPoint2(-n.X, -n.Y);\n\t\t\t\tk = 0;\n\t\t\t\tfor (var j = len - 1; j >= 0; j--)\n\t\t\t\t\tk = this.OffsetPoint(j, k, node.m_jointype);\n\t\t\t\tthis.m_destPolys.push(this.m_destPoly);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tvar k = 0;\n\t\t\t\tfor (var j = 1; j < len - 1; ++j)\n\t\t\t\t\tk = this.OffsetPoint(j, k, node.m_jointype);\n\t\t\t\tvar pt1;\n\t\t\t\tif (node.m_endtype === ClipperLib.EndType.etOpenButt)\n\t\t\t\t{\n\t\t\t\t\tvar j = len - 1;\n\t\t\t\t\tpt1 = new ClipperLib.FPoint2(this.m_srcPoly[j].X + this.m_normals[j].X * delta, this.m_srcPoly[j].Y + this.m_normals[j].Y * delta);\n\t\t\t\t\tthis.m_destPoly.push(pt1);\n\t\t\t\t\tpt1 = new ClipperLib.FPoint2(this.m_srcPoly[j].X - this.m_normals[j].X * delta, this.m_srcPoly[j].Y - this.m_normals[j].Y * delta);\n\t\t\t\t\tthis.m_destPoly.push(pt1);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tvar j = len - 1;\n\t\t\t\t\tk = len - 2;\n\t\t\t\t\tthis.m_sinA = 0;\n\t\t\t\t\tthis.m_normals[j] = new ClipperLib.FPoint2(-this.m_normals[j].X, -this.m_normals[j].Y);\n\t\t\t\t\tif (node.m_endtype === ClipperLib.EndType.etOpenSquare)\n\t\t\t\t\t\tthis.DoSquare(j, k);\n\t\t\t\t\telse\n\t\t\t\t\t\tthis.DoRound(j, k);\n\t\t\t\t}\n\t\t\t\t//re-build m_normals ...\n\t\t\t\tfor (var j = len - 1; j > 0; j--)\n\t\t\t\t\tthis.m_normals[j] = new ClipperLib.FPoint2(-this.m_normals[j - 1].X, -this.m_normals[j - 1].Y);\n\t\t\t\tthis.m_normals[0] = new ClipperLib.FPoint2(-this.m_normals[1].X, -this.m_normals[1].Y);\n\t\t\t\tk = len - 1;\n\t\t\t\tfor (var j = k - 1; j > 0; --j)\n\t\t\t\t\tk = this.OffsetPoint(j, k, node.m_jointype);\n\t\t\t\tif (node.m_endtype === ClipperLib.EndType.etOpenButt)\n\t\t\t\t{\n\t\t\t\t\tpt1 = new ClipperLib.FPoint2(this.m_srcPoly[0].X - this.m_normals[0].X * delta, this.m_srcPoly[0].Y - this.m_normals[0].Y * delta);\n\t\t\t\t\tthis.m_destPoly.push(pt1);\n\t\t\t\t\tpt1 = new ClipperLib.FPoint2(this.m_srcPoly[0].X + this.m_normals[0].X * delta, this.m_srcPoly[0].Y + this.m_normals[0].Y * delta);\n\t\t\t\t\tthis.m_destPoly.push(pt1);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tk = 1;\n\t\t\t\t\tthis.m_sinA = 0;\n\t\t\t\t\tif (node.m_endtype === ClipperLib.EndType.etOpenSquare)\n\t\t\t\t\t\tthis.DoSquare(0, 1);\n\t\t\t\t\telse\n\t\t\t\t\t\tthis.DoRound(0, 1);\n\t\t\t\t}\n\t\t\t\tthis.m_destPolys.push(this.m_destPoly);\n\t\t\t}\n\t\t}\n\t};\n\n\tClipperLib.ClipperOffset.prototype.Execute = function ()\n\t{\n\t\tvar a = arguments,\n\t\t\tispolytree = a[0] instanceof ClipperLib.PolyTree;\n\t\tif (!ispolytree) // function (solution, delta)\n\t\t{\n\t\t\tvar solution = a[0],\n\t\t\t\tdelta = a[1];\n\t\t\tClipperLib.Clear(solution);\n\t\t\tthis.FixOrientations();\n\t\t\tthis.DoOffset(delta);\n\t\t\t//now clean up 'corners' ...\n\t\t\tvar clpr = new ClipperLib.Clipper(0);\n\t\t\tclpr.AddPaths(this.m_destPolys, ClipperLib.PolyType.ptSubject, true);\n\t\t\tif (delta > 0)\n\t\t\t{\n\t\t\t\tclpr.Execute(ClipperLib.ClipType.ctUnion, solution, ClipperLib.PolyFillType.pftPositive, ClipperLib.PolyFillType.pftPositive);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tvar r = ClipperLib.Clipper.GetBounds(this.m_destPolys);\n\t\t\t\tvar outer = new ClipperLib.Path();\n\t\t\t\touter.push(new ClipperLib.FPoint2(r.left - 10, r.bottom + 10));\n\t\t\t\touter.push(new ClipperLib.FPoint2(r.right + 10, r.bottom + 10));\n\t\t\t\touter.push(new ClipperLib.FPoint2(r.right + 10, r.top - 10));\n\t\t\t\touter.push(new ClipperLib.FPoint2(r.left - 10, r.top - 10));\n\t\t\t\tclpr.AddPath(outer, ClipperLib.PolyType.ptSubject, true);\n\t\t\t\tclpr.ReverseSolution = true;\n\t\t\t\tclpr.Execute(ClipperLib.ClipType.ctUnion, solution, ClipperLib.PolyFillType.pftNegative, ClipperLib.PolyFillType.pftNegative);\n\t\t\t\tif (solution.length > 0)\n\t\t\t\t\tsolution.splice(0, 1);\n\t\t\t}\n\t\t\t//console.log(JSON.stringify(solution));\n\t\t}\n\t\telse // function (polytree, delta)\n\t\t{\n\t\t\tvar solution = a[0],\n\t\t\t\tdelta = a[1];\n\t\t\tsolution.Clear();\n\t\t\tthis.FixOrientations();\n\t\t\tthis.DoOffset(delta);\n\t\t\t//now clean up 'corners' ...\n\t\t\tvar clpr = new ClipperLib.Clipper(0);\n\t\t\tclpr.AddPaths(this.m_destPolys, ClipperLib.PolyType.ptSubject, true);\n\t\t\tif (delta > 0)\n\t\t\t{\n\t\t\t\tclpr.Execute(ClipperLib.ClipType.ctUnion, solution, ClipperLib.PolyFillType.pftPositive, ClipperLib.PolyFillType.pftPositive);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tvar r = ClipperLib.Clipper.GetBounds(this.m_destPolys);\n\t\t\t\tvar outer = new ClipperLib.Path();\n\t\t\t\touter.push(new ClipperLib.FPoint2(r.left - 10, r.bottom + 10));\n\t\t\t\touter.push(new ClipperLib.FPoint2(r.right + 10, r.bottom + 10));\n\t\t\t\touter.push(new ClipperLib.FPoint2(r.right + 10, r.top - 10));\n\t\t\t\touter.push(new ClipperLib.FPoint2(r.left - 10, r.top - 10));\n\t\t\t\tclpr.AddPath(outer, ClipperLib.PolyType.ptSubject, true);\n\t\t\t\tclpr.ReverseSolution = true;\n\t\t\t\tclpr.Execute(ClipperLib.ClipType.ctUnion, solution, ClipperLib.PolyFillType.pftNegative, ClipperLib.PolyFillType.pftNegative);\n\t\t\t\t//remove the outer PolyNode rectangle ...\n\t\t\t\tif (solution.ChildCount() === 1 && solution.Childs()[0].ChildCount() > 0)\n\t\t\t\t{\n\t\t\t\t\tvar outerNode = solution.Childs()[0];\n\t\t\t\t\t//solution.Childs.set_Capacity(outerNode.ChildCount);\n\t\t\t\t\tsolution.Childs()[0] = outerNode.Childs()[0];\n\t\t\t\t\tsolution.Childs()[0].m_Parent = solution;\n\t\t\t\t\tfor (var i = 1; i < outerNode.ChildCount(); i++)\n\t\t\t\t\t\tsolution.AddChild(outerNode.Childs()[i]);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tsolution.Clear();\n\t\t\t}\n\t\t}\n\t};\n\n\tClipperLib.ClipperOffset.prototype.OffsetPoint = function (j, k, jointype)\n\t{\n\t\t//cross product ...\n\t\tthis.m_sinA = (this.m_normals[k].X * this.m_normals[j].Y - this.m_normals[j].X * this.m_normals[k].Y);\n\n\t\tif (this.m_sinA === 0)\n\t\t{\n      return k;\n\t\t}\n\n/*\n\t\telse if (this.m_sinA < 0.00005 && this.m_sinA > -0.00005)\n{\n\t\t\tconsole.log(this.m_sinA);\n      return k;\n}\n*/\n/*\n\t\tif (Math.abs(this.m_sinA * this.m_delta) < 1.0)\n\t\t{\n\t\t\t//dot product ...\n\t\t\tvar cosA = (this.m_normals[k].X * this.m_normals[j].X + this.m_normals[j].Y * this.m_normals[k].Y);\n\t\t\tif (cosA > 0) // angle ==> 0 degrees\n\t\t\t{\n\t\t\t\tthis.m_destPoly.push(new ClipperLib.FPoint2(this.m_srcPoly[j].X + this.m_normals[k].X * this.m_delta,\n\t\t\t\t\tthis.m_srcPoly[j].Y + this.m_normals[k].Y * this.m_delta));\n\t\t\t\treturn k;\n\t\t\t}\n\t\t\t//else angle ==> 180 degrees\n\t\t}\n*/\n\t\telse if (this.m_sinA > 1)\n\t\t\tthis.m_sinA = 1.0;\n\t\telse if (this.m_sinA < -1)\n\t\t\tthis.m_sinA = -1.0;\n\t\tif (this.m_sinA * this.m_delta < 0)\n\t\t{\n\t\t\tthis.m_destPoly.push(new ClipperLib.FPoint2(this.m_srcPoly[j].X + this.m_normals[k].X * this.m_delta,\n\t\t\t\tthis.m_srcPoly[j].Y + this.m_normals[k].Y * this.m_delta));\n\t\t\tthis.m_destPoly.push(new ClipperLib.FPoint1(this.m_srcPoly[j]));\n\t\t\tthis.m_destPoly.push(new ClipperLib.FPoint2(this.m_srcPoly[j].X + this.m_normals[j].X * this.m_delta,\n\t\t\t\tthis.m_srcPoly[j].Y + this.m_normals[j].Y * this.m_delta));\n\t\t}\n\t\telse\n\t\t\tswitch (jointype)\n\t\t\t{\n\t\t\tcase ClipperLib.JoinType.jtMiter:\n\t\t\t\t{\n\t\t\t\t\tvar r = 1 + (this.m_normals[j].X * this.m_normals[k].X + this.m_normals[j].Y * this.m_normals[k].Y);\n\t\t\t\t\tif (r >= this.m_miterLim)\n\t\t\t\t\t\tthis.DoMiter(j, k, r);\n\t\t\t\t\telse\n\t\t\t\t\t\tthis.DoSquare(j, k);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tcase ClipperLib.JoinType.jtSquare:\n\t\t\t\tthis.DoSquare(j, k);\n\t\t\t\tbreak;\n\t\t\tcase ClipperLib.JoinType.jtRound:\n\t\t\t\tthis.DoRound(j, k);\n\t\t\t\tbreak;\n\t\t\t}\n\t\tk = j;\n\t\treturn k;\n\t};\n\n\tClipperLib.ClipperOffset.prototype.DoSquare = function (j, k)\n\t{\n\t\tvar dx = Math.tan(Math.atan2(this.m_sinA,\n\t\t\tthis.m_normals[k].X * this.m_normals[j].X + this.m_normals[k].Y * this.m_normals[j].Y) / 4);\n\t\tthis.m_destPoly.push(new ClipperLib.FPoint2(\n\t\t\tthis.m_srcPoly[j].X + this.m_delta * (this.m_normals[k].X - this.m_normals[k].Y * dx),\n\t\t\tthis.m_srcPoly[j].Y + this.m_delta * (this.m_normals[k].Y + this.m_normals[k].X * dx)));\n\t\tthis.m_destPoly.push(new ClipperLib.FPoint2(\n\t\t\tthis.m_srcPoly[j].X + this.m_delta * (this.m_normals[j].X + this.m_normals[j].Y * dx),\n\t\t\tthis.m_srcPoly[j].Y + this.m_delta * (this.m_normals[j].Y - this.m_normals[j].X * dx)));\n\t};\n\n\tClipperLib.ClipperOffset.prototype.DoMiter = function (j, k, r)\n\t{\n\t\tvar q = this.m_delta / r;\n\t\tthis.m_destPoly.push(new ClipperLib.FPoint2(\n\t\t\tthis.m_srcPoly[j].X + (this.m_normals[k].X + this.m_normals[j].X) * q,\n\t\t\tthis.m_srcPoly[j].Y + (this.m_normals[k].Y + this.m_normals[j].Y) * q));\n\t};\n\n\tClipperLib.ClipperOffset.prototype.DoRound = function (j, k)\n\t{\n\t\tvar a = Math.atan2(this.m_sinA,\n\t\t\tthis.m_normals[k].X * this.m_normals[j].X + this.m_normals[k].Y * this.m_normals[j].Y);\n\n\t\tvar steps = Math.max(Math.round(this.m_StepsPerRad * Math.abs(a)), 1);\n\n\t\tvar X = this.m_normals[k].X,\n\t\t\tY = this.m_normals[k].Y,\n\t\t\tX2;\n\t\tfor (var i = 0; i < steps; ++i)\n\t\t{\n\t\t\tthis.m_destPoly.push(new ClipperLib.FPoint2(\n\t\t\t\tthis.m_srcPoly[j].X + X * this.m_delta,\n\t\t\t\tthis.m_srcPoly[j].Y + Y * this.m_delta));\n\t\t\tX2 = X;\n\t\t\tX = X * this.m_cos - this.m_sin * Y;\n\t\t\tY = X2 * this.m_sin + Y * this.m_cos;\n\t\t}\n\t\tthis.m_destPoly.push(new ClipperLib.FPoint2(\n\t\t\tthis.m_srcPoly[j].X + this.m_normals[j].X * this.m_delta,\n\t\t\tthis.m_srcPoly[j].Y + this.m_normals[j].Y * this.m_delta));\n\t};\n\n\tClipperLib.Error = function (message)\n\t{\n\t\ttry\n\t\t{\n\t\t\tthrow new Error(message);\n\t\t}\n\t\tcatch (err)\n\t\t{\n\t\t\talert(err.message);\n\t\t}\n\t};\n\n\t// ---------------------------------------------\n\n\t// JS extension by Timo 2013\n\tClipperLib.JS = {};\n\n\tClipperLib.JS.AreaOfPolygon = function (poly)\n\t{\n\t\treturn ClipperLib.Clipper.Area(poly);\n\t};\n\n\tClipperLib.JS.AreaOfPolygons = function (poly)\n\t{\n\t\tvar area = 0;\n\t\tfor (var i = 0; i < poly.length; i++)\n\t\t{\n\t\t\tarea += ClipperLib.Clipper.Area(poly[i]);\n\t\t}\n\t\treturn area;\n\t};\n\n\tClipperLib.JS.BoundsOfPath = function (path)\n\t{\n\t\treturn ClipperLib.JS.BoundsOfPaths([path]);\n\t};\n\n\tClipperLib.JS.BoundsOfPaths = function (paths)\n\t{\n\t\tvar bounds = ClipperLib.Clipper.GetBounds(paths);\n\t\treturn bounds;\n\t};\n\n\t// Clean() joins vertices that are too near each other\n\t// and causes distortion to offsetted polygons without cleaning\n\tClipperLib.JS.Clean = function (polygon, delta)\n\t{\n\t\tif (!(polygon instanceof Array)) return [];\n\t\tvar isPolygons = polygon[0] instanceof Array;\n\t\tvar polygon = ClipperLib.JS.Clone(polygon);\n\t\tif (typeof delta !== \"number\" || delta === null)\n\t\t{\n\t\t\tClipperLib.Error(\"Delta is not a number in Clean().\");\n\t\t\treturn polygon;\n\t\t}\n\t\tif (polygon.length === 0 || (polygon.length === 1 && polygon[0].length === 0) || delta < 0) return polygon;\n\t\tif (!isPolygons) polygon = [polygon];\n\t\tvar k_length = polygon.length;\n\t\tvar len, poly, result, d, p, j, i;\n\t\tvar results = [];\n\t\tfor (var k = 0; k < k_length; k++)\n\t\t{\n\t\t\tpoly = polygon[k];\n\t\t\tlen = poly.length;\n\t\t\tif (len === 0) continue;\n\t\t\telse if (len < 3)\n\t\t\t{\n\t\t\t\tresult = poly;\n\t\t\t\tresults.push(result);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tresult = poly;\n\t\t\td = delta * delta;\n\t\t\t//d = Math.floor(c_delta * c_delta);\n\t\t\tp = poly[0];\n\t\t\tj = 1;\n\t\t\tfor (i = 1; i < len; i++)\n\t\t\t{\n\t\t\t\tif ((poly[i].X - p.X) * (poly[i].X - p.X) +\n\t\t\t\t\t(poly[i].Y - p.Y) * (poly[i].Y - p.Y) <= d)\n\t\t\t\t\tcontinue;\n\t\t\t\tresult[j] = poly[i];\n\t\t\t\tp = poly[i];\n\t\t\t\tj++;\n\t\t\t}\n\t\t\tp = poly[j - 1];\n\t\t\tif ((poly[0].X - p.X) * (poly[0].X - p.X) +\n\t\t\t\t(poly[0].Y - p.Y) * (poly[0].Y - p.Y) <= d)\n\t\t\t\tj--;\n\t\t\tif (j < len)\n\t\t\t\tresult.splice(j, len - j);\n\t\t\tif (result.length) results.push(result);\n\t\t}\n\t\tif (!isPolygons && results.length) results = results[0];\n\t\telse if (!isPolygons && results.length === 0) results = [];\n\t\telse if (isPolygons && results.length === 0) results = [\n\t\t\t[]\n\t\t];\n\t\treturn results;\n\t}\n\t// Make deep copy of Polygons or Polygon\n\t// so that also FPoint objects are cloned and not only referenced\n\t// This should be the fastest way\n\tClipperLib.JS.Clone = function (polygon)\n\t{\n\t\tif (!(polygon instanceof Array)) return [];\n\t\tif (polygon.length === 0) return [];\n\t\telse if (polygon.length === 1 && polygon[0].length === 0) return [\n\t\t\t[]\n\t\t];\n\t\tvar isPolygons = polygon[0] instanceof Array;\n\t\tif (!isPolygons) polygon = [polygon];\n\t\tvar len = polygon.length,\n\t\t\tplen, i, j, result;\n\t\tvar results = new Array(len);\n\t\tfor (i = 0; i < len; i++)\n\t\t{\n\t\t\tplen = polygon[i].length;\n\t\t\tresult = new Array(plen);\n\t\t\tfor (j = 0; j < plen; j++)\n\t\t\t{\n\t\t\t\tresult[j] = {\n\t\t\t\t\tX: polygon[i][j].X,\n\t\t\t\t\tY: polygon[i][j].Y\n\t\t\t\t};\n\n\t\t\t}\n\t\t\tresults[i] = result;\n\t\t}\n\t\tif (!isPolygons) results = results[0];\n\t\treturn results;\n\t};\n\n\t// Removes points that doesn't affect much to the visual appearance.\n\t// If middle point is at or under certain distance (tolerance) of the line segment between\n\t// start and end point, the middle point is removed.\n\tClipperLib.JS.Lighten = function (polygon, tolerance)\n\t{\n\t\tif (!(polygon instanceof Array)) return [];\n\t\tif (typeof tolerance !== \"number\" || tolerance === null)\n\t\t{\n\t\t\tClipperLib.Error(\"Tolerance is not a number in Lighten().\")\n\t\t\treturn ClipperLib.JS.Clone(polygon);\n\t\t}\n\t\tif (polygon.length === 0 || (polygon.length === 1 && polygon[0].length === 0) || tolerance < 0)\n\t\t{\n\t\t\treturn ClipperLib.JS.Clone(polygon);\n\t\t}\n\t\tvar isPolygons = polygon[0] instanceof Array;\n\t\tif (!isPolygons) polygon = [polygon];\n\t\tvar i, j, poly, k, poly2, plen, A, B, P, d, rem, addlast;\n\t\tvar bxax, byay, l, ax, ay;\n\t\tvar len = polygon.length;\n\t\tvar toleranceSq = tolerance * tolerance;\n\t\tvar results = [];\n\t\tfor (i = 0; i < len; i++)\n\t\t{\n\t\t\tpoly = polygon[i];\n\t\t\tplen = poly.length;\n\t\t\tif (plen === 0) continue;\n\t\t\tfor (k = 0; k < 1000000; k++) // could be forever loop, but wiser to restrict max repeat count\n\t\t\t{\n\t\t\t\tpoly2 = [];\n\t\t\t\tplen = poly.length;\n\t\t\t\t// the first have to added to the end, if first and last are not the same\n\t\t\t\t// this way we ensure that also the actual last point can be removed if needed\n\t\t\t\tif (poly[plen - 1].X !== poly[0].X || poly[plen - 1].Y !== poly[0].Y)\n\t\t\t\t{\n\t\t\t\t\taddlast = 1;\n\t\t\t\t\tpoly.push(\n\t\t\t\t\t{\n\t\t\t\t\t\tX: poly[0].X,\n\t\t\t\t\t\tY: poly[0].Y\n\t\t\t\t\t});\n\t\t\t\t\tplen = poly.length;\n\t\t\t\t}\n\t\t\t\telse addlast = 0;\n\t\t\t\trem = []; // Indexes of removed points\n\t\t\t\tfor (j = 0; j < plen - 2; j++)\n\t\t\t\t{\n\t\t\t\t\tA = poly[j]; // Start point of line segment\n\t\t\t\t\tP = poly[j + 1]; // Middle point. This is the one to be removed.\n\t\t\t\t\tB = poly[j + 2]; // End point of line segment\n\t\t\t\t\tax = A.X;\n\t\t\t\t\tay = A.Y;\n\t\t\t\t\tbxax = B.X - ax;\n\t\t\t\t\tbyay = B.Y - ay;\n\t\t\t\t\tif (bxax !== 0 || byay !== 0) // To avoid Nan, when A==P && P==B. And to avoid peaks (A==B && A!=P), which have lenght, but not area.\n\t\t\t\t\t{\n\t\t\t\t\t\tl = ((P.X - ax) * bxax + (P.Y - ay) * byay) / (bxax * bxax + byay * byay);\n\t\t\t\t\t\tif (l > 1)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tax = B.X;\n\t\t\t\t\t\t\tay = B.Y;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (l > 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tax += bxax * l;\n\t\t\t\t\t\t\tay += byay * l;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbxax = P.X - ax;\n\t\t\t\t\tbyay = P.Y - ay;\n\t\t\t\t\td = bxax * bxax + byay * byay;\n\t\t\t\t\tif (d <= toleranceSq)\n\t\t\t\t\t{\n\t\t\t\t\t\trem[j + 1] = 1;\n\t\t\t\t\t\tj++; // when removed, transfer the pointer to the next one\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// add all unremoved points to poly2\n\t\t\t\tpoly2.push(\n\t\t\t\t{\n\t\t\t\t\tX: poly[0].X,\n\t\t\t\t\tY: poly[0].Y\n\t\t\t\t});\n\t\t\t\tfor (j = 1; j < plen - 1; j++)\n\t\t\t\t\tif (!rem[j]) poly2.push(\n\t\t\t\t\t{\n\t\t\t\t\t\tX: poly[j].X,\n\t\t\t\t\t\tY: poly[j].Y\n\t\t\t\t\t});\n\t\t\t\tpoly2.push(\n\t\t\t\t{\n\t\t\t\t\tX: poly[plen - 1].X,\n\t\t\t\t\tY: poly[plen - 1].Y\n\t\t\t\t});\n\t\t\t\t// if the first point was added to the end, remove it\n\t\t\t\tif (addlast) poly.pop();\n\t\t\t\t// break, if there was not anymore removed points\n\t\t\t\tif (!rem.length) break;\n\t\t\t\t// else continue looping using poly2, to check if there are points to remove\n\t\t\t\telse poly = poly2;\n\t\t\t}\n\t\t\tplen = poly2.length;\n\t\t\t// remove duplicate from end, if needed\n\t\t\tif (poly2[plen - 1].X === poly2[0].X && poly2[plen - 1].Y === poly2[0].Y)\n\t\t\t{\n\t\t\t\tpoly2.pop();\n\t\t\t}\n\t\t\tif (poly2.length > 2) // to avoid two-point-polygons\n\t\t\t\tresults.push(poly2);\n\t\t}\n\t\tif (!isPolygons)\n\t\t{\n\t\t\tresults = results[0];\n\t\t}\n\t\tif (typeof (results) === \"undefined\")\n\t\t{\n\t\t\tresults = [];\n\t\t}\n\t\treturn results;\n\t}\n\n\tClipperLib.JS.PerimeterOfPath = function (path, closed)\n\t{\n\t\tif (typeof (path) === \"undefined\") return 0;\n\t\tvar sqrt = Math.sqrt;\n\t\tvar perimeter = 0.0;\n\t\tvar p1, p2, p1x = 0.0,\n\t\t\tp1y = 0.0,\n\t\t\tp2x = 0.0,\n\t\t\tp2y = 0.0;\n\t\tvar j = path.length;\n\t\tif (j < 2) return 0;\n\t\tif (closed)\n\t\t{\n\t\t\tpath[j] = path[0];\n\t\t\tj++;\n\t\t}\n\t\twhile (--j)\n\t\t{\n\t\t\tp1 = path[j];\n\t\t\tp1x = p1.X;\n\t\t\tp1y = p1.Y;\n\t\t\tp2 = path[j - 1];\n\t\t\tp2x = p2.X;\n\t\t\tp2y = p2.Y;\n\t\t\tperimeter += sqrt((p1x - p2x) * (p1x - p2x) + (p1y - p2y) * (p1y - p2y));\n\t\t}\n\t\tif (closed) path.pop();\n\t\treturn perimeter;\n\t};\n\n\tClipperLib.JS.PerimeterOfPaths = function (paths, closed)\n\t{\n\t\tvar perimeter = 0;\n\t\tfor (var i = 0; i < paths.length; i++)\n\t\t{\n\t\t\tperimeter += ClipperLib.JS.PerimeterOfPath(paths[i], closed);\n\t\t}\n\t\treturn perimeter;\n\t};\n\n\t/**\n\t* @constructor\n\t*/\n\tClipperLib.ExPolygons = function ()\n\t{\n\t\treturn [];\n\t}\n\t/**\n\t* @constructor\n\t*/\n\tClipperLib.ExPolygon = function ()\n\t{\n\t\tthis.outer = null;\n\t\tthis.holes = null;\n\t};\n\n\tClipperLib.JS.AddOuterPolyNodeToExPolygons = function (polynode, expolygons)\n\t{\n\t\tvar ep = new ClipperLib.ExPolygon();\n\t\tep.outer = polynode.Contour();\n\t\tvar childs = polynode.Childs();\n\t\tvar ilen = childs.length;\n\t\tep.holes = new Array(ilen);\n\t\tvar node, n, i, j, childs2, jlen;\n\t\tfor (i = 0; i < ilen; i++)\n\t\t{\n\t\t\tnode = childs[i];\n\t\t\tep.holes[i] = node.Contour();\n\t\t\t//Add outer polygons contained by (nested within) holes ...\n\t\t\tfor (j = 0, childs2 = node.Childs(), jlen = childs2.length; j < jlen; j++)\n\t\t\t{\n\t\t\t\tn = childs2[j];\n\t\t\t\tClipperLib.JS.AddOuterPolyNodeToExPolygons(n, expolygons);\n\t\t\t}\n\t\t}\n\t\texpolygons.push(ep);\n\t};\n\n\tClipperLib.JS.ExPolygonsToPaths = function (expolygons)\n\t{\n\t\tvar a, i, alen, ilen;\n\t\tvar paths = new ClipperLib.Paths();\n\t\tfor (a = 0, alen = expolygons.length; a < alen; a++)\n\t\t{\n\t\t\tpaths.push(expolygons[a].outer);\n\t\t\tfor (i = 0, ilen = expolygons[a].holes.length; i < ilen; i++)\n\t\t\t{\n\t\t\t\tpaths.push(expolygons[a].holes[i]);\n\t\t\t}\n\t\t}\n\t\treturn paths;\n\t}\n\tClipperLib.JS.PolyTreeToExPolygons = function (polytree)\n\t{\n\t\tvar expolygons = new ClipperLib.ExPolygons();\n\t\tvar node, i, childs, ilen;\n\t\tfor (i = 0, childs = polytree.Childs(), ilen = childs.length; i < ilen; i++)\n\t\t{\n\t\t\tnode = childs[i];\n\t\t\tClipperLib.JS.AddOuterPolyNodeToExPolygons(node, expolygons);\n\t\t}\n\t\treturn expolygons;\n\t};\n\n})();\n","\r\nimport { ComplexPolygon } from \"./complex-polygon\";\r\n\r\nexport function polygonArea(pts) {\r\n    \r\n    if (pts.length < 3)\r\n        return 0;\r\n\r\n    let needsClose = false;\r\n    if (pts[0] !== pts[pts.length-1])\r\n        needsClose = true;\r\n\r\n    let total = 0;\r\n    for (let i=0, len=pts.length-1; i<len; i++) {\r\n        let v1 = pts[i];\r\n        let v2 = pts[i+1];\r\n        total += v1.x * v2.y - v2.x * v1.y;\r\n    }\r\n\r\n    if (needsClose) {\r\n        let v1 = pts[pts.length-1];\r\n        let v2 = pts[0];\r\n        total += v1.x * v2.y - v2.x * v1.y;\r\n    }\r\n\r\n    return total * 0.5;\r\n}\r\n\r\n\r\nlet v2 = new THREE.Vector2();\r\n\r\n\r\n//An intermediate complex polygon representation, used by the DCEL structure to compose and triangulate\r\n//complex polygons, and also to convert the polygon data to various visualization representations\r\nexport class ContourSet {\r\n\r\n    constructor() {\r\n        this.contours = [];\r\n        this.areas = [];\r\n        this.bbox = new THREE.Box2();\r\n\r\n        this.allPoints = this.pts = [];\r\n        this.allPointsMap = {};\r\n    }\r\n\r\n    addContour(verts, skipZeroAreas) {\r\n\r\n        this.polygon = null;\r\n        this.perimeterMem = undefined;\r\n\r\n        let area = polygonArea(verts);\r\n\r\n        if (area < 0) {\r\n            verts.reverse();\r\n            area = Math.abs(area);\r\n        }\r\n\r\n        let cntr = [];\r\n\r\n        verts.forEach( (v, i) => {\r\n\r\n            let id = v.id;\r\n\r\n            if (typeof id === \"undefined\") {\r\n                //Auto-assign unique vertex ID if not given -- this assumes the caller\r\n                //has cleaned up the vertex data, or the polygon is simple enough not to\r\n                //suffer from numeric issues.\r\n                id = (this.contours.length + \":\" + i);\r\n            }\r\n\r\n            let idx = this.allPointsMap[id];\r\n            if (idx === undefined) {\r\n                idx = this.allPoints.length;\r\n                this.allPoints.push(v);\r\n                this.allPointsMap[id] = idx;\r\n\r\n                v2.set(v.x, v.y);\r\n                this.bbox.expandByPoint(v2);\r\n            }\r\n            cntr.push(idx);\r\n        });\r\n\r\n        if (area === 0 && skipZeroAreas)\r\n            return;\r\n\r\n        this.contours.push(cntr);\r\n        this.areas.push(area);\r\n    }\r\n\r\n    addContourSet(cset) {\r\n\r\n        //TODO: this can be optimized to skip this pre-processing\r\n\r\n        let cntr = cset.contours[0];\r\n        let pts = cset.allPoints;\r\n\r\n        let ptlist = cntr.map(idx => pts[idx]);\r\n\r\n        this.addContour(ptlist);\r\n    }\r\n\r\n\r\n    triangulate(customInsideChecker) {\r\n\r\n        if (this.polygon)\r\n            return;\r\n\r\n        let pts = this.allPoints;\r\n\r\n        let polygon = new ComplexPolygon(pts, customInsideChecker, this.bbox);\r\n\r\n        polygon.contours = this.contours;\r\n\r\n        polygon.triangulate();\r\n\r\n        this.polygon = polygon;\r\n        this.triangulationFailed = this.polygon.triangulationFailed;\r\n    }\r\n\r\n    area() {\r\n        return this.areas[0];\r\n    }\r\n\r\n    areaNet() {\r\n        let total = this.areas[0];\r\n        for (let i=1; i<this.areas.length; i++)\r\n            total -= this.areas[i];\r\n        return total;\r\n    }\r\n\r\n    perimeter() {\r\n\r\n        if (this.perimeterMem)\r\n            return this.perimeterMem;\r\n\r\n        let total = 0;\r\n        let pts = this.contours[0];\r\n        for (let i=0, len=pts.length-1; i<len; i++) {\r\n            let v1 = pts[i];\r\n            let v2 = pts[i+1];\r\n            total += Math.sqrt((v1.x - v2.x) * (v1.x - v2.x) + (v1.y - v2.y) * (v1.y - v2.y));\r\n        }\r\n\r\n        this.perimeterMem = total;\r\n\r\n        return total;\r\n    }\r\n\r\n\r\n    getThemeColor() {\r\n        //returns a stable random-ish color value\r\n        //based on properties of the geometry,\r\n        //for use during colorized visualization of areas and volumes\r\n\r\n        let r = ((this.areas[0] * 100) % 17) / 16;\r\n        let g = (this.allPoints.length % 23) / 22;\r\n        let b = ((this.perimeterMem * 100) % 29) / 28;\r\n\r\n        return { r: r, g: g, b: b };\r\n    }\r\n\r\n    hash() {\r\n        let all = [];\r\n        this.contours.forEach(c => {\r\n            let vids = c.map(idx => this.allPoints[idx].id);\r\n            if (vids[0] === vids[vids.length-1])\r\n                vids.pop(); //remove last point that equals first point, since the same closed contour can use any of its points as a start point\r\n            vids.sort();\r\n            all.push(vids);\r\n        });\r\n        return JSON.stringify(all);\r\n    }\r\n\r\n    \r\n    stitchContours() {\r\n\r\n        //invalidate this just in case something tries to use it...\r\n        //it makes no sense for open polylines anyway\r\n        this.areas = [];\r\n\r\n        let openCntrs = [];\r\n        for (var i=0; i<this.contours.length; i++) {\r\n            let cntr = this.contours[i];\r\n            if (cntr[0] !== cntr[cntr.length-1])\r\n                openCntrs.push(cntr);\r\n        }\r\n\r\n        if (!openCntrs.length)\r\n            return;\r\n\r\n\r\n        let didSomething = true;\r\n        while (didSomething) {\r\n\r\n            didSomething = false;\r\n\r\n            //Try to combine contours\r\n            let cntr_edge_table = {};\r\n            let contours = this.contours;\r\n\r\n            for (let i=0; i<contours.length; i++) {\r\n                let cntr = contours[i];\r\n\r\n                let start = cntr[0];\r\n                let end = cntr[cntr.length-1];\r\n\r\n                if (start === end)\r\n                    continue;\r\n\r\n                if (!cntr_edge_table[start])\r\n                    cntr_edge_table[start] = [-i-1];\r\n                else\r\n                    cntr_edge_table[start].push(-i-1);\r\n\r\n\r\n                if (!cntr_edge_table[end])\r\n                    cntr_edge_table[end] = [i];\r\n                else\r\n                    cntr_edge_table[end].push(i);\r\n            }\r\n\r\n            for (let p in cntr_edge_table) {\r\n                let entry = cntr_edge_table[p];\r\n\r\n                if (entry.length === 2) {\r\n                    let toerase = undefined;\r\n\r\n                    if (entry[0] < 0 && entry[1] < 0) {\r\n                        let c1 = -entry[0]-1; let c2 = -entry[1]-1;\r\n                        //join start point to startpoint\r\n                        contours[c2].shift();\r\n                        Array.prototype.push.apply(contours[c1].reverse(),contours[c2]);\r\n                        toerase = c2;\r\n                    }\r\n\r\n                    if (entry[0] < 0 && entry[1] > 0) {\r\n                        let c1 = -entry[0]-1; let c2 = entry[1];\r\n                        //join start point to endpoint\r\n                        contours[c2].pop();\r\n                        Array.prototype.push.apply(contours[c2], contours[c1]);\r\n                        toerase = c1;\r\n                    }\r\n\r\n                    if (entry[0] > 0 && entry[1] < 0) {\r\n                        let c1 = entry[0]; let c2 = -entry[1]-1;\r\n                        //join end point to startpoint\r\n                        contours[c1].pop();\r\n                        Array.prototype.push.apply(contours[c1], contours[c2]);\r\n                        toerase = c2;\r\n                    }\r\n\r\n                    if (entry[0] > 0 && entry[1] > 0) {\r\n                        let c1 = entry[0]; let c2 = entry[1];\r\n                        //join end point to endpoint\r\n                        contours[c1].pop();\r\n                        Array.prototype.push.apply(contours[c1], contours[c2].reverse());\r\n                        toerase = c2;\r\n                    }\r\n\r\n                    if (toerase !== undefined) {\r\n                        contours.splice(toerase, 1);\r\n                        didSomething = true;\r\n                    }\r\n                    break;\r\n                }\r\n            }\r\n\r\n        }\r\n   \r\n    }\r\n\r\n\r\n    containsPointFrom(cs2) {\r\n\r\n        //Only need to check a single point from the interior of the\r\n        //potential hole. Make sure it's inside the triangulation and not on the edge\r\n        //to avoid numeric noise.\r\n        if (!cs2.polygon.indices || cs2.polygon.indices.length < 3)\r\n            return false;\r\n\r\n        let p0 = cs2.allPoints[cs2.polygon.indices[0]];\r\n        let p1 = cs2.allPoints[cs2.polygon.indices[1]];\r\n        let p2 = cs2.allPoints[cs2.polygon.indices[2]];\r\n\r\n        let cx = (p0.x + p1.x + p2.x) / 3;\r\n        let cy = (p0.y + p1.y + p2.y) / 3;\r\n\r\n        return this.polygon && this.polygon.pointInPolygon(cx, cy);\r\n    }\r\n\r\n\r\n    //creates a vertex buffer containing a filled 2D polygon for visualization on the cut plane\r\n    //as 2D polygon mesh in the 3D model space\r\n    //TODO: Use this directly from the this.polygon\r\n    toPolygonMesh(packNormals) {\r\n\r\n        return this.polygon.toPolygonMesh(packNormals);\r\n\r\n    }\r\n\r\n    //creates an extruded polygon 3d mesh\r\n    //with the given thickness (maxZ=0, minZ=-thickness)\r\n    //TODO: Use this directly from the this.polygon\r\n    toExtrudedMesh(thickness) {\r\n\r\n        return this.polygon.toExtrudedMesh(thickness);\r\n    }\r\n\r\n\r\n}\r\n\r\n\r\n\r\n\r\n","\r\nimport { isZero, TOL } from \"./fuzzy-math\";\r\n\r\nlet v1 = new THREE.Vector3();\r\n\r\nexport function xPlaneSegment(plane, pt0, pt1, res1, res2) {\r\n\r\n    let direction = v1.subVectors(pt1, pt0);\r\n\r\n    let denominator = plane.normal.dot( direction );\r\n\r\n    if ( isZero(denominator) ) {\r\n\r\n        res1.copy(pt0);\r\n        res2.copy(pt1);\r\n\r\n        // line is coplanar\r\n        return 2;\r\n    }\r\n\r\n    denominator = 1.0 / denominator;\r\n\r\n    let t = - ( pt0.dot( plane.normal ) * denominator + plane.constant * denominator);\r\n\r\n    if ( t < -TOL || t > 1 + TOL ) {\r\n\r\n        return 0;\r\n\r\n    }\r\n\r\n    let pt = direction.multiplyScalar( t ).add( pt0 );\r\n\r\n    res1.copy(pt);\r\n\r\n    return 1;\r\n}\r\n","\n\nexport const DefaultTessParams = {\n    //How many forward iterations to use when approximating Bezier curves\n    //More iterations are needed in case the min_seg_len setting below is smaller\n    //relative to mesh size. However, the two numbers need to be tuned together\n    //so that NUM_ITERATIONS is enough to result in segment lengths desired.\n\n    //Note that those values are tuned for PDF rendering, where text characters\n    //are drawn one by one. If a long piece of text is drawn all at once, then\n    //its bounding box will be quite large, so the relative min_seg_len will also\n    //be too large and the characters will look coarse. In such cases, we will need\n    //to better estimate this by using e.g. the font height only.\n    numIterations: 100,\n\n    //What fraction of the bounding sbox should be the minimum length of\n    //a segment\n    minSegLenFraction: 0.05\n};\n\nexport function SetTesselationParams(num_iterations, min_seg_len_fraction) {\n    if (num_iterations)\n        DefaultTessParams.numIterations = num_iterations;\n\n    if (min_seg_len_fraction)\n        DefaultTessParams.minSegLenFraction = min_seg_len_fraction;\n}\n\nfunction distance(x1, y1, x2, y2) {\n    return Math.sqrt((x1-x2)*(x1-x2) + (y1-y2)*(y1-y2));\n}\n\nfunction adjustMaxdim(maxdim, segLength) {\n    if(maxdim > 4 * segLength && segLength > 0) {\n        var time = Math.sqrt(maxdim / segLength);\n        time = Math.min(4, time);\n        maxdim = segLength * time ;\n    }\n    return maxdim;\n}\n\nexport function TesselateCubic(ctx, px1, py1, px2, py2, px3, py3, px4, py4, maxdim, tessParams, isFont)\n{\n    tessParams = tessParams || DefaultTessParams;\n\n    var aproximateLength = distance(px1, py1, px2, py2) + distance(px2, py2, px3, py3) + distance(px3, py3, px4, py4);\n\n    // maxdim is the size of the bounds of the path\n    // but for individual path, we need to use aproximateLength\n    // we need to balance both performance and visual effect\n    // so we leverage both value and try to balance it.\n    if(!isFont) {\n        maxdim = adjustMaxdim(maxdim, aproximateLength);\n    }\n\n    //we will base the max number of segments to use for approximation\n    //on the bounds of the full line buffer contents\n    //TODO: as an improvement we could take the bounds of this particular curve\n    //with respect to the full bounds of the line buffer data.\n    maxdim = maxdim || (1/tessParams.minSegLenFraction);\n\n    //minimum length of tesselation segment\n    //set to 1/100 of the bounds\n    var minSegLen = maxdim * tessParams.minSegLenFraction;\n\n    //but for now we will iterate 100 times\n    var dt = 1.0 / tessParams.numIterations;\n\n    //double dt2 = dt*dt;\n    var dt3 = dt * dt * dt;\n\n    var pre1 = 3.0 * dt;\n    var pre2 = pre1 * dt;\n    var pre3 = pre2 + pre2;\n    var pre4 = 6.0 * dt3;\n\n    var temp1x = px1 - 2.0 * px2 + px3;\n    var temp1y = py1 - 2.0 * py2 + py3;\n    var temp2x = 3.0 * (px2 - px3) - px1 + px4;\n    var temp2y = 3.0 * (py2 - py3) - py1 + py4;\n\n    var fx    = px1;\n    var fy    = py1;\n    var dfx   = (px2 - px1) * pre1 + temp1x * pre2 + temp2x * dt3;\n    var dfy   = (py2 - py1) * pre1 + temp1y * pre2 + temp2y * dt3;\n    var ddfx  = temp1x * pre3 + temp2x * pre4;\n    var ddfy  = temp1y * pre3 + temp2y * pre4;\n    var dddfx = temp2x * pre4;\n    var dddfy = temp2y * pre4;\n\n    var error = 0.0;\n\n    // forward differencing loop\n    var tMax = 0|(1.0/dt - 0.5);\n    for (var t=0; t<tMax; t++)\n    {\n        fx   += dfx;\n        fy   += dfy;\n        dfx  += ddfx;\n        dfy  += ddfy;\n        ddfy += dddfy;\n        ddfx += dddfx;\n\n        error += Math.sqrt(dfx*dfx+dfy*dfy);\n\n        if (error >= minSegLen)  //add segment only if we have reached treshold length\n        {\n            // line to current\n            ctx.lineTo(fx, fy);\n            error = 0.0;\n        }\n    }\n\n    ctx.lineTo(px4, py4);\n}\n\nexport function TesselateQuad(ctx, px1, py1, px2, py2, px3, py3, maxdim, tessParams, isFont)\n{\n    tessParams = tessParams || DefaultTessParams;\n\n    var aproximateLength = distance(px1, py1, px2, py2) + distance(px2, py2, px3, py3);\n\n    // maxdim is the size of the bounds of the path\n    // but for individual path, we need to use aproximateLength\n    // we need to balance both performance and visual effect\n    // so we leverage both value and try to balance it.\n    if(!isFont) {\n        maxdim = adjustMaxdim(maxdim, aproximateLength);\n    }\n\n    //we will base the max number of segments to use for approximation\n    //on the bounds of the full line buffer contents\n    //TODO: as an improvement we could take the bounds of this particular curve\n    //with respect to the full bounds of the line buffer data.\n    maxdim = maxdim || (1/tessParams.minSegLenFraction);\n\n    //minimum length of tesselation segment\n    //set to a fraction of the bbox of the entire path (value chosen to work well for text at reasonable font size)\n    var minSegLen = maxdim * tessParams.minSegLenFraction;\n\n    //but for now we will iterate 100 times\n    var dt = 1.0 / tessParams.numIterations;\n\n    var dt2 = dt*dt;\n\n    var ax = px1 - 2.0*px2 + px3;        //replace 2* by addition?\n    var ay = py1 - 2.0*py2 + py3;        //replace 2* by addition?\n\n    var bx = 2.0*(px2-px1);\n    var by = 2.0*(py2-py1);\n\n    var fx   = px1;\n    var fy   = py1;\n    var dfx  = bx*dt + ax*dt2;\n    var dfy  = by*dt + ay*dt2;\n    var ddfx = 2.0*ax*dt2;\n    var ddfy = 2.0*ay*dt2;\n\n    var error = 0.0;\n\n    //forward differencing loop\n    var tMax = 0|(1.0/dt - 0.5);\n    for (var t=0; t<tMax; t++)\n    {\n        fx   += dfx;\n        fy   += dfy;\n        dfx  += ddfx;\n        dfy  += ddfy;\n\n        error += Math.sqrt(dfx*dfx + dfy*dfy);\n\n        if (error >= minSegLen)  // how many pixels should each line be?)\n        {\n            ctx.lineTo(fx, fy);\n            error = 0.0;\n        }\n    }\n\n    ctx.lineTo(px3, py3);\n}\n\n// Cubic Bezier for single points. Note that TesselateCubic is faster by using deltas.\n// Result is returned as a new {x,y} or written to optionalTarget.\nexport function getCubeBezierPoint(t, px1, py1, px2, py2, px3, py3, px4, py4, optionalTarget) {\n\n    var result = optionalTarget || {x: undefined, y: undefined};\n\n    let k = 1-t;\n\n    // Bernstein coefficients\n    let bp1 = k * k * k;\n    let bp2 = 3 * k * k * t;\n    let bp3 = 3 * k * t * t;\n    let bp4 = t * t * t;\n\n    result.x = bp1 * px1 + bp2 * px2 + bp3 * px3 + bp4 * px4;\n    result.y = bp1 * py1 + bp2 * py2 + bp3 * py3 + bp4 * py4;\n\n    return result;\n}\n\n\n","import ClipperLib from \"clipper-lib-fpoint\";\nimport Earcut from \"earcut\";\nimport { TesselateQuad, TesselateCubic, DefaultTessParams } from \"./bezier\";\n\n//Helper for converting complex HTML Canvas paths to simple polylines / polygons\n\n\n const  MOVETO  = 0,\n        LINETO  = 1,\n        ARC     = 2,\n        ARCTO   = 3,\n        QUADTO  = 4,\n        CUBICTO = 5,\n        ELLIPSE = 6,\n        CLOSE   = 7;\n\n\nlet _v2 = new THREE.Vector2();\nlet _tmpBox = new THREE.Box2();\n\n// Tmp objct for Ellipse Arcs. We need delayed initialization, \n// because Autodesk.Extensions.CompGeom might not be available yet at compile time.\nlet _tmpArc = null;\nlet getTmpArc = () => {\n    _tmpArc = _tmpArc || new Autodesk.Extensions.CompGeom.EllipseArc();\n    return _tmpArc;\n};\n\nexport function Path2D(precisionTolerance) {\n    this.segTypes = [];\n    this.segData = [];\n    this.hasCurves = false;\n    this.bbox = new THREE.Box2();\n    this.precisionTolerance = precisionTolerance;\n}\n\n// Optional: Use custom tesselation params for bezier arcs. Undefined sets to default.\nPath2D.prototype.setTessParams = function(tessParams) {\n    this.tessParams = tessParams;\n};\n\nPath2D.prototype.closePath = function() {\n    if (this.segTypes.length && this.segTypes[this.segTypes.length - 1] === CLOSE)\n        return;\n    this.segTypes.push(CLOSE);\n};\n\n\nPath2D.prototype.moveTo = function(x, y) {\n    this.segTypes.push(MOVETO);\n    this.segData.push(x, y);\n\n    this.bbox.expandByPoint(_v2.set(x,y));\n};\n\nPath2D.prototype.lineTo = function(x, y) {\n    this.segTypes.push(LINETO);\n    this.segData.push(x, y);\n\n    this.bbox.expandByPoint(_v2.set(x,y));\n};\n\nPath2D.prototype.arc = function(x, y, radius, startAngle, endAngle, anticlockwise) {\n    this.hasCurves = true;\n    this.segTypes.push(ARC);\n    this.segData.push(x, y, radius, startAngle, endAngle, anticlockwise);\n\n    this.bbox.expandByPoint(_v2.set(x,y)); //TODO: all corners\n};\n\nPath2D.prototype.arcTo = function(x1, y1, x2, y2, radius) {\n    this.hasCurves = true;\n    this.segTypes.push(ARCTO);\n    this.segData.push(x1, y1, x2, y2, radius);\n\n    this.bbox.expandByPoint(_v2.set(x1,y1));\n    this.bbox.expandByPoint(_v2.set(x2,y2));\n};\n\nPath2D.prototype.quadraticCurveTo = function(cp1x, cp1y, x, y) {\n    this.hasCurves = true;\n    this.segTypes.push(QUADTO);\n    this.segData.push(cp1x, cp1y, x, y);\n\n    this.bbox.expandByPoint(_v2.set(cp1x,cp1y));\n    this.bbox.expandByPoint(_v2.set(x,y));\n};\n\nPath2D.prototype.bezierCurveTo = function(cp1x, cp1y, cp2x, cp2y, x, y) {\n    this.hasCurves = true;\n    this.segTypes.push(CUBICTO);\n    this.segData.push(cp1x, cp1y, cp2x, cp2y, x, y);\n    this.bbox.expandByPoint(_v2.set(cp1x,cp1y));\n    this.bbox.expandByPoint(_v2.set(cp2x,cp2y));\n    this.bbox.expandByPoint(_v2.set(x,y));\n};\n\n// for params, see https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/ellipse\nPath2D.prototype.ellipse = function(cx, cy, rx, ry, rotation, startAngle, endAngle, ccw) {\n\n    this.hasCurves = true;\n    this.segTypes.push(ELLIPSE);\n    this.segData.push(cx, cy, rx, ry, rotation, startAngle, endAngle, ccw);\n\n    // consider arc in bbox\n    const arcBox = getTmpArc().set(cx, cy, rx, ry, rotation, startAngle, endAngle, ccw).computeBBox(_tmpBox);\n    this.bbox.union(arcBox);\n};\n\nPath2D.prototype.flatten = function(forceCloseContours) {\n\n    var ret = new Path2D(this.precisionTolerance);\n\n    var dataOffset = 0;\n    var lastX = 0;\n    var lastY = 0;\n    var contourStartX = lastX;\n    var contourStartY = lastY;\n\n    var segTypes = this.segTypes;\n    var segData = this.segData;\n\n    var sz = this.bbox.size().length();\n\n    for (var i=0; i<segTypes.length; i++) {\n\n        var st = segTypes[i];\n\n        switch(st) {\n\n            case MOVETO: {\n                    if (forceCloseContours) {\n                        if (lastX !== contourStartX || lastY !== contourStartY) {\n                            ret.closePath();\n                        }\n                    }\n\n                    lastX = segData[dataOffset++];\n                    lastY = segData[dataOffset++];\n                    contourStartX = lastX;\n                    contourStartY = lastY;\n                    ret.moveTo(lastX, lastY);\n                }\n                break;\n            case CLOSE:\n                ret.closePath();\n                break;\n            case LINETO: {\n                    var x = segData[dataOffset++];\n                    var y = segData[dataOffset++];\n\n                    if (x !== lastX || y !== lastY) {\n                        ret.lineTo(x, y);\n\n                        lastX = x;\n                        lastY = y;\n                    }\n                }\n                break;\n            case QUADTO: {\n                    const cp1x = segData[dataOffset++], cp1y = segData[dataOffset++],\n                        x = segData[dataOffset++], y = segData[dataOffset++];\n                    TesselateQuad(ret, lastX, lastY, cp1x, cp1y, x, y, sz, this.tessParams, !!this.isFontChar);                    \n\n                    lastX = x;\n                    lastY = y;\n                }\n                break;\n            case CUBICTO: {\n                    const cp1x = segData[dataOffset++], cp1y = segData[dataOffset++],\n                        cp2x = segData[dataOffset++], cp2y = segData[dataOffset++],\n                        x = segData[dataOffset++], y = segData[dataOffset++];\n                    TesselateCubic(ret, lastX, lastY, cp1x, cp1y, cp2x, cp2y, x, y, sz, this.tessParams, !!this.isFontChar);\n                    lastX = x;\n                    lastY = y;\n                }\n                break;\n            case ARC:\n                console.warn(\"not implemented: arc\");\n                dataOffset += 6;\n                break;\n            case ARCTO:\n                console.warn(\"not implemented: arcto\");\n                dataOffset += 4;\n                break;\n            case ELLIPSE: {\n                    // read ellipse params\n                    var cx = segData[dataOffset++];\n                    var cy = segData[dataOffset++];\n                    var rx = segData[dataOffset++];\n                    var ry = segData[dataOffset++];\n                    var rotation   = segData[dataOffset++];\n                    var startAngle = segData[dataOffset++];\n                    var endAngle   = segData[dataOffset++];\n                    var ccw        = segData[dataOffset++];\n\n                    // determine tesselation params\n                    const tessParams       = this.tessParams || DefaultTessParams;\n                    const maxSegments      = tessParams.numIterations;\n                    const minSegmentLength = tessParams.minSegLenFraction * sz;\n                    \n                    // tesselate arc\n                    const arc = getTmpArc().set(cx, cy, rx, ry, rotation, startAngle, endAngle, ccw);\n                    arc.tesselate(ret, maxSegments, minSegmentLength);\n\n                    // Update lastX/lastY\n                    // The last lineTo() appends x and y of the end position to ret.segData. \n                    // So, we can always extract it from there.\n                    lastX = ret.segData[ret.segData.length-2];\n                    lastY = ret.segData[ret.segData.length-1];\n                }\n                break;\n        }\n    }\n\n    if (forceCloseContours) {\n        if (lastX !== contourStartX || lastY !== contourStartY) {\n            ret.closePath();\n        }\n    }\n\n    return ret;\n};\n\nPath2D.prototype.applyTransform = function(loader, xform) {\n\n    for (let i=0; i<this.segData.length; i+=2) {\n\n        let x = this.segData[i];\n        let y = this.segData[i+1];\n\n        this.segData[i] = loader.tx(x, y, xform);\n        this.segData[i+1] = loader.ty(x, y, xform);\n    }\n};\n\nPath2D.prototype.stroke = function (loader, lineWidth, color, dbId, layerId, clipPathIn, applyTransform, lineStyle) {\n    var needClipping = clipPathIn != null;\n    let subjFlatted = this;\n    if (applyTransform || this.hasCurves) {\n        subjFlatted = this.flatten(false);\n    }\n\n    var self = this;\n    // check weather we can do simple path\n    if (needClipping) {\n        var subPaths = [];\n        var subPath;\n        var segIndex = 0;\n        for (var i = 0; i < subjFlatted.segTypes.length; i++) {\n            if (subjFlatted.segTypes[i] == MOVETO) {\n                subPath = new Path2D(this.precisionTolerance);\n                subPaths.push(subPath);\n                subPath.moveTo(subjFlatted.segData[segIndex++], subjFlatted.segData[segIndex++]);\n            } else if (subjFlatted.segTypes[i] == LINETO) {\n                subPath?.lineTo(subjFlatted.segData[segIndex++], subjFlatted.segData[segIndex++]);\n            } else if (subjFlatted.segTypes[i] == CLOSE) {\n                subPath?.closePath();\n            }\n        }\n\n        var clipFlatted = clipPathIn.flattened || clipPathIn.flatten(true);\n        var clips = clipFlatted.toClipperPath(loader, false);\n        subPaths.map((subPath) => {\n            // still need to do a check for each subPath\n            var subPreResult = self.preCheckForClipping(loader, clipFlatted, subPath, applyTransform, true);\n            if (subPreResult.needCancel) {\n                return;\n            } else if (subPreResult.needClipping) {\n                var myPath = subPath.toClipperPath(loader, applyTransform)[0];\n                if (!myPath) {\n                    return;\n                }\n                \n                if (ClipperLib.Clipper.Orientation(myPath)) {\n                    // LMV-5983\n                    // turn closed paths to clockwise orientation\n                    // to workaround a problem where anticlockwise self-intersecting paths ended up with\n                    // a different order of vertices after clipping\n                    myPath.reverse();\n                }\n\n                var solution = new ClipperLib.PolyTree();\n                var cpr = new ClipperLib.Clipper();\n                // if the path is closed, but we set the open flag, it will cause infinity loop\n                let closed = myPath[0].X == myPath[myPath.length - 1].X && myPath[0].Y == myPath[myPath.length - 1].Y;\n                cpr.AddPath(myPath, ClipperLib.PolyType.ptSubject, closed);\n                cpr.AddPaths(clips, ClipperLib.PolyType.ptClip, true);\n\n                cpr.Execute(ClipperLib.ClipType.ctIntersection, solution, ClipperLib.PolyFillType.pftEvenOdd, ClipperLib.PolyFillType.pftEvenOdd);\n                strokeClipperSolution(solution);\n            } else {\n                this.strokeFlattedPath(loader, subPath, lineWidth, color, dbId, layerId, applyTransform, lineStyle);\n            }\n        });\n    } else {\n        // just draw all the segments\n        this.strokeFlattedPath(loader, subjFlatted, lineWidth, color, dbId, layerId, applyTransform, lineStyle);\n    }\n\n    function strokeClipperSolution(solution) {\n        var node = solution.GetFirst();\n        while (node) {\n            self.strokeClipperContour(loader, node.Contour(), node.IsOpen, color, lineWidth, dbId, layerId, loader.currentVpId, lineStyle, false);\n            node = node.GetNext();\n        }\n    }\n};\n\nPath2D.prototype.strokeFlattedPath = function (loader, flatted, lineWidth, color, dbId, layerId, applyTransform, lineStyle) {\n    let segData = flatted.segData;\n    let segTypes = flatted.segTypes;\n\n    let xform;\n    if (applyTransform) {\n        xform = loader.getCurrentTransform();\n    }\n\n    var dataOffset = 0;\n    var lastX = 0;\n    var lastY = 0;\n    var contourStartX = 0;\n    var contourStartY = 0;\n\n    for (var i = 0; i < segTypes.length; i++) {\n\n        var st = segTypes[i];\n\n        switch (st) {\n\n            case MOVETO: {\n                let tmpx = segData[dataOffset++];\n                let tmpy = segData[dataOffset++];\n\n                if (applyTransform) {\n                    contourStartX = loader.tx(tmpx, tmpy, xform);\n                    contourStartY = loader.ty(tmpx, tmpy, xform);\n                } else {\n                    contourStartX = tmpx;\n                    contourStartY = tmpy;\n                }\n\n                lastX = contourStartX;\n                lastY = contourStartY;\n            }\n                break;\n            case CLOSE:\n            case LINETO: {\n                let x, y;\n                if (st === CLOSE) {\n                    x = contourStartX;\n                    y = contourStartY;\n                } else {\n                    let tmpx = segData[dataOffset++];\n                    let tmpy = segData[dataOffset++];\n\n                    if (applyTransform) {\n                        x = loader.tx(tmpx, tmpy, xform);\n                        y = loader.ty(tmpx, tmpy, xform);\n                    } else {\n                        x = tmpx;\n                        y = tmpy;\n                    }\n                }\n                \n                // LMV-5336 - Paths that contain a moveTo and a lineTo at the same X, Y positions were not being drawn.\n                // Add the segment when the previous operation was moveTo.\n                const isPrevMoveTo = i > 0 && segTypes[i - 1] === MOVETO;\n                if (x !== lastX || y !== lastY || isPrevMoveTo) {\n\n                    //Use centerpoint for the initial inside check for better numeric stability,\n                    //in case the start point is exactly on the clip polygon's edge, in which case the inside\n                    //check would return a random result\n\n                    //Segment is either completely inside or completely outside (does not intersect the clip path at all)\n                    loader.flushBuffer(4);\n\n                    loader.currentVbb.addSegment(lastX, lastY, x, y,\n                                    /*totalDistance*/0, lineWidth, color, dbId, layerId, loader.currentVpId || 0, lineStyle\n                    );\n\n                    lastX = x;\n                    lastY = y;\n                }\n            }\n                break;\n            default: {\n                console.error(\"Path must be flattened before rendering\");\n            }\n        }\n    }\n};\n\nPath2D.prototype.strokeClipperContour = function (loader, contour, isOpen, color, lineWidth, dbId, layerId, vpId, lineStyle, applyTransform) {\n    let l = contour.length;\n    let lastIndex = isOpen ? 0 : l - 1;\n    let startIndex = isOpen ? 1 : 0;\n    let xform;\n    if (applyTransform) {\n        xform = loader.getCurrentTransform();\n    }\n    let lastx = applyTransform ? loader.tx(contour[lastIndex].X, contour[lastIndex].Y, xform) : contour[lastIndex].X;\n    let lasty = applyTransform ? loader.ty(contour[lastIndex].X, contour[lastIndex].Y, xform) : contour[lastIndex].Y;\n    for (var i = startIndex; i < l; i++) {\n        let x = applyTransform ? loader.tx(contour[i].X, contour[i].Y, xform) : contour[i].X;\n        let y = applyTransform ? loader.ty(contour[i].X, contour[i].Y, xform) : contour[i].Y;\n\n        loader.flushBuffer(4);\n        loader.currentVbb.addSegment(lastx, lasty, x, y, 0, lineWidth, color, dbId, layerId, vpId, lineStyle);\n        lastx = x, lasty = y;\n    }\n};\n\n//Checks if the path is a simple AABB.\n//Used to speed up polygon clipping operations.\nPath2D.prototype.isAABB = function() {\n\n    const EPS = 1e-10;\n    const ANGLE_EPS = 1e-3;\n\n    let st = this.segTypes;\n\n    if (st.length !== 6 && st.length !== 5)\n        return false;\n\n    if (st[0] !== MOVETO)\n        return false;\n\n    if (st.length === 6 && st[5] !== CLOSE)\n        return false;\n    else if (st.length === 5 && (st[4] !== CLOSE && st[4] !== LINETO))\n        return false;\n\n    for (let i=1; i<st.length-1; i++)\n        if (st[i] !== LINETO)\n            return false;\n\n\n    let seg = this.segData;\n\n    //check segments 1 and 3 for parallel and same length\n    let dxA = seg[2] - seg[0];\n    let dyA = seg[3] - seg[1];\n    let dxC = seg[6] - seg[4];\n    let dyC = seg[7] - seg[5];\n    let lenA = Math.sqrt(dxA*dxA + dyA*dyA);\n    let lenC = Math.sqrt(dxC*dxC + dyC*dyC);\n\n    if (Math.abs(lenA - lenC) > EPS)\n        return false;\n\n    dxA /= lenA; dyA /= lenA;\n    dxC /= lenC; dyC /= lenC;\n    let dot = dxA*dxC + dyA*dyC;\n\n    if (Math.abs(1 + dot) > ANGLE_EPS)\n        return false;\n\n    //check segments 2 and 4 for parallel and same length\n    let dxB = seg[4] - seg[2];\n    let dyB = seg[5] - seg[3];\n    let dxD = seg[8] - seg[6];\n    let dyD = seg[9] - seg[7];\n    let lenB = Math.sqrt(dxB*dxB + dyB*dyB);\n    let lenD = Math.sqrt(dxD*dxD + dyD*dyD);\n\n    if (Math.abs(lenB - lenD) > EPS)\n        return false;\n\n    dxB /= lenB; dyB /= lenB;\n    dxD /= lenD; dyD /= lenD;\n    dot = dxB*dxD + dyB*dyD;\n\n    if (Math.abs(1 + dot) > ANGLE_EPS)\n        return false;\n\n    //make sure there is a right angle\n    dot = dxA*dxB + dyA*dyB;\n\n    if (Math.abs(dot) > ANGLE_EPS)\n        return false;\n\n    //make sure segments are vertical/horizontal\n    if (Math.abs(dxA) > EPS && Math.abs(dyA))\n        return false;\n\n    return true;\n};\n\nconst INSIDE = 1;\nconst OUTSIDE = 2;\nconst UNKNOWN = 4;\n\nfunction bboxOverlap(clipBox, pathBox, precisionTolerance) {\n\n    if (clipBox.containsBox(pathBox))\n        return INSIDE;\n\n    //The above AABB containment check is exact\n    //and sometimes misses cases where the bboxes are\n    //almost exactly equal, with very slight numeric noise in the values\n    //(which happens quite often with Revit PDFs)\n\n    //So now do another check if our bbox contains the input bbox within a tolerance\n    let EPS = precisionTolerance;\n\n    if (EPS === undefined) {\n        EPS = 1e-3 / clipBox.size().length();\n    }\n\n    if (pathBox.min.x - clipBox.max.x > EPS)\n        return OUTSIDE;\n    if ((pathBox.min.y - clipBox.min.y) > EPS)\n        return OUTSIDE;\n\n    if ((pathBox.max.x - clipBox.max.x) < -EPS)\n        return OUTSIDE;\n    if ((pathBox.max.y - clipBox.max.y) < -EPS)\n        return OUTSIDE;\n\n    if ((pathBox.min.x - clipBox.min.x) < -EPS)\n        return UNKNOWN;\n    if ((pathBox.min.y - clipBox.min.y) < -EPS)\n        return UNKNOWN;\n\n    if ((pathBox.max.x - clipBox.max.x) > EPS)\n        return UNKNOWN;\n    if ((pathBox.max.y - clipBox.max.y) > EPS)\n        return UNKNOWN;\n\n    return INSIDE;\n}\n\nPath2D.prototype.isAABBContain = function(bbox) {\n\n    if (!this.isAABB())\n        return UNKNOWN;\n\n    return bboxOverlap(this.bbox, bbox, this.precisionTolerance);\n};\n\n\nPath2D.prototype.clip = function (clipPathIn, mode) {\n    var clipFlatted = clipPathIn.flattened || clipPathIn.flatten(true);\n    var subjFlatted = this.flattened || this.flatten(true);\n\n    var preResult = this.preCheckForClipping(null, clipFlatted, subjFlatted, false, false);\n    if (preResult.needCancel) {\n        console.warn(\"No overlap between nested clip regions.\");\n        return new Path2D();\n    } else if (preResult.needClipping == false) {\n        if (preResult.needSwapSubject) {\n            return clipPathIn;\n        } else {\n            return this;\n        }\n    } else {\n        // do the clipping here\n        var clips = clipFlatted.toClipperPath(null, false);\n        var myPath = subjFlatted.toClipperPath(null, false);\n\n        var solution = new ClipperLib.PolyTree();\n        var cpr = new ClipperLib.Clipper();\n        cpr.AddPaths(myPath, ClipperLib.PolyType.ptSubject, true);\n        cpr.AddPaths(clips, ClipperLib.PolyType.ptClip, true);\n\n        cpr.Execute(ClipperLib.ClipType.ctIntersection, solution, ClipperLib.PolyFillType.pftEvenOdd, ClipperLib.PolyFillType.pftEvenOdd);\n\n        // need to rebuild a path from the solution, no need to do the tesselation\n        let res = new Path2D(this.precisionTolerance);\n        var node = solution.GetFirst();\n        while (node) {\n            var contour = node.Contour();\n            for (var i = 0; i < contour.length; i++) {\n                if (i == 0) {\n                    res.moveTo(contour[i].X, contour[i].Y);\n                } else {\n                    res.lineTo(contour[i].X, contour[i].Y);\n                }\n            }\n\n            if (contour[contour.length - 1].X != contour[0].X || contour[contour.length - 1].Y != contour[0].Y) {\n                res.lineTo(contour[0].X, contour[0].Y);\n            }\n            node = node.GetNext();\n        }\n        return res;\n    }\n};\n\n/**\n * If segments type is 0, 1, 0, 1 pattern, we should avoid to do fill to it\n * Most of the time, it wants to be line segments, but from 2D, you can always pass a fill/stroke command to it.\n * Eatch MoveTo should start with a segment.\n */\nPath2D.prototype.isFillable = function () {\n    //Skip some easily detectable degenerate polygons that result in no fill\n    let p = this.flattened || this.flatten(true);\n    if (p.segTypes.length < 3) {\n        return false;\n    } else if (p.segTypes.length === 3) {\n        if (p.segTypes[2] === CLOSE\n            && p.segTypes[1] === LINETO\n            && p.segTypes[0] === MOVETO) {\n            return false;\n        }\n    } else {\n        var isFillable = false;\n\n        for (var i = 0; i < p.segTypes.length; i += 2) {\n            if (!(p.segTypes[i] == MOVETO && p.segTypes[i + 1] == LINETO)) {\n                isFillable = true;\n                break;\n            }\n        }\n        return isFillable;\n    }\n};\n\nPath2D.prototype.fill = function (loader, color, dbId, layerId, clipPathIn, applyTransform, isFillStrokeCombo) {\n    if(!this.isFillable()) {\n        return;\n    }\n\n    let subjFlatted = this.flattened || this.flatten(true);\n    var self = this;\n\n    function clipProcess() {\n        var needClipping = clipPathIn != null;\n        var needSwapSubject = false;\n        // check weather we can do simple path\n        if (needClipping) {\n            var clipFlatted = clipPathIn.flattened || clipPathIn.flatten(true);\n\n            var preResult = self.preCheckForClipping(loader, clipFlatted, subjFlatted, applyTransform, false);\n            if (preResult.needCancel) {\n                return;\n            }\n\n            needClipping = preResult.needClipping;\n            needSwapSubject = preResult.needSwapSubject;\n        }\n\n        if (needClipping) {\n            const clipFlatted = clipPathIn.flattened || clipPathIn.flatten(true);\n            var clips = clipFlatted.toClipperPath(loader, false);\n            var myPath = subjFlatted.toClipperPath(loader, applyTransform);\n\n            var solution = new ClipperLib.PolyTree();\n            var cpr = new ClipperLib.Clipper();\n            cpr.AddPaths(myPath, ClipperLib.PolyType.ptSubject, true);\n            cpr.AddPaths(clips, ClipperLib.PolyType.ptClip, true);\n\n            cpr.Execute(ClipperLib.ClipType.ctIntersection, solution, ClipperLib.PolyFillType.pftEvenOdd, ClipperLib.PolyFillType.pftEvenOdd);\n\n            var polygons = self.getPolygonFromClipperSolution(solution);\n            return {\n                polygons,\n                appliedTransform: applyTransform,\n                needClipping\n            };\n        } else {\n            // if we use clip path directly as subject, we can not cache it, and should not apply transform to it\n            subjFlatted = !needSwapSubject ? subjFlatted : clipFlatted;\n            if (self.cached) {\n                return {\n                    polygons: self.cached,\n                    appliedTransform: false,\n                    needClipping,\n                    subjFlatted\n                };\n            } else {\n                const myPath = subjFlatted.toClipperPath(loader, false);\n\n                const solution = new ClipperLib.PolyTree();\n                const cpr = new ClipperLib.Clipper();\n                cpr.AddPaths(myPath, ClipperLib.PolyType.ptSubject, true);\n                cpr.Execute(ClipperLib.ClipType.ctUnion, solution, ClipperLib.PolyFillType.pftEvenOdd, ClipperLib.PolyFillType.pftEvenOdd);\n                const polygons = self.getPolygonFromClipperSolution(solution);\n                if (!needSwapSubject) {\n                    self.cached = polygons;\n                }\n                return {\n                    polygons,\n                    appliedTransform: needSwapSubject,      // clipPath has already applied transform\n                    needClipping,\n                    subjFlatted\n                };\n            }\n        }\n    }\n\n    function fillPolygon(polygon, needApplytransform, needClipping) {\n        var vertices = polygon.vertices;\n\n        if (needApplytransform) {\n            var xform = loader.getCurrentTransform();\n            var vertices1 = [];\n            for (var i = 0; i < vertices.length; i += 2) {\n                let x = loader.tx(vertices[i], vertices[i + 1], xform);\n                let y = loader.ty(vertices[i], vertices[i + 1], xform);\n                vertices1.push(x, y);\n            }\n            vertices = vertices1;\n        }\n        loader.addPolyTriangle(vertices, polygon.indices, color, dbId, layerId, false);\n\n        // do the antialias stroke here\n        if (!isFillStrokeCombo) {\n            if (needClipping || !self.isFontChar) {\n                for (var c in polygon.contours) {\n                    self.strokeClipperContour(loader, polygon.contours[c], true, color, -0.5, dbId, layerId, loader.currentVpId, 0, needApplytransform);\n                }\n            } else {\n                // stroke the line with the original flatted path\n                self.strokeFlattedPath(loader, result.subjFlatted, -0.5, color, dbId, layerId, needApplytransform, 0);\n            }\n        }\n    }\n\n    var result = clipProcess();\n    if (result) {\n        result.polygons.map((polygon) => {\n            var needApplytransform = applyTransform && !result.appliedTransform;\n            fillPolygon(polygon, needApplytransform, result.needClipping);\n        });\n    }\n};\n\n\nPath2D.prototype.toClipperPath = function (loader, applyTransform) {\n    var paths = [];\n    var path = [];\n    var segTypes = this.segTypes;\n    var segData = this.segData;\n    var segIndex = 0;\n    var xform;\n    if (applyTransform) {\n        xform = loader.getCurrentTransform();\n    }\n\n    function addPoint(path, point) {\n        if (applyTransform) {\n            let x = loader.tx(point.X, point.Y, xform);\n            let y = loader.ty(point.X, point.Y, xform);\n            point.X = x;\n            point.Y = y;\n        }\n\n        if ((path.length > 0 && (path[path.length - 1].X != point.X || path[path.length - 1].Y != point.Y)) || path.length == 0) {\n            path.push(point);\n        }\n    }\n\n    for (var i = 0; i < segTypes.length; i++) {\n        if (segTypes[i] == MOVETO) {\n            if (path && path.length > 1) {\n                paths.push(path);\n            }\n            path = [];\n            addPoint(path, { X: segData[segIndex++], Y: segData[segIndex++] });\n        } else if (segTypes[i] == LINETO) {\n            addPoint(path, { X: segData[segIndex++], Y: segData[segIndex++] });\n        } else if (segTypes[i] == CLOSE) {\n            path.push({ X: path[0].X, Y: path[0].Y });\n            paths.push(path);\n            path = [];\n        }\n    }\n\n    if (path && path.length > 1) {\n        paths.push(path);\n    }\n\n    return paths;\n};\n\nPath2D.prototype.hasIntersection = function (box1, box2, tolerance) {\n    return !(box1.max.x - box2.min.x <= -tolerance ||   // left\n        box1.max.y - box2.min.y <= -tolerance ||   // bottom\n        box1.min.x - box2.max.x >= tolerance ||   // right\n        box1.min.y - box2.max.y >= tolerance);    // top\n};\n\nPath2D.prototype.preCheckForClipping = function (loader, clipFlatted, subjFlatted, applyTransform, strokeOnly) {\n    var clipBound = clipFlatted.bbox;\n    var subjBound = subjFlatted.bbox;\n\n    if (applyTransform) {\n        let xform = loader.getCurrentTransform();\n        // we need to apply transform to the subject bounds\n        subjBound = loader.transformBox(subjBound, xform, _tmpBox);\n    }\n\n    // do a simple check if two bounds has no overlap, set need cancel to true\n    if (!this.hasIntersection(clipBound, subjBound, this.precisionTolerance)) {\n        return {\n            needCancel: true\n        };\n    } else if (clipFlatted.isAABB() && clipBound.containsBox(subjBound)) {\n        return {\n            needClipping: false\n        };\n    }\n    else if (subjFlatted.isAABB() && subjBound.containsBox(clipBound)) {\n        // there is nothing to stroke\n        if (strokeOnly) {\n            return {\n                needCancel: true\n            };\n        } else {\n            return {\n                needClipping: false,\n                needSwapSubject: true\n            };\n        }\n    }\n    else {\n        return {\n            needClipping: true\n        };\n    }\n};\n\nPath2D.prototype.getPolygonFromClipperSolution = function (solution) {\n    function addContour(contours, vertices, contour) {\n        for (var i = 0; i < contour.length; i++) {\n            vertices.push(contour[i].X, contour[i].Y);\n        }\n        contours.push(contour);\n    }\n\n    var exPolygons = ClipperLib.JS.PolyTreeToExPolygons(solution);\n    var polygons = exPolygons.map((item) => {\n        var vertices = [];\n        var holeIndices = [];\n        var contours = [];\n\n        // clipper library has some defect when we use 4 thickline to construct a rectangle with border\n        // It flipped the hole and outer\n        // Add this logic to flip it back to the correct value\n        if(item.holes.length == 1 && Math.abs(ClipperLib.JS.AreaOfPolygons(item.holes)) > Math.abs(ClipperLib.JS.AreaOfPolygon(item.outer))) {\n            let temp = item.holes[0];\n            item.holes[0] = item.outer;\n            item.outer = temp;\n        }\n        addContour(contours, vertices, item.outer);\n\n        item.holes.map((hole) => {\n            holeIndices.push(vertices.length / 2);\n            addContour(contours, vertices, hole);\n        });\n\n        var indices = Earcut(vertices, holeIndices);\n        return {\n            vertices,\n            indices,\n            holeIndices,\n            contours\n        };\n    });\n\n    return polygons;\n};\n\n\nPath2D.prototype.msdfClipping = function(clipFlatted) {\n    var subjFlatted = this.flattened || this.flatten(true);\n    var myPath = subjFlatted.toClipperPath(null, false);\n    var clips = clipFlatted.toClipperPath(null, false);\n\n    var solution = new ClipperLib.PolyTree();\n    var cpr = new ClipperLib.Clipper();\n    cpr.AddPaths(myPath, ClipperLib.PolyType.ptSubject, true);\n    cpr.AddPaths(clips, ClipperLib.PolyType.ptClip, true);\n\n    cpr.Execute(ClipperLib.ClipType.ctIntersection, solution, ClipperLib.PolyFillType.pftEvenOdd, ClipperLib.PolyFillType.pftEvenOdd);\n\n    return this.getPolygonFromClipperSolution(solution);\n};","var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n","\r\nconst INSIDE = 0; // 0000\r\nconst LEFT = 1;   // 0001\r\nconst RIGHT = 2;  // 0010\r\nconst BOTTOM = 4; // 0100\r\nconst TOP = 8;    // 1000\r\n\r\n// Compute the bit code for a point (x, y) using the clip rectangle\r\n// bounded diagonally by (xmin, ymin), and (xmax, ymax)\r\n\r\nfunction ComputeOutCode(x, y, xmin, ymin, xmax, ymax)\r\n{\r\n\tlet code;\r\n\r\n\tcode = INSIDE;          // initialised as being inside of [[clip window]]\r\n\r\n\tif (x < xmin)           // to the left of clip window\r\n\t\tcode |= LEFT;\r\n\telse if (x > xmax)      // to the right of clip window\r\n\t\tcode |= RIGHT;\r\n\tif (y < ymin)           // below the clip window\r\n\t\tcode |= BOTTOM;\r\n\telse if (y > ymax)      // above the clip window\r\n\t\tcode |= TOP;\r\n\r\n\treturn code;\r\n}\r\n\r\n// CohenSutherland clipping algorithm clips a line from\r\n// P0 = (x0, y0) to P1 = (x1, y1) against a rectangle with\r\n// diagonal from (xmin, ymin) to (xmax, ymax).\r\nexport function xLineBox(x0, y0, x1, y1, xmin, ymin, xmax, ymax)\r\n{\r\n\t// compute outcodes for P0, P1, and whatever point lies outside the clip rectangle\r\n\tlet outcode0 = ComputeOutCode(x0, y0, xmin, ymin, xmax, ymax);\r\n\tlet outcode1 = ComputeOutCode(x1, y1, xmin, ymin, xmax, ymax);\r\n\tlet accept = false;\r\n\r\n\t// eslint-disable-next-line no-constant-condition\r\n\twhile (true) {\r\n\t\tif (!(outcode0 | outcode1)) {\r\n\t\t\t// bitwise OR is 0: both points inside window; trivially accept and exit loop\r\n\t\t\taccept = true;\r\n\t\t\tbreak;\r\n\t\t} else if (outcode0 & outcode1) {\r\n\t\t\t// bitwise AND is not 0: both points share an outside zone (LEFT, RIGHT, TOP,\r\n\t\t\t// or BOTTOM), so both must be outside window; exit loop (accept is false)\r\n\t\t\tbreak;\r\n\t\t} else {\r\n\t\t\t// failed both tests, so calculate the line segment to clip\r\n\t\t\t// from an outside point to an intersection with clip edge\r\n\t\t\tlet x, y;\r\n\r\n\t\t\t// At least one endpoint is outside the clip rectangle; pick it.\r\n\t\t\tlet outcodeOut = outcode0 ? outcode0 : outcode1;\r\n\r\n\t\t\t// Now find the intersection point;\r\n\t\t\t// use formulas:\r\n\t\t\t//   slope = (y1 - y0) / (x1 - x0)\r\n\t\t\t//   x = x0 + (1 / slope) * (ym - y0), where ym is ymin or ymax\r\n\t\t\t//   y = y0 + slope * (xm - x0), where xm is xmin or xmax\r\n\t\t\t// No need to worry about divide-by-zero because, in each case, the\r\n\t\t\t// outcode bit being tested guarantees the denominator is non-zero\r\n\t\t\tif (outcodeOut & TOP) {           // point is above the clip window\r\n\t\t\t\tx = x0 + (x1 - x0) * (ymax - y0) / (y1 - y0);\r\n\t\t\t\ty = ymax;\r\n\t\t\t} else if (outcodeOut & BOTTOM) { // point is below the clip window\r\n\t\t\t\tx = x0 + (x1 - x0) * (ymin - y0) / (y1 - y0);\r\n\t\t\t\ty = ymin;\r\n\t\t\t} else if (outcodeOut & RIGHT) {  // point is to the right of clip window\r\n\t\t\t\ty = y0 + (y1 - y0) * (xmax - x0) / (x1 - x0);\r\n\t\t\t\tx = xmax;\r\n\t\t\t} else if (outcodeOut & LEFT) {   // point is to the left of clip window\r\n\t\t\t\ty = y0 + (y1 - y0) * (xmin - x0) / (x1 - x0);\r\n\t\t\t\tx = xmin;\r\n\t\t\t}\r\n\r\n\t\t\t// Now we move outside point to intersection point to clip\r\n\t\t\t// and get ready for next pass.\r\n\t\t\tif (outcodeOut === outcode0) {\r\n\t\t\t\tx0 = x;\r\n\t\t\t\ty0 = y;\r\n\t\t\t\toutcode0 = ComputeOutCode(x0, y0, xmin, ymin, xmax, ymax);\r\n\t\t\t} else {\r\n\t\t\t\tx1 = x;\r\n\t\t\t\ty1 = y;\r\n\t\t\t\toutcode1 = ComputeOutCode(x1, y1, xmin, ymin, xmax, ymax);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\treturn accept;\r\n}\r\n\r\n","\r\nexport function xBoxBox(minx1, miny1, maxx1, maxy1,\r\n                 minx2, miny2, maxx2, maxy2) {\r\n\r\n    return ((minx1 <= maxx2)\r\n        && (miny1 <= maxy2)\r\n        && (maxx1 >= minx2)\r\n        && (maxy1 >= miny2));\r\n\r\n}\r\n","/*\n * Poly2Tri Copyright (c) 2009-2014, Poly2Tri Contributors\n * http://code.google.com/p/poly2tri/\n * \n * poly2tri.js (JavaScript port) (c) 2009-2014, Poly2Tri Contributors\n * https://github.com/r3mi/poly2tri.js\n * \n * All rights reserved.\n * \n * Distributed under the 3-clause BSD License, see LICENSE.txt\n */\n\n\"use strict\";\n\n/*\n * Class added in the JavaScript version (was not present in the c++ version)\n */\n\nvar xy = require('./xy');\n\n/**\n * Custom exception class to indicate invalid Point values\n * @constructor\n * @public\n * @extends Error\n * @struct\n * @param {string=} message - error message\n * @param {Array.<XY>=} points - invalid points\n */\nvar PointError = function(message, points) {\n    this.name = \"PointError\";\n    /**\n     * Invalid points\n     * @public\n     * @type {Array.<XY>}\n     */\n    this.points = points = points || [];\n    /**\n     * Error message\n     * @public\n     * @type {string}\n     */\n    this.message = message || \"Invalid Points!\";\n    for (var i = 0; i < points.length; i++) {\n        this.message += \" \" + xy.toString(points[i]);\n    }\n};\nPointError.prototype = new Error();\nPointError.prototype.constructor = PointError;\n\n\nmodule.exports = PointError;\n","/*\n * Poly2Tri Copyright (c) 2009-2014, Poly2Tri Contributors\n * http://code.google.com/p/poly2tri/\n * \n * poly2tri.js (JavaScript port) (c) 2009-2014, Poly2Tri Contributors\n * https://github.com/r3mi/poly2tri.js\n * \n * All rights reserved.\n * \n * Distributed under the 3-clause BSD License, see LICENSE.txt\n */\n\n\"use strict\";\n\n/**\n * The following functions operate on \"Point\" or any \"Point like\" object with {x,y},\n * as defined by the {@link XY} type\n * ([duck typing]{@link http://en.wikipedia.org/wiki/Duck_typing}).\n * @module\n * @private\n */\n\n/**\n * poly2tri.js supports using custom point class instead of {@linkcode Point}.\n * Any \"Point like\" object with <code>{x, y}</code> attributes is supported\n * to initialize the SweepContext polylines and points\n * ([duck typing]{@link http://en.wikipedia.org/wiki/Duck_typing}).\n *\n * poly2tri.js might add extra fields to the point objects when computing the\n * triangulation : they are prefixed with <code>_p2t_</code> to avoid collisions\n * with fields in the custom class.\n *\n * @example\n *      var contour = [{x:100, y:100}, {x:100, y:300}, {x:300, y:300}, {x:300, y:100}];\n *      var swctx = new poly2tri.SweepContext(contour);\n *\n * @typedef {Object} XY\n * @property {number} x - x coordinate\n * @property {number} y - y coordinate\n */\n\n\n/**\n * Point pretty printing : prints x and y coordinates.\n * @example\n *      xy.toStringBase({x:5, y:42})\n *      //  \"(5;42)\"\n * @protected\n * @param {!XY} p - point object with {x,y}\n * @returns {string} <code>\"(x;y)\"</code>\n */\nfunction toStringBase(p) {\n    return (\"(\" + p.x + \";\" + p.y + \")\");\n}\n\n/**\n * Point pretty printing. Delegates to the point's custom \"toString()\" method if exists,\n * else simply prints x and y coordinates.\n * @example\n *      xy.toString({x:5, y:42})\n *      //  \"(5;42)\"\n * @example\n *      xy.toString({x:5,y:42,toString:function() {return this.x+\":\"+this.y;}})\n *      //  \"5:42\"\n * @param {!XY} p - point object with {x,y}\n * @returns {string} <code>\"(x;y)\"</code>\n */\nfunction toString(p) {\n    // Try a custom toString first, and fallback to own implementation if none\n    var s = p.toString();\n    return (s === '[object Object]' ? toStringBase(p) : s);\n}\n\n\n/**\n * Compare two points component-wise. Ordered by y axis first, then x axis.\n * @param {!XY} a - point object with {x,y}\n * @param {!XY} b - point object with {x,y}\n * @return {number} <code>&lt; 0</code> if <code>a &lt; b</code>,\n *         <code>&gt; 0</code> if <code>a &gt; b</code>, \n *         <code>0</code> otherwise.\n */\nfunction compare(a, b) {\n    if (a.y === b.y) {\n        return a.x - b.x;\n    } else {\n        return a.y - b.y;\n    }\n}\n\n/**\n * Test two Point objects for equality.\n * @param {!XY} a - point object with {x,y}\n * @param {!XY} b - point object with {x,y}\n * @return {boolean} <code>True</code> if <code>a == b</code>, <code>false</code> otherwise.\n */\nfunction equals(a, b) {\n    return a.x === b.x && a.y === b.y;\n}\n\n\nmodule.exports = {\n    toString: toString,\n    toStringBase: toStringBase,\n    compare: compare,\n    equals: equals\n};\n","/*\n * Poly2Tri Copyright (c) 2009-2014, Poly2Tri Contributors\n * http://code.google.com/p/poly2tri/\n * \n * poly2tri.js (JavaScript port) (c) 2009-2014, Poly2Tri Contributors\n * https://github.com/r3mi/poly2tri.js\n *\n * All rights reserved.\n * \n * Distributed under the 3-clause BSD License, see LICENSE.txt\n */\n\n/* jshint maxcomplexity:10 */\n\n\"use strict\";\n\n\n/*\n * Note\n * ====\n * the structure of this JavaScript version of poly2tri intentionally follows\n * as closely as possible the structure of the reference C++ version, to make it \n * easier to keep the 2 versions in sync.\n */\n\nvar xy = require(\"./xy\");\n\n\n// ---------------------------------------------------------------------Triangle\n/**\n * Triangle class.<br>\n * Triangle-based data structures are known to have better performance than\n * quad-edge structures.\n * See: J. Shewchuk, \"Triangle: Engineering a 2D Quality Mesh Generator and\n * Delaunay Triangulator\", \"Triangulations in CGAL\"\n *\n * @constructor\n * @struct\n * @param {!XY} pa  point object with {x,y}\n * @param {!XY} pb  point object with {x,y}\n * @param {!XY} pc  point object with {x,y}\n */\nvar Triangle = function(a, b, c) {\n    /**\n     * Triangle points\n     * @private\n     * @type {Array.<XY>}\n     */\n    this.points_ = [a, b, c];\n\n    /**\n     * Neighbor list\n     * @private\n     * @type {Array.<Triangle>}\n     */\n    this.neighbors_ = [null, null, null];\n\n    /**\n     * Has this triangle been marked as an interior triangle?\n     * @private\n     * @type {boolean}\n     */\n    this.interior_ = false;\n\n    /**\n     * Flags to determine if an edge is a Constrained edge\n     * @private\n     * @type {Array.<boolean>}\n     */\n    this.constrained_edge = [false, false, false];\n\n    /**\n     * Flags to determine if an edge is a Delauney edge\n     * @private\n     * @type {Array.<boolean>}\n     */\n    this.delaunay_edge = [false, false, false];\n};\n\nvar p2s = xy.toString;\n/**\n * For pretty printing ex. <code>\"[(5;42)(10;20)(21;30)]\"</code>.\n * @public\n * @return {string}\n */\nTriangle.prototype.toString = function() {\n    return (\"[\" + p2s(this.points_[0]) + p2s(this.points_[1]) + p2s(this.points_[2]) + \"]\");\n};\n\n/**\n * Get one vertice of the triangle.\n * The output triangles of a triangulation have vertices which are references\n * to the initial input points (not copies): any custom fields in the\n * initial points can be retrieved in the output triangles.\n * @example\n *      var contour = [{x:100, y:100, id:1}, {x:100, y:300, id:2}, {x:300, y:300, id:3}];\n *      var swctx = new poly2tri.SweepContext(contour);\n *      swctx.triangulate();\n *      var triangles = swctx.getTriangles();\n *      typeof triangles[0].getPoint(0).id\n *      //  \"number\"\n * @param {number} index - vertice index: 0, 1 or 2\n * @public\n * @returns {XY}\n */\nTriangle.prototype.getPoint = function(index) {\n    return this.points_[index];\n};\n\n/**\n * For backward compatibility\n * @function\n * @deprecated use {@linkcode Triangle#getPoint} instead\n */\nTriangle.prototype.GetPoint = Triangle.prototype.getPoint;\n\n/**\n * Get all 3 vertices of the triangle as an array\n * @public\n * @return {Array.<XY>}\n */\n// Method added in the JavaScript version (was not present in the c++ version)\nTriangle.prototype.getPoints = function() {\n    return this.points_;\n};\n\n/**\n * @private\n * @param {number} index\n * @returns {?Triangle}\n */\nTriangle.prototype.getNeighbor = function(index) {\n    return this.neighbors_[index];\n};\n\n/**\n * Test if this Triangle contains the Point object given as parameter as one of its vertices.\n * Only point references are compared, not values.\n * @public\n * @param {XY} point - point object with {x,y}\n * @return {boolean} <code>True</code> if the Point object is of the Triangle's vertices,\n *         <code>false</code> otherwise.\n */\nTriangle.prototype.containsPoint = function(point) {\n    var points = this.points_;\n    // Here we are comparing point references, not values\n    return (point === points[0] || point === points[1] || point === points[2]);\n};\n\n/**\n * Test if this Triangle contains the Edge object given as parameter as its\n * bounding edges. Only point references are compared, not values.\n * @private\n * @param {Edge} edge\n * @return {boolean} <code>True</code> if the Edge object is of the Triangle's bounding\n *         edges, <code>false</code> otherwise.\n */\nTriangle.prototype.containsEdge = function(edge) {\n    return this.containsPoint(edge.p) && this.containsPoint(edge.q);\n};\n\n/**\n * Test if this Triangle contains the two Point objects given as parameters among its vertices.\n * Only point references are compared, not values.\n * @param {XY} p1 - point object with {x,y}\n * @param {XY} p2 - point object with {x,y}\n * @return {boolean}\n */\nTriangle.prototype.containsPoints = function(p1, p2) {\n    return this.containsPoint(p1) && this.containsPoint(p2);\n};\n\n/**\n * Has this triangle been marked as an interior triangle?\n * @returns {boolean}\n */\nTriangle.prototype.isInterior = function() {\n    return this.interior_;\n};\n\n/**\n * Mark this triangle as an interior triangle\n * @private\n * @param {boolean} interior\n * @returns {Triangle} this\n */\nTriangle.prototype.setInterior = function(interior) {\n    this.interior_ = interior;\n    return this;\n};\n\n/**\n * Update neighbor pointers.\n * @private\n * @param {XY} p1 - point object with {x,y}\n * @param {XY} p2 - point object with {x,y}\n * @param {Triangle} t Triangle object.\n * @throws {Error} if can't find objects\n */\nTriangle.prototype.markNeighborPointers = function(p1, p2, t) {\n    var points = this.points_;\n    // Here we are comparing point references, not values\n    if ((p1 === points[2] && p2 === points[1]) || (p1 === points[1] && p2 === points[2])) {\n        this.neighbors_[0] = t;\n    } else if ((p1 === points[0] && p2 === points[2]) || (p1 === points[2] && p2 === points[0])) {\n        this.neighbors_[1] = t;\n    } else if ((p1 === points[0] && p2 === points[1]) || (p1 === points[1] && p2 === points[0])) {\n        this.neighbors_[2] = t;\n    } else {\n        throw new Error('poly2tri Invalid Triangle.markNeighborPointers() call');\n    }\n};\n\n/**\n * Exhaustive search to update neighbor pointers\n * @private\n * @param {!Triangle} t\n */\nTriangle.prototype.markNeighbor = function(t) {\n    var points = this.points_;\n    if (t.containsPoints(points[1], points[2])) {\n        this.neighbors_[0] = t;\n        t.markNeighborPointers(points[1], points[2], this);\n    } else if (t.containsPoints(points[0], points[2])) {\n        this.neighbors_[1] = t;\n        t.markNeighborPointers(points[0], points[2], this);\n    } else if (t.containsPoints(points[0], points[1])) {\n        this.neighbors_[2] = t;\n        t.markNeighborPointers(points[0], points[1], this);\n    }\n};\n\n\nTriangle.prototype.clearNeighbors = function() {\n    this.neighbors_[0] = null;\n    this.neighbors_[1] = null;\n    this.neighbors_[2] = null;\n};\n\nTriangle.prototype.clearDelaunayEdges = function() {\n    this.delaunay_edge[0] = false;\n    this.delaunay_edge[1] = false;\n    this.delaunay_edge[2] = false;\n};\n\n/**\n * Returns the point clockwise to the given point.\n * @private\n * @param {XY} p - point object with {x,y}\n */\nTriangle.prototype.pointCW = function(p) {\n    var points = this.points_;\n    // Here we are comparing point references, not values\n    if (p === points[0]) {\n        return points[2];\n    } else if (p === points[1]) {\n        return points[0];\n    } else if (p === points[2]) {\n        return points[1];\n    } else {\n        return null;\n    }\n};\n\n/**\n * Returns the point counter-clockwise to the given point.\n * @private\n * @param {XY} p - point object with {x,y}\n */\nTriangle.prototype.pointCCW = function(p) {\n    var points = this.points_;\n    // Here we are comparing point references, not values\n    if (p === points[0]) {\n        return points[1];\n    } else if (p === points[1]) {\n        return points[2];\n    } else if (p === points[2]) {\n        return points[0];\n    } else {\n        return null;\n    }\n};\n\n/**\n * Returns the neighbor clockwise to given point.\n * @private\n * @param {XY} p - point object with {x,y}\n */\nTriangle.prototype.neighborCW = function(p) {\n    // Here we are comparing point references, not values\n    if (p === this.points_[0]) {\n        return this.neighbors_[1];\n    } else if (p === this.points_[1]) {\n        return this.neighbors_[2];\n    } else {\n        return this.neighbors_[0];\n    }\n};\n\n/**\n * Returns the neighbor counter-clockwise to given point.\n * @private\n * @param {XY} p - point object with {x,y}\n */\nTriangle.prototype.neighborCCW = function(p) {\n    // Here we are comparing point references, not values\n    if (p === this.points_[0]) {\n        return this.neighbors_[2];\n    } else if (p === this.points_[1]) {\n        return this.neighbors_[0];\n    } else {\n        return this.neighbors_[1];\n    }\n};\n\nTriangle.prototype.getConstrainedEdgeCW = function(p) {\n    // Here we are comparing point references, not values\n    if (p === this.points_[0]) {\n        return this.constrained_edge[1];\n    } else if (p === this.points_[1]) {\n        return this.constrained_edge[2];\n    } else {\n        return this.constrained_edge[0];\n    }\n};\n\nTriangle.prototype.getConstrainedEdgeCCW = function(p) {\n    // Here we are comparing point references, not values\n    if (p === this.points_[0]) {\n        return this.constrained_edge[2];\n    } else if (p === this.points_[1]) {\n        return this.constrained_edge[0];\n    } else {\n        return this.constrained_edge[1];\n    }\n};\n\n// Additional check from Java version (see issue #88)\nTriangle.prototype.getConstrainedEdgeAcross = function(p) {\n    // Here we are comparing point references, not values\n    if (p === this.points_[0]) {\n        return this.constrained_edge[0];\n    } else if (p === this.points_[1]) {\n        return this.constrained_edge[1];\n    } else {\n        return this.constrained_edge[2];\n    }\n};\n\nTriangle.prototype.setConstrainedEdgeCW = function(p, ce) {\n    // Here we are comparing point references, not values\n    if (p === this.points_[0]) {\n        this.constrained_edge[1] = ce;\n    } else if (p === this.points_[1]) {\n        this.constrained_edge[2] = ce;\n    } else {\n        this.constrained_edge[0] = ce;\n    }\n};\n\nTriangle.prototype.setConstrainedEdgeCCW = function(p, ce) {\n    // Here we are comparing point references, not values\n    if (p === this.points_[0]) {\n        this.constrained_edge[2] = ce;\n    } else if (p === this.points_[1]) {\n        this.constrained_edge[0] = ce;\n    } else {\n        this.constrained_edge[1] = ce;\n    }\n};\n\nTriangle.prototype.getDelaunayEdgeCW = function(p) {\n    // Here we are comparing point references, not values\n    if (p === this.points_[0]) {\n        return this.delaunay_edge[1];\n    } else if (p === this.points_[1]) {\n        return this.delaunay_edge[2];\n    } else {\n        return this.delaunay_edge[0];\n    }\n};\n\nTriangle.prototype.getDelaunayEdgeCCW = function(p) {\n    // Here we are comparing point references, not values\n    if (p === this.points_[0]) {\n        return this.delaunay_edge[2];\n    } else if (p === this.points_[1]) {\n        return this.delaunay_edge[0];\n    } else {\n        return this.delaunay_edge[1];\n    }\n};\n\nTriangle.prototype.setDelaunayEdgeCW = function(p, e) {\n    // Here we are comparing point references, not values\n    if (p === this.points_[0]) {\n        this.delaunay_edge[1] = e;\n    } else if (p === this.points_[1]) {\n        this.delaunay_edge[2] = e;\n    } else {\n        this.delaunay_edge[0] = e;\n    }\n};\n\nTriangle.prototype.setDelaunayEdgeCCW = function(p, e) {\n    // Here we are comparing point references, not values\n    if (p === this.points_[0]) {\n        this.delaunay_edge[2] = e;\n    } else if (p === this.points_[1]) {\n        this.delaunay_edge[0] = e;\n    } else {\n        this.delaunay_edge[1] = e;\n    }\n};\n\n/**\n * The neighbor across to given point.\n * @private\n * @param {XY} p - point object with {x,y}\n * @returns {Triangle}\n */\nTriangle.prototype.neighborAcross = function(p) {\n    // Here we are comparing point references, not values\n    if (p === this.points_[0]) {\n        return this.neighbors_[0];\n    } else if (p === this.points_[1]) {\n        return this.neighbors_[1];\n    } else {\n        return this.neighbors_[2];\n    }\n};\n\n/**\n * @private\n * @param {!Triangle} t Triangle object.\n * @param {XY} p - point object with {x,y}\n */\nTriangle.prototype.oppositePoint = function(t, p) {\n    var cw = t.pointCW(p);\n    return this.pointCW(cw);\n};\n\n/**\n * Legalize triangle by rotating clockwise around oPoint\n * @private\n * @param {XY} opoint - point object with {x,y}\n * @param {XY} npoint - point object with {x,y}\n * @throws {Error} if oPoint can not be found\n */\nTriangle.prototype.legalize = function(opoint, npoint) {\n    var points = this.points_;\n    // Here we are comparing point references, not values\n    if (opoint === points[0]) {\n        points[1] = points[0];\n        points[0] = points[2];\n        points[2] = npoint;\n    } else if (opoint === points[1]) {\n        points[2] = points[1];\n        points[1] = points[0];\n        points[0] = npoint;\n    } else if (opoint === points[2]) {\n        points[0] = points[2];\n        points[2] = points[1];\n        points[1] = npoint;\n    } else {\n        throw new Error('poly2tri Invalid Triangle.legalize() call');\n    }\n};\n\n/**\n * Returns the index of a point in the triangle. \n * The point *must* be a reference to one of the triangle's vertices.\n * @private\n * @param {XY} p - point object with {x,y}\n * @returns {number} index 0, 1 or 2\n * @throws {Error} if p can not be found\n */\nTriangle.prototype.index = function(p) {\n    var points = this.points_;\n    // Here we are comparing point references, not values\n    if (p === points[0]) {\n        return 0;\n    } else if (p === points[1]) {\n        return 1;\n    } else if (p === points[2]) {\n        return 2;\n    } else {\n        throw new Error('poly2tri Invalid Triangle.index() call');\n    }\n};\n\n/**\n * @private\n * @param {XY} p1 - point object with {x,y}\n * @param {XY} p2 - point object with {x,y}\n * @return {number} index 0, 1 or 2, or -1 if errror\n */\nTriangle.prototype.edgeIndex = function(p1, p2) {\n    var points = this.points_;\n    // Here we are comparing point references, not values\n    if (p1 === points[0]) {\n        if (p2 === points[1]) {\n            return 2;\n        } else if (p2 === points[2]) {\n            return 1;\n        }\n    } else if (p1 === points[1]) {\n        if (p2 === points[2]) {\n            return 0;\n        } else if (p2 === points[0]) {\n            return 2;\n        }\n    } else if (p1 === points[2]) {\n        if (p2 === points[0]) {\n            return 1;\n        } else if (p2 === points[1]) {\n            return 0;\n        }\n    }\n    return -1;\n};\n\n/**\n * Mark an edge of this triangle as constrained.\n * @private\n * @param {number} index - edge index\n */\nTriangle.prototype.markConstrainedEdgeByIndex = function(index) {\n    this.constrained_edge[index] = true;\n};\n/**\n * Mark an edge of this triangle as constrained.\n * @private\n * @param {Edge} edge instance\n */\nTriangle.prototype.markConstrainedEdgeByEdge = function(edge) {\n    this.markConstrainedEdgeByPoints(edge.p, edge.q);\n};\n/**\n * Mark an edge of this triangle as constrained.\n * This method takes two Point instances defining the edge of the triangle.\n * @private\n * @param {XY} p - point object with {x,y}\n * @param {XY} q - point object with {x,y}\n */\nTriangle.prototype.markConstrainedEdgeByPoints = function(p, q) {\n    var points = this.points_;\n    // Here we are comparing point references, not values        \n    if ((q === points[0] && p === points[1]) || (q === points[1] && p === points[0])) {\n        this.constrained_edge[2] = true;\n    } else if ((q === points[0] && p === points[2]) || (q === points[2] && p === points[0])) {\n        this.constrained_edge[1] = true;\n    } else if ((q === points[1] && p === points[2]) || (q === points[2] && p === points[1])) {\n        this.constrained_edge[0] = true;\n    }\n};\n\n\n// ---------------------------------------------------------Exports (public API)\n\nmodule.exports = Triangle;\n","\r\nexport const TOL = 1e-6;\r\n\r\nexport function isZero(f) {\r\n    return Math.abs(f) < TOL;\r\n}\r\n\r\nexport function isEqual(a, b) {\r\n    return isZero(a - b);\r\n}"],"sourceRoot":""}