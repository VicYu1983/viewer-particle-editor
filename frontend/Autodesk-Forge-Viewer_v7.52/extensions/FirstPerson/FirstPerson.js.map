{"version":3,"file":"FirstPerson/FirstPerson.js","sources":["webpack://Autodesk.Extensions.[name]/webpack/bootstrap","webpack://Autodesk.Extensions.[name]/./extensions/FirstPerson/FirstPerson.js","webpack://Autodesk.Extensions.[name]/./extensions/FirstPerson/FirstPersonTool.js","webpack://Autodesk.Extensions.[name]/./extensions/Gamepad/GamepadModule.js"],"sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./extensions/FirstPerson/FirstPerson.js\");\n","import { FirstPersonTool } from './FirstPersonTool';\n\n//\n// First Person\n//\n\n'use strict';\n\n/**\n               * First Person navigation tool, similar to those found in videogames.\n               *\n               * It will also replace the default walk tool button when {@link Autodesk.Viewing.GuiViewer3D} is present.\n               * @constructor\n               * @see {@link Autodesk.Viewing.Extension} for common inherited methods.\n               * @param {Autodesk.Viewing.Viewer3D} viewer - Viewer instance.\n               * @param {object} options - Not used.\n               */\nexport function FirstPersonExtension(viewer, options) {\n  Autodesk.Viewing.Extension.call(this, viewer, options);\n  this.name = \"firstperson\";\n}\n\nFirstPersonExtension.prototype = Object.create(Autodesk.Viewing.Extension.prototype);\nFirstPersonExtension.prototype.constructor = FirstPersonExtension;\n\nvar proto = FirstPersonExtension.prototype;\n\nproto.load = function () {\n  var self = this;\n  var viewer = this.viewer;\n  var avu = Autodesk.Viewing.UI;\n\n  // Register tool\n  this.tool = new FirstPersonTool(viewer);\n  viewer.toolController.registerTool(this.tool);\n\n  // Add the ui to the viewer.\n  this.createUI();\n  // Register listeners\n  this.onToolChanged = function (e) {\n    if (e.toolName.indexOf('firstperson') === -1) {\n      return;\n    }\n    if (self.firstPersonToolButton) {\n      var state = e.active ? avu.Button.State.ACTIVE : avu.Button.State.INACTIVE;\n      self.firstPersonToolButton.setState(state);\n    }\n  };\n\n  viewer.addEventListener(Autodesk.Viewing.TOOL_CHANGE_EVENT, this.onToolChanged);\n\n  return true;\n};\n\nproto.createUI = function ()\n{\n  var viewer = this.viewer;\n  if (!viewer.getToolbar) return; // Adds support for Viewer3D instance\n\n  var self = this;\n  var avu = Autodesk.Viewing.UI;\n  var toolbar = viewer.getToolbar();\n  var navTools = toolbar.getControl(Autodesk.Viewing.TOOLBAR.NAVTOOLSID);\n\n  // Create a button for the tool.\n  this.firstPersonToolButton = new avu.Button('toolbar-firstPersonTool');\n  this.firstPersonToolButton.setToolTip('First person');\n  this.firstPersonToolButton.onClick = function () {\n    if (self.activeStatus) {\n      self.deactivate();\n    } else\n    {\n      self.activate();\n    }\n  };\n  this.firstPersonToolButton.setIcon(\"adsk-icon-first-person\");\n\n  var cameraSubmenuTool = navTools.getControl('toolbar-cameraSubmenuTool');\n  if (cameraSubmenuTool) {\n    navTools.addControl(this.firstPersonToolButton, { index: navTools.indexOf(cameraSubmenuTool.getId()) });\n  } else {\n    navTools.addControl(this.firstPersonToolButton);\n  }\n};\n\nproto.unload = function () {\n  var viewer = this.viewer;\n\n  // Remove listeners\n  viewer.removeEventListener(Autodesk.Viewing.TOOL_CHANGE_EVENT, this.onToolChanged);\n  this.onToolChanged = undefined;\n\n  // Remove hotkey\n  viewer.getHotkeyManager().popHotkeys(this.HOTKEYS_ID);\n\n  // Remove the UI\n  if (this.firstPersonToolButton) {\n    var toolbar = viewer.getToolbar();\n    if (toolbar) {\n      this.firstPersonToolButton.removeFromParent();\n    }\n    this.firstPersonToolButton = null;\n  }\n\n  //Uh, why does the viewer need to keep track of this in addition to the tool stack?\n  if (viewer.getActiveNavigationTool() == this.tool.getName())\n  viewer.setActiveNavigationTool();\n\n  // Deregister tool\n  viewer.toolController.deregisterTool(this.tool);\n  this.tool = null;\n\n  return true;\n};\n\nproto.activate = function () {\n  if (!this.activeStatus) {\n    this.viewer.setActiveNavigationTool(\"firstperson\");\n    this.activeStatus = true;\n  }\n  return true;\n};\nproto.deactivate = function () {\n  if (this.activeStatus) {\n    this.viewer.setActiveNavigationTool();\n    this.activeStatus = false;\n  }\n  return true;\n};\n\nAutodesk.Viewing.theExtensionManager.registerExtension('Autodesk.FirstPerson', FirstPersonExtension);","import { GamepadModule } from '../Gamepad/GamepadModule';\nvar av = Autodesk.Viewing;\n/*\n                            * First Person View tool for LMV\n                            *\n                            * This tool provides a first person view with movement using the standard WASD keys\n                            * to forward/backward/left/right and the QE keys to move vertically.  The mouse or\n                            * cursor is used to orient the view.  Movement is always along or perpendicular to\n                            * the view direction.\n                            *\n                            * The SHIFT key may be used when moving to increase the speed.  Or the default\n                            * movement speed may be increased/decreased with the MINUS or EQUAL keys.  The\n                            * ZERO (0) will reset to the default speed values.\n                            *\n                            * @author Hans Kellner (Oct 2014)\n                            *\n                            */\nexport function FirstPersonTool(viewerapi) {\n\n  var avp = Autodesk.Viewing.Private;\n\n  var _isMac = navigator.userAgent.search(\"Mac OS\") != -1;\n  var _navapi = viewerapi.navigation;\n  var _container = viewerapi.container;\n  var _camera = _navapi.getCamera();\n  var _names = [\"firstperson\"];\n\n  this.setGlobalManager(viewerapi.globalManager);\n\n  var _modifierState = { SHIFT: 0, ALT: 0, CONTROL: 0 }; // TODO: Use the hotkeymanager for these.\n  var _keys = Autodesk.Viewing.KeyCode;\n\n  var _isActive = false;\n\n  // true to disable mouse & keyboard navigation.  Used when a HUD is visible to simulate\n  // a modal dialog.\n  var _ignoreMouseAndKeyNav = false;\n\n  // if true then mouse drag changes view orientation, otherwise just mouse move.\n  // If this is set to false then auto-tracking is enabled which might be a usability\n  // issue depending on where the cursor is locate when the tool is enabled.\n  // Movement is based on the distance the cursor is located from the center of\n  // the screen.  If the cursor is away from center when the tool is enabled then\n  // in auto-tracking (non-drag) mode the camera will begin moving.  This may be\n  // disconcerting to the user.\n  var _mouseDraggingLookMode = true;\n\n  var _isDragging = false;\n  var _touchType = null;\n\n  var _clock = new THREE.Clock(true);\n\n  var _hudMessageStartShowTime = -1;\n  var _hudMessageShowTime = 5000; // milliseconds to show HUD\n\n  var _modelScaleFactor = 1.0;\n\n  // These values define how fast/slow the camera movements are made.\n  // Adjust these to fine tune the movement.\n  var _movementSpeedDefault = 2.0;\n  var _movementSpeed = 2.0;\n  var _wheelMovementSpeed = 1.0;\n  var _verticalMovementSpeed = 0.5;\n  var _lookSpeed = 0.0035;\n\n  var _wheelDelta = 0;\n\n  // Current cursor\n  var _lastX = -1e20;\n  var _lastY = -1e20;\n\n  // Relative movement\n  var _deltaYaw = 0;\n  var _deltaPitch = 0;\n\n  // Key movement flags\n  var _moveForward = false;\n  var _moveBackward = false;\n  var _moveLeft = false;\n  var _moveRight = false;\n  var _moveUp = false;\n  var _moveDown = false;\n\n  // Previous FOV and Perspective settings\n  var _previousFov = _camera.fov;\n  var _restorePreviousFov = false;\n\n  var _wasPerspective = _camera.isPerspective;\n  var _restorePreviousPerspective = false;\n\n  // Help HUD\n  var _bDontShowAgain_HelpHUD = false;\n\n  //gamepad\n  var _gamepadModule;\n  //if this browser supports gamepad, instantiate GamepadModule\n  if (navigator.getGamepads || !!navigator.webkitGetGamepads || !!navigator.webkitGamepads) {\n    _gamepadModule = new GamepadModule(viewerapi);\n  }\n\n  //ADP \n  var _trackToolUsed = false;\n\n  // ToolInterface\n\n  this.isActive = function ()\n  {\n    return _isActive;\n  };\n\n  this.getNames = function ()\n  {\n    return _names;\n  };\n\n  this.getName = function ()\n  {\n    return _names[0];\n  };\n\n  this.activate = function ()\n  {\n    _clock.start();\n\n    // Switch to perspective\n    _wasPerspective = _camera.isPerspective;\n    _navapi.toPerspective();\n\n    // Change FOV to a wide value for a better 1st person experience\n    _previousFov = _camera.fov;\n    _navapi.setVerticalFov(75, true);\n\n    // Calculate a movement scale factor based on the model bounds.\n    var boundsSize = viewerapi.model.getBoundingBox().size();\n    _modelScaleFactor = Math.max(Math.min(Math.min(boundsSize.x, boundsSize.y), boundsSize.z) / 10.0, 0.0001);\n\n    // HACK: Place focus in canvas so we get key events.\n    viewerapi.canvas.focus();\n\n    _isActive = true;\n\n    // Display the HUD on startup but only if \"don't show me again\" wasn't requested\n    if (viewerapi.getFirstPersonToolPopup() && !_bDontShowAgain_HelpHUD) {\n      showHelpHUD();\n    }\n\n    this.addCrosshair();\n\n    viewerapi.impl.pauseHighlight(true);\n\n    if (_gamepadModule) {\n      _gamepadModule.activate(this.getName());\n    }\n  };\n\n  this.deactivate = function ()\n  {\n    _isActive = false;\n\n    _clock.stop();\n\n    hideHUD();\n    this.removeCrosshair();\n\n    if (_restorePreviousFov) {\n      _navapi.setVerticalFov(_previousFov, true);\n    }\n\n    if (_restorePreviousPerspective) {\n      if (!_wasPerspective)\n      _navapi.toOrthographic();\n    }\n\n    viewerapi.impl.pauseHighlight(false);\n\n    if (_gamepadModule)\n    _gamepadModule.deactivate();\n\n  };\n\n  this.getCursor = function ()\n  {\n    return \"url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH3goOFQoQszohGAAAA9hJREFUSMedll1oHGUUhp8zuzP5291pEvNTomgVjFCCCa0NpAqJEJTUFVv8uWxQLwKCF6IUr7wJ6J30QvBCAlZssA0EkYJaAm1FwU3iakrbVNNuutlukk3dzWyT/ZnJ7ufFTtokbmvX72Y45+N73/Oe8858I+xYSikBJJFI7AmFQh9alvVWoVC47vP5ho4cOXJeRGwqWN4yOQ2oHh0dPROJRNo7OjqIRCKPRxeiP66srBxSSn0vIsX/RaCU0gDV399vNjQ0tB8/fpxAIEAsFuP06dPEYrFvgHqguEMxIqLKdUPbmnArU52dnb2maWJUGeRyOWzbpqGxgXg87gOMncDlwLe2Y5uCwcHBFp/P90k4PE349xkWolGi0SjhPy5hF+UmIEopz/1AtxRcqmJzDQ8P7750+Wq8e9+TPGLe4sSp39jz9LMsxm/izE6gOVnquoIcOHDgnddfe/VEU3PLWkUzSCQSesCzxNtvHKZu11O0137OuTMneYY1+l+px99sci5zgU+/Pv/Z5OTkWeCvigja2tqqri3/RPbiMfSWLvY+/wJ7XwxCOoyz+gPF5C0OzsFZv8NEOOxU7KL5+fkcooFUo9avYt+4htTU43noJVTmIPYvp8hnChSKCr/fr1VMkEqlCgEATUDTAIVykhSWRtj4M4/KKzZ9Z9u2ehCCbVUYhlEaurg7m09NB/GWYhe2r69vV8UEvb29DeIWL+6uIG6w6b1SGAqF0hUTZDKZ7GLKy1w0h+Z1keQuMEDOKbK+oZFIJOyKZqCUEsuy/k4mk6kr0ZH6/Z2CkrttEl1QjuJkKI3z6KGp6vTFpYoVmKaZ9Xg8lleDoq3IzOdBILuygbVgs2YVSNrgOM7o1NTURkUE7qufX15evo5A0VHcnrNRgFgFJF6gsVmntlaIxWKNIlK/s8D/VCAianZ29spmv0vfVoVuaNT6PYhWMpGIGIZhNAGtQC3bbXDfj51YlrWObHeOKu3didfX1x3btgGqgADgu5eafyXT6XT2zmDLnVDg9Xq9uq573fMeQAeqy+HtTAgguq7h0aUsgyZCJpPZcBxnE1xz3fhACqp7enoe+3ZimVg8j6ELiIACEUETWErnsCwrD2h1dXW6C+4A2a033T0VfPD+e8dePvoFb36sM/LzKomkQ1FgMW3z7neL3Gh6jtbW1rmamhrDNM0NYAVIAYWyl06ZPwoNeHh6evqJmZmZiV8vnCBw+yLRRCv7gkdpamr6aGho6KuBgQFnfHx88V7AZQlcEt01jgD+sbGx3V+OjPR07d8fDQaDl1OpVLK7u9swTXP1Qa7NfwCi46BIaoRmhAAAAABJRU5ErkJggg==), auto\";\n  };\n\n  this.adjustSpeed = function (direction)\n  {\n    if (direction === 0) {// reset to default\n      _movementSpeed = _movementSpeedDefault;\n    } else\n    {\n      _movementSpeed *= direction > 0 ? 1.10 : 0.90;\n      if (_movementSpeed < 0.01) {\n        _movementSpeed = 0.01;\n      }\n    }\n  };\n\n  function getEventModifierState(event)\n  {\n    if (_touchType)\n    return false;\n\n    var ctrlKey = event.ctrlKey || _isMac && event.metaKey;\n    var metaKey = event.metaKey && !_isMac;\n\n    //console.log(\"Mod keys: ctrl = \"+ctrlKey+\" meta = \"+metaKey+\" alt^ctrl = \"+ (event.altKey ^ ctrlKey));\n\n    return ctrlKey || metaKey || event.shiftKey || event.altKey;\n  }\n\n  /////////////////////////////////////////////////////////////////////////\n  // Tool event handler callbacks - can use \"this\".\n\n  this.handleGesture = function (event)\n  {\n    // Convert Hammer touch-event X,Y into mouse-event X,Y.\n    if (event.pointers && event.pointers.length > 0) {\n      event.pageX = event.pointers[0].pageX;\n      event.pageY = event.pointers[0].pageY;\n    }\n\n    switch (event.type) {\n\n      case \"dragstart\":\n        _touchType = \"drag\";\n        // Single touch, fake the mouse for now...\n        return this.handleButtonDown(event, 0);\n\n      case \"dragmove\":\n        return _touchType === \"drag\" ? this.handleMouseMove(event) : false;\n\n      case \"dragend\":\n        if (_touchType === \"drag\")\n        {\n          this.handleButtonUp(event, 0);\n          _touchType = null;\n          return true;\n        }\n        return false;}\n\n\n    return false;\n  };\n\n  this.handleSingleClick = function ()\n  {\n    return false;\n  };\n\n  this.handleButtonDown = function (event, button)\n  {\n    hideHUD();\n\n    var modifierState = getEventModifierState(event);\n    if (button === 0 && !modifierState) {\n\n      _lastX = event.pageX;\n      _lastY = event.pageY;\n\n      _deltaYaw = _deltaPitch = 0;\n      _isDragging = true;\n      return true;\n    }\n\n    return true; // Eat all these so default tools don't screw with view\n  };\n\n  this.handleMouseMove = function (event)\n  {\n    var dx = _lastX < -1e10 ? 0 : event.pageX - _lastX;\n    var dy = _lastY < -1e10 ? 0 : event.pageY - _lastY;\n    _lastX = event.pageX;\n    _lastY = event.pageY;\n\n    if (_isDragging === _mouseDraggingLookMode && !_ignoreMouseAndKeyNav)\n    {\n      // Joystick Camera Orientation\n      /** DISABLED\n       var xNew = event.pageX - window.innerWidth / 2;\n       var yNew = event.pageY - window.innerHeight / 2;\n       if (_mouseDraggingLookMode) {\n      // If in drag mode then movement is relative to start point\n      _mouseDX = xNew - _mouseXstart;\n      _mouseDY = yNew - _mouseYstart;\n      }\n       else {\n      _mouseDX = xNew;\n      _mouseDY = yNew;\n      }\n       // A circular area in the middle of the screen or around the start point\n       // defines a neutral area in which no movement occurs.\n       var mouseMoveDist = Math.sqrt( _mouseDX * _mouseDX + _mouseDY * _mouseDY );\n       if ( mouseMoveDist < _neutralZoneDist ) {\n      _mouseDX = _mouseDY = 0;\n      }\n       DISABLED **/\n\n      // Discrete Camera Orientation\n      _deltaYaw += dx * _lookSpeed;\n      _deltaPitch += dy * _lookSpeed;\n    }\n\n    return true; // Eat all these so default tools don't screw with view\n  };\n\n  this.handleButtonUp = function (event, button)\n  {\n\n    // If are dragging for a specific button then end dragging no matter\n    // what the state of the modifiers.  Otherwise you won't end dragging.\n    if (button === 0 && _isDragging) {\n      _deltaYaw = _deltaPitch = 0;\n      _isDragging = false;\n      return true;\n    }\n\n    return true; // Eat all these so default tools don't screw with view\n  };\n\n  this.handleKeyDown = function (event, keyCode)\n  {\n    if (_ignoreMouseAndKeyNav) {\n      return false;\n    }\n\n    hideHUD();\n\n    var handled = false;\n\n    switch (keyCode) {\n\n      case _keys.ESCAPE:\n        break;\n\n      case _keys.TAB:handled = false;break;\n\n      // Eat the modifiers so defualt tools don't activate and mess with cam\n      case _keys.SHIFT:_modifierState.SHIFT = 1;handled = true;break;\n      case _keys.CONTROL:_modifierState.CONTROL = 1;handled = true;break;\n      case _keys.ALT:_modifierState.ALT = 1;handled = true;break;\n      case _keys.SPACE:_modifierState.SPACE = 1;handled = true;break;\n\n      case _keys.EQUALS:this.adjustSpeed(1);handled = true;break;\n      case _keys.DASH:this.adjustSpeed(-1);handled = true;break;\n      case _keys.ZERO:this.adjustSpeed(0);handled = true;break; // Reset dolly speed to default\n\n      case _keys.UP:\n      case _keys.w:\n        _moveForward = true;handled = true;\n        break;\n\n      case _keys.LEFT:\n      case _keys.a:\n        _moveLeft = true;handled = true;\n        break;\n\n      case _keys.DOWN:\n      case _keys.s:\n        _moveBackward = true;handled = true;\n        break;\n\n      case _keys.RIGHT:\n      case _keys.d:\n        _moveRight = true;handled = true;\n        break;\n\n      case _keys.q:\n        _moveUp = true;handled = true;\n        break;\n\n      case _keys.e:\n        _moveDown = true;handled = true;\n        break;\n\n      case _keys.g:\n        handled = true;\n        break;\n\n      case _keys.F1:\n        handled = true;\n        break;}\n\n\n    return handled;\n  };\n\n  this.handleKeyUp = function (event, keyCode)\n  {\n    if (_ignoreMouseAndKeyNav) {\n      return false;\n    }\n\n    var handled = false;\n\n    switch (keyCode) {\n\n      case _keys.TAB:\n        handled = false;\n        break;\n\n      // Eat the modifiers so defualt tools don't activate and mess with cam\n      case _keys.SHIFT:_modifierState.SHIFT = 0;handled = true;break;\n      case _keys.CONTROL:_modifierState.CONTROL = 0;handled = true;break;\n      case _keys.ALT:_modifierState.ALT = 0;handled = true;break;\n      case _keys.SPACE:_modifierState.SPACE = 0;handled = true;break;\n\n      case _keys.UP:\n      case _keys.w:\n        _moveForward = false;handled = true;\n        firstPersonToolUsed();\n        break;\n\n      case _keys.LEFT:\n      case _keys.a:\n        _moveLeft = false;handled = true;\n        firstPersonToolUsed();\n        break;\n\n      case _keys.DOWN:\n      case _keys.s:\n        _moveBackward = false;handled = true;\n        firstPersonToolUsed();\n        break;\n\n      case _keys.RIGHT:\n      case _keys.d:\n        _moveRight = false;handled = true;\n        firstPersonToolUsed();\n        break;\n\n      case _keys.q:\n        _moveUp = false;handled = true;\n        firstPersonToolUsed();\n        break;\n\n      case _keys.e:\n        _moveDown = false;handled = true;\n        firstPersonToolUsed();\n        break;\n\n      case _keys.g:\n        _mouseDraggingLookMode = !_mouseDraggingLookMode;\n        showDraggingLookModeHUD(_mouseDraggingLookMode);\n        handled = true;\n        break;\n\n      case _keys.F1:\n        showHelpHUD();\n        handled = true;\n        break;}\n\n\n    return handled;\n  };\n\n  this.handleWheelInput = function (delta)\n  {\n    if (_ignoreMouseAndKeyNav) {\n      return false;\n    }\n\n    if (_navapi.getReverseZoomDirection())\n    delta *= -1;\n\n    _wheelDelta += delta;\n\n    return true;\n  };\n\n  this.handleSingleClick = function () {\n    return false;\n  };\n\n  this.handleDoubleClick = function () {\n    return false;\n  };\n\n  this.handleSingleTap = function (event)\n  {\n    return this.handleSingleClick(event, 0);\n  };\n\n  this.handleDoubleTap = function () {\n    return false;\n  };\n\n  this.handleBlur = function ()\n  {\n    // Reset things when we lose focus...\n    _moveForward = _moveBackward = false;\n    _moveLeft = _moveRight = false;\n    _moveUp = _moveDown = false;\n\n    return false;\n  };\n\n  this.update = function ()\n  {\n\n    if (!_isActive || !_navapi.isActionEnabled('walk'))\n    return false;\n\n    var delta = _clock.getDelta(); //returns delta in unit seconds\n\n    if (_hudMessageStartShowTime > -1) {\n      var curTime = new Date().getTime();\n      if (curTime - _hudMessageStartShowTime > _hudMessageShowTime) {// seconds\n        hideHUD();\n      }\n    }\n\n    // From the Collaboration extension:\n    //the \"go home\" call may change the camera back to ortho... and we can't do ortho while walking...\n    //HACK: Really, the home view should be set once when launch the extension, then set it back.\n    if (!_camera.isPerspective) {\n      console.log(\"Lost perspective mode: resetting view.\");\n      _navapi.toPerspective();\n    }\n\n    var localCam = _camera.clone(); // Copy of camera to modify\n\n    // Handle movement changes\n\n    var actualMoveSpeed = delta * _movementSpeed * _modelScaleFactor * (_modifierState.SHIFT === 1 ? 4 : 1);\n    var actualVerticalMoveSpeed = delta * _verticalMovementSpeed * _modelScaleFactor * (_modifierState.SHIFT === 1 ? 4 : 1);\n\n\n    if (_wheelDelta != 0) {\n      var actualWheelMoveSpeed = _wheelDelta * _wheelMovementSpeed * _modelScaleFactor * (_modifierState.SHIFT === 1 ? 4 : 1);\n      localCam.translateZ(-actualWheelMoveSpeed);\n      _wheelDelta = 0;\n    }\n\n    if (_moveForward) {\n      localCam.translateZ(-actualMoveSpeed);\n    }\n\n    if (_moveBackward) {\n      localCam.translateZ(actualMoveSpeed);\n    }\n\n    if (_moveLeft) {\n      localCam.translateX(-actualMoveSpeed);\n    }\n\n    if (_moveRight) {\n      localCam.translateX(actualMoveSpeed);\n    }\n\n    if (_moveUp) {\n      localCam.translateY(actualVerticalMoveSpeed);\n    }\n\n    if (_moveDown) {\n      localCam.translateY(-actualVerticalMoveSpeed);\n    }\n\n    var newPosition = localCam.position;\n    var posChanged = newPosition.distanceToSquared(_camera.position) !== 0;\n\n    // Handle look changes\n\n    // var actualLookSpeed = delta * _lookSpeed;\t\n\n    var newTarget = localCam.target;\n\n    var directionFwd = _camera.target.clone().sub(_camera.position);\n    //directionFwd = directionFwd.sub((directionFwd.multiply(_camera.worldup)).multiply(_camera.worldup));\n\n    var directionRight = directionFwd.clone().cross(_camera.up).normalize();\n\n    /** Joystick Camera Orientation\n                                                                              ** This code enabled continuous movement of camera as apposed to the\n                                                                              ** discrete movement mode below.  Moving the cursor outside of the\n                                                                              ** center of the view orients the camera in that direction and continues\n                                                                              ** moving while cursor is outside neutral center.  It works like a\n                                                                              ** virtual joystick.\n                                                                              **\n                                                                              ** Uncomment/Comment these sections to switch the style of camera orientation.\n                                                                              **/\n\n    /** DISABLED\n                                                                                   var dyawAngle = 0, dpitchAngle = 0;\n                                                                                   if (Math.abs(_mouseDX) > _neutralZoneDist) {\n                                                                                  if (_mouseDX > 0) {\n                                                                                      _mouseDX = Math.min(_mouseDX, _mouseXMaxLimit); // Throttle look speed.\n                                                                                      dyawAngle = (_mouseDX - _neutralZoneDist) * actualLookSpeed;\n                                                                                  }\n                                                                                  else {\n                                                                                      _mouseDX = Math.max(_mouseDX, -_mouseXMaxLimit); // Throttle look speed.\n                                                                                      dyawAngle = (_mouseDX + _neutralZoneDist) * actualLookSpeed;\n                                                                                  }\n                                                                                  }\n                                                                                   if (Math.abs(_mouseDY) > _neutralZoneDist) {\n                                                                                  if (_mouseDY > 0) {\n                                                                                      _mouseDY = Math.min(_mouseDY, _mouseYMaxLimit); // Throttle look speed.\n                                                                                      dpitchAngle = (_mouseDY - _neutralZoneDist) * actualLookSpeed;\n                                                                                  }\n                                                                                  else {\n                                                                                      _mouseDY = Math.max(_mouseDY, -_mouseYMaxLimit); // Throttle look speed.\n                                                                                      dpitchAngle = (_mouseDY + _neutralZoneDist) * actualLookSpeed;\n                                                                                  }\n                                                                                  }\n                                                                                   if (dpitchAngle) {\n                                                                                  var pitchQ = new THREE.Quaternion();\n                                                                                  pitchQ.setFromAxisAngle(directionRight, -dpitchAngle);\n                                                                                  // Need to limit pitch to +-85 degrees so we don't create\n                                                                                  // camera jumping at vertical limits.\n                                                                                  var dirFwdTmp = directionFwd.clone();\n                                                                                  dirFwdTmp.applyQuaternion(pitchQ);\n                                                                                  var vertical = _camera.worldup.clone();\n                                                                                  var vertAngle = dirFwdTmp.angleTo(vertical);\n                                                                                  var vertLimit = THREE.Math.degToRad(5);\n                                                                                  // If new angle is within limits then update values; otherwise ignore\n                                                                                  if ( vertAngle >= vertLimit && vertAngle <= (Math.PI - vertLimit) ) {\n                                                                                      directionFwd.applyQuaternion(pitchQ);\n                                                                                      localCam.up.applyQuaternion(pitchQ);\n                                                                                  }\n                                                                                  }\n                                                                                   if (dyawAngle) {\n                                                                                  var yawQ = new THREE.Quaternion();\n                                                                                  yawQ.setFromAxisAngle(_camera.worldup, -dyawAngle);\n                                                                                  directionFwd.applyQuaternion(yawQ);\n                                                                                  localCam.up.applyQuaternion(yawQ);\n                                                                                  }\n                                                                                   DISABLED **/\n\n    /** Discrete Camera Orientation\n                                                                                                 ** Movement based on the delta changes in position or cursor.  See the\n                                                                                                 ** the \"Dynamic Move\" code for an alternative.  In this mode the camera\n                                                                                                 ** is oriented based on the delta movement of the cursor.  Movement\n                                                                                                 ** stops as camera is oriented to new change of cursor.\n                                                                                                 ** TODO: Add logic to smooth motion so camera position ramps towards\n                                                                                                 ** the new location rather than discrete jumps.\n                                                                                                 **/\n\n    if (_deltaPitch != 0) {\n      var pitchQ = new THREE.Quaternion();\n      pitchQ.setFromAxisAngle(directionRight, -_deltaPitch);\n      // Need to limit pitch to +-85 degrees so we don't create\n      // camera jumping at vertical limits.\n      var dirFwdTmp = directionFwd.clone();\n      dirFwdTmp.applyQuaternion(pitchQ);\n\n      var vertical = _camera.worldup.clone();\n      var vertAngle = dirFwdTmp.angleTo(vertical);\n      var vertLimit = THREE.Math.degToRad(5);\n\n      // If new angle is within limits then update values; otherwise ignore\n      if (vertAngle >= vertLimit && vertAngle <= Math.PI - vertLimit) {\n        directionFwd.applyQuaternion(pitchQ);\n        localCam.up.applyQuaternion(pitchQ);\n      }\n\n      _deltaPitch = 0.0;\n    }\n\n    if (_deltaYaw != 0) {\n      var yawQ = new THREE.Quaternion();\n      yawQ.setFromAxisAngle(_camera.worldup, -_deltaYaw);\n      directionFwd.applyQuaternion(yawQ);\n      localCam.up.applyQuaternion(yawQ);\n      _deltaYaw = 0.0;\n    }\n\n    // Now calc new target location and if it changed.\n    newTarget = newPosition.clone().add(directionFwd);\n    //now fix newPosition for lockInPlane\n    var targetChanged = newTarget.distanceToSquared(_camera.target) !== 0;\n    // If position or target changed then update camera.\n    if (posChanged || targetChanged) {\n\n      _navapi.setView(newPosition, newTarget);\n      //_camera.position = newPosition.clone();\n      //_camera.target = newTarget.clone();\n      //_camera.dirty = true;s\n      // Force the camera to stay orientated up with world up.\n      _navapi.orientCameraUp();\n    }\n\n    //gamepad integration\n    if (_gamepadModule) {\n      _camera = _gamepadModule.update(_camera);\n    }\n\n    return _camera.dirty;\n\n\n  };\n  //ADP\n  var firstPersonToolUsed = function firstPersonToolUsed() {\n    if (!_trackToolUsed) {\n      avp.logger.track({ category: 'tool_used', name: 'FirstPerson_tool' });\n      _trackToolUsed = true;\n    }\n  };\n\n\n  /////////////////////////////////////////////////////////////////////////\n  // HUD helpers\n\n  // Show a HUD for a specific amount of time (showDelay > 0) or until closed.\n  var showHUD = function showHUD(messageSpecs, showDelay, closeCB, buttonCB, checkboxCB)\n  {\n    // TODO: Tool should not be trying to interact with UI\n    // Does not comply with headless viewer policy.\n    if (!Autodesk.Viewing.Private.HudMessage) {\n      return;\n    }\n\n    Autodesk.Viewing.Private.HudMessage.displayMessage(_container, messageSpecs, closeCB, buttonCB, checkboxCB);\n\n    if (showDelay > 0) {\n      _hudMessageStartShowTime = new Date().getTime();\n      _hudMessageShowTime = showDelay;\n    } else\n    {\n      _hudMessageStartShowTime = -1;\n      _hudMessageShowTime = 0;\n    }\n  };\n\n  var hideHUD = function hideHUD()\n  {\n    // TODO: Tool should not be trying to interact with UI\n    // Does not comply with headless viewer policy.\n    if (Autodesk.Viewing.Private.HudMessage) {\n      Autodesk.Viewing.Private.HudMessage.dismiss(); // in case it's still visible\n    }\n    _hudMessageStartShowTime = -1;\n  };\n\n  var showDraggingLookModeHUD = function showDraggingLookModeHUD(enabled)\n  {\n    hideHUD();\n\n    var themessage = enabled ?\n    \"Press the primary mouse button and drag to change the view orientation\" :\n    \"Move the cursor to change the view orientation\";\n\n    var messageSpecs = {\n      \"msgTitleKey\": \"First Person Tool\",\n      \"messageKey\": themessage,\n      \"messageDefaultValue\": themessage };\n\n\n    var closeCallback = function closeCallback() {}; // dummy callback function so that the 'X' is shown\n    showHUD(messageSpecs, 0, closeCallback);\n  };\n\n\n  var showHelpHUD = function showHelpHUD()\n  {\n    hideHUD();\n\n    // TODO: Sadly, the HudMessage api doesn't support html formatted messages\n    var messageSpecs = {\n      \"msgTitleKey\": \"First Person Tool\",\n      \"messageKey\": \"Use the WASD and QE keys to move\",\n      \"messageDefaultValue\": \"Use the WASD and QE keys to move\", // simplify key and remove peroid\n      \"buttonText\": \"Ok Got It\" };\n\n\n    var closeCallback = function closeCallback() {}; // dummy callback function so that the 'X' is shown\n    var buttonCallback = function buttonCallback() {\n      _bDontShowAgain_HelpHUD = true;\n      viewerapi.setFirstPersonToolPopup(false);\n      hideHUD();\n    };\n    showHUD(messageSpecs, 0, closeCallback, buttonCallback);\n  };\n\n  this.addCrosshair = function () {\n    if (avp.stringToDOM) {\n      this.crosshair = avp.stringToDOM('<div id=\"remote-crosshair\"><div class=\"crosshair-v\"></div><div class=\"crosshair-h\"></div></div>f');\n      viewerapi.canvasWrap.appendChild(this.crosshair);\n    }\n  };\n\n  this.removeCrosshair = function () {\n    if (this.crosshair && this.crosshair.parentNode) {\n      this.crosshair.parentNode.removeChild(this.crosshair);\n    }\n  };\n}\n\nav.GlobalManagerMixin.call(FirstPersonTool.prototype);","/***\n* GamepadModule is a tool (not an extension) that reacts to input from\n* a gamepad controller plugged into the hosting machine.\n *\n* @param viewerapi\n* @constructor\n*/\nexport function GamepadModule(viewerapi) {\n\n  var avp = Autodesk.Viewing.Private;\n\n  var _navapi = viewerapi.navigation;\n  var _container = viewerapi.container;\n  var _camera = _navapi.getCamera();\n\n  var _modelScaleFactor = 1.0;\n\n  var _explodeSpeed = 0;\n\n  var _THRESHOLD = 0.1;\n  var _SPEED_ADJUST = 5.5,\n  _INITIAL_SPEED_SCALAR = 6,\n  _speed_scalar = _INITIAL_SPEED_SCALAR;\n\n\n  var _btnPressMap = {};\n  var _gamepad;\n  var _hudMessageStartShowTime;\n  var _hudMessageShowTime;\n  var _viewerState;\n  var _savepoints;\n  var _nextsavepoint;\n\n  //Nav mode toggle\n  var _lockInPlane;\n\n  var _clock = new THREE.Clock(true);\n\n  var VIEWER_STATE_FILTER = {\n    seedURN: false,\n    objectSet: true,\n    viewport: true,\n    renderOptions: {\n      environment: false,\n      ambientOcclusion: false,\n      toneMap: {\n        exposure: false },\n\n      appearance: false } };\n\n\n  var _actualMoveSpeed;\n  var _movementSpeed = 2.0;\n  var _INITIAL_FOV = 75;\n  var _ZOOM_SCALAR = -45; //smaller => closer zoom\n  var _altitudeLockCoord;\n  var _currentTool;\n\n  /*Face Buttons*/\n  var _BUTTONS = {\n    SOUTH_BTN: 0,\n    EAST_BTN: 1,\n    WEST_BTN: 2,\n    NORTH_BTN: 3,\n\n    /*Shoulder and trigger buttons*/\n    LEFT_SHOULDER: 4,\n    RIGHT_SHOULDER: 5,\n    LEFT_TRIGGER: 6, //ANALOG\n    RIGHT_TRIGGER: 7, //ANALOG\n\n    /*directional pad (DPad)*/\n    SOUTH_DPAD: 13,\n    EAST_DPAD: 15,\n    WEST_DPAD: 14,\n    NORTH_DPAD: 12,\n\n    /*Joystick buttons (press joystick in)*/\n    LEFT_STICK_BUTTON: 10,\n    RIGHT_STICK_BUTTON: 11 };\n\n\n\n  var _STICKS = {\n    //Axis//\n    /*Left and right joysticks*/\n    LEFT_STICK_X: 0, //ANALOG\n    LEFT_STICK_Y: 1, //ANALOG\n    RIGHT_STICK_X: 2, //ANALOG\n    RIGHT_STICK_Y: 3 //ANALOG\n  };\n\n  var _BLANK_FUNC = function _BLANK_FUNC() {};\n  var _BUTTON_MAPPING = {};\n  for (var k in _BUTTONS) {\n    if (Object.prototype.hasOwnProperty.call(_BUTTONS, k))\n    _BUTTON_MAPPING[_BUTTONS[k]] = _BLANK_FUNC;\n  }\n\n  var init = function init() {\n\n  };\n\n  this.activate = function (toolName) {\n    // Calculate a movement scale factor based on the model bounds.\n    var boundsSize = viewerapi.model.getBoundingBox().size();\n    _modelScaleFactor = Math.max(Math.min(Math.min(boundsSize.x, boundsSize.y), boundsSize.z) / 10.0, 0.0001);\n    _gamepad = navigator.getGamepads()[0];\n    _viewerState = new Autodesk.Viewing.Private.ViewerState(viewerapi);\n    _savepoints = [];\n    _nextsavepoint = 0;\n    _currentTool = toolName;\n    setMapping(toolName);\n  };\n\n  this.deactivate = function () {\n    //console.log(\"DEACTIVATE\");\n    _currentTool = null;\n    _viewerState = null;\n  };\n\n  this.update = function (delta, camera) {\n\n    if (camera)\n    _camera = camera;\n    delta = _clock.getDelta();\n\n    //poll for gamepad connection\n    _gamepad = navigator.getGamepads()[0];\n\n    if (_hudMessageStartShowTime > -1) {\n      var curTime = new Date().getTime();\n      if (curTime - _hudMessageStartShowTime > _hudMessageShowTime) {// seconds\n        hideHUD();\n      }\n    }\n\n    if (_gamepad) {\n      _actualMoveSpeed = delta * _movementSpeed * _modelScaleFactor * _speed_scalar; // (_gamepad.buttons[_BUTTONS.RIGHT_TRIGGER].value > _THRESHOLD ? _SPEED_ADJUST * _gamepad.buttons[_BUTTONS.RIGHT_TRIGGER].value + _MAX_SPEED_SCALAR : _MAX_SPEED_SCALAR);\n      // From the Collaboration extension:\n      //the \"go home\" call may change the camera back to ortho... and we can't do ortho while walking...\n      //HACK: Really, the home view should be set once when launch the extension, then set it back.\n      if (!_camera.isPerspective) {\n        //console.log(\"Lost perspective mode: resetting view.\");\n        _navapi.toPerspective();\n      }\n      if (_gamepad) {//TODO test for connection (change of state?)\n        if (inputDetected()) {//need to update camera scene\n          // console.log(\"needs update\");\n          _camera.dirty = true;\n          if (_lockInPlane) {\n            _altitudeLockCoord = _camera.position.z;\n          }\n\n          var direction = _camera.target.clone().sub(_camera.position);\n          var distance = direction.length();\n          direction.multiplyScalar(1.0 / distance);\n          var right = direction.clone().cross(_camera.up).normalize();\n          if (Math.abs(_gamepad.axes[_STICKS.LEFT_STICK_Y]) > _THRESHOLD) {\n            var forwardMove = direction.clone().multiplyScalar(-_gamepad.axes[_STICKS.LEFT_STICK_Y] * _actualMoveSpeed);\n            _camera.position.add(forwardMove);\n            _camera.target.add(forwardMove);\n          }\n\n          if (Math.abs(_gamepad.axes[_STICKS.LEFT_STICK_X]) > _THRESHOLD) {\n            var strafeMove = right.clone().multiplyScalar(_gamepad.axes[_STICKS.LEFT_STICK_X] * _actualMoveSpeed);\n            _camera.position.add(strafeMove);\n            _camera.target.add(strafeMove);\n          }\n\n          var lookUpDown = new THREE.Quaternion();\n          var ndir = direction;\n          if (Math.abs(_gamepad.axes[_STICKS.RIGHT_STICK_Y]) > _THRESHOLD) {\n\n            var tempCam = _camera.clone(); //modify this camera to see if it will be in viable range\n            var tempDir = direction.clone();\n\n            lookUpDown.setFromAxisAngle(right, -_gamepad.axes[_STICKS.RIGHT_STICK_Y] * _actualMoveSpeed / 2); //lookscale\n\n            tempDir.applyQuaternion(lookUpDown);\n            tempCam.up.applyQuaternion(lookUpDown);\n            var vertical = tempCam.worldup.clone();\n            var vertAngle = tempDir.angleTo(vertical);\n            var vertLimit = THREE.Math.degToRad(5);\n\n            // If new angle is within limits then update values; otherwise ignore\n            if (vertAngle >= vertLimit && vertAngle <= Math.PI - vertLimit) {\n              ndir = direction.clone().applyQuaternion(lookUpDown);\n              _camera.up.applyQuaternion(lookUpDown);\n            }\n          }\n\n          var lookLeftRight = new THREE.Quaternion();\n          if (Math.abs(_gamepad.axes[_STICKS.RIGHT_STICK_X]) > _THRESHOLD) {\n            lookLeftRight.setFromAxisAngle(_camera.worldup, -_gamepad.axes[_STICKS.RIGHT_STICK_X] * _actualMoveSpeed / 2); //lookscale\n            ndir.applyQuaternion(lookLeftRight);\n            _camera.up.applyQuaternion(lookLeftRight);\n          }\n\n          /*HANDLE ALL BUTTON INPUTS*/\n          handleGamepadFaceButtons();\n          /**************************/\n\n          if (_lockInPlane)\n          _camera.position.z = _altitudeLockCoord;\n\n          ndir.multiplyScalar(distance);\n          _camera.target.copy(_camera.position).add(ndir);\n        }\n      }\n    }\n    return _camera;\n  };\n\n\n  // Show a HUD for a specific amount of time (showDelay > 0) or until closed.\n  var showHUD = function showHUD(messageSpecs, showDelay, closeCB, buttonCB, checkboxCB)\n  {\n    Autodesk.Viewing.Private.HudMessage.displayMessage(_container, messageSpecs, closeCB, buttonCB, checkboxCB);\n\n    if (showDelay > 0) {\n      _hudMessageStartShowTime = new Date().getTime();\n      _hudMessageShowTime = showDelay;\n    } else\n    {\n      _hudMessageStartShowTime = -1;\n      _hudMessageShowTime = 0;\n    }\n  };\n\n  var hideHUD = function hideHUD()\n  {\n    Autodesk.Viewing.Private.HudMessage.dismiss(); // in case it's still visible\n    _hudMessageStartShowTime = -1;\n  };\n\n  var showDPadHud = function showDPadHud(direction)\n  {\n    hideHUD();\n    var message;\n    switch (direction) {\n      case \"up\":\n        message = _lockInPlane ? \"Vertical Lock Mode\" : \"Fly mode\";break;\n      case \"left\":\n        break;\n      case \"right\":\n        break;\n      case \"down\":\n        break;}\n\n\n    var messageSpecs = {\n      \"msgTitleKey\": \"View Orientation Drag Mode Toggled\",\n      \"messageKey\": \"View Orientation Drag Mode Toggled\",\n      \"messageDefaultValue\": message };\n\n\n    showHUD(messageSpecs, 2000); //show hud for 2secs\n\n  };\n\n  //checks for any button doing anything important\n  function inputDetected() {\n    //check to see if we pressed a button last frame\n    //loop through mapping to only check buttons we care about\n    for (var btn in _BUTTON_MAPPING) {\n      if (Object.prototype.hasOwnProperty.call(_BUTTON_MAPPING, btn)) {\n        if (_gamepad.buttons[btn].pressed) {\n          if (_gamepad.buttons[btn].value != 0.5) {\n            _btnPressMap[btn] = true; //its pressed!\n            return true;\n          }\n        }\n      }\n    }\n    for (var _btn in _btnPressMap) {\n      if (Object.prototype.hasOwnProperty.call(_btnPressMap, _btn)) {\n        if (_btnPressMap[_btn]) {\n          //_btnPressMap[btn] = false;//\n          return true;\n        }\n      }\n    }\n    //now check movement\n    return !(Math.abs(_gamepad.axes[_STICKS.LEFT_STICK_X]) < _THRESHOLD &&\n    Math.abs(_gamepad.axes[_STICKS.LEFT_STICK_Y]) < _THRESHOLD &&\n    Math.abs(_gamepad.axes[_STICKS.RIGHT_STICK_X]) < _THRESHOLD &&\n    Math.abs(_gamepad.axes[_STICKS.RIGHT_STICK_Y]) < _THRESHOLD);\n\n  }\n\n  /*\n    will check face buttons (including Directional Pad) for input\n     */\n  function handleGamepadFaceButtons() {\n    for (var btn in _BUTTONS) {\n      if (Object.prototype.hasOwnProperty.call(_BUTTONS, btn)) {\n        handleGamepadButton(_BUTTONS[btn]);\n      }\n    }\n  }\n\n  function handleGamepadButton(buttonIdx) {\n    //buttons in first IF are testing for being held (good for analog inputs and held down buttons)\n    //ELSE IF will activate upon RELEASE of a button\n    if (_gamepad.buttons[buttonIdx].value > _THRESHOLD) {\n      _btnPressMap[buttonIdx] = true; //set was_pressed\n      switch (buttonIdx) {\n        case _BUTTONS.LEFT_SHOULDER:\n          _BUTTON_MAPPING[buttonIdx]();break;\n        case _BUTTONS.RIGHT_SHOULDER:\n          _BUTTON_MAPPING[buttonIdx]();break;\n        case _BUTTONS.LEFT_TRIGGER:\n          _BUTTON_MAPPING[buttonIdx](_gamepad.buttons[_BUTTONS.LEFT_TRIGGER].value);break;\n        case _BUTTONS.RIGHT_TRIGGER:\n          _BUTTON_MAPPING[buttonIdx](_gamepad.buttons[_BUTTONS.RIGHT_TRIGGER].value);break;}\n\n    }\n    //ON RELEASE\n    else if (_btnPressMap[buttonIdx]) {\n        _btnPressMap[buttonIdx] = false;\n        switch (buttonIdx) {\n          case _BUTTONS.SOUTH_BTN:\n            _BUTTON_MAPPING[buttonIdx]();break;\n          case _BUTTONS.EAST_BTN:\n            _BUTTON_MAPPING[buttonIdx]();break;\n          case _BUTTONS.WEST_BTN:\n            _BUTTON_MAPPING[buttonIdx]();break;\n          case _BUTTONS.NORTH_BTN:\n            _BUTTON_MAPPING[buttonIdx]();break;\n          case _BUTTONS.NORTH_DPAD:\n            _BUTTON_MAPPING[buttonIdx]();break;\n          case _BUTTONS.SOUTH_DPAD:\n            _BUTTON_MAPPING[buttonIdx]();break;\n          case _BUTTONS.WEST_DPAD:\n            _BUTTON_MAPPING[buttonIdx]();break;\n          case _BUTTONS.EAST_DPAD:\n            _BUTTON_MAPPING[buttonIdx]();break;\n          case _BUTTONS.RIGHT_STICK_BUTTON:\n            _BUTTON_MAPPING[buttonIdx]();break;\n          case _BUTTONS.LEFT_STICK_BUTTON:\n            _BUTTON_MAPPING[buttonIdx]();break;\n          case _BUTTONS.LEFT_TRIGGER:\n            _BUTTON_MAPPING[buttonIdx](_gamepad.buttons[_BUTTONS.LEFT_TRIGGER].value);break;\n          case _BUTTONS.RIGHT_TRIGGER:\n            _BUTTON_MAPPING[buttonIdx](_gamepad.buttons[_BUTTONS.RIGHT_TRIGGER].value);break;}\n\n      }\n  }\n\n  var setMapping = function setMapping(mapping) {\n    switch (mapping) {\n      case \"headtracker\":\n        _BUTTON_MAPPING[_BUTTONS.SOUTH_BTN] = selectObject;\n        _BUTTON_MAPPING[_BUTTONS.SOUTH_DPAD] = goHome;\n        _BUTTON_MAPPING[_BUTTONS.NORTH_DPAD] = toggleNavMode;\n        _BUTTON_MAPPING[_BUTTONS.WEST_BTN] = hideObject;\n        _BUTTON_MAPPING[_BUTTONS.LEFT_SHOULDER] = decAltitude;\n        _BUTTON_MAPPING[_BUTTONS.RIGHT_SHOULDER] = incAltitude;\n        _BUTTON_MAPPING[_BUTTONS.LEFT_TRIGGER] = explode;\n        _BUTTON_MAPPING[_BUTTONS.RIGHT_TRIGGER] = fineSpeedAdjust;\n        _BUTTON_MAPPING[_BUTTONS.RIGHT_STICK_BUTTON] = deselectAll;\n        _BUTTON_MAPPING[_BUTTONS.LEFT_STICK_BUTTON] = unhideAll;\n        break;\n      default:\n        _BUTTON_MAPPING[_BUTTONS.SOUTH_BTN] = selectObject;\n        _BUTTON_MAPPING[_BUTTONS.EAST_BTN] = createSavePoint;\n        _BUTTON_MAPPING[_BUTTONS.WEST_BTN] = hideObject;\n        _BUTTON_MAPPING[_BUTTONS.NORTH_BTN] = showPropertyPanel;\n        _BUTTON_MAPPING[_BUTTONS.SOUTH_DPAD] = goHome;\n        _BUTTON_MAPPING[_BUTTONS.WEST_DPAD] = previousSavePoint;\n        _BUTTON_MAPPING[_BUTTONS.EAST_DPAD] = nextSavePoint;\n        _BUTTON_MAPPING[_BUTTONS.NORTH_DPAD] = toggleNavMode;\n        _BUTTON_MAPPING[_BUTTONS.LEFT_SHOULDER] = decAltitude;\n        _BUTTON_MAPPING[_BUTTONS.RIGHT_SHOULDER] = incAltitude;\n        _BUTTON_MAPPING[_BUTTONS.LEFT_TRIGGER] = triggerZoom;\n        _BUTTON_MAPPING[_BUTTONS.RIGHT_TRIGGER] = fineSpeedAdjust;\n        _BUTTON_MAPPING[_BUTTONS.RIGHT_STICK_BUTTON] = deselectAll;\n        _BUTTON_MAPPING[_BUTTONS.LEFT_STICK_BUTTON] = unhideAll;\n        break;}\n\n  };\n\n  //things buttons can do below\n  var goHome = function goHome() {\n    viewerapi.navigation.setRequestHomeView(true);\n    viewerapi.showAll();\n    viewerapi.impl.selector.clearSelection();\n    viewerapi.explode(0);\n  };\n\n  //Shoulder buttons and triggers\n  var decAltitude = function decAltitude() {\n    if (_lockInPlane)\n    _altitudeLockCoord += -_gamepad.buttons[_BUTTONS.LEFT_SHOULDER].pressed * _actualMoveSpeed;else\n\n    _camera.translateY(-_gamepad.buttons[_BUTTONS.LEFT_SHOULDER].pressed * _actualMoveSpeed);\n  };\n\n  var incAltitude = function incAltitude() {\n    if (_lockInPlane)\n    _altitudeLockCoord += _gamepad.buttons[_BUTTONS.RIGHT_SHOULDER].pressed * _actualMoveSpeed;else\n\n    _camera.translateY(_gamepad.buttons[_BUTTONS.RIGHT_SHOULDER].pressed * _actualMoveSpeed);\n  };\n\n  var explode = function explode(analog_value) {\n    if (analog_value > _THRESHOLD) {\n      if (analog_value == 0.5) {//not set yet\n        viewerapi.explode(0);\n        return;\n      }\n      _explodeSpeed = analog_value;\n      var ns = _explodeSpeed;\n      if (ns > 1) ns = 1;\n      if (ns < 0) ns = 0;\n      viewerapi.explode(ns);\n    } else\n\n    viewerapi.explode(0);\n  };\n\n\n  //Triggers are analog, so pass in value of trigger\n  var triggerZoom = function triggerZoom(analog_value) {\n    if (analog_value > _THRESHOLD) {\n      if (analog_value == 0.5) {\n        _camera.fov = _INITIAL_FOV;\n        _btnPressMap[_BUTTONS.LEFT_TRIGGER] = false;\n        return;\n      }\n      //linear interp: y = -40x + 75\n      ///75 is original fov angle. smaller slope = greater max zoom.\n      // equation will interpolate between based on trigger pressure (analog)\n      _camera.fov = _ZOOM_SCALAR * analog_value + _INITIAL_FOV;\n    } else\n    {\n      _camera.fov = _INITIAL_FOV; //originally 75\n    }\n  };\n\n  var fineSpeedAdjust = function fineSpeedAdjust(analog_value) {\n    if (analog_value > _THRESHOLD) {\n      if (analog_value == 0.5) {//ignore\n        //TODO set speed correctly before input received AND have whole speedadjust down here!!\n        _btnPressMap[_BUTTONS.RIGHT_TRIGGER] = false;\n        return;\n      }\n      _speed_scalar = -(_SPEED_ADJUST * analog_value) + _INITIAL_SPEED_SCALAR;\n    } else\n    {\n      _speed_scalar = _INITIAL_SPEED_SCALAR;\n    }\n\n  };\n\n  var createSavePoint = function createSavePoint() {\n    var state = _viewerState.getState(VIEWER_STATE_FILTER);\n    _savepoints.push(state);\n    avp.logger.log(\"Savepoint created.\");\n  };\n\n  var previousSavePoint = function previousSavePoint() {\n    if (_savepoints.length) {\n      _nextsavepoint--;\n      if (_nextsavepoint < 0)\n      _nextsavepoint = _savepoints.length - 1;\n      _viewerState.restoreState(_savepoints[_nextsavepoint]);\n    }\n  };\n\n  var nextSavePoint = function nextSavePoint() {\n    if (_savepoints.length) {\n      _nextsavepoint++;\n      if (_nextsavepoint >= _savepoints.length)\n      _nextsavepoint = 0;\n      _viewerState.restoreState(_savepoints[_nextsavepoint]);\n    }\n  };\n\n  var selectObject = function selectObject() {\n    var res = viewerapi.impl.hitTestViewport(new THREE.Vector3(0, 0, 0));\n    if (_currentTool == \"headtracker\") {\n      //vr tool forgets to do this, necessary for center selection\n      _camera.updateMatrixWorld();\n    }\n    if (res) {\n      viewerapi.impl.selector.toggleSelection(res.dbId, res.model);\n      //viewerapi.fitToView(res.dbId);\n    } else {\n      viewerapi.impl.selector.clearSelection();\n    }\n  };\n\n  var deselectAll = function deselectAll() {\n    viewerapi.impl.selector.clearSelection();\n  };\n\n  var unhideAll = function unhideAll() {\n    viewerapi.showAll();\n    viewerapi.impl.selector.clearSelection();\n    viewerapi.explode(0);\n  };\n\n  var hideObject = function hideObject() {\n    var res = viewerapi.impl.hitTestViewport(new THREE.Vector3(0, 0, 0), false);\n    if (res) {\n      // TODO: this doesn't seem right. Probably should use indexOf()\n      if (res.dbId in viewerapi.getHiddenNodes())\n      viewerapi.show(res.dbId);else\n\n      viewerapi.hide(res.dbId);\n    }\n  };\n\n  var showPropertyPanel = function showPropertyPanel() {\n    viewerapi.getPropertyPanel(true).setVisible(!viewerapi.getPropertyPanel(true).isVisible());\n  };\n\n  var toggleNavMode = function toggleNavMode() {\n    _lockInPlane = !_lockInPlane;\n    if (_lockInPlane)\n    _altitudeLockCoord = _camera.position.z;\n    showDPadHud(\"up\");\n  };\n\n  init();\n}"],"mappings":";;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AClFA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AClIA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACnxBA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;A","sourceRoot":""}