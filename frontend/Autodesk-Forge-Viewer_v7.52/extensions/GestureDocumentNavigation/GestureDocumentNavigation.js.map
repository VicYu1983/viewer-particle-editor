{"version":3,"file":"GestureDocumentNavigation/GestureDocumentNavigation.js","sources":["webpack://Autodesk.Extensions.[name]/webpack/bootstrap","webpack://Autodesk.Extensions.[name]/./extensions/GestureDocumentNavigation/BubbleUtils.js","webpack://Autodesk.Extensions.[name]/./extensions/GestureDocumentNavigation/CameraUtils.js","webpack://Autodesk.Extensions.[name]/./extensions/GestureDocumentNavigation/GeometryUtils.js","webpack://Autodesk.Extensions.[name]/./extensions/GestureDocumentNavigation/GestureDocumentNavigation.js","webpack://Autodesk.Extensions.[name]/./extensions/GestureDocumentNavigation/GestureDocumentNavigationConstants.js","webpack://Autodesk.Extensions.[name]/./extensions/GestureDocumentNavigation/GestureDocumentNavigationTool.js","webpack://Autodesk.Extensions.[name]/./extensions/GestureDocumentNavigation/ModelUtils.js"],"sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./extensions/GestureDocumentNavigation/GestureDocumentNavigation.js\");\n","import ModelUtils from './ModelUtils';\n\nexport var parseBubble = function parseBubble(viewerDoc) {\n  var doc = viewerDoc;\n  var viewableItem = doc.getRoot().findAllViewables()[0];\n  var fileExtension = ModelUtils.getModelExtension(viewableItem.name());\n\n  function buildTree(node, role) {\n    // Don't save nodes with type other than 'folder' or 'view' or 'geometry'.\n    if (!(node.type() === 'folder' || node.type() === 'view' || node.type() === 'geometry')) {\n      return null;\n    }\n\n    // Don't save a geometry with a different role than the given one (2d or 3d).\n    if (node.type() === 'geometry' && node.data.role !== role) {\n      return null;\n    }\n\n    var outputNode = {\n      guid: node.guid(),\n      name: node.name(),\n      type: node.type() };\n\n\n    if (node.type() === 'geometry') {\n      outputNode.order = node.data.order;\n      outputNode.status = node.data.status;\n      outputNode.role = node.data.role;\n      outputNode.hasThumbnail = node.data.hasThumbnail && node.data.hasThumbnail.toLowerCase() === 'true';\n    }\n\n    if (node.children) {\n      // build the subtree of the node's children.\n      var outputChildren = node.children.map(function (child) {return buildTree(child, role);}).filter(function (child) {return !!child;});\n\n      if (outputChildren.length > 0) {\n        outputNode.children = outputChildren;\n      }\n    }\n\n    // Don't save empty folders\n    if (node.type() === 'folder' && !outputNode.children) {\n      return null;\n    }\n\n    return outputNode;\n  }\n\n  var getGeometries = function getGeometries(tree) {\n    if (!tree) {\n      return [];\n    }\n    var wrapper = new Autodesk.Viewing.BubbleNode(tree);\n    var geometries = wrapper.search({ type: 'geometry' });\n    if (geometries) {\n      return geometries.map(function (geometry) {return geometry.data;});\n    }\n\n    return null;\n  };\n\n  var modifyGeometries = function modifyGeometries(geometries) {\n    geometries.forEach(function (geometry) {\n      // PDFs can have only one single view - so if there are more, remove them.\n      if (fileExtension === 'pdf' && geometry.children && geometry.children.length > 1) {\n        geometry.children = [geometry.children[0]];\n      }\n    });\n\n\n    // If current document is PDF, then sort geometries by 'order' property.\n    // Since pdf extractor will handle pdf by parallel process, the geometries list may out of order.\n    if (fileExtension === 'pdf') {\n      geometries.sort(function (a, b) {\n        return a.order - b.order;\n      });\n    } else {\n      geometries.sort(function (a, b) {\n        return a.name.localeCompare(b.name);\n      });\n    }\n\n    return geometries;\n  };\n\n  var filterGeometries = function filterGeometries(geometries) {\n    return geometries.filter(function (geometry) {return (\n        // NWD extractor doesn't support 2d files. If they do appear, ignore them.\n        !(fileExtension === 'nwd' && geometry.role === '2d'));});\n\n\n    // In case you want to add another filter here, just compose like this: a.filter(b => b>2).filter(c => c>3).\n  };\n\n  if (fileExtension === 'pdf') {\n    var pdfItems = filterGeometries(modifyGeometries(getGeometries(buildTree(viewableItem, '2d'))));\n\n    return [{ type: 'PDF', sheets: pdfItems }];\n  } else {\n    var geometries3D = filterGeometries(modifyGeometries(getGeometries(buildTree(viewableItem, '3d'))));\n    var geometries2D = filterGeometries(modifyGeometries(getGeometries(buildTree(viewableItem, '2d'))));\n\n    return [\n    { type: '2D', sheets: geometries2D },\n    { type: '3D', sheets: geometries3D }];\n\n  }\n};","import GeometryUtils from './GeometryUtils';\n\nvar CameraUtils = {};\n\n// Same as viewer.worldToClient, but with a camera as argument.\nCameraUtils.worldToClient = function (viewer, point, camera) {\n  var p = new THREE.Vector4(point.x, point.y, point.z, 1);\n  p.applyMatrix4(camera.matrixWorldInverse);\n  p.applyMatrix4(camera.projectionMatrix);\n\n  // Don't want to mirror values with negative z (behind camera)\n  if (p.w > 0) {\n    p.x /= p.w;\n    p.y /= p.w;\n    p.z /= p.w;\n  }\n\n  return viewer.impl.viewportToClient(p.x, p.y);\n};\n\nCameraUtils.getCameraEyeVector = function (camera) {\n  return camera.target.clone().sub(camera.position).normalize();\n};\n\nCameraUtils.getCameraRightVector = function (camera) {\n  var eye = CameraUtils.getCameraEyeVector(camera);\n  return new THREE.Vector3().crossVectors(eye, camera.up).normalize();\n};\n\nCameraUtils.getCameraUpVector = function (camera) {\n  var right = CameraUtils.getCameraRightVector(camera);\n  var eye = CameraUtils.getCameraEyeVector(camera);\n  return new THREE.Vector3().crossVectors(right, eye).normalize();\n};\n\nCameraUtils.getCameraRotation = function (camera) {\n  return GeometryUtils.getSignedAngle(CameraUtils.getCameraUpVector(camera), new THREE.Vector3(0, 1, 0), CameraUtils.getCameraEyeVector(camera));\n};\n\nexport default CameraUtils;","var GeometryUtils = {};\n\nGeometryUtils.radiansToDegrees = function (radians) {\n  return radians * (180 / Math.PI);\n};\n\nGeometryUtils.degreesToRadians = function (degrees) {\n  return degrees * (Math.PI / 180);\n};\n\nGeometryUtils.applyRotation = function (points, angle, pivot, frontVector) {\n  if (!(points instanceof Array)) {\n    points = [points];\n  }\n\n  points.forEach(function (point) {\n    point.sub(pivot);\n    point.applyAxisAngle(frontVector, angle);\n    point.add(pivot);\n  });\n};\n\nGeometryUtils.getSignedAngle = function (v1, v2, eyeVector) {\n  var angle = v1.angleTo(v2);\n\n  var n = v1.clone().cross(v2).normalize();\n  var sign = eyeVector.dot(n) > 0 ? 1 : -1;\n\n  return angle * sign;\n};\n\nGeometryUtils.swapBoundingBoxY = function (boundingBox) {var _ref =\n  [boundingBox.min.y, boundingBox.max.y];boundingBox.max.y = _ref[0];boundingBox.min.y = _ref[1];\n\n  return boundingBox;\n};\n\nexport default GeometryUtils;","function _typeof(obj) {\"@babel/helpers - typeof\";if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;};}return _typeof(obj);}function _toConsumableArray(arr) {return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();}function _nonIterableSpread() {throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");}function _unsupportedIterableToArray(o, minLen) {if (!o) return;if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);var n = Object.prototype.toString.call(o).slice(8, -1);if (n === \"Object\" && o.constructor) n = o.constructor.name;if (n === \"Map\" || n === \"Set\") return Array.from(o);if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);}function _iterableToArray(iter) {if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);}function _arrayWithoutHoles(arr) {if (Array.isArray(arr)) return _arrayLikeToArray(arr);}function _arrayLikeToArray(arr, len) {if (len == null || len > arr.length) len = arr.length;for (var i = 0, arr2 = new Array(len); i < len; i++) {arr2[i] = arr[i];}return arr2;}function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {try {var info = gen[key](arg);var value = info.value;} catch (error) {reject(error);return;}if (info.done) {resolve(value);} else {Promise.resolve(value).then(_next, _throw);}}function _asyncToGenerator(fn) {return function () {var self = this,args = arguments;return new Promise(function (resolve, reject) {var gen = fn.apply(self, args);function _next(value) {asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);}function _throw(err) {asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);}_next(undefined);});};}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError(\"Cannot call a class as a function\");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}function _inherits(subClass, superClass) {if (typeof superClass !== \"function\" && superClass !== null) {throw new TypeError(\"Super expression must either be null or a function\");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}function _createSuper(Derived) {var hasNativeReflectConstruct = _isNativeReflectConstruct();return function _createSuperInternal() {var Super = _getPrototypeOf(Derived),result;if (hasNativeReflectConstruct) {var NewTarget = _getPrototypeOf(this).constructor;result = Reflect.construct(Super, arguments, NewTarget);} else {result = Super.apply(this, arguments);}return _possibleConstructorReturn(this, result);};}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");}return self;}function _isNativeReflectConstruct() {if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;if (Reflect.construct.sham) return false;if (typeof Proxy === \"function\") return true;try {Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));return true;} catch (e) {return false;}}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}import CameraUtils from './CameraUtils';\nimport GeometryUtils from './GeometryUtils';\nimport { parseBubble } from './BubbleUtils';\nimport GestureDocumentNavigationTool from './GestureDocumentNavigationTool';\n\n/**\n                                                                              * Provide an option to switch sheets and documents, using gestures.\n                                                                              * \n                                                                              * The extension id is: `Autodesk.BIM360.GestureDocumentNavigation`\n                                                                              * \n                                                                              * @example\n                                                                              *   viewer.loadExtension('Autodesk.BIM360.GestureDocumentNavigation')\n                                                                              *  \n                                                                              * @memberof Autodesk.Viewing.Extensions\n                                                                              * @alias Autodesk.Viewing.Extensions.GestureDocumentNavigationExtension\n                                                                              * @see {@link Autodesk.Viewing.Extension} for common inherited methods.\n                                                                              */var\nGestureDocumentNavigationExtension = /*#__PURE__*/function (_Autodesk$Viewing$Ext) {_inherits(GestureDocumentNavigationExtension, _Autodesk$Viewing$Ext);var _super = _createSuper(GestureDocumentNavigationExtension);function GestureDocumentNavigationExtension() {_classCallCheck(this, GestureDocumentNavigationExtension);return _super.apply(this, arguments);}_createClass(GestureDocumentNavigationExtension, [{ key: \"load\",\n    /**\n                                                                                                                                                                                                                                                                                                                                                                                                                                        * Load the GestureDocumentNavigation extension.\n                                                                                                                                                                                                                                                                                                                                                                                                                                        *\n                                                                                                                                                                                                                                                                                                                                                                                                                                        * @returns {boolean} True if measure extension is loaded successfully.\n                                                                                                                                                                                                                                                                                                                                                                                                                                        * \n                                                                                                                                                                                                                                                                                                                                                                                                                                        * @alias Autodesk.Viewing.Extensions.GestureDocumentNavigationExtension#load\n                                                                                                                                                                                                                                                                                                                                                                                                                                        */value: function () {var _load = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {var _this = this;var documentNode, viewerDoc, items, items2D, items3D, prevLock, cache, translation, negativeTranslation;return regeneratorRuntime.wrap(function _callee2$(_context2) {while (1) {switch (_context2.prev = _context2.next) {case 0:\n\n                documentNode = this.viewer.impl.model.getDocumentNode();\n                viewerDoc = documentNode.getRootNode().lmvDocument;\n\n                this.currentGuid = documentNode.guid();\n                this.currentUrn = viewerDoc.myData.urn;\n\n                this.documents = [{ urn: this.currentUrn, guid: this.currentGuid }];\n\n                items = parseBubble(viewerDoc);\n                items2D = items[0] && items[0].sheets || [];\n                items3D = items[1] && items[1].sheets || [];\n                this.sheets = [].concat(_toConsumableArray(items2D), _toConsumableArray(items3D));\n\n                this.pivot = new THREE.Vector3();\n\n                this.currentSheetIndex = this.sheets.findIndex(function (sheet) {return sheet.guid === _this.currentGuid;});\n                this.updateCurrentDocumentIndex();\n\n                this.tool = new GestureDocumentNavigationTool(this);\n\n                this.viewer.toolController.registerTool(this.tool);\n\n                prevLock = this.viewer.toolController.setIsLocked(false);\n                this.viewer.toolController.activateTool(this.tool.getName());\n                this.viewer.toolController.setIsLocked(prevLock);\n\n                cache = this.getCache();if (!\n\n                this.viewer.impl.is2d) {_context2.next = 28;break;}\n                this.viewer.fitToView(undefined, undefined, true);if (!\n\n                cache.direction) {_context2.next = 26;break;}\n                translation = this.getTranslation(cache.direction);\n                negativeTranslation = translation.clone().negate();_context2.next = 25;return (\n                  this.translateCamera(negativeTranslation, true));case 25:\n                this.viewer.addEventListener(Autodesk.Viewing.RENDER_PRESENTED_EVENT, /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {return regeneratorRuntime.wrap(function _callee$(_context) {while (1) {switch (_context.prev = _context.next) {case 0:_context.next = 2;return (\n                            _this.translateCamera(translation, false));case 2:\n                          cache.direction = undefined;case 3:case \"end\":return _context.stop();}}}, _callee);})),\n                { once: true });case 26:_context2.next = 29;break;case 28:\n\n\n                cache.direction = undefined;case 29:return _context2.abrupt(\"return\",\n\n\n                true);case 30:case \"end\":return _context2.stop();}}}, _callee2, this);}));function load() {return _load.apply(this, arguments);}return load;}()\n\n\n    /**\n                                                                                                                                                                 * Unload the measure extension.\n                                                                                                                                                                 *\n                                                                                                                                                                 * @returns {boolean} True if measure extension is unloaded successfully.\n                                                                                                                                                                 * \n                                                                                                                                                                 * @alias Autodesk.Viewing.Extensions.GestureDocumentNavigationExtension#unload\n                                                                                                                                                                 */ }, { key: \"unload\", value: function unload()\n    {\n      if (this.tool) {\n        this.viewer.toolController.deregisterTool(this.tool);\n        this.tool = null;\n      }\n\n      this.viewer = null;\n      this.options = null;\n\n      return true;\n    } }, { key: \"updateNextDocument\", value: function updateNextDocument(\n\n    urn, guid) {\n      this.documents.push({ urn: urn, guid: guid });\n      this.updateCurrentDocumentIndex();\n    } }, { key: \"updatePrevDocument\", value: function updatePrevDocument(\n\n    urn, guid) {\n      this.documents.unshift({ urn: urn, guid: guid });\n      this.updateCurrentDocumentIndex();\n    } }, { key: \"updateCurrentDocumentIndex\", value: function updateCurrentDocumentIndex()\n\n    {var _this2 = this;\n      this.currentDocumentIndex = this.documents.findIndex(\n      function (doc) {return doc.urn === _this2.currentUrn && doc.guid === _this2.currentGuid;});\n\n    }\n\n    /**\n       * Prepare current document before switching sheet / document.\n       *\n       * @param {Function} cb - This callback is called after current document is ready to switch.\n       * @alias Autodesk.Viewing.Extensions.GestureDocumentNavigationExtension#prepareChange\n       */ }, { key: \"prepareChange\", value: function () {var _prepareChange = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(\n      cb) {var _this3 = this;var onDone, translation;return regeneratorRuntime.wrap(function _callee3$(_context3) {while (1) {switch (_context3.prev = _context3.next) {case 0:\n                onDone = function onDone() {\n                  var cache = _this3.getCache();\n                  cache.direction = _this3.tool.currentDirection;\n                  cb();\n                };if (!\n\n                this.viewer.model.is3d()) {_context3.next = 5;break;}\n                onDone();_context3.next = 9;break;case 5:\n\n                translation = this.getTranslation(this.tool.currentDirection);_context3.next = 8;return (\n                  this.translateCamera(translation, false));case 8:\n                onDone();case 9:case \"end\":return _context3.stop();}}}, _callee3, this);}));function prepareChange(_x) {return _prepareChange.apply(this, arguments);}return prepareChange;}()\n\n\n\n    /**\n                                                                                                                                                                                                * Change a sheet.\n                                                                                                                                                                                                *\n                                                                                                                                                                                                * @param {number} guid - The guid of the desired sheet.\n                                                                                                                                                                                                * @alias Autodesk.Viewing.Extensions.GestureDocumentNavigationExtension#changeSheetRequired\n                                                                                                                                                                                                */ }, { key: \"changeSheetRequired\", value: function changeSheetRequired(\n    guid) {var _this4 = this;\n      if (!this.options.enableSheetSwipe || !guid) {\n        return;\n      }\n\n      this.prepareChange(function () {\n        _this4.viewer.dispatchEvent({ type: Autodesk.Viewing.GestureDocumentNavigationEvents.CHANGE_SHEET_REQUIRED, guid: guid });\n      });\n    }\n\n    /**\n       * Change a document.\n       *\n       * @param {number} urn - The urn of the desired document.\n       * @param {number} guid - The guid of the desired sheet.\n       * @alias Autodesk.Viewing.Extensions.GestureDocumentNavigationExtension#changeSheetRequired\n       */ }, { key: \"changeDocumentRequired\", value: function changeDocumentRequired(\n    urn, guid) {var _this5 = this;\n      if (!urn) {\n        return;\n      }\n\n      this.prepareChange(function () {\n        _this5.viewer.dispatchEvent({ type: Autodesk.Viewing.GestureDocumentNavigationEvents.CHANGE_DOCUMENT_REQUIRED, urn: urn, guid: guid });\n      });\n    } }, { key: \"getTranslation\", value: function getTranslation(\n\n    direction) {\n      var camera = this.viewer.getCamera();\n      var size = Math.max(camera.top - camera.bottom, camera.right - camera.left);\n      var translation = direction.clone().multiplyScalar(size);\n\n      var cameraRotation = CameraUtils.getCameraRotation(camera);\n      var eyeVec = CameraUtils.getCameraEyeVector(camera);\n      GeometryUtils.applyRotation(translation, -cameraRotation, this.pivot, eyeVec);\n\n      return translation;\n    } }, { key: \"translateCamera\", value: function () {var _translateCamera = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(\n\n      translation, immediate) {var camera, position, target;return regeneratorRuntime.wrap(function _callee4$(_context4) {while (1) {switch (_context4.prev = _context4.next) {case 0:\n                this.viewer.utilities.autocam.endInteraction();\n\n                camera = this.viewer.getCamera();\n\n                position = camera.position.clone().add(translation);\n                target = camera.target.clone().add(translation);if (!\n\n                immediate) {_context4.next = 8;break;}\n                this.viewer.navigation.setView(position, target);_context4.next = 11;break;case 8:\n\n                this.viewer.navigation.setRequestTransitionWithUp(true, position, target, camera.fov, camera.up);_context4.next = 11;return (\n                  Autodesk.Viewing.EventUtils.waitUntilTransitionEnded(this.viewer));case 11:case \"end\":return _context4.stop();}}}, _callee4, this);}));function translateCamera(_x2, _x3) {return _translateCamera.apply(this, arguments);}return translateCamera;}() }]);return GestureDocumentNavigationExtension;}(Autodesk.Viewing.Extension);export { GestureDocumentNavigationExtension as default };\n\n\n\n\nAutodesk.Viewing.GestureDocumentNavigationEvents = {};\nAutodesk.Viewing.GestureDocumentNavigationEvents.CHANGE_DOCUMENT_REQUIRED = 'change.document.required';\nAutodesk.Viewing.GestureDocumentNavigationEvents.CHANGE_SHEET_REQUIRED = 'change.sheet.required';\n\nGestureDocumentNavigationExtension.extensionName = 'Autodesk.BIM360.GestureDocumentNavigation';\n\nAutodesk.Viewing.theExtensionManager.registerExtension(GestureDocumentNavigationExtension.extensionName, GestureDocumentNavigationExtension);","export var NAVIGATION_DISTANCE_2D = 50;\nexport var NAVIGATION_DISTANCE_3D = 350; // In order to prevent unwanted navigation, the minimum navigation distance is pretty high.\nexport var NAVIGATION_VELOCITY_2D = 0.7;\nexport var NAVIGATION_VELOCITY_3D = 1.1;","function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError(\"Cannot call a class as a function\");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}import GeometryUtils from './GeometryUtils';\nimport * as Constants from './GestureDocumentNavigationConstants';var\n\nGestureDocumentNavigationTool = /*#__PURE__*/function () {\n  function GestureDocumentNavigationTool(extension) {_classCallCheck(this, GestureDocumentNavigationTool);\n    this.viewer = extension.viewer;\n    this.navigationDistance = this.viewer.impl.is2d ? Constants.NAVIGATION_DISTANCE_2D : Constants.NAVIGATION_DISTANCE_3D;\n    this.navigationVelocity = this.viewer.impl.is2d ? Constants.NAVIGATION_VELOCITY_2D : Constants.NAVIGATION_VELOCITY_3D;\n\n    this.documents = extension.documents;\n    this.sheets = extension.sheets;\n\n    this.extension = extension;\n\n    this.names = ['gesture-document-navigation'];\n\n    this.leftDirection = new THREE.Vector3(1, 0, 0);\n    this.rightDirection = new THREE.Vector3(-1, 0, 0);\n    this.upDirection = new THREE.Vector3(0, 1, 0);\n    this.downDirection = new THREE.Vector3(0, -1, 0);\n    this.eyeVector = new THREE.Vector3(0, 0, 1);\n\n    this.currentDirection = null;\n  }_createClass(GestureDocumentNavigationTool, [{ key: \"getNames\", value: function getNames()\n\n    {\n      return this.names;\n    } }, { key: \"getName\", value: function getName()\n\n    {\n      return this.names[0];\n    } }, { key: \"activate\", value: function activate(\n\n    name) {\n      if (name === this.getName()) {\n        this.isActive = true;\n      }\n    } }, { key: \"deactivate\", value: function deactivate(\n\n    name) {\n      if (name === this.getName()) {\n        this.isActive = false;\n      }\n    } }, { key: \"isActive\", value: function isActive()\n\n    {\n      return this.isActive;\n    } }, { key: \"getPriority\", value: function getPriority()\n\n    {\n      return 100;\n    } }, { key: \"_isCanvasContainsViewport\", value: function _isCanvasContainsViewport()\n\n    {\n      var bounds = Autodesk.Viewing.ScreenShot.getSceneClientBounds(this.viewer, this.viewer.navigation.getCamera());\n      var containerBounds = this.viewer.impl.getCanvasBoundingClientRect();\n\n      return bounds.min.x > containerBounds.left &&\n      bounds.max.x < containerBounds.right &&\n      bounds.min.y > containerBounds.height - containerBounds.bottom &&\n      bounds.max.y < containerBounds.height - containerBounds.top;\n\n    }\n\n    /**\n       * On Drag event, gets the the right item to switch to, based on user gesture's direction,\n       * @returns {boolean} True if there is an item to move to.\n       * @param {boolean} event - Dragmove event.\n       * @private\n      */ }, { key: \"onDrag\", value: function onDrag(\n    event) {\n      var v = new THREE.Vector3(event.canvasX, event.canvasY, 0).sub(this.startPoint);\n      var length = v.length();\n\n      var angle = GeometryUtils.getSignedAngle(v, this.leftDirection, this.eyeVector);\n\n      if (angle < 0) {\n        angle += 2 * Math.PI;\n      }\n\n      var indexToLoad = null;\n      var isSheet;\n      var isDocument;\n\n      if (angle > 5 / 4 * Math.PI && angle < 7 / 4 * Math.PI && this.sheets.length > 1) {\n        this.currentDirection = this.upDirection;\n\n        if (this.extension.currentSheetIndex === 0) {\n          if (this.extension.options.enableCyclicSwipe) {\n            indexToLoad = this.sheets.length - 1;\n          }\n        } else {\n          indexToLoad = this.extension.currentSheetIndex - 1;\n        }\n\n        isSheet = true;\n      } else if (angle > 1 / 4 * Math.PI && angle <= 3 / 4 * Math.PI && this.sheets.length > 1) {\n        this.currentDirection = this.downDirection;\n\n        if (this.extension.currentSheetIndex === this.sheets.length - 1) {\n          if (this.extension.options.enableCyclicSwipe) {\n            indexToLoad = 0;\n          }\n        } else {\n          indexToLoad = this.extension.currentSheetIndex + 1;\n        }\n\n        isSheet = true;\n      } else if (angle > 3 / 4 * Math.PI && angle <= 5 / 4 * Math.PI && this.documents.length > 1) {\n        this.currentDirection = this.leftDirection;\n\n        if (this.extension.currentDocumentIndex === this.documents.length - 1) {\n          if (this.extension.options.enableCyclicSwipe) {\n            indexToLoad = 0;\n          }\n        } else {\n          indexToLoad = this.extension.currentDocumentIndex + 1;\n        }\n\n        isDocument = true;\n      } else if ((angle > 7 / 4 * Math.PI || angle <= 1 / 4 * Math.PI) && this.documents.length > 1) {\n        this.currentDirection = this.rightDirection;\n\n        if (this.extension.currentDocumentIndex === 0) {\n          if (this.extension.options.enableCyclicSwipe) {\n            indexToLoad = this.documents.length - 1;\n          }\n        } else {\n          indexToLoad = this.extension.currentDocumentIndex - 1;\n        }\n\n        isDocument = true;\n      }\n\n      var hasItem = indexToLoad !== null && (isSheet || isDocument);\n\n      if (hasItem && length >= this.navigationDistance) {\n        if (isSheet) {var\n          guid = this.sheets[indexToLoad].guid;\n          this.extension.changeSheetRequired(guid);\n        } else if (isDocument) {var _this$documents$index =\n          this.documents[indexToLoad],urn = _this$documents$index.urn,_guid = _this$documents$index.guid;\n          this.extension.changeDocumentRequired(urn, _guid);\n        }\n\n        this.changing = true;\n      }\n\n      return hasItem;\n    } }, { key: \"_isSwipeEnabled\", value: function _isSwipeEnabled()\n\n    {\n      return this.viewer.model.is3d() || this._isCanvasContainsViewport();\n    } }, { key: \"handleGesture\", value: function handleGesture(\n\n    event) {\n      switch (event.type) {\n        case 'dragstart':\n          this.isSwipeEnabled = this._isSwipeEnabled();\n          if (this.isSwipeEnabled) {\n            this.startPoint = new THREE.Vector3(event.canvasX, event.canvasY, 0);\n          }\n\n          this.swiping = false;\n          this.changing = false;\n\n          return false;\n        case 'dragmove':\n          if (this.changing) {\n            return true;\n          } else if (this.swiping || this.isSwipeEnabled && Math.abs(event.overallVelocity) > this.navigationVelocity) {\n            this.swiping = true;\n            return this.onDrag(event);\n          }\n\n          return false;\n        case 'dragend':\n          // When finish swiping, prevent the camera from orbiting. Relevant for 3D only - there is no camera orbit for 2D.\n          // I limited this to 3D only, because of a bug I found when returning true when swiping from a 2D document to 3D document - It was blocking orbit.\n          return this.changing && this.viewer.model.is3d();\n\n        default:\n          break;}\n\n\n      return false;\n    } }]);return GestureDocumentNavigationTool;}();export { GestureDocumentNavigationTool as default };","var ModelUtils = {};\n\nModelUtils.getModelExtension = function (url) {\n  var match = url && url.toLowerCase().match(/\\.([a-z0-9]+)(\\?|$)/);\n  var fileExtension = match ? match[1] : null;\n  return fileExtension;\n};\n\nexport default ModelUtils;"],"mappings":";;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AClFA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC3GA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACvCA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACrCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACtMA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;;;;;;;;;;;;ACHA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC1LA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;A","sourceRoot":""}