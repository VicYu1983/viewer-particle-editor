{"version":3,"sources":["webpack://Autodesk.Extensions.[name]/webpack/bootstrap","webpack://Autodesk.Extensions.[name]/./extensions/GestureDocumentNavigation/GeometryUtils.js","webpack://Autodesk.Extensions.[name]/./extensions/GestureDocumentNavigation/CameraUtils.js","webpack://Autodesk.Extensions.[name]/./extensions/GestureDocumentNavigation/ModelUtils.js","webpack://Autodesk.Extensions.[name]/./extensions/GestureDocumentNavigation/BubbleUtils.js","webpack://Autodesk.Extensions.[name]/./extensions/GestureDocumentNavigation/GestureDocumentNavigationTool.js","webpack://Autodesk.Extensions.[name]/./extensions/GestureDocumentNavigation/GestureDocumentNavigationConstants.js","webpack://Autodesk.Extensions.[name]/./extensions/GestureDocumentNavigation/GestureDocumentNavigation.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","GeometryUtils","radians","Math","PI","degrees","points","angle","pivot","frontVector","Array","forEach","point","sub","applyAxisAngle","add","v1","v2","eyeVector","angleTo","clone","cross","normalize","dot","boundingBox","min","y","max","CameraUtils","viewer","camera","THREE","Vector4","x","z","applyMatrix4","matrixWorldInverse","projectionMatrix","w","impl","viewportToClient","target","position","eye","getCameraEyeVector","Vector3","crossVectors","up","right","getCameraRightVector","getSignedAngle","getCameraUpVector","ModelUtils","url","match","toLowerCase","parseBubble","viewerDoc","viewableItem","getRoot","findAllViewables","fileExtension","getModelExtension","buildTree","node","role","type","data","outputNode","guid","order","status","hasThumbnail","children","outputChildren","map","child","filter","length","getGeometries","tree","geometries","Autodesk","Viewing","BubbleNode","search","geometry","modifyGeometries","sort","a","b","localeCompare","filterGeometries","sheets","geometries3D","GestureDocumentNavigationTool","extension","this","navigationDistance","is2d","navigationVelocity","documents","names","leftDirection","rightDirection","upDirection","downDirection","currentDirection","getName","isActive","bounds","ScreenShot","getSceneClientBounds","navigation","getCamera","containerBounds","getCanvasBoundingClientRect","left","height","bottom","top","event","v","canvasX","canvasY","startPoint","isSheet","isDocument","indexToLoad","currentSheetIndex","options","enableCyclicSwipe","currentDocumentIndex","hasItem","changeSheetRequired","urn","changeDocumentRequired","changing","model","is3d","_isCanvasContainsViewport","isSwipeEnabled","_isSwipeEnabled","swiping","abs","overallVelocity","onDrag","GestureDocumentNavigationExtension","Extension","documentNode","getDocumentNode","getRootNode","lmvDocument","currentGuid","currentUrn","myData","items","items2D","items3D","findIndex","sheet","updateCurrentDocumentIndex","tool","toolController","registerTool","prevLock","setIsLocked","activateTool","cache","getCache","fitToView","undefined","direction","translation","getTranslation","negativeTranslation","negate","translateCamera","addEventListener","RENDER_PRESENTED_EVENT","once","deregisterTool","push","unshift","doc","cb","onDone","enableSheetSwipe","prepareChange","dispatchEvent","GestureDocumentNavigationEvents","CHANGE_SHEET_REQUIRED","CHANGE_DOCUMENT_REQUIRED","size","multiplyScalar","cameraRotation","getCameraRotation","eyeVec","applyRotation","immediate","utilities","autocam","endInteraction","setView","setRequestTransitionWithUp","fov","EventUtils","waitUntilTransitionEnded","extensionName","theExtensionManager","registerExtension"],"mappings":"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","file":"GestureDocumentNavigation/GestureDocumentNavigation.min.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 844);\n","const GeometryUtils = {};\n\nGeometryUtils.radiansToDegrees = (radians) => {\n    return radians * (180 / Math.PI);\n};\n\nGeometryUtils.degreesToRadians = (degrees) => {\n    return degrees * (Math.PI / 180);\n};\n\nGeometryUtils.applyRotation = (points, angle, pivot, frontVector) => {\n    if (!(points instanceof Array)) {\n        points = [points];\n    }\n\n    points.forEach((point) => {\n        point.sub(pivot);\n        point.applyAxisAngle(frontVector, angle);\n        point.add(pivot);\n    });\n};\n\nGeometryUtils.getSignedAngle = (v1, v2, eyeVector) => {\n    const angle = v1.angleTo(v2);\n\n    const n = v1.clone().cross(v2).normalize();\n    const sign = eyeVector.dot(n) > 0 ? 1 : -1;\n\n    return angle * sign;\n};\n\nGeometryUtils.swapBoundingBoxY = (boundingBox) => {\n    [boundingBox.max.y, boundingBox.min.y] = [boundingBox.min.y, boundingBox.max.y];\n\n    return boundingBox;\n};\n\nexport default GeometryUtils;","import GeometryUtils from './GeometryUtils';\n\nconst CameraUtils = {};\n\n// Same as viewer.worldToClient, but with a camera as argument.\nCameraUtils.worldToClient = (viewer, point, camera) => {\n    var p = new THREE.Vector4(point.x, point.y, point.z, 1);\n    p.applyMatrix4(camera.matrixWorldInverse);\n    p.applyMatrix4(camera.projectionMatrix);\n\n    // Don't want to mirror values with negative z (behind camera)\n    if (p.w > 0) {\n        p.x /= p.w;\n        p.y /= p.w;\n        p.z /= p.w;\n    }\n\n    return viewer.impl.viewportToClient(p.x, p.y);\n};\n\nCameraUtils.getCameraEyeVector = (camera) => {\n    return camera.target.clone().sub(camera.position).normalize();\n};\n\nCameraUtils.getCameraRightVector = (camera) => {\n    const eye = CameraUtils.getCameraEyeVector(camera);\n    return new THREE.Vector3().crossVectors(eye, camera.up).normalize();\n};\n\nCameraUtils.getCameraUpVector = (camera) => {\n    const right = CameraUtils.getCameraRightVector(camera);\n    const eye = CameraUtils.getCameraEyeVector(camera);\n    return new THREE.Vector3().crossVectors(right, eye).normalize();\n};\n\nCameraUtils.getCameraRotation = (camera) => {\n    return GeometryUtils.getSignedAngle(CameraUtils.getCameraUpVector(camera), new THREE.Vector3(0, 1, 0), CameraUtils.getCameraEyeVector(camera));\n};\n\nexport default CameraUtils;","const ModelUtils = {};\n\nModelUtils.getModelExtension = (url) => {\n    const match = url && url.toLowerCase().match(/\\.([a-z0-9]+)(\\?|$)/);\n    const fileExtension = match ? match[1] : null;\n    return fileExtension;\n};\n\nexport default ModelUtils;","import ModelUtils from './ModelUtils';\n\nexport const parseBubble = (viewerDoc) => {\n    const doc = viewerDoc;\n    const viewableItem = doc.getRoot().findAllViewables()[0];\n    const fileExtension = ModelUtils.getModelExtension(viewableItem.name());\n\n    function buildTree(node, role) {\n        // Don't save nodes with type other than 'folder' or 'view' or 'geometry'.\n        if (!(node.type() === 'folder' || node.type() === 'view' || node.type() === 'geometry')) {\n            return null;\n        }\n\n        // Don't save a geometry with a different role than the given one (2d or 3d).\n        if (node.type() === 'geometry' && node.data.role !== role) {\n            return null;\n        }\n\n        const outputNode = {\n            guid: node.guid(),\n            name: node.name(),\n            type: node.type()\n        };\n\n        if (node.type() === 'geometry') {\n            outputNode.order = node.data.order;\n            outputNode.status = node.data.status;\n            outputNode.role = node.data.role;\n            outputNode.hasThumbnail = node.data.hasThumbnail && node.data.hasThumbnail.toLowerCase() === 'true';\n        }\n\n        if (node.children) {\n            // build the subtree of the node's children.\n            const outputChildren = node.children.map(child => buildTree(child, role)).filter(child => !!child);\n\n            if (outputChildren.length > 0) {\n                outputNode.children = outputChildren;\n            }\n        }\n\n        // Don't save empty folders\n        if (node.type() === 'folder' && !outputNode.children) {\n            return null;\n        }\n\n        return outputNode;\n    }\n\n    const getGeometries = (tree) => {\n        if (!tree) {\n            return [];\n        }\n        const wrapper = new Autodesk.Viewing.BubbleNode(tree);\n        const geometries = wrapper.search({ type: 'geometry' });\n        if (geometries) {\n            return geometries.map(geometry => geometry.data);\n        }\n\n        return null;\n    };\n\n    const modifyGeometries = (geometries) => {\n        geometries.forEach((geometry) => {\n            // PDFs can have only one single view - so if there are more, remove them.\n            if (fileExtension === 'pdf' && geometry.children && geometry.children.length > 1) {\n                geometry.children = [geometry.children[0]];\n            }\n        });\n\n\n        // If current document is PDF, then sort geometries by 'order' property.\n        // Since pdf extractor will handle pdf by parallel process, the geometries list may out of order.\n        if (fileExtension === 'pdf') {\n            geometries.sort(function (a, b) {\n                return a.order - b.order;\n            });\n        } else {\n            geometries.sort(function (a, b) {\n                return a.name.localeCompare(b.name);\n            });\n        }\n\n        return geometries;\n    };\n\n    const filterGeometries = (geometries) => {\n        return geometries.filter(geometry =>\n            // NWD extractor doesn't support 2d files. If they do appear, ignore them.\n            !(fileExtension === 'nwd' && geometry.role === '2d')\n        );\n\n        // In case you want to add another filter here, just compose like this: a.filter(b => b>2).filter(c => c>3).\n    };\n\n    if (fileExtension === 'pdf') {\n        const pdfItems = filterGeometries(modifyGeometries(getGeometries(buildTree(viewableItem, '2d'))));\n\n        return [{ type: 'PDF', sheets: pdfItems }];\n    } else {\n        const geometries3D = filterGeometries(modifyGeometries(getGeometries(buildTree(viewableItem, '3d'))));\n        const geometries2D = filterGeometries(modifyGeometries(getGeometries(buildTree(viewableItem, '2d'))));\n\n        return [\n            { type: '2D', sheets: geometries2D },\n            { type: '3D', sheets: geometries3D }\n        ];\n    }\n};\n","import GeometryUtils from './GeometryUtils';\nimport * as Constants from './GestureDocumentNavigationConstants';\n\nexport default class GestureDocumentNavigationTool {\n    constructor(extension) {\n        this.viewer = extension.viewer;\n        this.navigationDistance = this.viewer.impl.is2d ? Constants.NAVIGATION_DISTANCE_2D : Constants.NAVIGATION_DISTANCE_3D;\n        this.navigationVelocity = this.viewer.impl.is2d ? Constants.NAVIGATION_VELOCITY_2D : Constants.NAVIGATION_VELOCITY_3D;\n\n        this.documents = extension.documents;\n        this.sheets = extension.sheets;\n\n        this.extension = extension;\n\n        this.names = ['gesture-document-navigation'];\n\n        this.leftDirection = new THREE.Vector3(1, 0, 0);\n        this.rightDirection = new THREE.Vector3(-1, 0, 0);\n        this.upDirection = new THREE.Vector3(0, 1, 0);\n        this.downDirection = new THREE.Vector3(0, -1, 0);\n        this.eyeVector = new THREE.Vector3(0, 0, 1);\n\n        this.currentDirection = null;\n    }\n\n    getNames() {\n        return this.names;\n    }\n\n    getName() {\n        return this.names[0];\n    }\n\n    activate(name) {\n        if (name === this.getName()) {\n            this.isActive = true;\n        }\n    }\n\n    deactivate(name) {\n        if (name === this.getName()) {\n            this.isActive = false;\n        }\n    }\n\n    isActive() {\n        return this.isActive;\n    }\n\n    getPriority() {\n        return 100;\n    }\n\n    _isCanvasContainsViewport() {\n        const bounds = Autodesk.Viewing.ScreenShot.getSceneClientBounds(this.viewer, this.viewer.navigation.getCamera());\n        const containerBounds = this.viewer.impl.getCanvasBoundingClientRect();\n\n        return (bounds.min.x > containerBounds.left &&\n                bounds.max.x < containerBounds.right &&\n                bounds.min.y > containerBounds.height - containerBounds.bottom &&\n                bounds.max.y < containerBounds.height - containerBounds.top\n            );\n    }\n\n    /**\n     * On Drag event, gets the the right item to switch to, based on user gesture's direction,\n     * @returns {boolean} True if there is an item to move to.\n     * @param {boolean} event - Dragmove event.\n     * @private\n    */\n    onDrag(event) {\n        const v = new THREE.Vector3(event.canvasX, event.canvasY, 0).sub(this.startPoint);\n        const length = v.length();\n\n        let angle = GeometryUtils.getSignedAngle(v, this.leftDirection, this.eyeVector);\n\n        if (angle < 0) {\n            angle += 2 * Math.PI;\n        }\n\n        let indexToLoad = null;\n        let isSheet;\n        let isDocument;\n\n        if (angle > 5/4 * Math.PI && angle < 7/4 * Math.PI && this.sheets.length > 1) {\n            this.currentDirection = this.upDirection;\n\n            if (this.extension.currentSheetIndex === 0) {\n                if (this.extension.options.enableCyclicSwipe) {\n                    indexToLoad = this.sheets.length - 1;\n                }\n            } else {\n                indexToLoad = this.extension.currentSheetIndex - 1;\n            }\n\n            isSheet = true;\n        } else if (angle > 1/4 * Math.PI && angle <= 3/4 * Math.PI && this.sheets.length > 1) {\n            this.currentDirection = this.downDirection;\n\n            if (this.extension.currentSheetIndex === this.sheets.length - 1) {\n                if (this.extension.options.enableCyclicSwipe) {\n                    indexToLoad = 0;\n                }\n            } else {\n                indexToLoad = this.extension.currentSheetIndex + 1;\n            }\n\n            isSheet = true;\n        } else if (angle > 3/4 * Math.PI && angle <= 5/4 * Math.PI && this.documents.length > 1) {\n            this.currentDirection = this.leftDirection;\n            \n            if (this.extension.currentDocumentIndex === this.documents.length - 1) {\n                if (this.extension.options.enableCyclicSwipe) {\n                    indexToLoad = 0;\n                }\n            } else {\n                indexToLoad = this.extension.currentDocumentIndex + 1;\n            }\n\n            isDocument = true;\n        } else if ((angle > 7/4 * Math.PI || angle <= 1/4 * Math.PI) && this.documents.length > 1) {\n            this.currentDirection = this.rightDirection;\n\n            if (this.extension.currentDocumentIndex === 0) {\n                if (this.extension.options.enableCyclicSwipe) {\n                    indexToLoad = this.documents.length - 1;\n                }\n            } else {\n                indexToLoad = this.extension.currentDocumentIndex - 1;\n            }\n\n            isDocument = true;\n        }\n\n        const hasItem = indexToLoad !== null && (isSheet || isDocument);\n\n        if (hasItem && length >= this.navigationDistance) {\n            if (isSheet) {\n                const { guid } = this.sheets[indexToLoad];\n                this.extension.changeSheetRequired(guid);\n            } else if (isDocument) {\n                const { urn, guid } = this.documents[indexToLoad];\n                this.extension.changeDocumentRequired(urn, guid);\n            }\n\n            this.changing = true;\n        }\n\n        return hasItem;\n    }\n\n    _isSwipeEnabled() {\n        return this.viewer.model.is3d() || this._isCanvasContainsViewport();\n    }\n\n    handleGesture(event) {\n        switch (event.type) {\n            case 'dragstart':\n                this.isSwipeEnabled = this._isSwipeEnabled();\n                if (this.isSwipeEnabled) {\n                    this.startPoint = new THREE.Vector3(event.canvasX, event.canvasY, 0);\n                }\n\n                this.swiping = false;\n                this.changing = false;\n\n                return false;\n            case 'dragmove':\n                if (this.changing) {\n                    return true;\n                } else if (this.swiping || (this.isSwipeEnabled && Math.abs(event.overallVelocity) > this.navigationVelocity)) {\n                    this.swiping = true;\n                    return this.onDrag(event);\n                }\n\n                return false;\n            case 'dragend':\n                // When finish swiping, prevent the camera from orbiting. Relevant for 3D only - there is no camera orbit for 2D.\n                // I limited this to 3D only, because of a bug I found when returning true when swiping from a 2D document to 3D document - It was blocking orbit.\n                return this.changing && this.viewer.model.is3d();\n\n            default:\n                break;\n        }\n\n        return false;\n    }\n}\n","export const NAVIGATION_DISTANCE_2D = 50;\nexport const NAVIGATION_DISTANCE_3D = 350; // In order to prevent unwanted navigation, the minimum navigation distance is pretty high.\nexport const NAVIGATION_VELOCITY_2D = 0.7;\nexport const NAVIGATION_VELOCITY_3D = 1.1;\n","import CameraUtils from './CameraUtils';\nimport GeometryUtils from './GeometryUtils';\nimport { parseBubble } from './BubbleUtils';\nimport GestureDocumentNavigationTool from './GestureDocumentNavigationTool';\n\n/**\n * Provide an option to switch sheets and documents, using gestures.\n * \n * The extension id is: `Autodesk.BIM360.GestureDocumentNavigation`\n * \n * @example\n *   viewer.loadExtension('Autodesk.BIM360.GestureDocumentNavigation')\n *  \n * @memberof Autodesk.Viewing.Extensions\n * @alias Autodesk.Viewing.Extensions.GestureDocumentNavigationExtension\n * @see {@link Autodesk.Viewing.Extension} for common inherited methods.\n */\nexport default class GestureDocumentNavigationExtension extends Autodesk.Viewing.Extension {\n    /**\n     * Load the GestureDocumentNavigation extension.\n     *\n     * @returns {boolean} True if measure extension is loaded successfully.\n     * \n     * @alias Autodesk.Viewing.Extensions.GestureDocumentNavigationExtension#load\n     */\n    async load() {\n        const documentNode = this.viewer.impl.model.getDocumentNode();\n        const viewerDoc = documentNode.getRootNode().lmvDocument;\n\n        this.currentGuid = documentNode.guid();\n        this.currentUrn = viewerDoc.myData.urn;\n\n        this.documents = [{ urn: this.currentUrn, guid: this.currentGuid }];\n\n        const items = parseBubble(viewerDoc);\n        const items2D = (items[0] && items[0].sheets) || [];\n        const items3D = (items[1] && items[1].sheets) || [];\n        this.sheets = [...items2D, ...items3D];\n\n        this.pivot = new THREE.Vector3();\n\n        this.currentSheetIndex = this.sheets.findIndex(sheet => sheet.guid === this.currentGuid);\n        this.updateCurrentDocumentIndex();\n\n        this.tool = new GestureDocumentNavigationTool(this);\n\n        this.viewer.toolController.registerTool(this.tool);\n\n        const prevLock = this.viewer.toolController.setIsLocked(false);\n        this.viewer.toolController.activateTool(this.tool.getName());\n        this.viewer.toolController.setIsLocked(prevLock);\n\n        const cache = this.getCache();\n\n        if (this.viewer.impl.is2d) {\n            this.viewer.fitToView(undefined, undefined, true);\n\n            if (cache.direction) {\n                const translation = this.getTranslation(cache.direction);\n                const negativeTranslation = translation.clone().negate();\n                await this.translateCamera(negativeTranslation, true);\n                this.viewer.addEventListener(Autodesk.Viewing.RENDER_PRESENTED_EVENT, async () => {\n                    await this.translateCamera(translation, false);\n                    cache.direction = undefined;\n                }, { once: true });\n            }\n        } else {\n            cache.direction = undefined;\n        }\n\n        return true;\n    }\n\n    /**\n     * Unload the measure extension.\n     *\n     * @returns {boolean} True if measure extension is unloaded successfully.\n     * \n     * @alias Autodesk.Viewing.Extensions.GestureDocumentNavigationExtension#unload\n     */\n    unload() {\n        if (this.tool) {\n            this.viewer.toolController.deregisterTool(this.tool);\n            this.tool = null;\n        }\n\n        this.viewer = null;\n        this.options = null;\n\n        return true;\n    }\n\n    updateNextDocument(urn, guid) {\n        this.documents.push({ urn, guid });\n        this.updateCurrentDocumentIndex();\n    }\n\n    updatePrevDocument(urn, guid) {\n        this.documents.unshift({ urn, guid });\n        this.updateCurrentDocumentIndex();\n    }\n\n    updateCurrentDocumentIndex() {\n        this.currentDocumentIndex = this.documents.findIndex(\n            (doc) => doc.urn === this.currentUrn && doc.guid === this.currentGuid\n        );\n    }\n\n    /**\n     * Prepare current document before switching sheet / document.\n     *\n     * @param {Function} cb - This callback is called after current document is ready to switch.\n     * @alias Autodesk.Viewing.Extensions.GestureDocumentNavigationExtension#prepareChange\n     */\n    async prepareChange(cb) {\n        const onDone = () => {\n            const cache = this.getCache();\n            cache.direction = this.tool.currentDirection;\n            cb();\n        };\n\n        if (this.viewer.model.is3d()) {\n            onDone();\n        } else {\n            const translation = this.getTranslation(this.tool.currentDirection);\n            await this.translateCamera(translation, false);\n            onDone();\n        }\n    }\n\n    /**\n     * Change a sheet.\n     *\n     * @param {number} guid - The guid of the desired sheet.\n     * @alias Autodesk.Viewing.Extensions.GestureDocumentNavigationExtension#changeSheetRequired\n     */\n    changeSheetRequired(guid) {\n        if (!this.options.enableSheetSwipe || !guid) {\n            return;\n        }\n        \n        this.prepareChange(() => {\n            this.viewer.dispatchEvent({ type: Autodesk.Viewing.GestureDocumentNavigationEvents.CHANGE_SHEET_REQUIRED, guid });\n        });\n    }\n\n    /**\n     * Change a document.\n     *\n     * @param {number} urn - The urn of the desired document.\n     * @param {number} guid - The guid of the desired sheet.\n     * @alias Autodesk.Viewing.Extensions.GestureDocumentNavigationExtension#changeSheetRequired\n     */\n    changeDocumentRequired(urn, guid) {\n        if (!urn) {\n            return;\n        }\n\n        this.prepareChange(() => {\n            this.viewer.dispatchEvent({ type: Autodesk.Viewing.GestureDocumentNavigationEvents.CHANGE_DOCUMENT_REQUIRED, urn, guid });\n        });\n    }\n\n    getTranslation(direction) {\n        const camera = this.viewer.getCamera();\n        const size = Math.max(camera.top - camera.bottom, camera.right - camera.left);\n        const translation = direction.clone().multiplyScalar(size);\n\n        const cameraRotation = CameraUtils.getCameraRotation(camera);\n        const eyeVec = CameraUtils.getCameraEyeVector(camera);\n        GeometryUtils.applyRotation(translation, -cameraRotation, this.pivot, eyeVec);\n\n        return translation;\n    }\n\n    async translateCamera(translation, immediate) {\n        this.viewer.utilities.autocam.endInteraction();\n\n        const camera = this.viewer.getCamera();\n\n        const position = camera.position.clone().add(translation);\n        const target = camera.target.clone().add(translation);\n\n        if (immediate) {\n            this.viewer.navigation.setView(position, target);\n        } else {\n            this.viewer.navigation.setRequestTransitionWithUp(true, position, target, camera.fov, camera.up);\n            await Autodesk.Viewing.EventUtils.waitUntilTransitionEnded(this.viewer);\n        }\n    }\n}\n\nAutodesk.Viewing.GestureDocumentNavigationEvents = {};\nAutodesk.Viewing.GestureDocumentNavigationEvents.CHANGE_DOCUMENT_REQUIRED = 'change.document.required';\nAutodesk.Viewing.GestureDocumentNavigationEvents.CHANGE_SHEET_REQUIRED = 'change.sheet.required';\n\nGestureDocumentNavigationExtension.extensionName = 'Autodesk.BIM360.GestureDocumentNavigation';\n\nAutodesk.Viewing.theExtensionManager.registerExtension(GestureDocumentNavigationExtension.extensionName, GestureDocumentNavigationExtension);\n\n"],"sourceRoot":""}