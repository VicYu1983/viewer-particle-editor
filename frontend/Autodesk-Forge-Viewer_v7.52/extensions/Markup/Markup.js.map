{"version":3,"file":"Markup/Markup.js","sources":["webpack://Autodesk.Extensions.[name]/webpack/bootstrap","webpack://Autodesk.Extensions.[name]/./extensions/Markup/Markup.js","webpack://Autodesk.Extensions.[name]/./extensions/Markup/core/DomElementStyle.js","webpack://Autodesk.Extensions.[name]/./extensions/Markup/core/EditFrame.js","webpack://Autodesk.Extensions.[name]/./extensions/Markup/core/EditModeManager.js","webpack://Autodesk.Extensions.[name]/./extensions/Markup/core/Markup.js","webpack://Autodesk.Extensions.[name]/./extensions/Markup/core/MarkupArrow.js","webpack://Autodesk.Extensions.[name]/./extensions/Markup/core/MarkupCallout.js","webpack://Autodesk.Extensions.[name]/./extensions/Markup/core/MarkupCircle.js","webpack://Autodesk.Extensions.[name]/./extensions/Markup/core/MarkupCloud.js","webpack://Autodesk.Extensions.[name]/./extensions/Markup/core/MarkupDimension.js","webpack://Autodesk.Extensions.[name]/./extensions/Markup/core/MarkupEvents.js","webpack://Autodesk.Extensions.[name]/./extensions/Markup/core/MarkupFreehand.js","webpack://Autodesk.Extensions.[name]/./extensions/Markup/core/MarkupHighlight.js","webpack://Autodesk.Extensions.[name]/./extensions/Markup/core/MarkupPen.js","webpack://Autodesk.Extensions.[name]/./extensions/Markup/core/MarkupPolyLine.js","webpack://Autodesk.Extensions.[name]/./extensions/Markup/core/MarkupPolycloud.js","webpack://Autodesk.Extensions.[name]/./extensions/Markup/core/MarkupRectangle.js","webpack://Autodesk.Extensions.[name]/./extensions/Markup/core/MarkupStamp.js","webpack://Autodesk.Extensions.[name]/./extensions/Markup/core/MarkupText.js","webpack://Autodesk.Extensions.[name]/./extensions/Markup/core/MarkupTool.js","webpack://Autodesk.Extensions.[name]/./extensions/Markup/core/MarkupTypes.js","webpack://Autodesk.Extensions.[name]/./extensions/Markup/core/Markups.css?b962","webpack://Autodesk.Extensions.[name]/./extensions/Markup/core/MarkupsCore.js","webpack://Autodesk.Extensions.[name]/./extensions/Markup/core/MarkupsCoreUtils.js","webpack://Autodesk.Extensions.[name]/./extensions/Markup/core/StyleUtils.js","webpack://Autodesk.Extensions.[name]/./extensions/Markup/core/edit-actions/CloneMarkup.js","webpack://Autodesk.Extensions.[name]/./extensions/Markup/core/edit-actions/CreateArrow.js","webpack://Autodesk.Extensions.[name]/./extensions/Markup/core/edit-actions/CreateCallout.js","webpack://Autodesk.Extensions.[name]/./extensions/Markup/core/edit-actions/CreateCircle.js","webpack://Autodesk.Extensions.[name]/./extensions/Markup/core/edit-actions/CreateCloud.js","webpack://Autodesk.Extensions.[name]/./extensions/Markup/core/edit-actions/CreateDimension.js","webpack://Autodesk.Extensions.[name]/./extensions/Markup/core/edit-actions/CreateFreehand.js","webpack://Autodesk.Extensions.[name]/./extensions/Markup/core/edit-actions/CreateHighlight.js","webpack://Autodesk.Extensions.[name]/./extensions/Markup/core/edit-actions/CreatePolycloud.js","webpack://Autodesk.Extensions.[name]/./extensions/Markup/core/edit-actions/CreatePolyline.js","webpack://Autodesk.Extensions.[name]/./extensions/Markup/core/edit-actions/CreateRectangle.js","webpack://Autodesk.Extensions.[name]/./extensions/Markup/core/edit-actions/CreateStamp.js","webpack://Autodesk.Extensions.[name]/./extensions/Markup/core/edit-actions/CreateText.js","webpack://Autodesk.Extensions.[name]/./extensions/Markup/core/edit-actions/DeleteArrow.js","webpack://Autodesk.Extensions.[name]/./extensions/Markup/core/edit-actions/DeleteCallout.js","webpack://Autodesk.Extensions.[name]/./extensions/Markup/core/edit-actions/DeleteCircle.js","webpack://Autodesk.Extensions.[name]/./extensions/Markup/core/edit-actions/DeleteCloud.js","webpack://Autodesk.Extensions.[name]/./extensions/Markup/core/edit-actions/DeleteDimension.js","webpack://Autodesk.Extensions.[name]/./extensions/Markup/core/edit-actions/DeleteFreehand.js","webpack://Autodesk.Extensions.[name]/./extensions/Markup/core/edit-actions/DeleteHighlight.js","webpack://Autodesk.Extensions.[name]/./extensions/Markup/core/edit-actions/DeletePolycloud.js","webpack://Autodesk.Extensions.[name]/./extensions/Markup/core/edit-actions/DeletePolyline.js","webpack://Autodesk.Extensions.[name]/./extensions/Markup/core/edit-actions/DeleteRectangle.js","webpack://Autodesk.Extensions.[name]/./extensions/Markup/core/edit-actions/DeleteStamp.js","webpack://Autodesk.Extensions.[name]/./extensions/Markup/core/edit-actions/DeleteText.js","webpack://Autodesk.Extensions.[name]/./extensions/Markup/core/edit-actions/EditAction.js","webpack://Autodesk.Extensions.[name]/./extensions/Markup/core/edit-actions/EditActionGroup.js","webpack://Autodesk.Extensions.[name]/./extensions/Markup/core/edit-actions/EditActionManager.js","webpack://Autodesk.Extensions.[name]/./extensions/Markup/core/edit-actions/SetArrow.js","webpack://Autodesk.Extensions.[name]/./extensions/Markup/core/edit-actions/SetCallout.js","webpack://Autodesk.Extensions.[name]/./extensions/Markup/core/edit-actions/SetCircle.js","webpack://Autodesk.Extensions.[name]/./extensions/Markup/core/edit-actions/SetCloud.js","webpack://Autodesk.Extensions.[name]/./extensions/Markup/core/edit-actions/SetDimension.js","webpack://Autodesk.Extensions.[name]/./extensions/Markup/core/edit-actions/SetFreehand.js","webpack://Autodesk.Extensions.[name]/./extensions/Markup/core/edit-actions/SetHighlight.js","webpack://Autodesk.Extensions.[name]/./extensions/Markup/core/edit-actions/SetPolycloud.js","webpack://Autodesk.Extensions.[name]/./extensions/Markup/core/edit-actions/SetPolyline.js","webpack://Autodesk.Extensions.[name]/./extensions/Markup/core/edit-actions/SetPosition.js","webpack://Autodesk.Extensions.[name]/./extensions/Markup/core/edit-actions/SetRectangle.js","webpack://Autodesk.Extensions.[name]/./extensions/Markup/core/edit-actions/SetRotation.js","webpack://Autodesk.Extensions.[name]/./extensions/Markup/core/edit-actions/SetSize.js","webpack://Autodesk.Extensions.[name]/./extensions/Markup/core/edit-actions/SetStamp.js","webpack://Autodesk.Extensions.[name]/./extensions/Markup/core/edit-actions/SetStyle.js","webpack://Autodesk.Extensions.[name]/./extensions/Markup/core/edit-actions/SetText.js","webpack://Autodesk.Extensions.[name]/./extensions/Markup/core/edit-clipboard/Clipboard.js","webpack://Autodesk.Extensions.[name]/./extensions/Markup/core/edit-input/InputHandler.js","webpack://Autodesk.Extensions.[name]/./extensions/Markup/core/edit-modes/BuiltinEditModes.js","webpack://Autodesk.Extensions.[name]/./extensions/Markup/core/edit-modes/EditMode.js","webpack://Autodesk.Extensions.[name]/./extensions/Markup/core/edit-modes/EditModeArrow.js","webpack://Autodesk.Extensions.[name]/./extensions/Markup/core/edit-modes/EditModeCallout.js","webpack://Autodesk.Extensions.[name]/./extensions/Markup/core/edit-modes/EditModeCircle.js","webpack://Autodesk.Extensions.[name]/./extensions/Markup/core/edit-modes/EditModeCloud.js","webpack://Autodesk.Extensions.[name]/./extensions/Markup/core/edit-modes/EditModeDimension.js","webpack://Autodesk.Extensions.[name]/./extensions/Markup/core/edit-modes/EditModeFreehand.js","webpack://Autodesk.Extensions.[name]/./extensions/Markup/core/edit-modes/EditModeHighlight.js","webpack://Autodesk.Extensions.[name]/./extensions/Markup/core/edit-modes/EditModePen.js","webpack://Autodesk.Extensions.[name]/./extensions/Markup/core/edit-modes/EditModePolycloud.js","webpack://Autodesk.Extensions.[name]/./extensions/Markup/core/edit-modes/EditModePolyline.js","webpack://Autodesk.Extensions.[name]/./extensions/Markup/core/edit-modes/EditModeRectangle.js","webpack://Autodesk.Extensions.[name]/./extensions/Markup/core/edit-modes/EditModeStamp.js","webpack://Autodesk.Extensions.[name]/./extensions/Markup/core/edit-modes/EditModeText.js","webpack://Autodesk.Extensions.[name]/./extensions/Markup/core/edit-modes/EditorTextAutosize.js","webpack://Autodesk.Extensions.[name]/./extensions/Markup/core/edit-modes/EditorTextInput.js","webpack://Autodesk.Extensions.[name]/./extensions/Markup/gui/MarkupsGui.css?e525","webpack://Autodesk.Extensions.[name]/./extensions/Markup/gui/MarkupsGui.js","webpack://Autodesk.Extensions.[name]/./extensions/Markup/core/Markups.css","webpack://Autodesk.Extensions.[name]/./extensions/Markup/gui/MarkupsGui.css","webpack://Autodesk.Extensions.[name]/./node_modules/css-loader/lib/css-base.js","webpack://Autodesk.Extensions.[name]/./node_modules/resize-observer-polyfill/dist/ResizeObserver.es.js","webpack://Autodesk.Extensions.[name]/./node_modules/style-loader/lib/addStyles.js","webpack://Autodesk.Extensions.[name]/./node_modules/style-loader/lib/urls.js","webpack://Autodesk.Extensions.[name]/(webpack)/buildin/global.js"],"sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./extensions/Markup/Markup.js\");\n","'use strict';\n\nimport { MarkupsCore } from './core/MarkupsCore';\nimport { MarkupsGui } from './gui/MarkupsGui';\n\nimport { Clipboard } from './core/edit-clipboard/Clipboard';\nimport { CloneMarkup } from './core/edit-actions/CloneMarkup';\nimport { CreateArrow } from './core/edit-actions/CreateArrow';\nimport { CreateCallout } from './core/edit-actions/CreateCallout';\nimport { CreateCircle } from './core/edit-actions/CreateCircle';\nimport { CreateCloud } from './core/edit-actions/CreateCloud';\nimport { CreateDimension } from './core/edit-actions/CreateDimension';\nimport { CreateFreehand } from './core/edit-actions/CreateFreehand';\nimport { CreateHighlight } from './core/edit-actions/CreateHighlight';\nimport { CreatePolycloud } from './core/edit-actions/CreatePolycloud';\nimport { CreatePolyline } from './core/edit-actions/CreatePolyline';\nimport { CreateRectangle } from './core/edit-actions/CreateRectangle';\nimport { CreateText } from './core/edit-actions/CreateText';\nimport { DeleteArrow } from './core/edit-actions/DeleteArrow';\nimport { DeleteCallout } from './core/edit-actions/DeleteCallout';\nimport { DeleteCircle } from './core/edit-actions/DeleteCircle';\nimport { DeleteCloud } from './core/edit-actions/DeleteCloud';\nimport { DeleteStamp } from './core/edit-actions/DeleteStamp';\nimport { DeleteDimension } from './core/edit-actions/DeleteDimension';\nimport { DeleteFreehand } from './core/edit-actions/DeleteFreehand';\nimport { DeleteHighlight } from './core/edit-actions/DeleteHighlight';\nimport { DeletePolycloud } from './core/edit-actions/DeletePolycloud';\nimport { DeletePolyline } from './core/edit-actions/DeletePolyline';\nimport { DeleteRectangle } from './core/edit-actions/DeleteRectangle';\nimport { DeleteText } from './core/edit-actions/DeleteText';\n\nimport { EditAction } from './core/edit-actions/EditAction';\nimport { EditActionGroup } from './core/edit-actions/EditActionGroup';\nimport { EditActionManager } from './core/edit-actions/EditActionManager';\nimport { EditFrame } from './core/EditFrame';\n\nimport { EditMode } from './core/edit-modes/EditMode';\nimport { EditModeArrow } from './core/edit-modes/EditModeArrow';\nimport { EditModeCallout } from './core/edit-modes/EditModeCallout';\nimport { EditModeCircle } from './core/edit-modes/EditModeCircle';\nimport { EditModeCloud } from './core/edit-modes/EditModeCloud';\nimport { EditModeStamp } from './core/edit-modes/EditModeStamp';\nimport { EditModeDimension } from './core/edit-modes/EditModeDimension';\nimport { EditModeFreehand } from './core/edit-modes/EditModeFreehand';\nimport { EditModeHighlight } from './core/edit-modes/EditModeHighlight';\nimport { EditModePen } from './core/edit-modes/EditModePen';\nimport { EditModePolycloud } from './core/edit-modes/EditModePolycloud';\nimport { EditModePolyline } from './core/edit-modes/EditModePolyline';\nimport { EditModeRectangle } from './core/edit-modes/EditModeRectangle';\nimport { EditModeText } from './core/edit-modes/EditModeText';\nimport { EditorTextInput } from './core/edit-modes/EditorTextInput';\n\n\nimport { Markup } from './core/Markup';\nimport { MarkupArrow } from './core/MarkupArrow';\nimport { MarkupCallout } from './core/MarkupCallout';\nimport { MarkupCircle } from './core/MarkupCircle';\nimport { MarkupCloud } from './core/MarkupCloud';\nimport { MarkupDimension } from './core/MarkupDimension';\nimport { MarkupFreehand } from './core/MarkupFreehand';\nimport { MarkupHighlight } from './core/MarkupHighlight';\nimport { MarkupPen } from './core/MarkupPen';\nimport { MarkupPolycloud } from './core/MarkupPolycloud';\nimport { MarkupPolyline } from './core/MarkupPolyLine';\nimport { MarkupRectangle } from './core/MarkupRectangle';\nimport { MarkupText } from './core/MarkupText';\nimport { MarkupStamp } from './core/MarkupStamp';\nimport { MarkupTool } from './core/MarkupTool';\n\nimport { SetArrow } from './core/edit-actions/SetArrow';\nimport { SetCallout } from './core/edit-actions/SetCallout';\nimport { SetCircle } from './core/edit-actions/SetCircle';\nimport { SetCloud } from './core/edit-actions/SetCloud';\nimport { SetDimension } from './core/edit-actions/SetDimension';\nimport { SetFreehand } from './core/edit-actions/SetFreehand';\nimport { SetHighlight } from './core/edit-actions/SetHighlight';\nimport { SetPolycloud } from './core/edit-actions/SetPolycloud';\nimport { SetPolyline } from './core/edit-actions/SetPolyline';\nimport { SetPosition } from './core/edit-actions/SetPosition';\nimport { SetRectangle } from './core/edit-actions/SetRectangle';\nimport { SetRotation } from './core/edit-actions/SetRotation';\nimport { SetSize } from './core/edit-actions/SetSize';\nimport { SetStyle } from './core/edit-actions/SetStyle';\nimport { SetText } from './core/edit-actions/SetText';\nimport { SetStamp } from './core/edit-actions/SetStamp';\n\n\nimport * as MarkupEvents from './core/MarkupEvents';\nimport * as MarkupTypes from './core/MarkupTypes';\n\nimport * as Utils from './core/MarkupsCoreUtils';\nimport * as StyleUtils from './core/StyleUtils';\n\nimport { theEditModeManager } from './core/EditModeManager';\n\n// All the things\nexport var Core = {\n  Clipboard: Clipboard,\n  CloneMarkup: CloneMarkup,\n  CreateArrow: CreateArrow,\n  CreateCallout: CreateCallout,\n  CreateCircle: CreateCircle,\n  CreateCloud: CreateCloud,\n  CreateDimension: CreateDimension,\n  CreateFreehand: CreateFreehand,\n  CreateHighlight: CreateHighlight,\n  CreatePolycloud: CreatePolycloud,\n  CreatePolyline: CreatePolyline,\n  CreateRectangle: CreateRectangle,\n  CreateText: CreateText,\n  DeleteArrow: DeleteArrow,\n  DeleteCallout: DeleteCallout,\n  DeleteCircle: DeleteCircle,\n  DeleteCloud: DeleteCloud,\n  DeleteDimension: DeleteDimension,\n  DeleteFreehand: DeleteFreehand,\n  DeleteHighlight: DeleteHighlight,\n  DeletePolycloud: DeletePolycloud,\n  DeletePolyline: DeletePolyline,\n  DeleteRectangle: DeleteRectangle,\n  DeleteText: DeleteText,\n  DeleteStamp: DeleteStamp,\n\n  EditAction: EditAction,\n  EditActionGroup: EditActionGroup,\n  EditActionManager: EditActionManager,\n  EditFrame: EditFrame,\n\n  EditMode: EditMode,\n  EditModeArrow: EditModeArrow,\n  EditModeCallout: EditModeCallout,\n  EditModeCircle: EditModeCircle,\n  EditModeCloud: EditModeCloud,\n  EditModeDimension: EditModeDimension,\n  EditModeFreehand: EditModeFreehand,\n  EditModeHighlight: EditModeHighlight,\n  EditModePen: EditModePen,\n  EditModePolycloud: EditModePolycloud,\n  EditModePolyline: EditModePolyline,\n  EditModeRectangle: EditModeRectangle,\n  EditModeText: EditModeText,\n  EditModeStamp: EditModeStamp,\n  EditorTextInput: EditorTextInput,\n\n  Markup: Markup,\n  MarkupArrow: MarkupArrow,\n  MarkupCallout: MarkupCallout,\n  MarkupCircle: MarkupCircle,\n  MarkupCloud: MarkupCloud,\n  MarkupDimension: MarkupDimension,\n  MarkupFreehand: MarkupFreehand,\n  MarkupHighlight: MarkupHighlight,\n  MarkupPen: MarkupPen,\n  MarkupPolycloud: MarkupPolycloud,\n  MarkupPolyline: MarkupPolyline,\n  MarkupRectangle: MarkupRectangle,\n  MarkupText: MarkupText,\n  MarkupStamp: MarkupStamp,\n  MarkupTool: MarkupTool,\n\n  MarkupsCore: MarkupsCore,\n\n  SetArrow: SetArrow,\n  SetCallout: SetCallout,\n  SetCircle: SetCircle,\n  SetCloud: SetCloud,\n  SetDimension: SetDimension,\n  SetFreehand: SetFreehand,\n  SetHighlight: SetHighlight,\n  SetPolycloud: SetPolycloud,\n  SetPolyline: SetPolyline,\n  SetPosition: SetPosition,\n  SetRectangle: SetRectangle,\n  SetRotation: SetRotation,\n  SetSize: SetSize,\n  SetStyle: SetStyle,\n  SetText: SetText,\n  SetStamp: SetStamp,\n\n\n  MarkupEvents: MarkupEvents,\n  MarkupTypes: MarkupTypes,\n  theEditModeManager: theEditModeManager,\n  Utils: Utils };\n\n\n// Spread the markup types to minimize breaking changes (sigh)\nfor (var markupType in MarkupTypes) {\n  Core[markupType] = MarkupTypes[markupType];\n}\n\n// Spread the event ids to minimize breaking changes (sigh)\nfor (var eventType in MarkupEvents) {\n  Core[eventType] = MarkupEvents[eventType];\n}\n\n// Merge StyleUtils with utils (because those methods used to live in Utils)\nfor (var thing in StyleUtils) {\n  if (thing in Core.Utils)\n  throw new Error(\"Property \".concat(thing, \" from StyleUtils already present in MarkupsCoreUtils.\"));\n\n  Core.Utils[thing] = StyleUtils[thing];\n}\n\n\nexport var Gui = {\n  MarkupsGui: MarkupsGui };\n\n\n\n// Also map back to legacy namespace\nAutodesk.Viewing.Extensions.Markups = {\n  Core: Core };","'use strict';\n\n/**\n               * Curring object which generate a string that can be used\n               * as a Dom element's 'style' value.\n               *\n               * @constructor\n               */\nexport function DomElementStyle() {\n\n  this.reset();\n}\n\n/*\n   * Constants\n   */\nvar BROWSER_PREFIXES = ['-ms-', '-webkit-', '-moz-', '-o-'];\n\nvar proto = DomElementStyle.prototype;\n\nproto.reset = function () {\n\n  this.attributes = {};\n  this.dirty = false;\n  this.styleString = '';\n\n  return this;\n};\n\n/**\n    *\n    * @param {String} key\n    * @param {*} value\n    * @param {Object} [options]\n    * @param {Boolean} [options.allBrowsers] - Whether to add browser prefix to key\n    * @returns {Autodesk.Viewing.Extensions.Markups.Core.Utils.DomeElemStyle}\n    */\nproto.setAttribute = function (key, value, options) {\n\n  this.attributes[key] = value;\n\n  if (options && options.allBrowsers) {\n    var that = this;\n    BROWSER_PREFIXES.forEach(function (prefix) {\n      that.attributes[prefix + key] = value;\n    });\n  }\n  this.dirty = true; // Could be optimized\n  return this;\n};\n\n/**\n    * Removes one or more attributes\n    * @param {String|Array} key - Key or Keys to be removed\n    * @returns {Autodesk.Viewing.Extensions.Markups.Core.Utils.DomElemStyle} this\n    */\nproto.removeAttribute = function (key) {\n\n  if (!Array.isArray(key)) {\n    key = [key];\n  }\n\n  var self = this;\n  key.forEach(function (k) {\n    if (k in self.attributes) {\n      delete self.attributes[k];\n      self.dirty = true;\n    }\n  });\n  return this;\n};\n\n/**\n    * Gets the String representation of this style object\n    * @returns {string}\n    */\nproto.getStyleString = function () {\n\n  if (this.dirty) {\n    this.styleString = generateStyle(this.attributes);\n    this.dirty = false;\n  }\n  return this.styleString;\n};\n\n/**\n    * Clones the current Object\n    *\n    * @returns {Autodesk.Viewing.Extensions.Markups.Core.Utils.DomElemStyle}\n    */\nproto.clone = function () {\n\n  var clone = new DomElementStyle();\n  var attributes = this.attributes;\n\n  for (var key in attributes) {\n    clone.setAttribute(key, attributes[key]);\n  }\n  return clone;\n};\n\n/**\n    * Generates the style value string. Non mutable function.\n    *\n    * @param {Object} attributes\n    * @private\n    */\nfunction generateStyle(attributes) {\n\n  var elements = [];\n  for (var key in attributes) {\n    var val = attributes[key];\n    elements.push(key);\n    elements.push(':');\n    elements.push(val);\n    elements.push('; ');\n  }\n  return elements.join('');\n}","'use strict';\n\nimport { EDIT_FRAME_DEFAULT_MARGIN,\naddTraitEventDispatcher, isTouchDevice, degreesToRadians } from './MarkupsCoreUtils';\nimport * as MarkupEvents from './MarkupEvents';\nimport { CloneMarkup } from './edit-actions/CloneMarkup';\nimport { SetPosition } from './edit-actions/SetPosition';\nimport { SetSize } from './edit-actions/SetSize';\nimport { SetRotation } from './edit-actions/SetRotation';\n\nvar av = Autodesk.Viewing;\nvar avp = Autodesk.Viewing.Private;\n\n/**\n                                     * A component to handle the selection of markups.\n                                     *\n                                     *\n                                     *      Sample\n                                     *\n                                     *      var containingDiv = document.getElementById('containingDiv3d-app-wrapper');\n                                     *      var selectionComponent = new EditFrame(containingDiv);\n                                     *      selectionComponent.setSelection(100, 100, 300, 150, 0);\n                                     *\n                                     * @param {HTMLElement} containingDiv The container where the selection layer will live.\n                                     * @param {Object} editor\n                                     * @constructor\n                                     */\nexport function EditFrame(containingDiv, editor) {\n\n  this.containingDiv = containingDiv;\n  this.editor = editor;\n  this.setGlobalManager(this.editor.viewer.globalManager);\n  this.selectionLayer = createSelectionLayer.bind(this)();\n\n  this.frameMargin = EDIT_FRAME_DEFAULT_MARGIN;\n\n  this.selection = {\n    x: 0,\n    y: 0,\n    width: 0,\n    height: 0,\n    rotation: 0,\n    element: null,\n    active: false,\n    dragging: false,\n    resizing: false,\n    //a dictionary of all the drag points\n    //the key for each drag point will be its cardinal/ordinal direction\n    handle: {} };\n\n\n  createSelectorBox.bind(this)();\n\n  if (isTouchDevice()) {\n    this.hammer = new av.Hammer.Manager(this.selectionLayer, {\n      recognizers: [\n      av.GestureRecognizers.drag,\n      av.GestureRecognizers.doubletap,\n      av.GestureRecognizers.doubletap2,\n      av.GestureRecognizers.pan,\n      av.GestureRecognizers.pinch],\n\n      handlePointerEventMouse: false,\n      inputClass: av.isIE11 ? av.Hammer.PointerEventInput : av.Hammer.TouchInput });\n\n\n    this.onHammerDragBinded = this.onHammerDrag.bind(this);\n    this.onHammerDoubleTapBinded = this.onHammerDoubleTap.bind(this);\n    this.onTouchPanBinded = this.onTouchPan.bind(this);\n    this.onTouchPinchBinded = this.onTouchPinch.bind(this);\n\n    this.hammer.on(\"dragstart dragmove dragend\", this.onHammerDragBinded);\n    this.hammer.on(\"doubletap\", this.onHammerDoubleTapBinded);\n    this.hammer.on(\"doubletap2\", this.onHammerDoubleTapBinded);\n    this.hammer.on(\"panstart panmove panend\", this.onTouchPanBinded);\n    this.hammer.on(\"pinchstart pinchmove pinchend\", this.onTouchPinchBinded);\n\n    this.hammer.get('drag').requireFailure('pinch');\n    this.hammer.get('drag').requireFailure('pan');\n  }\n\n  handleSelectionBoxDragging.bind(this)();\n  handleSelectionBoxResizing.bind(this)();\n  handleSelectionDoubleClick.bind(this)();\n  handleSelectionBoxRotating.bind(this)();\n\n  //add the selection into the container given to us\n  this.containingDiv.appendChild(this.selectionLayer);\n\n  addTraitEventDispatcher(this);\n}\n\nav.GlobalManagerMixin.call(EditFrame.prototype);\nvar proto = EditFrame.prototype;\n\nproto.unload = function () {\n\n  this.containingDiv.removeChild(this.selectionLayer);\n  this.selectionLayer = null;\n};\n/**\n    * Draws a selection box with the given attributes\n    *\n    * @param {number} x - The x coordinate to place the selection box\n    * @param {number} y - The y coordinate to place the selection box\n    * @param {number} width - The width of the selection box\n    * @param {number} height - The height of the selection box\n    * @param {number} rotation - The amount of degrees to rotate the selection box\n    */\nproto.setSelection = function (x, y, width, height, rotation) {\n\n  var margin = this.frameMargin;\n  var doubleMargin = margin * 2;\n\n  updateSelectorBoxDimensions.bind(this)(width + doubleMargin, height + doubleMargin);\n  updateSelectorBoxPosition.bind(this)(x - margin, y - margin, rotation);\n  updateSelectionBoxState.bind(this)(true); //activate the selection box\n  this.selectionLayer.style.visibility = 'visible';\n};\n\n/**\n    * Displays the selection box based on the position, dimension, and rotation of a given markup\n    *\n    * @param {Autodesk.Viewing.Extensions.Markups.Core.Markup} markup - the markup that should appear as selected\n    */\nproto.setMarkup = function (markup) {\n\n  this.hammer && this.hammer.set({ enable: markup !== null });\n  this.markup = markup;\n\n  updateSelectionBoxState.bind(this)(false);\n\n  if (markup) {\n    var boundingBox = markup.getBoundingRect();\n    var rotation = markup.getRotation();\n    this.frameMargin = boundingBox.margin !== undefined ? boundingBox.margin : EDIT_FRAME_DEFAULT_MARGIN;\n\n    this.setSelection(boundingBox.x, boundingBox.y, boundingBox.width, boundingBox.height, rotation);\n\n    this.enableResizeHandles();\n    this.enableRotationHandle();\n\n    if (markup.preventReposition) {\n      this.selectionLayer.firstChild.style.cursor = '';\n    } else\n    {\n      this.selectionLayer.firstChild.style.cursor = 'move';\n    }\n  }\n};\n\nproto.startDrag = function (event) {\n\n  if (this.markup && this.markup.preventReposition) return;\n\n  this.onMouseMove = this._onRepositionMouseMove.bind(this);\n  this.onMouseUp = this._onRepositionMouseUp.bind(this);\n  this._onRepositionMouseDown(event, this.editor.getMousePosition());\n};\n\nproto.isActive = function () {\n  return this.selection.active;\n};\n\nproto.isDragging = function () {\n\n  return this.selection.dragging;\n};\n\nproto.isResizing = function () {\n\n  return this.selection.resizing;\n};\n\nproto.isRotating = function () {\n\n  return this.selection.rotating;\n};\n\nproto.onMouseMove = function (event) {\n\n  //dummy fn\n};\n\nproto.onMouseUp = function (event) {\n  //dummy fn\n};\n\nproto.onWheel = function (event) {\n  this.editor.viewer.toolController.mousewheel(event);\n};\n\nproto.onTouchPan = function (event) {\n  var gestureHandler = this.editor.viewer.toolController.getTool(\"gestures\");\n  gestureHandler.distributeGesture(event);\n  event.preventDefault();\n};\n\nproto.onTouchPinch = function (event) {\n  var gestureHandler = this.editor.viewer.toolController.getTool(\"gestures\");\n  gestureHandler.distributeGesture(event);\n  event.preventDefault();\n};\n\nproto.onHammerDrag = function (event) {\n\n  function updateEditorInput(input, parent, event) {\n\n    //TODO: Change this when refactoring input in edit frame.\n    var rect = parent.getBoundingClientRect();\n    input.mousePosition.x = event.pageX - rect.left;\n    input.mousePosition.y = event.pageY - rect.top;\n  }\n\n  //console.log('EditFrame drag ' + event.type);\n  convertEventHammerToMouse(event);\n  switch (event.type) {\n    case 'dragstart':\n      updateEditorInput(this.editor.input, this.editor.svg, event);\n      this.editor.callSnapperMouseDown();\n      // Check whether to translate, rotate or resize\n      if (isRotatePoint(event.target)) {\n        // Rotate\n        this._onRotationMouseDown(event);\n      } else if (isDragPoint(event.target)) {\n        // Resize\n        this._onResizeMouseDown(event);\n      } else {\n        this.startDrag(event);\n      }\n      event.preventDefault();\n      break;\n    case 'dragmove':\n      updateEditorInput(this.editor.input, this.editor.svg, event);\n      this.editor.callSnapperMouseMove();\n      this.onMouseMove(event);\n      event.preventDefault();\n      break;\n    case 'dragend':\n      updateEditorInput(this.editor.input, this.editor.svg, event);\n      this.onMouseUp(event);\n      event.preventDefault();\n      break;}\n\n};\n\nproto.onHammerDoubleTap = function (event) {\n\n  function updateEditorInput(input, parent, event) {\n\n    //TODO: Change this when refactoring input in edit frame.\n    var rect = parent.getBoundingClientRect();\n    input.mousePosition.x = event.pageX - rect.left;\n    input.mousePosition.y = event.pageY - rect.top;\n  }\n\n  convertEventHammerToMouse(event);\n  updateEditorInput(this.editor.input, this.editor.svg, event);\n\n  this.selection.dragging = false;\n  this.editor.editMode && this.editor.editMode.onMouseDoubleClick(this.markup);\n};\n\nproto.enableResizeHandles = function () {\n\n  var markup = this.markup;\n  var handle;\n\n  if (markup.isHeightConstrained() || markup.isWidthConstrained()) {\n    //hide all the handles\n    for (var direction in this.selection.handle) {\n      handle = this.selection.handle[direction];\n      if (handle) handle.style.display = 'none';\n    }\n\n    //show only the resize points that are allowed\n    if (!markup.isHeightConstrained()) {\n      this.selection.handle['n'].style.display = 'block';\n      this.selection.handle['s'].style.display = 'block';\n    }\n    if (!markup.isWidthConstrained()) {\n      this.selection.handle['w'].style.display = 'block';\n      this.selection.handle['e'].style.display = 'block';\n    }\n  } else {\n    //no constraints, show all resize handles\n    for (var direction in this.selection.handle) {\n      handle = this.selection.handle[direction];\n      if (handle) handle.style.display = 'block';\n    }\n  }\n};\n\nproto.enableRotationHandle = function () {\n\n  var markup = this.markup;\n  var display = markup.isRotationConstrained() ? 'none' : 'block';\n  this.selection.rotationHandle.style.display = display;\n  this.selection.rotationBridge.style.display = display;\n};\n\nfunction convertEventHammerToMouse(event) {\n  // Convert Hammer touch-event X,Y into mouse-event X,Y.\n  event.pageX = event.pointers[0].clientX;\n  event.pageY = event.pointers[0].clientY;\n}\n\n/**\n   * Creates an element spanning the full height and width of its parent.\n   * It serves as our surface to draw the selection box.\n   *\n   * @return {HTMLElement}\n   */\nfunction createSelectionLayer() {\n\n  var _document = this.getDocument();\n  var selectionLayer = _document.createElement('div');\n  selectionLayer.style.position = 'absolute';\n  selectionLayer.style.top = 0;\n  selectionLayer.style.bottom = 0;\n  selectionLayer.style.left = 0;\n  selectionLayer.style.right = 0;\n  //don't let the selection box be visible outside the selection layer\n  selectionLayer.style.overflow = 'hidden';\n  selectionLayer.style.visibility = 'hidden';\n  togglePointerEvents(selectionLayer, false);\n  return selectionLayer;\n}\n\n/**\n   * Creates a single drag point with the corresponding styles\n   *\n   * @param {number} diameter - The size of the drag point\n   * @param {string} position - The cardinal(n, s, w, e) or ordinal(nw, nw, sw, se) direction of the point\n   * @return {HTMLElement}\n   */\nfunction createDragPoint(position) {\n\n  var _document = this.getDocument();\n  var point = _document.createElement('div');\n\n  setResizeCursor(point, position);\n  point.className = 'selector-drag-point autodesk-markups-extension-core-make-me-bigger sdp-handle-' + position;\n  point.classList.add('adsk-viewing-viewer');\n  point.setAttribute('data-sdp-handle', position);\n\n  return point;\n}\n\nfunction createRotatePoint() {\n  var _document = this.getDocument();\n  var point = _document.createElement('div');\n  point.classList.add('adsk-viewing-viewer');\n  point.classList.add('selector-rotate-point');\n  point.classList.add('autodesk-markups-extension-core-make-me-bigger');\n  setResizeCursor(point, 'w');\n\n  return point;\n}\n\nfunction createRotationBridge() {\n  var _document = this.getDocument();\n  var rotationBridge = _document.createElement('div');\n  rotationBridge.classList.add('adsk-viewing-viewer');\n  rotationBridge.classList.add('selector-rotate-point');\n  rotationBridge.classList.add('autodesk-markups-extension-core-make-me-bigger');\n  rotationBridge.classList.add('rotation-bridge');\n  setResizeCursor(rotationBridge, 'w');\n\n  return rotationBridge;\n}\n\nfunction setResizeCursor(element, direction) {\n\n  var cursor;\n  switch (direction) {\n    case 'n':\n    case 's':\n      cursor = 'ns-resize';\n      break;\n    case 'w':\n    case 'e':\n      cursor = 'ew-resize';\n      break;\n    case 'ne':\n    case 'sw':\n      cursor = 'nesw-resize';\n      break;\n    case 'nw':\n    case 'se':\n      cursor = 'nwse-resize';\n      break;}\n\n  element.style.cursor = cursor;\n}\n\n/**\n   * Creates the 8 drag points of the selection box.\n   *\n   * @this EditFrame\n   */\nfunction createDragPoints(selector) {\n\n  ['n', 's', 'w', 'e', 'nw', 'ne', 'sw', 'se'].forEach(function (direction) {\n    //store the drag point and put it in the DOM\n    this.selection.handle[direction] = createDragPoint.call(this, direction);\n    selector.appendChild(this.selection.handle[direction]);\n  }.bind(this));\n}\n\n/**\n   * Determines if an element is a drag point\n   *\n   * @return {boolean}\n   */\nfunction isDragPoint(element) {\n\n  return matchesSelectorAux(element, '.selector-drag-point');\n}\n\n/**\n   * Determines if an element is a rotate point\n   *\n   * @return {boolean}\n   */\nfunction isRotatePoint(element) {\n\n  return matchesSelectorAux(element, '.selector-rotate-point');\n}\n\n/**\n   * Creates the element that will be used as the selection box. It also\n   * takes care of adding the drag handles\n   *\n   * @return {HTMLElement} - the selection box\n   * @this EditFrame\n   */\nfunction createSelectorBox() {\n\n  var _document = this.getDocument();\n  var selectorBox = _document.createElement('div');\n  togglePointerEvents(selectorBox, true);\n  selectorBox.classList.add('selector-box');\n\n  this.selection.rotationBridge = createRotationBridge.bind(this)();\n  selectorBox.appendChild(this.selection.rotationBridge);\n\n  this.selection.rotationHandle = createRotatePoint.bind(this)();\n  selectorBox.appendChild(this.selection.rotationHandle);\n\n  createDragPoints.bind(this)(selectorBox);\n\n  //store the selector box\n  this.selection.element = selectorBox;\n\n  if (!av.isMobileDevice()) {\n    this.onWheelBinded = this.onWheel.bind(this);\n    this.selection.element.addEventListener('wheel', this.onWheelBinded);\n    this.selection.element.addEventListener('DOMMouseScroll', this.onWheelBinded); // firefox\n  }\n\n  //add the selection box to the selection layer\n  this.selectionLayer.appendChild(this.selection.element);\n\n  //we are just creating the box, start it out hidden\n  updateSelectionBoxState.bind(this)(false);\n\n  return selectorBox;\n}\n\n/**\n   * Utility to create the CSS translate3d value from a given 2d point\n   *\n   * @param {number} x - coordinate\n   * @param {number} y - coordinate\n   * @return {string}\n   */\nfunction toTranslate3d(x, y) {\n\n  return 'translate3d(' + x + 'px,' + y + 'px,0)';\n}\n\n\n/**\n   * Updates the display state of the selection box\n   *\n   * @param {boolean} active - The new state of the the selection box\n   * @this EditFrame\n   */\nfunction updateSelectionBoxState(active) {\n\n  this.selection.active = active;\n  this.selection.element.style.display = active ? 'block' : 'none';\n}\n\n/**\n   * Updates the position and rotation of the selection box.\n   *\n   * @param {number} x - The x coordinate to place the selection box\n   * @param {number} y - The y coordinate to place the selection box\n   * @param {number} rotation - The amount of degrees to rotate the selection box\n   * @this EditFrame\n   */\nfunction updateSelectorBoxPosition(x, y, rotation) {\n\n  this.selection.x = x;\n  this.selection.y = y;\n  this.selection.rotation = rotation;\n  var size = this.markup.getBoundingRect();\n  //TODO: consider DomElementStyle\n\n  size.width += this.frameMargin * 2;\n  size.height += this.frameMargin * 2;\n\n  var transform = toTranslate3d(x, y) + ' rotate(' + rotation + 'rad)';\n  var transformOrigin = size.width / 2 + 'px ' + size.height / 2 + 'px';\n\n  this.selection.element.style.msTransform =\n  this.selection.element.style.webkitTransform =\n  this.selection.element.style.transform = transform;\n  this.selection.element.style.msTransformOrigin =\n  this.selection.element.style.webkitTransformOrigin =\n  this.selection.element.style.transformOrigin = transformOrigin;\n}\n\n/**\n   * Updates the dimensions of the selection box (width and height).\n   *\n   * @param {number} width - The new width of the selection box\n   * @param {number} height - The new height of the selection box\n   * @this EditFrame\n   */\nfunction updateSelectorBoxDimensions(width, height) {\n\n  this.selection.width = width;\n  this.selection.height = height;\n  this.selection.element.style.width = width + 'px';\n  this.selection.element.style.height = height + 'px';\n}\n\n/**\n   * Attaches all the necessary listeners to handle a drag action.\n   *\n   * @this EditFrame\n   */\nfunction handleSelectionBoxDragging() {\n\n  this.selection.element.addEventListener('mousedown', this._onRepositionMouseDown.bind(this));\n}\n\n/**\n   * Handles panning when right clicking down\n   * @param event\n   * @returns {boolean} returns true if the event was handled\n   * @private\n   */\nproto._handleRightClickDown = function (event) {\n\n  if (!av.isMobileDevice() && (avp.isRightClick(event, this.editor.viewer.navigation) || avp.isMiddleClick(event))) {\n    this.editor.input.onMouseDownRightClick(event);\n    return true;\n  }\n\n  return false;\n};\n\nvar ignoreFirstMouseMove = false;\nproto._onRepositionMouseDown = function (event, cursor) {\n\n  if (this._handleRightClickDown(event))\n  return;\n\n  // Return for markups that are not allowed to be repositioned.\n  if (this.markup && this.markup.preventReposition) return;\n\n  // ignore the first mouse move for the Microsoft Surface\n  ignoreFirstMouseMove = !av.isMobileDevice() && av.isTouchDevice();\n  //a synthetic start means that the event was triggered manually and not as a\n  //result of a mousedown on the edit frame\n  var _window = this.getWindow();\n  var syntheticStart = !(event instanceof _window.MouseEvent);\n\n  //during a real mousedown, ignore events originating from a resizing handle\n  if (!syntheticStart && (isDragPoint(event.target) || isRotatePoint(event.target))) return;\n\n  //get the cursor position\n  cursor = syntheticStart ? cursor : this.editor.getMousePosition();\n\n  //store the initial cursor and axis constrains\n  this.initialCursor = cursor;\n  this.initialPosition = this.markup.getClientPosition();\n  this.areAxisConstrained = false;\n  this.axisConstrains = new THREE.Vector2(1, 1);\n\n  //update the function that will handle the mousemove and mouseup events\n  this.onMouseMove = this._onRepositionMouseMove.bind(this);\n  this.onMouseUp = this._onRepositionMouseUp.bind(this);\n\n  if (this.selection.dragging)\n  return;\n\n  this.selection.dragging = true;\n  this.editor.beginActionGroup();\n\n  //if alt down I drop a clone.\n  if (event && event.altKey) {\n    var editor = this.editor;\n    var cloneMarkup = new CloneMarkup(editor, editor.getId(), this.markup, this.markup.position);\n    cloneMarkup.execute();\n  }\n\n  this.dispatchEvent({ type: MarkupEvents.EVENT_EDITFRAME_EDITION_START }); // Moving around\n};\n\nproto._onRepositionMouseMove = function (event) {\n\n  // This check is needed for selecting markups on devices that have touch screen + mouse (eg: Microsoft Surface)\n  if (ignoreFirstMouseMove) {\n    ignoreFirstMouseMove = false;\n    return false;\n  }\n  //ignore mousemove events if the dragging state hasn't been activated\n  if (!this.selection.dragging || !this.markup || this.markup.preventReposition) return false;\n\n  //get the position of the cursor relative to selection layer\n  var cursor = this.editor.getMousePosition();\n\n  //constrain axis if shift key is down.\n  var constrainAxis = this.editor.input.constrainAxis;\n  if (this.areAxisConstrained !== constrainAxis) {\n    this.areAxisConstrained = constrainAxis;\n    this.axisConstrains = constrainAxis ? new THREE.Vector2(0, 0) : new THREE.Vector2(1, 1);\n\n    this.initialPosition.x += cursor.x - this.initialCursor.x;\n    this.initialPosition.y += cursor.y - this.initialCursor.y;\n\n    this.initialCursor.x = cursor.x;\n    this.initialCursor.y = cursor.y;\n  }\n\n  //determine how many pixel we have to shift the\n  //selection box to keep the cursor on the drag point\n  var movement = {\n    x: cursor.x - this.initialCursor.x,\n    y: cursor.y - this.initialCursor.y };\n\n\n  var deadZone = 15;\n  if (this.axisConstrains.x === 0 && this.axisConstrains.y === 0) {\n\n    if (Math.abs(movement.x) > deadZone) {\n      this.axisConstrains.x = 1;\n      movement.x += movement.x < 0 ? deadZone : -deadZone;\n    } else\n    if (Math.abs(movement.y) > deadZone) {\n      this.axisConstrains.y = 1;\n      movement.y += movement.y < 0 ? deadZone : -deadZone;\n    }\n  }\n\n  var x = this.initialPosition.x + movement.x * this.axisConstrains.x;\n  var y = this.initialPosition.y + movement.y * this.axisConstrains.y;\n\n  updateSelectorBoxPosition.bind(this)(x, y, this.selection.rotation);\n\n  //tell the markup to start transforming\n  //the markup expects an (x, y) coordinate that\n  //uses an origin at the center, adjust our x, y because\n  //our origin starts at the top left\n  var position = this.editor.positionFromClientToMarkups(x, y);\n  var setPosition = new SetPosition(this.editor, this.markup, position);\n  setPosition.execute();\n  return true;\n};\n\nproto._onRepositionMouseUp = function () {\n\n  if (this.markup && this.markup.preventReposition) return;\n\n  this.last = null;\n\n  //this should never be called after the mouse up because we are no longer repositioning\n  this.onMouseMove = function () {/*do nothing*/};\n  this.onMouseUp = function () {/*do nothing*/};\n\n  if (!this.selection.dragging) {\n    return;\n  }\n\n  this.editor.closeActionGroup();\n  this.selection.dragging = false;\n  this.dispatchEvent({ type: MarkupEvents.EVENT_EDITFRAME_EDITION_END }); // Moving around\n};\n\nproto._onResizeMouseDown = function (event) {\n\n  if (this._handleRightClickDown(event))\n  return;\n\n  var target = event.target;\n\n  //is the target where the mousedown occurred a drag point\n  if (!isDragPoint(target)) {\n    return;\n  }\n\n  //keep a reference to the point where the drag started\n  this.selection.handle.resizing = target;\n  //figure out which direction this point should resize\n  var direction = this.selection.handle.resizing.getAttribute('data-sdp-handle');\n  //set the cursor position for the entire layer\n  this.containingDiv.style.cursor = direction + '-resize';\n\n  var cursor = this.editor.getMousePosition();\n\n  var position = this.markup.getClientPosition();\n  var size = this.markup.getBoundingRect();\n\n  //store the center\n  this.initial = {\n    x: position.x,\n    y: position.y,\n    width: size.width,\n    height: size.height,\n    mouseX: cursor.x,\n    mouseY: cursor.y };\n\n\n  this.onMouseMove = this._onResizeMouseMove.bind(this);\n  this.onMouseUp = this._onResizeMouseUp.bind(this);\n\n  if (this.selection.resizing) {\n    return;\n  }\n\n  this.selection.resizing = true;\n  this.editor.beginActionGroup();\n\n  setHandleSelected(event.target, true);\n\n  //notify the markup that dragging has started\n  this.dispatchEvent({ type: MarkupEvents.EVENT_EDITFRAME_EDITION_START }); // Resizing\n};\n\nproto._onResizeMouseMove = function (event) {\n\n  if (!this.selection.resizing) return false;\n\n  var cursor = this.editor.getMousePosition();\n  var initial = this.initial;\n\n  var movement = {\n    x: cursor.x - initial.mouseX,\n    y: cursor.y - initial.mouseY };\n\n\n  var vector = new THREE.Vector3(movement.x, movement.y, 0);\n  var undoRotation = new THREE.Matrix4().makeRotationZ(-this.selection.rotation);\n  movement = vector.applyMatrix4(undoRotation);\n\n  var x = initial.x,\n  y = initial.y,\n  width = initial.width,\n  height = initial.height;\n\n  var localSpaceDelta = new THREE.Vector3();\n\n  //get the direction of the arrow being dragged\n  var direction = this.selection.handle.resizing.getAttribute('data-sdp-handle');\n\n  // TODO: Make a mechanism to configure and use this feature from Markups Core.\n  // If shift is pressed, figure aspect ratio is maintained.\n  if (this.editor.input.keepAspectRatio && ['nw', 'ne', 'sw', 'se'].indexOf(direction) !== -1) {\n\n    var delta = new THREE.Vector3(movement.x, movement.y, 0);\n    switch (direction) {\n      case 'nw':movement.set(-initial.width, -initial.height, 0);break;\n      case 'ne':movement.set(initial.width, -initial.height, 0);break;\n      case 'sw':movement.set(initial.width, -initial.height, 0);break;\n      case 'se':movement.set(initial.width, initial.height, 0);break;}\n\n    movement.normalize();\n    movement = delta.projectOnVector(movement);\n  }\n\n  var translations = {\n    n: function n() {\n      height -= movement.y;\n      localSpaceDelta.y = movement.y;\n    },\n    s: function s() {\n      height += movement.y;\n      localSpaceDelta.y = movement.y;\n    },\n    w: function w() {\n      width -= movement.x;\n      localSpaceDelta.x = movement.x;\n    },\n    e: function e() {\n      width += movement.x;\n      localSpaceDelta.x = movement.x;\n    },\n    nw: function nw() {\n      this.n();\n      this.w();\n    },\n    ne: function ne() {\n      this.n();\n      this.e();\n    },\n    sw: function sw() {\n      this.s();\n      this.w();\n    },\n    se: function se() {\n      this.s();\n      this.e();\n    } };\n\n\n  translations[direction]();\n\n  // Check if new size is smaller than min width or height\n  if (width <= this.markup.getMinWidth() || height <= this.markup.getMinHeight()) return;\n\n  var redoRotation = new THREE.Matrix4().makeRotationZ(this.selection.rotation);\n  var actualDelta = localSpaceDelta.applyMatrix4(redoRotation);\n\n  var newPos = this.editor.positionFromClientToMarkups(\n  x + actualDelta.x * 0.5,\n  y + actualDelta.y * 0.5);\n\n  var newSize = this.editor.sizeFromClientToMarkups(width, height);\n\n  var setSize = new SetSize(this.editor, this.markup, newPos, newSize.x, newSize.y);\n  setSize.execute();\n  return true;\n};\n\nfunction setHandleSelected(handle, isSelected) {\n  if (isSelected) {\n    handle.classList.add('selected');\n  } else {\n    handle.classList.remove('selected');\n  }\n}\n\nproto._onResizeMouseUp = function (event) {\n  this.selection.resizing = false;\n  this.selection.handle.resizing = null;\n  this.containingDiv.style.cursor = '';\n\n  for (var direction in this.selection.handle) {\n    if (this.selection.handle[direction]) {\n      setHandleSelected(this.selection.handle[direction], false);\n    }\n  }\n\n\n  this.editor.closeActionGroup();\n  this.dispatchEvent({ type: MarkupEvents.EVENT_EDITFRAME_EDITION_END }); // Resizing\n\n  //this should never be called after the mouse up because we are no longer resizing\n  this.onMouseMove = function () {/*do nothing*/\n  };\n  this.onMouseUp = function () {/*do nothing*/\n  };\n};\n\n\n/**\n    * Attaches all the necessary listeners to handle a resizing action.\n    *\n    * @this EditFrame\n    */\nfunction handleSelectionBoxResizing() {\n  this.selectionLayer.addEventListener('mousedown', this._onResizeMouseDown.bind(this));\n}\n\nfunction handleSelectionBoxRotating() {\n\n  this.selection.element.addEventListener('mousedown', this._onRotationMouseDown.bind(this));\n}\n\nvar initialRotation;\nvar initialHandlePosition;\n\nproto._onRotationMouseDown = function (event) {\n\n  if (this._handleRightClickDown(event))\n  return;\n\n  //ignore anything not coming from the rotation point\n  if (!isRotatePoint(event.target)) return;\n\n  this.editor.beginActionGroup();\n  this.selection.rotating = true;\n\n  //store the initial cursor\n  initialHandlePosition = this.editor.getMousePosition();\n\n  initialRotation = this.selection.rotation || 0;\n\n  //update the function that will handle the mousemove and mouseup events\n  this.onMouseMove = this._onRotationMouseMove.bind(this);\n  this.onMouseUp = this._onRotationMouseUp.bind(this);\n\n  setHandleSelected(event.target, true);\n\n  this.dispatchEvent({ type: MarkupEvents.EVENT_EDITFRAME_EDITION_START }); // Rotating\n};\n\nproto._onRotationMouseMove = function (event) {\n\n  //ignore mousemove events if the dragging state hasn't been activated\n  if (!this.selection.rotating) return false;\n\n  var cursor = this.editor.getMousePosition();\n  var position = this.markup.getClientPosition();\n\n  var r = getAngleBetweenPoints(position, cursor);\n  var r2 = getAngleBetweenPoints(position, initialHandlePosition);\n  var rotation = r - r2 + initialRotation;\n\n  // TODO: Make a mechanism to configure and use this feature from Markups Core.\n  if (this.editor.input.snapRotations) {\n    var snap = degreesToRadians(22.5);\n    rotation = Math.ceil(rotation / snap) * snap;\n  }\n\n  //pass rotation as degrees\n  updateSelectorBoxPosition.bind(this)(this.selection.x, this.selection.y, rotation);\n\n  //convert to radians\n  var setRotation = new SetRotation(this.editor, this.markup, rotation);\n  setRotation.execute();\n  return true;\n};\n\nproto._onRotationMouseUp = function (event) {\n\n  this.selection.rotating = false;\n  initialRotation = null;\n  initialHandlePosition = null;\n  setHandleSelected(this.selection.rotationHandle, false);\n  this.editor.closeActionGroup();\n  this.dispatchEvent({ type: MarkupEvents.EVENT_EDITFRAME_EDITION_END }); // Rotating\n};\n\n/**\n    * Attaches double click listener and pass events to markup, markups such as text use it to enter text edit\n    * mode.\n    *\n    * @this EditFrame\n    */\nfunction handleSelectionDoubleClick() {\n\n  var doubleClick = function (event) {\n    if (event.defaultPrevented) {\n      return;\n    }\n    this.selection.dragging = false;\n    var editMode = this.editor.editMode;\n    editMode && editMode.onMouseDoubleClick(this.markup);\n  }.bind(this);\n\n  var selectorBoxWrapper = this.selectionLayer;\n  selectorBoxWrapper.addEventListener('dblclick', doubleClick);\n}\n\nfunction togglePointerEvents(element, state) {\n\n  element.style.pointerEvents = state ? 'auto' : 'none';\n}\n\nfunction getAngleBetweenPoints(p1, p2) {\n\n  return Math.atan2(p2.y - p1.y, p2.x - p1.x);\n}\n\nfunction matchesSelectorAux(domElem, selector) {\n  if (domElem.matches) return domElem.matches(selector); //Un-prefixed\n  if (domElem.msMatchesSelector) return domElem.msMatchesSelector(selector); //IE\n  if (domElem.mozMatchesSelector) return domElem.mozMatchesSelector(selector); //Firefox (Gecko)\n  if (domElem.webkitMatchesSelector) return domElem.webkitMatchesSelector(selector); // Opera, Safari, Chrome\n  return false;\n}","function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError(\"Cannot call a class as a function\");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}\n// Maps EditMode id (string) into a contructor/class\nvar _editModes = {};var\n\nEditModeManager = /*#__PURE__*/function () {\n  function EditModeManager() {\n    // nothing //\n    _classCallCheck(this, EditModeManager);}_createClass(EditModeManager, [{ key: \"register\", value: function register(\n\n    id, clazz) {\n      if (id in _editModes)\n      throw new Error(\"EditMode with id (\".concat(id, \") already registered.\"));\n\n      _editModes[id] = clazz;\n    } }, { key: \"unregister\", value: function unregister(\n\n    id) {\n      if (id in _editModes)\n      delete _editModes[id];\n    } }, { key: \"getClass\", value: function getClass(\n\n    id) {\n      return _editModes[id] || null;\n    } }, { key: \"getRegistered\", value: function getRegistered()\n\n    {\n      var ret = {};\n      for (var id in _editModes) {\n        if (_editModes.hasOwnProperty(id)) {\n          ret[id] = _editModes[id];\n        }\n      }\n      return ret; // shallow copy.\n    } }]);return EditModeManager;}();\n\n\n\nexport var theEditModeManager = new EditModeManager();","'use strict';\n\nimport { addTraitEventDispatcher, renderToCanvas, radiansToDegrees,\ncheckPolygon, checkLineSegment, isTouchDevice } from './MarkupsCoreUtils';\nimport { createStyle, copyStyle, cloneStyle } from './StyleUtils';\nimport * as MarkupEvents from './MarkupEvents';\n\nvar av = Autodesk.Viewing;\n\n/**\n                            * Base class for all markups.\n                            *\n                            * A Markup is a class that is capable of rendering itself as an Svg node.<br>\n                            * It can also render itself into a canvas-2d context.\n                            * Component within {@link Autodesk.Viewing.Extensions.Markups.Core.MarkupsCore MarkupsCore} extension.\n                            *\n                            * Any class extending Markup should contain at least the following methods:\n                            * - getEditMode()\n                            * - set()\n                            * - updateStyle()\n                            * - setParent()\n                            * - setRotation()\n                            * - setSize()\n                            * - setPosition()\n                            * - renderToCanvas()\n                            * - setMetadata()\n                            *\n                            * A good reference is the rectangle markup implementation available in\n                            * {@link Autodesk.Viewing.Extensions.Markups.Core.MarkupRectangle|MarkupRectangle}.\n                            *\n                            * @tutorial feature_markup\n                            * @constructor\n                            * @memberof Autodesk.Viewing.Extensions.Markups.Core\n                            *\n                            * @param {number} id - Identifier, populated with return value of {@link Autodesk.Viewing.Extensions.Markups.Core.MarkupsCore#getId getId()}.\n                            * @param {Autodesk.Viewing.Extensions.Markups.Core.MarkupsCore} editor - Markups extension\n                            * @param {Array} styleAttributes - Attributes for customization. Related to {@link Autodesk.Viewing.Extensions.Markups.Core.MarkupsCore#setStyle setStyle()}.\n                            * @constructor\n                            */\nexport function Markup(id, editor, styleAttributes) {\n\n  this.id = id;\n  this.type = \"\";\n  this.editor = editor;\n  this.viewer = editor.viewer;\n  this.setGlobalManager(this.viewer.globalManager);\n  this.position = { x: 0, y: 0 };\n  this.size = { x: 0, y: 0 };\n  this.rotation = 0;\n  this.style = createStyle(styleAttributes, this.editor);\n  this.style = copyStyle(editor.getDefaultStyle(), this.style);\n  this.highlightColor = '#0696D7';\n  this.constraintWidth = false;\n  this.constraintHeight = false;\n  this.constraintRotation = false;\n  this.minWidth = -10000;\n  this.minHeight = -10000;\n  this.highlighted = false;\n  this.selected = false;\n\n  // bind to this to pass this.globalManager\n  this.checkLineSegment = checkLineSegment.bind(this);\n  this.checkPolygon = checkPolygon.bind(this);\n  this.renderToCanvasX = renderToCanvas.bind(this);\n\n  addTraitEventDispatcher(this);\n}\n\nav.GlobalManagerMixin.call(Markup.prototype);\nvar proto = Markup.prototype;\n\nproto.destroy = function () {\n\n  this.unselect();\n  this.setParent(null);\n};\n\n/**\n    * Specifies the parent layer which will contain the markup.\n    * @param {HTMLElement} parent\n    */\nproto.setParent = function (parent) {\n\n  var div = this.shape;\n  div.parentNode && div.parentNode.removeChild(div);\n  parent && parent.appendChild(div);\n};\n\n/**\n    * Clones (deep-copy) the markup. Used internally by the copy/cut/paste mechanism in\n    * {@link Autodesk.Viewing.Extensions.Markups.Core.MarkupsCore MarkupsCore}.\n    *\n    * @returns {Autodesk.Viewing.Extensions.Markups.Core.Markup} clone of the current markup\n    */\nproto.clone = function () {\n\n  var clone = Object.create(this.__proto__);\n  var overrides = this.getCloneOverrides();\n\n  for (var name in this) {\n\n    if (!this.hasOwnProperty(name)) {\n      continue;\n    }\n\n    var member = this[name];\n\n    // Is there an override for this member?\n    if (overrides.hasOwnProperty(name)) {\n      clone[name] = overrides[name];\n      continue;\n    }\n\n    // Member is null or undefined?\n    if (member === null || member === undefined) {\n      clone[name] = member;\n      continue;\n    }\n\n    // Member has a clone function?\n    if (member['clone'] instanceof Function) {\n      clone[name] = member.clone();\n      continue;\n    }\n\n    // Is it a function?\n    if (member instanceof Function) {\n      clone[name] = member.bind(clone);\n      continue;\n    }\n\n    // Is it an html node?\n    if (member.nodeType) {\n      clone[name] = member.cloneNode(true);\n      continue;\n    }\n\n    // Is it the globalManager?\n    if (member instanceof av.GlobalManager) {\n      av.GlobalManagerMixin.call(clone);\n      clone.setGlobalManager(member);\n      continue;\n    }\n\n    // Just a plain object?\n    if (member instanceof Object) {\n      clone[name] = JSON.parse(JSON.stringify(member));\n      continue;\n    }\n\n    // Ok, it seems it's just a primitive type.\n    clone[name] = member;\n  }\n\n  this.cloneShape(clone);\n  return clone;\n};\n\nproto.cloneShape = function (clone) {\n\n  clone.shape.markup = clone.shape.childNodes.item(0);\n  clone.shape.hitarea = clone.shape.childNodes.item(1);\n  clone.bindDomEvents();\n};\n\n/**\n    * Used internally by\n    * {@link Autodesk.Viewing.Extensions.Markups.Core.Markup#clone clone()},\n    * provides a mechanism to avoid cloning specific attributes.<br>\n    * Developers only need to override this method when creating new Markup types.\n    * When overriding, first call the super() implementation and then include additional attribute/value pairs to it.\n    * @returns {Object} containing attributes that need not to be cloned.\n    */\nproto.getCloneOverrides = function () {\n\n  return {\n    viewer: this.viewer,\n    editor: this.editor,\n    hammer: null,\n    listeners: {} };\n\n};\n\n/**\n    * Used internally to select a markup.<br>\n    * Fires event Autodesk.Viewing.Extensions.Markups.Core.EVENT_MARKUP_SELECTED.\n    */\nproto.select = function () {\n\n  if (this.selected) {\n    return;\n  }\n\n  this.selected = true;\n  this.highlighted = false;\n  this.updateStyle();\n  this.dispatchEvent({ type: MarkupEvents.EVENT_MARKUP_SELECTED, markup: this });\n};\n\n/**\n    * Used internally to signal that the current markup has been unselected.<br>\n    * No event is fired.\n    */\nproto.unselect = function () {\n\n  this.selected = false;\n};\n\nproto.highlight = function (highlight) {\n\n  if (this.interactionsDisabled) {\n    return;\n  }\n\n  this.highlighted = highlight;\n  this.updateStyle();\n};\n\n/**\n    * Returns a copy of the markup's style.\n    * @returns {Object}\n    */\nproto.getStyle = function () {\n\n  return cloneStyle(this.style);\n};\n\n/**\n    * Used internally to set the style object. Triggers a re-render of the markup (Svg)\n    * @param {Object} style - Dictionary with key/value pairs\n    */\nproto.setStyle = function (style) {\n\n  copyStyle(style, this.style);\n  this.updateStyle();\n};\n\n/**\n    * Used internally and implemented by specific Markup types to render themselves as Svg.\n    */\nproto.updateStyle = function () {\n\n};\n\n/**\n    * Used internally to notify the markup that it is now being edited.<br>\n    * Fires event Autodesk.Viewing.Extensions.Markups.Core.EVENT_MARKUP_ENTER_EDITION.\n    */\nproto.edit = function () {\n\n  this.dispatchEvent({ type: MarkupEvents.EVENT_MARKUP_ENTER_EDITION, markup: this });\n};\n\n/**\n    * Used internally to signal that it is no longer being edited.<br>\n    * Fires event Autodesk.Viewing.Extensions.Markups.Core.EVENT_MARKUP_CANCEL_EDITION.\n    */\nproto.cancel = function () {\n\n  this.dispatchEvent({ type: MarkupEvents.EVENT_MARKUP_CANCEL_EDITION, markup: this });\n};\n\n/**\n    * Used internally to signal that the markup is being deleted.<br>\n    * Fires event Autodesk.Viewing.Extensions.Markups.Core.EVENT_MARKUP_DELETE_EDITION.\n    */\nproto.deleteMarkup = function () {\n\n  this.dispatchEvent({ type: MarkupEvents.EVENT_MARKUP_DELETE_EDITION, markup: this });\n};\n\n/**\n    * Used internally to get the {@link Autodesk.Viewing.Extensions.Markups.Core.EditMode EditMode}\n    * associated with the current Markup.<br>\n    * Implemented by classes extending this one.\n    * @returns {Autodesk.Viewing.Extensions.Markups.Core.EditMode}\n    */\nproto.getEditMode = function () {\n\n  console.warn('EditMode of markup type' + this.type + ' not defined.');\n  return null;\n};\n\n/**\n    * Used internally to get the markup's position in browser pixel space.<br>\n    * Notice that (0,0) is top left.<br>\n    * See also\n    * {@link Autodesk.Viewing.Extensions.Markups.Core.Markup#getClientSize|getClientSize()}.\n    * @returns {*}\n    */\nproto.getClientPosition = function () {\n\n  var position = this.position;\n  return this.editor.positionFromMarkupsToClient(position.x, position.y);\n};\n\n/**\n    * Used internally to get the markup's bounding rect in browser pixel space.<br>\n    * See also\n    * {@link Autodesk.Viewing.Extensions.Markups.Core.Markup#getClientPosition|getClientPosition()}.\n    * @returns {*}\n    */\nproto.getClientSize = function () {\n\n  var size = this.size;\n  return this.editor.sizeFromMarkupsToClient(size.x, size.y);\n};\n\n/**\n    * Used internally to get the markup's bounding rect in browser pixel space, including the stroke width.<br>\n    * @returns {Object} a rectangle with right, top, left, bottom attributes\n    */\nproto.getBoundingRect = function () {\n\n  var rotation = this.rotation;\n\n  if (rotation !== 0) {// Undo rotation to find a tight bounding rect\n    this.setRotation(0);\n  }\n\n  var parentRect = this.viewer.impl.getCanvasBoundingClientRect();\n\n  var boundRect = this.shape.markup.getBoundingClientRect();\n  var top = boundRect.top - parentRect.top;\n\n  var strokeWidth = this.style['stroke-width'] || 0;\n  var offset = this.editor.sizeFromMarkupsToClient(strokeWidth, 0).x;\n\n  if (rotation !== 0) {\n    this.setRotation(rotation);\n  }\n\n  return {\n    x: boundRect.left - parentRect.left - offset,\n    y: top - offset,\n    width: boundRect.width + 2 * offset,\n    height: boundRect.height + 2 * offset };\n\n};\n\n/**\n    * Changes the rotation of the markup to the given angle.\n    * This gets called by the Autodesk.Viewing.Extensions.Markups.Core.SetRotation edit action\n    *\n    * @param {Number} angle\n    */\nproto.setRotation = function (angle) {\n\n  this.rotation = angle;\n  this.updateStyle();\n};\n\nproto.getRotation = function () {\n\n  return this.rotation;\n};\n\n/**\n    * Used by the EditFrame to move the markup in Client Space coordinates\n    * @param {Number} x - New X location for the markup. Notice that markups are centered on this value.\n    * @param {Number} y - New Y location for the markup. Notice that markups are centered on this value.\n    */\nproto.setPosition = function (x, y) {\n\n  this.position.x = x;\n  this.position.y = y;\n\n  this.updateStyle();\n};\n\n/**\n    * Changes the position and size of the markup.\n    * This gets called by the Autodesk.Viewing.Extensions.Markups.Core.SetSize edit action\n    * @param {{x: Number, y: Number}} position\n    * @param {Number} width\n    * @param {Number} height\n    */\nproto.setSize = function (position, width, height) {\n\n  this.position.x = position.x;\n  this.position.y = position.y;\n  this.size.x = width;\n  this.size.y = height;\n\n  this.updateStyle();\n};\n\nproto.isWidthConstrained = function () {\n\n  return this.constraintWidth;\n};\n\nproto.isHeightConstrained = function () {\n\n  return this.constraintHeight;\n};\n\nproto.isRotationConstrained = function () {\n\n  return this.constraintRotation;\n};\n\nproto.setMinWidth = function (minWidth) {\n  this.minWidth = minWidth;\n};\n\nproto.setMinHeight = function (minHeight) {\n  this.minHeight = minHeight;\n};\n\nproto.getMinWidth = function () {\n  return this.minWidth;\n};\n\nproto.getMinHeight = function () {\n  return this.minHeight;\n};\n\n/**\n    * Used to disable highlight on annotations while a new annotation is being created.\n    * @param {Boolean} disable - Whether (mouse) interactions are enable.\n    */\nproto.disableInteractions = function (disable) {\n\n  this.interactionsDisabled = disable;\n};\n\n/**\n    *\n    * @param width\n    */\nproto.setStrokeWidth = function (width) {\n\n};\n\nproto.constrainsToBounds = function (bounds) {\n\n};\n\nproto.onMouseDown = function (event) {\n\n  if (this.interactionsDisabled) {\n    return;\n  }\n\n  this.select();\n  this.editor.editFrame.startDrag(event);\n};\n\n/**\n    *\n    * @param idTarget\n    * @returns *\n    */\nproto.generatePoint3d = function (idTarget) {\n\n  var viewer = this.viewer;\n  var polygon = this.generateBoundingPolygon();\n  var self = this;\n\n  function checkLineSegmentAux(a, b) {\n\n    var point2d = self.checkLineSegment(a.x, a.y, b.x, b.y, idTarget);\n    var point3d = point2d && viewer.clientToWorld(point2d.x, point2d.y);\n    return point3d && point3d.point;\n  }\n\n  function checkPolygonAux(polygon) {\n\n    var point2d = self.checkPolygon(polygon, idTarget);\n    var point3d = point2d && viewer.clientToWorld(point2d.x, point2d.y);\n    return point3d && point3d.point;\n  }\n\n  // Try to avoid expensive calculations by checking some lines segments first.\n  // If line check cannot find a point the costly one by area is used.\n  // A ----midAB---- B\n  // |               |\n  // |     center    |\n  // |               |\n  // C --------------D\n\n  var xVertices = polygon.xVertices;\n  var yVertices = polygon.yVertices;\n\n  var midAB = new THREE.Vector2(xVertices[0] + xVertices[1], yVertices[0] + yVertices[1]).multiplyScalar(0.5);\n  var midAC = new THREE.Vector2(xVertices[0] + xVertices[3], yVertices[0] + yVertices[3]).multiplyScalar(0.5);\n  var midDB = new THREE.Vector2(xVertices[2] + xVertices[1], yVertices[2] + yVertices[1]).multiplyScalar(0.5);\n  var midDC = new THREE.Vector2(xVertices[2] + xVertices[3], yVertices[2] + yVertices[3]).multiplyScalar(0.5);\n  var center = midAC.clone().add(midDB).multiplyScalar(0.5);\n\n  var point3d =\n  checkLineSegmentAux(center, midDB) ||\n  checkLineSegmentAux(center, midAC) ||\n  checkLineSegmentAux(center, midAB) ||\n  checkLineSegmentAux(center, midDC);\n\n  return point3d || checkPolygonAux(polygon);\n};\n\n/**\n    *\n    * @returns {{min: {x: number, y: number}, max: {x: number, y: number}}}\n    */\nproto.generateBoundingBox = function () {\n\n  var boundingBox = { min: { x: 0, y: 0 }, max: { x: 0, y: 0 } };\n\n  // Get bounding box from markup bounding polygon.\n  var polygon = this.generateBoundingPolygon();\n\n  var vertexCount = polygon.vertexCount;\n  var xVertices = polygon.xVertices;\n  var yVertices = polygon.yVertices;\n\n  var bbX0 = Number.POSITIVE_INFINITY;\n  var bbY0 = Number.POSITIVE_INFINITY;\n  var bbX1 = Number.NEGATIVE_INFINITY;\n  var bbY1 = Number.NEGATIVE_INFINITY;\n\n  for (var i = 0; i < vertexCount; ++i) {\n\n    var bbX = xVertices[i];\n    var bbY = yVertices[i];\n\n    bbX0 = Math.min(bbX0, bbX);\n    bbY0 = Math.min(bbY0, bbY);\n    bbX1 = Math.max(bbX1, bbX);\n    bbY1 = Math.max(bbY1, bbY);\n  }\n\n  boundingBox.min.x = bbX0;\n  boundingBox.min.y = bbY0;\n  boundingBox.max.x = bbX1;\n  boundingBox.max.y = bbY1;\n\n  return boundingBox;\n};\n\n/**\n    *\n    * @returns {{vertexCount: number, xVertices: Float32Array, yVertices: Float32Array}}\n    */\nproto.generateBoundingPolygon = function () {\n\n  var position = this.getClientPosition();\n  var halfSize = this.getClientSize();\n\n  halfSize.x *= 0.5;\n  halfSize.y *= 0.5;\n\n  var lt = new THREE.Vector3(-halfSize.x, -halfSize.y).add(position);\n  var rt = new THREE.Vector3(halfSize.x, -halfSize.y).add(position);\n  var rb = new THREE.Vector3(halfSize.x, halfSize.y).add(position);\n  var lb = new THREE.Vector3(-halfSize.x, halfSize.y).add(position);\n\n  if (this.rotation !== 0) {\n\n    var m1 = new THREE.Matrix4().makeTranslation(-position.x, -position.y, 0);\n    var m2 = new THREE.Matrix4().makeRotationZ(this.rotation);\n    var m3 = new THREE.Matrix4().makeTranslation(position.x, position.y, 0);\n    var transform = m3.multiply(m2).multiply(m1);\n\n    lt.applyMatrix4(transform);\n    rt.applyMatrix4(transform);\n    rb.applyMatrix4(transform);\n    lb.applyMatrix4(transform);\n  }\n\n  return { // packed for fast access in test algorithm.\n    vertexCount: 4,\n    xVertices: new Float32Array([lt.x, rt.x, rb.x, lb.x]),\n    yVertices: new Float32Array([lt.y, rt.y, rb.y, lb.y]) };\n\n};\n\n/**\n    * Implemented by extending classes.<br>\n    * Gets called automatically when\n    * {@link Autodesk.Viewing.Extensions.Markups.Core.MarkupsCore#generateData|generateData()}\n    * @returns {null|Element} - Either null (default) or the metadata Svg node\n    */\nproto.setMetadata = function () {\n\n  return null; // No metadata is injected by default.\n};\n\nproto.setMouseDisabledWhenTouching = function (event) {\n\n  if (event.isFirst) {\n    this.shape.removeEventListener('mousedown', this.onMouseDownBinded);\n  } else if (event.isFinal) {\n    var _this = this;\n    setTimeout(function () {\n      _this.shape.addEventListener('mousedown', _this.onMouseDownBinded);\n    }, 10);\n  }\n};\n\nproto.bindDomEvents = function () {\n\n  if (isTouchDevice()) {\n\n    this.hammer = new av.Hammer.Manager(this.shape, {\n      recognizers: [\n      av.GestureRecognizers.singletap],\n\n      handlePointerEventMouse: false,\n      inputClass: av.isIE11 ? av.Hammer.PointerEventInput : av.Hammer.TouchInput });\n\n\n    this.onSingleTapBinded = function (event) {\n\n      this.onMouseDown(event);\n    }.bind(this);\n\n    this.onHammerInputBinded = function (event) {\n\n      this.setMouseDisabledWhenTouching(event);\n    }.bind(this);\n\n    this.hammer.on('singletap', this.onSingleTapBinded);\n    this.hammer.on('hammer.input', this.onHammerInputBinded);\n  }\n\n  this.onMouseDownBinded = this.onMouseDown.bind(this);\n  this.onMouseOutBinded = function () {\n\n    this.highlight(false);\n  }.bind(this);\n\n  this.onMouseOverBinded = function () {\n\n    this.highlight(true);\n  }.bind(this);\n\n  this.shape.addEventListener('mousedown', this.onMouseDownBinded);\n  this.shape.addEventListener('mouseout', this.onMouseOutBinded);\n  this.shape.addEventListener('mouseover', this.onMouseOverBinded);\n};\n\nproto.renderToCanvas = function (ctx, viewBox, width, height, callback) {\n\n  this.renderToCanvasX(this.shape, viewBox, width, height, ctx, callback);\n};\n\nproto.getPath = function () {\n\n};\n\nproto.getTransform = function () {\n\n  return [\n  'translate(', this.position.x, ',', this.position.y, ')',\n  'rotate(', radiansToDegrees(-this.rotation), ')'].\n  join(' ');\n};","'use strict';\n\nimport { Markup } from './Markup';\nimport * as MarkupTypes from './MarkupTypes';\nimport { createMarkupPathSvg, composeRGBAString, setAttributeToMarkupSvg,\nupdateMarkupPathSvgHitarea, checkLineSegment, addMarkupMetadata } from './MarkupsCoreUtils';\nimport { cloneStyle } from './StyleUtils';\nimport { EditModeArrow } from './edit-modes/EditModeArrow';\n\n/**\n                                                             *\n                                                             * @param id\n                                                             * @param editor\n                                                             * @constructor\n                                                             */\nexport function MarkupArrow(id, editor) {\n\n  var styleAttributes = ['stroke-width', 'stroke-color', 'stroke-opacity'];\n  Markup.call(this, id, editor, styleAttributes);\n\n  // bind to this to pass this.globalManager\n  this.addMarkupMetadata = addMarkupMetadata.bind(this);\n  this.checkLineSegment = checkLineSegment.bind(this);\n\n  this.type = MarkupTypes.MARKUP_TYPE_ARROW;\n  this.constraintHeight = true;\n\n  // Create head and tail.\n  this.head = new THREE.Vector3();\n  this.tail = new THREE.Vector3();\n  this.size.y = this.style['stroke-width'] * 3;\n  this.shape = createMarkupPathSvg();\n\n  this.bindDomEvents();\n}\n\nMarkupArrow.prototype = Object.create(Markup.prototype);\nMarkupArrow.prototype.constructor = MarkupArrow;\n\nvar proto = MarkupArrow.prototype;\n\nproto.getEditMode = function () {\n\n  return new EditModeArrow(this.editor);\n};\n\n/**\n    * Sets top-left and bottom-right values in client space coordinates (2d).\n    * Notice that for the arrow, the top left is the \"tail\" of the arrow and\n    * the bottom right is the \"head\" of it.\n    *\n    * @param {Number} xO - tail\n    * @param {Number} yO - tail\n    * @param {Number} xF - head\n    * @param {Number} yF - head\n    */\nproto.set = function (xO, yO, xF, yF) {\n\n  var vO = new THREE.Vector2(xO, yO);\n  var vF = new THREE.Vector2(xF, yF);\n  var vDir = vF.clone().sub(vO).normalize();\n\n  this.size.x = vO.distanceTo(vF); // TODO: Clamp min length\n  this.rotation = Math.acos(vDir.dot(new THREE.Vector2(1, 0)));\n  this.rotation = yF > yO ? Math.PI * 2 - this.rotation : this.rotation;\n\n  var head = this.head;\n  var tail = this.tail;\n\n  head.set(xF, yF, 0);\n  tail.set(xO, yO, 0);\n\n  this.position.x = tail.x + (head.x - tail.x) * 0.5;\n  this.position.y = tail.y + (head.y - tail.y) * 0.5;\n\n  this.updateStyle();\n};\n\n/**\n    * Changes the rotation of the markup to the given angle.\n    * This gets called by the Autodesk.Viewing.Extensions.Markups.Core.SetRotation edit action\n    *\n    * @param {Number} angle\n    */\nproto.setRotation = function (angle) {\n\n  this.rotation = angle;\n\n  var xF = Math.cos(-angle);\n  var yF = Math.sin(-angle);\n  var vFDir = new THREE.Vector2(xF, yF); // already normalized\n  vFDir.multiplyScalar(this.size.x * 0.5);\n\n  var vCenter = new THREE.Vector2(this.position.x, this.position.y);\n  var vO = vCenter.clone().sub(vFDir);\n  var vF = vCenter.clone().add(vFDir);\n\n  this.head.set(vF.x, vF.y, 0);\n  this.tail.set(vO.x, vO.y, 0);\n\n  this.updateStyle();\n};\n\n/**\n    * Changes the position and size of the markup.\n    * This gets called by the namespace.SetSize edit action\n    * @param {{x: Number, y: Number}} position - arrow's center\n    * @param {Number} width - Arrow's length\n    * @param {Number} height - We ignore this one because we use the arrow's stroke width instead\n    */\nproto.setSize = function (position, width, height) {\n\n  var xF = Math.cos(-this.rotation);\n  var yF = Math.sin(-this.rotation);\n  var vFDir = new THREE.Vector2(xF, yF); // already normalized\n  vFDir.multiplyScalar(width * 0.5);\n\n  var vCenter = new THREE.Vector2(position.x, position.y);\n  var vO = vCenter.clone().sub(vFDir);\n  var vF = vCenter.clone().add(vFDir);\n\n  this.head.set(vF.x, vF.y, 0);\n  this.tail.set(vO.x, vO.y, 0);\n\n  this.position.x = position.x;\n  this.position.y = position.y;\n  this.size.x = width;\n\n  this.updateStyle();\n};\n\nproto.updateStyle = function () {\n\n  var style = this.style;\n  var shape = this.shape;\n  var strokeWidth = style['stroke-width'];\n  var strokeColor = this.highlighted ? this.highlightColor : composeRGBAString(style['stroke-color'], style['stroke-opacity']);\n  var transform = this.getTransform();\n\n  this.size.y = strokeWidth * 3;\n  this.style['fill-color'] = style['stroke-color'];\n  this.style['fill-opacity'] = style['stroke-opacity'];\n\n  setAttributeToMarkupSvg(shape, 'd', this.getPath().join(' '));\n  setAttributeToMarkupSvg(shape, 'stroke-width', strokeWidth);\n  setAttributeToMarkupSvg(shape, 'stroke', strokeColor);\n  setAttributeToMarkupSvg(shape, 'fill', strokeColor);\n  setAttributeToMarkupSvg(shape, 'transform', transform);\n  updateMarkupPathSvgHitarea(shape, this.editor);\n};\n\n/**\n    * Used by the EditFrame to move the markup in Client Space coordinates\n    * @param {Number} x - New X location for the markup. Notice that markups are centered on this value.\n    * @param {Number} y - New Y location for the markup. Notice that markups are centered on this value.\n    */\nproto.setPosition = function (x, y) {\n\n  var head = this.head;\n  var tail = this.tail;\n\n  var dx = head.x - tail.x;\n  var dy = head.y - tail.y;\n\n  var xo = x + dx * 0.5;\n  var yo = y + dy * 0.5;\n\n  head.x = xo;\n  head.y = yo;\n\n  tail.x = xo - dx;\n  tail.y = yo - dy;\n\n  this.position.x = tail.x + (head.x - tail.x) * 0.5;\n  this.position.y = tail.y + (head.y - tail.y) * 0.5;\n\n  this.updateStyle();\n};\n\nproto.generatePoint3d = function (idTarget) {\n\n  var head = this.editor.positionFromMarkupsToClient(this.head.x, this.head.y);\n  var tail = this.editor.positionFromMarkupsToClient(this.tail.x, this.tail.y);\n\n  var direction = head.clone().sub(tail).normalize();\n\n  var point2d = this.checkLineSegment(head.x, head.y, head.x + direction.x * 200, head.y + direction.y * 200, idTarget);\n  var point3d = point2d && this.viewer.clientToWorld(point2d.x, point2d.y);\n\n  return point3d && point3d.point;\n};\n\nproto.setMetadata = function () {\n\n  var metadata = cloneStyle(this.style);\n\n  metadata.type = this.type;\n  metadata.head = [this.head.x, this.head.y].join(\" \");\n  metadata.tail = [this.tail.x, this.tail.y].join(\" \");\n  metadata.rotation = String(this.rotation);\n\n  return this.addMarkupMetadata(this.shape, metadata);\n};\n\nproto.getPath = function () {\n\n  // To build the arrow we need 7 points in total\n  // The 'default' arrow built here has the following characteristics:\n  //\n  // 1. It is built horizontally facing right\n  // 2. It's bounding rectangle has length: this.size.x\n  // 3. It's bounding rectangle has height: 2 * this.strokeWidth\n  // 4. The arrow tail's thickness is: this.strokeWidth\n  // 5. The arrow head's length is: 2/3 of (point 3)\n  // 6. The arrow head's thickness is: (point 3)\n  // 7. The arrow generated is centered in its local (0,0), meaning that\n  //    two points are placed with negative x values, and all other have\n  //    positive x values:\n  //\n  //                            (3)\\\n  //                              \\  \\\n  //             (1)-------------(2)   \\\n  //              |         (0)        (4)\n  //             (7)-------------(6)   /\n  //                              /  /\n  //                            (5)/\n  //\n\n  var sizeX = this.size.x;\n  var sizeY = this.size.y;\n  var sizeYOver3 = sizeY / 3;\n  var strokeWidth = this.style['stroke-width'];\n  var tailW = sizeX - strokeWidth * 3;\n  var headW = sizeX - tailW;\n  var spikeOffset = strokeWidth * 0.3;\n\n  return [\n  'M', -sizeX * 0.5, -sizeY * 0.5 + sizeYOver3, // (1)\n  'l', tailW, 0, // (2)\n  'l', -spikeOffset, -sizeYOver3, // (3)\n  'l', headW + spikeOffset, sizeYOver3 * 1.5, // (4)\n  'l', -headW - spikeOffset, sizeYOver3 * 1.5, // (5)\n  'l', spikeOffset, -sizeYOver3, // (6)\n  'l', -tailW, 0, // (7)\n  'z'];\n\n};","'use strict';\n\nimport { Markup } from './Markup';\nimport * as MarkupTypes from './MarkupTypes';\nimport { createMarkupTextSvg, createMarkupPathSvg, createMarkupGroupSvg,\ncomposeRGBAString, setAttributeToMarkupSvg, setMarkupTextSvgTransform,\nupdateMarkupTextSvgClipper, updateMarkupTextSvgHitarea, updateMarkupPathSvgHitarea,\ncreateSvgElement, addMarkupMetadata, radiansToDegrees, createRectanglePath,\nEDIT_FRAME_DEFAULT_MARGIN } from './MarkupsCoreUtils';\nimport { cloneStyle, copyStyle, isStyleEqual } from './StyleUtils';\nimport { EditModeCallout } from './edit-modes/EditModeCallout';\n\n// LMV ViewerLMV-2170 [Markup] [PDF] Text markup missing/cutoff for normal sized text.\n// If the font size of an SVG text is too small, the text is not rendered independently of its final screen size.\n// To solve the issue we multiply font size by 100 and scale down the text in its transform.\nvar FONT_SIZE_SCALE = 100;\n\nvar STARTING_WIDTH_FACTOR = 6;\n\n/**\n                                * Callout Markup.\n                                * @constructor\n                                */\nexport function MarkupCallout(id, editor, size) {\n\n  var styleAttributes = [\n  'font-size',\n  'stroke-width',\n  'stroke-color',\n  'stroke-opacity',\n  'fill-color',\n  'fill-opacity',\n  'font-family',\n  'font-style',\n  'font-weight'];\n\n\n  Markup.call(this, id, editor, styleAttributes);\n\n  // bind to this to pass this.globalManager\n  this.addMarkupMetadata = addMarkupMetadata.bind(this);\n  this.createSvgElement = createSvgElement.bind(this);\n\n\n  this.type = MarkupTypes.MARKUP_TYPE_CALLOUT;\n  this.textShape = createMarkupTextSvg();\n  this.rectShape = createMarkupPathSvg();\n  this.shape = createMarkupGroupSvg([this.rectShape, this.textShape]);\n  this.isFrameUsed = true;\n  this.constraintRotation = true;\n  this.constraintHeight = true;\n  this.constraintWidth = false;\n  this.size.x = size.x;\n  this.size.y = size.y;\n  this.currentText = \"\";\n  this.currentTextLines = [\"\"];\n  this.prevHighlight = false;\n  this.isHelperTextActive = false;\n\n  // Note: We could have this property be a style property.\n  // However, there is no need for this property to be exposed to the user for alteration\n  // This value is a percentage of the font size used to offset vertically 2 text lines\n  // of the same paragraph.\n  // Notice that this value is used by EditorTextInput.js\n  this.lineHeight = 130;\n\n  this.minWidth = this.getClientFontSize() * STARTING_WIDTH_FACTOR;\n\n  this.bindDomEvents();\n}\n\nMarkupCallout.prototype = Object.create(Markup.prototype);\nMarkupCallout.prototype.constructor = MarkupCallout;\n\nvar proto = MarkupCallout.prototype;\n\nproto.getEditMode = function () {\n\n  return new EditModeCallout(this.editor);\n};\n\n/**\n    *\n    * @param {Object} position\n    * @param {Object} size\n    * @param {String} textString\n    */\nproto.set = function (position, size, textString, isFrameUsed) {\n\n  this.position.x = position.x;\n  this.position.y = position.y;\n  this.size.x = size.x;\n  this.size.y = size.y;\n  this.setIsFilledFrameUsed(isFrameUsed);\n  this.setText(textString);\n};\n\nproto.setSize = function (position, width, height) {\n\n  this.position.x = position.x;\n  this.position.y = position.y;\n  this.size.x = width;\n  this.size.y = height;\n\n  var sizeUpdateRequired = true;\n\n  if (this.isHelperTextActive) {\n    this.updateTextBoxStyle();\n  } else {\n    this.updateStyle(sizeUpdateRequired);\n  }\n};\n\nproto.setPosition = function (x, y) {\n\n  this.position.x = x;\n  this.position.y = y;\n\n  if (this.isHelperTextActive) {\n    this.updateTextBoxStyle();\n  } else {\n    this.updateStyle();\n  }\n};\n\nproto.setStyle = function (style) {\n  var stylesEqual = isStyleEqual(style, this.style);\n\n  if (!stylesEqual) {\n    copyStyle(style, this.style);\n  }\n\n  this.updateStyle(!stylesEqual);\n};\n\nproto.setText = function (text) {\n\n  this.currentText = text;\n};\n\n/**\n    * Returns the raw string value\n    * @returns {String}\n    */\nproto.getText = function () {\n\n  return this.currentText;\n};\n\n/**\n    * Returns a shallow copy of the text lines used for rendering SVG text\n    * @returns {Array.<String>}\n    */\nproto.getTextLines = function () {\n\n  return this.currentTextLines.concat();\n};\n\nproto.highlightChanged = function () {\n\n  if (this.highlighted && this.highlighted !== this.prevHighlight) {\n    var rect = this.rectShape;\n    var text = this.textShape;\n    var strokeColor = this.highlighted ? this.highlightColor : composeRGBAString(style['stroke-color'], style['stroke-opacity']);\n    setAttributeToMarkupSvg(text, 'fill', strokeColor);\n\n    if (this.isFrameUsed) {\n      setAttributeToMarkupSvg(rect, 'stroke', strokeColor);\n    }\n\n    this.prevHighlight = true;\n    return false;\n  }\n\n  return true;\n};\n\nproto.updateTextBoxStyle = function () {\n  var editMode = this.editor.duringEditMode && this.editor.editMode;\n\n  if (!editMode || editMode.type !== this.type) {\n    editMode = this.getEditMode();\n  }\n\n  editMode.updateTextBoxStyle();\n};\n\nproto.setIsHelperTextActive = function (isActive) {\n  this.isHelperTextActive = isActive;\n};\n\n/**\n    * Applies data values into DOM element style/attribute(s)\n    *\n    */\nproto.updateStyle = function (sizeUpdateRequired) {\n\n  if (this.highlightChanged()) {\n    this.prevHighlight = false;\n    var style = this.style;\n    var rect = this.rectShape;\n    var text = this.textShape;\n    var fontSize = this.style['font-size'];\n    var fontFamily = this.style['font-family'];\n    var fontWeight = this.style['font-weight'];\n    var fontStyle = this.style['font-style'];\n    var strokeColor = this.highlighted ? this.highlightColor : composeRGBAString(style['stroke-color'], style['stroke-opacity']);\n    var strokeWidth = this.style['stroke-width'];\n\n    // FONT_SIZE_SCALE is used to scale up fontSize, but it is only needed in cases where the font size is too small\n    FONT_SIZE_SCALE = fontSize > 1 ? 1 : 100;\n\n    this.rebuildTextSvg(sizeUpdateRequired);\n\n    var editor = this.editor;\n    var textContainerTransform = this.getTextContainerTransform();\n    var textTransform = this.getTextTransform();\n\n    setAttributeToMarkupSvg(text, 'font-family', fontFamily);\n    setAttributeToMarkupSvg(text, 'font-size', fontSize * FONT_SIZE_SCALE);\n    setAttributeToMarkupSvg(text, 'fill', strokeColor);\n    setAttributeToMarkupSvg(text, 'font-weight', fontWeight);\n    setAttributeToMarkupSvg(text, 'font-style', fontStyle);\n\n    setMarkupTextSvgTransform(text, textContainerTransform, textTransform);\n    updateMarkupTextSvgClipper(text, this.size.x, this.size.y);\n    updateMarkupTextSvgHitarea(text, this.size.x, this.size.y, editor);\n\n    var path = this.getPath().join(' ');\n    var transform = this.getTransform();\n    var fillColor = composeRGBAString(style['fill-color'], style['fill-opacity']);\n\n    setAttributeToMarkupSvg(rect, 'd', path);\n    setAttributeToMarkupSvg(rect, 'stroke-width', strokeWidth);\n    setAttributeToMarkupSvg(rect, 'stroke', strokeColor);\n    setAttributeToMarkupSvg(rect, 'transform', transform);\n    setAttributeToMarkupSvg(rect, 'fill', fillColor);\n    updateMarkupPathSvgHitarea(rect, editor);\n  }\n};\n\n/**\n    * Re-creates SVG tags that render SVG text.\n    * Each line is placed around tspan tags which are vertically offset to each other.\n    */\nproto.rebuildTextSvg = function (sizeUpdateRequired) {\n\n  // TODO: Remove the need to get text values from an object in edit mode, should be a function.\n  // editMode needs to be set to load markups in view mode\n  var editMode = this.editor.duringEditMode && this.editor.editMode;\n\n  if (!editMode || editMode.type !== this.type) {\n    editMode = this.getEditMode();\n    editMode.textInputHelper.textArea.value = this.currentText;\n    editMode.textInputHelper.setStyle(this.style);\n  }\n\n  if (editMode.textInputHelper.textMarkup && editMode.textInputHelper.textMarkup !== this) {\n    return;\n  }\n\n  var style = cloneStyle(editMode.textInputHelper.style);\n  var text = editMode.textInputHelper.textArea.value;\n\n  var textHelperValues = editMode.textInputHelper.getTextValuesForMarkup(this, sizeUpdateRequired);\n\n  this.currentTextLines = textHelperValues.textValues.lines;\n\n  if (textHelperValues.newPos) {\n    var position = this.editor.positionFromClientToMarkups(textHelperValues.newPos.x, textHelperValues.newPos.y);\n    var size = this.editor.sizeFromClientToMarkups(textHelperValues.width, textHelperValues.height);\n\n    this.position.x = position.x;\n    this.position.y = position.y;\n    this.size.x = size.x;\n    this.size.y = size.y;\n  }\n\n  if (editMode.selectedMarkup !== this && !editMode.textInputHelper.firstEdit) {\n    editMode.textInputHelper.textArea.value = text;\n    editMode.textInputHelper.setStyle(style);\n  }\n\n  var markup = this.createSvgElement('text');\n  markup.setAttribute('id', 'markup');\n  markup.setAttribute('alignment-baseline', 'middle');\n\n  this.textShape.childNodes[0].removeChild(this.textShape.markup);\n  this.textShape.childNodes[0].appendChild(markup);\n  this.textShape.markup = markup;\n\n  // For each line, create a tspan, add as child and offset it vertically.\n  var yOffset = this.getLineHeight() * FONT_SIZE_SCALE * (this.lineHeight / 100);\n\n  var padding = this.getLineHeight() * FONT_SIZE_SCALE / 2;\n  var dx = padding;\n  var dy = padding;\n\n  this.currentTextLines.forEach(function (line) {\n\n    var tspan = this.createSvgElement('tspan');\n\n    tspan.setAttribute('x', dx);\n    tspan.setAttribute('y', dy);\n    tspan.textContent = line;\n\n    markup.appendChild(tspan);\n    dy += yOffset;\n  }.bind(this));\n};\n\nproto.setIsFilledFrameUsed = function (isFrameUsed) {\n\n  this.isFrameUsed = isFrameUsed;\n\n  var hasRectShape = this.rectShape.parentNode === this.shape;\n  if (isFrameUsed && !hasRectShape) {\n    this.shape.insertBefore(this.rectShape, this.shape.firstChild);\n  } else if (!isFrameUsed && hasRectShape) {\n    this.shape.removeChild(this.rectShape);\n  }\n};\n\nproto.setIsFilledFrameVisible = function (isVisible) {\n\n  this.rectShape.markup.style.display = isVisible && this.isFrameUsed ? 'block' : 'none';\n};\n\nproto.setIsShapeVisible = function (isVisible) {\n\n  this.shape.style.display = isVisible ? 'block' : 'none';\n};\n\nproto.setMetadata = function () {\n  var metadata = cloneStyle(this.style);\n\n  metadata.type = this.type;\n  metadata.position = [this.position.x, this.position.y].join(\" \");\n  metadata.size = [this.size.x, this.size.y].join(\" \");\n  metadata.text = String(this.currentText);\n  metadata.isframeused = this.isFrameUsed ? 1 : 0;\n\n  return this.addMarkupMetadata(this.shape, metadata);\n};\n\n/**\n    * Helper method that returns the font size in client space coords.\n    * @returns {Number}\n    */\nproto.getClientFontSize = function () {\n\n  return this.editor.sizeFromMarkupsToClient(0, this.style['font-size']).y;\n};\n\nproto.getLineHeight = function () {\n  return this.style['font-size'];\n};\n\nproto.getTextContainerTransform = function () {\n\n  var x = this.position.x - this.size.x * 0.5;\n  var y = this.position.y + this.size.y * 0.5;\n\n  return [\n  'translate(', x, ',', y, ')',\n  'rotate(', radiansToDegrees(-this.rotation), ')',\n  'scale(1,-1)'].\n  join(' ');\n};\n\nproto.getTextTransform = function () {\n\n  var lineHeight = this.getLineHeight();\n\n  var x = this.position.x - this.size.x * 0.5;\n  var y = this.position.y + this.size.y * 0.5 - lineHeight;\n\n  return [\n  'translate(', x, ',', y, ')',\n  'rotate(', radiansToDegrees(-this.rotation), ')',\n  'scale(' + 1 / FONT_SIZE_SCALE + ',' + -1 / FONT_SIZE_SCALE + ')'].\n  join(' ');\n};\n\nproto.cloneShape = function (clone) {\n\n  clone.textShape = createMarkupTextSvg();\n  clone.rectShape = createMarkupPathSvg();\n  clone.shape = createMarkupGroupSvg([clone.rectShape, clone.textShape]);\n  clone.bindDomEvents();\n};\n\nproto.getPath = function () {\n  var strokeWidth = this.style['stroke-width'];\n\n  var w = this.size.x + strokeWidth;\n  var h = this.size.y + strokeWidth;\n  var x = -w * 0.5;\n  var y = -h * 0.5;\n\n  var path = [];\n  createRectanglePath(x, y, w, h, false, path);\n\n  return path;\n};\n\nproto.getBoundingRect = function () {\n\n  var pos = this.getClientPosition();\n  var size = this.getClientSize();\n  var strokeWidth = this.style['stroke-width'];\n  var width = this.editor.sizeFromMarkupsToClient(strokeWidth, 0).x;\n  var margin = width + EDIT_FRAME_DEFAULT_MARGIN;\n\n  return {\n    x: pos.x - size.x / 2,\n    y: pos.y - size.y / 2,\n    width: size.x,\n    height: size.y,\n    margin: margin };\n\n};","'use strict';\n\nimport { Markup } from './Markup';\nimport * as MarkupTypes from './MarkupTypes';\nimport { createMarkupPathSvg, composeRGBAString, setAttributeToMarkupSvg,\nupdateMarkupPathSvgHitarea, addMarkupMetadata, createEllipsePath } from './MarkupsCoreUtils';\nimport { cloneStyle } from './StyleUtils';\nimport { EditModeCircle } from './edit-modes/EditModeCircle';\n\n/**\n                                                               *\n                                                               * @param id\n                                                               * @param editor\n                                                               * @constructor\n                                                               */\nexport function MarkupCircle(id, editor) {\n\n  var styleAttributes = ['stroke-width', 'stroke-color', 'stroke-opacity', 'fill-color', 'fill-opacity'];\n  Markup.call(this, id, editor, styleAttributes);\n\n  // bind to this to pass this.globalManager\n  this.addMarkupMetadata = addMarkupMetadata.bind(this);\n\n  this.type = MarkupTypes.MARKUP_TYPE_CIRCLE;\n  this.shape = createMarkupPathSvg();\n\n  this.bindDomEvents();\n}\n\nMarkupCircle.prototype = Object.create(Markup.prototype);\nMarkupCircle.prototype.constructor = MarkupCircle;\n\nvar proto = MarkupCircle.prototype;\n\nproto.getEditMode = function () {\n\n  return new EditModeCircle(this.editor);\n};\n\nproto.set = function (position, size) {\n\n  this.setSize(position, size.x, size.y);\n};\n\n/**\n    * Applies data values into DOM element style/attribute(s)\n    *\n    */\nproto.updateStyle = function () {\n\n  var style = this.style;\n  var shape = this.shape;\n  var path = this.getPath().join(' ');\n\n  var strokeWidth = this.style['stroke-width'];\n  var strokeColor = this.highlighted ? this.highlightColor : composeRGBAString(style['stroke-color'], style['stroke-opacity']);\n  var fillColor = composeRGBAString(style['fill-color'], style['fill-opacity']);\n  var transform = this.getTransform();\n\n  setAttributeToMarkupSvg(shape, 'd', path);\n  setAttributeToMarkupSvg(shape, 'stroke-width', strokeWidth);\n  setAttributeToMarkupSvg(shape, 'stroke', strokeColor);\n  setAttributeToMarkupSvg(shape, 'fill', fillColor);\n  setAttributeToMarkupSvg(shape, 'transform', transform);\n  updateMarkupPathSvgHitarea(shape, this.editor);\n};\n\nproto.setMetadata = function () {\n\n  var metadata = cloneStyle(this.style);\n\n  metadata.type = this.type;\n  metadata.position = [this.position.x, this.position.y].join(\" \");\n  metadata.size = [this.size.x, this.size.y].join(\" \");\n  metadata.rotation = String(this.rotation);\n\n  return this.addMarkupMetadata(this.shape, metadata);\n};\n\nproto.getPath = function () {\n\n  var size = this.size;\n  if (size.x === 1 || size.y === 1) {\n    return [''];\n  }\n\n  var strokeWidth = this.style['stroke-width'];\n\n  var ellipseW = size.x - strokeWidth;\n  var ellipseH = size.y - strokeWidth;\n\n  var ellipseX = -0.5 * ellipseW;\n  var ellipseY = 0;\n\n  var path = [];\n  createEllipsePath(ellipseX, ellipseY, ellipseW, ellipseH, false, path);\n\n  return path;\n};","'use strict';\n\nimport { Markup } from './Markup';\nimport * as MarkupTypes from './MarkupTypes';\nimport { createMarkupPathSvg, composeRGBAString, setAttributeToMarkupSvg,\nupdateMarkupPathSvgHitarea, addMarkupMetadata, createEllipsePath } from './MarkupsCoreUtils';\nimport { cloneStyle } from './StyleUtils';\nimport { EditModeCloud } from './edit-modes/EditModeCloud';\n\n/**\n                                                             *\n                                                             * @param id\n                                                             * @param editor\n                                                             * @constructor\n                                                             */\nexport function MarkupCloud(id, editor) {\n\n  var styleAttributes = ['stroke-width', 'stroke-linejoin', 'stroke-color', 'stroke-opacity', 'fill-color', 'fill-opacity'];\n  Markup.call(this, id, editor, styleAttributes);\n\n  // bind to this to pass this.globalManager\n  this.addMarkupMetadata = addMarkupMetadata.bind(this);\n\n  this.type = MarkupTypes.MARKUP_TYPE_CLOUD;\n  this.shape = createMarkupPathSvg();\n\n  this.bindDomEvents();\n}\n\nMarkupCloud.prototype = Object.create(Markup.prototype);\nMarkupCloud.prototype.constructor = MarkupCloud;\n\nvar proto = MarkupCloud.prototype;\n\nproto.getEditMode = function () {\n\n  return new EditModeCloud(this.editor);\n};\n\n/**\n    * Sets position and size in markup space coordinates.\n    * @param {Object} position\n    * @param {Object} size\n    */\nproto.set = function (position, size) {\n\n  this.setSize(position, size.x, size.y);\n};\n\n/**\n    * Applies data values into DOM element style/attribute(s)\n    *\n    */\nproto.updateStyle = function () {\n\n  var style = this.style;\n  var shape = this.shape;\n  var path = this.getPath().join(' ');\n\n  var strokeWidth = this.style['stroke-width'];\n  var strokeColor = this.highlighted ? this.highlightColor : composeRGBAString(style['stroke-color'], style['stroke-opacity']);\n  var fillColor = composeRGBAString(style['fill-color'], style['fill-opacity']);\n  var transform = this.getTransform();\n\n  setAttributeToMarkupSvg(shape, 'd', path);\n  setAttributeToMarkupSvg(shape, 'stroke-width', strokeWidth);\n  setAttributeToMarkupSvg(shape, 'stroke', strokeColor);\n  setAttributeToMarkupSvg(shape, 'fill', fillColor);\n  setAttributeToMarkupSvg(shape, 'transform', transform);\n  updateMarkupPathSvgHitarea(shape, this.editor);\n};\n\nproto.setMetadata = function () {\n\n  var metadata = cloneStyle(this.style);\n\n  metadata.type = this.type;\n  metadata.position = [this.position.x, this.position.y].join(\" \");\n  metadata.size = [this.size.x, this.size.y].join(\" \");\n  metadata.rotation = String(this.rotation);\n\n  return this.addMarkupMetadata(this.shape, metadata);\n};\n\n/**\n    * Helper function that creates intermediate points given the\n    * current position and size.\n    * @returns {Array}\n    */\nproto.getPath = function () {\n\n  var position = this.position;\n  var size = this.size;\n  var strokeWidth = this.style['stroke-width'];\n  var radius = strokeWidth * 2;\n\n  function createArcTo(x, y, xRadius, yRadius, path) {\n\n    path.push('a');\n    path.push(xRadius);\n    path.push(yRadius);\n    path.push(0);\n    path.push(1);\n    path.push(1);\n    path.push(x);\n    path.push(y);\n\n    return path;\n  }\n\n  function createCorner(corner, xRadius, yRadius, strokeWidth, path) {\n\n    switch (corner) {\n\n      case 'LT':\n        return createArcTo(xRadius, -yRadius, xRadius, yRadius, path);\n        break;\n\n      case 'RT':\n        return createArcTo(xRadius, yRadius, xRadius, yRadius, path);\n        break;\n\n      case 'RB':\n        return createArcTo(-xRadius, yRadius, xRadius, yRadius, path);\n        break;\n\n      case 'LB':\n        return createArcTo(-xRadius, -yRadius, xRadius, yRadius, path);\n        break;}\n\n  }\n\n  function getSideParameters(x1, x2, radius, strokeWidth) {\n\n    var diameter = radius * 2;\n    var length = Math.abs(x2 - x1 - strokeWidth);\n    var count = Math.round(length / diameter);\n\n    diameter += (length - diameter * count) / count;\n    radius = diameter * 0.5;\n\n    var xValueInset = diameter * 0.05;\n    var yValueOffset = radius * 3.5 / 3.0;\n\n    return {\n      count: count,\n      radius: radius,\n      diameter: diameter,\n      p1: { x: xValueInset, y: -yValueOffset },\n      p2: { x: diameter - xValueInset, y: -yValueOffset },\n      p3: { x: diameter, y: 0 } };\n\n  }\n\n  function createTSide(hSidesParameters, path) {\n\n    var sp = hSidesParameters;\n    for (var i = 0; i < sp.count; ++i) {\n\n      path.push('c');\n      path.push(sp.p1.x);\n      path.push(sp.p1.y);\n      path.push(sp.p2.x);\n      path.push(sp.p2.y);\n      path.push(sp.p3.x);\n      path.push(sp.p3.y);\n    }\n\n    return path;\n  }\n\n  function createRSide(vSidesParameters, path) {\n\n    var sp = vSidesParameters;\n    for (var i = 0; i < sp.count; ++i) {\n      path.push('c');\n      path.push(-sp.p1.y);\n      path.push(sp.p1.x);\n      path.push(-sp.p2.y);\n      path.push(sp.p2.x);\n      path.push(-sp.p3.y);\n      path.push(sp.p3.x);\n    }\n\n    return path;\n  }\n\n  function createBSide(hSidesParameters, path) {\n\n    var sp = hSidesParameters;\n    for (var i = 0; i < sp.count; ++i) {\n      path.push('c');\n      path.push(-sp.p1.x);\n      path.push(-sp.p1.y);\n      path.push(-sp.p2.x);\n      path.push(-sp.p2.y);\n      path.push(-sp.p3.x);\n      path.push(-sp.p3.y);\n    }\n\n    return path;\n  }\n\n  function createLSide(vSidesParameters, path) {\n\n    var sp = vSidesParameters;\n    for (var i = 0; i < sp.count; ++i) {\n      path.push('c');\n      path.push(sp.p1.y);\n      path.push(-sp.p1.x);\n      path.push(sp.p2.y);\n      path.push(-sp.p2.x);\n      path.push(sp.p3.y);\n      path.push(-sp.p3.x);\n    }\n\n    return path;\n  }\n\n  var l = position.x;\n  var t = position.y;\n  var r = position.x + size.x;\n  var b = position.y + size.y;\n\n  var minSize = radius * 5;\n  var path = [];\n\n  if (size.x < minSize || size.y < minSize) {\n\n    var w = size.x - strokeWidth;\n    var h = size.y - strokeWidth;\n    var x = -w * 0.5;\n    var y = 0;\n\n    createEllipsePath(x, y, w, h, false, path);\n  } else {\n\n    var hSidesParameters = getSideParameters(l, r, radius, strokeWidth);\n    var vSidesParameters = getSideParameters(t, b, radius, strokeWidth);\n\n    var cornerSizeX = hSidesParameters.diameter;\n    var cornerSizeY = vSidesParameters.diameter;\n    var cornerRadiusX = hSidesParameters.radius;\n    var cornerRadiusY = vSidesParameters.radius;\n\n    hSidesParameters = getSideParameters(l + cornerSizeX, r - cornerSizeX, radius, strokeWidth);\n    vSidesParameters = getSideParameters(t + cornerSizeY, b - cornerSizeY, radius, strokeWidth);\n\n    var halfStrokeWidth = strokeWidth * 0.5;\n    var x = -size.x * 0.5 + halfStrokeWidth + cornerRadiusX;\n    var y = -size.y * 0.5 + halfStrokeWidth + cornerRadiusY * 2;\n\n    path.push('M');\n    path.push(x);\n    path.push(y);\n\n    createCorner('LT', cornerRadiusX, cornerRadiusY, strokeWidth, path);\n    createTSide(hSidesParameters, path);\n    createCorner('RT', cornerRadiusX, cornerRadiusY, strokeWidth, path);\n    createRSide(vSidesParameters, path);\n    createCorner('RB', cornerRadiusX, cornerRadiusY, strokeWidth, path);\n    createBSide(hSidesParameters, path);\n    createCorner('LB', cornerRadiusX, cornerRadiusY, strokeWidth, path);\n    createLSide(vSidesParameters, path);\n  }\n\n  path.push('z');\n  return path;\n};","'use strict';\n\nimport { Markup } from './Markup';\nimport * as MarkupTypes from './MarkupTypes';\nimport { createMarkupPathSvg, createMarkupTextSvg, composeRGBAString, addMarkupMetadata,\nradiansToDegrees, degreesToRadians, measureTextLines, setMarkupTextSvgTransform,\nsetAttributeToMarkupSvg, updateMarkupPathSvgHitarea, createSvgElement, checkLineSegment,\nupdateMarkupTextSvgBackground, updateMarkupTextSvgClipper, updateMarkupTextSvgHitarea } from\n'./MarkupsCoreUtils';\nimport { cloneStyle } from './StyleUtils';\nimport { EditModeDimension } from './edit-modes/EditModeDimension';\n\nvar DIMENSION_MARKUP_HEIGHT = 10;\nvar TEXT_OFFSET = 2;\nvar DEFAULT_TEXT = 'Add Length';\nvar BACKGROUND_COLOR = 'none'; //'#ffffff';\n\n/**\n *\n * @param id\n * @param editor\n * @constructor\n */\nexport function MarkupDimension(id, editor) {\n\n  var styleAttributes = ['stroke-width', 'stroke-color', 'stroke-opacity', 'font-size', 'font-family', 'font-style', 'font-weight'];\n  Markup.call(this, id, editor, styleAttributes);\n\n  this.type = MarkupTypes.MARKUP_TYPE_DIMENSION;\n  this.constraintHeight = true;\n  this.constraintWidth = true;\n\n  // bind to this to pass this.globalManager\n  this.addMarkupMetadata = addMarkupMetadata.bind(this);\n  this.createSvgElement = createSvgElement.bind(this);\n  this.checkLineSegment = checkLineSegment.bind(this);\n  this.measureTextLines = measureTextLines.bind(this);\n\n\n  this.firstAnchor = new THREE.Vector3();\n  this.secondAnchor = new THREE.Vector3();\n  this.shape = createMarkupPathSvg();\n  this.text = createMarkupTextSvg();\n  this.shape.appendChild(this.text);\n  this.textSize = { x: 0, y: 0 };\n  this.initialText = DEFAULT_TEXT;\n  this.currentText = ' ';\n\n  if (!this.viewer.model.is2d()) {\n    this.preventReposition = true;\n    this.constraintRotation = true;\n  }\n\n  this.bindDomEvents();\n}\n\nMarkupDimension.prototype = Object.create(Markup.prototype);\nMarkupDimension.prototype.constructor = MarkupDimension;\n\nvar proto = MarkupDimension.prototype;\n\nproto.getEditMode = function () {\n\n  return new EditModeDimension(this.editor);\n};\n\n/**\n    * Sets top-left and bottom-right values in client space coordinates (2d).\n    * Notice that for the Dimension, the top left is the \"secondAnchor\" of the Dimension and\n    * the bottom right is the \"firstAnchor\" of it.\n    *\n    * @param {Number} xO - secondAnchor\n    * @param {Number} yO - secondAnchor\n    * @param {Number} xF - firstAnchor\n    * @param {Number} yF - firstAnchor\n    */\nproto.set = function (xO, yO, xF, yF, text) {\n\n  var vO = new THREE.Vector2(xO, yO);\n  var vF = new THREE.Vector2(xF, yF);\n  var vDir = vF.clone().sub(vO).normalize();\n\n  this.size.x = vO.distanceTo(vF); // TODO: Clamp min length\n  this.rotation = Math.acos(vDir.dot(new THREE.Vector2(1, 0)));\n  this.rotation = yF > yO ? Math.PI * 2 - this.rotation : this.rotation;\n\n  var firstAnchor = this.firstAnchor;\n  var secondAnchor = this.secondAnchor;\n\n  firstAnchor.set(xF, yF, 0);\n  secondAnchor.set(xO, yO, 0);\n\n  this.position.x = secondAnchor.x + (firstAnchor.x - secondAnchor.x) * 0.5;\n  this.position.y = secondAnchor.y + (firstAnchor.y - secondAnchor.y) * 0.5;\n\n  this.currentText = text;\n  this.updateStyle();\n};\n\n/**\n    * Changes the rotation of the markup to the given angle.\n    * This gets called by the Autodesk.Viewing.Extensions.Markups.Core.SetRotation edit action\n    *\n    * @param {Number} angle\n    */\nproto.setRotation = function (angle) {\n\n  if (radiansToDegrees(angle) === 90) {\n    angle = degreesToRadians(-90);\n  }\n\n  this.rotation = angle;\n\n  var xF = Math.cos(-angle);\n  var yF = Math.sin(-angle);\n  var vFDir = new THREE.Vector2(xF, yF); // already normalized\n  vFDir.multiplyScalar(this.size.x * 0.5);\n\n  var vCenter = new THREE.Vector2(this.position.x, this.position.y);\n  var vO = vCenter.clone().sub(vFDir);\n  var vF = vCenter.clone().add(vFDir);\n\n  this.firstAnchor.set(vF.x, vF.y, 0);\n  this.secondAnchor.set(vO.x, vO.y, 0);\n\n  this.updateStyle();\n};\n\n/**\n    * Changes the position and size of the markup.\n    * This gets called by the namespace.SetSize edit action\n    * @param {{x: Number, y: Number}} position - Dimension's center\n    * @param {Number} width - Dimension's length\n    * @param {Number} height - We ignore this one because we use the Dimension's stroke width instead\n    */\nproto.setSize = function (position, width, height) {\n\n  var xF = Math.cos(-this.rotation);\n  var yF = Math.sin(-this.rotation);\n  var vFDir = new THREE.Vector2(xF, yF); // already normalized\n  vFDir.multiplyScalar(width * 0.5);\n\n  var vCenter = new THREE.Vector2(position.x, position.y);\n  var vO = vCenter.clone().sub(vFDir);\n  var vF = vCenter.clone().add(vFDir);\n\n  this.firstAnchor.set(vF.x, vF.y, 0);\n  this.secondAnchor.set(vO.x, vO.y, 0);\n\n  this.position.x = position.x;\n  this.position.y = position.y;\n  this.size.x = width;\n\n  this.updateStyle();\n};\n\n/**\n    * Helper method that returns the font size in client space coords.\n    * @returns {Number}\n    */\nproto.getClientFontSize = function () {\n\n  return this.editor.sizeFromMarkupsToClient(0, this.style['font-size']).y;\n};\n\nproto.updateStyle = function () {\n\n  var style = this.style;\n  var shape = this.shape;\n  var strokeWidth = style['stroke-width'];\n  var strokeColor = this.highlighted ? this.highlightColor : composeRGBAString(style['stroke-color'], style['stroke-opacity']);\n  var transform = this.getTransform();\n\n  this.rebuildTextSvg(this.currentText);\n\n  setAttributeToMarkupSvg(shape, 'd', this.getPath().join(' '));\n  setAttributeToMarkupSvg(shape, 'stroke-width', strokeWidth / 2);\n  setAttributeToMarkupSvg(shape, 'stroke', strokeColor);\n  setAttributeToMarkupSvg(shape, 'fill', strokeColor);\n  setAttributeToMarkupSvg(shape, 'transform', transform);\n  updateMarkupPathSvgHitarea(shape, this.editor);\n};\n\nproto.rebuildTextSvg = function (value) {\n  var style = this.style;\n  var strokeColor = this.highlighted ? this.highlightColor : composeRGBAString(style['stroke-color'], style['stroke-opacity']);\n  var strokeWidth = style['stroke-width'];\n  var backgroundColor = value === ' ' ? 'none' : BACKGROUND_COLOR;\n\n  var markup = this.createSvgElement('text');\n  markup.setAttribute('id', 'markup');\n  markup.setAttribute('alignment-baseline', 'middle');\n\n  var text = this.text;\n  var editor = this.editor;\n\n  text.childNodes[0].removeChild(text.markup);\n  text.childNodes[0].appendChild(markup);\n  text.markup = markup;\n\n  var tspan = this.createSvgElement('tspan');\n  tspan.textContent = value;\n  markup.appendChild(tspan);\n\n  var lineSize = this.measureTextLines([value], style, editor)[0]; // Only one line for measurement\n  var textSize = this.textSize = editor.sizeFromClientToMarkups(lineSize.width, lineSize.height);\n\n  var edgeH = DIMENSION_MARKUP_HEIGHT * strokeWidth / 2;\n  var textOffset = TEXT_OFFSET * strokeWidth / 2;\n  var offset = textSize.x + 2 * strokeWidth >= this.size.x ? textOffset + edgeH / 2 : textOffset; // If the line is too short for the given text, put it under.\n\n  this.size.y = edgeH + textSize.y + offset;\n\n  var textTransform = this.getTextTransform(4 / 5 * textSize.y + offset, true); // Text height is Always 4/5 of the entire label height.\n  var backgroundTransform = this.getTextTransform(textSize.y + offset, false);\n\n  setAttributeToMarkupSvg(text, 'font-family', style['font-family']);\n  setAttributeToMarkupSvg(text, 'font-size', style['font-size']);\n  setAttributeToMarkupSvg(text, 'font-weight', style['font-weight']);\n  setAttributeToMarkupSvg(text, 'font-style', style['font-style']);\n  setAttributeToMarkupSvg(text, 'text-rendering', 'auto');\n  setAttributeToMarkupSvg(text, 'fill', strokeColor);\n  setMarkupTextSvgTransform(text, backgroundTransform, textTransform);\n  updateMarkupTextSvgBackground(text, textSize.x, textSize.y, backgroundColor);\n  updateMarkupTextSvgClipper(text, textSize.x, textSize.y);\n  updateMarkupTextSvgHitarea(text, textSize.x, textSize.y, editor);\n};\n\nproto.shouldFlip = function () {\n  return this.firstAnchor.x < this.secondAnchor.x;\n};\n\nproto.getTextTransform = function (offset, inverse) {\n\n  var flip = this.shouldFlip() ? -1 : 1;\n\n  inverse = inverse ? -1 : 1;\n\n  if (radiansToDegrees(this.rotation) === 90) {\n    this.rotation = degreesToRadians(-90);\n  }\n\n  return [\n  'translate(', this.position.x, ',', this.position.y, ')',\n  'rotate(', radiansToDegrees(-this.rotation), ')',\n  'translate(', -flip * this.textSize.x / 2, ',', -flip * offset, ')',\n  'scale(' + flip + ',' + flip * inverse + ')'].\n  join(' ');\n};\n\n/**\n    * Used by the EditFrame to move the markup in Client Space coordinates\n    * @param {Number} x - New X location for the markup. Notice that markups are centered on this value.\n    * @param {Number} y - New Y location for the markup. Notice that markups are centered on this value.\n    */\nproto.setPosition = function (x, y) {\n\n  var firstAnchor = this.firstAnchor;\n  var secondAnchor = this.secondAnchor;\n\n  var dx = firstAnchor.x - secondAnchor.x;\n  var dy = firstAnchor.y - secondAnchor.y;\n\n  var xo = x + dx * 0.5;\n  var yo = y + dy * 0.5;\n\n  firstAnchor.x = xo;\n  firstAnchor.y = yo;\n\n  secondAnchor.x = xo - dx;\n  secondAnchor.y = yo - dy;\n\n  this.position.x = secondAnchor.x + (firstAnchor.x - secondAnchor.x) * 0.5;\n  this.position.y = secondAnchor.y + (firstAnchor.y - secondAnchor.y) * 0.5;\n\n  this.updateStyle();\n};\n\nproto.generatePoint3d = function (idTarget) {\n\n  var firstAnchor = this.editor.positionFromMarkupsToClient(this.firstAnchor.x, this.firstAnchor.y);\n  var secondAnchor = this.editor.positionFromMarkupsToClient(this.secondAnchor.x, this.secondAnchor.y);\n\n  var direction = firstAnchor.clone().sub(secondAnchor).normalize();\n\n  var point2d = this.checkLineSegment(firstAnchor.x, firstAnchor.y, firstAnchor.x + direction.x * 200, firstAnchor.y + direction.y * 200, idTarget);\n  var point3d = point2d && this.viewer.clientToWorld(point2d.x, point2d.y);\n\n  return point3d && point3d.point;\n};\n\nproto.setMetadata = function () {\n\n  this.text.setAttribute('pointer-events', 'none');\n\n  var metadata = cloneStyle(this.style);\n\n  metadata.type = this.type;\n  metadata.firstAnchor = [this.firstAnchor.x, this.firstAnchor.y].join(\" \");\n  metadata.secondAnchor = [this.secondAnchor.x, this.secondAnchor.y].join(\" \");\n  metadata.text = String(this.currentText);\n\n  return this.addMarkupMetadata(this.shape, metadata);\n};\n\n\n/**\n    * Returns the raw string value\n    * @returns {String}\n    */\nproto.getText = function () {\n\n  // if the current text is 'Add Length', you want the textbox will be empty when the user open it.\n  return this.currentText === this.initialText ? '' : this.currentText;\n};\n\nproto.getPath = function () {\n\n  //   1_                            _4\n  //   | |                          | |\n  //   | |2                        3| |\n  //  0|  --------------------------  |\n  //   |  --------------------------  |\n  //   | |7                       6 | |\n  //   |_|          TEXT            |_|\n  //   8                             5\n\n  var strokeWidth = this.style['stroke-width'];\n  var segmentLength = this.size.x - strokeWidth / 2; // segment length (p2 to p3 length)\n  var edgeH = DIMENSION_MARKUP_HEIGHT * strokeWidth / 2; // Edge height (p1 to p8 length)\n\n  return [\n  'M', -segmentLength * 0.5, 0, // 0\n  'l', 0, edgeH / 2, // 1\n  'l', 0, -edgeH / 2, // 2\n  'l', segmentLength, 0, // 3\n  'l', 0, edgeH / 2, // 4\n  'l', 0, -edgeH, // 5\n  'l', 0, edgeH / 2, // 6\n  'l', -segmentLength, 0, // 7\n  'l', 0, -edgeH / 2, // 8\n  'z'];\n\n};\n\nproto.cloneShape = function (clone) {\n\n  clone.shape = createMarkupPathSvg();\n  clone.text = createMarkupTextSvg();\n  clone.shape.appendChild(clone.text);\n  clone.bindDomEvents();\n};\n\nproto.getBoundingRect = function () {\n  var pos = this.getClientPosition();\n  var size = this.getClientSize();\n  return {\n    x: pos.x - size.x / 2,\n    y: pos.y - size.y / 2,\n    width: size.x,\n    height: size.y };\n\n};","'use strict';\n\n/**\n               * Fired whenever the drawing tool changes. For example, when the Arrow drawing\n               * tool changes into the Rectangle drawing tool.\n               * See {@link Autodesk.Viewing.Extensions.Markups.Core.MarkupsCore/#changeEditMode|MarkupsCore.changeEditMode()}\n               * for a list of all supported drawing tools (EditModes).\n               * \n               * @event Autodesk.Viewing.Extensions.Markups.Core.MarkupsCore#EVENT_EDITMODE_CHANGED\n               * @type {string}\n               */\nexport var EVENT_EDITMODE_CHANGED = \"EVENT_EDITMODE_CHANGED\";\n\n/**\n                                                               * Fired when Edit mode has been enabled, which allows the end user to start\n                                                               * drawing markups over the Viewer canvas.\n                                                               * See also {@link Autodesk.Viewing.Extensions.Markups.Core.MarkupsCore/#enterEditMode|MarkupsCore.enterEditMode()}.\n                                                               * \n                                                               * @event Autodesk.Viewing.Extensions.Markups.Core.MarkupsCore#EVENT_EDITMODE_ENTER\n                                                               * @type {string}\n                                                               */\nexport var EVENT_EDITMODE_ENTER = \"EVENT_EDITMODE_ENTER\";\n\n/**\n                                                           * Fired when Edit mode has been disabled, preventing the end user from\n                                                           * drawing markups over the Viewer canvas.\n                                                           * See also {@link Autodesk.Viewing.Extensions.Markups.Core.MarkupsCore/#leaveEditMode|MarkupsCore.leaveEditMode()}.\n                                                           * \n                                                           * @event Autodesk.Viewing.Extensions.Markups.Core.MarkupsCore#EVENT_EDITMODE_LEAVE\n                                                           * @type {string}\n                                                           */\nexport var EVENT_EDITMODE_LEAVE = \"EVENT_EDITMODE_LEAVE\";\n\n/**\n                                                           * Fired when a drawn markup has been selected by the end user with a click command.\n                                                           * \n                                                           * @event Autodesk.Viewing.Extensions.Markups.Core.MarkupsCore#EVENT_MARKUP_SELECTED\n                                                           * @type {string}\n                                                           */\nexport var EVENT_MARKUP_SELECTED = \"EVENT_MARKUP_SELECTED\";\n\n/**\n                                                             * Fired when a drawn markup is being dragged over the Viewer canvas.\n                                                             * \n                                                             * @event Autodesk.Viewing.Extensions.Markups.Core.MarkupsCore#EVENT_MARKUP_DRAGGING\n                                                             * @type {string}\n                                                             */\nexport var EVENT_MARKUP_DRAGGING = \"EVENT_MARKUP_DRAGGING\";\n\n/**\n                                                             * Internal usage only.\n                                                             * \n                                                             * @event Autodesk.Viewing.Extensions.Markups.Core.MarkupsCore#EVENT_MARKUP_ENTER_EDITION\n                                                             * @type {string}\n                                                             * @private\n                                                             */\nexport var EVENT_MARKUP_ENTER_EDITION = \"EVENT_MARKUP_ENTER_EDITION\";\n\n/**\n                                                                       * Internal usage only.\n                                                                       * \n                                                                       * @event Autodesk.Viewing.Extensions.Markups.Core.MarkupsCore#EVENT_MARKUP_CANCEL_EDITION\n                                                                       * @type {string}\n                                                                       * @private\n                                                                       */\nexport var EVENT_MARKUP_CANCEL_EDITION = \"EVENT_MARKUP_CANCEL_EDITION\";\n\n/**\n                                                                         * Internal usage only.\n                                                                         * \n                                                                         * @event Autodesk.Viewing.Extensions.Markups.Core.MarkupsCore#EVENT_MARKUP_DELETE_EDITION\n                                                                         * @type {string}\n                                                                         * @private\n                                                                         */\nexport var EVENT_MARKUP_DELETE_EDITION = \"EVENT_MARKUP_DELETE_EDITION\";\n\n\n/**\n                                                                         * Fired whenever a new undo or redo action is available.\n                                                                         */\nexport var EVENT_HISTORY_CHANGED = \"EVENT_HISTORY_CHANGED\";\n\n/**\n                                                             * Fired when a markup creation begins. \n                                                             * For example, as soon as the user starts dragging with the mouse\n                                                             * to draw an arrow on the screen.\n                                                             */\nexport var EVENT_EDITMODE_CREATION_BEGIN = \"EVENT_EDITMODE_CREATION_BEGIN\";\n\n/**\n                                                                             * Fired when a markup has been created.\n                                                                             * For example, as soon as the user stops dragging and releases the\n                                                                             * mouse button to finish drawing an arrow on the screen\n                                                                             */\nexport var EVENT_EDITMODE_CREATION_END = \"EVENT_EDITMODE_CREATION_END\";\n\n/**\n                                                                         * Fired when a markup is no longer selected.\n                                                                         */\nexport var EVENT_MARKUP_DESELECT = \"EVENT_MARKUP_DESELECT\";\n\n/**\n                                                             * The selected markup is being modified\n                                                             */\nexport var EVENT_EDITFRAME_EDITION_START = \"EVENT_EDITFRAME_EDITION_START\";\n\n/**\n                                                                             * The selected markup is no longer being modified\n                                                                             */\nexport var EVENT_EDITFRAME_EDITION_END = \"EVENT_EDITFRAME_EDITION_END\";","'use strict';\n\nimport { MarkupPen } from './MarkupPen';\nimport * as MarkupTypes from './MarkupTypes';\nimport { EditModeFreehand } from './edit-modes/EditModeFreehand';\n\n\n/**\n                                                                   *\n                                                                   * @param id\n                                                                   * @param editor\n                                                                   * @constructor\n                                                                   */\nexport function MarkupFreehand(id, editor) {\n\n  MarkupPen.call(this, id, editor);\n  this.type = MarkupTypes.MARKUP_TYPE_FREEHAND;\n}\n\nMarkupFreehand.prototype = Object.create(MarkupPen.prototype);\nMarkupFreehand.prototype.constructor = MarkupFreehand;\n\nvar proto = MarkupFreehand.prototype;\n\nproto.getEditMode = function () {\n\n  return new EditModeFreehand(this.editor);\n};","'use strict';\n\nimport { MarkupPen } from './MarkupPen';\nimport * as MarkupTypes from './MarkupTypes';\nimport { EditModeHighlight } from './edit-modes/EditModeHighlight';\n\n/**\n                                                                     *\n                                                                     * @param id\n                                                                     * @param editor\n                                                                     * @constructor\n                                                                     */\nexport function MarkupHighlight(id, editor) {\n\n  MarkupPen.call(this, id, editor);\n  this.type = MarkupTypes.MARKUP_TYPE_HIGHLIGHT;\n}\n\nMarkupHighlight.prototype = Object.create(MarkupPen.prototype);\nMarkupHighlight.prototype.constructor = MarkupHighlight;\n\nvar proto = MarkupHighlight.prototype;\n\nproto.getEditMode = function () {\n\n  return new EditModeHighlight(this.editor);\n};","'use strict';\n\nimport { Markup } from './Markup';\nimport { createMarkupPathSvg, setAttributeToMarkupSvg, updateMarkupPathSvgHitarea,\ncomposeRGBAString, addMarkupMetadata } from './MarkupsCoreUtils';\nimport { cloneStyle } from './StyleUtils';\n\n/**\n                                            * Base class for Pen Markup rendering (currently freehand and highlighter)\n                                            *\n                                            * Derived classes must implement getEditMode()\n                                            * @param id\n                                            * @param editor\n                                            * @constructor\n                                            */\nexport function MarkupPen(id, editor) {\n\n  var styleAttributes = ['stroke-width', 'stroke-color', 'stroke-opacity'];\n  Markup.call(this, id, editor, styleAttributes);\n\n  // bind to this to pass this.globalManager\n  this.addMarkupMetadata = addMarkupMetadata.bind(this);\n\n  this.shape = createMarkupPathSvg();\n\n  this.bindDomEvents();\n}\n\nMarkupPen.prototype = Object.create(Markup.prototype);\nMarkupPen.prototype.constructor = MarkupPen;\n\nvar proto = MarkupPen.prototype;\n\n/**\n                                  * Sets top-left and bottom-right values in client space coordinates (2d).\n                                  *\n                                  * @param position\n                                  * @param size\n                                  * @param locations\n                                  */\nproto.set = function (position, size, locations, isAbsoluteCoords) {\n\n  this.rotation = 0; // Reset angle //\n  this.isAbsoluteCoords = isAbsoluteCoords;\n  if (this.isAbsoluteCoords) {\n    this.updatePath(locations);\n  } else {\n    this.locations = locations.slice(0);\n\n    this.size.x = size.x === 0 ? 1 : size.x;\n    this.size.y = size.y === 0 ? 1 : size.y;\n\n    this.setSize(position, size.x, size.y);\n    this.updateStyle();\n  }\n};\n\nproto.setPosition = function (x, y) {\n\n  this.position.x = x;\n  this.position.y = y;\n\n  var shape = this.shape;\n  var transform = this.getTransform();\n\n  setAttributeToMarkupSvg(shape, 'transform', transform);\n  updateMarkupPathSvgHitarea(shape, this.editor);\n};\n\n/**\n    * Applies data values into DOM element style/attribute(s)\n    *\n    */\nproto.updateStyle = function () {\n\n  var style = this.style;\n  var shape = this.shape;\n  var path = this.getPath().join(' ');\n\n  var strokeWidth = this.style['stroke-width'];\n  var strokeColor = this.highlighted ? this.highlightColor : composeRGBAString(style['stroke-color'], style['stroke-opacity']);\n  var fillColor = 'none';\n\n  setAttributeToMarkupSvg(shape, 'stroke-width', strokeWidth);\n  setAttributeToMarkupSvg(shape, 'stroke-linejoin', 'round');\n  setAttributeToMarkupSvg(shape, 'stroke-linecap', 'round');\n  setAttributeToMarkupSvg(shape, 'stroke', strokeColor);\n  setAttributeToMarkupSvg(shape, 'fill', fillColor);\n\n  this.updatePath(path);\n  updateMarkupPathSvgHitarea(shape, this.editor);\n};\n\nproto.updatePath = function (path) {\n  var shape = this.shape;\n  var transform = this.isAbsoluteCoords ? 'scale(1)' : this.getTransform();\n\n  setAttributeToMarkupSvg(shape, 'transform', transform);\n  setAttributeToMarkupSvg(shape, 'd', path);\n};\n\n/**\n    * Changes the position and size of the markup.\n    * This gets called by the Autodesk.Viewing.Extensions.Markups.Core.SetSize edit action\n    * @param {{x: Number, y: Number}} position\n    * @param {Number} width\n    * @param {Number} height\n    */\nproto.setSize = function (position, width, height) {\n\n  width = width === 0 ? 1 : width;\n  height = height === 0 ? 1 : height;\n\n  var locations = this.locations;\n  var locationsCount = locations.length;\n\n  var scaleX = width / this.size.x;\n  var scaleY = height / this.size.y;\n\n  for (var i = 0; i < locationsCount; ++i) {\n\n    var point = locations[i];\n\n    point.x *= scaleX;\n    point.y *= scaleY;\n  }\n\n  this.position.x = position.x;\n  this.position.y = position.y;\n\n  this.size.x = width;\n  this.size.y = height;\n\n  this.updateStyle();\n};\n\nproto.setMetadata = function () {\n\n  var metadata = cloneStyle(this.style);\n\n  metadata.type = this.type;\n  metadata.position = [this.position.x, this.position.y].join(\" \");\n  metadata.size = [this.size.x, this.size.y].join(\" \");\n  metadata.rotation = String(this.rotation);\n  metadata.locations = this.locations.map(function (point) {\n    return [point.x, point.y].join(\" \");\n  }).join(\" \");\n\n  return this.addMarkupMetadata(this.shape, metadata);\n};\n\nproto.getPath = function () {\n\n  var path = [];\n  var locations = this.locations;\n  var locationsCount = locations.length;\n\n  if (locationsCount > 1) {\n\n    path.push('M');\n    path.push(+locations[0].x.toFixed(6));\n    path.push(+locations[0].y.toFixed(6));\n\n    for (var i = 1; i < locationsCount; ++i) {\n\n      var locationA = locations[i - 1];\n      var locationB = locations[i];\n\n      path.push('l');\n      path.push(+(locationB.x - locationA.x).toFixed(6));\n      path.push(+(locationB.y - locationA.y).toFixed(6));\n    }\n  }\n\n  return path;\n};","'use strict';\n\nimport { Markup } from './Markup';\nimport * as MarkupTypes from './MarkupTypes';\nimport { createMarkupPathSvg, composeRGBAString,\nsetAttributeToMarkupSvg, updateMarkupPathSvgHitarea, addMarkupMetadata } from './MarkupsCoreUtils';\nimport { cloneStyle } from './StyleUtils';\nimport { EditModePolyline } from './edit-modes/EditModePolyline';\n\n/**\n                                                                   *\n                                                                   * @param id\n                                                                   * @param editor\n                                                                   * @constructor\n                                                                   */\nexport function MarkupPolyline(id, editor) {\n\n  var styleAttributes = ['stroke-width', 'stroke-color', 'stroke-opacity', 'fill-color', 'fill-opacity'];\n  Markup.call(this, id, editor, styleAttributes);\n\n  // bind to this to pass this.globalManager\n  this.addMarkupMetadata = addMarkupMetadata.bind(this);\n\n  this.type = MarkupTypes.MARKUP_TYPE_POLYLINE;\n  this.shape = createMarkupPathSvg('path');\n\n  this.bindDomEvents();\n}\n\nMarkupPolyline.prototype = Object.create(Markup.prototype);\nMarkupPolyline.prototype.constructor = MarkupPolyline;\n\nvar proto = MarkupPolyline.prototype;\n\nproto.getEditMode = function () {\n\n  return new EditModePolyline(this.editor);\n};\n\n/**\n    * Sets top-left and bottom-right values in client space coordinates (2d).\n    *\n    * @param position\n    * @param size\n    * @param locations\n    * @param closed\n    */\nproto.set = function (position, size, locations, closed) {\n\n  this.rotation = 0; // Reset angle //\n  this.locations = locations.concat();\n\n  this.size.x = size.x === 0 ? 1 : size.x;\n  this.size.y = size.y === 0 ? 1 : size.y;\n\n  this.closed = closed;\n\n  this.setSize(position, size.x, size.y);\n  this.updateStyle();\n};\n\n\n/**\n    * Applies data values into DOM element style/attribute(s)\n    *\n    */\nproto.updateStyle = function () {\n\n  var style = this.style;\n  var shape = this.shape;\n\n  var strokeWidth = this.style['stroke-width'];\n  var strokeColor = this.highlighted ? this.highlightColor : composeRGBAString(style['stroke-color'], style['stroke-opacity']);\n  var fillColor = this.closed ? composeRGBAString(style['fill-color'], style['fill-opacity']) : 'none';\n  var transform = this.getTransform();\n\n  setAttributeToMarkupSvg(shape, 'd', this.getPath().join(' '));\n  setAttributeToMarkupSvg(shape, 'stroke-width', strokeWidth);\n  setAttributeToMarkupSvg(shape, 'stroke', strokeColor);\n  setAttributeToMarkupSvg(shape, 'fill', fillColor);\n  setAttributeToMarkupSvg(shape, 'transform', transform);\n  updateMarkupPathSvgHitarea(shape, this.editor);\n};\n\n/**\n    * Changes the position and size of the markup.\n    * This gets called by the Autodesk.Viewing.Extensions.Markups.Core.SetSize edit action\n    * @param {{x: Number, y: Number}} position\n    * @param {Number} width\n    * @param {Number} height\n    */\nproto.setSize = function (position, width, height) {\n\n  width = width === 0 ? 1 : width;\n  height = height === 0 ? 1 : height;\n\n  var locations = this.locations;\n  var locationsCount = locations.length;\n\n  var scaleX = width / this.size.x;\n  var scaleY = height / this.size.y;\n\n  for (var i = 0; i < locationsCount; ++i) {\n\n    var point = locations[i];\n\n    point.x *= scaleX;\n    point.y *= scaleY;\n  }\n\n  this.position.x = position.x;\n  this.position.y = position.y;\n\n  this.size.x = width;\n  this.size.y = height;\n\n  this.updateStyle();\n};\n\nproto.setMetadata = function () {\n\n  var metadata = cloneStyle(this.style);\n\n  metadata.type = this.type;\n  metadata.position = [this.position.x, this.position.y].join(\" \");\n  metadata.size = [this.size.x, this.size.y].join(\" \");\n  metadata.rotation = String(this.rotation);\n  metadata.locations = this.locations.map(function (point) {\n    return [point.x, point.y].join(\" \");\n  }).join(\" \");\n\n  return this.addMarkupMetadata(this.shape, metadata);\n};\n\nproto.getPath = function () {\n\n  var path = [];\n  var locations = this.locations;\n  var locationsCount = locations.length;\n\n  if (locationsCount === 0) {\n    return ' ';\n  }\n\n  path.push('M');\n  path.push(locations[0].x);\n  path.push(locations[0].y);\n\n  for (var i = 1; i < locationsCount; ++i) {\n\n    var locationA = locations[i - 1];\n    var locationB = locations[i];\n\n    path.push('l');\n    path.push(locationB.x - locationA.x);\n    path.push(locationB.y - locationA.y);\n  }\n\n  this.closed && path.push('z');\n  return path;\n};","'use strict';\n\nimport { Markup } from './Markup';\nimport * as MarkupTypes from './MarkupTypes';\nimport { createMarkupPathSvg, composeRGBAString, setAttributeToMarkupSvg,\nupdateMarkupPathSvgHitarea, addMarkupMetadata } from './MarkupsCoreUtils';\nimport { cloneStyle } from './StyleUtils';\nimport { EditModePolycloud } from './edit-modes/EditModePolycloud';\n\n/**\n                                                                     *\n                                                                     * @param id\n                                                                     * @param editor\n                                                                     * @constructor\n                                                                     */\nexport function MarkupPolycloud(id, editor) {\n\n  var styleAttributes = ['stroke-width', 'stroke-color', 'stroke-opacity', 'fill-color', 'fill-opacity'];\n  Markup.call(this, id, editor, styleAttributes);\n\n  // bind to this to pass this.globalManager\n  this.addMarkupMetadata = addMarkupMetadata.bind(this);\n\n  this.type = MarkupTypes.MARKUP_TYPE_POLYCLOUD;\n  this.locations = [];\n  this.shape = createMarkupPathSvg();\n\n  this.bindDomEvents();\n}\n\nMarkupPolycloud.prototype = Object.create(Markup.prototype);\nMarkupPolycloud.prototype.constructor = MarkupPolycloud;\n\nvar proto = MarkupPolycloud.prototype;\n\nproto.getEditMode = function () {\n\n  return new EditModePolycloud(this.editor);\n};\n\n/**\n    *\n    * Sets top-left and bottom-right values in client space coordinates (2d).\n    * @param position\n    * @param size\n    * @param locations\n    * @param closed\n    */\nproto.set = function (position, size, locations, closed) {\n\n  this.rotation = 0; // Reset angle //\n  this.locations = locations.concat();\n\n  this.size.x = size.x === 0 ? 1 : size.x;\n  this.size.y = size.y === 0 ? 1 : size.y;\n\n  this.closed = closed;\n\n  this.setSize(position, size.x, size.y);\n  this.updateStyle();\n};\n\n/**\n    * Applies data values into DOM element style/attribute(s)\n    *\n    */\nproto.updateStyle = function () {\n\n  var style = this.style;\n  var shape = this.shape;\n  var path = this.getPath().join(' ');\n\n  var strokeWidth = this.style['stroke-width'];\n  var strokeColor = this.highlighted ? this.highlightColor : composeRGBAString(style['stroke-color'], style['stroke-opacity']);\n  var fillColor = this.closed ? composeRGBAString(style['fill-color'], style['fill-opacity']) : 'none';\n  var transform = this.getTransform();\n\n  setAttributeToMarkupSvg(shape, 'd', path);\n  setAttributeToMarkupSvg(shape, 'stroke-width', strokeWidth);\n  setAttributeToMarkupSvg(shape, 'stroke', strokeColor);\n  setAttributeToMarkupSvg(shape, 'fill', fillColor);\n  setAttributeToMarkupSvg(shape, 'transform', transform);\n  updateMarkupPathSvgHitarea(shape, this.editor);\n};\n\n/**\n    * Changes the position and size of the markup.\n    * This gets called by the Autodesk.Viewing.Extensions.Markups.Core.SetSize edit action\n    * @param {{x: Number, y: Number}} position\n    * @param {Number} width\n    * @param {Number} height\n    */\nproto.setSize = function (position, width, height) {\n\n  width = width === 0 ? 1 : width;\n  height = height === 0 ? 1 : height;\n\n  var locations = this.locations;\n  var locationsCount = locations.length;\n\n  var scaleX = width / this.size.x;\n  var scaleY = height / this.size.y;\n\n  for (var i = 0; i < locationsCount; ++i) {\n\n    var point = locations[i];\n\n    point.x *= scaleX;\n    point.y *= scaleY;\n  }\n\n  this.position.x = position.x;\n  this.position.y = position.y;\n\n  this.size.x = width;\n  this.size.y = height;\n\n  this.updateStyle();\n};\n\nproto.setMetadata = function () {\n\n  var metadata = cloneStyle(this.style);\n\n  metadata.type = this.type;\n  metadata.position = [this.position.x, this.position.y].join(\" \");\n  metadata.size = [this.size.x, this.size.y].join(\" \");\n  metadata.rotation = String(this.rotation);\n  metadata.locations = this.locations.map(function (point) {\n    return [point.x, point.y].join(\" \");\n  }).join(\" \");\n\n  return this.addMarkupMetadata(this.shape, metadata);\n};\n\nproto.getPath = function () {\n\n  function getOrientation(locations) {\n\n    switch (locations.length) {\n\n      case 0:\n      case 1:\n        return 1;\n      case 2:\n\n        var fstPoint = locations[0];\n        var sndPoint = locations[1];\n\n        return fstPoint.y > sndPoint.y ? 1 : -1;\n      default:\n\n        var pointA = locations[0];\n        var pointB = locations[1];\n        var pointC = locations[2];\n\n        var orientation =\n        (pointB.x - pointA.x) * (pointB.y + pointA.y) +\n        (pointC.x - pointB.x) * (pointC.y + pointB.y);\n\n        return orientation < 0 ? 1 : -1;}\n\n  }\n\n  function getSides(locations, closed) {\n\n    var locationsCount = locations.length;\n\n    var sides = [];\n    var sidesCount = locationsCount - (closed ? 0 : 1);\n\n    for (var i = 0; i < sidesCount; ++i) {\n\n      var locationA = locations[i];\n      var locationB = locations[(i + 1) % locationsCount];\n\n      var dx = locationB.x - locationA.x;\n      var dy = locationB.y - locationA.y;\n\n      var length = Math.sqrt(dx * dx + dy * dy);\n\n      sides.push({\n        index: i,\n        pointA: new THREE.Vector3(locationA.x, locationA.y, 0),\n        pointB: new THREE.Vector3(locationB.x, locationB.y, 0),\n        vecAB: new THREE.Vector3(dx / length, dy / length, 0),\n        vecBA: new THREE.Vector3(-dx / length, -dy / length, 0),\n        length: length });\n\n    }\n\n    return sides;\n  }\n\n  function updateCorners(side, cornerA, cornerB, orientation) {\n    var rA = cornerA.radius;\n    var rB = cornerB.radius;\n    var D = side.length;\n\n    if (rA > 0 && rB > 0 && rA + rB > D && Math.abs(rA - rB) < D) {\n      // Corner arcs overlap, so correct them by finding the circle-circle intersection\n      var a = side.pointA.x;\n      var b = side.pointA.y;\n      var c = side.pointB.x;\n      var d = side.pointB.y;\n\n      var delta = 0.25 * Math.sqrt((D + rA + rB) * (D + rA - rB) * (D - rA + rB) * (-D + rA + rB));\n      var xS = (a + c) / 2 + (c - a) * (rA * rA - rB * rB) / (2 * D * D);\n      var xT = 2 * (b - d) / (D * D) * delta;\n      var yS = (b + d) / 2 + (d - b) * (rA * rA - rB * rB) / (2 * D * D);\n      var yT = 2 * (a - c) / (D * D) * delta;\n      var x1 = xS + xT;\n      var x2 = xS - xT;\n      var y1 = yS - yT;\n      var y2 = yS + yT;\n      var testPointOnCircle = Math.abs((x1 - a) * (x1 - a) + (y1 - b) * (y1 - b) - rA * rA);\n      if (testPointOnCircle > 0.0000001) {\n        var tmp = y1;\n        y1 = y2;\n        y2 = tmp;\n      }\n\n      var intersec = new THREE.Vector3(x1, y1, 0);\n      var intersecSide = Math.sign(intersec.clone().sub(side.pointA).cross(side.vecAB).z);\n      if (intersecSide !== orientation) {\n        intersec.set(x2, y2, 0);\n      }\n\n      cornerA.pointB = intersec.clone();\n      cornerB.pointA = intersec.clone();\n\n      return true;\n    }\n\n    return false;\n  }\n\n  function updateSides(sides, corners, radius, orientation) {\n\n    var diameter = radius * 2;\n    var sidesCount = sides.length;\n\n    for (var i = 0; i < sidesCount; ++i) {\n\n      var side = sides[i];\n      var cornerA = corners[i];\n      var cornerB = corners[(i + 1) % sidesCount];\n\n      side.bodyA = side.vecAB.clone().multiplyScalar(cornerA.radius).add(side.pointA);\n      side.bodyB = side.vecBA.clone().multiplyScalar(cornerB.radius).add(side.pointB);\n\n      if (updateCorners(side, cornerA, cornerB, orientation)) {\n        side.body = 0;\n        side.bodyDiameter = side.bodyCount = 0;\n      } else {\n        side.body = side.bodyB.clone().sub(side.bodyA).length();\n        side.bodyCount = Math.round(side.body / diameter);\n        if (side.bodyCount === 0 && side.body > 0.5 * radius) {\n          side.bodyCount = 1;\n        }\n        side.bodyDiameter = diameter + (side.body - diameter * side.bodyCount) / side.bodyCount;\n      }\n\n      side.bodyRadius = side.bodyDiameter * 0.5;\n    }\n  }\n\n  function getCorners(sides, radius, closed) {\n\n    var corners = [];\n    var sidesCount = sides.length;\n\n    for (var i = 0; i < sidesCount; ++i) {\n\n      var sideA = sides[i !== 0 ? i - 1 : sidesCount - 1];\n      var sideB = sides[i];\n      var large = sideA.vecBA.clone().cross(sideB.vecAB).z < 0;\n\n      var sidesTooShort = sideA.length < radius || sideB.length < radius;\n      if (sidesTooShort || i === 0 && !closed) {\n\n        corners.push({\n          pointA: sideB.pointA.clone(),\n          pointB: sideB.pointA.clone(),\n          radius: 0,\n          large: false });\n\n      } else {\n\n        corners.push({\n          pointA: sideB.pointA.clone().add(sideA.vecBA.clone().multiplyScalar(radius)),\n          pointB: sideB.pointA.clone().add(sideB.vecAB.clone().multiplyScalar(radius)),\n          radius: radius,\n          large: large });\n\n      }\n    }\n\n    return corners;\n  }\n\n  function createSidePath(side, orientation, path) {\n\n    var count = side.bodyCount;\n    if (count === 0) {\n      return;\n    }\n\n    var radius = side.bodyRadius;\n    var diameter = side.bodyDiameter;\n\n    var xValueInset = diameter * 0.05;\n    var yValueOffset = radius * 3.5 / 3.0;\n\n    var p1 = new THREE.Vector3(xValueInset, orientation * -yValueOffset);\n    var p2 = new THREE.Vector3(diameter - xValueInset, orientation * -yValueOffset);\n    var p3 = new THREE.Vector3(diameter, 0);\n\n    var angle = Math.acos(side.vecAB.x) * (side.vecAB.y < 0 ? -1 : 1);\n    var rotation = new THREE.Matrix4().makeRotationZ(angle);\n\n    p1.applyMatrix4(rotation);\n    p2.applyMatrix4(rotation);\n    p3.applyMatrix4(rotation);\n\n    for (var i = 0; i < count; ++i) {\n\n      path.push('c');\n      path.push(p1.x);\n      path.push(p1.y);\n      path.push(p2.x);\n      path.push(p2.y);\n      path.push(p3.x);\n      path.push(p3.y);\n    }\n  }\n\n  function createCornerPath(corner, first, orientation, path) {\n\n    if (first) {\n\n      path.push('M');\n      path.push(corner.pointA.x);\n      path.push(corner.pointA.y);\n    }\n\n    var large = orientation === 1 ? corner.large : !corner.large;\n\n    if (corner.radius !== 0) {\n\n      path.push('a');\n      path.push(corner.radius);\n      path.push(corner.radius);\n      path.push(0);\n      path.push(large ? 1 : 0);\n      path.push(orientation === 1 ? 1 : 0);\n      path.push(corner.pointB.x - corner.pointA.x);\n      path.push(corner.pointB.y - corner.pointA.y);\n    }\n    return path;\n  }\n\n\n  var strokeWidth = this.style['stroke-width'];\n  var radius = strokeWidth * 2;\n  var orientation = getOrientation(this.locations);\n  var closed = this.closed;\n  var path = [];\n\n  var sides = getSides(this.locations, closed);\n  var corners = getCorners(sides, radius, closed);\n  var cornersCount = corners.length;\n\n  updateSides(sides, corners, radius, orientation);\n\n  for (var i = 0; i < cornersCount; ++i) {\n\n    createCornerPath(corners[i], i === 0, orientation, path);\n    createSidePath(sides[i], orientation, path);\n  }\n\n  closed && path.push('z');\n  return path;\n};","'use strict';\n\nimport { Markup } from './Markup';\nimport * as MarkupTypes from './MarkupTypes';\nimport { createMarkupPathSvg, composeRGBAString, createRectanglePath,\nsetAttributeToMarkupSvg, updateMarkupPathSvgHitarea, addMarkupMetadata } from './MarkupsCoreUtils';\nimport { cloneStyle } from './StyleUtils';\nimport { EditModeRectangle } from './edit-modes/EditModeRectangle';\n\n/**\n                                                                     * Rectangle markup.\n                                                                     *\n                                                                     * Implements a Rectangle {@link Autodesk.Viewing.Extensions.Markups.Core.Markup|Markup}.\n                                                                     * Included in documentation as an example of how to create\n                                                                     * a specific markup type. Developers are encourage to look into this class's source code and copy\n                                                                     * as much code as they need. Find link to source code below.\n                                                                     *\n                                                                     * @tutorial feature_markup\n                                                                     * @constructor\n                                                                     * @memberof Autodesk.Viewing.Extensions.Markups.Core\n                                                                     * @extends Autodesk.Viewing.Extensions.Markups.Core.Markup\n                                                                     *\n                                                                     * @param {number} id\n                                                                     * @param {Autodesk.Viewing.Extensions.Markups.Core.MarkupsCore} editor\n                                                                     * @constructor\n                                                                     */\nexport function MarkupRectangle(id, editor) {\n\n  var styleAttributes = ['stroke-width', 'stroke-color', 'stroke-opacity', 'fill-color', 'fill-opacity'];\n  Markup.call(this, id, editor, styleAttributes);\n\n  // Bind to this to pass this.globalManager\n  this.addMarkupMetadata = addMarkupMetadata.bind(this);\n\n  this.type = MarkupTypes.MARKUP_TYPE_RECTANGLE;\n  this.shape = createMarkupPathSvg();\n\n  this.bindDomEvents();\n}\n\nMarkupRectangle.prototype = Object.create(Markup.prototype);\nMarkupRectangle.prototype.constructor = MarkupRectangle;\n\nvar proto = MarkupRectangle.prototype;\n\nproto.getEditMode = function () {\n\n  return new EditModeRectangle(this.editor);\n};\n\n/**\n    * Sets position and size in markup space coordinates\n    * @param {Object} position\n    * @param {Object} size\n    */\nproto.set = function (position, size) {\n\n  this.position.x = position.x;\n  this.position.y = position.y;\n  this.size.x = size.x;\n  this.size.y = size.y;\n\n  this.updateStyle();\n};\n\n/**\n    * Applies data values into DOM element style/attribute(s)\n    *\n    */\nproto.updateStyle = function () {\n\n  var style = this.style;\n  var shape = this.shape;\n  var path = this.getPath().join(' ');\n\n  var strokeWidth = this.style['stroke-width'];\n  var strokeColor = this.highlighted ? this.highlightColor : composeRGBAString(style['stroke-color'], style['stroke-opacity']);\n  var fillColor = composeRGBAString(style['fill-color'], style['fill-opacity']);\n  var transform = this.getTransform();\n\n  setAttributeToMarkupSvg(shape, 'd', path);\n  setAttributeToMarkupSvg(shape, 'stroke-width', strokeWidth);\n  setAttributeToMarkupSvg(shape, 'stroke', strokeColor);\n  setAttributeToMarkupSvg(shape, 'fill', fillColor);\n  setAttributeToMarkupSvg(shape, 'transform', transform);\n  updateMarkupPathSvgHitarea(shape, this.editor);\n};\n\nproto.setMetadata = function () {\n\n  var metadata = cloneStyle(this.style);\n\n  metadata.type = this.type;\n  metadata.position = [this.position.x, this.position.y].join(\" \");\n  metadata.size = [this.size.x, this.size.y].join(\" \");\n  metadata.rotation = String(this.rotation);\n\n  return this.addMarkupMetadata(this.shape, metadata);\n};\n\nproto.getPath = function () {\n\n  var strokeWidth = this.style['stroke-width'];\n\n  var w = this.size.x - strokeWidth;\n  var h = this.size.y - strokeWidth;\n  var x = -w * 0.5;\n  var y = -h * 0.5;\n\n  var path = [];\n  createRectanglePath(x, y, w, h, false, path);\n\n  return path;\n};","'use strict';function _typeof(obj) {\"@babel/helpers - typeof\";if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;};}return _typeof(obj);}function _slicedToArray(arr, i) {return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();}function _nonIterableRest() {throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");}function _unsupportedIterableToArray(o, minLen) {if (!o) return;if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);var n = Object.prototype.toString.call(o).slice(8, -1);if (n === \"Object\" && o.constructor) n = o.constructor.name;if (n === \"Map\" || n === \"Set\") return Array.from(o);if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);}function _arrayLikeToArray(arr, len) {if (len == null || len > arr.length) len = arr.length;for (var i = 0, arr2 = new Array(len); i < len; i++) {arr2[i] = arr[i];}return arr2;}function _iterableToArrayLimit(arr, i) {if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return;var _arr = [];var _n = true;var _d = false;var _e = undefined;try {for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {_arr.push(_s.value);if (i && _arr.length === i) break;}} catch (err) {_d = true;_e = err;} finally {try {if (!_n && _i[\"return\"] != null) _i[\"return\"]();} finally {if (_d) throw _e;}}return _arr;}function _arrayWithHoles(arr) {if (Array.isArray(arr)) return arr;}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError(\"Cannot call a class as a function\");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}function _inherits(subClass, superClass) {if (typeof superClass !== \"function\" && superClass !== null) {throw new TypeError(\"Super expression must either be null or a function\");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}function _createSuper(Derived) {var hasNativeReflectConstruct = _isNativeReflectConstruct();return function _createSuperInternal() {var Super = _getPrototypeOf(Derived),result;if (hasNativeReflectConstruct) {var NewTarget = _getPrototypeOf(this).constructor;result = Reflect.construct(Super, arguments, NewTarget);} else {result = Super.apply(this, arguments);}return _possibleConstructorReturn(this, result);};}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");}return self;}function _isNativeReflectConstruct() {if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;if (Reflect.construct.sham) return false;if (typeof Proxy === \"function\") return true;try {Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));return true;} catch (e) {return false;}}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}\n\nimport { Markup } from './Markup';\nimport * as MarkupTypes from './MarkupTypes';\nimport { createMarkupPathSvg, composeRGBAString,\nsetAttributeToMarkupSvg, updateMarkupPathSvgHitarea, addMarkupMetadata,\nstringToSvgNode,\ncreateSvgElement } from './MarkupsCoreUtils';\nimport { cloneStyle, copyStyle, isStyleEqual } from './StyleUtils';\nimport { EditModeStamp } from './edit-modes/EditModeStamp';\n\nexport { MarkupStamp };var\n\nMarkupStamp = /*#__PURE__*/function (_Markup) {_inherits(MarkupStamp, _Markup);var _super = _createSuper(MarkupStamp);\n  /** \n                                                                                                                        * @param {number} id \n                                                                                                                        * @param {Autodesk.Viewing.Extensions.Markups.Core.MarkupsCore} editor \n                                                                                                                        */\n  function MarkupStamp(id, editor, svgData) {var _this;_classCallCheck(this, MarkupStamp);\n    var styleAttributes = [\n    'text-data'];\n\n    _this = _super.call(this, id, editor, styleAttributes);\n    _this.type = MarkupTypes.MARKUP_TYPE_STAMP;\n    _this.addMarkupMetadata = addMarkupMetadata.bind(_assertThisInitialized(_this));\n\n    _this.createShapeGroup();\n\n    _this.scriptSvgData = svgData;\n    _this.loadSvgData();\n\n    _this.bindDomEvents();return _this;\n  }_createClass(MarkupStamp, [{ key: \"createShapeGroup\", value: function createShapeGroup()\n\n    {\n      /* \n      * shape\n      *    group\n      *      customSvg\n      *    hitarea (aka markup)\n      */\n      this.shape = createSvgElement('g');\n      this.shape.group = createSvgElement('g');\n      this.shape.appendChild(this.shape.group);\n\n      var hitarea = createSvgElement('path');\n      hitarea.setAttribute('id', \"hitarea\");\n      hitarea.setAttribute('fill', \"none\");\n      this.shape.appendChild(hitarea);\n\n      this.shape.hitarea = hitarea;\n      this.shape.markup = hitarea;\n    } }, { key: \"loadSvgData\", value: function loadSvgData()\n\n    {\n      var svgString = this.scriptSvgData || this.style['text-data'];\n      var svgNode = stringToSvgNode(svgString);\n\n      // null if parsing fails, so exit\n      if (svgNode === null) {\n        console.warn(\"SVG data \" + svgString + \" is invalid, skipping shape update\");\n        return;\n      }var _this$getDimensions =\n\n      this.getDimensions(svgNode),_this$getDimensions2 = _slicedToArray(_this$getDimensions, 2),width = _this$getDimensions2[0],height = _this$getDimensions2[1];\n\n      // update the bounding box when the SVG is changed\n      var path = \"M 0 0 l \".concat(width, \" 0 l 0 \").concat(height, \" l \").concat(-width, \" 0 z\");\n      this.shape.hitarea.setAttribute('d', path);\n\n      this.shape.group.innerHTML = svgNode.innerHTML;\n\n      // This is to standardize things:\n      // width and height are 1 unit\n      // position is in the centre\n      // have to flip things because of y axis going upwards\n      this.shape.group.setAttribute('transform', \"translate( -0.5 , 0.5 ) scale( \".concat(1 / width, \" , \").concat(-1 / height, \" )\"));\n      // then copy to the hitarea because it's outside the SVG\n      this.shape.hitarea.setAttribute('transform', this.shape.group.getAttribute('transform'));\n    } }, { key: \"getEditMode\", value: function getEditMode()\n\n    {\n      return new EditModeStamp(this.editor);\n    } }, { key: \"set\", value: function set(\n\n    position, size) {\n      this.setSize(position, size.x, size.y);\n      this.updateStyle();\n    } }, { key: \"updateStyle\", value: function updateStyle(\n\n    styleChanged) {\n      var strokeColor = this.highlighted ? this.highlightColor : composeRGBAString(this.style['stroke-color'], this.style['stroke-opacity']);\n      this.shape.hitarea.setAttribute('stroke', strokeColor);\n\n      // This only provides translation and rotation, not scale\n      var transform = this.getTransform() + \" scale( \".concat(this.size.x, \" , \").concat(this.size.y, \" )\");\n      this.shape.setAttribute('transform', transform);\n\n      if (styleChanged) {\n        this.loadSvgData();\n      }\n    } }, { key: \"getDimensions\", value: function getDimensions(\n\n    customSvg) {\n      var vb = customSvg.getAttribute('viewBox');\n      if (!vb) {\n        // if no viewbox is specified, check for width and height\n        var _width = customSvg.getAttribute('width') || 100;\n        var _height = customSvg.getAttribute('height') || 100;\n        return [_width, _height];\n      }\n      var strings = vb.split(' ');\n      var width = parseInt(strings[2]);\n      var height = parseInt(strings[3]);\n\n      return [width, height];\n    } }, { key: \"setMetadata\", value: function setMetadata()\n\n    {\n\n      var metadata = cloneStyle(this.style);\n\n      metadata.type = this.type;\n      metadata.position = [this.position.x, this.position.y].join(\" \");\n      metadata.size = [this.size.x, this.size.y].join(\" \");\n      metadata.rotation = String(this.rotation);\n\n      return this.addMarkupMetadata(this.shape, metadata);\n    } }, { key: \"setStyle\", value: function setStyle(\n\n    style) {\n      var stylesEqual = isStyleEqual(style, this.style);\n      if (!stylesEqual) {\n        copyStyle(style, this.style);\n      }\n\n      this.updateStyle(!stylesEqual);\n    } }]);return MarkupStamp;}(Markup);","'use strict';\n\nimport { Markup } from './Markup';\nimport * as MarkupTypes from './MarkupTypes';\nimport { composeRGBAString, setAttributeToMarkupSvg, addMarkupMetadata, radiansToDegrees,\ncreateMarkupTextSvg, setMarkupTextSvgTransform, updateMarkupTextSvgBackground,\nupdateMarkupTextSvgClipper, updateMarkupTextSvgHitarea, createSvgElement } from './MarkupsCoreUtils';\nimport { cloneStyle, isStyleEqual, copyStyle } from './StyleUtils';\nimport { EditModeText } from './edit-modes/EditModeText';\n\n// LMV ViewerLMV-2170 [Markup] [PDF] Text markup missing/cutoff for normal sized text.\n// If the font size of an SVG text is too small, the text is not rendered independently of its final screen size.\n// To solve the issue we multiply font size by 100 and scale down the text in its transform.\nvar FONT_SIZE_SCALE = 100;\n\nvar STARTING_WIDTH_FACTOR = 6;\n\n/**\n                                * Text Markup.\n                                * @constructor\n                                */\nexport function MarkupText(id, editor, size) {\n\n  var styleAttributes = [\n  'font-size',\n  'stroke-color',\n  'stroke-opacity',\n  'fill-color',\n  'fill-opacity',\n  'font-family',\n  'font-style',\n  'font-weight'];\n\n\n  Markup.call(this, id, editor, styleAttributes);\n\n  // Bind to this to pass globalManager\n  this.createSvgElement = createSvgElement.bind(this);\n  this.addMarkupMetadata = addMarkupMetadata.bind(this);\n\n  this.type = MarkupTypes.MARKUP_TYPE_TEXT;\n  this.shape = createMarkupTextSvg();\n  this.constraintRotation = true;\n  this.constraintHeight = true;\n  this.constraintWidth = false;\n  this.size.x = size.x;\n  this.size.y = size.y;\n  this.currentText = \"\";\n  this.currentTextLines = [\"\"];\n  this.textDirty = true;\n  this.textSize = { x: 0, y: 0 };\n  this.prevHighlight = false;\n  this.isHelperTextActive = false;\n\n  // Note: We could have this property be a style property.\n  // However, there is no need for this property to be exposed to the user for alteration\n  // This value is a percentage of the font size used to offset vertically 2 text lines\n  // of the same paragraph.\n  // Notice that this value is used by EditorTextInput.js\n  this.lineHeight = 130;\n\n  this.minWidth = this.getClientFontSize() * STARTING_WIDTH_FACTOR;\n\n  this.bindDomEvents();\n}\n\nMarkupText.prototype = Object.create(Markup.prototype);\nMarkupText.prototype.constructor = MarkupText;\n\nvar proto = MarkupText.prototype;\n\nproto.getEditMode = function () {\n\n  return new EditModeText(this.editor);\n};\n\n/**\n    *\n    * @param {String} position\n    * @param {String} size\n    * @param {String} textString\n    */\nproto.set = function (position, size, textString) {\n\n  this.position.x = position.x;\n  this.position.y = position.y;\n  this.size.x = size.x;\n  this.size.y = size.y;\n\n  this.setText(textString);\n};\n\nproto.setSize = function (position, width, height) {\n\n  this.position.x = position.x;\n  this.position.y = position.y;\n  this.size.x = width;\n  this.size.y = height;\n\n  var sizeUpdateRequired = true;\n\n  if (this.isHelperTextActive) {\n    this.updateTextBoxStyle();\n  } else {\n    this.updateStyle(sizeUpdateRequired);\n  }\n};\n\nproto.setPosition = function (x, y) {\n\n  this.position.x = x;\n  this.position.y = y;\n\n  if (this.isHelperTextActive) {\n    this.updateTextBoxStyle();\n  } else {\n    this.updateStyle();\n  }\n};\n\nproto.setStyle = function (style) {\n\n  var stylesEqual = isStyleEqual(style, this.style);\n\n  if (!stylesEqual) {\n    copyStyle(style, this.style);\n  }\n\n  this.updateStyle(!stylesEqual);\n};\n\n/**\n    *\n    * @param {String} text\n    */\nproto.setText = function (text) {\n\n  this.currentText = text;\n};\n\n/**\n    * Returns the raw string value\n    * @returns {String}\n    */\nproto.getText = function () {\n\n  return this.currentText;\n};\n\n/**\n    * Returns a shallow copy of the text lines used for rendering SVG text\n    * @returns {Array.<String>}\n    */\nproto.getTextLines = function () {\n\n  return this.currentTextLines.concat();\n};\n\nproto.highlightChanged = function () {\n\n  if (this.highlighted && this.highlighted !== this.prevHighlight) {\n    var shape = this.shape;\n    var strokeColor = this.highlighted ? this.highlightColor : composeRGBAString(style['stroke-color'], style['stroke-opacity']);\n    setAttributeToMarkupSvg(shape, 'fill', strokeColor);\n\n    this.prevHighlight = true;\n    return false;\n  }\n\n  return true;\n};\n\nproto.updateTextBoxStyle = function () {\n  var editMode = this.editor.duringEditMode && this.editor.editMode;\n\n  if (!editMode || editMode.type !== this.type) {\n    editMode = this.getEditMode();\n  }\n\n  editMode.updateTextBoxStyle();\n};\n\nproto.setIsHelperTextActive = function (isActive) {\n  this.isHelperTextActive = isActive;\n};\n\n/**\n    * Applies data values into DOM element style/attribute(s)\n    *\n    */\nproto.updateStyle = function (sizeUpdateRequired) {\n\n  if (this.highlightChanged()) {\n    this.prevHighlight = false;\n    var style = this.style;\n    var shape = this.shape;\n    var fontSize = this.style['font-size'];\n    var fontFamily = this.style['font-family'];\n    var fontWeight = this.style['font-weight'];\n    var fontStyle = this.style['font-style'];\n    var strokeColor = this.highlighted ? this.highlightColor : composeRGBAString(style['stroke-color'], style['stroke-opacity']);\n    var fillColor = composeRGBAString(style['fill-color'], style['fill-opacity']);\n\n    // FONT_SIZE_SCALE is used to scale up fontSize, but it is only needed in cases where the font size is too small\n    FONT_SIZE_SCALE = fontSize > 1 ? 1 : 100;\n\n    this.rebuildTextSvg(sizeUpdateRequired);\n\n    setAttributeToMarkupSvg(shape, 'font-family', fontFamily);\n    setAttributeToMarkupSvg(shape, 'font-size', fontSize * FONT_SIZE_SCALE);\n    setAttributeToMarkupSvg(shape, 'fill', strokeColor);\n    setAttributeToMarkupSvg(shape, 'font-weight', fontWeight);\n    setAttributeToMarkupSvg(shape, 'font-style', fontStyle);\n\n    var editor = this.editor;\n    var transform = this.getTransform();\n    var textTransform = this.getTextTransform();\n\n    setMarkupTextSvgTransform(shape, transform, textTransform);\n    updateMarkupTextSvgBackground(shape, this.size.x, this.size.y, fillColor);\n    updateMarkupTextSvgClipper(shape, this.size.x, this.size.y);\n    updateMarkupTextSvgHitarea(shape, this.size.x, this.size.y, editor);\n  }\n};\n\n/**\n    * Re-creates SVG tags that render SVG text.\n    * Each line is placed around tspan tags which are vertically offset to each other.\n    */\nproto.rebuildTextSvg = function (sizeUpdateRequired) {\n\n  // TODO: Remove the need to get text values from an object in edit mode, should be a function.\n  // editMode needs to be set to load markups in view mode\n  var editMode = this.editor.duringEditMode && this.editor.editMode;\n\n  if (!editMode || editMode.type !== this.type) {\n    editMode = this.getEditMode();\n    editMode.textInputHelper.textArea.value = this.currentText;\n    editMode.textInputHelper.setStyle(this.style);\n  }\n\n  if (editMode.textInputHelper.textMarkup && editMode.textInputHelper.textMarkup !== this) {\n    return;\n  }\n\n  var style = cloneStyle(editMode.textInputHelper.style);\n  var text = editMode.textInputHelper.textArea.value;\n\n  var textHelperValues = editMode.textInputHelper.getTextValuesForMarkup(this, sizeUpdateRequired);\n\n  this.currentTextLines = textHelperValues.textValues.lines;\n\n  if (textHelperValues.newPos) {\n    var position = this.editor.positionFromClientToMarkups(textHelperValues.newPos.x, textHelperValues.newPos.y);\n    var size = this.editor.sizeFromClientToMarkups(textHelperValues.width, textHelperValues.height);\n\n    this.position.x = position.x;\n    this.position.y = position.y;\n    this.size.x = size.x;\n    this.size.y = size.y;\n  }\n\n  if (editMode.selectedMarkup !== this && !editMode.textInputHelper.firstEdit) {\n    editMode.textInputHelper.textArea.value = text;\n    editMode.textInputHelper.setStyle(style);\n  }\n\n  var markup = this.createSvgElement('text');\n  markup.setAttribute('id', 'markup');\n  markup.setAttribute('alignment-baseline', 'middle');\n\n  this.shape.childNodes[0].removeChild(this.shape.markup);\n  this.shape.childNodes[0].appendChild(markup);\n  this.shape.markup = markup;\n\n  // For each line, create a tspan, add as child and offset it vertically.\n  var yOffset = this.getLineHeight() * FONT_SIZE_SCALE * (this.lineHeight / 100);\n\n  var padding = this.getLineHeight() * FONT_SIZE_SCALE / 2;\n  var dx = padding;\n  var dy = padding;\n\n  this.currentTextLines.forEach(function (line) {\n\n    var tspan = this.createSvgElement('tspan');\n\n    tspan.setAttribute('x', dx);\n    tspan.setAttribute('y', dy);\n    tspan.textContent = line;\n\n    markup.appendChild(tspan);\n    dy += yOffset;\n  }.bind(this));\n};\n\nproto.setIsShapeVisible = function (isVisible) {\n\n  this.shape.style.display = isVisible ? 'block' : 'none';\n};\n\nproto.setMetadata = function () {\n\n  var metadata = cloneStyle(this.style);\n\n  metadata.type = this.type;\n  metadata.position = [this.position.x, this.position.y].join(\" \");\n  metadata.size = [this.size.x, this.size.y].join(\" \");\n  metadata.text = String(this.currentText);\n\n  return this.addMarkupMetadata(this.shape, metadata);\n};\n\n/**\n    * Helper method that returns the font size in client space coords.\n    * @returns {Number}\n    */\nproto.getClientFontSize = function () {\n\n  return this.editor.sizeFromMarkupsToClient(0, this.style['font-size']).y;\n};\n\nproto.getLineHeight = function () {\n\n  return this.style['font-size'];\n};\n\nproto.getTransform = function () {\n\n  var x = this.position.x - this.size.x * 0.5;\n  var y = this.position.y + this.size.y * 0.5;\n\n  return [\n  'translate(', x, ',', y, ')',\n  'rotate(', radiansToDegrees(-this.rotation), ')',\n  'scale(1,-1)'].\n  join(' ');\n};\n\nproto.getTextTransform = function () {\n\n  var lineHeight = this.getLineHeight();\n\n  var x = this.position.x - this.size.x * 0.5;\n  var y = this.position.y + this.size.y * 0.5 - lineHeight;\n\n  return [\n  'translate(', x, ',', y, ')',\n  'rotate(', radiansToDegrees(-this.rotation), ')',\n  'scale(' + 1 / FONT_SIZE_SCALE + ',' + -1 / FONT_SIZE_SCALE + ')'].\n  join(' ');\n};\n\nproto.cloneShape = function (clone) {\n\n  clone.shape = createMarkupTextSvg();\n  clone.bindDomEvents();\n};\n\nproto.getBoundingRect = function () {\n  var pos = this.getClientPosition();\n  var size = this.getClientSize();\n  return {\n    x: pos.x - size.x / 2,\n    y: pos.y - size.y / 2,\n    width: size.x,\n    height: size.y };\n\n};","'use strict';\n\nvar avp = Autodesk.Viewing.Private;\n\nexport function MarkupTool() {\n\n  Autodesk.Viewing.ToolInterface.call(this);\n  this.names = [\"markups.core\"];\n  this.panTool = null;\n  this.allowNav = false;\n  this.is2d = false;\n\n  this.coreExt = null;\n  this.hotkeysEnabled = true;\n\n  var _ctrlDown = false;\n  var _shiftDown = false;\n\n  // Non-ToolInterface methods //\n\n  this.allowNavigation = function (allow) {\n    this.allowNav = allow;\n  };\n  this.setCoreExtension = function (coreExt) {\n    this.coreExt = coreExt;\n  };\n  this.setHotkeysEnabled = function (enabled) {\n    this.hotkeysEnabled = enabled;\n  };\n\n\n  // ToolInterface methods //\n\n  this.activate = function (name, viewerApi) {\n    this.panTool = viewerApi.toolController.getTool(\"pan\");\n    if (this.panTool) {\n      this.panTool.activate(\"pan\"); // TODO: What if we want \"zoom\" here?\n    }\n\n    this.is2d = viewerApi.model.is2d();\n    this.viewer = viewerApi;\n  };\n\n  this.deactivate = function (name) {\n    if (this.panTool) {\n      this.panTool.deactivate(\"pan\");\n    }\n  };\n\n  this.handleKeyDown = function (event, keyCode) {\n\n    if (!this.coreExt.editMode) {\n      return false;\n    }\n\n    if (!this.hotkeysEnabled) {\n      return true; // Consume event\n    }\n\n    // Don't propagate key handling down to tool //\n\n    switch (keyCode) {\n      case Autodesk.Viewing.KeyCode.CONTROL:_ctrlDown = true;break;\n      case Autodesk.Viewing.KeyCode.SHIFT:_shiftDown = true;break;\n\n      case Autodesk.Viewing.KeyCode.x:_ctrlDown && !this.allowNav && this.coreExt.cut();break;\n      case Autodesk.Viewing.KeyCode.c:_ctrlDown && !this.allowNav && this.coreExt.copy();break;\n      case Autodesk.Viewing.KeyCode.v:_ctrlDown && !this.allowNav && this.coreExt.paste();break;\n      case Autodesk.Viewing.KeyCode.d:\n        if (_ctrlDown && !this.allowNav) {\n          // Duplicate\n          this.coreExt.copy();\n          this.coreExt.paste();\n        }\n        break;\n      case Autodesk.Viewing.KeyCode.z:\n        if (_ctrlDown && !_shiftDown && !this.allowNav) {\n          this.coreExt.undo();\n        } else\n        if (_ctrlDown && _shiftDown && !this.allowNav) {\n          this.coreExt.redo(); // Also support Ctrl+Y\n        }\n        break;\n      case Autodesk.Viewing.KeyCode.y:_ctrlDown && !this.allowNav && this.coreExt.redo();break; // Also support ctrl+shift+z\n      case Autodesk.Viewing.KeyCode.ESCAPE:this.coreExt.onUserCancel();break;\n\n      case Autodesk.Viewing.KeyCode.BACKSPACE: // Fall through\n      case Autodesk.Viewing.KeyCode.DELETE:\n        var selectedMarkup = this.coreExt.getSelection();\n        if (selectedMarkup) {\n          this.coreExt.deleteMarkup(selectedMarkup);\n        }\n        break;\n      case Autodesk.Viewing.KeyCode.F12:\n        return false; // To allow opening developer console.\n        break;\n      default:break;}\n\n\n    return true; // Consume event\n  };\n  this.handleKeyUp = function (event, keyCode) {\n\n    if (!this.coreExt.editMode) {\n      return false;\n    }\n\n    if (!this.hotkeysEnabled) {\n      return true; // Consume event\n    }\n\n    // Don't propagate key handling down to tool\n\n    switch (keyCode) {\n      case Autodesk.Viewing.KeyCode.CONTROL:_ctrlDown = false;break;\n      case Autodesk.Viewing.KeyCode.SHIFT:_shiftDown = false;break;\n      default:break;}\n\n\n    return true; // Consume event ONLY\n  };\n\n  this.update = function () {\n    if (this.allowNav && this.panTool && this.panTool.update) {\n      return this.panTool.update();\n    }\n    return false;\n  };\n\n  this.handleSingleClick = function (event, button) {\n    if (this.allowNav) {\n      // If pan tool won't handle single click, then pass over the event.\n      if (this.panTool && this.panTool.handleSingleClick)\n      return this.panTool.handleSingleClick(event, button);else\n\n      return false;\n    }\n    return true; // Consume event\n  };\n  this.handleDoubleClick = function (event, button) {\n    if (this.allowNav) {\n      // If pan tool won't handle double click, then pass over the event\n      if (this.panTool && this.panTool.handleDoubleClick) {\n        return this.panTool.handleDoubleClick(event, button);\n      } else\n\n      return false;\n    }\n    return true; // Consume event\n  };\n  this.handleSingleTap = function (event) {\n    if (this.allowNav) {\n      // If pan tool won't handle single tap, then pass over the event\n      if (this.panTool && this.panTool.handleSingleTap) {\n        return this.panTool.handleSingleTap(event);\n      } else\n\n      return false;\n    }\n    return true; // Consume event\n  };\n  this.handleDoubleTap = function (event) {\n    if (this.allowNav) {\n      // If pan tool won't handle double tap, then pass over the event\n      if (this.panTool && this.panTool.handleDoubleTap) {\n        return this.panTool.handleDoubleTap(event);\n      } else\n\n      return false;\n    }\n    return true; // Consume event\n  };\n  this.handleWheelInput = function (delta, event) {\n    if (this.allowNav || this.is2d) {\n      // If pan tool won't handle wheel input, then pass over the event\n      if (this.panTool && this.panTool.handleWheelInput) {\n        this.coreExt.callSnapperMouseMove();\n        return this.panTool.handleWheelInput(delta, event);\n      } else\n\n      return false;\n    }\n    return true; // Consume event\n  };\n  this.handleButtonDown = function (event, button) {\n    if (this.allowNav || this.is2d && (avp.isRightClick(event, this.viewer.navigation) || avp.isMiddleClick(event))) {\n      // If pan tool won't handle button down, then pass over the event\n      if (this.panTool && this.panTool.handleButtonDown) {\n        return this.panTool.handleButtonDown(event, button);\n      } else\n\n      return false;\n    }\n    return true; // Consume event\n  };\n  this.handleButtonUp = function (event, button) {\n    if (this.allowNav || this.is2d && (avp.isRightClick(event, this.viewer.navigation) || avp.isMiddleClick(event))) {\n      // If pan tool won't handle button up, then pass over the event\n      if (this.panTool && this.panTool.handleButtonUp) {\n        return this.panTool.handleButtonUp(event, button);\n      } else\n\n      return false;\n    }\n    return true; // Consume event\n  };\n  this.handleMouseMove = function (event) {\n    if (this.allowNav || this.is2d) {\n      // If pan tool won't handle button move, then pass over the event\n      if (this.panTool && this.panTool.handleMouseMove) {\n        return this.panTool.handleMouseMove(event);\n      } else\n\n      return false;\n    }\n    return true; // Consume event\n  };\n  this.handleGesture = function (event) {\n    if (this.allowNav || this.is2d) {\n      // If pan tool won't handle gesture, then pass over the event\n      if (this.panTool && this.panTool.handleGesture) {\n        return this.panTool.handleGesture(event);\n      } else\n\n      return false;\n    }\n    return true; // Consume event\n  };\n  this.handleBlur = function (event) {\n    if (this.allowNav) {\n      // If pan tool won't handle blur, then pass over the event\n      if (this.panTool && this.panTool.handleBlur) {\n        return this.panTool.handleBlur(event);\n      } else\n\n      return false;\n    }\n    return true; // Consume event\n  };\n}","\n// These are all the supported markup types.\n\nexport var MARKUP_TYPE_ARROW = \"arrow\";\nexport var MARKUP_TYPE_TEXT = \"label\";\nexport var MARKUP_TYPE_RECTANGLE = \"rectangle\";\nexport var MARKUP_TYPE_CIRCLE = \"ellipse\";\nexport var MARKUP_TYPE_CLOUD = \"cloud\";\nexport var MARKUP_TYPE_FREEHAND = \"freehand\";\nexport var MARKUP_TYPE_HIGHLIGHT = \"highlight\";\nexport var MARKUP_TYPE_POLYLINE = \"polyline\";\nexport var MARKUP_TYPE_POLYCLOUD = \"polycloud\";\nexport var MARKUP_TYPE_CALLOUT = \"callout\";\nexport var MARKUP_TYPE_DIMENSION = \"dimension\";\nexport var MARKUP_TYPE_STAMP = \"stamp\";","\nvar content = require(\"!!../../../node_modules/css-loader/index.js!../../../node_modules/sass-loader/dist/cjs.js!./Markups.css\");\n\nif(typeof content === 'string') content = [[module.id, content, '']];\n\nvar transform;\nvar insertInto;\n\n\n\nvar options = {\"hmr\":true}\n\noptions.transform = transform\noptions.insertInto = undefined;\n\nvar update = require(\"!../../../node_modules/style-loader/lib/addStyles.js\")(content, options);\n\nif(content.locals) module.exports = content.locals;\n\nif(module.hot) {\n\tmodule.hot.accept(\"!!../../../node_modules/css-loader/index.js!../../../node_modules/sass-loader/dist/cjs.js!./Markups.css\", function() {\n\t\tvar newContent = require(\"!!../../../node_modules/css-loader/index.js!../../../node_modules/sass-loader/dist/cjs.js!./Markups.css\");\n\n\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\n\t\tvar locals = (function(a, b) {\n\t\t\tvar key, idx = 0;\n\n\t\t\tfor(key in a) {\n\t\t\t\tif(!b || a[key] !== b[key]) return false;\n\t\t\t\tidx++;\n\t\t\t}\n\n\t\t\tfor(key in b) idx--;\n\n\t\t\treturn idx === 0;\n\t\t}(content.locals, newContent.locals));\n\n\t\tif(!locals) throw new Error('Aborting CSS HMR due to changed css-modules locals.');\n\n\t\tupdate(newContent);\n\t});\n\n\tmodule.hot.dispose(function() { update(); });\n}","'use strict';function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {try {var info = gen[key](arg);var value = info.value;} catch (error) {reject(error);return;}if (info.done) {resolve(value);} else {Promise.resolve(value).then(_next, _throw);}}function _asyncToGenerator(fn) {return function () {var self = this,args = arguments;return new Promise(function (resolve, reject) {var gen = fn.apply(self, args);function _next(value) {asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);}function _throw(err) {asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);}_next(undefined);});};}\n\nimport { EditActionManager } from './edit-actions/EditActionManager';\nimport * as MarkupEvents from './MarkupEvents';\nimport * as MarkupTypes from './MarkupTypes';\nimport { addTraitEventDispatcher, createSvgElement, setSvgParentAttributes,\nMARKUP_DEFAULT_STROKE_WIDTH_IN_PIXELS, MARKUP_DEFAULT_FONT_WIDTH_IN_PIXELS,\nhideLmvUi, restoreLmvUi, dismissLmvHudMessage,\nremoveAllMetadata, transferChildNodes, addSvgMetadata,\nsvgNodeToString, checkPolygon, stringToSvgNode, createMarkupFromSVG,\nworldToClient, clientToWorld } from './MarkupsCoreUtils';\nimport { cloneStyle, copyStyle, createStyle } from './StyleUtils';\nimport { DomElementStyle } from './DomElementStyle';\nimport { Clipboard } from './edit-clipboard/Clipboard';\nimport { InputHandler } from './edit-input/InputHandler';\nimport { EditFrame } from './EditFrame';\nimport { MarkupTool } from './MarkupTool';\nimport { EditModeArrow } from './edit-modes/EditModeArrow';\n\nimport './edit-modes/BuiltinEditModes'; // IMPORTANT!! HAS SIDE EFFECTS\nimport './Markups.css'; // IMPORTANT!!\n\n\nvar MeasureCommon = Autodesk.Viewing.MeasureCommon;\n\nvar PERSPECTIVE_MODE_SCALE = 1000;\n\n/**\n                                    * Extension that allows end users to draw 2D markups on top of 2D and 3D models.\n                                    *\n                                    * @tutorial feature_markup\n                                    * @param {Autodesk.Viewing.Viewer3D} viewer - Viewer instance used to operate on.\n                                    * @param {object} options - Same Dictionary object passed into {@link Autodesk.Viewing.Viewer3D|Viewer3D}'s constructor.\n                                    * {@link Autodesk.Viewing.Extensions.Markups.Core.MarkupsCore/#show|show()}.\n                                    * @param {boolean} [options.markupDisableHotkeys] - Disables hotkeys for copy, cut, paste, duplicate, undo, redo and deselect.\n                                    * @param {Autodesk.Viewing.ToolInterface} [options.markupToolClass] - Class override for input handling.\n                                    * Use it to override/extend default hotkeys and/or mouse/gesture input.\n                                    * @memberof Autodesk.Viewing.Extensions.Markups.Core\n                                    * @class\n                                    */\nexport function MarkupsCore(viewer, options) {var _this = this;\n\n  Autodesk.Viewing.Extension.call(this, viewer, options);\n\n  this.options = this.options || {};\n  this.markups = [];\n  this.styles = {};\n\n  this.activeLayer = '';\n  this.duringViewMode = false;\n  this.duringEditMode = false;\n\n  this.svgLayersMap = {};\n\n  // Add action manager.\n  this.actionManager = new EditActionManager(50); // history of 50 actions.\n  this.actionManager.addEventListener(MarkupEvents.EVENT_HISTORY_CHANGED, this.onEditActionHistoryChanged.bind(this));\n\n  this.nextId = 0; // Used to identify markups by id during an edit session.\n\n  // Clipboard.\n  this.clipboard = new Clipboard(this);\n\n  // Default Input handler.\n  this.input = new InputHandler();\n  this.input.setGlobalManager(this.globalManager);\n\n  // Bind functions so they have access to globalManager\n  this.createSvgElement = createSvgElement.bind(this);\n  this.addSvgMetadata = addSvgMetadata.bind(this);\n  this.checkPolygon = checkPolygon.bind(this);\n\n  // Extension will dispatch events.\n  addTraitEventDispatcher(this);\n\n  var initStrokeAndFontWidths = function initStrokeAndFontWidths(model) {\n    // For 2d, set these widths once, and not recalculate again\n    if (model.is2d()) {\n      _this.getStrokeWidth();\n      _this.getFontWidth();\n    }\n  };\n\n  if (viewer.model) {\n    initStrokeAndFontWidths(viewer.model);\n  } else {\n    // Camera is reset right after a model load\n    // This is the right camera to use for widths initialization\n    viewer.addEventListener(Autodesk.Viewing.MODEL_ADDED_EVENT, function (_ref) {var model = _ref.model;\n      viewer.addEventListener(Autodesk.Viewing.CAMERA_CHANGE_EVENT, function () {\n        initStrokeAndFontWidths(model);\n      }, { once: true });\n    }, { once: true });\n  }\n\n  // Handled events.\n  this.onCameraChangeBinded = this.onCameraChange.bind(this);\n  this.onViewerResizeBinded = function (event) {\n    // This is ugly, but we need to do this twice\n    var self = this;\n    // First usage is to avoid a blinking scenario\n    self.onViewerResize(event);\n    requestAnimationFrame(function () {\n      // Second one is to actually make it work on some resize scenarios.\n      // Check the unlikely scenario that we are no longer in view mode.\n      if (self.duringViewMode) {\n        self.onViewerResize(event);\n      }\n    });\n  }.bind(this);\n\n  this.onMarkupSelectedBinded = this.onMarkupSelected.bind(this);\n  this.onMarkupEnterEditionBinded = this.onMarkupEnterEdition.bind(this);\n  this.onMarkupCancelEditionBinded = this.onMarkupCancelEdition.bind(this);\n  this.onMarkupDeleteEditionBinded = this.onMarkupDeleteEdition.bind(this);\n  this.onToolChangeBinded = this.onToolChange.bind(this);\n  this.onUnitsCalibrationStartsBinded = this.onUnitsCalibrationStarts.bind(this);\n\n  viewer.addEventListener(MeasureCommon.Events.UNITS_CALIBRATION_STARTS_EVENT, this.onUnitsCalibrationStartsBinded);\n}\n\nMarkupsCore.prototype = Object.create(Autodesk.Viewing.Extension.prototype);\nMarkupsCore.prototype.constructor = MarkupsCore;\n\nvar proto = MarkupsCore.prototype;\n\nproto.load = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {var svg, svgStyle, toolClass;return regeneratorRuntime.wrap(function _callee$(_context) {while (1) {switch (_context.prev = _context.next) {case 0:\n\n          // Add layer where annotations will actually live\n          svg = this.svg = this.createSvgElement('svg');\n          setSvgParentAttributes(svg);\n\n          // NOTE: Required since LMV renders Y coordinates upwards,\n          // while browser's Y coordinates goes downwards.\n          svgStyle = new DomElementStyle();\n          svgStyle.setAttribute('position', 'absolute');\n          svgStyle.setAttribute('left', '0');\n          svgStyle.setAttribute('top', '0');\n          svgStyle.setAttribute('transform', 'scale(1,-1)', { allBrowsers: true });\n          svgStyle.setAttribute('transformOrigin', '0, 0', { allBrowsers: true });\n          svg.setAttribute('style', svgStyle.getStyleString());\n\n          this.bounds = { x: 0, y: 0, width: 0, height: 0 };\n\n          this.input.attachTo(this);\n\n          //Instantiate edit frame.\n          this.editFrame = new EditFrame(this.viewer.container, this);\n          this.editFrame.addEventListener(MarkupEvents.EVENT_EDITFRAME_EDITION_START, function () {this.disableMarkupInteractions(true);}.bind(this));\n          this.editFrame.addEventListener(MarkupEvents.EVENT_EDITFRAME_EDITION_END, function () {this.disableMarkupInteractions(false);}.bind(this));\n\n          // Register tool\n          toolClass = this.options.markupToolClass || MarkupTool;\n          this.changeMarkupTool(toolClass, !this.options.markupDisableHotkeys);_context.next = 18;return (\n\n            this.viewer.loadExtension('Autodesk.Snapping'));case 18:\n\n          this.snapper = new Autodesk.Viewing.Extensions.Snapping.Snapper(this.viewer, { markupMode: true });\n          this.viewer.toolController.registerTool(this.snapper);return _context.abrupt(\"return\",\n\n          true);case 21:case \"end\":return _context.stop();}}}, _callee, this);}));\n\n\n/**\n                                                                                    * Change the markup tool's class in order to implement a different behaviour to the UI.\n                                                                                    *\n                                                                                    * @param {Autodesk.Viewing.Extensions.Markups.Core.MarkupTool} toolClass - Implementation or extension of MarkupTool's class.\n                                                                                    * @param {boolean} enableHotKeys - Whether to enable markup's hot-keys or not.\n                                                                                    */\nproto.changeMarkupTool = function (toolClass, enableHotKeys) {\n  if (this.markupTool) {\n    this.viewer.toolController.deregisterTool(this.markupTool);\n    this.markupTool = null;\n  }\n\n  this.markupTool = new toolClass();\n  this.markupTool.setCoreExtension(this);\n  this.markupTool.setHotkeysEnabled(enableHotKeys);\n  this.viewer.toolController.registerTool(this.markupTool);\n};\n\nproto.unload = function () {\n\n  this.hide();\n\n  this.input.detachFrom(this);\n\n  this.editFrame.unload();\n\n  if (this.markupTool) {\n    this.viewer.toolController.deregisterTool(this.markupTool);\n    this.markupTool = null;\n  }\n\n  if (this.snapper) {\n    this.viewer.toolController.deregisterTool(this.snapper);\n    this.snapper = null;\n  }\n\n  var svg = this.svg;\n  if (svg && this.onMouseDownBinded) {\n    svg.removeEventListener(\"mousedown\", this.onMouseDownBinded);\n    this.onMouseDownBinded = null;\n  }\n  if (svg.parentNode) {\n    svg.parentNode.removeChild(svg);\n  }\n  this.editModeSvgLayerNode = null;\n  this.svg = null;\n\n  return true;\n};\n\nMarkupsCore.prototype.getStrokeWidth = function () {\n\n  if (!this.initialStrokeWidth || this.viewer.model && !this.viewer.model.is2d()) {\n    this.initialStrokeWidth = this.sizeFromClientToMarkups(0, MARKUP_DEFAULT_STROKE_WIDTH_IN_PIXELS).y;\n  }\n\n  return this.initialStrokeWidth;\n};\n\nMarkupsCore.prototype.getFontWidth = function () {\n\n  if (!this.initialFontWidth || this.viewer.model && !this.viewer.model.is2d()) {\n    this.initialFontWidth = this.sizeFromClientToMarkups(0, MARKUP_DEFAULT_FONT_WIDTH_IN_PIXELS).y;\n  }\n\n  return this.initialFontWidth;\n};\n\n/**\n    * Toggle in and out of Edit mode. In Edit mode the user is able to draw markups on the canvas.\n    *\n    * See also\n    * {@link Autodesk.Viewing.Extensions.Markups.Core.MarkupsCore/#enterEditMode|enterEditMode()} and\n    * {@link Autodesk.Viewing.Extensions.Markups.Core.MarkupsCore/#leaveEditMode|leaveEditMode()}\n    */\nMarkupsCore.prototype.toggleEditMode = function () {\n\n  if (this.duringEditMode) {\n    this.leaveEditMode();\n  } else {\n    this.enterEditMode();\n  }\n};\n\n/**\n    * Enables mouse interactions and mobile device gestures over the Viewer canvas to create or draw markups.\n    *\n    * Exit Edit mode by calling {@link Autodesk.Viewing.Extensions.Markups.Core.MarkupsCore/#leaveEditMode|leaveEditMode()}.\n    *\n    * See also\n    * {@link Autodesk.Viewing.Extensions.Markups.Core.MarkupsCore/#show|show()}\n    *\n    * @param {string} layerId - [optional] Identifier for the layer of markups to be edited. Example \"Layer1\".\n    * @returns {boolean} Returns true if editMode is active\n    */\nMarkupsCore.prototype.enterEditMode = function (layerId) {\n\n  /**\n                                                           * @param layer\n                                                           * @param disable\n                                                           * @private\n                                                           */\n  function disableLayerMarkups(layer, disable) {\n    if (layer) {\n      var layerMarkups = layer.markups;\n      for (var k = 0; k < layerMarkups.length; k++) {\n        var m = layerMarkups[k];\n        m.disableInteractions(disable);\n      }\n    }\n  }\n  if (layerId) {\n    if (!this.svgLayersMap[layerId]) {\n      // if layerId is supplied but it does not exist in the svgLayerMap then create the new layer\n      console.warn(\"No such layer exists.\");\n      return false;\n    }\n  }\n\n  // If not currently shown, then show\n  if (!this.duringViewMode) {\n    if (!this.show()) {\n      return false; // Failed to enter view mode.\n    }\n  }\n\n  // Initialize the edit mode layer if it does not exist\n  if (!this.editModeSvgLayerNode) {\n    var parSvg = this.createSvgElement('g');\n    this.editModeSvgLayerNode = {\n      markups: [],\n      svg: parSvg };\n\n    this.editModeSvgLayerNode.svg.setAttribute('cursor', 'default');\n  }\n\n\n  if (this.editModeSvgLayerNode.svg.parentNode != this.svg || !layerId) {\n    this.svg.appendChild(this.editModeSvgLayerNode.svg);\n  }\n  this.svg.setAttribute('cursor', 'crosshair');\n\n\n  if (layerId) {\n    var layer = this.svgLayersMap[layerId];\n    // If the layer exists in the layer map, use the information stored for that specific layer.\n    if (layer) {\n      // Remove the edit layer when entering edit mode of a specific edit mode.\n      var editModeLayerParentNode = this.editModeSvgLayerNode.svg.parentNode;\n      editModeLayerParentNode && editModeLayerParentNode.removeChild(this.editModeSvgLayerNode.svg);\n\n      // disable the markups in the editModeLayer\n      disableLayerMarkups(this.editModeSvgLayerNode, true);\n\n      // Enable interactions for markups in the current edit layer and disable interactions for markups in\n      // the other layers.\n      for (var key in this.svgLayersMap) {\n        var markups = this.svgLayersMap[key].markups;\n        for (var i = 0; i < markups.length; i++) {\n          var markup = markups[i];\n          if (key !== layerId.toString()) {\n            // disable all not in the current layer.\n            markup.disableInteractions(true);\n          } else {\n            // enable all markups in current layer.\n            markup.disableInteractions(false);\n          }\n        }\n      }\n\n      // assign the current layer to the global active layer\n      this.activeLayer = layerId;\n      this.editingLayer = layerId;\n      var svgParent = layer.svg;\n\n      // remove previous svg layer child from svg\n      svgParent.parentNode && this.svg.removeChild(svgParent);\n\n      // reassign the markups in that layer to the global markups list\n      this.markups = layer.markups.slice();\n\n      // re-append svg layer child to svg to make it the top most layer\n      this.svg.appendChild(svgParent);\n    }\n  } else {\n    // disable interactions for the previous markups\n    // Example: enterEditMode(layer) -> enterEditMode()\n    if (this.editingLayer) {\n      for (var k = 0; k < this.markups.length; k++) {\n        var m = this.markups[k];\n        m.disableInteractions(true);\n      }\n      disableLayerMarkups(this.editModeSvgLayerNode, false);\n    }\n    this.editingLayer = '';\n    if (!this.editModeSvgLayerNode) {\n      this.markups = [];\n    } else {\n      this.markups = this.editModeSvgLayerNode.markups.slice();\n    }\n    this.activeLayer = '';\n  }\n\n  this.input.enterEditMode();\n  this.activateTool(true);\n  this.styles = {}; // Clear EditMode styles.\n  this.defaultStyle = null;\n  this.duringEditMode = true;\n  this.changeEditMode(new EditModeArrow(this));\n  this.actionManager.clear();\n  this.dispatchEvent({ type: MarkupEvents.EVENT_EDITMODE_ENTER });\n  this.allowNavigation(false);\n  return true;\n};\n\n/**\n    * Exits Edit mode.\n    *\n    * See also {@link Autodesk.Viewing.Extensions.Markups.Core.MarkupsCore/#enterEditMode|enterEditMode()}.\n    *\n    * @returns {boolean} Returns true if Edit mode has been deactivated\n    */\nMarkupsCore.prototype.leaveEditMode = function () {\n\n  var NOT_IN_EDIT_MODE = true;\n  var WE_ARE_STILL_IN_EDIT_MODE = false;\n\n  if (!this.duringEditMode || !this.duringViewMode) {\n    return NOT_IN_EDIT_MODE;\n  }\n\n  var viewer = this.viewer;\n  if (!viewer) {\n    return WE_ARE_STILL_IN_EDIT_MODE; // something is very wrong...\n  }\n\n  this.editMode.destroy();\n  this.editMode = null;\n  this.duringEditMode = false;\n\n  if (this.snapper) {\n    this.snapper.indicator.clearOverlays();\n    this.snapper.clearSnapped();\n  }\n\n  // Remove the edit layer\n  if (this.editModeSvgLayerNode && this.editModeSvgLayerNode.svg.parentNode) {\n    this.svg.removeChild(this.editModeSvgLayerNode.svg);\n  }\n  this.svg.setAttribute('cursor', 'default');\n\n  this.input.leaveEditMode();\n  this.editFrame.setMarkup(null);\n  this.activateTool(true);\n\n  this.allowNavigation(true);\n  this.dispatchEvent({ type: MarkupEvents.EVENT_EDITMODE_LEAVE });\n  return NOT_IN_EDIT_MODE;\n};\n\n/**\n    * Toggle between visible markups, i.e., show() and hidden markups, i.e., hide().\n    */\nMarkupsCore.prototype.toggle = function () {\n\n  if (this.duringViewMode) {\n    this.hide();\n  } else {\n    this.show();\n  }\n};\n\n/**\n    * Enables loading of previously saved markups.\n    * Exit Edit mode by calling {@link Autodesk.Viewing.Extensions.Markups.Core.MarkupsCore/#hide|hide()}.\n    *\n    * See also\n    * {@link Autodesk.Viewing.Extensions.Markups.Core.MarkupsCore/#enterEditMode|enterEditMode()}.\n    *\n    * @returns {boolean} Whether it successfully entered view mode or not.\n    */\nMarkupsCore.prototype.show = function () {\n\n  var viewer = this.viewer;\n  if (!viewer || !viewer.model || !this.svg) {\n    return false;\n  }\n\n  // Return if already showing or in edit-mode.\n  // Notice that edit mode requires that we are currently show()-ing.\n  if (this.duringViewMode || this.duringEditMode) {\n    return true;\n  }\n\n  viewer.addEventListener(Autodesk.Viewing.CAMERA_CHANGE_EVENT, this.onCameraChangeBinded);\n  viewer.addEventListener(Autodesk.Viewing.VIEWER_RESIZE_EVENT, this.onViewerResizeBinded);\n\n  // Add parent svg of all markups.\n  viewer.container.appendChild(this.svg);\n  viewer.reorderElements(this.svg);\n\n  this.input.enterViewMode();\n  hideLmvUi(viewer);\n\n  // TODO: Nasty hack, currently there is no API to disable mouse highlighting in 3d models.\n  // TODO: We nuke rollover function in viewer, for now, public api will be added soon.\n  this.onViewerRolloverObject = viewer.impl.rolloverObject;\n  viewer.impl.rolloverObject = function () {};\n\n  this.activateTool(true);\n  var camera = viewer.impl.camera;\n  this.onViewerResize({ width: camera.clientWidth, height: camera.clientHeight });\n\n  // See function loadMarkups() for when the actual SVG gets added onstage //\n  this.svgLayersMap = {};\n  this.duringViewMode = true;\n  this.allowNavigation(true);\n  return true;\n};\n\n/**\n    * Removes any markup currently overlaid on the viewer. It exits Edit mode if it is active.\n    *\n    * See also\n    * {@link Autodesk.Viewing.Extensions.Markups.Core.MarkupsCore/#show|show()}\n    *\n    * @returns {boolean} Whether it successfully left view mode or not.\n    */\nMarkupsCore.prototype.hide = function () {\n\n  var RESULT_HIDE_OK = true;\n  var RESULT_HIDE_FAIL = false;\n\n  var viewer = this.viewer;\n  if (!viewer || !this.duringViewMode) {\n    return RESULT_HIDE_OK;\n  }\n\n  if (this.duringEditMode) {\n    if (!this.leaveEditMode()) {\n      return RESULT_HIDE_FAIL;\n    }\n  }\n\n  viewer.removeEventListener(Autodesk.Viewing.CAMERA_CHANGE_EVENT, this.onCameraChangeBinded);\n  viewer.removeEventListener(Autodesk.Viewing.VIEWER_RESIZE_EVENT, this.onViewerResizeBinded);\n\n  var svg = this.svg;\n  svg.parentNode && svg.parentNode.removeChild(svg);\n\n  // Remove all Markups and metadata (if any)\n  this.unloadMarkupsAllLayers();\n  removeAllMetadata(svg);\n\n  this.input.leaveViewMode();\n  restoreLmvUi(viewer);\n  this.viewer.impl.rolloverObject = this.onViewerRolloverObject;\n\n  this.activateTool(false);\n  this.duringViewMode = false;\n  return RESULT_HIDE_OK;\n};\n\n/**\n    * Removes newly created markups in the current editing layer.\n    * Markups that were created in a specific layer will not be removed.\n    *\n    * Markups should have been added while in\n    * {@link Autodesk.Viewing.Extensions.Markups.Core.MarkupsCore/#enterEditMode|Edit mode}.\n    */\nMarkupsCore.prototype.clear = function () {\n  // Can only clear specific layers when in the edit mode of that layer.\n  if (!this.duringEditMode) {\n    console.warn(\"Clear only removes markups when in Edit Mode.\");\n    return;\n  }\n  var editModeLayer = this.editingLayer ? this.svgLayersMap[this.editingLayer] : this.editModeSvgLayerNode;\n  if (editModeLayer) {\n    var markups = editModeLayer.markups;\n    var svg = editModeLayer.svg;\n    if (svg && svg.childNodes.length > 0) {\n      while (svg.childNodes.length) {\n        svg.removeChild(svg.childNodes[0]);\n      }\n    }\n    while (markups.length > 0) {\n      var markup = markups[0];\n      this.removeMarkup(markup);\n      markup.destroy();\n    }\n  }\n};\n\n/**\n    * Returns an SVG string with the markups created so far.\n    * The SVG string can be reloaded using\n    * {@link Autodesk.Viewing.Extensions.Markups.Core.MarkupsCore/#loadMarkups|loadMarkups()}.\n    *\n    * Markups should have been added while in\n    * {@link Autodesk.Viewing.Extensions.Markups.Core.MarkupsCore/#enterEditMode|Edit mode}.\n    *\n    * @returns {string} Returns an SVG element with all of the created markups in a string format.\n    */\nMarkupsCore.prototype.generateData = function () {\n\n  var defaultLayer = this.editModeSvgLayerNode.svg;\n\n  if (this.editMode) {\n    this.editMode.onSave();\n  }\n\n  // Sanity check, remove any lingering metadata nodes\n  removeAllMetadata(this.svg);\n\n  if (this.activeLayer) {\n    defaultLayer = this.svgLayersMap[this.activeLayer].svg;\n  }\n\n  var tmpNode = this.createSvgElement(\"svg\");\n  transferChildNodes(this.svg, tmpNode); // Transfer includes this.editModeSvgLayerNode\n  transferChildNodes(defaultLayer, this.svg);\n\n  // version 1: first implementation.\n  // version 2: added global offset to markup positions.\n  // version 3: change node structure to include hitareas, hit areas are not exported.\n  // version 4: scale perspective markups space by PERSPECTIVE_MODE_SCALE because bug in firefox. LMV-1150\n  var metadataObject = {\n    \"data-model-version\": \"4\" };\n\n  var metadataNode = this.addSvgMetadata(this.svg, metadataObject);\n  var metadataNodes = [metadataNode];\n\n  // Notify each markup to inject metadata\n  this.markups.forEach(function (markup) {\n    var addedNode = markup.setMetadata();\n    if (addedNode) {\n      metadataNodes.push(addedNode);\n    }\n  });\n\n  // Generate the data!\n  var data = svgNodeToString(this.svg);\n\n  // Remove metadataObject before returning\n  metadataNodes.forEach(function (metadataNode) {\n    metadataNode.parentNode.removeChild(metadataNode);\n  });\n\n  transferChildNodes(this.svg, defaultLayer);\n  transferChildNodes(tmpNode, this.svg);\n  tmpNode = null; // get rid of it.\n\n  return data;\n};\n\n/**\n    * @private\n    */\nMarkupsCore.prototype.generatePoints3d = function () {\n\n  var result = { markups: [], main: null };\n  var markups = this.markups;\n  var markupsCount = markups.length;\n\n  if (markupsCount === 0) {\n    return result;\n  }\n\n  // Gather a 3d point for markup.\n  var idTarget = this.viewer.impl.renderer().readbackTargetId();\n  for (var i = 0; i < markupsCount; ++i) {\n\n    var markup = markups[i];\n    var point = markup.generatePoint3d(idTarget) || null;\n    result.markups.push(\n    {\n      id: markup.id,\n      type: markup.type,\n      point: point || null });\n\n  }\n\n\n  // If there is 3d point associated with an arrow, we use that as main point.\n  if (markupsCount === 1) {\n\n    var main = result.markups[0].point;\n    result.main = main && main.clone();\n    return result;\n  }\n\n  for (var _i = 0; _i < markupsCount; ++_i) {\n\n    var collision = result.markups[_i];\n    if (collision.type === MarkupTypes.MARKUP_TYPE_ARROW && collision.point !== null) {\n\n      result.main = collision.point.clone();\n      return result;\n    }\n  }\n\n  // If there is no arrows, we average bounding boxes and get a 3d point inside it.\n  var bbX0 = Number.POSITIVE_INFINITY;\n  var bbY0 = Number.POSITIVE_INFINITY;\n  var bbX1 = Number.NEGATIVE_INFINITY;\n  var bbY1 = Number.NEGATIVE_INFINITY;\n\n  for (var _i2 = 0; _i2 < markupsCount; ++_i2) {\n\n    var boundingBox = markups[_i2].generateBoundingBox();\n\n    bbX0 = Math.min(bbX0, boundingBox.min.x);\n    bbY0 = Math.min(bbY0, boundingBox.min.y);\n    bbX1 = Math.max(bbX1, boundingBox.max.x);\n    bbY1 = Math.max(bbY1, boundingBox.max.y);\n  }\n\n  var polygon = {};\n\n  polygon.vertexCount = 4;\n  polygon.xVertices = new Float32Array([bbX0, bbX1, bbX1, bbX0]);\n  polygon.yVertices = new Float32Array([bbY0, bbY0, bbY1, bbY1]);\n\n  var point2d = this.checkPolygon(polygon, idTarget);\n  var point3d = point2d && this.viewer.clientToWorld(point2d.x, point2d.y);\n  result.main = point3d && point3d.point;\n\n  return result;\n};\n\n/**\n    * Renders the markups onto a 2D canvas context to generate an image.\n    *\n    * @param {CanvasRenderingContext2D} context - Markups are drawn using the context provided\n    * @param callback\n    * @param renderAllMarkups\n    * @private\n    */\nMarkupsCore.prototype.renderToCanvas = function (context, callback, renderAllMarkups) {\n\n  var width = this.bounds.width;\n  var height = this.bounds.height;\n  var viewBox = this.getSvgViewBox(width, height);\n  var numberOfScreenshotsTaken = 0;\n  var markups = [];\n  var layer;\n\n  var onMarkupScreenshotTaken = function () {\n    if (callback && ++numberOfScreenshotsTaken === markups.length) {\n      callback();\n    }\n  }.bind(this);\n\n  if (renderAllMarkups) {\n    var svgKeys = Object.keys(this.svg.childNodes);\n    var layersKeys = Object.keys(this.svgLayersMap);\n\n    // Append only markups that their parent layer is contained inside the svg main container.\n    for (var i = 0; i < svgKeys.length; i++) {\n      for (var j = 0; j < layersKeys.length; j++) {\n        layer = this.svgLayersMap[layersKeys[j]];\n        if (this.svg.childNodes[svgKeys[i]] === layer.svg) {\n          markups = markups.concat(layer.markups);\n        }\n      }\n    }\n  } else {\n    layer = this.svgLayersMap[this.activeLayer] || this.editModeSvgLayerNode;\n    markups = layer.markups;\n  }\n\n  if (markups.length === 0) {\n    callback();\n  } else {\n    markups.forEach(function (markup) {\n      markup.renderToCanvas(context, viewBox, width, height, onMarkupScreenshotTaken);\n    });\n  }\n};\n\n/**\n    * Changes the active drawing tool. For example, from the Arrow drawing tool to the Rectangle drawing tool.\n    * Only applicable while in {@link Autodesk.Viewing.Extensions.Markups.Core.MarkupsCore/#enterEditMode|Edit mode}.\n    *\n    * Supported values are:\n    * - `new Autodesk.Viewing.Extensions.Markups.Core.EditModeArrow(MarkupsCoreInstance)`\n    * - `new Autodesk.Viewing.Extensions.Markups.Core.EditModeRectangle(MarkupsCoreInstance)`\n    * - `new Autodesk.Viewing.Extensions.Markups.Core.EditModeCircle(MarkupsCoreInstance)`\n    * - `new Autodesk.Viewing.Extensions.Markups.Core.EditModeCloud(MarkupsCoreInstance)`\n    * - `new Autodesk.Viewing.Extensions.Markups.Core.EditModeText(MarkupsCoreInstance)`\n    * - `new Autodesk.Viewing.Extensions.Markups.Core.EditModeFreehand(MarkupsCoreInstance)`\n    * - `new Autodesk.Viewing.Extensions.Markups.Core.EditModePolyline(MarkupsCoreInstance)`\n    * - `new Autodesk.Viewing.Extensions.Markups.Core.EditModePolycloud(MarkupsCoreInstance)`\n    *\n    * This function fires event `Autodesk.Viewing.Extensions.Markups.Core.EVENT_EDITMODE_CHANGED`.\n    *\n    * @param {object} editMode - Object instance for the drawing tool\n    */\nMarkupsCore.prototype.changeEditMode = function (editMode) {\n\n  var oldEditMode = this.editMode;\n  oldEditMode && oldEditMode.destroy();\n\n  editMode.addEventListener(MarkupEvents.EVENT_EDITMODE_CREATION_BEGIN, function () {this.disableMarkupInteractions(true);}.bind(this));\n  editMode.addEventListener(MarkupEvents.EVENT_EDITMODE_CREATION_END, function () {this.disableMarkupInteractions(false);}.bind(this));\n  editMode.addEventListener(MarkupEvents.EVENT_MARKUP_DESELECT, function (event) {this.dispatchEvent(event);}.bind(this));\n\n  this.editMode = editMode;\n  this.styles[editMode.type] = cloneStyle(editMode.getStyle());\n\n  this.dispatchEvent({ type: MarkupEvents.EVENT_EDITMODE_CHANGED, target: editMode });\n};\n\n/**\n    * Check whether a user can perform camera navigation operations on the current loaded model.\n    * While the extension is active, the user can still draw markups.\n    * Panning and zooming are only supported for orthographic cameras.\n    *\n    * @returns {boolean} Whether {@link Autodesk.Viewing.Extensions.Markups.Core.MarkupsCore/#allowNavigation|allowNavigation()} can succeed.\n    */\nMarkupsCore.prototype.isNavigationAllowed = function () {\n\n  return !this.viewer.impl.camera.isPerspective;\n};\n\n/**\n    * Enables click, tap, and swipe behavior to allow camera zoom and panning operations. It is only available in\n    * {@link Autodesk.Viewing.Extensions.Markups.Core.MarkupsCore/#enterEditMode|Edit mode}.\n    *\n    * @param {boolean} allow - Whether camera navigation interactions are active or not.\n    */\nMarkupsCore.prototype.allowNavigation = function (allow) {\n\n  //we will still need to update the markup styles even if in perspective mode\n  var editMode = this.editMode;\n  this.navigating = allow;\n\n  if (allow) {\n    this.svg.setAttribute(\"pointer-events\", \"none\");\n    editMode && this.selectMarkup(null);\n  } else {\n    this.svg.setAttribute(\"pointer-events\", \"painted\");\n  }\n\n  // Update pointer events for all markups.\n  var markups = this.markups;\n  var markupsCount = markups.length;\n\n  for (var i = 0; i < markupsCount; ++i) {\n    markups[i].updateStyle();\n  }\n  editMode && editMode.notifyAllowNavigation(allow);\n\n  // Navigation is not allowed while in perspective mode.\n  if (allow && (this.duringEditMode || this.duringViewMode) && !this.isNavigationAllowed()) {\n    return false;\n  }\n\n  // Clear snapper.\n  if (allow && this.snapper) {\n    this.snapper.indicator.clearOverlays();\n    this.snapper.clearSnapped();\n  }\n\n  this.markupTool.allowNavigation(allow);\n\n};\n\n/**\n    * Sets mouse interactions and mobile device gestures with markups. Only applicable in\n    * {@link Autodesk.Viewing.Extensions.Markups.Core.MarkupsCore/#enterEditMode|Edit mode}.\n    *\n    * @param {boolean} disable - true to disable interactions with markups; false to enable interactions with markups; default false.\n    */\nMarkupsCore.prototype.disableMarkupInteractions = function (disable) {\n\n  if (this.editModeSvgLayerNode) {\n    this.editModeSvgLayerNode.svg.setAttribute('cursor', disable ? 'inherit' : 'default');\n  }\n  this.markups.forEach(function (markup) {markup.disableInteractions(disable);});\n};\n\n/**\n    *\n    * @param isActive\n    * @private\n    */\nMarkupsCore.prototype.activateTool = function (isActive) {\n  if (isActive) {\n    if (!this.cachedNavigationTool) {\n      this.cachedNavigationTool = this.viewer.getActiveNavigationTool();\n      this.viewer.addEventListener(Autodesk.Viewing.TOOL_CHANGE_EVENT, this.onToolChangeBinded);\n    }\n    this.viewer.setActiveNavigationTool(this.markupTool.getName());\n  } else {\n\n    if (this.cachedNavigationTool) {\n      this.viewer.setActiveNavigationTool(this.cachedNavigationTool);\n      this.cachedNavigationTool = null;\n    } else {\n      var defaultToolName = this.viewer.getDefaultNavigationToolName();\n      this.viewer.setActiveNavigationTool(defaultToolName);\n    }\n\n    this.viewer.removeEventListener(Autodesk.Viewing.TOOL_CHANGE_EVENT, this.onToolChangeBinded);\n  }\n};\n\n/**\n    *\n    * @param event\n    * @private\n    */\nMarkupsCore.prototype.onToolChange = function (event) {\n\n  if (event.toolName !== this.markupTool.getName())\n  return;\n\n  if (event.active) {\n    var navAllowed = this.isNavigationAllowed();\n    this.viewer.setNavigationLockSettings({\n      pan: navAllowed,\n      zoom: navAllowed,\n      orbit: false,\n      roll: false,\n      fov: false,\n      walk: false,\n      gotoview: false });\n\n  }\n  this.viewer.setNavigationLock(event.active);\n};\n\nMarkupsCore.prototype.onUnitsCalibrationStarts = function () {\n  if (this.duringEditMode) {\n    this.hide();\n  }\n};\n\n//// Input /////////////////////////////////////////////////////////////////////////////////////////////////////////\n\nproto.changeInputHandler = function (inputHandler) {\n\n  this.input.detachFrom(this);\n  inputHandler.attachTo(this);\n  this.input = inputHandler;\n\n  if (this.duringEditMode) {\n    inputHandler.enterEditMode();\n  }\n\n  if (this.duringViewMode) {\n    inputHandler.enterViewMode();\n  }\n};\n\n//// Copy and Paste System /////////////////////////////////////////////////////////////////////////////////////////\n\n/**\n * Standard copy operation. Applies to any selected markup.<br>\n * See also\n * {@link Autodesk.Viewing.Extensions.Markups.Core.MarkupsCore/#cut|cut()} and\n * {@link Autodesk.Viewing.Extensions.Markups.Core.MarkupsCore/#paste|paste()}.\n */\nMarkupsCore.prototype.copy = function () {\n\n  this.clipboard.copy();\n};\n\n/**\n    * Standard cut operation. Applies to any selected markup, which gets removed from the screen at call time.<br>\n    * See also\n    * {@link Autodesk.Viewing.Extensions.Markups.Core.MarkupsCore/#copy|copy()} and\n    * {@link Autodesk.Viewing.Extensions.Markups.Core.MarkupsCore/#paste|paste()}.\n    */\nMarkupsCore.prototype.cut = function () {\n\n  this.clipboard.cut();\n};\n\n/**\n    * Standard paste operation. This function will paste any previously copied or cut markup.\n    * Can be called repeatedly after a single copy or cut operation.<br>\n    * See also\n    * {@link Autodesk.Viewing.Extensions.Markups.Core.MarkupsCore/#copy|copy()} and\n    * {@link Autodesk.Viewing.Extensions.Markups.Core.MarkupsCore/#cut|cut()}.\n    */\nMarkupsCore.prototype.paste = function () {\n\n  this.clipboard.paste();\n};\n\n//// Undo and Redo System //////////////////////////////////////////////////////////////////////////////////////////\n/**\n * Will undo the previous operation.<br>\n * The Undo/Redo stacks will track any change done to the existing markups.<br>\n * See also\n * {@link Autodesk.Viewing.Extensions.Markups.Core.MarkupsCore/#redo|redo()} and\n * {@link Autodesk.Viewing.Extensions.Markups.Core.MarkupsCore/#isUndoStackEmpty|isUndoStackEmpty()}.\n */\nMarkupsCore.prototype.undo = function () {\n\n  this.actionManager.undo();\n};\n\n/**\n    * Will redo any previously undo operation.<br>\n    * See also\n    * {@link Autodesk.Viewing.Extensions.Markups.Core.MarkupsCore/#undo|undo()},\n    * {@link Autodesk.Viewing.Extensions.Markups.Core.MarkupsCore/#isRedoStackEmpty|isRedoStackEmpty()}.\n    */\nMarkupsCore.prototype.redo = function () {\n\n  this.actionManager.redo();\n};\n\n/**\n    * Returns true when {@link Autodesk.Viewing.Extensions.Markups.Core.MarkupsCore/#undo|undo()}\n    * produces no changes.\n    *\n    * @returns {boolean} true if there are no changes to undo; false if there are changes to undo.\n    */\nMarkupsCore.prototype.isUndoStackEmpty = function () {\n\n  return this.actionManager.isUndoStackEmpty();\n};\n\n/**\n    * Returns true when {@link Autodesk.Viewing.Extensions.Markups.Core.MarkupsCore/#redo|redo()}\n    * produces no changes.\n    *\n    * @returns {boolean} true if there are no changes to redo; false if there are changes to redo.\n    */\nMarkupsCore.prototype.isRedoStackEmpty = function () {\n\n  return this.actionManager.isRedoStackEmpty();\n};\n\nproto.beginActionGroup = function () {\n\n  this.actionManager.beginActionGroup();\n};\n\nproto.closeActionGroup = function () {\n\n  this.actionManager.closeActionGroup();\n};\n\nproto.cancelActionGroup = function () {\n\n  this.actionManager.cancelActionGroup();\n};\n\n/**\n    * Helper function for generating unique markup ids.\n    *\n    * @returns {number}\n    */\nproto.getId = function () {\n\n  return ++this.nextId;\n};\n\n/**\n    * @param event\n    * @private\n    */\nproto.onEditActionHistoryChanged = function (event) {\n\n  var data = event.data;\n  if (data.action !== 'undo' && data.targetId !== -1) {\n\n    // Markup can be null when deleting, that's ok, we unselect in that case.\n    var markup = this.getMarkup(data.targetId);\n    this.selectMarkup(markup);\n  }\n  if (data.action === 'undo' && !this.isUndoStackEmpty()) {\n\n    var _markup = this.getMarkup(this.actionManager.getLastElementInUndoStack().getTargetId());\n    this.selectMarkup(_markup);\n  }\n\n  this.dispatchEvent(event);\n};\n\n/**\n    * Returns a markup with the specified ID. Returns null when not found.\n    * The ID can be retrieved from the return value of getSelection(). <br>\n    * See also\n    * {@link Autodesk.Viewing.Extensions.Markups.Core.MarkupsCore/#getSelection|getSelection()}.\n    *\n    * @param {string} id Markup identifier.\n    * @returns {Autodesk.Viewing.Extensions.Markups.Core.Markup} Returns markup object.\n    */\nMarkupsCore.prototype.getMarkup = function (id) {\n\n  var markups = this.markups;\n  var markupsCount = markups.length;\n\n  for (var i = 0; i < markupsCount; ++i) {\n    if (markups[i].id == id) {\n      return markups[i];\n    }\n  }\n\n  return null;\n};\n\n\n/**\n    * Selects or deselects a markup. A selected markup gets an overlayed UI that allows you to perform transformations\n    * such as resizing, rotations, and translations. To deselect a markup, send a null value. <br>\n    * See also\n    * {@link Autodesk.Viewing.Extensions.Markups.Core.MarkupsCore/#getMarkup|getMarkup()}.\n    *\n    * @param {Autodesk.Viewing.Extensions.Markups.Core.Markup|null} markup The markup instance to select. Set the value to null to deselect a markup.\n    */\nMarkupsCore.prototype.selectMarkup = function (markup) {\n\n  if (markup) {\n\n    if (this.editMode.type === markup.type) {\n      this.editMode.setSelection(markup);\n    } else {\n\n      var editMode = markup.getEditMode();\n      editMode.setSelection(null);\n\n      this.changeEditMode(editMode);\n      this.setStyle(markup.getStyle());\n      this.editMode.setSelection(markup);\n    }\n  } else {\n    // fix for text markup in view mode\n    if (this.editMode) {\n      this.editMode.setSelection(null);\n    }\n  }\n};\n\n/**\n    * Returns the currently selected markup. A selected markup has a custom UI overlayed that allows you to perform\n    * resizing, rotations and translations.<br>\n    * See also\n    * {@link Autodesk.Viewing.Extensions.Markups.Core.MarkupsCore/#selectMarkup|selectMarkup()}.\n    *\n    * @returns {Autodesk.Viewing.Extensions.Markups.Core.Markup|null} Returns selected markup object; null if no markup is selected.\n    */\nMarkupsCore.prototype.getSelection = function () {\n\n  return this.editMode.getSelection();\n};\n\n/**\n    * Deletes a markup from the canvas. Only applies while in\n    * {@link Autodesk.Viewing.Extensions.Markups.Core.MarkupsCore/#enterEditMode|Edit mode}.\n    *\n    * @param {Autodesk.Viewing.Extensions.Markups.Core.Markup} markup - Markup object.\n    * @param {boolean} [dontAddToHistory] Whether delete action can be {@link Autodesk.Viewing.Extensions.Markups.Core.MarkupsCore/#undo|undone}.\n    */\nMarkupsCore.prototype.deleteMarkup = function (markup, dontAddToHistory) {\n\n  if (!this.editMode || this.editMode && this.editMode.selectedMarkup.id !== markup.id) {\n    this.editMode = markup.getEditMode();\n  }\n  this.editMode.deleteMarkup(markup, dontAddToHistory);\n};\n\nproto.addMarkup = function (markup) {\n\n  var markups;\n  var layer = this.activeLayer;\n  var layerObject = this.svgLayersMap[layer] || '';\n\n  if (layerObject) {\n    var svgParent = layerObject.svg;\n    // append markup svg to layer svg\n    markup.setParent(svgParent);\n    // Add markup to layer markups if it does not exist\n    layerObject.markups.push(markup);\n    markups = layerObject.markups.slice();\n  } else {\n    // if layer is undefined create a edit mode svg layer\n    markup.setParent(this.editModeSvgLayerNode.svg);\n    this.editModeSvgLayerNode.markups.push(markup);\n    markups = this.editModeSvgLayerNode.markups.slice();\n  }\n\n  markup.addEventListener(MarkupEvents.EVENT_MARKUP_SELECTED, this.onMarkupSelectedBinded);\n  markup.addEventListener(MarkupEvents.EVENT_MARKUP_ENTER_EDITION, this.onMarkupEnterEditionBinded);\n  markup.addEventListener(MarkupEvents.EVENT_MARKUP_CANCEL_EDITION, this.onMarkupCancelEditionBinded);\n  markup.addEventListener(MarkupEvents.EVENT_MARKUP_DELETE_EDITION, this.onMarkupDeleteEditionBinded);\n  // Only set the global markups array when in edit mode\n  if (this.duringEditMode) {\n    this.markups = markups;\n  }\n};\n\n/**\n    *\n    * @param markup\n    * @private\n    */\nproto.removeMarkup = function (markup) {\n\n  if (!markup) {\n    return false;\n  }\n  var self = this;\n\n  /**\n                    * Get the layer markups in which the markup exists.\n                    * This function will remove the markup if it exists in the corresponding layer markups array.\n                    *\n                    * @param markup\n                    * @returns {number} returns -1 if the markup does not exist in a layer markups array\n                    */\n  function removeMarkupIfExists(markup) {\n    var markupIndex;\n    var layerMarkups = -1;\n    // check if the markup exists in the edit layer\n    if (self.editModeSvgLayerNode) {\n      var editLayerMarkups = self.editModeSvgLayerNode.markups;\n      markupIndex = editLayerMarkups.indexOf(markup);\n      if (markupIndex !== -1) {\n        // remove the markup from the corresponding markup array\n        editLayerMarkups.splice(markupIndex, 1);\n        layerMarkups = editLayerMarkups.slice();\n        // update the global markups array if the markup is in the active layer\n        if (self.activeLayer === '') {\n          self.markups = layerMarkups;\n        }\n        return layerMarkups;\n      }\n    }\n    // check if the markup exists in a layer\n    if (self.svgLayersMap) {\n      for (var layer in self.svgLayersMap) {\n        var markups = self.svgLayersMap[layer].markups;\n        markupIndex = markups.indexOf(markup);\n        if (markupIndex !== -1) {\n          // remove the markup from the corresponding markup array\n          markups.splice(markupIndex, 1);\n          layerMarkups = markups.slice();\n          // update the global markups array if the markup is in the active layer\n          if (self.activeLayer === layer) {\n            self.markups = layerMarkups;\n          }\n          return layerMarkups;\n        }\n      }\n    }\n    return layerMarkups;\n  }\n\n  var layerMarkups = removeMarkupIfExists(markup);\n  if (layerMarkups === -1)\n  return false;\n\n  markup.setParent(null);\n\n  markup.removeEventListener(MarkupEvents.EVENT_MARKUP_SELECTED, this.onMarkupSelectedBinded);\n  markup.removeEventListener(MarkupEvents.EVENT_MARKUP_ENTER_EDITION, this.onMarkupEnterEditionBinded);\n  markup.removeEventListener(MarkupEvents.EVENT_MARKUP_CANCEL_EDITION, this.onMarkupCancelEditionBinded);\n  markup.removeEventListener(MarkupEvents.EVENT_MARKUP_DELETE_EDITION, this.onMarkupDeleteEditionBinded);\n\n  var editMode = this.editMode;\n  if (editMode) {\n    var selectedMarkup = editMode.getSelection();\n    if (selectedMarkup === markup) {\n      this.selectMarkup(null);\n    }\n  }\n};\n\n//// Markups style /////////////////////////////////////////////////////////////////////////////////////////////////\n\nMarkupsCore.prototype.setStyle = function (style) {\n\n  var styles = this.styles;\n  var editMode = this.editMode;\n\n  copyStyle(style, styles[editMode.type]);\n  // copyStyle(styles[editMode.type], style);\n  editMode.setStyle(styles[editMode.type]);\n};\n\nMarkupsCore.prototype.getStyle = function () {\n\n  return cloneStyle(this.styles[this.editMode.type]);\n};\n\nMarkupsCore.prototype.getDefaultStyle = function () {\n\n  var defaultStyleAttributes = [\n  'stroke-width',\n  'font-size',\n  'font-family',\n  'font-style',\n  'font-weight',\n  'stroke-color',\n  'stroke-opacity',\n  'fill-color',\n  'text-data',\n  'fill-opacity'];\n  this.defaultStyle = this.defaultStyle || createStyle(defaultStyleAttributes, this);\n\n  return this.defaultStyle;\n};\n\n//// Markups depth order ///////////////////////////////////////////////////////////////////////////////////////////\n\n/**\n *\n * @param markup\n * @private\n */\nproto.bringToFront = function (markup) {\n\n  this.sendMarkupTo(markup, this.markups.length - 1);\n};\n\n/**\n    *\n    * @param markup\n    * @private\n    */\nproto.sendToBack = function (markup) {\n\n  this.sendMarkupTo(markup, 0);\n};\n\n/**\n    *\n    * @param markup\n    * @private\n    */\nproto.bringForward = function (markup) {\n\n  var markupIndex = this.markups.indexOf(markup);\n  this.sendMarkupTo(markup, markupIndex + 1);\n};\n\n/**\n    *\n    * @param markup\n    * @private\n    */\nproto.bringBackward = function (markup) {\n\n  var markupIndex = this.markups.indexOf(markup);\n  this.sendMarkupTo(markup, markupIndex - 1);\n};\n\n/**\n    *\n    * @param markup\n    * @param index\n    * @private\n    */\nproto.sendMarkupTo = function (markup, index) {\n\n  var markups = this.markups;\n  var markupIndex = markups.indexOf(markup);\n\n  if (markupIndex === -1 || index < 0 || index >= markups.length) {\n    return;\n  }\n\n  markups.splice(markupIndex, 1);\n  index = markupIndex > index ? index - 1 : index;\n  markups.splice(index, 0, markup);\n\n  // TODO: Add markup in right position not always at the end.\n  markup.setParent(null);\n  if (this.activeLayer) {\n    var parent = this.svgLayersMap[this.activeLayer].svg;\n    markup.setParent(parent);\n  } else {\n    markup.setParent(this.editModeSvgLayerNode.svg);\n  }\n};\n\n\n/**\n    * Loads data (SVG string) for all markups in a specified layer (layerId) to the Viewer's canvas.<br>\n    *\n    * See also\n    * {@link Autodesk.Viewing.Extensions.Markups.Core.MarkupsCore/#unloadMarkups|unloadMarkups()}, and\n    * {@link Autodesk.Viewing.Extensions.Markups.Core.MarkupsCore/#hideMarkups|hideMarkups()}.\n    *\n    * @param {string} markupString - SVG string with markups. See also {@link Autodesk.Viewing.Extensions.Markups.Core.MarkupsCore/#generateData|generateData()}.\n    * @param {string} layerId - Identifier for the layer where the markup should be loaded to. Example \"Layer1\".\n    * @returns {boolean} Whether the markup string was able to be loaded successfully\n    */\nMarkupsCore.prototype.loadMarkups = function (markupString, layerId) {\n\n  if (this.duringEditMode) {\n    console.warn(\"Markups will not be loaded during the edit mode\");\n    return false;\n  }\n\n  if (!this.duringViewMode) {\n    return false;\n  }\n\n  if (!layerId) {\n    console.warn(\"loadMarkups failed; missing 2nd argument 'layerId'\");\n    return false;\n  }\n\n  // Can it be parsed into SVG?\n  var parent = stringToSvgNode(markupString);\n  if (!parent) {\n    return false;\n  }\n\n  // If the supplied layerId exists in the svg layers map and there are children in the svg then return false.\n  if (layerId in this.svgLayersMap && this.svg.childNodes.length > 0) {\n    console.warn(\"This layer is already loaded, will not load again.\");\n    return false;\n  }\n  this.activeLayer = layerId;\n  var svgLayerNode = this.svgLayersMap[layerId];\n\n  // if the layer exists, delete it\n  if (svgLayerNode)\n  delete this.svgLayersMap[layerId];\n\n  // create an empty parent svg layer node for layerId\n  // Child markups will get added to th parent svg layer node in the addMarkup function\n  var newSvg = this.createLayerNode();\n\n  svgLayerNode = {\n    markups: [],\n    svgString: markupString,\n    svg: newSvg };\n\n  this.svgLayersMap[layerId] = svgLayerNode;\n\n  var children = parent.childNodes;\n  for (var i = 0; i < children.length; i++) {\n    var child = children[i];\n    var markup = createMarkupFromSVG(child, this);\n    // Disable markups if already in edit mode and the active layer is different\n    if (markup && this.duringEditMode && this.editingLayer !== this.activeLayer) {\n      markup.disableInteractions(true);\n    }\n\n    if (!markup && child.localName !== \"metadata\") {\n      // Append child removes it from parent and copies it over to the new svg layer node,\n      // so we need to reduce index by 1 to continue proper iteration\n      svgLayerNode.svg.appendChild(child);\n      i--;\n      if (typeof child.setAttribute === 'function') {\n        child.setAttribute(\"pointer-events\", \"none\");\n      }\n    }\n  }\n\n  var svgParentNode = this.svgLayersMap[this.activeLayer].svg;\n\n  this.svg.appendChild(svgParentNode);\n  // If already in an edit mode layer then reassign active layer to edit layer\n  if (this.duringEditMode && this.editingLayer !== this.activeLayer) {\n    this.activeLayer = this.editingLayer;\n    if (this.editingLayer)\n    this.markups = this.svgLayersMap[this.activeLayer].markups.slice();\n  }\n  return true;\n};\n\n/**\n    * TODO: Probably this function needs to be moved to MarkupCoreUtils.js\n    * Creates a new layer node\n    * */\n\nproto.createLayerNode = function () {\n\n  var newSvgLayerNode = this.createSvgElement('g');\n  newSvgLayerNode.setAttribute('cursor', 'default');\n  return newSvgLayerNode;\n};\n\n/**\n    * Revert any changes made to the specific layer.\n    *\n    * See also\n    * {@link Autodesk.Viewing.Extensions.Markups.Core.MarkupsCore/#loadMarkups|loadMarkups()} and\n    * {@link Autodesk.Viewing.Extensions.Markups.Core.MarkupsCore/#enterEditMode|enterEditMode()}.\n    *\n    * @param {string} layerId - ID of the layer to revert any changes that were made to it.\n    * @returns {boolean} true if the layer was unloaded, false if the layer was not unloaded.\n    */\nMarkupsCore.prototype.revertLayer = function (layerId) {\n  if (!layerId) {\n    console.warn(\"revertLayer failed because no layerId was supplied.\");\n    return false;\n  }\n  var svgLayerNode = this.svgLayersMap[layerId];\n  if (!svgLayerNode) {\n    console.warn(\"The supplied layer does not exist.\");\n    return false;\n  }\n  var inEditMode = this.duringEditMode;\n  // Leave editMode to revert a layer\n  if (inEditMode)\n  this.leaveEditMode();\n\n  // keep track of previous global markups.\n  var currentMarkups = this.markups.slice();\n  // Set the global markups to the markups in the current layer. These ones get removed in the unloadMarkups\n  this.markups = svgLayerNode.markups;\n  var layerSvg = svgLayerNode.svgString;\n  this.unloadMarkups(layerId);\n  this.loadMarkups(layerSvg, layerId);\n  // Assign markups\n  if (this.editingLayer) {\n    if (this.editingLayer !== layerId) {\n      this.markups = currentMarkups;\n      var layerObject = this.svgLayersMap[this.editingLayer];\n      if (layerObject) {\n        layerObject.markups = currentMarkups;\n      }\n    }\n  } else {\n    if (this.editModeSvgLayerNode) {\n      this.editModeSvgLayerNode.markups = currentMarkups;\n    }\n  }\n\n  if (this.editingLayer || this.editingLayer.length === 0) {\n    var svg = this.editingLayer.length === 0 ? this.editModeSvgLayerNode.svg : this.svgLayersMap[this.editingLayer].svg;\n    if (svg.parentNode == this.svg) {\n      this.svg.removeChild(svg);\n      this.svg.appendChild(svg);\n    }\n  }\n  return true;\n};\n\n/**\n    * Removes markups from the DOM (Document Object Model). This is helpful for freeing up memory.<br>\n    *\n    * See also\n    * {@link Autodesk.Viewing.Extensions.Markups.Core.MarkupsCore/#loadMarkups|loadMarkups()},\n    * {@link Autodesk.Viewing.Extensions.Markups.Core.MarkupsCore/#unloadMarkupsAllLayers|unloadMarkupsAllLayers()},\n    * {@link Autodesk.Viewing.Extensions.Markups.Core.MarkupsCore/#clear|clear()},\n    * {@link Autodesk.Viewing.Extensions.Markups.Core.MarkupsCore/#hide|hide()}, and\n    * {@link Autodesk.Viewing.Extensions.Markups.Core.MarkupsCore/#hideMarkups|hideMarkups()}.\n    *\n    * @param {string} layerId - ID of the layer containing all markups to unload (from the DOM).\n    * @returns {boolean} Whether the operation succeeded or not.\n    */\nMarkupsCore.prototype.unloadMarkups = function (layerId) {\n\n  if (!layerId) {\n    console.warn(\"unloadMarkups failed; No layerId provided.\");\n    return false;\n  }\n\n  var svgLayerNode = this.svgLayersMap[layerId];\n  if (!svgLayerNode) {\n    // TODO: Do we need to log anything here?\n    console.warn('No such layer exists to unload.');\n    return false;\n  }\n\n  var layerMarkups = svgLayerNode.markups.slice();\n  var numMarkups = layerMarkups.length;\n  for (var i = 0; i < numMarkups; i++) {\n    var markup = layerMarkups[i];\n    this.removeMarkup(markup);\n    markup.destroy();\n  }\n\n  // Remove the markups in the layer from the svg canvas\n  if (svgLayerNode.svg.parentNode === this.svg)\n  this.svg.removeChild(svgLayerNode.svg);\n\n  // Delete the layer from the layer map.\n  delete this.svgLayersMap[layerId];\n  // Reset the active layer if the supplied layer id is the same as the active layer\n  if (this.activeLayer.toString() === layerId.toString()) {\n    this.activeLayer = '';\n  }\n  // Leave edit mode and reset the editing layer if the supplied layer is the same as the current editing layer\n  if (this.editingLayer && this.editingLayer.toString() === layerId.toString()) {\n    this.editingLayer = '';\n    this.duringEditMode && this.leaveEditMode();\n  }\n\n  return true;\n};\n\n/**\n    * Removes all markups loaded so far. Great for freeing up memory.\n    *\n    * See also\n    * {@link Autodesk.Viewing.Extensions.Markups.Core.MarkupsCore/#loadMarkups|loadMarkups()},\n    * {@link Autodesk.Viewing.Extensions.Markups.Core.MarkupsCore/#unloadMarkups|unloadMarkups()},\n    * {@link Autodesk.Viewing.Extensions.Markups.Core.MarkupsCore/#clear|clear()},\n    * {@link Autodesk.Viewing.Extensions.Markups.Core.MarkupsCore/#hide|hide()}, and\n    * {@link Autodesk.Viewing.Extensions.Markups.Core.MarkupsCore/#hideMarkups|hideMarkups()}.\n    */\nMarkupsCore.prototype.unloadMarkupsAllLayers = function () {\n  this.activeLayer = '';\n  var self = this;\n\n  //this is specific to the editModeSvgLayerNode, enterEditMode().\n  var unloadSvgLayerNode = function unloadSvgLayerNode() {\n    if (self.editModeSvgLayerNode) {\n      var layerMarkups = self.editModeSvgLayerNode.markups.slice();\n      var numMarkups = layerMarkups.length;\n      for (var i = 0; i < numMarkups; i++) {\n        var markup = layerMarkups[i];\n        self.removeMarkup(markup);\n        markup.destroy();\n      }\n    }\n  };\n\n  // Unload the markups in the editModeSvgLayerNode\n  unloadSvgLayerNode();\n  var layerId;\n  for (layerId in this.svgLayersMap) {\n    this.unloadMarkups(layerId);\n  }\n};\n\n/**\n    * Hides all markups in a specified layer. Note that hidden markups will not be unloaded.\n    * Use the {@link Autodesk.Viewing.Extensions.Markups.Core.MarkupsCore/#showMarkups|showMarkups()} method to make\n    * them visible again; no additional parsing is required.\n    *\n    * See also\n    * {@link Autodesk.Viewing.Extensions.Markups.Core.MarkupsCore/#showMarkups|showMarkups()},\n    * {@link Autodesk.Viewing.Extensions.Markups.Core.MarkupsCore/#unloadMarkups|unloadMarkups()}, and\n    * {@link Autodesk.Viewing.Extensions.Markups.Core.MarkupsCore/#loadMarkups|loadMarkups()}.\n    *\n    * @param {string} layerId - ID of the layer containing all markups that should be hidden (in the DOM).\n    * @returns {boolean} Whether the operation succeeded or not.\n    */\nMarkupsCore.prototype.hideMarkups = function (layerId) {\n\n  if (!layerId) {\n    console.warn(\"hideMarkups failed; No layerId provided.\");\n    return false;\n  }\n\n  var svgLayerNode = this.svgLayersMap[layerId];\n  if (!svgLayerNode) {\n    // TODO: Do we need to log anything here?\n    return false;\n  }\n  var layerSvg = svgLayerNode.svg;\n\n  // Return false if the layer svg is not present in the main svg\n  if (layerSvg.parentNode != this.svg) {\n    console.warn(\"Layer is already hidden.\");\n    return false;\n  }\n  // remove the layer svg from the main svg\n  this.svg.removeChild(layerSvg);\n  return true;\n};\n\n/**\n    * Unhides a layer of hidden markups\n    * ({@link Autodesk.Viewing.Extensions.Markups.Core.MarkupsCore/#hideMarkups|hideMarkups()}).\n    *\n    * @param {string} layerId - ID of the layer containing all markups to unload (from the DOM).\n    * @returns {boolean} Whether the operation succeeded or not.\n    */\nMarkupsCore.prototype.showMarkups = function (layerId) {\n\n  if (!layerId) {\n    console.warn(\"showMarkups failed; No layerId provided.\");\n    return false;\n  }\n\n  var svgLayerNode = this.svgLayersMap[layerId];\n  if (!svgLayerNode) {\n    // TODO: Do we need to log anything here?\n    return false;\n  }\n  // Append the layer svg to the main svg\n  var layerSvg = svgLayerNode.svg;\n  this.svg.appendChild(layerSvg);\n};\n\n//// Client Space <-> Markup Space /////////////////////////////////////////////////////////////////////////////////\n\nproto.positionFromClientToMarkups = function (x, y) {\n\n  return this.clientToMarkups(x, y);\n};\n\nproto.positionFromMarkupsToClient = function (x, y) {\n\n  return this.markupsToClient(x, y);\n};\n\nproto.vectorFromClientToMarkups = function (x, y) {\n\n  var a = this.clientToMarkups(0, 0);\n  var b = this.clientToMarkups(x, y);\n\n  return { x: b.x - a.x, y: b.y - a.y };\n};\n\nproto.vectorFromMarkupsToClient = function (x, y) {\n\n  var a = this.markupsToClient(0, 0);\n  var b = this.markupsToClient(x, y);\n\n  return { x: b.x - a.x, y: b.y - a.y };\n};\n\nproto.sizeFromClientToMarkups = function (w, h) {\n\n  var a = this.clientToMarkups(0, 0);\n  var b = this.clientToMarkups(w, h);\n\n  return { x: Math.abs(b.x - a.x), y: Math.abs(b.y - a.y) };\n};\n\nproto.sizeFromMarkupsToClient = function (w, h) {\n\n  var a = this.markupsToClient(0, 0);\n  var b = this.markupsToClient(w, h);\n\n  return { x: Math.abs(b.x - a.x), y: Math.abs(b.y - a.y) };\n};\n\nproto.markupsToClient = function (x, y) {\n\n  var camera = this.viewer.impl.camera;\n  var point = new THREE.Vector3(x, y, 0);\n\n  if (camera.isPerspective) {\n\n    var bb = this.viewer.impl.getCanvasBoundingClientRect();\n\n    point.x = point.x / PERSPECTIVE_MODE_SCALE * (bb.height * 0.5) + bb.width * 0.5;\n    point.y = -point.y / PERSPECTIVE_MODE_SCALE * (bb.height * 0.5) + bb.height * 0.5;\n  } else {\n\n    point.applyMatrix4(camera.matrixWorld);\n    point.sub(camera.position);\n\n    // In LMV model is offset by a global offset, we correct this offset when transforming to markups space, so\n    // exported markups don't have the offset.\n    var globalOffset = this.viewer.model && this.viewer.model.getData().globalOffset;\n    if (globalOffset) {\n      point.sub(globalOffset);\n    }\n\n    point = worldToClient(point, this.viewer, false);\n    point.z = 0;\n  }\n\n  return point;\n};\n\nproto.clientToMarkups = function (x, y) {\n\n  var camera = this.viewer.impl.camera;\n  var point = new THREE.Vector3(x, y, 0);\n\n  if (camera.isPerspective) {\n\n    var bb = this.viewer.impl.getCanvasBoundingClientRect();\n\n    // Multiply by PERSPECTIVE_MODE_SCALE because Firfox on Windows machines have problems to deal with very small paths.\n    point.x = (point.x - bb.width * 0.5) / (bb.height * 0.5) * PERSPECTIVE_MODE_SCALE;\n    point.y = -(point.y - bb.height * 0.5) / (bb.height * 0.5) * PERSPECTIVE_MODE_SCALE;\n  } else {\n\n    point = clientToWorld(point.x, point.y, 0, this.viewer);\n\n    // In LMV model is offset by a global offset, we correct this offset when transforming to markups space, so\n    // exported markups don't have the offset.\n    var globalOffset = this.viewer.model && this.viewer.model.getData().globalOffset;\n    if (globalOffset) {\n      point.add(globalOffset);\n    }\n\n    point.add(camera.position);\n    point.applyMatrix4(camera.matrixWorldInverse);\n    point.z = 0;\n  }\n\n  return point;\n};\n\nproto.getSvgViewBox = function (clientWidth, clientHeight) {\n\n  // Get pan offset.\n  var lt = this.clientToMarkups(0, 0);\n  var rb = this.clientToMarkups(clientWidth, clientHeight);\n\n  var l = Math.min(lt.x, rb.x);\n  var t = Math.min(lt.y, rb.y);\n  var r = Math.max(lt.x, rb.x);\n  var b = Math.max(lt.y, rb.y);\n\n  return [l, t, r - l, b - t].join(' ');\n};\n\nproto.getBounds = function () {\n\n  return this.bounds;\n};\n\nproto.getMousePosition = function () {\n\n  // When snapping, use the snap position instead of the mouse position\n  // as the start point of the markup drawing.\n  // For now only works for 2D.\n  if (this.editMode.useWithSnapping() && this.snapper && this.snapper.isSnapped()) {\n    return this.getSnapPosition();\n  }\n  return this.input.getMousePosition();\n};\n\nproto.getSnapPosition = function () {\n\n  var point = MeasureCommon.getSnapResultPosition(this.snapper.getSnapResult(), this.viewer);\n  var p = this.project(point);\n  return { x: p.x, y: p.y };\n};\n\nproto.project = function (position) {\n  var camera = this.viewer.navigation.getCamera();\n  var containerBounds = this.viewer.navigation.getScreenViewport();\n\n  var p = new THREE.Vector3().copy(position);\n  p.project(camera);\n\n  return new THREE.Vector3(Math.round((p.x + 1) / 2 * containerBounds.width),\n  Math.round((-p.y + 1) / 2 * containerBounds.height), p.z);\n};\n\n//// Handled Events ////////////////////////////////////////////////////////////////////////////////////////////////\n\nproto.onCameraChange = function () {\n\n  // Update annotations' parent transform.\n  var viewBox = this.getSvgViewBox(this.bounds.width, this.bounds.height);\n\n  // HACK, for some reason the 2nd frame returns an empty canvas.\n  // The reason why this happens is that the code above calls into the viewer\n  // and a division by zero occurs due to LMV canvas having zero width and height\n  // When we detect this case, avoid setting the viewBox value and rely on one\n  // previously set.\n  if (viewBox === \"NaN NaN NaN NaN\") {\n    return;\n  }\n\n  if (this.svg) {\n    this.svg.setAttribute('viewBox', viewBox);\n  }\n\n\n  var editMode = this.editMode;\n\n  if (editMode) {\n    // Edit frame has to be updated, re-setting the selected markup does the job.\n    if (this.editFrame.isActive()) {\n      var selectedMarkup = editMode.getSelection();\n      this.editFrame.setMarkup(selectedMarkup);\n    }\n\n    if (editMode.updateTextBoxStyle) {\n      editMode.updateTextBoxStyle();\n    }\n\n    if (this.snapper && editMode.useWithSnapping()) {\n      this.snapper.indicator.render();\n    }\n  }\n};\n\nproto.onViewerResize = function (event) {\n\n  this.bounds.x = 0;\n  this.bounds.y = 0;\n  this.bounds.width = event.width;\n  this.bounds.height = event.height;\n\n  if (this.svg) {\n    this.svg.setAttribute('width', this.bounds.width);\n    this.svg.setAttribute('height', this.bounds.height);\n  }\n\n  this.onCameraChange();\n};\n\nproto.callSnapperMouseDown = function () {\n\n  // Disable snapper in freehand mode\n  if (this.editMode && this.editMode.useWithSnapping()) {\n    var mousePosition = this.input.getMousePosition();\n    if (this.snapper) {\n      this.snapper.onMouseDown(mousePosition);\n      this.snapper.indicator.render();\n    }\n  } else {\n    // Clear the snapper when selecting a markup that does not allow snapping.\n    if (this.snapper) {\n      this.snapper.clearSnapped();\n      this.snapper.indicator.clearOverlays();\n    }\n  }\n};\n\nproto.callSnapperMouseMove = function () {\n\n  if (this.editMode && this.editMode.useWithSnapping()) {\n    var mousePosition = this.input.getMousePosition();\n    if (this.snapper) {\n      this.snapper.onMouseMove(mousePosition);\n      this.snapper.indicator.render();\n    }\n  }\n};\n\n/**\n    * Handler to mouse move events, used to create markups.\n    *\n    * @param event\n    * @returns {boolean} - if the event was handed by the editor\n    * @private\n    */\nproto.onMouseMove = function (event) {\n\n  if (this.navigating) {\n    return false;\n  }\n\n  var eventHandled = false;\n  if (this.editFrame.isActive() && event.type === 'mousemove') {\n    eventHandled = this.editFrame.onMouseMove(event);\n  }\n\n  this.callSnapperMouseMove();\n\n  eventHandled = this.editMode && this.editMode.onMouseMove(event) || eventHandled;\n\n  return eventHandled;\n};\n\n/**\n    * Handler to mouse down events, used to start creation markups.\n    *\n    * @param event\n    * @private\n    */\nproto.onMouseDown = function (event) {\n\n  dismissLmvHudMessage();\n\n  this.callSnapperMouseDown();\n\n  var bounds = this.getBounds();\n  var mousePosition = this.getMousePosition();\n\n  if (mousePosition.x >= bounds.x && mousePosition.x <= bounds.x + bounds.width &&\n  mousePosition.y >= bounds.y && mousePosition.y <= bounds.y + bounds.height) {\n    this.editMode.onMouseDown(event);\n  }\n\n  // TODO: There is a better way to do this, implement when undo/redo group.\n  if (!this.editMode.creating && event.target === this.svg) {\n    this.selectMarkup(null);\n  }\n  this.ignoreNextMouseUp = false;\n};\n\n/**\n    * \n    * @param {*} event \n    * @returns {boolean} - true / false means the editor did / didn't handle the event\n    * @private\n    */\nproto.onMouseUp = function (event) {\n\n  if (this.navigating) {\n    return false;\n  }\n\n  if (this.editFrame.isActive()) {\n    this.editFrame.onMouseUp(event);\n    return true;\n  }\n\n  if (!this.ignoreNextMouseUp) {\n    return this.editMode.onMouseUp(event);\n  }\n};\n\nproto.onMouseDoubleClick = function (event) {\n\n  if (this.navigating) {\n    return;\n  }\n\n  if (this.editFrame.isActive()) {\n    return;\n  }\n\n  this.editMode.onMouseDoubleClick(event);\n};\n\nproto.onUserCancel = function () {\n  if (!this.editMode) {\n    return;\n  } else\n  if (this.editMode.creating) {\n    this.editMode.creationCancel();\n  } else {\n    this.editMode.unselect();\n  }\n};\n\n/**\n    *\n    * @param event\n    * @private\n    */\nproto.onMarkupSelected = function (event) {\n\n  this.selectMarkup(event.markup);\n  this.dispatchEvent(event);\n};\n\nproto.onMarkupEnterEdition = function () {\n\n};\n\nproto.onMarkupCancelEdition = function () {\n\n  this.onUserCancel();\n};\n\nproto.onMarkupDeleteEdition = function (event) {\n\n  this.removeMarkup(event.markup);\n  this.editMode.deleteMarkup();\n};\n\nAutodesk.Viewing.theExtensionManager.registerExtension('Autodesk.Viewing.MarkupsCore', MarkupsCore);","import * as MarkupType from '../core/MarkupTypes';\nimport { CreateArrow } from './edit-actions/CreateArrow';\nimport { CreateRectangle } from './edit-actions/CreateRectangle';\nimport { CreateText } from './edit-actions/CreateText';\nimport { CreateCallout } from './edit-actions/CreateCallout';\nimport { CreateCircle } from './edit-actions/CreateCircle';\nimport { CreateCloud } from './edit-actions/CreateCloud';\nimport { CreateFreehand } from './edit-actions/CreateFreehand';\nimport { CreatePolyline } from './edit-actions/CreatePolyline';\nimport { CreatePolycloud } from './edit-actions/CreatePolycloud';\nimport { CreateHighlight } from './edit-actions/CreateHighlight';\nimport { CreateDimension } from './edit-actions/CreateDimension';\nimport { DomElementStyle } from './DomElementStyle';\nimport { CreateStamp } from './edit-actions/CreateStamp';\n\n\nvar av = Autodesk.Viewing;\nvar avp = Autodesk.Viewing.Private;\n\nvar _gWindow = av.getGlobal();\nvar _gDocument = _gWindow.document;\n\n// Change these constants to alter the default sizes in pixels of strokes and fonts.\nexport var MARKUP_DEFAULT_STROKE_WIDTH_IN_PIXELS = 1;\nexport var MARKUP_DEFAULT_FONT_WIDTH_IN_PIXELS = 10;\nexport var MARKUP_DEFAULT_HITAREAS_MARGIN_IN_PIXELS = 15;\nexport var EDIT_FRAME_DEFAULT_MARGIN = 7;\n\n/**\n                                           * // isTouchDevice is an LMV function. Hammer is included by LMV as well\n                                           * @returns {boolean}\n                                           */\nexport var isTouchDevice = function isTouchDevice() {\n  // isTouchDevice() is an LMV function.\n  // Hammer (a touch detection lib) is packaged with LMV as well\n  if (av.isTouchDevice && typeof Hammer === \"function\") {\n    return av.isTouchDevice();\n  }\n  return false;\n};\n\n//// SVG  //////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n/**\n *\n * @param type\n * @returns {Element}\n */\nexport var createSvgElement = function createSvgElement(type) {\n\n  var _document = this && this.getDocument && this.getDocument() || _gDocument;\n  // See https://developer.mozilla.org/en-US/docs/Web/API/Document/createElementNS\n  var namespace = 'http://www.w3.org/2000/svg';\n  return _document.createElementNS(namespace, type);\n};\n\n/**\n    *\n    * @param {Element} svg - an SVGElement\n    * @returns {Element} svg param is returned back\n    */\nexport var setSvgParentAttributes = function setSvgParentAttributes(svg) {\n\n  // See: https://developer.mozilla.org/en-US/docs/Web/SVG/Namespaces_Crash_Course\n  svg.setAttribute('version', '1.1'); // Notice that this is the SVG version, not the \"MARKUP DATA VERSION\"!\n  svg.setAttribute('baseProfile', 'full');\n  svg.setAttribute('layer-order-id', 'markups-svg');\n  return svg;\n};\n\nexport var createMarkupGroupSvg = function createMarkupGroupSvg(children) {\n  children = children || [];\n  var svg = createSvgElement('g');\n  svg.setAttribute('cursor', 'default');\n  svg.setAttribute('pointer-events', 'none');\n\n  for (var i = 0; i < children.length; i++) {\n    svg.appendChild(children[i]);\n  }\n\n  return svg;\n};\n\nexport var createMarkupPathSvg = function createMarkupPathSvg() {\n\n  var svg = createSvgElement('g');\n  svg.setAttribute('cursor', 'inherit');\n  svg.setAttribute('pointer-events', 'none');\n\n  var markup = createSvgElement('path');\n  markup.setAttribute('id', 'markup');\n\n  var hitarea = createSvgElement('path');\n  hitarea.setAttribute('id', 'hitarea');\n  hitarea.setAttribute('fill', 'transparent');\n  hitarea.setAttribute('stroke', 'transparent');\n\n  svg.markup = markup;\n  svg.hitarea = hitarea;\n\n  svg.appendChild(markup);\n  svg.appendChild(hitarea);\n\n  return svg;\n};\n\nexport var setAttributeToMarkupSvg = function setAttributeToMarkupSvg(svg, attribute, value) {\n\n  svg.markup.setAttribute(attribute, value);\n};\n\nexport var updateMarkupPathSvgHitarea = function updateMarkupPathSvgHitarea(svg, editor) {\n\n  var markup = svg.markup;\n  var hitarea = svg.hitarea;\n\n  var hitareaMargin = editor.sizeFromClientToMarkups(0, MARKUP_DEFAULT_HITAREAS_MARGIN_IN_PIXELS).y;\n  hitareaMargin += parseFloat(markup.getAttribute('stroke-width')) + hitareaMargin;\n\n  var markupFill = markup.getAttribute('fill');\n  var markupStroke = markup.getAttribute('stroke');\n  var strokeEnabled = markupStroke !== '' && markupStroke !== 'none';\n  var fillEnabled = markupFill !== '' && markupFill !== 'none';\n\n  hitarea.setAttribute('d', markup.getAttribute('d'));\n  hitarea.setAttribute('stroke-width', hitareaMargin);\n  hitarea.setAttribute('transform', markup.getAttribute('transform'));\n\n  if (editor.duringEditMode && !editor.navigating) {\n    if (strokeEnabled && fillEnabled) {\n      svg.setAttribute('pointer-events', 'painted');\n      return;\n    }\n\n    if (strokeEnabled) {\n      svg.setAttribute('pointer-events', 'stroke');\n      return;\n    }\n\n    if (fillEnabled) {\n      svg.setAttribute('pointer-events', 'fill');\n      return;\n    }\n  }\n\n  svg.setAttribute('pointer-events', 'none');\n};\n\nexport var createMarkupTextSvg = function createMarkupTextSvg() {\n\n  var svg = createSvgElement('g');\n  svg.setAttribute('cursor', 'default');\n\n  var clipperId = 'markup-clipper-' + getUniqueID();\n  var clipperUrl = 'url(#' + clipperId + ')';\n\n  var clipper = createSvgElement('clipPath');\n  clipper.setAttribute('id', clipperId);\n  clipper.removeAttribute('pointer-events');\n  clipper.rect = createSvgElement('rect');\n  clipper.appendChild(clipper.rect);\n\n  var background = createSvgElement('rect');\n  background.setAttribute('id', 'markup-background');\n  background.removeAttribute('pointer-events');\n\n  var markup = createSvgElement('text');\n  markup.setAttribute('id', 'markup');\n\n  var hitarea = createSvgElement('rect');\n  hitarea.setAttribute('id', 'hitarea');\n  hitarea.setAttribute('fill', 'transparent');\n  hitarea.setAttribute('stroke', 'none');\n  hitarea.setAttribute('stroke-width', '0');\n\n  var clippedArea = createSvgElement('g');\n  clippedArea.setAttribute('clip-path', clipperUrl);\n  clippedArea.appendChild(clipper);\n  clippedArea.appendChild(background);\n  clippedArea.appendChild(markup);\n\n  svg.appendChild(clippedArea);\n  svg.appendChild(hitarea);\n\n  svg.clipper = clipper;\n  svg.background = background;\n  svg.markup = markup;\n  svg.hitarea = hitarea;\n\n  return svg;\n};\n\nexport var setMarkupTextSvgTransform = function setMarkupTextSvgTransform(svg, transform, textTransform) {\n\n  svg.clipper.rect.setAttribute('transform', transform);\n  svg.background.setAttribute('transform', transform);\n  svg.markup.setAttribute('transform', textTransform);\n  svg.hitarea.setAttribute('transform', transform);\n};\n\nexport var updateMarkupTextSvgHitarea = function updateMarkupTextSvgHitarea(svg, w, h, editor) {\n\n  var hitarea = svg.hitarea;\n  var hitareaMargin = editor.sizeFromClientToMarkups(0, MARKUP_DEFAULT_HITAREAS_MARGIN_IN_PIXELS).y;\n\n  hitarea.setAttribute('x', -hitareaMargin);\n  hitarea.setAttribute('y', -hitareaMargin);\n  hitarea.setAttribute('width', w + hitareaMargin * 2);\n  hitarea.setAttribute('height', h + hitareaMargin * 2);\n  svg.setAttribute(\"pointer-events\", editor.navigating ? \"none\" : \"painted\");\n};\n\nexport var updateMarkupTextSvgBackground = function updateMarkupTextSvgBackground(svg, w, h, color) {\n\n  var background = svg.background;\n\n  background.setAttribute('x', 0);\n  background.setAttribute('y', 0);\n  background.setAttribute('width', w);\n  background.setAttribute('height', h);\n  background.setAttribute('fill', color);\n};\n\nexport var updateMarkupTextSvgClipper = function updateMarkupTextSvgClipper(svg, w, h) {\n\n  var clipper = svg.clipper;\n\n  clipper.rect.setAttribute('x', 0);\n  clipper.rect.setAttribute('y', 0);\n  clipper.rect.setAttribute('width', w);\n  clipper.rect.setAttribute('height', h);\n};\n\n/**\n    * Helper function that injects metadata for the whole Markup document.\n    * Metadata includes: version.\n    * @param {Element} svg - an SVGElement\n    * @param {Object} metadata - Dictionary with attributes\n    */\nexport var addSvgMetadata = function addSvgMetadata(svg, metadata) {\n\n  var _document = this && this.getDocument && this.getDocument() || _gDocument;\n\n  var metadataNode = _document.createElementNS('http://www.w3.org/2000/svg', 'metadata');\n  var dataVersionNode = _document.createElement('markup_document');\n\n  metadataNode.appendChild(dataVersionNode);\n\n  // NOTE: We could iterate over the properties, but we don't because these are the only ones supported\n  dataVersionNode.setAttribute(\"data-model-version\", metadata[\"data-model-version\"]); // Version. For example: \"1\"\n\n  svg.insertBefore(metadataNode, svg.firstChild);\n  return metadataNode;\n};\n\n/**\n    * Helper function that injects metadata for specific markup svg nodes.\n    * @param {Element} markupNode - an SVGElement for the markup\n    * @param {Object} metadata - Dictionary where all key/value pairs are added as metadata entries.\n    * @returns {Element}\n    */\nexport var addMarkupMetadata = function addMarkupMetadata(markupNode, metadata) {\n\n  var _document = this && this.getDocument && this.getDocument() || _gDocument;\n\n  var metadataNode = _document.createElementNS('http://www.w3.org/2000/svg', 'metadata');\n  var dataVersionNode = _document.createElement('markup_element');\n\n  metadataNode.appendChild(dataVersionNode);\n  for (var key in metadata) {\n    if (metadata.hasOwnProperty(key)) {\n      dataVersionNode.setAttribute(key, metadata[key]);\n    }\n  }\n\n  markupNode.insertBefore(metadataNode, markupNode.firstChild);\n  return metadataNode;\n};\n\n/**\n    * Removes al metadata nodes from an Svg node structure.\n    * Method will remove all metadata nodes from children nodes as well.\n    * @param svgNode\n    */\nexport var removeAllMetadata = function removeAllMetadata(svgNode) {\n\n  if (svgNode.getElementsByTagName) {\n    var nodes = svgNode.getElementsByTagName(\"metadata\");\n    for (var i = 0; i < nodes.length; ++i) {\n      var metadataNode = nodes[i];\n      metadataNode.parentNode && metadataNode.parentNode.removeChild(metadataNode);\n    }\n  }\n\n  // Transverse children nodes\n  var svgChildren = svgNode.children || svgNode.childNodes;\n  if (svgChildren) {\n    for (i = 0; i < svgChildren.length; ++i) {\n      removeAllMetadata(svgChildren[i]);\n    }\n  }\n};\n\n/**\n    * Utility function that transfers children from an Html/Svg node into another one.\n    * @param nodeFrom - The node instance from where children will be taken.\n    * @param nodeInto - The node that's going to parent the transferred children.\n    */\nexport var transferChildNodes = function transferChildNodes(nodeFrom, nodeInto) {\n\n  var svgChildren = nodeFrom.children || nodeFrom.childNodes;\n  var tmpArray = [];\n  for (var i = 0; i < svgChildren.length; ++i) {\n    tmpArray.push(svgChildren[i]); // Avoid appendChild\n  }\n  tmpArray.forEach(function (node) {\n    nodeInto.appendChild(node);\n  });\n};\n\n/**\n    * Generate a unique id.\n    * @returns {string}\n    */\nexport var getUniqueID = function getUniqueID() {\n  return THREE.Math.generateUUID();\n};\n\n\n/**\n    * Serializes an SVG node into a String.\n    * @param domNode\n    * @returns {string}\n    */\nexport var svgNodeToString = function svgNodeToString(domNode) {\n\n  function removeHitareas(svg, hitareas) {\n\n    var hitarea = svg.hitarea;\n    var hitareaParent = hitarea && hitarea.parentNode;\n\n    if (hitareaParent) {\n\n      hitareas.push({ hitarea: hitarea, parent: hitareaParent });\n      hitareaParent.removeChild(hitarea);\n    }\n\n    var children = svg.childNodes;\n    var childrenCount = children.length;\n\n    for (var i = 0; i < childrenCount; ++i) {\n      removeHitareas(children.item(i), hitareas);\n    }\n  }\n\n  function addHitareas(hitareas) {\n\n    var hitareasCount = hitareas.length;\n    for (var i = 0; i < hitareasCount; ++i) {\n\n      var hitarea = hitareas[i];\n      hitarea.parent.appendChild(hitarea.hitarea);\n    }\n  }\n\n  var result;\n  try {\n    var hitareas = [];\n    removeHitareas(domNode, hitareas);\n\n    var xmlSerializer = new XMLSerializer();\n    result = xmlSerializer.serializeToString(domNode);\n\n    addHitareas(hitareas);\n\n  } catch (err) {\n    result = '';\n    console.warn('svgNodeToString failed to generate string representation of domNode.');\n  }\n  return result;\n};\n\nexport var stringToSvgNode = function stringToSvgNode(stringNode) {\n\n  var node = null;\n  try {\n    var domParser = new DOMParser();\n    var doc = domParser.parseFromString(stringNode, \"text/xml\");\n    node = doc.firstChild; // We should only be getting 1 child anyway.\n  } catch (err) {\n    node = null;\n    console.warn('stringToSvgNode failed to generate an HTMLElement from its string representation.');\n  }\n  return node;\n};\n\n/**\n    * Injects functions and members to a client object which will\n    * receive the ability to dispatch events.\n    * Mechanism is the same as in Autodesk.Viewing.Viewer.\n    *\n    * Note: All of the code here comes from Autodesk.Viewing.Viewer\n    *\n    * @param {Object} client - Object that will become an event dispatcher.\n    */\nexport var addTraitEventDispatcher = function addTraitEventDispatcher(client) {\n\n  // Inject member variable\n  client.listeners = {};\n\n  // Inject functions\n  client.addEventListener = function (type, listener) {\n    if (typeof this.listeners[type] == \"undefined\") {\n      this.listeners[type] = [];\n    }\n    this.listeners[type].push(listener);\n  };\n  client.hasEventListener = function (type, listener) {\n    if (this.listeners === undefined) return false;\n    var listeners = this.listeners;\n    if (listeners[type] !== undefined && listeners[type].indexOf(listener) !== -1) {\n      return true;\n    }\n    return false;\n  };\n  client.removeEventListener = function (type, listener) {\n    if (this.listeners[type] instanceof Array) {\n      var li = this.listeners[type];\n      for (var i = 0, len = li.length; i < len; i++) {\n        if (li[i] === listener) {\n          li.splice(i, 1);\n          break;\n        }\n      }\n    }\n  };\n  client.dispatchEvent = function (event) {\n    if (typeof event == \"string\") {\n      event = { type: event };\n    }\n    if (!event.target) {\n      event.target = this;\n    }\n\n    if (!event.type) {\n      throw new Error(\"event type unknown.\");\n    }\n\n    if (this.listeners[event.type] instanceof Array) {\n      var typeListeners = this.listeners[event.type].slice();\n      for (var i = 0; i < typeListeners.length; i++) {\n        typeListeners[i].call(this, event);\n      }\n    }\n  };\n};\n\n/**\n    * Removes the EventDispatcher trait\n    *\n    * @param {Object} client\n    */\nexport var removeTraitEventDispatcher = function removeTraitEventDispatcher(client) {\n\n  try {\n    delete client.listeners;\n    delete client.addEventListener;\n    delete client.hasEventListener;\n    delete client.removeEventListener;\n    delete client.dispatchEvent;\n  } catch (e) {\n    // nothing\n  }\n};\n\n//// Math  /////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n/**\n * Calculates the pixel position in client space coordinates of a point in world space.\n * @param {THREE.Vector3} point Point in world space coordinates.\n * @param viewer\n * @param snap Round values to closest pixel center.\n * @returns {THREE.Vector3} Point transformed and projected into client space coordinates.\n */\nexport var worldToClient = function worldToClient(point, viewer, snap) {\n\n  var p = worldToViewport(point, viewer);\n  var result = viewportToClient(p.x, p.y, viewer);\n  result.z = 0;\n\n  // snap to the center of the\n  if (snap) {\n    result.x = Math.floor(result.x) + 0.5;\n    result.y = Math.floor(result.y) + 0.5;\n  }\n\n  return result;\n};\n\nexport var clientToWorld = function clientToWorld(clientX, clientY, depth, viewer) {\n\n  var point = clientToViewport(clientX, clientY, viewer);\n  point.z = depth;\n\n  point.unproject(viewer.impl.camera);\n  return point;\n};\n\nexport var clientToViewport = function clientToViewport(clientX, clientY, viewer) {\n\n  return viewer.impl.clientToViewport(clientX, clientY);\n};\n\nexport var viewportToClient = function viewportToClient(viewportX, viewportY, viewer) {\n\n  return viewer.impl.viewportToClient(viewportX, viewportY);\n};\n\n/**\n    * Calculates the world position of a point in client space coordinates.\n    * @param {Object} point - { x:Number, y:Number, z:Number }\n    * @param {Object} viewer - LMV instance\n    * @returns {THREE.Vector3}\n    */\nexport var worldToViewport = function worldToViewport(point, viewer) {\n\n  var p = new THREE.Vector3();\n\n  p.x = point.x;\n  p.y = point.y;\n  p.z = point.z;\n\n  p.project(viewer.impl.camera);\n  return p;\n};\n\nexport var metersToModel = function metersToModel(meters, viewer) {\n\n  var modelToMeter = viewer.model.getUnitScale();\n  var meterToModel = 1 / modelToMeter;\n\n  return meterToModel * meters;\n};\n\nexport var radiansToDegrees = function radiansToDegrees(radians) {\n\n  return radians * (180 / Math.PI);\n};\n\nexport var degreesToRadians = function degreesToRadians(degrees) {\n\n  return degrees * (Math.PI / 180);\n};\n\n/**\n    *\n    * @param value\n    * @returns {number}\n    */\nexport var sign = function sign(value) {\n\n  return value >= 0 ? 1 : -1;\n};\n\n/**\n    *\n    * @param pointA\n    * @param pointB\n    * @param range\n    * @param editor\n    * @returns {boolean}\n    */\nexport var areMarkupsPointsInClientRange = function areMarkupsPointsInClientRange(pointA, pointB, range, editor) {\n\n  range = editor.sizeFromClientToMarkups(0, range).y;\n\n  var dx = pointA.x - pointB.x;\n  var dy = pointA.y - pointB.y;\n\n  return range * range >= dx * dx + dy * dy;\n};\n\n//// LMV ui ////////////////////////////////////////////////////////////////////////////////////////////////////////\n\nexport var hideLmvUi = function hideLmvUi(viewer) {\n\n  // If the viewer is no gui, then there is nothing to hide\n  if (!viewer.toolbar) {\n    return;\n  }\n\n  // Exit other tools and hide HudMessages.\n  viewer.setActiveNavigationTool();\n\n  dismissLmvHudMessage();\n  hideLmvPanels(true, viewer);\n  hideLmvToolsAndPanels(viewer);\n};\n\nexport var restoreLmvUi = function restoreLmvUi(viewer) {\n\n  // If the viewer is no gui, then there is nothing to hide\n  if (!viewer.toolbar) {\n    return;\n  }\n\n  dismissLmvHudMessage();\n  hideLmvPanels(false, viewer);\n  showLmvToolsAndPanels(viewer);\n};\n\n/**\n    *\n    * @param hide\n    * @param viewer\n    */\nexport var hideLmvPanels = function hideLmvPanels(hide, viewer) {\n\n  var dockingPanels = viewer.dockingPanels;\n\n  // Panels may not be present when dealing with an instance of Viewer3D.js\n  // (as opposed to an instance of GuiViewer3D.js)\n  if (!dockingPanels) return;\n\n  for (var i = 0; i < dockingPanels.length; ++i) {\n\n    var panel = dockingPanels[i];\n    var panelContainer = panel.container;\n\n    if (panelContainer.classList.contains(\"dockingPanelVisible\")) {\n      panelContainer.style.display = hide ? \"none\" : \"block\";\n\n      // Call the visibility changed notification if any additional\n      // stuff needs to be done (update the date i.e. PropertyPanel, etc).\n      panel.visibilityChanged();\n    }\n  }\n};\n\n/**\n    * Shows panels and tools in the viewer.\n    * @param viewer\n    */\nexport var showLmvToolsAndPanels = function showLmvToolsAndPanels(viewer) {\n\n  // Restore view cube.\n  if (viewer && viewer.model && !viewer.model.is2d()) {\n    viewer.getExtension(\"Autodesk.ViewCubeUi\", function (ext) {\n      ext.displayViewCube(true, false);\n      ext.displayHomeButton(true);\n    });\n  }\n\n  // TODO: Find or ask for a better way to restore this buttons.\n  var _document = viewer.getDocument();\n  var anim = _document.getElementsByClassName('toolbar-animation-subtoolbar');\n\n  if (anim.length > 0) {\n    anim[0].style.display = '';\n  }\n\n  // toolbar is absent when dealing with an instance of Viewer3D (instead of GuiViewer3D)\n  if (viewer.toolbar) {\n    var viewerContainer = viewer.toolbar.container;\n    var viewerContainerChildrenCount = viewerContainer.children.length;\n    for (var i = 0; i < viewerContainerChildrenCount; ++i) {\n      viewerContainer.children[i].style.display = \"\";\n    }\n  }\n};\n\n/**\n    * Hides panels and tools in the viewer.\n    * @param viewer\n    */\nexport var hideLmvToolsAndPanels = function hideLmvToolsAndPanels(viewer) {\n\n  // Hide Panels and tools.\n  if (viewer && viewer.model && !viewer.model.is2d()) {\n    viewer.getExtension(\"Autodesk.ViewCubeUi\", function (ext) {\n      ext.displayViewCube(false, false);\n      ext.displayHomeButton(false);\n    });\n\n  }\n\n  var _document = viewer.getDocument();\n  // TODO: Find or ask for a better way to hide this buttons.\n  var anim = _document.getElementsByClassName('toolbar-animation-subtoolbar');\n\n  if (anim.length > 0) {\n    anim[0].style.display = 'none';\n\n    var animator = viewer.impl.keyFrameAnimator;\n    if (animator && !animator.isPaused) {\n      animator.pauseCameraAnimations();\n      animator.pause();\n\n      var playButton = viewer.modelTools.getControl('toolbar-animationPlay');\n      if (playButton) {\n        playButton.setIcon('toolbar-animation-pause-icon');\n        playButton.setToolTip('Pause');\n      }\n    }\n  }\n\n  // toolbar is absent when dealing with an instance of Viewer3D (instead of GuiViewer3D)\n  if (viewer.toolbar) {\n    var viewerContainer = viewer.toolbar.container;\n    var viewerContainerChildrenCount = viewerContainer.children.length;\n    for (var i = 0; i < viewerContainerChildrenCount; ++i) {\n      viewerContainer.children[i].style.display = \"none\";\n    }\n  }\n};\n\n/**\n    * Dismisses all LMV HudMessages\n    */\nexport var dismissLmvHudMessage = function dismissLmvHudMessage() {\n\n  // Using try/catch block since we are accessing the Private namespace of LMV.\n  try {\n    var keepDismissing = true;\n    while (keepDismissing) {\n      keepDismissing = Autodesk.Viewing.Private.HudMessage.dismiss();\n    }\n  } catch (ignore) {\n    // Failing to show the message is an okay fallback scenario\n    console.warn(\"[CO2]Failed to dismiss LMV HudMessage\");\n  }\n};\n\n//// Styles ////////////////////////////////////////////////////////////////////////////////////////////////////////\n\nexport var getStrokeWidth = function getStrokeWidth(widthInPixels, editor) {\n\n  var size = editor.sizeFromClientToMarkups(0, widthInPixels);\n  return size.y;\n};\n\n/**\n    * Creates markups from a parsed svg string child\n    * @param child - child of a parsed SVG string\n    * @param editor - MarkupsCore\n    * @returns {*} Markup Object\n    */\nexport var createMarkupFromSVG = function createMarkupFromSVG(child, editor) {\n  // var self = this;\n  if (!child.childNodes[0]) {\n    return null;\n  }\n\n  var meta = child.childNodes[0].childNodes[0] || '';\n\n  var getCurrentStyle = function getCurrentStyle(editor, metadata) {\n\n    var source = ['stroke-width', 'stroke-color', 'stroke-opacity', 'fill-color', 'fill-opacity',\n    'font-family', 'font-size', 'font-style', 'font-weight', 'stroke-linejoin'];\n    var style = {};\n    for (var i = 0; i < source.length; i++) {\n      var value = metadata.getAttribute(source[i]);\n      if (value == null) {\n        continue;\n      }\n      switch (source[i]) {\n        case 'font-size':\n        case 'stroke-width':\n        case 'stroke-opacity':\n        case 'fill-opacity':\n          style[source[i]] = parseFloat(value);\n          break;\n        case 'stroke-linejoin':\n          break;\n        case 'font-family':\n        case 'font-style':\n        case 'font-weight':\n        case 'stroke-color':\n        case 'text-data':\n        case 'fill-color':\n          style[source[i]] = value;\n          break;\n        default:\n          avp.logger.warn('Style not recognized.');\n          break;}\n\n    }\n    return style;\n  };\n\n  var isClosed = function isClosed() {\n    var path = child.childNodes[1] || '';\n    var closed = false;\n    if (typeof path !== 'string') {\n      var d = path.getAttribute('d').split(' ');\n      if (d[d.length - 1].toLowerCase() === 'z') {\n        closed = true;\n      }\n    }\n    return closed;\n  };\n\n  var getLocations = function getLocations() {\n    var locations = [];\n    var locStr = meta.getAttribute('locations').split(\" \") || '';\n\n    for (var i = 0; i < locStr.length; i += 2) {\n      var pointPair = { x: parseFloat(locStr[i]), y: parseFloat(locStr[i + 1]) };\n      locations.push(pointPair);\n    }\n    return locations;\n  };\n\n  var getAttributeVector = function getAttributeVector(attribute) {\n    var posVec = new THREE.Vector3();\n    var value = meta.getAttribute(attribute) || meta.getAttribute(attribute.toLowerCase());\n    var strPos = value.split(\" \");\n    posVec.x = parseFloat(strPos[0]);\n    posVec.y = parseFloat(strPos[1]);\n    return posVec;\n  };\n\n  var getPosition = function getPosition() {\n    return getAttributeVector('position');\n  };\n\n  var getSize = function getSize() {\n    return getAttributeVector('size');\n  };\n\n  var getRotation = function getRotation() {\n    var strRot = meta.getAttribute('rotation') || '';\n    return parseFloat(strRot);\n  };\n\n  var getText = function getText() {\n    return meta.getAttribute('text') || '';\n  };\n\n  var getIsFrameUsed = function getIsFrameUsed() {\n    return !!parseInt(meta.getAttribute('isframeused'));\n  };\n\n  if (typeof meta !== 'string') {\n    // get the type of the child\n    var position, size, rotation, locations, tail, head, closed, text, firstAnchor, secondAnchor;\n    var id = editor.getId();\n    var style = getCurrentStyle(editor, meta);\n    var type = meta.getAttribute('type') || '';\n    var createMarkup;\n    switch (type) {\n      case MarkupType.MARKUP_TYPE_ARROW:\n        tail = getAttributeVector('tail');\n        head = getAttributeVector('head');\n        createMarkup = new CreateArrow(editor, id, tail, head, style);\n        break;\n\n      case MarkupType.MARKUP_TYPE_RECTANGLE:\n        position = getPosition();\n        size = getSize();\n        rotation = getRotation();\n        createMarkup = new CreateRectangle(editor, id, position, size, rotation, style);\n        break;\n\n      case MarkupType.MARKUP_TYPE_TEXT:\n        position = getPosition();\n        size = getSize();\n        text = getText();\n        createMarkup = new CreateText(editor, id, position, size, text, style);\n        break;\n\n      case MarkupType.MARKUP_TYPE_CALLOUT:\n        position = getPosition();\n        size = getSize();\n        text = getText();\n        var isFrameUsed = getIsFrameUsed();\n        createMarkup = new CreateCallout(editor, id, position, size, text, style, isFrameUsed);\n        break;\n\n      case MarkupType.MARKUP_TYPE_CIRCLE:\n        position = getPosition();\n        size = getSize();\n        rotation = getRotation();\n        createMarkup = new CreateCircle(editor, id, position, size, rotation, style);\n        break;\n\n      case MarkupType.MARKUP_TYPE_CLOUD:\n        position = getPosition();\n        size = getSize();\n        rotation = getRotation();\n        createMarkup = new CreateCloud(editor, id, position, size, rotation, style);\n        break;\n\n      case MarkupType.MARKUP_TYPE_FREEHAND:\n        position = getPosition();\n        size = getSize();\n        rotation = getRotation();\n        locations = getLocations();\n        createMarkup = new CreateFreehand(editor, id, position, size, rotation, locations, style);\n        break;\n\n      case MarkupType.MARKUP_TYPE_POLYLINE:\n        position = getPosition();\n        size = getSize();\n        rotation = getRotation();\n        locations = getLocations();\n        closed = isClosed();\n        createMarkup = new CreatePolyline(editor, id, position, size, rotation, locations, style, closed);\n        break;\n\n      case MarkupType.MARKUP_TYPE_POLYCLOUD:\n        position = getPosition();\n        size = getSize();\n        rotation = getRotation();\n        locations = getLocations();\n        closed = isClosed();\n        createMarkup = new CreatePolycloud(editor, id, position, size, rotation, locations, style, closed);\n        break;\n\n      case MarkupType.MARKUP_TYPE_HIGHLIGHT:\n        position = getPosition();\n        size = getSize();\n        rotation = getRotation();\n        locations = getLocations();\n        createMarkup = new CreateHighlight(editor, id, position, size, rotation, locations, style);\n        break;\n\n      case MarkupType.MARKUP_TYPE_DIMENSION:\n        firstAnchor = getAttributeVector('firstAnchor');\n        secondAnchor = getAttributeVector('secondAnchor');\n        text = getText();\n        createMarkup = new CreateDimension(editor, id, firstAnchor, secondAnchor, text, style);\n        break;\n\n      case MarkupType.MARKUP_TYPE_STAMP:\n        position = getPosition();\n        size = getSize();\n        rotation = getRotation();\n        createMarkup = new CreateStamp(editor, id, position, size, rotation, style, child);\n        break;\n\n      default:\n        createMarkup = null;\n        break;}\n\n    if (createMarkup) {\n      createMarkup.addToHistory = false;\n      createMarkup.execute();\n      var markupList = editor.svgLayersMap[editor.activeLayer].markups;\n\n      for (var i = 0; i < markupList.length; ++i) {\n        if (markupList[i].id === id) {\n          return markupList[i];\n        }\n      }\n    }\n    return null;\n  }\n};\n\n\nexport var composeRGBAString = function composeRGBAString(hexRGBString, opacity) {\n\n  if (!hexRGBString || !opacity || opacity <= 0) {\n    return 'none';\n  }\n\n  return ['rgba(' +\n  parseInt('0x' + hexRGBString.substr(1, 2)), ',',\n  parseInt('0x' + hexRGBString.substr(3, 2)), ',',\n  parseInt('0x' + hexRGBString.substr(5, 2)), ',', opacity, ')'].join('');\n};\n\n//// Id Target Collision ///////////////////////////////////////////////////////////////////////////////////////////\n\n/**\n *\n * @param x0\n * @param y0\n * @param x1\n * @param y1\n * @param idTarget\n */\nexport var checkLineSegment = function checkLineSegment(x0, y0, x1, y1, idTarget) {\n\n  var _window = this && this.getWindow && this.getWindow() || _gWindow;\n  var deviceRatio = _window.devicePixelRatio || 1;\n\n  x0 *= deviceRatio;\n  y0 *= deviceRatio;\n  x1 *= deviceRatio;\n  y1 *= deviceRatio;\n\n  var idTargetWidth = idTarget.width;\n  var idTargetHeight = idTarget.height;\n  var idTargetBuffer = idTarget.buffer;\n\n  x0 = Math.round(x0);\n  x1 = Math.round(x1);\n  y0 = Math.round(idTargetHeight - y0);\n  y1 = Math.round(idTargetHeight - y1);\n\n  function point(x, y) {\n\n    x = Math.round(x);\n    y = Math.round(y);\n\n    var dx = 0;\n    var dy = 0;\n\n    for (var j = -deviceRatio; j <= deviceRatio; j += deviceRatio * 2) {\n      dy += check(x, y + j) ? j : 0;\n    }\n\n    for (var i = -deviceRatio; i <= deviceRatio; i += deviceRatio * 2) {\n      dx += check(x + i, y) ? i : 0;\n    }\n\n    return {\n      x: Math.round(x / deviceRatio + dx),\n      y: Math.round((idTargetHeight - y) / deviceRatio - dy) };\n  }\n\n  function check(x, y) {\n\n    // Probably better to clip line at the beginning.\n    if (x < 0 || x >= idTargetWidth ||\n    y < 0 || y >= idTargetHeight) {\n      return false;\n    }\n\n    var index = (y * idTargetWidth + x) * 4;\n    return (\n      idTargetBuffer[index] !== 0xFF ||\n      idTargetBuffer[index + 1] !== 0xFF ||\n      idTargetBuffer[index + 2] !== 0xFF);\n  }\n\n  // DDA Line algorithm\n  var dx = x1 - x0;\n  var dy = y1 - y0;\n\n  var m = dx !== 0 ? dy / dx : 1;\n  var x = x0;\n  var y = y0;\n\n  if (dx !== 0 && Math.abs(m) <= 1) {\n\n    if (x0 <= x1) {\n      for (; x <= x1; ++x, y += m) {\n        if (check(x, Math.round(y))) {\n          return point(x, y);\n        }\n      }\n    } else {\n      for (; x >= x1; --x, y -= m) {\n        if (check(x, Math.round(y))) {\n          return point(x, y);\n        }\n      }\n    }\n  } else {\n\n    m = dx !== 0 ? 1 / m : 0;\n    if (y0 <= y1) {\n      for (; y <= y1; ++y, x += m) {\n        if (check(Math.round(x), y)) {\n          return point(x, y);\n        }\n      }\n    } else {\n      for (; y >= y1; --y, x -= m) {\n        if (check(Math.round(x), y)) {\n          return point(x, y);\n        }\n      }\n    }\n  }\n};\n\n/**\n    *\n    * @param polygon\n    * @param idTarget\n    */\nexport var checkPolygon = function checkPolygon(polygon, idTarget) {\n\n  // Return if incorrect parameters.\n  if (!polygon || polygon.verxtexCount < 3 || !idTarget) {\n    return null;\n  }\n\n  var _window = this && this.getWindow && this.getWindow() || _gWindow;\n  var deviceRatio = _window.devicePixelRatio || 1;\n\n  var idTargetWidth = idTarget.width;\n  var idTargetHeight = idTarget.height;\n  var idTargetBuffer = idTarget.buffer;\n\n  var vertexCount = polygon.vertexCount;\n  var xVertices = Float32Array.from(polygon.xVertices); // Clone to scale by device pixel ratio and to\n  var yVertices = Float32Array.from(polygon.yVertices); // change y coordinates to OpenGL style.\n\n  function point(x, y) {\n\n    var dx = 0;\n    var dy = 0;\n\n    for (var j = -deviceRatio; j <= deviceRatio; j += deviceRatio * 2) {\n      dy += check(x, y + j) ? j : 0;\n    }\n\n    for (var i = -deviceRatio; i <= deviceRatio; i += deviceRatio * 2) {\n      dx += check(x + i, y) ? i : 0;\n    }\n\n    return {\n      x: Math.round(x / deviceRatio) + dx,\n      y: Math.round((idTargetHeight - y) / deviceRatio - dy) };\n  }\n\n  function check(x, y) {\n\n    if (x < 0 || x >= idTargetWidth ||\n    y < 0 || y >= idTargetHeight) {\n      return false;\n    }\n\n    var index = (y * idTargetWidth + x) * 4;\n    return (\n    idTargetBuffer[index] !== 0xFF ||\n    idTargetBuffer[index + 1] !== 0xFF ||\n    idTargetBuffer[index + 2] !== 0xFF) && isInsidePolygon(x, y);\n  }\n\n  function isInsidePolygon(x, y) {\n\n    var result = false;\n    var vertexCount = polygon.vertexCount;\n    for (var i = 0, j = vertexCount - 1; i < vertexCount; j = i++) {\n\n      if (yVertices[i] > y != yVertices[j] > y &&\n      x < (xVertices[j] - xVertices[i]) * (y - yVertices[i]) / (yVertices[j] - yVertices[i]) + xVertices[i]) {\n        result = !result;\n      }\n    }\n    return result;\n  }\n\n  // Change coordinates to OpenGL style and calculate polygon's bounding box.\n  var bbX0 = Number.POSITIVE_INFINITY;\n  var bbY0 = Number.POSITIVE_INFINITY;\n  var bbX1 = Number.NEGATIVE_INFINITY;\n  var bbY1 = Number.NEGATIVE_INFINITY;\n\n  for (var i = 0; i < vertexCount; ++i) {\n\n    var bbX = xVertices[i] = xVertices[i] * deviceRatio;\n    var bbY = yVertices[i] = idTargetHeight - yVertices[i] * deviceRatio;\n\n    bbX0 = Math.min(bbX0, bbX);\n    bbY0 = Math.min(bbY0, bbY);\n    bbX1 = Math.max(bbX1, bbX);\n    bbY1 = Math.max(bbY1, bbY);\n  }\n\n  if (bbX1 < 0 || bbX0 > idTargetWidth ||\n  bbY1 < 0 || bbY0 > idTargetHeight) {\n    return null;\n  }\n\n  var bbW = Math.round(bbX1 - bbX0);\n  var bbH = Math.round(bbY1 - bbY0);\n\n  var bbCenterX = Math.round((bbX0 + bbX1) * 0.5);\n  var bbCenterY = Math.round((bbY0 + bbY1) * 0.5);\n\n  // Check\n  var x = bbCenterX;\n  var y = bbCenterY;\n\n  var w = 1;\n  var h = 1;\n\n  do {\n\n    var endX = x + w;\n    var endY = y + h;\n\n    for (; x < endX; ++x) {\n      if (check(x, y)) {\n        return point(x, y);\n      }\n    }\n\n    for (; y < endY; ++y) {\n      if (check(x, y)) {\n        return point(x, y);\n      }\n    }\n\n    if (w < bbW) {\n      endX = x - ++w;++w;\n    } else {\n      endX = x - w;\n    }\n\n    if (h < bbH) {\n      endY = y - ++h;++h;\n    } else {\n      endY = y - h;\n    }\n\n    for (; x > endX; --x) {\n      if (check(x, y)) {\n        return point(x, y);\n      }\n    }\n\n    for (; y > endY; --y) {\n      if (check(x, y)) {\n        return point(x, y);\n      }\n    }\n  } while (w < bbW || h < bbH);\n};\n\n//// CSS ///////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n/**\n *\n * @returns {*}\n */\nexport var createStyleSheet = function createStyleSheet() {\n\n  var _document = this && this.getDocument && this.getDocument() || _gDocument;\n  var style = _document.createElement(\"style\");\n\n  // This is WebKit hack.\n  style.appendChild(_document.createTextNode(\"\"));\n  _document.head.appendChild(style);\n\n  return style.sheet;\n};\n\n/**\n    *\n    * @param styleSheet\n    * @param selector\n    * @param styles\n    * @param index\n    */\nexport var addRuleToStyleSheet = function addRuleToStyleSheet(styleSheet, selector, styles, index) {\n\n  if (\"insertRule\" in styleSheet) {\n    styleSheet.insertRule(selector + \"{\" + styles + \"}\", index);\n  } else\n  if (\"addRule\" in styleSheet) {\n    styleSheet.addRule(selector, styles, index);\n  }\n};\n\n//// SVG ///////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n/**\n *\n * @param lines\n * @param style\n * @param editor\n */\nexport var measureTextLines = function measureTextLines(lines, style, editor) {\n\n  // Measure div style is line style with some custom layout properties.\n  var fontSize = editor.sizeFromMarkupsToClient(0, style['font-size']).y;\n\n  var measureStyle = new DomElementStyle().\n  setAttribute('font-family', style['font-family']).\n  setAttribute('font-size', fontSize + 'px').\n  setAttribute('font-weight', style['font-weight'] ? 'bold' : '').\n  setAttribute('font-style', style['font-style'] ? 'italic' : '').\n\n  removeAttribute(['top', 'left', 'width', 'height', 'overflow-y']).\n  setAttribute('position', 'absolute').\n  setAttribute('white-space', 'nowrap').\n  setAttribute('float', 'left').\n  setAttribute('visibility', 'hidden').\n  getStyleString();\n\n  var _document = this && this.getDocument && this.getDocument() || _gDocument;\n  // Create measure div.\n  var measure = _document.createElement('div');\n\n  measure.setAttribute('style', measureStyle);\n  editor.viewer.container.appendChild(measure);\n\n  // Measure.\n  var result = [];\n\n  var linesCount = lines.length;\n  for (var i = 0; i < linesCount; ++i) {\n\n    measure.innerText = lines[i];\n    result.push({\n      line: lines[i],\n      width: measure.clientWidth,\n      height: measure.clientHeight });\n\n  }\n\n  // Remove measure div and return result.\n  editor.viewer.container.removeChild(measure);\n  return result;\n};\n\nexport var createArcTo = function createArcTo(x, y, xRadius, yRadius, relative, path) {\n\n  path.push(relative ? 'a' : 'A');\n  path.push(xRadius);\n  path.push(yRadius);\n  path.push(0);\n  path.push(1);\n  path.push(1);\n  path.push(x);\n  path.push(y);\n\n  return path;\n};\n\nexport var createEllipsePath = function createEllipsePath(x, y, w, h, relative, path) {\n\n  var halfW = w * 0.5;\n  var halfH = h * 0.5;\n\n  path.push(relative ? 'm' : 'M');\n  path.push(x);\n  path.push(y);\n\n  createArcTo(w, 0, halfW, halfH, true, path);\n  createArcTo(-w, 0, halfW, halfH, true, path);\n\n  path.push('z');\n};\n\nexport var createRectanglePath = function createRectanglePath(x, y, w, h, relative, path) {\n\n  path.push(relative ? 'm' : 'M');\n  path.push(x);\n  path.push(y);\n  path.push('l');\n  path.push(w);\n  path.push(0);\n  path.push('l');\n  path.push(0);\n  path.push(h);\n  path.push('l');\n  path.push(-w);\n  path.push(0);\n  path.push('z');\n};\n\nexport var renderToCanvas = function renderToCanvas(svg, viewBox, width, height, ctx, callback) {\n\n  // Creating a new svg element, that will be drawn into the canvas.\n  var tmpSvg = createSvgElement('svg');\n\n  if (!av.isIE11) {\n    tmpSvg.setAttribute('xmlns', 'http://www.w3.org/2000/svg');\n  }\n\n  tmpSvg.setAttribute('width', width);\n  tmpSvg.setAttribute('height', height);\n  tmpSvg.setAttribute('viewBox', viewBox);\n  tmpSvg.setAttribute('transform', 'scale(1,-1)');\n\n  var markupGroup = svg.parentNode.cloneNode(true);\n\n  // Adding the markup itself to the temp SVG\n  tmpSvg.appendChild(markupGroup);\n\n  var _window = this && this.getWindow && this.getWindow() || _gWindow;\n  var _document = this && this.getDocument && this.getDocument() || _gDocument;\n  // Get the SVG as string\n  var temp = _document.createElement('div');\n  var node = tmpSvg.cloneNode(true);\n  temp.appendChild(node);\n  var data = temp.innerHTML;\n\n  tmpSvg = temp = node = null;\n\n  var img = new Image();\n\n  img.onload = function () {\n    ctx.drawImage(img, 0, 0);\n    callback();\n  };\n\n  img.src = 'data:image/svg+xml;base64,' + _window.btoa(unescape(encodeURIComponent(data)));\n};\n\n/*\n    Taken from Simplify.js, a high-performance JS polyline simplification library\n    (c) 2013, Vladimir Agafonkin\n    mourner.github.io/simplify-js\n   */\nexport var simplify = function simplify(points, tolerance, highestQuality) {\n\n  if (points.length <= 2) return points;\n\n  // square distance between 2 points\n  function getSqDist(p1, p2) {\n\n    var dx = p1.x - p2.x,\n    dy = p1.y - p2.y;\n\n    return dx * dx + dy * dy;\n  }\n\n  // square distance from a point to a segment\n  function getSqSegDist(p, p1, p2) {\n\n    var x = p1.x,\n    y = p1.y,\n    dx = p2.x - x,\n    dy = p2.y - y;\n\n    if (dx !== 0 || dy !== 0) {\n\n      var t = ((p.x - x) * dx + (p.y - y) * dy) / (dx * dx + dy * dy);\n\n      if (t > 1) {\n        x = p2.x;\n        y = p2.y;\n\n      } else if (t > 0) {\n        x += dx * t;\n        y += dy * t;\n      }\n    }\n\n    dx = p.x - x;\n    dy = p.y - y;\n\n    return dx * dx + dy * dy;\n  }\n  // rest of the code doesn't care about point format\n\n  // basic distance-based simplification\n  function simplifyRadialDist(points, sqTolerance) {\n\n    var prevPoint = points[0],\n    newPoints = [prevPoint],\n    point;\n\n    for (var i = 1, len = points.length; i < len; i++) {\n      point = points[i];\n\n      if (getSqDist(point, prevPoint) > sqTolerance) {\n        newPoints.push(point);\n        prevPoint = point;\n      }\n    }\n\n    if (prevPoint !== point) newPoints.push(point);\n\n    return newPoints;\n  }\n\n  function simplifyDPStep(points, first, last, sqTolerance, simplified) {\n    var maxSqDist = sqTolerance,\n    index;\n\n    for (var i = first + 1; i < last; i++) {\n      var sqDist = getSqSegDist(points[i], points[first], points[last]);\n\n      if (sqDist > maxSqDist) {\n        index = i;\n        maxSqDist = sqDist;\n      }\n    }\n\n    if (maxSqDist > sqTolerance) {\n      if (index - first > 1) simplifyDPStep(points, first, index, sqTolerance, simplified);\n      simplified.push(points[index]);\n      if (last - index > 1) simplifyDPStep(points, index, last, sqTolerance, simplified);\n    }\n  }\n\n  // simplification using Ramer-Douglas-Peucker algorithm\n  function simplifyDouglasPeucker(points, sqTolerance) {\n    var last = points.length - 1;\n\n    var simplified = [points[0]];\n    simplifyDPStep(points, 0, last, sqTolerance, simplified);\n    simplified.push(points[last]);\n\n    return simplified;\n  }\n\n  // both algorithms combined for awesome performance\n  var sqTolerance = tolerance !== undefined ? tolerance * tolerance : 1;\n\n  points = highestQuality ? points : simplifyRadialDist(points, sqTolerance);\n  points = simplifyDouglasPeucker(points, sqTolerance);\n\n  return points;\n};","\n/**\n * \n * @param {*} attributes \n * @param {*} editor \n */\nexport var createStyle = function createStyle(attributes, editor) {\n\n  var style = {};\n\n  for (var i = 0; i < attributes.length; ++i) {\n\n    style[attributes[i]] = null;\n  }\n\n  var defaults = getStyleDefaultValues(style, editor);\n\n  for (var i = 0; i < attributes.length; ++i) {\n\n    var attribute = attributes[i];\n    style[attribute] = defaults[attribute].values[defaults[attribute].default].value;\n  }\n\n  return style;\n};\n\n/**\n    *\n    * @param source\n    * @param destination\n    * @returns {*}\n    */\nexport var copyStyle = function copyStyle(source, destination) {\n\n  for (var attribute in destination) {\n    if (source.hasOwnProperty(attribute)) {\n      destination[attribute] = source[attribute];\n    }\n  }\n\n  return destination;\n};\n\n/**\n    *\n    * @param source\n    * @param destination\n    * @returns {*}\n    */\nexport var isStyleEqual = function isStyleEqual(source, destination) {\n\n  for (var attribute in destination) {\n    if (source.hasOwnProperty(attribute) && source[attribute] !== destination[attribute]) {\n      return false;\n    }\n  }\n\n  return true;\n};\n\n/**\n    *\n    * @param source\n    * @returns {{}}\n    */\nexport var cloneStyle = function cloneStyle(source) {\n\n  var clone = {};\n\n  for (var attribute in source) {\n    clone[attribute] = source[attribute];\n  }\n\n  return clone;\n};\n\n/**\n    *\n    * @param style\n    * @param editor\n    * @returns {{}}\n    */\nexport var getStyleDefaultValues = function getStyleDefaultValues(style, editor) {\n\n  function getWidths(normalWidth) {\n\n    return {\n      values: [\n      { name: 'Thin', value: normalWidth / 3 },\n      { name: 'Normal', value: normalWidth },\n      { name: 'Thick', value: normalWidth * 3 },\n      { name: 'Very Thick', value: normalWidth * 9 }],\n      default: 1 };\n\n  }\n\n  function getLineJoins() {\n\n    return {\n      values: [\n      { name: 'Miter', value: 'miter' },\n      { name: 'Round', value: 'round' },\n      { name: 'Bevel', value: 'bevel' }],\n      default: 0 };\n\n  }\n\n  function getFontSizes(normalWidth) {\n\n    return {\n      values: [\n      { name: 'Thin', value: normalWidth / 2 },\n      { name: 'Normal', value: normalWidth },\n      { name: 'Thick', value: normalWidth * 4 }],\n      default: 1 };\n\n  }\n\n  function getColors() {\n\n    return {\n      values: [\n      { name: 'red', value: '#ff0000' },\n      { name: 'green', value: '#00ff00' },\n      { name: 'blue', value: '#0000ff' },\n      { name: 'white', value: '#ffffff' },\n      { name: 'black', value: '#000000' },\n      { name: 'yellow', value: '#ffff00' }],\n      default: 0 };\n\n  }\n\n  function getOpacities(defaultTransparent) {\n\n    return {\n      values: [\n      { name: '100%', value: 1.00 },\n      { name: '75%', value: 0.75 },\n      { name: '50%', value: 0.50 },\n      { name: '25%', value: 0.25 },\n      { name: '0%', value: 0.00 }],\n      default: defaultTransparent ? 4 : 0 };\n\n  }\n\n  function getFontFamilies() {\n\n    // TODO: Localize?\n    // TODO: Validate fonts with design\n    // Source: http://www.webdesigndev.com/web-development/16-gorgeous-web-safe-fonts-to-use-with-css\n    return {\n      values: [\n      { name: 'Arial', value: 'Arial' },\n      { name: 'Arial Black', value: 'Arial Black' },\n      { name: 'Arial Narrow', value: 'Arial Narrow' },\n      { name: 'Century Gothic', value: 'Century Gothic' },\n      { name: 'Courier New', value: 'Courier New' },\n      { name: 'Georgia', value: 'Georgia' },\n      { name: 'Impact', value: 'Impact' },\n      { name: 'Lucida Console', value: 'Lucida Console' },\n      { name: 'Tahoma', value: 'Tahoma' },\n      { name: 'Verdana', value: 'Verdana' }],\n\n      default: 0 };\n\n  }\n\n  function getFontStyles() {\n    return {\n      values: [\n      { name: 'Normal', value: 'normal' },\n      { name: 'Italic', value: 'italic' }],\n      default: 0 };\n\n  }\n\n  function getFontWeights() {\n    return {\n      values: [\n      { name: 'Normal', value: 'normal' },\n      { name: 'Bold', value: 'bold' }],\n      default: 0 };\n  }\n\n  function getSvgString() {\n    return {\n      values: [\n      {\n        name: 'DefaultValue',\n        value: '<svg height=\"100\" width=\"100\" viewBox=\"0 0 100 100\"><circle cx=\"50\" cy=\"50\" r=\"40\" stroke=\"black\" stroke-width=\"3\" fill=\"red\" /></svg>' }],\n\n\n      default: 0 };\n\n  }\n\n  var values = cloneStyle(style);\n  var normaStrokeWidth = editor.getStrokeWidth();\n  var normaFontWidth = editor.getFontWidth();\n\n  for (var attribute in values) {\n\n    switch (attribute) {\n      case 'stroke-width':\n        values[attribute] = getWidths(normaStrokeWidth);\n        break;\n\n      case 'stroke-linejoin':\n        values[attribute] = getLineJoins();\n        break;\n\n      case 'font-size':\n        values[attribute] = getFontSizes(normaFontWidth);\n        break;\n\n      case 'font-family':\n        values[attribute] = getFontFamilies();\n        break;\n\n      case 'font-style':\n        values[attribute] = getFontStyles();\n        break;\n\n      case 'font-weight':\n        values[attribute] = getFontWeights();\n        break;\n\n      case 'stroke-color':\n      case 'fill-color':\n        values[attribute] = getColors();\n        break;\n\n      case 'stroke-opacity':\n        var defaultTransparent = false;\n        values[attribute] = getOpacities(defaultTransparent);\n        break;\n\n      case 'fill-opacity':\n        var defaultTransparent = true;\n        values[attribute] = getOpacities(defaultTransparent);\n        break;\n\n      case 'text-data':\n        values[attribute] = getSvgString();\n        break;\n\n      default:\n        break;}\n\n  }\n\n  return values;\n};","'use strict';\n\nimport { EditAction } from './EditAction';\n\n/**\n                                            *\n                                            * @param editor\n                                            * @param id\n                                            * @param markup\n                                            * @param position\n                                            * @constructor\n                                            */\nexport function CloneMarkup(editor, id, markup, position) {\n\n  EditAction.call(this, editor, 'CLONE-MARKUP', id);\n\n  this.clone = markup.clone();\n  this.clone.id = id;\n  this.position = { x: position.x, y: position.y };\n}\n\nCloneMarkup.prototype = Object.create(EditAction.prototype);\nCloneMarkup.prototype.constructor = CloneMarkup;\n\nvar proto = CloneMarkup.prototype;\n\nproto.redo = function () {\n\n  var editor = this.editor;\n  var clone = this.clone;\n  var position = this.position;\n\n  if (editor.getMarkup(this.targetId)) {\n    return;\n  }\n\n  var markup = clone.clone();\n  markup.setPosition(position.x, position.y);\n\n  editor.addMarkup(markup);\n};\n\nproto.undo = function () {\n\n  var markup = this.editor.getMarkup(this.targetId);\n  markup && this.editor.removeMarkup(markup);\n};","'use strict';\n\nimport { EditAction } from './EditAction';\nimport { MarkupArrow } from '../MarkupArrow';\nimport { cloneStyle } from '../StyleUtils';\n\n/**\n                                             * @constructor\n                                             */\nexport function CreateArrow(editor, id, head, tail, style) {\n\n  EditAction.call(this, editor, 'CREATE-ARROW', id);\n\n  this.selectOnExecution = false;\n  this.tail = tail;\n  this.head = head;\n  this.style = cloneStyle(style);\n}\n\nCreateArrow.prototype = Object.create(EditAction.prototype);\nCreateArrow.prototype.constructor = CreateArrow;\n\nvar proto = CreateArrow.prototype;\n\nproto.redo = function () {\n\n  var editor = this.editor;\n  var arrow = new MarkupArrow(this.targetId, editor);\n\n  editor.addMarkup(arrow);\n\n  // Confusing naming here. in arrow.set the first two numbers are\n  // the point you drag from and the second two are the point you\n  // drag to. So the head point is actually where the tail of the\n  // arrow is positioned and the tail point is the head is positioned.\n\n  //TODO: In MarkupArrow \"set\" function has tail x, tail y, head x, head y but used here in the opposite way\n  arrow.set(this.head.x, this.head.y, this.tail.x, this.tail.y);\n  arrow.setStyle(this.style);\n};\n\nproto.undo = function () {\n\n  var markup = this.editor.getMarkup(this.targetId);\n  markup && this.editor.removeMarkup(markup);\n};","'use strict';\n\nimport { EditAction } from './EditAction';\nimport { MarkupCallout } from '../MarkupCallout';\nimport { cloneStyle } from '../StyleUtils';\n\n/**\n                                             *\n                                             * @param editor\n                                             * @param id\n                                             * @param position\n                                             * @param size\n                                             * @param text\n                                             * @param style\n                                             * @constructor\n                                             */\nexport function CreateCallout(editor, id, position, size, text, style, isFrameUsed) {\n\n  EditAction.call(this, editor, 'CREATE-CALLOUT', id);\n\n  this.text = text;\n  this.position = { x: position.x, y: position.y };\n  this.size = { x: size.x, y: size.y };\n  this.style = cloneStyle(style);\n  this.isFrameUsed = isFrameUsed;\n}\n\nCreateCallout.prototype = Object.create(EditAction.prototype);\nCreateCallout.prototype.constructor = CreateCallout;\n\nvar proto = CreateCallout.prototype;\n\nproto.redo = function () {\n\n  var editor = this.editor;\n  var position = this.position;\n  var size = this.size;\n\n  var callout = new MarkupCallout(this.targetId, editor, size);\n\n  editor.addMarkup(callout);\n\n  callout.setIsFilledFrameUsed(this.isFrameUsed);\n  callout.setText(this.text);\n  callout.setSize(position, size.x, size.y);\n  callout.setStyle(this.style);\n};\n\nproto.undo = function () {\n\n  var markup = this.editor.getMarkup(this.targetId);\n  if (markup) {\n    this.editor.removeMarkup(markup);\n    markup.destroy();\n  }\n};","'use strict';\n\nimport { EditAction } from './EditAction';\nimport { MarkupCircle } from '../MarkupCircle';\nimport { cloneStyle } from '../StyleUtils';\n\n/**\n                                             * Markup create circle action.\n                                             *\n                                             * Implements an {@link Autodesk.Viewing.Extensions.Markups.Core.EditAction|EditAction}\n                                             * for creating a Circle {@link Autodesk.Viewing.Extensions.Markups.Core.Markup|Markup}.\n                                             * Included in documentation as an example of how to create\n                                             * a specific EditAction that deals with Markup creation.\n                                             * Developers are encourage to look into this class's source code and copy\n                                             * as much code as they need. Find link to source code below.\n                                             *\n                                             * @tutorial feature_markup\n                                             * @constructor\n                                             * @memberof Autodesk.Viewing.Extensions.Markups.Core\n                                             * @extends Autodesk.Viewing.Extensions.Markups.Core.EditAction\n                                             *\n                                             * @param editor\n                                             * @param id\n                                             * @param position\n                                             * @param size\n                                             * @param rotation\n                                             * @param style\n                                             */\nexport function CreateCircle(editor, id, position, size, rotation, style) {\n\n  EditAction.call(this, editor, 'CREATE-CIRCLE', id);\n\n  this.selectOnExecution = false;\n  this.position = { x: position.x, y: position.y };\n  this.size = { x: size.x, y: size.y };\n  this.rotation = rotation;\n  this.style = cloneStyle(style);\n}\n\nCreateCircle.prototype = Object.create(EditAction.prototype);\nCreateCircle.prototype.constructor = CreateCircle;\n\nvar proto = CreateCircle.prototype;\n\nproto.redo = function () {\n\n  var editor = this.editor;\n  var circle = new MarkupCircle(this.targetId, editor);\n\n  editor.addMarkup(circle);\n\n  circle.setSize(this.position, this.size.x, this.size.y);\n  circle.setRotation(this.rotation);\n  circle.setStyle(this.style);\n};\n\nproto.undo = function () {\n\n  var markup = this.editor.getMarkup(this.targetId);\n  markup && this.editor.removeMarkup(markup);\n};","'use strict';\n\nimport { EditAction } from './EditAction';\nimport { MarkupCloud } from '../MarkupCloud';\nimport { cloneStyle } from '../StyleUtils';\n\n/**\n                                             *\n                                             * @param editor\n                                             * @param id\n                                             * @param position\n                                             * @param size\n                                             * @param rotation\n                                             * @param style\n                                             * @constructor\n                                             */\nexport function CreateCloud(editor, id, position, size, rotation, style) {\n\n  EditAction.call(this, editor, 'CREATE-CLOUD', id);\n\n  this.selectOnExecution = false;\n  this.position = { x: position.x, y: position.y };\n  this.size = { x: size.x, y: size.y };\n  this.rotation = rotation;\n  this.style = cloneStyle(style);\n}\n\nCreateCloud.prototype = Object.create(EditAction.prototype);\nCreateCloud.prototype.constructor = CreateCloud;\n\nvar proto = CreateCloud.prototype;\n\nproto.redo = function () {\n\n  var editor = this.editor;\n  var cloud = new MarkupCloud(this.targetId, editor);\n\n  editor.addMarkup(cloud);\n\n  cloud.set(this.position, this.size);\n  cloud.setRotation(this.rotation);\n  cloud.setStyle(this.style);\n};\n\nproto.undo = function () {\n\n  var markup = this.editor.getMarkup(this.targetId);\n  markup && this.editor.removeMarkup(markup);\n};","'use strict';\n\nimport { EditAction } from './EditAction';\nimport { MarkupDimension } from '../MarkupDimension';\nimport { cloneStyle } from '../StyleUtils';\n\n/**\n                                             * @constructor\n                                             */\nexport function CreateDimension(editor, id, firstAnchor, secondAnchor, text, style) {\n\n  EditAction.call(this, editor, 'CREATE-DIMENSION', id);\n\n  this.selectOnExecution = false;\n  this.secondAnchor = secondAnchor;\n  this.firstAnchor = firstAnchor;\n  this.text = text;\n  this.style = cloneStyle(style);\n}\n\nCreateDimension.prototype = Object.create(EditAction.prototype);\nCreateDimension.prototype.constructor = CreateDimension;\n\nvar proto = CreateDimension.prototype;\n\nproto.redo = function () {\n\n  var editor = this.editor;\n  var dimension = new MarkupDimension(this.targetId, editor);\n\n  editor.addMarkup(dimension);\n\n  // Don't display the dimension markup when there is only one Anchor (First click, before mouse move).\n  if (this.secondAnchor) {\n    dimension.set(this.firstAnchor.x, this.firstAnchor.y, this.secondAnchor.x, this.secondAnchor.y, this.text);\n    dimension.setStyle(this.style);\n  }\n};\n\nproto.undo = function () {\n\n  var markup = this.editor.getMarkup(this.targetId);\n  markup && this.editor.removeMarkup(markup);\n};","'use strict';\n\nimport { EditAction } from './EditAction';\nimport { MarkupFreehand } from '../MarkupFreehand';\nimport { cloneStyle } from '../StyleUtils';\n\n/**\n                                             *\n                                             * @param editor\n                                             * @param id\n                                             * @param position\n                                             * @param size\n                                             * @param rotation\n                                             * @param locations\n                                             * @param style\n                                             * @constructor\n                                             */\nexport function CreateFreehand(editor, id, position, size, rotation, locations, style) {\n\n  EditAction.call(this, editor, 'CREATE-FREEHAND', id);\n\n  this.selectOnExecution = false;\n  this.position = position;\n  this.size = size;\n  this.rotation = rotation;\n  this.movements = locations.slice(0);\n  this.style = cloneStyle(style);\n}\n\nCreateFreehand.prototype = Object.create(EditAction.prototype);\nCreateFreehand.prototype.constructor = CreateFreehand;\n\nvar proto = CreateFreehand.prototype;\n\nproto.redo = function () {\n\n  var editor = this.editor;\n  var freehand = new MarkupFreehand(this.targetId, editor);\n\n  editor.addMarkup(freehand);\n\n  freehand.set(this.position, this.size, this.movements, false);\n  freehand.setRotation(this.rotation);\n  freehand.setStyle(this.style);\n};\n\nproto.undo = function () {\n\n  var markup = this.editor.getMarkup(this.targetId);\n  markup && this.editor.removeMarkup(markup);\n};","'use strict';\n\nimport { EditAction } from './EditAction';\nimport { MarkupHighlight } from '../MarkupHighlight';\nimport { cloneStyle } from '../StyleUtils';\n\n/**\n                                             *\n                                             * @param editor\n                                             * @param id\n                                             * @param position\n                                             * @param size\n                                             * @param rotation\n                                             * @param locations\n                                             * @param style\n                                             * @constructor\n                                             */\nexport function CreateHighlight(editor, id, position, size, rotation, locations, style) {\n\n  EditAction.call(this, editor, 'CREATE-HIGHLIGHT', id);\n\n  this.selectOnExecution = false;\n  this.position = position;\n  this.size = size;\n  this.rotation = rotation;\n  this.movements = locations.slice(0);\n  this.style = cloneStyle(style);\n}\n\nCreateHighlight.prototype = Object.create(EditAction.prototype);\nCreateHighlight.prototype.constructor = CreateHighlight;\n\nvar proto = CreateHighlight.prototype;\n\nproto.redo = function () {\n\n  var editor = this.editor;\n  var highlight = new MarkupHighlight(this.targetId, editor);\n\n  editor.addMarkup(highlight);\n\n  highlight.set(this.position, this.size, this.movements, false);\n  highlight.setRotation(this.rotation);\n  highlight.setStyle(this.style);\n};\n\nproto.undo = function () {\n\n  var markup = this.editor.getMarkup(this.targetId);\n  markup && this.editor.removeMarkup(markup);\n};","'use strict';\n\nimport { EditAction } from './EditAction';\nimport { MarkupPolycloud } from '../MarkupPolycloud';\nimport { cloneStyle } from '../StyleUtils';\n\n/**\n                                             *\n                                             * @param editor\n                                             * @param id\n                                             * @param position\n                                             * @param size\n                                             * @param rotation\n                                             * @param locations\n                                             * @param closed\n                                             * @param style\n                                             * @constructor\n                                             */\nexport function CreatePolycloud(editor, id, position, size, rotation, locations, style, closed) {\n\n  EditAction.call(this, editor, 'CREATE-POLYCLOUD', id);\n\n  this.selectOnExecution = false;\n  this.position = position;\n  this.size = size;\n  this.rotation = rotation;\n  this.movements = locations.concat();\n  this.style = cloneStyle(style);\n  this.closed = closed;\n}\n\nCreatePolycloud.prototype = Object.create(EditAction.prototype);\nCreatePolycloud.prototype.constructor = CreatePolycloud;\n\nvar proto = CreatePolycloud.prototype;\n\nproto.redo = function () {\n\n  var editor = this.editor;\n  var polyline = new MarkupPolycloud(this.targetId, editor);\n\n  editor.addMarkup(polyline);\n\n  polyline.set(this.position, this.size, this.movements, this.closed);\n  polyline.setRotation(this.rotation);\n  polyline.setStyle(this.style);\n};\n\nproto.undo = function () {\n\n  var markup = this.editor.getMarkup(this.targetId);\n  markup && this.editor.removeMarkup(markup);\n};","'use strict';\n\nimport { EditAction } from './EditAction';\nimport { MarkupPolyline } from '../MarkupPolyLine';\nimport { cloneStyle } from '../StyleUtils';\n\n/**\n                                             *\n                                             * @param editor\n                                             * @param id\n                                             * @param position\n                                             * @param size\n                                             * @param rotation\n                                             * @param locations\n                                             * @param closed\n                                             * @param style\n                                             * @constructor\n                                             */\nexport function CreatePolyline(editor, id, position, size, rotation, locations, style, closed) {\n\n  EditAction.call(this, editor, 'CREATE-POLYLINE', id);\n\n  this.selectOnExecution = false;\n  this.position = position;\n  this.size = size;\n  this.rotation = rotation;\n  this.movements = locations.concat();\n  this.closed = closed;\n  this.style = cloneStyle(style);\n}\n\nCreatePolyline.prototype = Object.create(EditAction.prototype);\nCreatePolyline.prototype.constructor = CreatePolyline;\n\nvar proto = CreatePolyline.prototype;\n\nproto.redo = function () {\n\n  var editor = this.editor;\n  var polyline = new MarkupPolyline(this.targetId, editor);\n\n  editor.addMarkup(polyline);\n\n  polyline.set(this.position, this.size, this.movements, this.closed);\n  polyline.setRotation(this.rotation);\n  polyline.setStyle(this.style);\n};\n\nproto.undo = function () {\n\n  var markup = this.editor.getMarkup(this.targetId);\n  markup && this.editor.removeMarkup(markup);\n};","'use strict';\n\nimport { EditAction } from './EditAction';\nimport { MarkupRectangle } from '../MarkupRectangle';\nimport { cloneStyle } from '../StyleUtils';\n\n/**\n                                             *\n                                             * @param editor\n                                             * @param id\n                                             * @param position\n                                             * @param size\n                                             * @param rotation\n                                             * @param style\n                                             * @constructor\n                                             */\nexport function CreateRectangle(editor, id, position, size, rotation, style) {\n\n  EditAction.call(this, editor, 'CREATE-RECTANGLE', id);\n\n  this.selectOnExecution = false;\n  this.position = { x: position.x, y: position.y };\n  this.size = { x: size.x, y: size.y };\n  this.rotation = rotation;\n  this.style = cloneStyle(style);\n}\n\nCreateRectangle.prototype = Object.create(EditAction.prototype);\nCreateRectangle.prototype.constructor = CreateRectangle;\n\nvar proto = CreateRectangle.prototype;\n\nproto.redo = function () {\n\n  var editor = this.editor;\n  var rectangle = new MarkupRectangle(this.targetId, editor);\n\n  editor.addMarkup(rectangle);\n\n  rectangle.set(this.position, this.size);\n  rectangle.setRotation(this.rotation);\n  rectangle.setStyle(this.style);\n};\n\nproto.undo = function () {\n\n  var markup = this.editor.getMarkup(this.targetId);\n  markup && this.editor.removeMarkup(markup);\n};","'use strict';function _typeof(obj) {\"@babel/helpers - typeof\";if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;};}return _typeof(obj);}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError(\"Cannot call a class as a function\");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}function _inherits(subClass, superClass) {if (typeof superClass !== \"function\" && superClass !== null) {throw new TypeError(\"Super expression must either be null or a function\");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}function _createSuper(Derived) {var hasNativeReflectConstruct = _isNativeReflectConstruct();return function _createSuperInternal() {var Super = _getPrototypeOf(Derived),result;if (hasNativeReflectConstruct) {var NewTarget = _getPrototypeOf(this).constructor;result = Reflect.construct(Super, arguments, NewTarget);} else {result = Super.apply(this, arguments);}return _possibleConstructorReturn(this, result);};}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");}return self;}function _isNativeReflectConstruct() {if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;if (Reflect.construct.sham) return false;if (typeof Proxy === \"function\") return true;try {Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));return true;} catch (e) {return false;}}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}\n\nimport { EditAction } from './EditAction';\nimport { MarkupStamp } from '../MarkupStamp';\nimport { cloneStyle } from '../StyleUtils';\n\nexport { CreateStamp };\n\n/**\n                         * @constructor\n                         * \n                         * @param editor \n                         * @param id \n                         * @param position \n                         * @param size \n                         * @param style \n                         * @param {string} svg\n                         */var\n\nCreateStamp = /*#__PURE__*/function (_EditAction) {_inherits(CreateStamp, _EditAction);var _super = _createSuper(CreateStamp);\n  function CreateStamp(editor, id, position, size, rotation, style, svgData) {var _this;_classCallCheck(this, CreateStamp);\n    _this = _super.call(this, editor, 'CREATE-STAMP', id);\n\n    _this.selectOnExecution = false;\n    _this.position = { x: position.x, y: position.y };\n    _this.size = { x: size.x, y: size.y };\n    _this.rotation = rotation;\n    _this.style = cloneStyle(style);\n    _this.svgData = svgData;return _this;\n  }_createClass(CreateStamp, [{ key: \"redo\", value: function redo()\n\n    {\n      var stamp = new MarkupStamp(this.targetId, this.editor, this.svgData);\n\n      this.editor.addMarkup(stamp);\n\n      stamp.setSize(this.position, this.size.x, this.size.y);\n      stamp.setRotation(this.rotation);\n      stamp.setStyle(this.style);\n    } }, { key: \"undo\", value: function undo()\n\n    {\n      var markup = this.editor.getMarkup(this.targetId);\n      this.editor.removeMarkup(markup);\n    } }]);return CreateStamp;}(EditAction);","'use strict';\n\nimport { EditAction } from './EditAction';\nimport { MarkupText } from '../MarkupText';\nimport { cloneStyle } from '../StyleUtils';\n\n/**\n                                             *\n                                             * @param editor\n                                             * @param id\n                                             * @param position\n                                             * @param size\n                                             * @param text\n                                             * @param style\n                                             * @constructor\n                                             */\nexport function CreateText(editor, id, position, size, text, style) {\n\n  EditAction.call(this, editor, 'CREATE-TEXT', id);\n\n  this.text = text;\n  this.position = { x: position.x, y: position.y };\n  this.size = { x: size.x, y: size.y };\n  this.style = cloneStyle(style);\n}\n\nCreateText.prototype = Object.create(EditAction.prototype);\nCreateText.prototype.constructor = CreateText;\n\nvar proto = CreateText.prototype;\n\nproto.redo = function () {\n\n  var editor = this.editor;\n  var position = this.position;\n  var size = this.size;\n\n  var text = new MarkupText(this.targetId, editor, size);\n\n  editor.addMarkup(text);\n\n  text.set(position, size, this.text);\n  text.setStyle(this.style);\n};\n\nproto.undo = function () {\n\n  var markup = this.editor.getMarkup(this.targetId);\n  if (markup) {\n    this.editor.removeMarkup(markup);\n    markup.destroy();\n  }\n};","'use strict';\n\nimport { EditAction } from './EditAction';\nimport { CreateArrow } from './CreateArrow';\n\n/**\n                                              *\n                                              * @param editor\n                                              * @param arrow\n                                              * @constructor\n                                              */\nexport function DeleteArrow(editor, arrow) {\n\n  // Confusing naming here. Arrow.tail is the starting point of the arrow,\n  // and arrow.head is the final point. In CreateArrow the head argument\n  // is the first point of the arrow and the tail argument is the second\n  // point of the argument. So construct CreateArrow with the tail before\n  // the head. \n  EditAction.call(this, editor, 'DELETE-ARROW', arrow.id);\n  this.createArrow = new CreateArrow(\n  editor,\n  arrow.id,\n  arrow.tail,\n  arrow.head,\n  arrow.getStyle());\n}\n\nDeleteArrow.prototype = Object.create(EditAction.prototype);\nDeleteArrow.prototype.constructor = DeleteArrow;\n\nvar proto = DeleteArrow.prototype;\n\nproto.redo = function () {\n\n  this.createArrow.undo();\n};\n\nproto.undo = function () {\n\n  this.createArrow.redo();\n};","'use strict';\n\nimport { EditAction } from './EditAction';\nimport { CreateCallout } from './CreateCallout';\n\n/**\n                                                  *\n                                                  * @param editor\n                                                  * @param text\n                                                  * @constructor\n                                                  */\nexport function DeleteCallout(editor, callout) {\n\n  EditAction.call(this, editor, 'DELETE-CALLOUT', callout.id);\n\n  var position = { x: callout.position.x, y: callout.position.y };\n  var size = { x: callout.size.x, y: callout.size.y };\n\n  this.createCallout = new CreateCallout(\n  editor,\n  callout.id,\n  position,\n  size,\n  callout.getText(),\n  callout.getStyle(),\n  callout.isFrameUsed);\n}\n\nDeleteCallout.prototype = Object.create(EditAction.prototype);\nDeleteCallout.prototype.constructor = DeleteCallout;\n\nvar proto = DeleteCallout.prototype;\n\nproto.redo = function () {\n\n  this.createCallout.undo();\n};\n\nproto.undo = function () {\n\n  this.createCallout.redo();\n};","'use strict';\n\nimport { EditAction } from './EditAction';\nimport { CreateCircle } from './CreateCircle';\n\n/**\n                                                * Markup delete circle action.\n                                                * \n                                                * Implements an {@link Autodesk.Viewing.Extensions.Markups.Core.EditAction|EditAction}\n                                                * for deleting a Circle {@link Autodesk.Viewing.Extensions.Markups.Core.Markup|Markup}.\n                                                * Included in documentation as an example of how to create\n                                                * a specific EditAction that deals with Markup deletion.\n                                                * Developers are encourage to look into this class's source code and copy\n                                                * as much code as they need. Find link to source code below.\n                                                *\n                                                * @tutorial feature_markup\n                                                * @constructor\n                                                * @memberof Autodesk.Viewing.Extensions.Markups.Core\n                                                * @extends Autodesk.Viewing.Extensions.Markups.Core.EditAction\n                                                *\n                                                * @param editor\n                                                * @param circle\n                                                */\nexport function DeleteCircle(editor, circle) {\n\n  EditAction.call(this, editor, 'DELETE-CIRCLE', circle.id);\n  this.createCircle = new CreateCircle(\n  editor,\n  circle.id,\n  circle.position,\n  circle.size,\n  circle.rotation,\n  circle.getStyle());\n}\n\nDeleteCircle.prototype = Object.create(EditAction.prototype);\nDeleteCircle.prototype.constructor = DeleteCircle;\n\nvar proto = DeleteCircle.prototype;\n\nproto.redo = function () {\n\n  this.createCircle.undo();\n};\n\nproto.undo = function () {\n\n  this.createCircle.redo();\n};","'use strict';\n\nimport { EditAction } from './EditAction';\nimport { CreateCloud } from './CreateCloud';\n\n/**\n                                              *\n                                              * @param editor\n                                              * @param cloud\n                                              * @constructor\n                                              */\nexport function DeleteCloud(editor, cloud) {\n\n  EditAction.call(this, editor, 'DELETE-CLOUD', cloud.id);\n  this.createCloud = new CreateCloud(\n  editor,\n  cloud.id,\n  cloud.position,\n  cloud.size,\n  cloud.rotation,\n  cloud.getStyle());\n}\n\nDeleteCloud.prototype = Object.create(EditAction.prototype);\nDeleteCloud.prototype.constructor = DeleteCloud;\n\nvar proto = DeleteCloud.prototype;\n\nproto.redo = function () {\n\n  this.createCloud.undo();\n};\n\nproto.undo = function () {\n\n  this.createCloud.redo();\n};","'use strict';\n\nimport { EditAction } from './EditAction';\nimport { CreateDimension } from './CreateDimension';\n\n/**\n                                                      *\n                                                      * @param editor\n                                                      * @param dimension\n                                                      * @constructor\n                                                      */\nexport function DeleteDimension(editor, dimension) {\n\n  // Confusing naming here. Dimension.secondAnchor is the starting point of the dimension,\n  // and dimension.firstAnchor is the final point. In CreateDimension the firstAnchor argument\n  // is the first point of the dimension and the secondAnchor argument is the second\n  // point of the argument. So construct CreateDimension with the secondAnchor before\n  // the firstAnchor. \n  EditAction.call(this, editor, 'DELETE-DIMENSION', dimension.id);\n  this.createDimension = new CreateDimension(\n  editor,\n  dimension.id,\n  dimension.secondAnchor,\n  dimension.firstAnchor,\n  dimension.currentText,\n  dimension.getStyle());\n}\n\nDeleteDimension.prototype = Object.create(EditAction.prototype);\nDeleteDimension.prototype.constructor = DeleteDimension;\n\nvar proto = DeleteDimension.prototype;\n\nproto.redo = function () {\n\n  this.createDimension.undo();\n};\n\nproto.undo = function () {\n\n  this.createDimension.redo();\n};","'use strict';\n\nimport { EditAction } from './EditAction';\nimport { CreateFreehand } from './CreateFreehand';\n\n/**\n                                                    *\n                                                    * @param editor\n                                                    * @param freehand\n                                                    * @constructor\n                                                    */\nexport function DeleteFreehand(editor, freehand) {\n  EditAction.call(this, editor, 'DELETE-FREEHAND', freehand.id);\n  this.createFreehand = new CreateFreehand(\n  editor,\n  freehand.id,\n  freehand.position,\n  freehand.size,\n  freehand.rotation,\n  freehand.locations,\n  freehand.getStyle());\n}\n\nDeleteFreehand.prototype = Object.create(EditAction.prototype);\nDeleteFreehand.prototype.constructor = DeleteFreehand;\n\nvar proto = DeleteFreehand.prototype;\n\nproto.redo = function () {\n\n  this.createFreehand.undo();\n};\n\nproto.undo = function () {\n\n  this.createFreehand.redo();\n};","'use strict';\n\nimport { EditAction } from './EditAction';\nimport { CreateHighlight } from './CreateHighlight';\n\n/**\n                                                      *\n                                                      * @param editor\n                                                      * @param highlight\n                                                      * @constructor\n                                                      */\nexport function DeleteHighlight(editor, highlight) {\n  EditAction.call(this, editor, 'DELETE-HIGHLIGHT', highlight.id);\n  this.createHighlight = new CreateHighlight(\n  editor,\n  highlight.id,\n  highlight.position,\n  highlight.size,\n  highlight.rotation,\n  highlight.locations,\n  highlight.getStyle());\n}\n\nDeleteHighlight.prototype = Object.create(EditAction.prototype);\nDeleteHighlight.prototype.constructor = DeleteHighlight;\n\nvar proto = DeleteHighlight.prototype;\n\nproto.redo = function () {\n\n  this.createHighlight.undo();\n};\n\nproto.undo = function () {\n\n  this.createHighlight.redo();\n};","'use strict';\n\nimport { EditAction } from './EditAction';\nimport { CreatePolycloud } from './CreatePolycloud';\n\n/**\n                                                      *\n                                                      * @param editor\n                                                      * @param polycloud\n                                                      * @constructor\n                                                      */\nexport function DeletePolycloud(editor, polycloud) {\n\n  EditAction.call(this, editor, 'DELETE-POLYCLOUD', polycloud.id);\n  this.createPolycloud = new CreatePolycloud(\n  editor,\n  polycloud.id,\n  polycloud.position,\n  polycloud.size,\n  polycloud.rotation,\n  polycloud.locations,\n  polycloud.getStyle(),\n  polycloud.closed);\n}\n\nDeletePolycloud.prototype = Object.create(EditAction.prototype);\nDeletePolycloud.prototype.constructor = DeletePolycloud;\n\nvar proto = DeletePolycloud.prototype;\n\nproto.redo = function () {\n\n  this.createPolycloud.undo();\n};\n\nproto.undo = function () {\n\n  this.createPolycloud.redo();\n};","'use strict';\n\nimport { EditAction } from './EditAction';\nimport { CreatePolyline } from './CreatePolyline';\n\n/**\n                                                    *\n                                                    * @param editor\n                                                    * @param polyline\n                                                    * @constructor\n                                                    */\nexport function DeletePolyline(editor, polyline) {\n\n  EditAction.call(this, editor, 'DELETE-POLYLINE', polyline.id);\n  this.createPolyline = new CreatePolyline(\n  editor,\n  polyline.id,\n  polyline.position,\n  polyline.size,\n  polyline.rotation,\n  polyline.locations,\n  polyline.getStyle(),\n  polyline.closed);\n}\n\nDeletePolyline.prototype = Object.create(EditAction.prototype);\nDeletePolyline.prototype.constructor = DeletePolyline;\n\nvar proto = DeletePolyline.prototype;\n\nproto.redo = function () {\n\n  this.createPolyline.undo();\n};\n\nproto.undo = function () {\n\n  this.createPolyline.redo();\n};","'use strict';\n\nimport { EditAction } from './EditAction';\nimport { CreateRectangle } from './CreateRectangle';\n\n/**\n                                                      *\n                                                      * @param editor\n                                                      * @param rectangle\n                                                      * @constructor\n                                                      */\nexport var DeleteRectangle = function DeleteRectangle(editor, rectangle) {\n\n  EditAction.call(this, editor, 'DELETE-RECTANGLE', rectangle.id);\n  this.createRectangle = new CreateRectangle(\n  editor,\n  rectangle.id,\n  rectangle.position,\n  rectangle.size,\n  rectangle.rotation,\n  rectangle.getStyle());\n};\n\nDeleteRectangle.prototype = Object.create(EditAction.prototype);\nDeleteRectangle.prototype.constructor = DeleteRectangle;\n\nvar proto = DeleteRectangle.prototype;\n\nproto.redo = function () {\n\n  this.createRectangle.undo();\n};\n\nproto.undo = function () {\n\n  this.createRectangle.redo();\n};","'use strict';function _typeof(obj) {\"@babel/helpers - typeof\";if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;};}return _typeof(obj);}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError(\"Cannot call a class as a function\");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}function _inherits(subClass, superClass) {if (typeof superClass !== \"function\" && superClass !== null) {throw new TypeError(\"Super expression must either be null or a function\");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}function _createSuper(Derived) {var hasNativeReflectConstruct = _isNativeReflectConstruct();return function _createSuperInternal() {var Super = _getPrototypeOf(Derived),result;if (hasNativeReflectConstruct) {var NewTarget = _getPrototypeOf(this).constructor;result = Reflect.construct(Super, arguments, NewTarget);} else {result = Super.apply(this, arguments);}return _possibleConstructorReturn(this, result);};}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");}return self;}function _isNativeReflectConstruct() {if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;if (Reflect.construct.sham) return false;if (typeof Proxy === \"function\") return true;try {Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));return true;} catch (e) {return false;}}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}\n\nimport { EditAction } from './EditAction';\nimport { CreateStamp } from './CreateStamp';\n\nexport { DeleteStamp };var\n\nDeleteStamp = /*#__PURE__*/function (_EditAction) {_inherits(DeleteStamp, _EditAction);var _super = _createSuper(DeleteStamp);\n  function DeleteStamp(editor, stamp) {var _this;_classCallCheck(this, DeleteStamp);\n    _this = _super.call(this, editor, 'DELETE-STAMP', stamp.id);\n\n    _this.createStamp = new CreateStamp(\n    editor,\n    stamp.id,\n    stamp.position,\n    stamp.size,\n    stamp.rotation,\n    stamp.getStyle());return _this;\n\n  }_createClass(DeleteStamp, [{ key: \"redo\", value: function redo()\n\n    {\n      this.createStamp.undo();\n    } }, { key: \"undo\", value: function undo()\n\n    {\n      this.createStamp.redo();\n    } }]);return DeleteStamp;}(EditAction);","'use strict';\n\nimport { EditAction } from './EditAction';\nimport { CreateText } from './CreateText';\n\n/**\n                                            *\n                                            * @param editor\n                                            * @param text\n                                            * @constructor\n                                            */\nexport function DeleteText(editor, text) {\n\n  EditAction.call(this, editor, 'DELETE-TEXT', text.id);\n\n  var position = { x: text.position.x, y: text.position.y };\n  var size = { x: text.size.x, y: text.size.y };\n\n  this.createText = new CreateText(\n  editor,\n  text.id,\n  position,\n  size,\n  text.getText(),\n  text.getStyle());\n}\n\nDeleteText.prototype = Object.create(EditAction.prototype);\nDeleteText.prototype.constructor = DeleteText;\n\nvar proto = DeleteText.prototype;\n\nproto.redo = function () {\n\n  this.createText.undo();\n};\n\nproto.undo = function () {\n\n  this.createText.redo();\n};","'use strict';\n\n/**\n               * Base class for all markup edit actions.\n               *\n               * EditActions encapsulate {@link Autodesk.Viewing.Extensions.Markups.Core.Markup|Markup}\n               * operations (such as creation, edition and deletion) that hook into the undo/redo system.\n               *\n               * The minimum set of methods to implement on an EditAction extension are:\n               * - execute()\n               * - undo()\n               * - redo()\n               *\n               * A good set of classes to check their implementation are:\n               * {@link Autodesk.Viewing.Extensions.Markups.Core.CreateCircle|CreateCircle}.\n               * {@link Autodesk.Viewing.Extensions.Markups.Core.DeleteCircle|DeleteCircle}.\n               * {@link Autodesk.Viewing.Extensions.Markups.Core.SetCircle|SetCircle}.\n               *\n               * @tutorial feature_markup\n               * @constructor\n               * @memberof Autodesk.Viewing.Extensions.Markups.Core\n               *\n               * @param {Autodesk.Viewing.Extensions.Markups.Core.MarkupsCore} editor\n               * @param {String} type - An identifier for the EditAction.\n               * @param {number} targetId - The id of the markup being affected.\n               */\nexport function EditAction(editor, type, targetId) {\n\n  this.type = type;\n  this.editor = editor;\n  this.targetId = targetId;\n  this.addToHistory = true;\n  this.selectOnExecution = true;\n}\n\n/**\n   * Performs the action.\n   */\nEditAction.prototype.execute = function () {\n\n  this.editor.actionManager.execute(this);\n};\n\n/**\n    * @abstract\n    */\nEditAction.prototype.redo = function () {\n\n};\n\n/**\n    * @abstract\n    */\nEditAction.prototype.undo = function () {\n\n};\n\n/**\n    * Provides a mechanism to merge consecutive actions of the same type.\n    * @param {Autodesk.Viewing.Extensions.Markups.Core.EditAction} action - Action to check if it can be merged with 'this'.\n    * @returns {boolean} Returns true if merge has been applied. Parameter will be discarded.\n    */\nEditAction.prototype.merge = function (action) {\n\n  return false;\n};\n\n/**\n    * Provides a mechanism to check whether the action yields no results.\n    * @returns {boolean} Returns true if no changes happen with this action.\n    */\nEditAction.prototype.isIdentity = function () {\n\n  return false;\n};","'use strict';\n\n/**\n               * This class will group actions edit actions that should be executed as a whole.\n               * When a group is open actions can be added to it, similar actions will be merged into one during this process.\n               * This class is not intended to be used by users, it's a helper class of EditActionManager.\n               * @constructor\n               */\nexport function EditActionGroup() {\n\n  this.actions = [];\n  this.closed = true;\n}\n\nvar proto = EditActionGroup.prototype;\n\n/**\n                                        *\n                                        * @returns {boolean}\n                                        */\nproto.open = function () {\n\n  if (!this.closed) {\n    return false;\n  }\n\n  this.closed = false;\n  return true;\n};\n\n/**\n    *\n    * @returns {boolean}\n    */\nproto.close = function () {\n\n  if (this.closed) {\n    return false;\n  }\n\n  this.closed = true;\n  return true;\n};\n\n/**\n    *\n    * @returns {number} targetId\n    */\nproto.undo = function () {\n\n  var actions = this.actions;\n  var actionsMaxIndex = actions.length - 1;\n\n  var targetId = -1;\n  for (var i = actionsMaxIndex; i >= 0; --i) {\n\n    var action = actions[i];\n    action.undo();\n\n    if (action.targetId !== -1) {\n      targetId = action.targetId;\n    }\n  }\n\n  return targetId;\n};\n\n/**\n    *\n    * @returns {number} targetId\n    */\nproto.redo = function () {\n\n  var actions = this.actions;\n  var actionsCount = actions.length;\n\n  var targetId = -1;\n  for (var i = 0; i < actionsCount; ++i) {\n\n    var action = actions[i];\n    action.redo();\n\n    if (action.targetId !== -1) {\n      targetId = action.targetId;\n    }\n  }\n\n  return targetId;\n};\n\n/**\n    *\n    * @returns {boolean}\n    */\nproto.isOpen = function () {\n\n  return !this.closed;\n};\n\n/**\n    *\n    * @returns {boolean}\n    */\nproto.isClosed = function () {\n\n  return this.closed;\n};\n\n/**\n    *\n    * @returns {boolean}\n    */\nproto.isEmpty = function () {\n\n  return this.actions.length === 0;\n};\n\n/**\n    *\n    * @param {EditAction} action\n    */\nproto.addAction = function (action) {\n\n  if (this.closed) {\n    return false;\n  }\n\n  this.actions.push(action);\n  this.compact();\n\n  return true;\n};\n\n/**\n    * @private\n    */\nproto.compact = function () {\n\n  var actions = this.actions;\n  var actionsCount = actions.length;\n\n  for (var i = 0; i < actionsCount; ++i) {\n\n    // If an action does nothing, remove it.\n    var actionA = actions[i];\n    if (actionA.isIdentity()) {\n      actions.splice(i, 1);\n      --actionsCount;\n      --i;\n      continue;\n    }\n\n    // If an action can be merged, merge it.\n    for (var j = i + 1; j < actionsCount; ++j) {\n\n      var actionB = actions[j];\n      if (actionA.type === actionB.type &&\n      actionA.merge(actionB)) {\n        actions.splice(j, 1);\n        --actionsCount;\n        --i;\n        break;\n      }\n    }\n  }\n};\n\nproto.getTargetId = function () {\n  var actions = this.actions;\n  var actionsCount = actions.length;\n  var targetId = -1;\n  for (var i = 0; i < actionsCount; ++i) {\n    var action = actions[i];\n    if (action.targetId !== -1) {\n      targetId = action.targetId;\n    }\n  }\n  return targetId;\n};","'use strict';\n\nimport { addTraitEventDispatcher } from '../MarkupsCoreUtils';\nimport * as MarkupEvents from '../MarkupEvents';\nimport { EditActionGroup } from './EditActionGroup';\n\n/**\n                                                      *\n                                                      * @param historySize\n                                                      * @constructor\n                                                      */\nexport function EditActionManager(historySize) {\n\n  this.historySize = historySize;\n\n  this.undoStack = [];\n  this.redoStack = [];\n\n  addTraitEventDispatcher(this);\n}\n\nvar proto = EditActionManager.prototype;\n\n/**\n                                          *\n                                          * @param action\n                                          */\nproto.execute = function (action) {\n\n  var redoStack = this.redoStack;\n  var undoStack = this.undoStack;\n\n  redoStack.splice(0, redoStack.length);\n\n  action.redo();\n\n  var group = this.getEditActionGroup();\n  if (group.isOpen()) {\n    group.addAction(action);\n  } else {\n    group.open();\n    group.addAction(action);\n    group.close();\n  }\n\n  if (undoStack.length > this.historySize) {\n    undoStack.splice(0, 1);\n  }\n\n  var targetId = action.selectOnExecution ? action.targetId : -1;\n  this.dispatchEvent(\n  { type: MarkupEvents.EVENT_HISTORY_CHANGED, data: { action: 'execute', targetId: targetId } });\n};\n\nproto.beginActionGroup = function () {\n\n  var undoStack = this.undoStack;\n  var undoStackCount = undoStack.length;\n  var group = null;\n\n  if (undoStackCount === 0 || undoStack[undoStackCount - 1].isClosed()) {\n\n    group = this.getEditActionGroup();\n    group.open();\n  } else {\n    console.warn('Markups - Undo/Redo - Action edit group already open.');\n  }\n};\n\nproto.closeActionGroup = function () {\n\n  var undoStack = this.undoStack;\n  var undoStackCount = undoStack.length;\n\n  if (undoStackCount === 0) {\n\n    console.warn('Markups - Undo/Redo - There is no action edit group to close.');\n    return;\n  }\n\n  var group = undoStack[undoStackCount - 1];\n  if (!group.close()) {\n    console.warn('Markups - Undo/Redo - Action edit group already closed.');\n  }\n\n  if (group.isEmpty()) {\n    undoStack.pop();\n  }\n};\n\nproto.cancelActionGroup = function () {\n\n  var undoStack = this.undoStack;\n  var undoStackCount = undoStack.length;\n\n  if (undoStackCount === 0) {\n\n    console.warn('Markups - Undo/Redo - There is no action edit group to close.');\n    return;\n  }\n\n  var group = undoStack[undoStackCount - 1];\n  if (!group.close()) {\n    console.warn('Markups - Undo/Redo - Action edit group already closed.');\n    return;\n  }\n\n  group.undo();\n  undoStack.pop();\n\n  this.dispatchEvent(\n  { type: MarkupEvents.EVENT_HISTORY_CHANGED, data: { action: 'cancel', targetId: -1 } });\n};\n\nproto.undo = function () {\n\n  var undoStack = this.undoStack;\n  var redoStack = this.redoStack;\n\n  if (undoStack.length === 0) {\n    return;\n  }\n\n  var group = undoStack.pop();\n  var targetId = group.undo();\n\n  redoStack.push(group);\n\n  this.dispatchEvent(\n  { type: MarkupEvents.EVENT_HISTORY_CHANGED, data: { action: 'undo', targetId: targetId } });\n};\n\nproto.redo = function () {\n\n  var undoStack = this.undoStack;\n  var redoStack = this.redoStack;\n\n  if (redoStack.length === 0) {\n    return;\n  }\n\n  var group = redoStack.pop();\n  var targetId = group.redo();\n\n  undoStack.push(group);\n\n  this.dispatchEvent(\n  { type: MarkupEvents.EVENT_HISTORY_CHANGED, data: { action: 'redo', targetId: targetId } });\n};\n\nproto.clear = function () {\n\n  this.undoStack.splice(0, this.undoStack.length);\n  this.redoStack.splice(0, this.redoStack.length);\n\n  this.dispatchEvent(\n  { type: MarkupEvents.EVENT_HISTORY_CHANGED, data: { action: 'clear', targetId: -1 } });\n};\n\nproto.isUndoStackEmpty = function () {\n\n  return this.undoStack.length === 0;\n};\n\nproto.isRedoStackEmpty = function () {\n\n  return this.redoStack.length === 0;\n};\n\nproto.getLastElementInUndoStack = function () {\n\n  var undoStack = this.undoStack;\n  var undoStackCount = undoStack.length;\n  return undoStack[undoStackCount - 1];\n};\n\n/**\n    *\n    * @return action\n    * @private\n    */\nproto.getEditActionGroup = function () {\n\n  var undoStack = this.undoStack;\n  var undoStackCount = this.undoStack.length;\n\n  var group = null;\n\n  if (undoStackCount === 0 || undoStack[undoStackCount - 1].isClosed()) {\n    group = new EditActionGroup();\n    undoStack.push(group);\n  } else {\n    group = undoStack[undoStackCount - 1];\n  }\n\n  return group;\n};","'use strict';\n\nimport { EditAction } from './EditAction';\n\n/**\n                                            *\n                                            * @param editor\n                                            * @param arrow\n                                            * @param head\n                                            * @param tail\n                                            * @constructor\n                                            */\nexport function SetArrow(editor, arrow, head, tail) {\n\n  EditAction.call(this, editor, 'SET-ARROW', arrow.id);\n\n  this.newHead = { x: head.x, y: head.y };\n  this.newTail = { x: tail.x, y: tail.y };\n  this.oldHead = { x: arrow.head.x, y: arrow.head.y };\n  this.oldTail = { x: arrow.tail.x, y: arrow.tail.y };\n}\n\nSetArrow.prototype = Object.create(EditAction.prototype);\nSetArrow.prototype.constructor = SetArrow;\n\nvar proto = SetArrow.prototype;\n\nproto.redo = function () {\n\n  this.applyState(this.targetId, this.newHead, this.newTail);\n};\n\nproto.undo = function () {\n\n  this.applyState(this.targetId, this.oldHead, this.oldTail);\n};\n\nproto.merge = function (action) {\n\n  if (this.targetId === action.targetId &&\n  this.type === action.type) {\n\n    this.newHead = action.newHead;\n    this.newTail = action.newTail;\n    return true;\n  }\n  return false;\n};\n\n/**\n    *\n    * @private\n    */\nproto.applyState = function (targetId, head, tail) {\n\n  var arrow = this.editor.getMarkup(targetId);\n  if (!arrow) {\n    return;\n  }\n\n  // Different stroke widths make positions differ at sub-pixel level.\n  var epsilon = 0.0001;\n\n  if (Math.abs(arrow.head.x - head.x) >= epsilon || Math.abs(arrow.head.y - head.y) >= epsilon ||\n  Math.abs(arrow.tail.x - tail.x) >= epsilon || Math.abs(arrow.tail.y - tail.y) >= epsilon) {\n\n    // Confusing naming here. in arrow.set the first two numbers are\n    // the point you drag from and the second two are the point you\n    // drag to. So the head point is actually where the tail of the\n    // arrow is positioned and the tail point is the head is positioned.\n    arrow.set(head.x, head.y, tail.x, tail.y);\n  }\n};\n\n/**\n    * @returns {boolean}\n    */\nproto.isIdentity = function () {\n\n  return (\n    this.newHead.x === this.oldHead.x &&\n    this.newHead.y === this.oldHead.y &&\n    this.newTail.x === this.oldTail.x &&\n    this.newTail.y === this.oldTail.y);\n};","'use strict';\n\nimport { EditAction } from './EditAction';\n\n/**\n                                            *\n                                            * @param editor\n                                            * @param markup\n                                            * @param position\n                                            * @param size\n                                            * @param text\n                                            * @constructor\n                                            */\nexport function SetCallout(editor, markup, position, size, text, isFrameUsed) {\n\n  EditAction.call(this, editor, 'SET-CALLOUT', markup.id);\n\n  this.newPosition = { x: position.x, y: position.y };\n  this.oldPosition = { x: markup.position.x, y: markup.position.y };\n  this.newSize = { x: size.x, y: size.y };\n  this.oldSize = { x: markup.size.x, y: markup.size.y };\n  this.newText = text;\n  this.oldText = markup.getText();\n  this.newIsFrameUsed = isFrameUsed;\n  this.oldIsFrameUsed = markup.isFrameUsed;\n}\n\nSetCallout.prototype = Object.create(EditAction.prototype);\nSetCallout.prototype.constructor = SetCallout;\n\nvar proto = SetCallout.prototype;\n\nproto.redo = function () {\n\n  var callout = this.editor.getMarkup(this.targetId);\n  callout && callout.set(this.newPosition, this.newSize, this.newText, this.newIsFrameUsed);\n};\n\nproto.undo = function () {\n\n  var callout = this.editor.getMarkup(this.targetId);\n  callout && callout.set(this.oldPosition, this.oldSize, this.oldText, this.oldIsFrameUsed);\n};","'use strict';\n\nimport { EditAction } from './EditAction';\n\n/**\n                                            * Markup set circle action.\n                                            *\n                                            * Implements an {@link Autodesk.Viewing.Extensions.Markups.Core.EditAction|EditAction}\n                                            * for editing properties of a Circle {@link Autodesk.Viewing.Extensions.Markups.Core.Markup|Markup}.\n                                            * Included in documentation as an example of how to create\n                                            * a specific EditAction that deals with Markup edition.\n                                            * Developers are encourage to look into this class's source code and copy\n                                            * as much code as they need. Find link to source code below.\n                                            *\n                                            * @tutorial feature_markup\n                                            * @constructor\n                                            * @memberof Autodesk.Viewing.Extensions.Markups.Core\n                                            * @extends Autodesk.Viewing.Extensions.Markups.Core.EditAction\n                                            *\n                                            * @param editor\n                                            * @param circle\n                                            * @param position\n                                            * @param size\n                                            */\nexport function SetCircle(editor, circle, position, size) {\n\n  EditAction.call(this, editor, 'SET-CIRCLE', circle.id);\n\n  this.newPosition = { x: position.x, y: position.y };\n  this.newSize = { x: size.x, y: size.y };\n  this.oldPosition = { x: circle.position.x, y: circle.position.y };\n  this.oldSize = { x: circle.size.x, y: circle.size.y };\n}\n\nSetCircle.prototype = Object.create(EditAction.prototype);\nSetCircle.prototype.constructor = SetCircle;\n\nvar proto = SetCircle.prototype;\n\nproto.redo = function () {\n\n  this.applyState(this.targetId, this.newPosition, this.newSize);\n};\n\nproto.undo = function () {\n\n  this.applyState(this.targetId, this.oldPosition, this.oldSize);\n};\n\nproto.merge = function (action) {\n\n  if (this.targetId === action.targetId &&\n  this.type === action.type) {\n\n    this.newPosition = action.newPosition;\n    this.newSize = action.newSize;\n    return true;\n  }\n  return false;\n};\n\n/**\n    *\n    * @private\n    */\nproto.applyState = function (targetId, position, size) {\n\n  var circle = this.editor.getMarkup(targetId);\n  if (!circle) {\n    return;\n  }\n\n  // Different stroke widths make positions differ at sub-pixel level.\n  var epsilon = 0.0001;\n\n  if (Math.abs(circle.position.x - position.x) > epsilon || Math.abs(circle.size.y - size.y) > epsilon ||\n  Math.abs(circle.position.y - position.y) > epsilon || Math.abs(circle.size.y - size.y) > epsilon) {\n\n    circle.set(position, size);\n  }\n};\n\n/**\n    * @returns {boolean}\n    */\nproto.isIdentity = function () {\n\n  return (\n    this.newPosition.x === this.oldPosition.x &&\n    this.newPosition.y === this.oldPosition.y &&\n    this.newSize.x === this.oldSize.x &&\n    this.newSize.y === this.oldSize.y);\n};","'use strict';\n\nimport { EditAction } from './EditAction';\n\n/**\n                                            *\n                                            * @param editor\n                                            * @param cloud\n                                            * @param position\n                                            * @param size\n                                            * @constructor\n                                            */\nexport function SetCloud(editor, cloud, position, size) {\n\n  EditAction.call(this, editor, 'SET-CLOUD', cloud.id);\n\n  this.newPosition = { x: position.x, y: position.y };\n  this.newSize = { x: size.x, y: size.y };\n  this.oldPosition = { x: cloud.position.x, y: cloud.position.y };\n  this.oldSize = { x: cloud.size.x, y: cloud.size.y };\n}\n\nSetCloud.prototype = Object.create(EditAction.prototype);\nSetCloud.prototype.constructor = SetCloud;\n\nvar proto = SetCloud.prototype;\n\nproto.redo = function () {\n\n  this.applyState(this.targetId, this.newPosition, this.newSize, this.newStrokeWidth, this.newColor);\n};\n\nproto.undo = function () {\n\n  this.applyState(this.targetId, this.oldPosition, this.oldSize, this.oldStrokeWidth, this.oldColor);\n};\n\nproto.merge = function (action) {\n\n  if (this.targetId === action.targetId &&\n  this.type === action.type) {\n\n    this.newPosition = action.newPosition;\n    this.newSize = action.newSize;\n    return true;\n  }\n  return false;\n};\n\n/**\n    *\n    * @private\n    */\nproto.applyState = function (targetId, position, size) {\n\n  var cloud = this.editor.getMarkup(targetId);\n  if (!cloud) {\n    return;\n  }\n\n  // Different stroke widths make positions differ at sub-pixel level.\n  var epsilon = 0.0001;\n\n  if (Math.abs(cloud.position.x - position.x) > epsilon || Math.abs(cloud.size.y - size.y) > epsilon ||\n  Math.abs(cloud.position.y - position.y) > epsilon || Math.abs(cloud.size.y - size.y) > epsilon) {\n\n    cloud.set(position, size);\n  }\n};\n\n/**\n    * @returns {boolean}\n    */\nproto.isIdentity = function () {\n\n  return (\n    this.newPosition.x === this.oldPosition.x &&\n    this.newPosition.y === this.oldPosition.y &&\n    this.newSize.x === this.oldSize.x &&\n    this.newSize.y === this.oldSize.y);\n};","'use strict';\n\nimport { EditAction } from './EditAction';\n\n/**\n                                            *\n                                            * @param editor\n                                            * @param dimension\n                                            * @param firstAnchor\n                                            * @param secondAnchor\n                                            * @constructor\n                                            */\nexport function SetDimension(editor, dimension, firstAnchor, secondAnchor, text) {\n\n  EditAction.call(this, editor, 'SET-DIMENSION', dimension.id);\n\n  this.newFirstAnchor = { x: firstAnchor.x, y: firstAnchor.y };\n  this.newSecondAnchor = { x: secondAnchor.x, y: secondAnchor.y };\n  this.oldFirstAnchor = { x: dimension.firstAnchor.x, y: dimension.firstAnchor.y };\n  this.oldSecondAnchor = { x: dimension.secondAnchor.x, y: dimension.secondAnchor.y };\n  this.newText = text;\n  this.oldText = dimension.currentText;\n}\n\nSetDimension.prototype = Object.create(EditAction.prototype);\nSetDimension.prototype.constructor = SetDimension;\n\nvar proto = SetDimension.prototype;\n\nproto.redo = function () {\n\n  this.applyState(this.newFirstAnchor, this.newSecondAnchor, this.newText);\n\n};\n\nproto.undo = function () {\n\n  this.applyState(this.oldFirstAnchor, this.oldSecondAnchor, this.oldText);\n\n};\n\nproto.merge = function (action) {\n\n  if (this.targetId === action.targetId &&\n  this.type === action.type) {\n\n    this.newFirstAnchor = action.newFirstAnchor;\n    this.newSecondAnchor = action.newSecondAnchor;\n    this.newText = action.newText;\n    return true;\n  }\n  return false;\n};\n\n/**\n    *\n    * @private\n    */\nproto.applyState = function (firstAnchor, secondAnchor, text) {\n\n  var dimension = this.editor.getMarkup(this.targetId);\n\n  if (!dimension) {\n    return;\n  }\n\n  dimension.set(firstAnchor.x, firstAnchor.y, secondAnchor.x, secondAnchor.y, text);\n\n};\n\n/**\n    * @returns {boolean}\n    */\nproto.isIdentity = function () {\n\n  return this.newText === this.oldText && (\n  !this.newFirstAnchor || !this.newSecondAnchor ||\n  this.newFirstAnchor.x === this.oldFirstAnchor.x &&\n  this.newFirstAnchor.y === this.oldFirstAnchor.y &&\n  this.newSecondAnchor.x === this.oldSecondAnchor.x &&\n  this.newSecondAnchor.y === this.oldSecondAnchor.y);\n};","'use strict';\n\nimport { EditAction } from './EditAction';\n\n/**\n                                            *\n                                            * @param editor\n                                            * @param freehand\n                                            * @param position\n                                            * @param size\n                                            * @param locations\n                                            * @constructor\n                                            */\nexport function SetFreehand(editor, freehand, position, size, locations, isAbsoluteCoords) {\n\n  EditAction.call(this, editor, 'SET-FREEHAND', freehand.id);\n\n  this.position = position;\n  this.size = size;\n  this.locations = isAbsoluteCoords ? locations : locations.slice(0);\n  this.isAbsoluteCoords = isAbsoluteCoords;\n\n  // No need to save old data\n}\n\nSetFreehand.prototype = Object.create(EditAction.prototype);\nSetFreehand.prototype.constructor = SetFreehand;\n\nvar proto = SetFreehand.prototype;\n\nproto.redo = function () {\n\n  var freehand = this.editor.getMarkup(this.targetId);\n  if (!freehand) {\n    return;\n  }\n\n  freehand.set(this.position, this.size, this.locations, this.isAbsoluteCoords);\n};\n\nproto.undo = function () {\n  // No need for undo.\n};\n\nproto.merge = function (action) {\n\n  if (this.targetId === action.targetId &&\n  this.type === action.type) {\n\n    this.locations = action.isAbsoluteCoords ? action.locations : action.locations.slice(0);\n    this.position = action.position;\n    this.size = action.size;\n    this.isAbsoluteCoords = action.isAbsoluteCoords;\n    return true;\n  }\n  return false;\n};\n\n/**\n    * @returns {boolean}\n    */\nproto.isIdentity = function () {\n\n  return false; // No need to optimize, always false.\n};","'use strict';\n\nimport { EditAction } from './EditAction';\n\n/**\n                                            *\n                                            * @param editor\n                                            * @param highlight\n                                            * @param position\n                                            * @param size\n                                            * @param locations\n                                            * @constructor\n                                            */\nexport function SetHighlight(editor, highlight, position, size, locations, isAbsoluteCoords) {\n\n  EditAction.call(this, editor, 'SET-HIGHLIGHT', highlight.id);\n\n  this.position = position;\n  this.size = size;\n  this.locations = isAbsoluteCoords ? locations : locations.slice(0);\n  this.isAbsoluteCoords = isAbsoluteCoords;\n\n  // No need to save old data\n}\n\nSetHighlight.prototype = Object.create(EditAction.prototype);\nSetHighlight.prototype.constructor = SetHighlight;\n\nvar proto = SetHighlight.prototype;\n\nproto.redo = function () {\n\n  var highlight = this.editor.getMarkup(this.targetId);\n  if (!highlight) {\n    return;\n  }\n\n  highlight.set(this.position, this.size, this.locations, this.isAbsoluteCoords);\n};\n\nproto.undo = function () {\n  // No need for undo.\n};\n\nproto.merge = function (action) {\n\n  if (this.targetId === action.targetId &&\n  this.type === action.type) {\n\n    this.locations = action.isAbsoluteCoords ? action.locations : action.locations.slice(0);\n    this.position = action.position;\n    this.size = action.size;\n    this.isAbsoluteCoords = action.isAbsoluteCoords;\n    return true;\n  }\n  return false;\n};\n\n/**\n    * @returns {boolean}\n    */\nproto.isIdentity = function () {\n\n  return false; // No need to optimize, always false.\n};","'use strict';\n\nimport { EditAction } from './EditAction';\n\n/**\n                                            *\n                                            * @param editor\n                                            * @param polycloud\n                                            * @param position\n                                            * @param size\n                                            * @param locations\n                                            * @param closed\n                                            * @constructor\n                                            */\nexport function SetPolycloud(editor, polycloud, position, size, locations, closed) {\n\n  EditAction.call(this, editor, 'SET-POLYCLOUD', polycloud.id);\n\n  this.position = position;\n  this.size = size;\n  this.locations = locations.concat();\n  this.closed = closed;\n\n  // No need to save old data\n}\n\nSetPolycloud.prototype = Object.create(EditAction.prototype);\nSetPolycloud.prototype.constructor = SetPolycloud;\n\nvar proto = SetPolycloud.prototype;\n\nproto.redo = function () {\n\n  var polycloud = this.editor.getMarkup(this.targetId);\n  if (!polycloud) {\n    return;\n  }\n\n  polycloud.set(this.position, this.size, this.locations, this.closed);\n};\n\nproto.undo = function () {\n  // No need for undo.\n};\n\nproto.merge = function (action) {\n\n  if (this.targetId === action.targetId &&\n  this.type === action.type) {\n\n    this.locations = action.locations.concat();\n    this.position = action.position;\n    this.size = action.size;\n    this.closed = action.closed;\n    return true;\n  }\n  return false;\n};\n\n/**\n    * @returns {boolean}\n    */\nproto.isIdentity = function () {\n\n  return false; // No need to optimize, always false.\n};","'use strict';\n\nimport { EditAction } from './EditAction';\n\n/**\n                                            *\n                                            * @param editor\n                                            * @param polyline\n                                            * @param position\n                                            * @param size\n                                            * @param locations\n                                            * @param closed\n                                            * @constructor\n                                            */\nexport function SetPolyline(editor, polyline, position, size, locations, closed) {\n\n  EditAction.call(this, editor, 'SET-POLYLINE', polyline.id);\n\n  this.position = position;\n  this.size = size;\n  this.locations = locations.concat();\n  this.closed = closed;\n\n  // No need to save old data\n}\n\nSetPolyline.prototype = Object.create(EditAction.prototype);\nSetPolyline.prototype.constructor = SetPolyline;\n\nvar proto = SetPolyline.prototype;\n\nproto.redo = function () {\n\n  var polyline = this.editor.getMarkup(this.targetId);\n  if (!polyline) {\n    return;\n  }\n\n  polyline.set(this.position, this.size, this.locations, this.closed);\n};\n\nproto.undo = function () {\n  // No need for undo.\n};\n\nproto.merge = function (action) {\n\n  if (this.targetId === action.targetId &&\n  this.type === action.type) {\n\n    this.locations = action.locations.concat();\n    this.position = action.position;\n    this.size = action.size;\n    this.closed = action.closed;\n    return true;\n  }\n  return false;\n};\n\n/**\n    * @returns {boolean}\n    */\nproto.isIdentity = function () {\n\n  return false; // No need to optimize, always false.\n};","'use strict';\n\nimport { EditAction } from './EditAction';\n\nexport function SetPosition(editor, markup, position) {\n\n  EditAction.call(this, editor, 'SET-POSITION', markup.id);\n\n  this.newPosition = { x: position.x, y: position.y };\n  this.oldPosition = { x: markup.position.x, y: markup.position.y };\n}\n\nSetPosition.prototype = Object.create(EditAction.prototype);\nSetPosition.prototype.constructor = SetPosition;\n\nvar proto = SetPosition.prototype;\n\nproto.redo = function () {\n\n  var markup = this.editor.getMarkup(this.targetId);\n  markup && markup.setPosition(this.newPosition.x, this.newPosition.y);\n};\n\nproto.undo = function () {\n\n  var markup = this.editor.getMarkup(this.targetId);\n  markup && markup.setPosition(this.oldPosition.x, this.oldPosition.y);\n};\n\n/**\n    *\n    * @param action\n    * @returns {boolean}\n    */\nproto.merge = function (action) {\n\n  if (this.targetId === action.targetId &&\n  this.type === action.type) {\n\n    this.newPosition = action.newPosition;\n    return true;\n  }\n  return false;\n};\n\n/**\n    * @returns {boolean}\n    */\nproto.isIdentity = function () {\n\n  var newPosition = this.newPosition;\n  var oldPosition = this.oldPosition;\n\n  return newPosition.x === oldPosition.x && newPosition.y === oldPosition.y;\n};","'use strict';\n\nimport { EditAction } from './EditAction';\n\n/**\n                                            *\n                                            * @param editor\n                                            * @param rectangle\n                                            * @param position\n                                            * @param size\n                                            * @constructor\n                                            */\nexport function SetRectangle(editor, rectangle, position, size) {\n\n  EditAction.call(this, editor, 'SET-RECTANGLE', rectangle.id);\n\n  this.newPosition = { x: position.x, y: position.y };\n  this.newSize = { x: size.x, y: size.y };\n  this.oldPosition = { x: rectangle.position.x, y: rectangle.position.y };\n  this.oldSize = { x: rectangle.size.x, y: rectangle.size.y };\n}\n\nSetRectangle.prototype = Object.create(EditAction.prototype);\nSetRectangle.prototype.constructor = SetRectangle;\n\nvar proto = SetRectangle.prototype;\n\nproto.redo = function () {\n\n  this.applyState(this.targetId, this.newPosition, this.newSize);\n};\n\nproto.undo = function () {\n\n  this.applyState(this.targetId, this.oldPosition, this.oldSize);\n};\n\nproto.merge = function (action) {\n\n  if (this.targetId === action.targetId &&\n  this.type === action.type) {\n\n    this.newPosition = action.newPosition;\n    this.newSize = action.newSize;\n    return true;\n  }\n  return false;\n};\n\n/**\n    *\n    * @private\n    */\nproto.applyState = function (targetId, position, size) {\n\n  var rectangle = this.editor.getMarkup(targetId);\n  if (!rectangle) {\n    return;\n  }\n\n  // Different stroke widths make positions differ at sub-pixel level.\n  var epsilon = 0.0001;\n\n  if (Math.abs(rectangle.position.x - position.x) > epsilon || Math.abs(rectangle.size.y - size.y) > epsilon ||\n  Math.abs(rectangle.position.y - position.y) > epsilon || Math.abs(rectangle.size.y - size.y) > epsilon) {\n\n    rectangle.set(position, size);\n  }\n};\n\n/**\n    * @returns {boolean}\n    */\nproto.isIdentity = function () {\n\n  return (\n    this.newPosition.x === this.oldPosition.x &&\n    this.newPosition.y === this.oldPosition.y &&\n    this.newSize.x === this.oldSize.x &&\n    this.newSize.y === this.oldSize.y);\n};","'use strict';\n\nimport { EditAction } from './EditAction';\n\n/**\n                                            *\n                                            * @param editor\n                                            * @param markup\n                                            * @param angle\n                                            * @constructor\n                                            */\nexport function SetRotation(editor, markup, angle) {\n\n  EditAction.call(this, editor, 'SET-ROTATION', markup.id);\n\n  var curAngle = markup.getRotation();\n\n  this.newRotation = { angle: angle };\n  this.oldRotation = { angle: curAngle };\n}\n\nSetRotation.prototype = Object.create(EditAction.prototype);\nSetRotation.prototype.constructor = SetRotation;\n\nvar proto = SetRotation.prototype;\n\nproto.redo = function () {\n\n  var markup = this.editor.getMarkup(this.targetId);\n  markup && markup.setRotation(this.newRotation.angle);\n};\n\nproto.undo = function () {\n\n  var markup = this.editor.getMarkup(this.targetId);\n  markup && markup.setRotation(this.oldRotation.angle);\n};\n\n/**\n    *\n    * @param action\n    * @returns {boolean}\n    */\nproto.merge = function (action) {\n\n  if (this.targetId === action.targetId &&\n  this.type === action.type) {\n\n    this.newRotation = action.newRotation;\n    return true;\n  }\n  return false;\n};\n\n/**\n    * @returns {boolean}\n    */\nproto.isIdentity = function () {\n\n  return this.newRotation.angle === this.oldRotation.angle;\n};","'use strict';\n\nimport { EditAction } from './EditAction';\n\n/**\n                                            *\n                                            * @param editor\n                                            * @param markup\n                                            * @param position\n                                            * @param width\n                                            * @param height\n                                            * @constructor\n                                            */\nexport function SetSize(editor, markup, position, width, height) {\n\n  EditAction.call(this, editor, 'SET-SIZE', markup.id);\n\n  this.newPosition = { x: position.x, y: position.y };\n  this.oldPosition = { x: markup.position.x, y: markup.position.y };\n  this.newWidth = width;\n  this.oldWidth = markup.size.x;\n  this.newHeight = height;\n  this.oldHeight = markup.size.y;\n}\n\nSetSize.prototype = Object.create(EditAction.prototype);\nSetSize.prototype.constructor = SetSize;\n\nvar proto = SetSize.prototype;\n\nproto.redo = function () {\n\n  var markup = this.editor.getMarkup(this.targetId);\n  markup && markup.setSize(this.newPosition, this.newWidth, this.newHeight);\n};\n\nproto.undo = function () {\n\n  var markup = this.editor.getMarkup(this.targetId);\n  markup && markup.setSize(this.oldPosition, this.oldWidth, this.oldHeight);\n};\n\nproto.merge = function (action) {\n\n  if (this.targetId === action.targetId &&\n  this.type === action.type) {\n\n    this.newPosition = action.newPosition;\n    this.newWidth = action.newWidth;\n    this.newHeight = action.newHeight;\n    return true;\n  }\n  return false;\n};\n\n/**\n    * @returns {boolean}\n    */\nproto.isIdentity = function () {\n\n  var identity =\n  this.newPosition.x === this.oldPosition.x &&\n  this.newPosition.y === this.oldPosition.y &&\n  this.newWidth === this.oldWidth &&\n  this.newHeight === this.oldHeight;\n\n  return identity;\n};","'use strict';function _typeof(obj) {\"@babel/helpers - typeof\";if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;};}return _typeof(obj);}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError(\"Cannot call a class as a function\");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}function _inherits(subClass, superClass) {if (typeof superClass !== \"function\" && superClass !== null) {throw new TypeError(\"Super expression must either be null or a function\");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}function _createSuper(Derived) {var hasNativeReflectConstruct = _isNativeReflectConstruct();return function _createSuperInternal() {var Super = _getPrototypeOf(Derived),result;if (hasNativeReflectConstruct) {var NewTarget = _getPrototypeOf(this).constructor;result = Reflect.construct(Super, arguments, NewTarget);} else {result = Super.apply(this, arguments);}return _possibleConstructorReturn(this, result);};}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");}return self;}function _isNativeReflectConstruct() {if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;if (Reflect.construct.sham) return false;if (typeof Proxy === \"function\") return true;try {Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));return true;} catch (e) {return false;}}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}\n\nimport { EditAction } from './EditAction';\n\nexport { SetStamp };var\n\nSetStamp = /*#__PURE__*/function (_EditAction) {_inherits(SetStamp, _EditAction);var _super = _createSuper(SetStamp);\n  function SetStamp(editor, stamp, position, size) {var _this;_classCallCheck(this, SetStamp);\n    _this = _super.call(this, editor, 'SET-STAMP', stamp.id);\n\n    _this.newPosition = { x: position.x, y: position.y };\n    _this.newSize = { x: size.x, y: size.y };\n    _this.oldPosition = { x: stamp.position.x, y: stamp.position.y };\n    _this.oldSize = { x: stamp.size.x, y: stamp.size.y };return _this;\n  }_createClass(SetStamp, [{ key: \"redo\", value: function redo()\n\n    {\n      this.applyState(this.targetId, this.newPosition, this.newSize);\n    } }, { key: \"undo\", value: function undo()\n\n    {\n      this.applyState(this.targetId, this.oldPosition, this.oldSize);\n    } }, { key: \"merge\", value: function merge(\n\n    action) {\n      if (this.targetId === action.targetId && this.type === action.type) {\n        this.newPosition = action.newPosition;\n        this.newSize = action.newSize;\n        return true;\n      }\n\n      return false;\n    } }, { key: \"applyState\", value: function applyState(\n\n    targetId, position, size) {\n      var stamp = this.editor.getMarkup(targetId);\n      if (!stamp) {\n        return;\n      }\n\n      // Different stroke widths make positions differ at sub-pixel level.\n      var epsilon = 0.0001;\n      if (\n      Math.abs(stamp.position.x - position.x) > epsilon ||\n      Math.abs(stamp.position.y - position.y) > epsilon ||\n      Math.abs(stamp.size.x - size.x) > epsilon ||\n      Math.abs(stamp.size.y - size.y) > epsilon)\n      {\n        stamp.set(position, size);\n      }\n    } }, { key: \"isIdentity\", value: function isIdentity()\n\n    {\n      return (\n        this.newPosition.x === this.oldPosition.x &&\n        this.newPosition.y === this.oldPosition.y &&\n        this.newSize.x === this.oldSize.x &&\n        this.newSize.y === this.newSize.y);\n\n    } }]);return SetStamp;}(EditAction);","'use strict';\n\nimport { EditAction } from './EditAction';\nimport { cloneStyle } from '../StyleUtils';\n\n/**\n                                             *\n                                             * @param editor\n                                             * @param markup\n                                             * @param style\n                                             * @constructor\n                                             */\nexport function SetStyle(editor, markup, style) {\n\n  EditAction.call(this, editor, 'SET-STYLE', markup.id);\n\n  this.newStyle = cloneStyle(style);\n  this.oldStyle = markup.getStyle();\n}\n\nSetStyle.prototype = Object.create(EditAction.prototype);\nSetStyle.prototype.constructor = SetStyle;\n\nvar proto = SetStyle.prototype;\n\nproto.redo = function () {\n\n  var markup = this.editor.getMarkup(this.targetId);\n  markup && markup.setStyle(this.newStyle);\n};\n\nproto.undo = function () {\n\n  var markup = this.editor.getMarkup(this.targetId);\n  markup && markup.setStyle(this.oldStyle);\n};","'use strict';\n\nimport { EditAction } from './EditAction';\n\n/**\n                                            *\n                                            * @param editor\n                                            * @param markup\n                                            * @param position\n                                            * @param size\n                                            * @param text\n                                            * @constructor\n                                            */\nexport function SetText(editor, markup, position, size, text) {\n\n  EditAction.call(this, editor, 'SET-TEXT', markup.id);\n\n  this.newPosition = { x: position.x, y: position.y };\n  this.oldPosition = { x: markup.position.x, y: markup.position.y };\n  this.newSize = { x: size.x, y: size.y };\n  this.oldSize = { x: markup.size.x, y: markup.size.y };\n  this.newText = text;\n  this.oldText = markup.getText();\n}\n\nSetText.prototype = Object.create(EditAction.prototype);\nSetText.prototype.constructor = SetText;\n\nvar proto = SetText.prototype;\n\nproto.redo = function () {\n\n  var text = this.editor.getMarkup(this.targetId);\n  text && text.set(this.newPosition, this.newSize, this.newText);\n};\n\nproto.undo = function () {\n\n  var text = this.editor.getMarkup(this.targetId);\n  text && text.set(this.oldPosition, this.oldSize, this.oldText);\n};","'use strict';\n\nimport { CloneMarkup } from '../edit-actions/CloneMarkup';\nimport { addTraitEventDispatcher } from '../MarkupsCoreUtils';\n\n/**\n                                                                *\n                                                                * @param editor\n                                                                * @constructor\n                                                                */\nexport function Clipboard(editor) {\n\n  this.editor = editor;\n  this.content = null;\n  this.pastePosition = { x: 0, y: 0 };\n\n  addTraitEventDispatcher(this);\n}\n\nvar proto = Clipboard.prototype;\n\nproto.copy = function () {\n\n  var selectedMarkup = this.editor.getSelection();\n  if (!selectedMarkup) {\n    return;\n  }\n\n  this.content = selectedMarkup.clone();\n  this.pastePosition.x = selectedMarkup.position.x;\n  this.pastePosition.y = selectedMarkup.position.y;\n};\n\nproto.cut = function () {\n\n  var selectedMarkup = this.editor.getSelection();\n  if (!selectedMarkup) {\n    return;\n  }\n\n  this.copy();\n  this.editor.deleteMarkup(selectedMarkup);\n};\n\nproto.paste = function () {\n\n  var content = this.content;\n  if (!content) {\n    return;\n  }\n\n  var editor = this.editor;\n  var position = this.pastePosition;\n  var delta = editor.sizeFromClientToMarkups(20, 20);\n\n  position.x += delta.x;\n  position.y -= delta.y;\n\n  var cloneMarkup = new CloneMarkup(editor, editor.getId(), content, position);\n  cloneMarkup.execute();\n};","'use strict';\n\nimport { isTouchDevice } from '../MarkupsCoreUtils';\n\nvar av = Autodesk.Viewing;\nvar avp = av.Private;\n\nvar _mouseEnabled = false;\nvar _mousePrevValue = false;\nvar _lock = false;\n\nexport function InputHandler() {\n\n  this.editor = null;\n  this.mousePosition = { x: 0, y: 0 };\n  this.makeSameXY = false; // TODO: FIND a better way to name and communicate these.\n  this.snapRotations = false;\n  this.keepAspectRatio = false;\n  this.constrainAxis = false;\n  this.duringEditMode = false;\n\n  this.onWheelBinded = this.onWheel.bind(this);\n  this.onTouchDragBinded = this.onTouchDrag.bind(this);\n  this.onTouchPanBinded = this.onTouchPan.bind(this);\n  this.onTouchPinchBinded = this.onTouchPinch.bind(this);\n  this.onSingleTapBinded = this.onSingleTap.bind(this);\n  this.onDoubleTapBinded = this.onDoubleTap.bind(this);\n  this.onMouseMoveBinded = this.onMouseMove.bind(this);\n  this.onMouseUpBinded = this.onMouseUp.bind(this);\n  this.onMouseDownBinded = this.onMouseDown.bind(this);\n  this.onMouseDoubleClickBinded = this.onMouseDoubleClick.bind(this);\n  this.onHammerInputBinded = this.onHammerInput.bind(this);\n  this.isMouseDown = false;\n}\n\nav.GlobalManagerMixin.call(InputHandler.prototype);\nvar proto = InputHandler.prototype;\n\nproto.attachTo = function (editor) {\n\n  this.editor && this.detachFrom(this.editor);\n  this.editor = editor;\n\n  if (isTouchDevice()) {\n\n    this.hammer = new av.Hammer.Manager(editor.svg, {\n      recognizers: [\n      av.GestureRecognizers.drag,\n      av.GestureRecognizers.doubletap,\n      av.GestureRecognizers.doubletap2,\n      av.GestureRecognizers.singletap,\n      av.GestureRecognizers.singletap2,\n      av.GestureRecognizers.press,\n      av.GestureRecognizers.pan,\n      av.GestureRecognizers.pinch],\n\n      handlePointerEventMouse: false,\n      inputClass: av.isIE11 ? av.Hammer.PointerEventInput : av.Hammer.TouchInput });\n\n\n    this.hammer.get('doubletap2').recognizeWith('doubletap');\n    this.hammer.get('singletap2').recognizeWith('singletap');\n    this.hammer.get('singletap').requireFailure('doubletap');\n  }\n};\n\nproto.onHammerInput = function (event) {\n\n  this.setMouseDisabledWhenTouching(event);\n};\n\nproto.setMouseDisabledWhenTouching = function (event) {\n\n  if (event.isFirst && !_lock) {\n    this.enableMouseButtons(false);\n    _lock = true;\n  } else if (event.isFinal) {\n    var _this = this;\n    setTimeout(function () {\n      _this.enableMouseButtons(_mousePrevValue);\n      _lock = false;\n    }, 10);\n  }\n};\n\nproto.enableMouseButtons = function (state) {\n\n  if (state && !_mouseEnabled)\n  {\n    this.editor.svg.addEventListener('mousedown', this.onMouseDownBinded);\n    this.editor.svg.addEventListener('dblclick', this.onMouseDoubleClickBinded);\n    this.editor.svg.addEventListener('wheel', this.onWheelBinded);\n    this.editor.svg.addEventListener('DOMMouseScroll', this.onWheelBinded); // Firefox\n\n    // The mouseup and mousemove listeners are at the document level to handle the case where\n    // mouse was held inside the canvas and released outside. \n    // When this happens, we don't want the editing to be in a hung state and cancel it\n    this.addDocumentEventListener('mousemove', this.onMouseMoveBinded);\n    this.addDocumentEventListener('mouseup', this.onMouseUpBinded);\n  } else\n  if (!state && _mouseEnabled)\n  {\n    this.editor.svg.removeEventListener('mousedown', this.onMouseDownBinded);\n    this.editor.svg.removeEventListener('dblclick', this.onMouseDoubleClickBinded);\n    this.editor.svg.removeEventListener('wheel', this.onWheelBinded);\n    this.editor.svg.removeEventListener('DOMMouseScroll', this.onWheelBinded);\n    this.removeDocumentEventListener('mousemove', this.onMouseMoveBinded);\n    this.removeDocumentEventListener('mouseup', this.onMouseUpBinded);\n\n  }\n\n  _mousePrevValue = _mouseEnabled;\n  _mouseEnabled = state;\n};\n\nproto.detachFrom = function (editor) {\n\n  this.hammer && this.hammer.destroy();\n\n  this.removeDocumentEventListener('mousemove', this.onMouseMoveBinded);\n  this.removeDocumentEventListener('mouseup', this.onMouseUpBinded);\n\n  if (this.editor) {\n    this.editor.svg.removeEventListener('mousedown', this.onMouseDownBinded);\n    this.editor.svg.removeEventListener('dblclick', this.onMouseDoubleClickBinded);\n  }\n\n  this.editor = editor;\n};\n\nproto.enterEditMode = function () {\n  if (this.duringEditMode) {\n    return;\n  }\n\n  if (this.hammer) {\n    this.hammer.on('dragstart dragmove dragend', this.onTouchDragBinded);\n    this.hammer.on('panstart panmove panend', this.onTouchPanBinded);\n    this.hammer.on('pinchstart pinchmove pinchend', this.onTouchPinchBinded);\n    this.hammer.on('singletap', this.onSingleTapBinded);\n    this.hammer.on('singletap2', this.onSingleTapBinded);\n    this.hammer.on('doubletap', this.onDoubleTapBinded);\n    this.hammer.on('doubletap2', this.onDoubleTapBinded);\n    this.hammer.on('hammer.input', this.onHammerInputBinded);\n\n    this.hammer.get('drag').requireFailure('pinch');\n    this.hammer.get('drag').requireFailure('pan');\n  }\n\n  if (!av.isMobileDevice()) {\n    this.enableMouseButtons(true);\n  }\n\n  this.duringEditMode = true;\n};\n\nproto.leaveEditMode = function () {\n  if (!this.duringEditMode) {\n    return;\n  }\n\n  if (this.hammer) {\n    this.hammer.off('dragstart dragmove dragend', this.onTouchDragBinded);\n    this.hammer.off('panstart panmove panend', this.onTouchPanBinded);\n    this.hammer.off('pinchstart pinchmove pinchend', this.onTouchPinchBinded);\n    this.hammer.off('singletap', this.onSingleTapBinded);\n    this.hammer.off('singletap2', this.onSingleTapBinded);\n    this.hammer.off('doubletap', this.onDoubleTapBinded);\n    this.hammer.off('doubletap2', this.onDoubleTapBinded);\n    this.hammer.off('hammer.input', this.onHammerInputBinded);\n  }\n\n  if (!av.isMobileDevice()) {\n    this.enableMouseButtons(false);\n  }\n\n  this.duringEditMode = false;\n};\n\nproto.enterViewMode = function () {\n\n};\n\nproto.leaveViewMode = function () {\n\n};\n\nproto.getMousePosition = function () {\n\n  return { x: this.mousePosition.x, y: this.mousePosition.y };\n};\n\nproto.onWheel = function (event) {\n\n  if (!av.isMobileDevice()) {\n    this.editor.viewer.toolController.mousewheel(event);\n  }\n\n  event.preventDefault();\n};\n\nproto.onMouseMove = function (event) {\n\n  processMouseEvent(this, event);\n\n  if (!av.isMobileDevice() && this.editor.viewer.container.contains(event.target)) {\n    this.editor.viewer.toolController.mousemove(event);\n  }\n\n  if (this.editor.onMouseMove(event)) {\n    // editor handled the event\n    event.preventDefault();\n  }\n};\n\n\nproto.onMouseDownRightClick = function (event) {\n\n  var _document = this.getDocument();\n  // Don't do blur in full screen (IE issue)\n  if (!(av.isIE11 && av.inFullscreen(_document))) {\n    _document.activeElement && _document.activeElement.blur && _document.activeElement.blur();\n  }\n\n  var controller = this.editor.viewer.toolController;\n  controller.__clientToCanvasCoords(event);\n\n  this.editor.markupTool.handleButtonDown(event, 2);\n};\n\nproto.onMouseUpRightClick = function (event) {\n\n  var controller = this.editor.viewer.toolController;\n  controller.__clientToCanvasCoords(event);\n\n  this.editor.markupTool.handleButtonUp(event, 2);\n};\n\nproto.onMouseDown = function (event) {\n\n  processMouseEvent(this, event);\n\n  // Panning when right clicking\n  if (!av.isMobileDevice() && (avp.isRightClick(event, this.editor.viewer.navigation) || avp.isMiddleClick(event))) {\n    this.onMouseDownRightClick(event);\n    return;\n  }\n\n  this.isMouseDown = true;\n  this.editor.onMouseDown(event);\n  event.preventDefault();\n};\n\nproto.onMouseUp = function (event) {\n\n  processMouseEvent(this, event);\n\n  if (!av.isMobileDevice() && this.editor.viewer.container.contains(event.target) && (\n  avp.isRightClick(event, this.editor.viewer.navigation) || avp.isMiddleClick(event)))\n  {\n    this.onMouseUpRightClick(event);\n    return;\n  }\n\n  this.isMouseDown = false;\n  if (this.editor.onMouseUp(event)) {\n    // editor handled the event\n    event.preventDefault();\n  }\n};\n\nproto.onMouseDoubleClick = function (event) {\n\n  processMouseEvent(this, event);\n  this.editor.onMouseDoubleClick(event);\n  event.preventDefault();\n};\n\nproto.onTouchDrag = function (event) {\n\n  convertEventHammerToMouse(event);\n  switch (event.type) {\n    case 'dragstart':\n      this.onMouseDown(event);\n      break;\n    case 'dragmove':\n      this.onMouseMove(event);\n      break;\n    case 'dragend':\n      this.onMouseUp(event);\n      break;}\n\n  event.preventDefault();\n};\n\nproto.onTouchPan = function (event) {\n\n  var gestureHandler = this.editor.viewer.toolController.getTool(\"gestures\");\n  gestureHandler.distributeGesture(event);\n  event.preventDefault();\n};\n\nproto.onTouchPinch = function (event) {\n\n  processMouseEvent(this, event);\n\n  var gestureHandler = this.editor.viewer.toolController.getTool(\"gestures\");\n  gestureHandler.distributeGesture(event);\n\n  this.mousePosition.x = this.mousePosition.y = null;\n  this.editor.callSnapperMouseMove();\n\n  event.preventDefault();\n};\n\nproto.onSingleTap = function (event) {\n\n  convertEventHammerToMouse(event);\n\n  this.onMouseDown(event);\n  this.onMouseUp(event);\n  event.preventDefault();\n};\n\nproto.onDoubleTap = function (event) {\n\n  convertEventHammerToMouse(event);\n  this.onMouseDoubleClick(event);\n  event.preventDefault();\n};\n\nfunction processMouseEvent(input, event) {\n\n  var rect = input.editor.svg.getBoundingClientRect();\n\n  input.makeSameXY = event.shiftKey;\n  input.snapRotations = event.shiftKey;\n  input.keepAspectRatio = event.shiftKey;\n  input.constrainAxis = event.shiftKey;\n\n  input.mousePosition.x = event.clientX - rect.left;\n  input.mousePosition.y = event.clientY - rect.top;\n}\n\nfunction convertEventHammerToMouse(event) {\n\n  // Convert Hammer touch-event X,Y into mouse-event X,Y.\n  event.shiftKey = false;\n  event.clientX = event.pointers[0].clientX;\n  event.clientY = event.pointers[0].clientY;\n}","\nimport { theEditModeManager } from '../EditModeManager';\nimport * as MarkupTypes from '../MarkupTypes';\n\nimport { EditModeArrow } from './EditModeArrow';\nimport { EditModeText } from './EditModeText';\nimport { EditModeRectangle } from './EditModeRectangle';\nimport { EditModeCircle } from './EditModeCircle';\nimport { EditModeCloud } from './EditModeCloud';\nimport { EditModeFreehand } from './EditModeFreehand';\nimport { EditModeHighlight } from './EditModeHighlight';\nimport { EditModePolyline } from './EditModePolyline';\nimport { EditModePolycloud } from './EditModePolycloud';\nimport { EditModeCallout } from './EditModeCallout';\nimport { EditModeDimension } from './EditModeDimension';\nimport { EditModeStamp } from './EditModeStamp';\n\n\ntheEditModeManager.register(MarkupTypes.MARKUP_TYPE_ARROW, EditModeArrow);\ntheEditModeManager.register(MarkupTypes.MARKUP_TYPE_TEXT, EditModeText);\ntheEditModeManager.register(MarkupTypes.MARKUP_TYPE_RECTANGLE, EditModeRectangle);\ntheEditModeManager.register(MarkupTypes.MARKUP_TYPE_CIRCLE, EditModeCircle);\ntheEditModeManager.register(MarkupTypes.MARKUP_TYPE_CLOUD, EditModeCloud);\ntheEditModeManager.register(MarkupTypes.MARKUP_TYPE_FREEHAND, EditModeFreehand);\ntheEditModeManager.register(MarkupTypes.MARKUP_TYPE_HIGHLIGHT, EditModeHighlight);\ntheEditModeManager.register(MarkupTypes.MARKUP_TYPE_POLYLINE, EditModePolyline);\ntheEditModeManager.register(MarkupTypes.MARKUP_TYPE_POLYCLOUD, EditModePolycloud);\ntheEditModeManager.register(MarkupTypes.MARKUP_TYPE_CALLOUT, EditModeCallout);\ntheEditModeManager.register(MarkupTypes.MARKUP_TYPE_DIMENSION, EditModeDimension);\ntheEditModeManager.register(MarkupTypes.MARKUP_TYPE_STAMP, EditModeStamp);","'use strict';\n\nimport * as MarkupEvents from '../MarkupEvents';\nimport { createStyle, copyStyle } from '../StyleUtils';\nimport { addTraitEventDispatcher, removeTraitEventDispatcher, sign } from '../MarkupsCoreUtils';\nimport { SetStyle } from '../edit-actions/SetStyle';\n\nvar av = Autodesk.Viewing;\n\n/**\n                            * Base class for all markup edit modes.\n                            *\n                            * An EditMode is responsible for handling user input to create and edit a\n                            * {@link Autodesk.Viewing.Extensions.Markups.Core.Markup|Markup}.\n                            *\n                            * Any class extending Markup should contain at least the following methods:\n                            * - deleteMarkup()\n                            * - onMouseDown()\n                            * - onMouseMove()\n                            *\n                            * A good reference is the Circle EditMode implementation available in\n                            * {@link Autodesk.Viewing.Extensions.Markups.Core.EditModeCircle|EditModeCircle}.\n                            *\n                            * @tutorial feature_markup\n                            * @constructor\n                            * @memberof Autodesk.Viewing.Extensions.Markups.Core\n                            *\n                            * @param {Autodesk.Viewing.Extensions.Markups.Core.MarkupsCore} editor - Markups extension.\n                            * @param {String} type - An identifier for the EditMode type. Not to be confused by the Markup's id.\n                            * @param {Array} styleAttributes - Attributes for customization.\n                            * @constructor\n                            */\nexport function EditMode(editor, type, styleAttributes) {\n\n  this.editor = editor;\n  this.viewer = editor.viewer;\n  this.setGlobalManager(this.viewer.globalManager);\n  this.type = type;\n  this.selectedMarkup = null;\n  this.dragging = false;\n  this.draggingAnnotationIniPosition = null;\n  this.draggingMouseIniPosition = new THREE.Vector2();\n  this.initialX = 0;\n  this.initialY = 0;\n  this.minSize = 9; // In pixels\n  this.creating = false;\n  this.size = { x: 0, y: 0 };\n  this.style = createStyle(styleAttributes, this.editor);\n  this.style = copyStyle(editor.getDefaultStyle(), this.style);\n\n  this.CREATION_METHOD_DRAG = 'CREATION_METHOD_DRAG';\n  this.CREATION_METHOD_CLICK = 'CREATION_METHOD_CLICK';\n  this.CREATION_METHOD_CLICKS = 'CREATION_METHOD_CLICKS';\n  this.creationMethod = this.CREATION_METHOD_DRAG;\n\n  addTraitEventDispatcher(this);\n}\n\nav.GlobalManagerMixin.call(EditMode.prototype);\nvar proto = EditMode.prototype;\n\nproto.destroy = function () {\n\n  this.unselect();\n  removeTraitEventDispatcher(this);\n};\n\nproto.unselect = function () {\n\n  var fireEv = false;\n  var selectedMarkup = this.selectedMarkup;\n  var selectedId = null;\n\n  if (selectedMarkup) {\n    selectedId = selectedMarkup.id;\n    selectedMarkup.unselect();\n    this.selectedMarkup = null;\n    fireEv = true;\n  }\n\n  this.editor.editFrame.setMarkup(null);\n\n  if (fireEv) {\n    this.dispatchEvent({ type: MarkupEvents.EVENT_MARKUP_DESELECT, markupId: selectedId });\n  }\n};\n\nproto.creationBegin = function () {\n\n  if (this.creating) {\n    return;\n  }\n\n  this.creating = true;\n  this.dispatchEvent({ type: MarkupEvents.EVENT_EDITMODE_CREATION_BEGIN });\n};\n\nproto.creationEnd = function (isCancelling) {\n\n  if (!this.creating) {\n    return false;\n  }\n\n  if (this.creationMethod !== this.CREATION_METHOD_CLICK) {\n\n    if (this.selectedMarkup && !this.isMinSizeValid()) {\n\n      this.creationCancel();\n      isCancelling = true;\n    } else {\n\n      if (this.creationMethod === this.CREATION_METHOD_DRAG) {\n        this.finishDragging();\n      }\n\n      if (this.selectedMarkup) {\n\n        // Opened on mouse down.\n        this.editor.closeActionGroup();\n        this.selectedMarkup = null;\n      }\n    }\n  }\n\n  this.creating = false;\n  this.dispatchEvent({ type: MarkupEvents.EVENT_EDITMODE_CREATION_END, creationCancelled: !!isCancelling });\n  return true;\n};\n\nproto.creationCancel = function () {\n\n  this.editor.cancelActionGroup();\n  this.creationEnd(true);\n  this.selectedMarkup = null; // No need to call unselect\n};\n\n/**\n    *\n    * @param style\n    */\nproto.setStyle = function (style) {\n\n  this.style = style;\n\n  var selectedMarkup = this.selectedMarkup;\n  if (!selectedMarkup) {\n    return;\n  }\n\n  var setStyle = new SetStyle(this.editor, selectedMarkup, style);\n  setStyle.execute();\n};\n\nproto.getStyle = function () {\n\n  return this.style;\n};\n\nproto.setSelection = function (markup) {\n\n  if (this.selectedMarkup !== markup) {\n    this.unselect();\n    markup && markup.select();\n  }\n\n  this.selectedMarkup = markup;\n\n  var editor = this.editor;\n  markup && editor.bringToFront(markup);\n\n  if (this.isTextInputHelperActive() && editor.editFrame.markup) {\n    this.textInputHelper.setEditFrame();\n  } else if (!this.creating) {\n    editor.editFrame.setMarkup(markup);\n  }\n};\n\nproto.getSelection = function () {\n\n  return this.selectedMarkup;\n};\n\n/**\n    *\n    * @param [markup] If provided deletes markup (has to have same type that the edit mode), otherwise deletes selected one.\n    * @param [cantUndo] If true to not add deletion to undo history.\n    * @returns {boolean}\n    */\nproto.deleteMarkup = function (markup, cantUndo) {\n\n  return false;\n};\n\n/**\n    * Used by classes extending EditMode to validate the minimum size (in screen coordinates) of the markup.\n    * See minSize attribute\n    * @return {Boolean} Whether current size is valid for creating the markup\n    * @private\n    */\nproto.isMinSizeValid = function () {\n\n  if (this.minSize !== 0) {\n\n    var tmp = this.editor.sizeFromMarkupsToClient(this.size.x, this.size.y);\n    return tmp.x * tmp.x + tmp.y * tmp.y >= this.minSize * this.minSize;\n\n  }\n  return true;\n};\n\n/**\n    * @private\n    */\nproto.startDragging = function () {\n\n  var selectedMarkup = this.selectedMarkup;\n  var mousePosition = this.editor.getMousePosition();\n\n  if (selectedMarkup) {\n\n    this.dragging = true;\n    this.draggingAnnotationIniPosition = selectedMarkup.getClientPosition();\n    this.draggingMouseIniPosition.set(mousePosition.x, mousePosition.y);\n  }\n};\n\n/**\n    * @private\n    */\nproto.finishDragging = function () {\n\n  var dragging = this.dragging;\n  var selectedMarkup = this.selectedMarkup;\n\n  this.dragging = false;\n\n  if (selectedMarkup && dragging) {\n\n    selectedMarkup.finishDragging();\n  }\n};\n\n/**\n    *\n    * @returns {{x: number, y: number}}\n    */\nproto.getFinalMouseDraggingPosition = function () {\n\n  var editor = this.editor;\n  var bounds = editor.getBounds();\n  var mousePosition = editor.getMousePosition();\n\n  var initialX = this.initialX;\n  var initialY = this.initialY;\n\n  var finalX = Math.min(Math.max(bounds.x, mousePosition.x), bounds.x + bounds.width);\n  var finalY = Math.min(Math.max(bounds.y, mousePosition.y), bounds.y + bounds.height);\n\n  if (finalX == initialX &&\n  finalY == initialY) {\n    finalX++;\n    finalY++;\n  }\n\n  // Make equal x/y when shift is down\n  if (editor.input.makeSameXY) {\n    var dx = Math.abs(finalX - initialX);\n    var dy = Math.abs(finalY - initialY);\n\n    var maxDelta = Math.max(dx, dy);\n\n    // These calculations have the opportunity to go beyond 'bounds'.\n    finalX = initialX + maxDelta * sign(finalX - initialX);\n    finalY = initialY + maxDelta * sign(finalY - initialY);\n  }\n\n  return { x: finalX, y: finalY };\n};\n\nproto.notifyAllowNavigation = function (allows) {\n\n};\n\nproto.onMouseMove = function (event) {\n  if (!this.selectedMarkup || !this.creating) {\n    return false;\n  }\n  return true;\n};\n\nproto.onMouseDown = function () {\n\n};\n\n/**\n    * Handler to mouse up events, used to start annotations creation.\n    * It will cancel the creation of a markup if its minSize conditions are not met.\n    *\n    * @param {MouseEvent} event Mouse event.\n    * @private\n    */\nproto.onMouseUp = function (event) {\n\n  if (this.creationMethod !== this.CREATION_METHOD_DRAG) {\n    return false;\n  }\n\n  return this.creationEnd();\n};\n\nproto.onMouseDoubleClick = function (event) {\n\n  if (this.creationMethod !== this.CREATION_METHOD_CLICKS) {\n    return;\n  }\n\n  this.creationEnd();\n};\n\n/**\n    * Notify the markup that the displayed markups are being saved so edit mode can finish current editions.\n    */\nproto.onSave = function () {\n\n  if (this.creating) {\n    this.creationCancel();\n  }\n};\n\n/**\n    *\n    * @returns {{x: *, y: *}}\n    */\nproto.getDraggingPosition = function () {\n\n  var mousePosition = this.editor.getMousePosition();\n\n  var dx = mousePosition.x - this.draggingMouseIniPosition.x;\n  var dy = mousePosition.y - this.draggingMouseIniPosition.y;\n\n  return {\n    x: this.draggingAnnotationIniPosition.x + dx,\n    y: this.draggingAnnotationIniPosition.y + dy };\n\n};\n\n/**\n    *\n    * @param x\n    * @param y\n    * @param bounds\n    * @returns {boolean}\n    * @orivate\n    */\nproto.isInsideBounds = function (x, y, bounds) {\n\n  return x >= bounds.x && x <= bounds.x + bounds.width &&\n  y >= bounds.y && y <= bounds.y + bounds.height;\n};\n\n/*\n    * Decides whether to use the snapper in the current edit mode or not.\n    * \n    * @returns {boolean}\n    */\nproto.useWithSnapping = function () {\n  return this.viewer.model.is2d();\n};\n\n\nproto.isTextInputHelperActive = function () {\n  return this.textInputHelper && this.textInputHelper.isActive();\n};","'use strict';\n\nimport { EditMode } from './EditMode';\nimport { DeleteArrow } from '../edit-actions/DeleteArrow';\nimport { CreateArrow } from '../edit-actions/CreateArrow';\nimport { SetArrow } from '../edit-actions/SetArrow';\nimport * as MarkupTypes from '../MarkupTypes';\n\n\nvar MeasureCommon = Autodesk.Viewing.MeasureCommon;\n\n/**\n                                                     *\n                                                     * @param editor\n                                                     * @constructor\n                                                     */\nexport function EditModeArrow(editor) {\n\n  var styleAttributes = ['stroke-width', 'stroke-color', 'stroke-opacity'];\n  EditMode.call(this, editor, MarkupTypes.MARKUP_TYPE_ARROW, styleAttributes);\n}\n\nEditModeArrow.prototype = Object.create(EditMode.prototype);\nEditModeArrow.prototype.constructor = EditModeArrow;\n\n\nvar proto = EditModeArrow.prototype;\n\nproto.deleteMarkup = function (markup, cantUndo) {\n\n  markup = markup || this.selectedMarkup;\n  if (markup && markup.type == this.type) {\n    var deleteArrow = new DeleteArrow(this.editor, markup);\n    deleteArrow.addToHistory = !cantUndo;\n    deleteArrow.execute();\n    return true;\n  }\n  return false;\n};\n\n/**\n    * Handler to mouse down events, used to start markups creation.\n    * @private\n    */\nproto.onMouseDown = function () {\n\n  EditMode.prototype.onMouseDown.call(this);\n\n  if (this.selectedMarkup) {\n    return;\n  }\n\n  var editor = this.editor;\n  var mousePosition = editor.getMousePosition();\n\n  this.initialX = mousePosition.x;\n  this.initialY = mousePosition.y;\n\n  this.size.x = 0;\n  this.size.y = 0;\n\n  // Snap to parallel/perpendicular of underlying vectors\n  this.lineSnapped = null;\n  if (editor.snapper) {\n    var geomType = editor.snapper.getGeometryType();\n    if (geomType === MeasureCommon.SnapType.SNAP_VERTEX ||\n    geomType === MeasureCommon.SnapType.SNAP_EDGE ||\n    geomType === MeasureCommon.SnapType.SNAP_MIDPOINT ||\n    geomType === MeasureCommon.SnapType.SNAP_CIRCLE_CENTER)\n    {\n      this.lineSnapped = editor.snapper.getEdge();\n    }\n  }\n\n  // Calculate head and tail.\n  var arrowMinSize = this.style['stroke-width'] * 3.5;\n\n  var head = this.head = editor.positionFromClientToMarkups(this.initialX, this.initialY);\n  var tail = {\n    x: head.x + Math.cos(Math.PI * 0.25) * arrowMinSize,\n    y: head.y + Math.sin(-Math.PI * 0.25) * arrowMinSize };\n\n  // Constrain head and tail inside working area.\n  var constrain = function (head, tail, size, bounds) {\n\n    if (this.isInsideBounds(tail.x, tail.y, bounds)) {\n      return;\n    }\n\n    tail.y = head.y + Math.sin(Math.PI * 0.25) * size;\n    if (this.isInsideBounds(tail.x, tail.y, bounds)) {\n      return;\n    }\n\n    tail.x = head.x + Math.cos(-Math.PI * 0.25) * size;\n    if (this.isInsideBounds(tail.x, tail.y, bounds)) {\n      return;\n    }\n\n    tail.y = head.y + Math.sin(-Math.PI * 0.25) * size;\n\n  }.bind(this);\n\n  constrain(head, tail, arrowMinSize, editor.getBounds());\n\n  // Create arrow.\n  editor.beginActionGroup();\n\n  var arrowVector = new THREE.Vector2(tail.x - head.x, tail.y - head.y);\n  if (arrowVector.lengthSq() < arrowMinSize * arrowMinSize) {\n\n    arrowVector = arrowVector.normalize().multiplyScalar(arrowMinSize);\n    tail.x = head.x + arrowVector.x;\n    tail.y = head.y + arrowVector.y;\n  }\n\n  var arrowId = editor.getId();\n  var create = new CreateArrow(editor, arrowId, head, tail, this.style);\n  create.execute();\n\n  this.selectedMarkup = editor.getMarkup(arrowId);\n  this.creationBegin();\n};\n\n/**\n    * Handler to mouse move events, used to create markups.\n    * @param {MouseEvent} event Mouse event.\n    * @private\n    */\nproto.onMouseMove = function (event) {\n\n  if (!EditMode.prototype.onMouseMove.call(this, event)) {\n    return false;\n  }\n\n  var selectedMarkup = this.selectedMarkup;\n\n  var editor = this.editor;\n  var final = this.getFinalMouseDraggingPosition();\n  var initialX = this.initialX;\n  var initialY = this.initialY;\n\n  // Snap to parallel/perpendicular of underlying vectors\n  if (editor.snapper && !editor.snapper.isSnapped() && this.lineSnapped) {\n    var start = editor.project(this.lineSnapped.vertices[0]);\n    var end = editor.project(this.lineSnapped.vertices[1]);\n    var p = new THREE.Vector3(final.x, final.y, start.z);\n\n    var parallel = MeasureCommon.nearestPointInPointToLine(p, start, end);\n\n    // select an arbitrary point on the perpendicular line\n    var k = -(start.x - end.x) / (start.y - end.y);\n    var b = initialY - k * initialX;\n    var x = initialX + 1;\n    var y = k * x + b;\n    var pEnd = new THREE.Vector3(x, y, start.z);\n\n    var pStart = new THREE.Vector3(initialX, initialY, start.z);\n    var perpendicular = MeasureCommon.nearestPointInPointToLine(p, pStart, pEnd);\n\n    // Snap to parallel of underlying vectors\n    if (parallel.distanceTo(p) <= 20) {\n      final.x = parallel.x;\n      final.y = parallel.y;\n    }\n    // Snap to perpendicular of underlying vectors\n    else if (perpendicular.distanceTo(p) <= 20) {\n        final.x = perpendicular.x;\n        final.y = perpendicular.y;\n      }\n  }\n\n  var head = this.head;\n  var tail = editor.positionFromClientToMarkups(final.x, final.y);\n\n  var arrowVector = new THREE.Vector2(tail.x - head.x, tail.y - head.y);\n  var arrowMinSize = selectedMarkup.style['stroke-width'] * 3.5;\n\n  if (arrowVector.lengthSq() < arrowMinSize * arrowMinSize) {\n\n    arrowVector = arrowVector.normalize().multiplyScalar(arrowMinSize);\n    tail.x = head.x + arrowVector.x;\n    tail.y = head.y + arrowVector.y;\n  }\n\n  this.size = editor.sizeFromClientToMarkups(final.x - initialX, final.y - initialY);\n\n  var setArrow = new SetArrow(editor, selectedMarkup, head, tail);\n  setArrow.execute();\n  return true;\n};","'use strict';\n\nimport { EditMode } from './EditMode';\nimport { DeleteCallout } from '../edit-actions/DeleteCallout';\nimport { CreateCallout } from '../edit-actions/CreateCallout';\nimport { SetCallout } from '../edit-actions/SetCallout';\nimport { SetStyle } from '../edit-actions/SetStyle';\nimport { SetSize } from '../edit-actions/SetSize';\nimport * as MarkupTypes from '../MarkupTypes';\nimport * as MarkupEvents from '../MarkupEvents';\nimport { EditorTextInput } from './EditorTextInput';\n\n\nvar STARTING_WIDTH_FACTOR = 6;\n\n/**\n                                *\n                                * @param editor\n                                * @constructor\n                                */\nexport function EditModeCallout(editor) {\n\n  var styleAttributes = [\n  'font-size',\n  'stroke-width',\n  'stroke-color',\n  'stroke-opacity',\n  'fill-color',\n  'fill-opacity',\n  'font-family',\n  'font-style',\n  'font-weight'];\n\n  EditMode.call(this, editor, MarkupTypes.MARKUP_TYPE_CALLOUT, styleAttributes);\n\n  this.style['fill-opacity'] = 1.0;\n  this.style['fill-color'] = '#ffffff';\n\n  var helper = new EditorTextInput(this.viewer.container, this.editor, false, 'Text', 360);\n  helper.addEventListener(helper.EVENT_TEXT_CHANGE, this.onHelperTextChange.bind(this), false);\n  helper.addEventListener(helper.EVENT_TEXT_SET_ACTIVE, this.onHelperSetActive.bind(this), false);\n  helper.addEventListener(helper.EVENT_TEXT_SET_INACTIVE, this.onHelperSetActive.bind(this), false);\n\n  this.textInputHelper = helper;\n  this.onHistoryChangeBinded = this.onHistoryChange.bind(this);\n  this.minSize = 0; // No need to size it initially\n  this.creationMethod = this.CREATION_METHOD_CLICK;\n}\n\nEditModeCallout.prototype = Object.create(EditMode.prototype);\nEditModeCallout.prototype.constructor = EditModeCallout;\n\nvar proto = EditModeCallout.prototype;\n\nproto.deleteMarkup = function (markup, cantUndo) {\n\n  markup = markup || this.selectedMarkup;\n  if (markup && markup.type === this.type) {\n    var deleteCallout = new DeleteCallout(this.editor, markup);\n    deleteCallout.addToHistory = !cantUndo;\n    deleteCallout.execute();\n    return true;\n  }\n  return false;\n};\n\nproto.setStyle = function (style) {\n\n  if (this.textInputHelper && this.textInputHelper.isActive()) {\n\n    this.textInputHelper.setStyle(style);\n  } else {\n    EditMode.prototype.setStyle.call(this, style);\n  }\n};\n\nproto.notifyAllowNavigation = function (allows) {\n\n  if (allows && this.textInputHelper && this.textInputHelper.isActive()) {\n    this.textInputHelper.acceptAndExit();\n  }\n};\n\nproto.destroy = function () {\n\n  if (this.textInputHelper) {\n    if (this.textInputHelper.isActive()) {\n      this.textInputHelper.acceptAndExit();\n    }\n    this.textInputHelper.destroy();\n    this.textInputHelper = null;\n  }\n  EditMode.prototype.destroy.call(this);\n};\n\n/**\n    * Handler to mouse down events, used to start markups creation.\n    */\nproto.onMouseDown = function () {\n\n  if (this.textInputHelper && this.textInputHelper.isActive()) {\n    this.textInputHelper.acceptAndExit();\n    return;\n  }\n\n  if (this.selectedMarkup) {\n    return;\n  }\n\n  var editor = this.editor;\n  var mousePosition = editor.getMousePosition();\n  var clientFontSize = editor.sizeFromMarkupsToClient(0, this.style['font-size']).y;\n  var initialWidth = clientFontSize * STARTING_WIDTH_FACTOR; // Find better way to initialize size.\n  var initialHeight = clientFontSize * 1;\n\n  // Center position.\n  var size = this.size = editor.sizeFromClientToMarkups(initialWidth, initialHeight);\n  var position = editor.positionFromClientToMarkups(\n  mousePosition.x + initialWidth * 0.5,\n  mousePosition.y + initialHeight * 0.5);\n\n  this.creationBegin();\n  editor.beginActionGroup();\n\n  // Given the initial width and font size, we assume that the text fits in one line.\n  var createCallout = new CreateCallout(\n  editor,\n  editor.getId(),\n  position,\n  size,\n  '',\n  this.style,\n  true);\n\n  createCallout.execute();\n  this.creationEnd();\n\n  this.selectedMarkup = editor.getMarkup(createCallout.targetId);\n  this.textInputHelper && this.textInputHelper.setActive(this.selectedMarkup, true);\n  this.editor.actionManager.addEventListener(MarkupEvents.EVENT_HISTORY_CHANGED, this.onHistoryChangeBinded);\n};\n\nproto.onMouseUp = function (event) {\n\n};\n\nproto.onMouseDoubleClick = function (markup) {\n\n  if (markup === this.selectedMarkup) {\n    this.editor.selectMarkup(markup);\n    this.editor.editFrame.setMarkup(markup);\n    this.textInputHelper && this.textInputHelper.setActive(markup, false);\n  }\n};\n\nproto.onHelperSetActive = function (event) {\n  var databag = event.data;\n  var markup = databag.markup;\n  if (markup) {\n    markup.setIsHelperTextActive(databag.isActive);\n    markup.setIsShapeVisible(!databag.isActive);\n  }\n};\n\nproto.onHelperTextChange = function (event) {\n\n  var dataBag = event.data;\n  var textMarkup = dataBag.markup;\n  var textStyle = dataBag.style;\n  var curSelection = this.selectedMarkup;\n\n  this.editor.actionManager.removeEventListener(MarkupEvents.EVENT_HISTORY_CHANGED, this.onHistoryChangeBinded);\n\n  // Deal with edge case first: Creating a Label without text\n  if (dataBag.newText === '') {\n    this.editor.cancelActionGroup();\n\n    var deleteCallout = new DeleteCallout(this.editor, textMarkup);\n    deleteCallout.execute();\n\n    if (textMarkup !== curSelection) {\n      this.editor.selectMarkup(curSelection);\n    }\n\n    return;\n  }\n\n  // When the text is created for the first time, an action group\n  // is already created and it includes the CreateCallout action.\n  // Thus, no need to begin another action group.\n  if (!dataBag.firstEdit) {\n    this.editor.beginActionGroup();\n  }\n\n  // Size change action //\n  var position = this.editor.positionFromClientToMarkups(\n  dataBag.newPos.x, dataBag.newPos.y);\n\n  var size = this.editor.sizeFromClientToMarkups(\n  dataBag.width, dataBag.height);\n\n  var setSize = new SetSize(\n  this.editor,\n  textMarkup,\n  position,\n  size.x,\n  size.y);\n  setSize.execute();\n\n  // Text change action //\n  var setCallout = new SetCallout(\n  this.editor,\n  textMarkup,\n  textMarkup.position,\n  textMarkup.size,\n  dataBag.newText,\n  textMarkup.isFrameUsed);\n  setCallout.execute();\n\n  var setStyle = new SetStyle(\n  this.editor,\n  textMarkup,\n  textStyle);\n\n  setStyle.execute();\n\n  // However, we do need to close the action group at this point. For both cases.\n  this.editor.closeActionGroup();\n  this.editor.selectMarkup(curSelection);\n};\n\n/**\n    * We want to make sure that the Input Helper gets removed from the screen\n    * whenever the user attempts to perform an undo or redo action.\n    * @param {Event} event\n    * @private\n    */\nproto.onHistoryChange = function (event) {\n\n  if (this.textInputHelper && this.textInputHelper.isActive()) {\n    this.editor.actionManager.removeEventListener(MarkupEvents.EVENT_HISTORY_CHANGED, this.onHistoryChangeBinded);\n    this.textInputHelper.setInactive();\n  }\n};\n\n/**\n    * Notify the markup that the displayed markups are being saved so edit mode can finish current editions.\n    */\nproto.onSave = function () {\n\n  EditMode.prototype.onSave.call(this);\n\n  // Close input helper if it's open.\n  if (this.textInputHelper && this.textInputHelper.isActive()) {\n    var firstEdit = this.textInputHelper.firstEdit;\n\n    this.editor.actionManager.removeEventListener(MarkupEvents.EVENT_HISTORY_CHANGED, this.onHistoryChangeBinded);\n    this.textInputHelper.setInactive();\n\n    // Close action group if open (first edit).\n    if (firstEdit) {\n      this.editor.cancelActionGroup();\n    }\n\n    this.editor.selectMarkup(null);\n    this.selectedMarkup = null;\n  }\n};\n\nproto.updateTextBoxStyle = function () {\n  if (this.isTextInputHelperActive()) {\n    this.textInputHelper.onCameraChanged();\n  }\n};","'use strict';\n\nimport { EditMode } from './EditMode';\nimport { DeleteCircle } from '../edit-actions/DeleteCircle';\nimport { CreateCircle } from '../edit-actions/CreateCircle';\nimport { SetCircle } from '../edit-actions/SetCircle';\nimport * as MarkupTypes from '../MarkupTypes';\n\n/**\n                                                * Markup circle edit mode.\n                                                *\n                                                * Implements a Circle {@link Autodesk.Viewing.Extensions.Markups.Core.EditMode|EditMode}.\n                                                * Included in documentation as an example of how to create\n                                                * an EditMode for a specific markup type. Developers are encourage to look into this class's source code and copy\n                                                * as much code as they need. Find link to source code below.\n                                                *\n                                                * @tutorial feature_markup\n                                                * @constructor\n                                                * @memberof Autodesk.Viewing.Extensions.Markups.Core\n                                                * @extends Autodesk.Viewing.Extensions.Markups.Core.EditMode\n                                                * @param {Autodesk.Viewing.Extensions.Markups.Core.MarkupsCore} editor\n                                                */\nexport function EditModeCircle(editor) {\n\n  var styleAttributes = ['stroke-width', 'stroke-color', 'stroke-opacity', 'fill-color', 'fill-opacity'];\n  EditMode.call(this, editor, MarkupTypes.MARKUP_TYPE_CIRCLE, styleAttributes);\n}\n\nEditModeCircle.prototype = Object.create(EditMode.prototype);\nEditModeCircle.prototype.constructor = EditModeCircle;\n\nvar proto = EditModeCircle.prototype;\n\nproto.deleteMarkup = function (markup, cantUndo) {\n\n  markup = markup || this.selectedMarkup;\n  if (markup && markup.type == this.type) {\n    var deleteCircle = new DeleteCircle(this.editor, markup);\n    deleteCircle.addToHistory = !cantUndo;\n    deleteCircle.execute();\n    return true;\n  }\n  return false;\n};\n\n/**\n    * Handler to mouse move events, used to create markups.\n    * @param {MouseEvent} event Mouse event.\n    * @private\n    */\nproto.onMouseMove = function (event) {\n\n  if (!EditMode.prototype.onMouseMove.call(this, event)) {\n    return false;\n  }\n\n  var selectedMarkup = this.selectedMarkup;\n\n  var editor = this.editor;\n\n  var final = this.getFinalMouseDraggingPosition();\n  final = editor.clientToMarkups(final.x, final.y);\n\n  var sizeX = Math.abs(this.firstPosition.x - final.x);\n  var sizeY = Math.abs(this.firstPosition.y - final.y);\n\n  var position = { x: (this.firstPosition.x + final.x) * 0.5, y: (this.firstPosition.y + final.y) * 0.5 };\n  var size = this.size = { x: sizeX, y: sizeY };\n\n  var setCircle = new SetCircle(\n  editor,\n  selectedMarkup,\n  position,\n  size);\n\n  setCircle.execute();\n  return true;\n};\n\n/**\n    * Handler to mouse down events, used to start markups creation.\n    * @private\n    */\nproto.onMouseDown = function () {\n\n  EditMode.prototype.onMouseDown.call(this);\n\n  if (this.selectedMarkup) {\n    return;\n  }\n\n  var editor = this.editor;\n  var mousePosition = editor.getMousePosition();\n\n  this.initialX = mousePosition.x;\n  this.initialY = mousePosition.y;\n\n  // Calculate center and size.\n  var position = this.firstPosition = editor.clientToMarkups(this.initialX, this.initialY);\n  var size = this.size = editor.sizeFromClientToMarkups(1, 1);\n\n  // Create circle.\n  editor.beginActionGroup();\n\n  var markupId = editor.getId();\n  var create = new CreateCircle(\n  editor,\n  markupId,\n  position,\n  size,\n  0,\n  this.style);\n  create.execute();\n\n  this.selectedMarkup = editor.getMarkup(markupId);\n  this.creationBegin();\n};","'use strict';\n\nimport { EditMode } from './EditMode';\nimport { DeleteCloud } from '../edit-actions/DeleteCloud';\nimport { CreateCloud } from '../edit-actions/CreateCloud';\nimport { SetCloud } from '../edit-actions/SetCloud';\nimport * as MarkupTypes from '../MarkupTypes';\n\n/**\n                                                *\n                                                * @param editor\n                                                * @constructor\n                                                */\nexport function EditModeCloud(editor) {\n\n  var styleAttributes = ['stroke-width', 'stroke-color', 'stroke-opacity', 'fill-color', 'fill-opacity'];\n  EditMode.call(this, editor, MarkupTypes.MARKUP_TYPE_CLOUD, styleAttributes);\n}\n\nEditModeCloud.prototype = Object.create(EditMode.prototype);\nEditModeCloud.prototype.constructor = EditModeCloud;\n\nvar proto = EditModeCloud.prototype;\n\nproto.deleteMarkup = function (markup, cantUndo) {\n\n  markup = markup || this.selectedMarkup;\n  if (markup && markup.type == this.type) {\n    var deleteCloud = new DeleteCloud(this.editor, markup);\n    deleteCloud.addToHistory = !cantUndo;\n    deleteCloud.execute();\n    return true;\n  }\n  return false;\n};\n\n/**\n    * Handler to mouse move events, used to create markups.\n    * @param {MouseEvent} event Mouse event.\n    * @private\n    */\nproto.onMouseMove = function (event) {\n\n  if (!EditMode.prototype.onMouseMove.call(this, event)) {\n    return false;\n  }\n\n  var selectedMarkup = this.selectedMarkup;\n\n  var editor = this.editor;\n\n  var pos = this.getFinalMouseDraggingPosition();\n  var final = editor.clientToMarkups(pos.x, pos.y);\n  var position = { x: (this.firstPosition.x + final.x) / 2, y: (this.firstPosition.y + final.y) / 2 };\n  var size = this.size = { x: Math.abs(final.x - this.firstPosition.x), y: Math.abs(final.y - this.firstPosition.y) };\n  var setCloud = new SetCloud(\n  editor,\n  selectedMarkup,\n  position,\n  size);\n\n  setCloud.execute();\n  return true;\n};\n\n/**\n    * Handler to mouse down events, used to start markups creation.\n    * @private\n    */\nproto.onMouseDown = function () {\n\n  EditMode.prototype.onMouseDown.call(this);\n\n  if (this.selectedMarkup) {\n    return;\n  }\n\n  var editor = this.editor;\n  var mousePosition = editor.getMousePosition();\n\n  this.initialX = mousePosition.x;\n  this.initialY = mousePosition.y;\n\n  // Calculate center and size.\n  var position = this.firstPosition = editor.clientToMarkups(this.initialX, this.initialY);\n  var size = this.size = editor.sizeFromClientToMarkups(1, 1);\n\n  // Create Cloud.\n  editor.beginActionGroup();\n\n  var markupId = editor.getId();\n  var create = new CreateCloud(\n  editor,\n  markupId,\n  position,\n  size,\n  0,\n  this.style);\n\n  create.execute();\n\n  this.selectedMarkup = editor.getMarkup(markupId);\n  this.creationBegin();\n};","'use strict';\n\nimport { EditMode } from './EditMode';\nimport { DeleteDimension } from '../edit-actions/DeleteDimension';\nimport { CreateDimension } from '../edit-actions/CreateDimension';\nimport { SetDimension } from '../edit-actions/SetDimension';\nimport { SetStyle } from '../edit-actions/SetStyle';\nimport * as MarkupTypes from '../MarkupTypes';\nimport * as MarkupEvents from '../MarkupEvents';\nimport { EditorTextInput } from './EditorTextInput';\nimport { measureTextLines, radiansToDegrees } from '../MarkupsCoreUtils';\n\nvar MeasureCommon = Autodesk.Viewing.MeasureCommon;\n\nvar MAX_LETTERS = 15;\nvar SPACE = \"\\xA0\"; // Non-breaking space\nvar _cursorPosition;\n\n/**\n                      *\n                      * @param editor\n                      * @constructor\n                      */\nexport function EditModeDimension(editor) {\n\n  var self = this;\n\n  var styleAttributes = ['stroke-width', 'stroke-color', 'stroke-opacity', 'font-size', 'font-family', 'font-style', 'font-weight'];\n  EditMode.call(this, editor, MarkupTypes.MARKUP_TYPE_DIMENSION, styleAttributes);\n\n  this.onHistoryChangeBinded = this.onHistoryChange.bind(this);\n\n  this.measurement = new MeasureCommon.Measurement(MeasureCommon.MeasurementTypes.MEASUREMENT_DISTANCE);\n  var viewer = this.viewer;\n  var measureExt = viewer.getExtension('Autodesk.Measure');\n\n  function abortDimensionMarkup() {\n    self.cancelEditModeChange = true;\n    editor.enterEditMode(); // Selects default edit mode.\n  }\n\n  if (!measureExt) {\n    console.error('Demension markup cant work without measure extension. Please load measure extension first');\n    abortDimensionMarkup();\n  }\n\n  this.sharedMeasureConfig = measureExt.sharedMeasureConfig;\n\n  // If PDF, force calibration\n  if ((measureExt.forceCalibrate || viewer.model.isLeaflet() || viewer.model.isPdf(true)) && !measureExt.calibrationTool.isCalibrated()) {\n    measureExt.openCalibrationRequiredDialog('dimension');\n    abortDimensionMarkup();\n  }\n}\n\nEditModeDimension.prototype = Object.create(EditMode.prototype);\nEditModeDimension.prototype.constructor = EditModeDimension;\n\nvar proto = EditModeDimension.prototype;\n\nproto.deleteMarkup = function (markup, cantUndo) {\n\n  markup = markup || this.selectedMarkup;\n  if (markup && markup.type == this.type) {\n    var deleteDimension = new DeleteDimension(this.editor, markup);\n    deleteDimension.addToHistory = !cantUndo;\n    deleteDimension.execute();\n    this.creating = false;\n    this.dragging = false;\n    return true;\n  }\n  return false;\n};\n\nproto.updateTextBoxStyle = function (style) {\n  if (this.isTextInputHelperActive()) {\n    if (!style) {\n      style = this.textInputHelper.textMarkup.getStyle();\n    }\n\n    this.textInputHelper.setStyle(style);\n    this.updateTextBox(this.textInputHelper.textMarkup);\n  }\n};\n\nproto.setStyle = function (style) {\n\n  EditMode.prototype.setStyle.call(this, style);\n  this.updateTextBoxStyle(style);\n\n};\n\nproto.notifyAllowNavigation = function (allows) {\n\n  if (allows && this.isTextInputHelperActive()) {\n    this.textInputHelper.acceptAndExit();\n  }\n};\n\nproto.creationBegin = function () {\n  EditMode.prototype.creationBegin.call(this);\n};\n\nproto.creationEnd = function () {\n\n  this.dragging = false;\n  EditMode.prototype.creationEnd.call(this);\n};\n\nproto.isMinSizeValid = function () {\n\n  if (this.minSize !== 0) {\n    var tmp = this.editor.sizeFromMarkupsToClient(this.selectedMarkup.size.x, this.selectedMarkup.size.y);\n    return tmp.x * tmp.x >= this.minSize * this.minSize;\n  }\n\n  return true;\n};\n\nproto.creationCancel = function () {\n\n  EditMode.prototype.creationCancel.call(this);\n\n  this.creating = false;\n  this.dragging = false;\n\n};\n\nproto.destroy = function () {\n\n  if (this.textInputHelper) {\n\n    if (this.textInputHelper.isActive()) {\n      this.textInputHelper.acceptAndExit();\n    }\n\n    this.editor.actionManager.removeEventListener(MarkupEvents.EVENT_HISTORY_CHANGED, this.onHistoryChangeBinded);\n\n    this.textInputHelper.destroy();\n    this.textInputHelper = null;\n  }\n\n  this.updateViewportId();\n\n  EditMode.prototype.destroy.call(this);\n};\n\nproto.getDistance = function () {\n\n  var distance = null;\n\n  this.measurement.computeResult(this.measurement.picks, this.viewer);\n\n  if (this.viewer.model && this.measurement.distanceXYZ) {\n    var d = Autodesk.Viewing.Private.convertUnits(this.viewer.model.getUnitString(), this.sharedMeasureConfig.units, this.sharedMeasureConfig.calibrationFactor, this.measurement.distanceXYZ);\n    return Autodesk.Viewing.Private.formatValueWithUnits(d, this.sharedMeasureConfig.units, 3, this.sharedMeasureConfig.precision);\n  }\n\n  return distance;\n};\n\nproto.updateMeasurement = function (measurementNumber) {\n  var editor = this.editor;\n\n  var pick = this.measurement.getPick(measurementNumber);\n\n  if (_cursorPosition) {\n    pick.geomType = MeasureCommon.SnapType.SNAP_VERTEX;\n    pick.geomVertex = _cursorPosition;\n    pick.intersectPoint = _cursorPosition;\n  } else {\n    editor.snapper.copyResults(pick);\n  }\n\n  return pick;\n};\n\nproto.updateViewportId = function (viewportId) {\n  if (this.viewer.model && this.viewer.model.is2d()) {\n    if (!viewportId) {\n      this.viewer.impl.updateViewportId(0);\n      this.editor.snapper.setViewportId(null);\n    } else\n    {\n      // Pass viewport Id to LineShader to make all other geometries with different viewport transparent\n      this.viewer.impl.updateViewportId(viewportId);\n      this.editor.snapper.setViewportId(viewportId);\n\n    }\n  }\n};\n\nproto.pickFirstAnchor = function () {\n  var editor = this.editor;\n  this.measurement.clearAllPicks();\n  var mousePosition = editor.getMousePosition();\n\n  this.initialX = mousePosition.x;\n  this.initialY = mousePosition.y;\n\n  this.firstAnchor = editor.positionFromClientToMarkups(this.initialX, this.initialY);\n\n  editor.beginActionGroup();\n\n  var dimensionId = editor.getId();\n  var create = new CreateDimension(editor, dimensionId, this.firstAnchor, null, this.currentText, this.style);\n  create.execute();\n\n  this.selectedMarkup = editor.getMarkup(dimensionId);\n  this.creationBegin();\n\n  var pick = this.updateMeasurement(1);\n  this.updateViewportId(pick.viewportIndex2d);\n};\n\nproto.pickSecondAnchor = function (mouseDown) {\n\n  var editor = this.editor;\n  var selectedMarkup = this.selectedMarkup;\n\n  this.secondAnchor = this.getFinalMouseDraggingPosition();\n\n  this.updateMeasurement(2);\n\n  // Correct Perpendicular\n  if (MeasureCommon.correctPerpendicularPicks(this.measurement.getPick(1), this.measurement.getPick(2), this.viewer, editor.snapper)) {\n    var newPos = MeasureCommon.getSnapResultPosition(this.measurement.getPick(2), this.viewer);\n    this.secondAnchor = editor.project(newPos);\n    editor.snapper.indicator.render();\n  }\n\n  var secondAnchor = editor.positionFromClientToMarkups(this.secondAnchor.x, this.secondAnchor.y);\n\n  this.size.x = selectedMarkup.size.x;\n  this.size.y = selectedMarkup.size.y;\n\n  selectedMarkup.currentText = this.getDistance();\n\n  var setDimension = new SetDimension(editor, selectedMarkup, this.firstAnchor, secondAnchor, selectedMarkup.currentText);\n  setDimension.execute();\n\n  var setStyle = new SetStyle(editor, selectedMarkup, this.style);\n  setStyle.execute();\n\n  // Open 'Add Length' textbox if no measurement has being taken.\n  if (mouseDown && !selectedMarkup.currentText && this.isMinSizeValid()) {\n    selectedMarkup.currentText = '';\n    this.editor.selectMarkup(null);\n    this.updateTextBox(selectedMarkup);\n  }\n};\n\n\n/**\n    * Handler to mouse down events, used to start markups creation.\n    * @private\n    */\nproto.onMouseDown = function (event) {\n\n  // Right click - do nothing.\n  if (Autodesk.Viewing.Private.isRightClick(event, this.viewer.navigation)) {\n    return;\n  }\n\n  _cursorPosition = null;\n\n  // Textbox is open.\n  if (this.isTextInputHelperActive()) {\n    this.textInputHelper.acceptAndExit();\n    return;\n  }\n\n  EditMode.prototype.onMouseDown.call(this);\n\n  // User selected an already created markup.\n  if (this.selectedMarkup && !this.creating) {\n    return;\n  }\n\n  var isSnapped = this.editor.snapper.isSnapped();\n\n  // Picked first point.\n  if (!this.selectedMarkup && !this.creating && isSnapped) {\n    this.pickFirstAnchor();\n  }\n\n  // Picked second point.\n  else if (this.selectedMarkup && this.creating) {\n\n      if (isSnapped) {\n        this.pickSecondAnchor(true);\n      } else {\n        this.deleteMarkup(this.selectedMarkup, true);\n        this.creating = true;\n      }\n\n      this.updateViewportId();\n      this.creationEnd();\n    }\n};\n\nproto.onMouseUp = function (event) {\n\n  if (this.dragging) {\n    this.onMouseDown(event);\n    this.dragging = false;\n  }\n};\n\n\n/**\n    * Handler to mouse move events, used to create markups.\n    * @param {MouseEvent} event Mouse event.\n    * @private\n    */\nproto.onMouseMove = function (event) {\n\n  _cursorPosition = null;\n\n  if (!this.selectedMarkup || !this.creating) {\n    return;\n  }\n\n  this.dragging = true;\n  this.pickSecondAnchor(false);\n};\n\nproto.getFinalMouseDraggingPosition = function () {\n\n  var editor = this.editor;\n  var bounds = editor.getBounds();\n  var mousePosition = editor.getMousePosition();\n\n  if (!editor.snapper.isSnapped()) {\n    if (editor.viewer.model && editor.viewer.model.is2d()) {\n      _cursorPosition = MeasureCommon.inverseProject(mousePosition, editor.viewer);\n    }\n  }\n\n  var initialX = this.initialX;\n  var initialY = this.initialY;\n\n  var finalX = Math.min(Math.max(bounds.x, mousePosition.x), bounds.x + bounds.width);\n  var finalY = Math.min(Math.max(bounds.y, mousePosition.y), bounds.y + bounds.height);\n\n  if (finalX == initialX &&\n  finalY == initialY) {\n    finalX++;\n    finalY++;\n  }\n\n  // Make straight line when shift key is down.\n  if (editor.input.constrainAxis && editor.viewer.model.is2d()) {\n    var dx = Math.abs(finalX - initialX);\n    var dy = Math.abs(finalY - initialY);\n\n    if (dx > dy) {\n      finalY = initialY;\n    } else\n    {\n      finalX = initialX;\n    }\n\n    editor.snapper.onMouseMove({ x: finalX, y: finalY });\n\n    if (editor.snapper.isSnapped()) {\n      editor.snapper.copyResults(this.measurement.getPick(2));\n      _cursorPosition = null;\n    } else {\n      _cursorPosition = MeasureCommon.inverseProject({ x: finalX, y: finalY }, editor.viewer);\n    }\n  }\n\n  return { x: finalX, y: finalY };\n};\n\nproto.isVisibleChar = function (keyCode) {\n\n  return keyCode > 47 && keyCode < 58 || // number keys\n  keyCode == 32 || // spacebar\n  keyCode > 64 && keyCode < 91 || // letter keys\n  keyCode > 95 && keyCode < 112 || // numpad keys\n  keyCode > 185 && keyCode < 193 || // ;=,-./` (in order)\n  keyCode > 218 && keyCode < 223; // [\\]' (in order)\n};\n\nproto.measureTextLine = function (text, markup, editor) {\n\n  text = text.replace(new RegExp(' ', 'g'), SPACE);\n  text = text.length === 0 ? markup.initialText : text;\n  return measureTextLines([text + '|'], this.style, editor)[0];\n\n};\n\nproto.handleKeyDown = function (e) {\n  var textInputHelper = this.textInputHelper;\n\n  if (e.keyCode === Autodesk.Viewing.KeyCode.ENTER) {\n    return;\n  }\n\n  var markup = textInputHelper.textMarkup;\n  var text = textInputHelper.textArea.value;\n\n  if (e.keyCode === Autodesk.Viewing.KeyCode.BACKSPACE) {\n    text = text.substring(0, text.length - 1);\n  }\n\n  if (text.length < MAX_LETTERS && this.isVisibleChar(e.keyCode)) {\n    text = text + e.key;\n  }\n\n  var size = this.measureTextLine(text, markup, this.editor);\n\n  this.updateTextBox(markup, size);\n};\n\nproto.updateTextBox = function (markup, size) {\n\n  if (!this.textInputHelper) {\n    this.textInputHelper = new EditorTextInput(this.viewer.container, this.editor, true, markup.initialText, MAX_LETTERS);\n    this.textInputHelper.addEventListener(this.textInputHelper.EVENT_TEXT_CHANGE, this.onHelperTextChange.bind(this), false);\n    this.handleKeyDownBinded = this.handleKeyDown.bind(this);\n  }\n\n  markup.text.style.display = 'none';\n\n  if (!size) {\n    size = this.measureTextLine(this.textInputHelper.textArea.value, markup, this.editor);\n  }\n\n  var transform = this.getTextAreaTransform(markup, size);\n\n  this.textInputHelper.styleTextArea.setAttribute('text-align', 'center');\n\n  this.textInputHelper.setActive(markup, false);\n\n\n  // Override textArea attributes\n  this.textInputHelper.textArea.style.position = 'static';\n  this.textInputHelper.textArea.style.padding = '0';\n  this.textInputHelper.textArea.style.width = size.width + 'px';\n  this.textInputHelper.textArea.style.height = size.height + 'px';\n  this.textInputHelper.textArea.style.transform = transform; // Maybe need to add 'allBrowsers' support\n\n  this.editor.actionManager.removeEventListener(MarkupEvents.EVENT_HISTORY_CHANGED, this.onHistoryChangeBinded);\n  this.editor.actionManager.addEventListener(MarkupEvents.EVENT_HISTORY_CHANGED, this.onHistoryChangeBinded);\n  this.textInputHelper.textArea.removeEventListener('keydown', this.handleKeyDownBinded);\n  this.textInputHelper.textArea.addEventListener('keydown', this.handleKeyDownBinded);\n\n};\n\nproto.getTextAreaTransform = function (markup, size) {\n\n  var position = markup.getClientPosition();\n  var rotation = radiansToDegrees(markup.rotation) % 360;\n\n  if (rotation > 90 && rotation <= 270 && markup.shouldFlip()) {\n    rotation = 180 + rotation;\n  }\n\n  return [\n  'translate(', position.x - size.width / 2 + 'px,', position.y - this.viewer.container.clientHeight - size.height + 'px)',\n  'rotate(', rotation + 'deg)',\n  'translate(0px,', size.height + 'px)'].\n  join(' ');\n};\n\nproto.onMouseDoubleClick = function (markup) {\n\n  if (markup === this.selectedMarkup) {\n    this.editor.selectMarkup(null);\n    this.updateTextBox(markup);\n  }\n};\n\nproto.onHelperTextChange = function (event) {\n\n  var dataBag = event.data;\n  var markup = dataBag.markup;\n  var textStyle = dataBag.style;\n  var editor = this.editor;\n\n  markup.text.style.display = 'block';\n\n  if (dataBag.newText === '') {\n    dataBag.newText = markup.initialText;\n  }\n\n  // When the text is created for the first time, an action group\n  // is already created and it includes the CreateText action.\n  // Thus, no need to begin another action group.\n  if (!dataBag.firstEdit) {\n    editor.beginActionGroup();\n  }\n\n  var setStyle = new SetStyle(editor, markup, textStyle);\n  setStyle.execute();\n\n  var setDimension = new SetDimension(editor, markup, markup.firstAnchor, markup.secondAnchor, dataBag.newText);\n  setDimension.execute();\n\n  editor.closeActionGroup();\n  editor.selectMarkup(null);\n};\n\n/**\n    * We want to make sure that the Input Helper gets removed from the screen\n    * whenever the user attempts to perform an undo or redo action.\n    * @param {Event} event\n    * @private\n    */\nproto.onHistoryChange = function (event) {\n  if (this.isTextInputHelperActive()) {\n    this.textInputHelper.textMarkup.text.style.display = 'block';\n    this.editor.actionManager.removeEventListener(MarkupEvents.EVENT_HISTORY_CHANGED, this.onHistoryChangeBinded);\n    this.textInputHelper.setInactive();\n  }\n};\n\n/**\n    * Notify the markup that the displayed markups are being saved so edit mode can finish current editions.\n    */\nproto.onSave = function () {\n\n  EditMode.prototype.onSave.call(this);\n\n  // Close input helper if it's open.\n  if (this.isTextInputHelperActive()) {\n    var editor = this.editor;\n    editor.actionManager.removeEventListener(MarkupEvents.EVENT_HISTORY_CHANGED, this.onHistoryChangeBinded);\n    var markup = this.textInputHelper.textMarkup;\n    this.textInputHelper.acceptAndExit();\n    markup.text.style.display = 'block';\n  }\n};\n\nproto.useWithSnapping = function () {\n  return true;\n};","'use strict';\n\nimport { EditModePen } from './EditModePen';\nimport { DeleteFreehand } from '../edit-actions/DeleteFreehand';\nimport { CreateFreehand } from '../edit-actions/CreateFreehand';\nimport { SetFreehand } from '../edit-actions/SetFreehand';\nimport * as MarkupTypes from '../MarkupTypes';\n\n/**\n                                                *\n                                                * @param editor\n                                                * @constructor\n                                                */\nexport function EditModeFreehand(editor) {\n\n  var styleAttributes = ['stroke-width', 'stroke-color', 'stroke-opacity'];\n  EditModePen.call(this, editor, MarkupTypes.MARKUP_TYPE_FREEHAND, styleAttributes);\n}\n\nEditModeFreehand.prototype = Object.create(EditModePen.prototype);\nEditModeFreehand.prototype.constructor = EditModeFreehand;\n\nvar proto = EditModeFreehand.prototype;\n\nproto.createPen = function (markupId, position, size, rotation, locations) {\n  return new CreateFreehand(this.editor,\n  markupId,\n  position,\n  size,\n  rotation,\n  locations,\n  this.style);\n};\n\nproto.deletePen = function (markup) {\n  return new DeleteFreehand(this.editor, markup);\n};\n\nproto.setPen = function (position, size, locations, isAbsoluteCoords) {\n  return new SetFreehand(this.editor,\n  this.selectedMarkup,\n  position,\n  size,\n  locations,\n  isAbsoluteCoords);\n};","'use strict';\n\nimport { EditModePen } from './EditModePen';\nimport { DeleteHighlight } from '../edit-actions/DeleteHighlight';\nimport { CreateHighlight } from '../edit-actions/CreateHighlight';\nimport { SetHighlight } from '../edit-actions/SetHighlight';\nimport * as MarkupTypes from '../MarkupTypes';\n\n/**\n                                                *\n                                                * @param editor\n                                                * @constructor\n                                                */\nexport function EditModeHighlight(editor) {\n\n  var styleAttributes = ['stroke-width', 'stroke-color', 'stroke-opacity'];\n  EditModePen.call(this, editor, MarkupTypes.MARKUP_TYPE_HIGHLIGHT, styleAttributes);\n\n  var normaStrokeWidth = editor.getStrokeWidth();\n  this.style['stroke-opacity'] = 0.50;\n  this.style['stroke-color'] = '#ffff00';\n  this.style['stroke-width'] = 4 * normaStrokeWidth; // Very Thick\n}\n\nEditModeHighlight.prototype = Object.create(EditModePen.prototype);\nEditModeHighlight.prototype.constructor = EditModeHighlight;\n\nvar proto = EditModeHighlight.prototype;\n\nproto.createPen = function (markupId, position, size, rotation, locations) {\n  return new CreateHighlight(this.editor,\n  markupId,\n  position,\n  size,\n  rotation,\n  locations,\n  this.style);\n};\n\nproto.deletePen = function (markup) {\n  return new DeleteHighlight(this.editor, markup);\n};\n\nproto.setPen = function (position, size, locations, isAbsoluteCoords) {\n  return new SetHighlight(this.editor,\n  this.selectedMarkup,\n  position,\n  size,\n  locations,\n  isAbsoluteCoords);\n};","'use strict';\n\nimport { EditMode } from './EditMode';\nimport { simplify } from '../MarkupsCoreUtils';\n\n/**\n                                                 * Base class for editing Pen tools (currently freehand and highlighter)\n                                                 *\n                                                 * Any class extending EditModePen should contain at least the following methods:\n                                                 * - createPen()\n                                                 * - deletePen()\n                                                 * - setPen()\n                                                 *\n                                                 * @param editor\n                                                 * @constructor\n                                                 */\nexport function EditModePen(editor, type, styleAttributes) {\n  EditMode.call(this, editor, type, styleAttributes);\n\n  this.smoothen = true;\n  this.bufferSize = 8;\n}\n\nEditModePen.prototype = Object.create(EditMode.prototype);\n\nvar proto = EditModePen.prototype;\n\nproto.deleteMarkup = function (markup, cantUndo) {\n\n  markup = markup || this.selectedMarkup;\n  if (markup && markup.type === this.type) {\n    var deleteMarkup = this.deletePen(markup);\n    deleteMarkup.addToHistory = !cantUndo;\n    deleteMarkup.execute();\n    return true;\n  }\n  return false;\n};\n\n/**\n    * Handler to mouse move events, used to create markups.\n    * @param {MouseEvent} event Mouse event.\n    * @private\n    */\nproto.onMouseMove = function (event) {\n\n  if (!EditMode.prototype.onMouseMove.call(this, event)) {\n    return false;\n  }\n\n  var selectedMarkup = this.selectedMarkup;\n\n  var editor = this.editor;\n  var mousePosition = editor.getMousePosition();\n  var movements = this.movements;\n\n  var location = editor.clientToMarkups(mousePosition.x, mousePosition.y);\n  if (this.smoothen) {\n    this.appendToBuffer(location);\n    this.amendPath();\n  } else {\n    var dx = this.lastX - mousePosition.x;\n    var dy = this.lastY - mousePosition.y;\n    var moveTol = 25; // 5^2, compare to square to avoid using square root of distance\n\n    if (movements.length > 1 && dx * dx + dy * dy < moveTol) {\n      movements[movements.length - 1] = location;\n      this.removeFromAbsolutePath(1);\n    } else {\n      movements.push(location);\n      this.lastX = mousePosition.x;\n      this.lastY = mousePosition.y;\n    }\n\n    this.addToAbsolutePath([location]);\n  }\n\n  var setPen = this.setPen(this.position, this.size, this.absolutePath, true);\n  setPen.execute();\n  return true;\n};\n\n/**\n    * Handler to mouse down events, used to start markups creation.\n    * @private\n    */\nproto.onMouseDown = function () {\n\n  EditMode.prototype.onMouseDown.call(this);\n\n  if (this.selectedMarkup) {\n    return;\n  }\n\n  var editor = this.editor;\n\n  editor.snapper && editor.snapper.clearSnapped();\n  var mousePosition = editor.getMousePosition();\n\n  this.lastX = this.initialX = mousePosition.x;\n  this.lastY = this.initialY = mousePosition.y;\n\n  //set the starting point\n  var position = this.position = editor.clientToMarkups(this.initialX, this.initialY);\n  this.movements = [position];\n  if (this.smoothen) {\n    this.buffer = []; // Reset buffer\n    this.movementsLastIndex = null;\n    this.appendToBuffer(position);\n  }\n\n  var size = this.size = editor.sizeFromClientToMarkups(1, 1);\n\n  // Create pen.\n  editor.beginActionGroup();\n\n  var markupId = editor.getId();\n  var create = this.createPen(markupId, position, size, 0, [{ x: 0, y: 0 }]);\n\n  create.execute();\n\n  this.createAbsolutePath(position);\n\n  this.selectedMarkup = editor.getMarkup(markupId);\n  this.creationBegin();\n};\n\nproto.onMouseUp = function () {\n\n  if (!this.creating) {\n    EditMode.prototype.onMouseUp.call(this);\n    return;\n  }\n\n  var movements = this.movements;\n  var cameraWidth = this.viewer.impl.camera.right - this.viewer.impl.camera.left;\n  var cameraHeight = this.viewer.impl.camera.top - this.viewer.impl.camera.bottom;\n  var cameraDiagSq = cameraWidth * cameraWidth + cameraHeight * cameraHeight;\n\n  movements = simplify(movements, cameraDiagSq * 0.00000001, true);\n\n  var xs = movements.map(function (item) {return item.x;});\n  var ys = movements.map(function (item) {return item.y;});\n\n  var l = Math.min.apply(null, xs);\n  var t = Math.min.apply(null, ys);\n  var r = Math.max.apply(null, xs);\n  var b = Math.max.apply(null, ys);\n\n  var width = r - l; // Already in markup coords space\n  var height = b - t; // Already in markup coords space\n\n  var position = {\n    x: l + width * 0.5,\n    y: t + height * 0.5 };\n\n  var size = this.size = { x: width, y: height };\n\n  // Adjust points to relate from the shape's center\n  var locations = movements.map(function (point) {\n    return {\n      x: point.x - position.x,\n      y: point.y - position.y };\n\n  });\n\n  var setPen = this.setPen(position, size, locations, false);\n  setPen.execute();\n\n  EditMode.prototype.onMouseUp.call(this);\n};\n\nproto.createPen = function () {\n  console.error('createPen not implemented');\n};\n\nproto.deletePen = function () {\n  console.error('deletePen not implemented');\n};\n\nproto.setPen = function () {\n  console.error('setPen not implemented');\n};\n\nproto.useWithSnapping = function () {\n  return false;\n};\n\nproto.createAbsolutePath = function (point) {\n\n  this.absolutePath = 'M' + +point.x.toFixed(6) + ' ' + +point.y.toFixed(6);\n  this.absolutePathIndexes = [0];\n};\n\nproto.removeFromAbsolutePath = function (numToRemove) {\n\n  numToRemove = Math.min(numToRemove, this.absolutePathIndexes.length);\n  if (numToRemove > 0) {\n    this.absolutePath = this.absolutePath.slice(0, this.absolutePathIndexes[this.absolutePathIndexes.length - numToRemove]);\n    this.absolutePathIndexes.splice(this.absolutePathIndexes.length - numToRemove);\n  }\n};\n\nproto.addToAbsolutePath = function (points) {\n\n  for (var i = 0; i < points.length; i++) {\n    this.absolutePathIndexes.push(this.absolutePath.length);\n    this.absolutePath += ' L' + +points[i].x.toFixed(6) + ' ' + +points[i].y.toFixed(6);\n  }\n};\n\nproto.appendToBuffer = function (point) {\n\n  this.buffer.push(point);\n  while (this.buffer.length > this.bufferSize) {\n    this.buffer.shift();\n  }\n};\n\nproto.amendPath = function () {\n\n  var point = this.getAveragePoint(0);\n  if (point) {\n    if (this.movementsLastIndex) {\n      this.removeFromAbsolutePath(this.movements.length - this.movementsLastIndex);\n      this.movements.splice(this.movementsLastIndex);\n    }\n\n    // Add the smoothed part of the path that will not change\n    var tmpBuffer = [point];\n    this.movementsLastIndex = this.movements.length + 1;\n\n    // Get the last part of the path (close to the current mouse position)\n    // This part will change if the mouse moves again\n    for (var offset = 2; offset < this.buffer.length; offset += 2) {\n      var pt = this.getAveragePoint(offset);\n      tmpBuffer.push(pt);\n    }\n\n    this.addToAbsolutePath(tmpBuffer);\n\n    // Set the complete current path coordinates\n    this.movements.push.apply(this.movements, tmpBuffer);\n\n  }\n};\n\n// Calculate the average point, starting at offset in the buffer\nproto.getAveragePoint = function (offset) {\n\n  var len = this.buffer.length;\n  if (len % 2 === 1 || len >= this.bufferSize) {\n    var totalX = 0;\n    var totalY = 0;\n    var pt;\n    var count = 0;\n    for (var i = offset; i < len; i++) {\n      count++;\n      pt = this.buffer[i];\n      totalX += pt.x;\n      totalY += pt.y;\n    }\n    return {\n      x: totalX / count,\n      y: totalY / count };\n\n  }\n  return null;\n};","'use strict';\n\nimport { EditMode } from './EditMode';\nimport { DeletePolycloud } from '../edit-actions/DeletePolycloud';\nimport { CreatePolycloud } from '../edit-actions/CreatePolycloud';\nimport { SetPolycloud } from '../edit-actions/SetPolycloud';\nimport * as MarkupTypes from '../MarkupTypes';\nimport { areMarkupsPointsInClientRange } from '../MarkupsCoreUtils';\n\nvar SNAP_RANGE = 25;\n\n/**\n                      *\n                      * @param editor\n                      * @constructor\n                      */\nexport function EditModePolycloud(editor) {\n\n  var styleAttributes = ['stroke-width', 'stroke-color', 'stroke-opacity', 'fill-color', 'fill-opacity'];\n  EditMode.call(this, editor, MarkupTypes.MARKUP_TYPE_POLYCLOUD, styleAttributes);\n\n  this.creationMethod = this.CREATION_METHOD_CLICKS;\n  this.movements = [];\n}\n\nEditModePolycloud.prototype = Object.create(EditMode.prototype);\nEditModePolycloud.prototype.constructor = EditModePolycloud;\n\nvar proto = EditModePolycloud.prototype;\n\nproto.deleteMarkup = function (markup, cantUndo) {\n\n  markup = markup || this.selectedMarkup;\n  if (markup && markup.type == this.type) {\n    var movements = this.movements;\n    if (this.creating && movements.length >= 2) {\n      movements.pop();\n      movements.pop();\n      var lastIndex = movements.length - 1;\n      if (lastIndex >= 0) {\n        // duplicate last location\n        var lastMove = movements[lastIndex];\n        movements.push(lastMove);\n        var locations = setPositionAndSize(movements, this);\n        var setPolycloud = new SetPolycloud(\n        this.editor,\n        markup,\n        this.position,\n        this.size,\n        locations);\n\n        setPolycloud.execute();\n      }\n    } else\n    {\n      var deletePolycloud = new DeletePolycloud(this.editor, markup);\n      deletePolycloud.addToHistory = !cantUndo;\n      deletePolycloud.execute();\n      this.creationEnd();\n      return true;\n    }\n  }\n  return false;\n};\n\n/**\n    * Handler to mouse move events, used to create markups.\n    * @param {MouseEvent} event Mouse event.\n    * @private\n    */\nproto.onMouseMove = function (event) {\n\n  if (!EditMode.prototype.onMouseMove.call(this, event)) {\n    return false;\n  }\n\n  var selectedMarkup = this.selectedMarkup;\n\n  var editor = this.editor;\n\n  this.dragging = true;\n\n  var movements = this.movements;\n  movements.splice(movements.length - 1, 1);\n\n  var mousePosition = editor.getMousePosition();\n  mousePosition = editor.clientToMarkups(mousePosition.x, mousePosition.y);\n\n  // Close polycloud if user clicks close to initial point.\n  if (movements.length >= 2 &&\n  areMarkupsPointsInClientRange(movements[0], mousePosition, SNAP_RANGE, this.editor)) {\n    mousePosition = movements[0]; // Snap!\n  }\n\n  movements.push(mousePosition);\n\n  var locations = setPositionAndSize(movements, this);\n  var setPolycloud = new SetPolycloud(\n  editor,\n  selectedMarkup,\n  this.position,\n  this.size,\n  locations);\n\n  setPolycloud.execute();\n  return true;\n};\n\n/**\n    * Handler to mouse down events, used to start markups creation.\n    * @private\n    */\nproto.onMouseDown = function () {\n\n  EditMode.prototype.onMouseDown.call(this);\n\n  // User selected an already created markup.\n  if (this.selectedMarkup && !this.creating) {\n    return;\n  }\n\n  if (this.creating) {\n    return;\n  }\n\n  // Creation process.\n  var editor = this.editor;\n  var mousePosition = editor.getMousePosition();\n\n  mousePosition = editor.clientToMarkups(mousePosition.x, mousePosition.y);\n\n  var size = this.size = editor.sizeFromClientToMarkups(1, 1);\n  this.movements = [mousePosition, mousePosition];\n\n  editor.beginActionGroup();\n\n  var markupId = editor.getId();\n  var create = new CreatePolycloud(\n  editor,\n  markupId,\n  mousePosition,\n  size,\n  0,\n  [{ x: 0, y: 0 }],\n  this.style);\n\n  create.execute();\n\n  this.selectedMarkup = editor.getMarkup(markupId);\n  this.creationBegin();\n};\n\n/**\n    * Handler to mouse down events, used to start markups creation.\n    * @private\n    */\nproto.onMouseUp = function (event) {\n\n  EditMode.prototype.onMouseUp.call(this);\n\n  if (!this.creating) {\n    return;\n  }\n\n  this.dragging = false;\n\n  // Creation process.\n  var editor = this.editor;\n  var mousePosition = editor.getMousePosition();\n  var movements = this.movements;\n  var closed = false;\n\n  mousePosition = editor.clientToMarkups(mousePosition.x, mousePosition.y);\n\n  if (movements.length > 1 &&\n  areMarkupsPointsInClientRange(movements[movements.length - 2], mousePosition, SNAP_RANGE, this.editor)) {\n    return;\n  }\n\n  // Close polycloud if user clicks close to initial point.\n  if (movements.length > 2 &&\n  areMarkupsPointsInClientRange(movements[0], mousePosition, SNAP_RANGE, this.editor)) {\n    mousePosition = movements[0]; // Snap!\n    closed = true;\n  }\n\n  movements.splice(movements.length - 1, 1);\n\n  if (!closed) {\n    movements.push(mousePosition);\n    movements.push(mousePosition);\n  }\n\n  var polycloud = this.selectedMarkup;\n  var locations = setPositionAndSize(movements, polycloud);\n  var setPolycloud = new SetPolycloud(\n  editor,\n  polycloud,\n  polycloud.position,\n  polycloud.size,\n  locations,\n  closed);\n\n  setPolycloud.execute();\n\n  if (closed) {\n    this.creationEnd();\n  }\n};\n\nproto.onMouseDoubleClick = function (event) {\n\n  if (!this.creating) {\n    return;\n  }\n\n  var movements = this.movements;\n  movements.splice(Math.max(0, movements.length - 1));\n\n  if (movements.length < 2) {\n\n    this.creationCancel();\n  } else {\n\n    var polycloud = this.selectedMarkup;\n    var locations = setPositionAndSize(movements, polycloud);\n    var setPolycloud = new SetPolycloud(\n    this.editor,\n    polycloud,\n    polycloud.position,\n    polycloud.size,\n    locations,\n    true);\n\n    setPolycloud.execute();\n    this.creationEnd();\n  }\n};\n\nproto.destroy = function () {\n  this.onMouseDoubleClick();\n  EditMode.prototype.creationEnd.call(this);\n  EditMode.prototype.destroy.call(this);\n};\n\nproto.creationEnd = function () {\n\n  // To pass isMinSizeValid,\n  // probably that test should be done with the markup size (not the recorded by the edit mode).\n  if (this.selectedMarkup) {\n    this.size.x = this.selectedMarkup.size.x;\n    this.size.y = this.selectedMarkup.size.y;\n  }\n\n  EditMode.prototype.creationEnd.call(this);\n\n  this.closed = false;\n  this.movements = [];\n  this.dragging = false;\n  this.creating = false;\n};\n\nproto.creationCancel = function () {\n\n  EditMode.prototype.creationCancel.call(this);\n\n  this.closed = false;\n  this.movements = [];\n  this.dragging = false;\n  this.creating = false;\n};\n\nfunction setPositionAndSize(locations, markup) {\n\n  // determine the position of the top-left and bottom-right points\n  var minFn = function minFn(collection, key) {\n    var targets = collection.map(function (item) {\n      return item[key];\n    });\n    return Math.min.apply(null, targets);\n  };\n\n  var maxFn = function maxFn(collection, key) {\n    var targets = collection.map(function (item) {\n      return item[key];\n    });\n    return Math.max.apply(null, targets);\n  };\n\n  var strokeWidth = markup.style['stroke-width'];\n  var radius = strokeWidth * 2 + strokeWidth * 0.5;\n\n  var l = minFn(locations, 'x') - radius;\n  var t = minFn(locations, 'y') - radius;\n  var r = maxFn(locations, 'x') + radius;\n  var b = maxFn(locations, 'y') + radius;\n  var w = r - l;\n  var h = b - t;\n\n  markup.size = { x: w, y: h };\n  markup.position = { x: l + w * 0.5, y: t + h * 0.5 };\n\n  // Adjust points to relate from the shape's center\n  var position = markup.position;\n  return locations.map(function (point) {\n    return {\n      x: point.x - position.x,\n      y: point.y - position.y };\n\n  });\n}","'use strict';\n\nimport { EditMode } from './EditMode';\nimport { DeletePolyline } from '../edit-actions/DeletePolyline';\nimport { CreatePolyline } from '../edit-actions/CreatePolyline';\nimport { SetPolyline } from '../edit-actions/SetPolyline';\nimport * as MarkupTypes from '../MarkupTypes';\nimport { areMarkupsPointsInClientRange } from '../MarkupsCoreUtils';\n\nvar SNAP_RANGE = 25;\n\n/**\n                      *\n                      * @param editor\n                      * @constructor\n                      */\nexport function EditModePolyline(editor) {\n\n  var styleAttributes = ['stroke-width', 'stroke-color', 'stroke-opacity', 'fill-color', 'fill-opacity'];\n  EditMode.call(this, editor, MarkupTypes.MARKUP_TYPE_POLYLINE, styleAttributes);\n\n  this.creationMethod = this.CREATION_METHOD_CLICKS;\n  this.movements = [];\n}\n\nEditModePolyline.prototype = Object.create(EditMode.prototype);\nEditModePolyline.prototype.constructor = EditModePolyline;\n\nvar proto = EditModePolyline.prototype;\n\nproto.deleteMarkup = function (markup, cantUndo) {\n\n  markup = markup || this.selectedMarkup;\n  if (markup && markup.type == this.type) {\n    var movements = this.movements;\n    if (this.creating && movements.length >= 2) {\n      movements.pop();\n      movements.pop();\n      var lastIndex = movements.length - 1;\n      if (lastIndex >= 0) {\n        // duplicate last location\n        var lastMove = movements[lastIndex];\n        movements.push(lastMove);\n        var locations = setPositionAndSize(movements, this);\n        var setPolyline = new SetPolyline(\n        this.editor,\n        markup,\n        this.position,\n        this.size,\n        locations);\n\n        setPolyline.execute();\n      }\n    } else\n    {\n      var deletePolyline = new DeletePolyline(this.editor, markup);\n      deletePolyline.addToHistory = !cantUndo;\n      deletePolyline.execute();\n      this.creationEnd();\n      return true;\n    }\n  }\n  return false;\n};\n\n/**\n    * Handler to mouse move events, used to create markups.\n    * @param {MouseEvent} event Mouse event.\n    * @private\n    */\nproto.onMouseMove = function (event) {\n\n  if (!EditMode.prototype.onMouseMove.call(this, event)) {\n    return false;\n  }\n\n  var selectedMarkup = this.selectedMarkup;\n\n  var editor = this.editor;\n\n  this.dragging = true;\n\n  var movements = this.movements;\n  movements.splice(movements.length - 1, 1);\n\n  var mousePosition = editor.getMousePosition();\n  mousePosition = editor.clientToMarkups(mousePosition.x, mousePosition.y);\n\n  // Close polyline if user clicks close to initial point.\n  if (movements.length >= 2 &&\n  areMarkupsPointsInClientRange(movements[0], mousePosition, SNAP_RANGE, this.editor)) {\n    mousePosition = movements[0]; // Snap!\n  }\n\n  movements.push(mousePosition);\n\n  var locations = setPositionAndSize(movements, this);\n  var setPolyline = new SetPolyline(\n  editor,\n  selectedMarkup,\n  this.position,\n  this.size,\n  locations);\n\n  setPolyline.execute();\n  return true;\n};\n\n/**\n    * Handler to mouse down events, used to start markups creation.\n    * @private\n    */\nproto.onMouseDown = function (event) {\n\n  EditMode.prototype.onMouseDown.call(this);\n\n  // User selected an already created markup.\n  if (this.selectedMarkup && !this.creating) {\n    return;\n  }\n\n  if (this.creating) {\n    return;\n  }\n\n  // Creation process.\n  var editor = this.editor;\n  var mousePosition = editor.getMousePosition();\n\n  mousePosition = editor.clientToMarkups(mousePosition.x, mousePosition.y);\n\n  var size = this.size = editor.sizeFromClientToMarkups(1, 1);\n  this.movements = [mousePosition, mousePosition];\n\n  editor.beginActionGroup();\n\n  var markupId = editor.getId();\n  var create = new CreatePolyline(\n  editor,\n  markupId,\n  mousePosition,\n  size,\n  0,\n  [{ x: 0, y: 0 }],\n  this.style);\n\n  create.execute();\n\n  this.selectedMarkup = editor.getMarkup(markupId);\n  this.creationBegin();\n};\n\n/**\n    * Handler to mouse down events, used to start markups creation.\n    * @private\n    */\nproto.onMouseUp = function () {\n\n  EditMode.prototype.onMouseUp.call(this);\n\n  if (!this.creating) {\n    return;\n  }\n\n  this.dragging = false;\n\n  // Creation process.\n  var editor = this.editor;\n  var mousePosition = editor.getMousePosition();\n  var movements = this.movements;\n  var closed = false;\n\n  mousePosition = editor.clientToMarkups(mousePosition.x, mousePosition.y);\n\n  if (movements.length > 1 &&\n  areMarkupsPointsInClientRange(movements[movements.length - 2], mousePosition, SNAP_RANGE, this.editor)) {\n    return;\n  }\n\n  // Close polyline if user clicks close to initial point.\n  if (movements.length > 2 &&\n  areMarkupsPointsInClientRange(movements[0], mousePosition, SNAP_RANGE, this.editor)) {\n    mousePosition = movements[0]; // Snap!\n    closed = true;\n  }\n\n  movements.splice(movements.length - 1, 1);\n\n  if (!closed) {\n    movements.push(mousePosition);\n    movements.push(mousePosition);\n  }\n\n  var polyline = this.selectedMarkup;\n  var locations = setPositionAndSize(movements, polyline);\n  var setPolyline = new SetPolyline(\n  editor,\n  polyline,\n  polyline.position,\n  polyline.size,\n  locations,\n  closed);\n\n  setPolyline.execute();\n\n  if (closed) {\n    this.creationEnd();\n  }\n};\n\nproto.destroy = function () {\n  this.onMouseDoubleClick();\n  EditMode.prototype.creationEnd.call(this);\n  EditMode.prototype.destroy.call(this);\n};\n\nproto.creationEnd = function () {\n\n  // To pass isMinSizeValid,\n  // probably that test should be done with the markup size (not the recorded by the edit mode).\n  if (this.selectedMarkup) {\n    this.size.x = this.selectedMarkup.size.x;\n    this.size.y = this.selectedMarkup.size.y;\n  }\n\n  EditMode.prototype.creationEnd.call(this);\n\n  this.closed = false;\n  this.movements = [];\n  this.dragging = false;\n  this.creating = false;\n};\n\nproto.creationCancel = function () {\n\n  EditMode.prototype.creationCancel.call(this);\n\n  this.closed = false;\n  this.movements = [];\n  this.dragging = false;\n  this.creating = false;\n};\n\n\nproto.onMouseDoubleClick = function (event) {\n\n  if (!this.creating) {\n    return;\n  }\n\n  var movements = this.movements;\n  movements.splice(Math.max(0, movements.length - 1));\n\n  if (movements.length < 2) {\n\n    this.creationCancel();\n  } else {\n\n    var polyline = this.selectedMarkup;\n    var locations = setPositionAndSize(movements, polyline);\n    var setPolyline = new SetPolyline(\n    this.editor,\n    polyline,\n    polyline.position,\n    polyline.size,\n    locations,\n    this.closed);\n\n    setPolyline.execute();\n    this.creationEnd();\n  }\n};\n\nfunction setPositionAndSize(locations, markup) {\n\n  // determine the position of the top-left and bottom-right points\n  var minFn = function minFn(collection, key) {\n    var targets = collection.map(function (item) {\n      return item[key];\n    });\n    return Math.min.apply(null, targets);\n  };\n\n  var maxFn = function maxFn(collection, key) {\n    var targets = collection.map(function (item) {\n      return item[key];\n    });\n    return Math.max.apply(null, targets);\n  };\n\n  var l = minFn(locations, 'x');\n  var t = minFn(locations, 'y');\n  var r = maxFn(locations, 'x');\n  var b = maxFn(locations, 'y');\n  var w = r - l;\n  var h = b - t;\n\n  markup.size = { x: w, y: h };\n  markup.position = { x: l + w * 0.5, y: t + h * 0.5 };\n\n  // Adjust points to relate from the shape's center\n  var position = markup.position;\n  return locations.map(function (point) {\n    return {\n      x: point.x - position.x,\n      y: point.y - position.y };\n\n  });\n}","'use strict';\n\nimport { EditMode } from './EditMode';\nimport { DeleteRectangle } from '../edit-actions/DeleteRectangle';\nimport { CreateRectangle } from '../edit-actions/CreateRectangle';\nimport { SetRectangle } from '../edit-actions/SetRectangle';\nimport * as MarkupTypes from '../MarkupTypes';\n\nvar MeasureCommon = Autodesk.Viewing.MeasureCommon;\n\n/**\n                                                     *\n                                                     * @param editor\n                                                     * @constructor\n                                                     */\nexport function EditModeRectangle(editor) {\n\n  var styleAttributes = ['stroke-width', 'stroke-color', 'stroke-opacity', 'fill-color', 'fill-opacity'];\n  EditMode.call(this, editor, MarkupTypes.MARKUP_TYPE_RECTANGLE, styleAttributes);\n}\n\nEditModeRectangle.prototype = Object.create(EditMode.prototype);\nEditModeRectangle.prototype.constructor = EditModeRectangle;\n\nvar proto = EditModeRectangle.prototype;\n\nproto.deleteMarkup = function (markup, cantUndo) {\n\n  markup = markup || this.selectedMarkup;\n  if (markup && markup.type == this.type) {\n    var deleteRectangle = new DeleteRectangle(this.editor, markup);\n    deleteRectangle.addToHistory = !cantUndo;\n    deleteRectangle.execute();\n    return true;\n  }\n  return false;\n};\n\n/**\n    * Handler to mouse move events, used to create markups.\n    * @param {MouseEvent} event Mouse event.\n    * @private\n    */\nproto.onMouseMove = function (event) {\n\n  if (!EditMode.prototype.onMouseMove.call(this, event)) {\n    return false;\n  }\n\n  var selectedMarkup = this.selectedMarkup;\n\n  var editor = this.editor;\n\n  var pos = this.getFinalMouseDraggingPosition();\n  var final = editor.clientToMarkups(pos.x, pos.y);\n  var position = { x: (this.firstCorner.x + final.x) / 2, y: (this.firstCorner.y + final.y) / 2 };\n\n  var width, height;\n  // Snap to parallel/perpendicular of underlying vectors\n  if (editor.snapper && this.lineSnapped) {\n    var start = editor.project(this.lineSnapped.vertices[0]);\n    var end = editor.project(this.lineSnapped.vertices[1]);\n\n    var startZ = start.z;\n\n    start = editor.clientToMarkups(start.x, start.y);\n    end = editor.clientToMarkups(end.x, end.y);\n\n    start = new THREE.Vector3(start.x, start.y, startZ);\n    end = new THREE.Vector3(end.x, end.y, startZ);\n\n    var p = new THREE.Vector3(final.x, final.y, startZ);\n\n    var parallel = MeasureCommon.nearestPointInPointToLine(p, start, end);\n    height = p.distanceTo(parallel);\n\n    // select an arbitrary point on the perpendicular line\n    var k = -(start.x - end.x) / (start.y - end.y);\n    var b = this.firstCorner.y - k * this.firstCorner.x;\n    var x = this.firstCorner.x + 1;\n    var y = k * x + b;\n    var pEnd = new THREE.Vector3(x, y, startZ);\n\n    var pStart = new THREE.Vector3(this.firstCorner.x, this.firstCorner.y, startZ);\n    var perpendicular = MeasureCommon.nearestPointInPointToLine(p, pStart, pEnd);\n    width = p.distanceTo(perpendicular);\n  } else\n  {\n    width = final.x - this.firstCorner.x;\n    height = final.y - this.firstCorner.y;\n  }\n\n  var size = this.size = { x: Math.abs(width), y: Math.abs(height) };\n\n  var setRectangle = new SetRectangle(\n  editor,\n  selectedMarkup,\n  position,\n  size);\n\n  setRectangle.execute();\n  return true;\n};\n\n/**\n    * Handler to mouse down events, used to start markups creation.\n    * @private\n    */\nproto.onMouseDown = function () {\n\n  EditMode.prototype.onMouseDown.call(this);\n\n  if (this.selectedMarkup) {\n    return;\n  }\n\n  var editor = this.editor;\n  var mousePosition = editor.getMousePosition();\n\n  this.initialX = mousePosition.x;\n  this.initialY = mousePosition.y;\n\n  // Calculate center and size.\n  var position = this.firstCorner = editor.clientToMarkups(this.initialX, this.initialY);\n  var size = this.size = editor.sizeFromClientToMarkups(1, 1);\n\n  // Calculate rotation\n  var rotation = 0;\n  this.lineSnapped = null;\n  if (editor.snapper) {\n    // Snap to parallel/perpendicular of underlying vectors\n    var geomType = editor.snapper.getGeometryType();\n    if (geomType === MeasureCommon.SnapType.SNAP_EDGE) {\n      this.lineSnapped = editor.snapper.getEdge();\n      var start = editor.project(this.lineSnapped.vertices[0]);\n      var end = editor.project(this.lineSnapped.vertices[1]);\n      var dx = end.x - start.x;\n      var dy = end.y - start.y;\n      rotation = this.rotation = Math.atan2(dy, dx);\n    }\n  }\n\n  // Create rectangle.\n  editor.beginActionGroup();\n\n  var markupId = editor.getId();\n  var create = new CreateRectangle(\n  editor,\n  markupId,\n  position,\n  size,\n  rotation,\n  this.style);\n\n  create.execute();\n\n  this.selectedMarkup = editor.getMarkup(markupId);\n  this.creationBegin();\n};","'use strict';function _typeof(obj) {\"@babel/helpers - typeof\";if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;};}return _typeof(obj);}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError(\"Cannot call a class as a function\");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}function _inherits(subClass, superClass) {if (typeof superClass !== \"function\" && superClass !== null) {throw new TypeError(\"Super expression must either be null or a function\");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}function _createSuper(Derived) {var hasNativeReflectConstruct = _isNativeReflectConstruct();return function _createSuperInternal() {var Super = _getPrototypeOf(Derived),result;if (hasNativeReflectConstruct) {var NewTarget = _getPrototypeOf(this).constructor;result = Reflect.construct(Super, arguments, NewTarget);} else {result = Super.apply(this, arguments);}return _possibleConstructorReturn(this, result);};}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");}return self;}function _isNativeReflectConstruct() {if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;if (Reflect.construct.sham) return false;if (typeof Proxy === \"function\") return true;try {Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));return true;} catch (e) {return false;}}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}\n\nimport { EditMode } from './EditMode';\nimport { DeleteStamp } from '../edit-actions/DeleteStamp';\nimport { CreateStamp } from '../edit-actions/CreateStamp';\nimport { SetStamp } from '../edit-actions/SetStamp';\nimport * as MarkupTypes from '../MarkupTypes';\n\nexport { EditModeStamp };var\n\nEditModeStamp = /*#__PURE__*/function (_EditMode) {_inherits(EditModeStamp, _EditMode);var _super = _createSuper(EditModeStamp);\n  function EditModeStamp(editor, svgData) {var _this;_classCallCheck(this, EditModeStamp);\n    var styleAttributes = [\n    'text-data'];\n\n    _this = _super.call(this, editor, MarkupTypes.MARKUP_TYPE_STAMP, styleAttributes);\n    _this.svgData = svgData;return _this;\n  }_createClass(EditModeStamp, [{ key: \"deleteMarkup\", value: function deleteMarkup(\n\n    markup, cantUndo) {\n      markup = markup || this.selectedMarkup;\n      if (markup && markup.type == this.type) {\n        var deleteStamp = new DeleteStamp(this.editor, markup);\n        deleteStamp.addToHistory = !cantUndo;\n        deleteStamp.execute();\n        return true;\n      }\n      return false;\n    } }, { key: \"onMouseMove\", value: function onMouseMove(\n\n    event) {\n      if (!EditMode.prototype.onMouseMove.call(this, event)) {\n        return false;\n      }var\n\n      selectedMarkup = this.selectedMarkup,editor = this.editor;\n\n      var final = this.getFinalMouseDraggingPosition();\n      final = editor.clientToMarkups(final.x, final.y);\n      var position = {\n        x: (this.firstPosition.x + final.x) / 2,\n        y: (this.firstPosition.y + final.y) / 2 };\n\n      var size = this.size = {\n        x: Math.abs(final.x - this.firstPosition.x),\n        y: Math.abs(final.y - this.firstPosition.y) };\n\n\n      var action = new SetStamp(editor, selectedMarkup, position, size);\n      action.execute();\n      return true;\n    } }, { key: \"onMouseDown\", value: function onMouseDown()\n\n    {\n      EditMode.prototype.onMouseDown.call(this);\n\n      if (this.selectedMarkup) {\n        return;\n      }\n\n      var editor = this.editor;\n      var mousePosition = editor.getMousePosition();\n\n      this.initialX = mousePosition.x;\n      this.initialY = mousePosition.y;\n      this.firstPosition = editor.clientToMarkups(this.initialX, this.initialY);\n      this.size = editor.sizeFromClientToMarkups(1, 1);\n\n      editor.beginActionGroup();\n      var markupId = editor.getId();\n      var action = new CreateStamp(editor, markupId, this.firstPosition, this.size, 0, this.style, this.svgData);\n      action.execute();\n\n      // maybe this isn't being called right, that would explain it\n      this.selectedMarkup = editor.getMarkup(markupId);\n      this.creationBegin();\n    } }]);return EditModeStamp;}(EditMode);","'use strict';\n\nimport { EditMode } from './EditMode';\nimport { DeleteText } from '../edit-actions/DeleteText';\nimport { DeleteCallout } from '../edit-actions/DeleteCallout';\nimport { CreateText } from '../edit-actions/CreateText';\nimport { SetText } from '../edit-actions/SetText';\nimport { SetSize } from '../edit-actions/SetSize';\nimport { SetStyle } from '../edit-actions/SetStyle';\nimport * as MarkupTypes from '../MarkupTypes';\nimport * as MarkupEvents from '../MarkupEvents';\nimport { EditorTextInput } from './EditorTextInput';\n\n\n/**\n                                                      *\n                                                      * @param editor\n                                                      * @constructor\n                                                      */\nexport function EditModeText(editor) {\n\n  var styleAttributes = [\n  'font-size',\n  'stroke-color',\n  'stroke-opacity',\n  'fill-color',\n  'fill-opacity',\n  'font-family',\n  'font-style',\n  'font-weight'];\n\n  EditMode.call(this, editor, MarkupTypes.MARKUP_TYPE_TEXT, styleAttributes);\n\n  var helper = new EditorTextInput(this.viewer.container, this.editor, false, 'Text', 260);\n  helper.addEventListener(helper.EVENT_TEXT_CHANGE, this.onHelperTextChange.bind(this), false);\n  helper.addEventListener(helper.EVENT_TEXT_SET_ACTIVE, this.onHelperSetActive.bind(this), false);\n  helper.addEventListener(helper.EVENT_TEXT_SET_INACTIVE, this.onHelperSetActive.bind(this), false);\n\n  this.textInputHelper = helper;\n  this.onHistoryChangeBinded = this.onHistoryChange.bind(this);\n  this.minSize = 0; // No need to size it initially\n  this.creationMethod = this.CREATION_METHOD_CLICK;\n}\n\nEditModeText.prototype = Object.create(EditMode.prototype);\nEditModeText.prototype.constructor = EditModeText;\n\nvar proto = EditModeText.prototype;\n\nproto.deleteMarkup = function (markup, cantUndo) {\n\n  markup = markup || this.selectedMarkup;\n  if (markup && markup.type == this.type) {\n    var deleteText = new DeleteText(this.editor, markup);\n    deleteText.addToHistory = !cantUndo;\n    deleteText.execute();\n    return true;\n  }\n  return false;\n};\n\n/**\n    *\n    * @param style\n    */\nproto.setStyle = function (style) {\n\n  if (this.textInputHelper && this.textInputHelper.isActive()) {\n\n    this.textInputHelper.setStyle(style);\n  } else {\n    EditMode.prototype.setStyle.call(this, style);\n  }\n};\n\nproto.notifyAllowNavigation = function (allows) {\n\n  if (allows && this.textInputHelper && this.textInputHelper.isActive()) {\n    this.textInputHelper.acceptAndExit();\n  }\n};\n\nproto.destroy = function () {\n\n  if (this.textInputHelper) {\n    if (this.textInputHelper.isActive()) {\n      this.textInputHelper.acceptAndExit();\n    }\n    this.textInputHelper.destroy();\n    this.textInputHelper = null;\n  }\n  EditMode.prototype.destroy.call(this);\n};\n\n/**\n    * Handler to mouse down events, used to start markups creation.\n    */\nproto.onMouseDown = function () {\n\n  if (this.textInputHelper && this.textInputHelper.isActive()) {\n    this.textInputHelper.acceptAndExit();\n    return;\n  }\n\n  if (this.selectedMarkup) {\n    return;\n  }\n\n  var editor = this.editor;\n  var mousePosition = editor.getMousePosition();\n  var clientFontSize = editor.sizeFromMarkupsToClient(0, this.style['font-size']).y;\n  var initialWidth = clientFontSize * 15; // Find better way to initialize size.\n  var initialHeight = clientFontSize * 1;\n\n  // Center position.\n  var size = this.size = editor.sizeFromClientToMarkups(initialWidth, initialHeight);\n  var position = editor.positionFromClientToMarkups(\n  mousePosition.x + initialWidth * 0.5,\n  mousePosition.y + initialHeight * 0.5);\n\n  this.creationBegin();\n  editor.beginActionGroup();\n\n  // Given the initial width and font size, we assume that the text fits in one line.\n  var createText = new CreateText(\n  editor,\n  editor.getId(),\n  position,\n  size,\n  '',\n  this.style);\n\n  createText.execute();\n  this.creationEnd();\n\n  this.selectedMarkup = editor.getMarkup(createText.targetId);\n  this.textInputHelper && this.textInputHelper.setActive(this.selectedMarkup, true);\n  this.editor.actionManager.addEventListener(MarkupEvents.EVENT_HISTORY_CHANGED, this.onHistoryChangeBinded);\n};\n\nproto.updateTextBoxStyle = function () {\n  if (this.isTextInputHelperActive()) {\n    this.textInputHelper.onCameraChanged();\n  }\n};\n\nproto.onMouseUp = function (event) {\n\n};\n\nproto.onMouseDoubleClick = function (markup) {\n\n  if (markup === this.selectedMarkup) {\n    this.editor.selectMarkup(markup);\n    this.editor.editFrame.setMarkup(markup);\n    this.textInputHelper && this.textInputHelper.setActive(markup, false);\n  }\n};\n\nproto.onHelperSetActive = function (event) {\n  var databag = event.data;\n  var markup = databag.markup;\n  if (markup) {\n    markup.setIsHelperTextActive(databag.isActive);\n    markup.setIsShapeVisible(!databag.isActive);\n  }\n};\n\nproto.onHelperTextChange = function (event) {\n\n  var dataBag = event.data;\n  var textMarkup = dataBag.markup;\n  var textStyle = dataBag.style;\n  var curSelection = this.selectedMarkup;\n\n  this.editor.actionManager.removeEventListener(MarkupEvents.EVENT_HISTORY_CHANGED, this.onHistoryChangeBinded);\n\n  // Deal with edge case first: Creating a Label without text\n  if (dataBag.newText === '') {\n    this.editor.cancelActionGroup();\n\n    var deleteCallout = new DeleteCallout(this.editor, textMarkup);\n    deleteCallout.execute();\n\n    if (textMarkup !== curSelection) {\n      this.editor.selectMarkup(curSelection);\n    }\n\n    return;\n  }\n\n  // When the text is created for the first time, an action group\n  // is already created and it includes the CreateText action.\n  // Thus, no need to begin another action group.\n  if (!dataBag.firstEdit) {\n    this.editor.beginActionGroup();\n  }\n\n  // Size change action //\n  var position = this.editor.positionFromClientToMarkups(\n  dataBag.newPos.x, dataBag.newPos.y);\n\n  var size = this.editor.sizeFromClientToMarkups(\n  dataBag.width, dataBag.height);\n\n  var setSize = new SetSize(\n  this.editor,\n  textMarkup,\n  position,\n  size.x,\n  size.y);\n  setSize.execute();\n\n  // Text change action //\n  var setText = new SetText(\n  this.editor,\n  textMarkup,\n  textMarkup.position,\n  textMarkup.size,\n  dataBag.newText);\n  setText.execute();\n\n  var setStyle = new SetStyle(\n  this.editor,\n  textMarkup,\n  textStyle);\n\n  setStyle.execute();\n\n  // However, we do need to close the action group at this point. For both cases.\n  this.editor.closeActionGroup();\n  this.editor.selectMarkup(curSelection);\n};\n\n/**\n    * We want to make sure that the Input Helper gets removed from the screen\n    * whenever the user attempts to perform an undo or redo action.\n    * @param {Event} event\n    * @private\n    */\nproto.onHistoryChange = function (event) {\n\n  if (this.textInputHelper && this.textInputHelper.isActive()) {\n    this.editor.actionManager.removeEventListener(MarkupEvents.EVENT_HISTORY_CHANGED, this.onHistoryChangeBinded);\n    this.textInputHelper.setInactive();\n  }\n};\n\n/**\n    * Notify the markup that the displayed markups are being saved so edit mode can finish current editions.\n    */\nproto.onSave = function () {\n\n  EditMode.prototype.onSave.call(this);\n\n  // Close input helper if it's open.\n  if (this.textInputHelper && this.textInputHelper.isActive()) {\n    var firstEdit = this.textInputHelper.firstEdit;\n\n    this.editor.actionManager.removeEventListener(MarkupEvents.EVENT_HISTORY_CHANGED, this.onHistoryChangeBinded);\n    this.textInputHelper.setInactive();\n\n    // Close action group if open (first edit).s\n    if (firstEdit) {\n      this.editor.cancelActionGroup();\n    }\n\n    this.editor.selectMarkup(null);\n    this.selectedMarkup = null;\n  }\n};\n\nproto.updateTextBoxStyle = function () {\n  if (this.isTextInputHelperActive()) {\n    this.textInputHelper.onCameraChanged();\n  }\n};","\n'use strict';\n\n/*!\n                  Based on Autosize 4.0.0\n                  license: MIT\n                  http://www.jacklmoore.com/autosize\n              */\nvar map = typeof Map === \"function\" ? new Map() : function () {\n  var keys = [];\n  var values = [];\n\n  return {\n    has: function has(key) {\n      return keys.indexOf(key) > -1;\n    },\n    get: function get(key) {\n      return values[keys.indexOf(key)];\n    },\n    set: function set(key, value) {\n      if (keys.indexOf(key) === -1) {\n        keys.push(key);\n        values.push(value);\n      }\n    },\n    'delete': function _delete(key) {\n      var index = keys.indexOf(key);\n      if (index > -1) {\n        keys.splice(index, 1);\n        values.splice(index, 1);\n      }\n    } };\n\n}();\n\nvar createEvent = function createEvent(name) {\n  return new Event(name, { bubbles: true });\n};\ntry {\n  new Event('test');\n} catch (e) {\n  // IE does not support `new Event()`\n  createEvent = function createEvent(name) {\n    var _document = Autodesk.Viewing.getGlobal().document;\n    var evt = _document.createEvent('Event');\n    evt.initEvent(name, true, false);\n    return evt;\n  };\n}\n\nfunction assign(ta) {\n  if (!ta || !ta.nodeName || ta.nodeName !== 'TEXTAREA' || map.has(ta)) return;\n\n  var heightOffset = null;\n  var clientWidth = ta.clientWidth;\n  var cachedHeight = null;\n\n  var self = this;\n  function init() {\n    var _window = self.getWindow();\n    var style = _window.getComputedStyle(ta, null);\n\n    if (style.resize === 'vertical') {\n      ta.style.resize = 'none';\n    } else if (style.resize === 'both') {\n      ta.style.resize = 'horizontal';\n    }\n\n    if (style.boxSizing === 'content-box') {\n      heightOffset = -(parseFloat(style.paddingTop) + parseFloat(style.paddingBottom));\n    } else {\n      heightOffset = parseFloat(style.borderTopWidth) + parseFloat(style.borderBottomWidth);\n    }\n    // Fix when a textarea is not on document body and heightOffset is Not a Number\n    if (isNaN(heightOffset)) {\n      heightOffset = 0;\n    }\n\n    update();\n  }\n\n  function changeOverflow(value) {\n    {\n      // Chrome/Safari-specific fix:\n      // When the textarea y-overflow is hidden, Chrome/Safari do not reflow the text to account for the space\n      // made available by removing the scrollbar. The following forces the necessary text reflow.\n      var width = ta.style.width;\n      ta.style.width = '0px';\n      // Force reflow:\n      /* jshint ignore:start */\n      ta.offsetWidth;\n      /* jshint ignore:end */\n      ta.style.width = width;\n    }\n\n    ta.style.overflow = value;\n  }\n\n  function getParentOverflows(el) {\n    var arr = [];\n\n    while (el && el.parentNode && el.parentNode instanceof Element) {\n      if (el.parentNode.scrollTop) {\n        arr.push({\n          node: el.parentNode,\n          scrollTop: el.parentNode.scrollTop });\n\n      }\n      el = el.parentNode;\n    }\n\n    return arr;\n  }\n\n  function resize() {\n    var originalHeight = ta.style.height;\n    var overflows = getParentOverflows(ta);\n    var _document = self.getDocument();\n    var docTop = _document.documentElement && _document.documentElement.scrollTop; // Needed for Mobile IE (ticket #240)\n\n    ta.style.height = '';\n\n    var endHeight = ta.scrollHeight + heightOffset;\n\n    if (ta.scrollHeight === 0) {\n      // If the scrollHeight is 0, then the element probably has display:none or is detached from the DOM.\n      ta.style.height = originalHeight;\n      return;\n    }\n\n    ta.style.height = endHeight + 'px';\n\n    // used to check if an update is actually necessary on window.resize\n    clientWidth = ta.clientWidth;\n\n    // prevents scroll-position jumping\n    overflows.forEach(function (el) {\n      // This condition is necessary for iOS 11, where you can't assign value to body.scrollTop\n      if (el.node.scrollTop !== el.scrollTop) {\n        el.node.scrollTop = el.scrollTop;\n      }\n    });\n\n    if (docTop) {\n      _document.documentElement.scrollTop = docTop;\n    }\n  }\n\n  function update() {\n    resize();\n\n    var _window = self.getWindow();\n    var styleHeight = Math.round(parseFloat(ta.style.height));\n    var computed = _window.getComputedStyle(ta, null);\n\n    // Using offsetHeight as a replacement for computed.height in IE, because IE does not account use of border-box\n    var actualHeight = computed.boxSizing === 'content-box' ? Math.round(parseFloat(computed.height)) : ta.offsetHeight;\n\n    // The actual height not matching the style height (set via the resize method) indicates that\n    // the max-height has been exceeded, in which case the overflow should be allowed.\n    if (actualHeight !== styleHeight) {\n      if (computed.overflow === 'hidden') {\n        changeOverflow('scroll');\n        resize();\n        actualHeight = computed.boxSizing === 'content-box' ? Math.round(parseFloat(window.getComputedStyle(ta, null).height)) : ta.offsetHeight;\n      }\n    } else {\n      // Normally keep overflow set to hidden, to avoid flash of scrollbar as the textarea expands.\n      if (computed.overflow !== 'hidden') {\n        changeOverflow('hidden');\n        resize();\n        actualHeight = computed.boxSizing === 'content-box' ? Math.round(parseFloat(window.getComputedStyle(ta, null).height)) : ta.offsetHeight;\n      }\n    }\n\n    if (cachedHeight !== actualHeight) {\n      cachedHeight = actualHeight;\n      var evt = createEvent('autosize:resized');\n      try {\n        ta.dispatchEvent(evt);\n      } catch (err) {\n        // Firefox will throw an error on dispatchEvent for a detached element\n        // https://bugzilla.mozilla.org/show_bug.cgi?id=889376\n      }\n    }\n  }\n\n  var pageResize = function pageResize() {\n    if (ta.clientWidth !== clientWidth) {\n      update();\n    }\n  };\n\n  var destroy = function (style) {\n    self.removeWindowEventListener('resize', pageResize, false);\n    ta.removeEventListener('input', update, false);\n    ta.removeEventListener('keyup', update, false);\n    ta.removeEventListener('autosize:destroy', destroy, false);\n    ta.removeEventListener('autosize:update', update, false);\n\n    Object.keys(style).forEach(function (key) {\n      ta.style[key] = style[key];\n    });\n\n    map['delete'](ta);\n  }.bind(ta, {\n    height: ta.style.height,\n    resize: ta.style.resize,\n    overflow: ta.style.overflow,\n    overflowX: ta.style.overflowX,\n    wordWrap: ta.style.wordWrap });\n\n\n  ta.addEventListener('autosize:destroy', destroy, false);\n\n  // IE9 does not fire onpropertychange or oninput for deletions,\n  // so binding to onkeyup to catch most of those events.\n  // There is no way that I know of to detect something like 'cut' in IE9.\n  if ('onpropertychange' in ta && 'oninput' in ta) {\n    ta.addEventListener('keyup', update, false);\n  }\n\n  self.addWindowEventListener('resize', pageResize, false);\n  ta.addEventListener('input', update, false);\n  ta.addEventListener('autosize:update', update, false);\n  ta.style.overflowX = 'hidden';\n  ta.style.wordWrap = 'break-word';\n\n  map.set(ta, {\n    destroy: destroy,\n    update: update });\n\n\n  init();\n}\n\nfunction destroy(ta) {\n  var methods = map.get(ta);\n  if (methods) {\n    methods.destroy();\n  }\n}\n\nfunction update(ta) {\n  var methods = map.get(ta);\n  if (methods) {\n    methods.update();\n  }\n}\n\nfunction isRuntimeSupported() {\n  // Don't support Node.js and IE8 (or lower)\n  var _window = Autodesk.Viewing.getGlobal();\n  if (typeof window === 'undefined' || typeof window.getComputedStyle !== 'function')\n  return false;\n  return true;\n}\n\nvar RUNTIME_SUPPORTED = isRuntimeSupported();\n\n\nexport var autosize = function autosize(el, options) {\n  var self = this;\n  if (RUNTIME_SUPPORTED && el) {\n    Array.prototype.forEach.call(el.length ? el : [el], function (x) {\n      return assign.bind(self)(x, options);\n    });\n  }\n  return el;\n};\n\nautosize.destroy = function (el) {\n  if (RUNTIME_SUPPORTED && el) {\n    Array.prototype.forEach.call(el.length ? el : [el], destroy);\n  }\n  return el;\n};\n\nautosize.update = function (el) {\n  if (RUNTIME_SUPPORTED && el) {\n    Array.prototype.forEach.call(el.length ? el : [el], update);\n  }\n  return el;\n};","'use strict';\n\nimport ResizeObserver from 'resize-observer-polyfill';\nimport { autosize } from './EditorTextAutosize';\nimport { addTraitEventDispatcher } from '../MarkupsCoreUtils';\nimport { cloneStyle } from '../StyleUtils';\nimport { DomElementStyle } from '../DomElementStyle';\n\nvar av = Autodesk.Viewing;\n\n/**\n                            * Auxiliary class that handles all input for the Label Markup (MarkupText.js)\n                            * It instantiates a TEXTAREA where the user can input text. When user input is\n                            * disabled, the textarea gets hidden and further rendering is delegated to\n                            * MarkupText.js\n                            *\n                            * @param {HTMLElement} parentDiv\n                            * @param {Object} editor - Core Extension\n                            * @constructor\n                            */\nexport function EditorTextInput(parentDiv, editor, singleLine, defaultText, maxLength) {\n\n  this.parentDiv = parentDiv;\n  this.editor = editor;\n  this.setGlobalManager(editor.viewer.globalManager);\n\n  // Constants\n  this.EVENT_TEXT_CHANGE = 'EVENT_CO2_TEXT_CHANGE';\n  this.EVENT_TEXT_SET_ACTIVE = 'EVENT_CO2_TEXT_SET_ACTIVE';\n  this.EVENT_TEXT_SET_INACTIVE = 'EVENT_CO2_TEXT_SET_INACTIVE';\n\n  var _document = this.getDocument();\n  // The actual TextArea input\n  if (singleLine) {\n    this.textArea = _document.createElement('input');\n    this.textArea.setAttribute('type', 'text');\n  } else\n  {\n    this.textArea = _document.createElement('textarea');\n    this.textArea.rows = '1';\n    if (!Autodesk.Viewing.isIE11) {// auto parameter not available in IE11\n      this.textArea.dir = 'auto';\n    }\n  }\n\n  this.firstEdit = true;\n  this.defaultText = defaultText;\n  this.textArea.setAttribute('maxlength', maxLength); // TODO: Make constant? Change value?\n  this.textArea.setAttribute('data-i18n', defaultText);\n  this.startingHeight = 0;\n\n  autosize.bind(this)(this.textArea);\n\n  var ro = new ResizeObserver(function (entries, observer) {\n    this.setEditFrame();\n  }.bind(this));\n\n  ro.observe(this.textArea);\n\n  this.styleTextArea = new DomElementStyle(); // TODO: Move this to EditMode.\n  this.styleTextArea.\n  setAttribute('position', 'absolute').\n  setAttribute('resize', 'none').\n  setAttribute('box-sizing', 'border-box').\n  setAttribute('-moz-box-sizing', 'border-box').\n  setAttribute('-webkit-box-sizing', 'border-box').\n  setAttribute('overflow', 'hidden').\n  setAttribute('outline', 'none').\n  setAttribute('border', 'none').\n  setAttribute('z-index', '1').\n  setAttribute('padding', '10px');\n\n  // Helper div to measure text width\n  this.measureDiv = _document.createElement('div');\n\n  // Become an event dispatcher\n  addTraitEventDispatcher(this);\n}\n\nav.GlobalManagerMixin.call(EditorTextInput.prototype);\nvar proto = EditorTextInput.prototype;\n\nproto.destroy = function () {\n\n  this.setInactive();\n};\n\n/**\n    * Initializes itself given an Label Markup (textMarkup)\n    * @param {Object} textMarkup\n    * @param {Boolean} firstEdit - Whether the markup is being edited for the first time.\n    */\nproto.setActive = function (textMarkup, firstEdit) {\n\n  if (this.textMarkup === textMarkup) {\n    return;\n  }\n\n  var placeholderText = Autodesk.Viewing.i18n.translate(this.defaultText);\n  this.textArea.setAttribute('placeholder', placeholderText);\n\n  this.setInactive();\n  this.parentDiv.appendChild(this.textArea);\n  this.textMarkup = textMarkup;\n  this.firstEdit = firstEdit || false;\n\n  this.constrainToCanvas = firstEdit;\n\n  this.initFromMarkup();\n\n  this.constrainToCanvas = false;\n\n  // On iOS this doesn't work quite well, the keyboard will dismiss after call focus programatically.\n  // http://stackoverflow.com/questions/32407185/wkwebview-cant-open-keyboard-for-input-field\n  if (!Autodesk.Viewing.isIOSDevice()) {\n    // Focus on next frame\n    var txtArea = this.textArea;\n    var _window = this.getWindow();\n    _window.requestAnimationFrame(function () {\n      txtArea.focus();\n    });\n  }\n\n  var dataBag = {\n    markup: this.textMarkup,\n    firstEdit: this.firstEdit,\n    isActive: true };\n\n  this.dispatchEvent({ type: this.EVENT_TEXT_SET_ACTIVE, data: dataBag });\n};\n\n/**\n    * Closes the editor text input and goes back into normal markup edition mode.\n    */\nproto.setInactive = function () {\n  var dataBag = {\n    markup: this.textMarkup,\n    isActive: false };\n\n\n  // In iOS10, the keyboard always show on screen after tap screen out of text\n  // area or save markup to end text edit, call blur to make sure keyboard dismiss.\n  if (Autodesk.Viewing.isIOSDevice())\n  {\n    this.textArea.blur();\n  }\n\n  this.removeWindowEventListener('resize', this.onResizeBinded);\n\n  if (this.textMarkup) {\n    this.textMarkup = null;\n    this.parentDiv.removeChild(this.textArea);\n  }\n  this.style = null;\n\n  this.dispatchEvent({ type: this.EVENT_TEXT_SET_INACTIVE, data: dataBag });\n};\n\nproto.isActive = function () {\n\n  return !!this.textMarkup;\n};\n\nproto.setEditFrame = function () {\n  if (this.editor.editFrame.markup && this.textMarkup && this.editor.editFrame.markup === this.textMarkup) {\n    var frameWidth = parseFloat(this.textArea.style.width);\n    var frameHeight = parseFloat(this.textArea.style.height);\n\n    var position = this.textMarkup.getClientPosition();\n    var rotation = this.textMarkup.getRotation();\n\n    var xPos = position.x - frameWidth / 2;\n    var yPos = position.y - this.startingHeight / 2;\n\n    this.editor.editFrame.setSelection(xPos, yPos, frameWidth, frameHeight, rotation);\n  }\n};\n\n/**\n    * Applies Markup styles to TextArea used for editing.\n    * It also saves a copy of the style object.\n    * @private\n    */\nproto.initFromMarkup = function (updateStyleFirst) {\n\n  var markup = this.textMarkup;\n  var position = markup.getClientPosition();\n  var size = markup.getClientSize();\n\n  // Text area padding is relative to the current font size\n  var padding = markup.getClientFontSize() / 2;\n\n  this.startingHeight = size.y;\n\n  var left = position.x - size.x * 0.5;\n  var top = position.y - size.y * 0.5;\n\n  var lineHeightPercentage = markup.lineHeight + \"%\";\n  this.styleTextArea.setAttribute('line-height', lineHeightPercentage);\n  this.styleTextArea.setAttribute('padding', padding + 'px');\n\n  this.setPosAndSize(left, top, size.x, size.y);\n  if (updateStyleFirst) {\n    this.setStyle(markup.getStyle());\n    this.textArea.value = markup.getText();\n  } else {\n    this.textArea.value = markup.getText();\n    this.setStyle(markup.getStyle());\n  }\n};\n\nproto.setPosAndSize = function (left, top, width, height) {\n  if (this.constrainToCanvas) {\n    // Check that it doesn't overflow out of the canvas\n    if (left + width >= this.editor.viewer.container.clientWidth) {\n      left = this.editor.viewer.container.clientWidth - (width + 10);\n    }\n    if (top + height >= this.editor.viewer.container.clientHeight) {\n      top = this.editor.viewer.container.clientHeight - (height + 10);\n    }\n\n    // Make sure text input left side always in the canvas area.\n    // Especially on iPhone6 & iPhone7\n    if (left < 5) {\n      left = 5;\n      width = this.editor.viewer.container.clientWidth - 10;\n    }\n  }\n\n  this.styleTextArea\n  // Size and position\n  .setAttribute('left', left + 'px').\n  setAttribute('top', top + 'px').\n  setAttribute('width', width + 'px').\n  setAttribute('height', height + 'px');\n};\n\nproto.setStyle = function (style) {\n\n  if (this.style) {\n    // An already present style means that the user\n    // has changed the style using the UI buttons.\n    // We need to account for the user having changed the\n    // width/height of the TextArea. Since there is no event\n    // we can detect for it, we do it here.\n    var temp = {};\n    this.injectSizeValues(temp);\n    this.setPosAndSize(\n    temp.newPos.x - temp.width * 0.5,\n    temp.newPos.y - temp.height * 0.5,\n    temp.width, temp.height);\n  }\n  var fontHeight = this.editor.sizeFromMarkupsToClient(0, style['font-size']).y;\n  var strokeWidth = this.editor.sizeFromMarkupsToClient(0, style['stroke-width']).y;\n  var textAreaStyle = this.styleTextArea\n  // Visuals\n  .setAttribute('color', style['stroke-color']).\n  setAttribute('outline', strokeWidth + 'px solid ' + style['stroke-color']).\n  setAttribute('font-family', style['font-family']).\n  setAttribute('font-size', fontHeight + 'px').\n  setAttribute('font-weight', style['font-weight']).\n  setAttribute('font-style', style['font-style']).\n  getStyleString();\n  this.textArea.setAttribute('style', textAreaStyle);\n  this.style = cloneStyle(style);\n  autosize.update(this.textArea);\n};\n\n/**\n    * Helper function that, for a given markup with some text in it\n    * returns an Array of lines in it.\n    * @param {Object} markup\n    * @returns {{text, lines}|{text: String, lines: Array.<String>}}\n    */\nproto.getTextValuesForMarkup = function (markup, sizeUpdateRequired) {\n  var active = this.isActive();\n  var activeMarkup = this.textMarkup;\n  var activeFirstEdit = this.firstEdit;\n\n  this.setActive(markup, false);\n  var textValues = this.getTextValues();\n\n  var dataBag = {\n    markup: markup,\n    textValues: textValues };\n\n\n  if (active) {\n    this.setActive(activeMarkup, activeFirstEdit);\n  } else {\n    if (sizeUpdateRequired) {\n      this.injectSizeValues(dataBag);\n    }\n\n    this.setInactive();\n  }\n\n  return dataBag;\n};\n\n/**\n    * Returns the current text as one string and an array of lines\n    * of how the text is being rendered (1 string per line)\n    * @returns {{text: String, lines: Array.<String>}}\n    */\nproto.getTextValues = function () {\n\n  var newText = this.textArea.value;\n  if (newText === this.defaultText) {\n    newText = '';\n  }\n  return {\n    text: newText,\n    lines: this.generateLines() };\n\n};\n\n/**\n    * Function called by UI\n    */\nproto.acceptAndExit = function () {\n\n  // If placeholder text, then remove.\n  var textValues = this.getTextValues();\n  var textMarkup = this.textMarkup;\n\n  var dataBag = {\n    markup: this.textMarkup,\n    style: this.style,\n    firstEdit: this.firstEdit,\n    newText: textValues.text,\n    newLines: textValues.lines };\n\n  this.injectSizeValues(dataBag);\n\n  this.dispatchEvent({ type: this.EVENT_TEXT_CHANGE, data: dataBag });\n  this.setInactive();\n  textMarkup.updateStyle(true); // Hack: LMV-3628\n};\n\n/**\n    * Injects position, width and height of the textarea rect\n    * @param {Object} dataBag\n    * @private\n    */\nproto.injectSizeValues = function (dataBag) {\n\n  // Explicit usage of parseFloat to remove the 'px' suffix.\n  var width = parseFloat(this.textArea.style.width);\n  var height = parseFloat(this.textArea.style.height);\n  var ox = parseFloat(this.textArea.style.left);\n  var oy = parseFloat(this.textArea.style.top);\n\n  dataBag.width = width;\n  dataBag.height = height;\n  dataBag.newPos = {\n    x: ox + width * 0.5,\n    y: oy + height * 0.5 };\n\n};\n\n/**\n    * Handler for when the camera moves\n    * @param {Object} event - Camera moves event\n    * @private\n    */\nproto.onCameraChanged = function (event) {\n  var str = this.textArea.value;\n  this.textMarkup.style = cloneStyle(this.style);\n  this.style = null; // TODO: Revisit this code because style changes are lost by doing this.\n  this.initFromMarkup(true);\n  this.textArea.value = str;\n  this.setEditFrame();\n};\n\n/**\n    * Grabs the text content of the textarea and returns\n    * an Array of lines.  Wrapped lines are returned as 2 lines.\n    */\nproto.generateLines = function () {\n\n  // First, get lines separated by line breaks:\n  var textContent = this.textArea.value;\n  var linesBreaks = textContent.split(/\\r*\\n/);\n\n  var styleMeasureStr = this.styleTextArea.clone().\n  removeAttribute(['top', 'left', 'width', 'height']).\n  setAttribute('position', 'absolute').\n  setAttribute('white-space', 'nowrap').\n  setAttribute('float', 'left').\n  setAttribute('visibility', 'hidden').\n  getStyleString();\n  this.measureDiv.setAttribute('style', styleMeasureStr);\n  this.parentDiv.appendChild(this.measureDiv);\n\n  var maxLineLength = this.textArea.clientWidth - 2 * parseFloat(this.textArea.style.padding);\n\n  // Now check whether the lines are wrapped.\n  // If so, subdivide into other lines.\n  var linesOutput = [];\n\n  for (var i = 0, len = linesBreaks.length; i < len; ++i) {\n    var line = trimRight(linesBreaks[i]);\n\n    // Add a space in an empty line so it appears in the lines output\n    line = line === '' ? ' ' : line;\n    this.splitLine(line, maxLineLength, linesOutput);\n  }\n\n  this.parentDiv.removeChild(this.measureDiv);\n  return linesOutput;\n};\n\n/**\n    * Given a String that represents one line of text that is\n    * longer than the max length a line is allowed, this method\n    * cuts text into several ones that are no longer than the max\n    * length.\n    *\n    * @param {String} text\n    * @param {Number} maxLength\n    * @param {Array} output\n    * @private\n    */\nproto.splitLine = function (text, maxLength, output) {\n\n  // End condition\n  if (text === '') {\n    return;\n  }\n\n  var remaining = '';\n  var done = false;\n\n  while (!done) {\n    this.measureDiv.innerText = text;\n    var lineLen = this.measureDiv.clientWidth - 2 * parseFloat(this.measureDiv.style.padding);\n    if (lineLen <= maxLength) {\n      output.push(text);\n      this.splitLine(trimLeft(remaining), maxLength, output);\n      done = true;\n    } else {\n      // Need to try with a shorter word!\n      var parts = this.getShorterLine(text);\n      if (parts.length === 1) {\n        // text is only one word that is way too long.\n        this.splitWord(text, remaining, maxLength, output);\n        done = true;\n      } else {\n        text = parts[0];\n        remaining = parts[1] + remaining;\n      }\n    }\n  }\n};\n\n/**\n    * Given a line of text such as \"hi there programmer\", it returns\n    * an array with 2 parts: [\"hi there\", \" programmer\"].\n    *\n    * It accounts for special cases with multi-spaces, such as for\n    * \"hi there  two-spaces\" returns [\"hi there\", \"  two-spaces\"]\n    *\n    * When there is only one word, it returns the whole word:\n    * \"JustOneWord\" returns [\"JustOneWord\"] (an array of 1 element)\n    *\n    * @param {String} line\n    * @returns {Array}\n    */\nproto.getShorterLine = function (line) {\n\n  // TODO: Account for TABs\n  // Will probably never do unless a bug is reported.\n\n  var iLastSpace = line.lastIndexOf(' ');\n  if (iLastSpace === -1) {\n    return [line]; // This is a single word\n  }\n\n  // Else\n  // Iterate back removing additional spaces (multi spaces)\n  while (line.charAt(iLastSpace - 1) === ' ') {\n    iLastSpace--;\n  }\n\n  var trailingWord = line.substr(iLastSpace); // Contains the spaces\n  var shorterLine = line.substr(0, iLastSpace);\n  return [shorterLine, trailingWord];\n};\n\n/**\n    * Given a single word, splits it into multiple lines that fits in maxWidth\n    * @param {String} word\n    * @param {String} remaining\n    * @param {Number} maxLength\n    * @param {Array} output\n    */\nproto.splitWord = function (word, remaining, maxLength, output) {\n\n  var lenSoFar = 1;\n  var fits = true;\n  while (fits) {\n\n    var part = word.substr(0, lenSoFar);\n    this.measureDiv.innerText = part;\n    var lineLen = this.measureDiv.clientWidth - 2 * parseFloat(this.measureDiv.style.padding);\n\n    if (lineLen > maxLength) {\n\n      if (lenSoFar === 1) {\n        // we can't split 1 character any longer.\n        output.push(part);\n        this.splitWord(word.substr(1), remaining, maxLength, output);\n        return;\n      }\n\n      // It was fine until one less char //\n      var okayWord = word.substr(0, lenSoFar - 1);\n      output.push(okayWord);\n      var extraWord = word.substr(lenSoFar - 1);\n      this.splitLine(extraWord + remaining, maxLength, output);\n      return;\n    }\n\n    // Try one more character\n    lenSoFar++;\n\n    // Check if we are done with all characters\n    if (lenSoFar > word.length) {\n      // Okay it fits\n      output.push(word);\n      return;\n    }\n  }\n};\n\nfunction trimRight(text) {\n  if (text.length === 0) {\n    return \"\";\n  }\n  var lastNonSpace = text.length - 1;\n  for (var i = lastNonSpace; i >= 0; --i) {\n    if (text.charAt(i) !== ' ') {\n      lastNonSpace = i;\n      break;\n    }\n  }\n  return text.substr(0, lastNonSpace + 1);\n}\n\nfunction trimLeft(text) {\n  if (text.length === 0) {\n    return \"\";\n  }\n  var firstNonSpace = 0;\n  for (var i = 0; i < text.length; ++i) {\n    if (text.charAt(i) !== ' ') {\n      firstNonSpace = i;\n      break;\n    }\n  }\n  return text.substr(firstNonSpace);\n}","\nvar content = require(\"!!../../../node_modules/css-loader/index.js!../../../node_modules/sass-loader/dist/cjs.js!./MarkupsGui.css\");\n\nif(typeof content === 'string') content = [[module.id, content, '']];\n\nvar transform;\nvar insertInto;\n\n\n\nvar options = {\"hmr\":true}\n\noptions.transform = transform\noptions.insertInto = undefined;\n\nvar update = require(\"!../../../node_modules/style-loader/lib/addStyles.js\")(content, options);\n\nif(content.locals) module.exports = content.locals;\n\nif(module.hot) {\n\tmodule.hot.accept(\"!!../../../node_modules/css-loader/index.js!../../../node_modules/sass-loader/dist/cjs.js!./MarkupsGui.css\", function() {\n\t\tvar newContent = require(\"!!../../../node_modules/css-loader/index.js!../../../node_modules/sass-loader/dist/cjs.js!./MarkupsGui.css\");\n\n\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\n\t\tvar locals = (function(a, b) {\n\t\t\tvar key, idx = 0;\n\n\t\t\tfor(key in a) {\n\t\t\t\tif(!b || a[key] !== b[key]) return false;\n\t\t\t\tidx++;\n\t\t\t}\n\n\t\t\tfor(key in b) idx--;\n\n\t\t\treturn idx === 0;\n\t\t}(content.locals, newContent.locals));\n\n\t\tif(!locals) throw new Error('Aborting CSS HMR due to changed css-modules locals.');\n\n\t\tupdate(newContent);\n\t});\n\n\tmodule.hot.dispose(function() { update(); });\n}","function _typeof(obj) {\"@babel/helpers - typeof\";if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;};}return _typeof(obj);}import { getStyleDefaultValues } from '../core/StyleUtils';\nimport * as MarkupEvents from '../core/MarkupEvents';\nimport * as MarkupTypes from '../core/MarkupTypes';\nimport { theEditModeManager } from '../core/EditModeManager';\n\nimport CSS from './MarkupsGui.css'; // IMPORTANT!!\n\nvar CORE_EXTENSION = 'Autodesk.Viewing.MarkupsCore';\n\nexport function MarkupsGui(viewer, options) {\n  Autodesk.Viewing.Extension.call(this, viewer, options);\n  this.domEvents = [];\n  this.name = 'markup';\n  this.onEditModeEnter = this.onEditModeEnter.bind(this);\n  this.onEditModeLeave = this.onEditModeLeave.bind(this);\n  this.onEditModeChange = this.onEditModeChange.bind(this);\n  this.onMarkupSelected = this.onMarkupSelected.bind(this);\n}\n\nMarkupsGui.prototype = Object.create(Autodesk.Viewing.Extension.prototype);\nMarkupsGui.prototype.constructor = MarkupsGui;\nvar proto = MarkupsGui.prototype;\nvar av = Autodesk.Viewing;\nvar avp = av.Private;\n\nproto.load = function () {var _this = this;\n\n  this.viewer.loadExtension(CORE_EXTENSION).then(function (coreExt) {\n\n    _this.core = coreExt;\n\n    // Hook into markup core events\n    _this.core.addEventListener(MarkupEvents.EVENT_EDITMODE_ENTER, _this.onEditModeEnter);\n    _this.core.addEventListener(MarkupEvents.EVENT_EDITMODE_LEAVE, _this.onEditModeLeave);\n    _this.core.addEventListener(MarkupEvents.EVENT_EDITMODE_CHANGED, _this.onEditModeChange);\n    _this.core.addEventListener(MarkupEvents.EVENT_MARKUP_SELECTED, _this.onMarkupSelected);\n  });\n\n  return true;\n};\n\nproto.unload = function () {\n\n  this.deactivate(); // not necessary, but leaves the viewer in an unusable state without it\n  this.unhookAllEvents();\n\n  this.core.removeEventListener(MarkupEvents.EVENT_EDITMODE_ENTER, this.onEditModeEnter);\n  this.core.removeEventListener(MarkupEvents.EVENT_EDITMODE_LEAVE, this.onEditModeLeave);\n  this.core.removeEventListener(MarkupEvents.EVENT_EDITMODE_CHANGED, this.onEditModeChange);\n  this.core.removeEventListener(MarkupEvents.EVENT_MARKUP_SELECTED, this.onMarkupSelected);\n\n  this.destroyToolUi();\n  this.destroyToolbarUI();\n  this.core = null;\n\n  return true;\n};\n\nproto.onToolbarCreated = function (toolbar) {\n\n  var self = this;\n  var viewer = this.viewer;\n\n  this.markupToolButton = new Autodesk.Viewing.UI.Button(\"toolbar-markupTool\");\n  this.markupToolButton.setToolTip(\"Markup\");\n  this.markupToolButton.setIcon(\"adsk-icon-markup\");\n  this.markupToolButton.onClick = function () {\n    // Since the bar will get hidden when closed, there\n    // is no need to track button state (active or not)\n    self.activate();\n  };\n\n  var modelTools = toolbar.getControl(Autodesk.Viewing.TOOLBAR.MODELTOOLSID);\n  if (modelTools) {\n    modelTools.addControl(this.markupToolButton, { index: 0 });\n  }\n};\n\nproto.destroyToolbarUI = function () {\n  if (this.markupToolButton) {\n    var toolbar = this.viewer.getToolbar();\n    if (toolbar) {\n      this.markupToolButton.removeFromParent();\n    }\n    this.markupToolButton = null;\n  }\n};\n\nproto.onEditModeEnter = function () {\n  avp.logger.log('ENTER edit mode');\n  this.showToolsUi();\n};\n\nproto.onEditModeLeave = function () {\n  avp.logger.log('LEAVE edit mode');\n  this.hideToolsUi();\n};\n\nproto.onEditModeChange = function (event) {\n  if (!this.domToolSelect || this.ignoreChangeEvent)\n  return;\n  var editMode = this.core.editMode;\n  var optionList = this.domToolSelect.options;\n  for (var i = 0, len = optionList.length; i < len; i++) {\n    var option = optionList[i];\n    if (option.value === editMode.type) {\n      this.domToolSelect.selectedIndex = i; // doesn't fire event\n      break;\n    }\n  }\n};\n\nproto.onMarkupSelected = function (event) {\n\n  var markup = event.markup;\n  var editMode = this.core.editMode;\n  this.setStylesUi(editMode, markup);\n};\n\nproto.showToolsUi = function () {\n  this.createToolsUi();\n\n  // Hide some UI\n  var canNavigate = this.core.isNavigationAllowed();\n  this.setControlVisibility('.lmv-markup-gui-enterNavMode', canNavigate, 'inline-block');\n  this.exitNavigationMode();\n  this.domContent.style.display = 'block'; // remove collapsed state\n\n  // It's okay if we call these many times in a row, no biggie.\n  this.viewer.container.appendChild(this.domRoot);\n};\n\nproto.hideToolsUi = function () {\n  if (this.domRoot && this.domRoot.parentNode) {\n    this.domRoot.parentNode.removeChild(this.domRoot);\n  }\n};\n\nproto.createToolsUi = function () {\n\n  if (this.domRoot)\n  return;\n\n  var optionIndex = 0;\n  function createEditModeOption(locLabel, editModeType) {\n    return [\n    '<option value=\"', editModeType, '\">',\n    locLabel,\n    '</option>'].\n    join('');\n  }\n\n  var html = [\n  '<div class=\"lmv-markup-gui-toolbar-content\">',\n\n  '<button class=\"lmv-markup-gui-collapse-btn\">&lt;-&gt;</button>',\n  '<button class=\"lmv-markup-editmode-done\">Exit</button>',\n  '<div class=\"lmv-markup-gui-collapse-content\">',\n  '<div class=\"lmv-markup-gui-editMode\">',\n  '<button class=\"lmv-markup-gui-enterNavMode\">Navigate</button>',\n  '<button class=\"lmv-markup-gui-undo\">&#8617;</button>',\n  '<button class=\"lmv-markup-gui-redo\">&#8618;</button>',\n  '<br>',\n  '<button class=\"lmv-markup-gui-delete\">Delete</button>',\n  '<button class=\"lmv-markup-gui-duplicate\">Duplicate</button>',\n  '<br>',\n  '<button class=\"lmv-markup-gui-cut\">Cut</button>',\n  '<button class=\"lmv-markup-gui-copy\">Copy</button>',\n  '<button class=\"lmv-markup-gui-paste\">Paste</button>',\n  '<br>',\n  '<span>Markup:</span>', // TODO: Localize\n  '<select class=\"lmv-markup-tool-select\">',\n  createEditModeOption('Arrow', MarkupTypes.MARKUP_TYPE_ARROW),\n  createEditModeOption('Rectangle', MarkupTypes.MARKUP_TYPE_RECTANGLE),\n  createEditModeOption('Circle', MarkupTypes.MARKUP_TYPE_CIRCLE),\n  createEditModeOption('Text', MarkupTypes.MARKUP_TYPE_TEXT),\n  createEditModeOption('Callout', MarkupTypes.MARKUP_TYPE_CALLOUT),\n  createEditModeOption('Cloud', MarkupTypes.MARKUP_TYPE_CLOUD),\n  createEditModeOption('PolyLine', MarkupTypes.MARKUP_TYPE_POLYLINE),\n  createEditModeOption('Polycloud', MarkupTypes.MARKUP_TYPE_POLYCLOUD),\n  createEditModeOption('Freehand', MarkupTypes.MARKUP_TYPE_FREEHAND),\n  createEditModeOption('Highlight', MarkupTypes.MARKUP_TYPE_HIGHLIGHT),\n  createEditModeOption('Dimension', MarkupTypes.MARKUP_TYPE_DIMENSION),\n  createEditModeOption('SVG Stamp', MarkupTypes.MARKUP_TYPE_STAMP),\n  '</select>',\n  '<br>',\n  '<div class=\"lmv-markup-gui-style-options\"></div>',\n  '</div>',\n  '<div class=\"lmv-markup-gui-navMode\" style=\"display:none;\">',\n  '<button class=\"lmv-markup-gui-exitNavMode\">Back to Markup</button>',\n  '</div>',\n  '</div>',\n  '</div>'].\n  join('');\n\n  var _document = this.getDocument();\n  this.domRoot = _document.createElement('div');\n  this.domRoot.className = 'lmv-markup-gui-toolbar';\n  this.domRoot.innerHTML = html;\n\n  this.domContent = this.domRoot.querySelector('.lmv-markup-gui-collapse-content');\n  this.domToolSelect = this.domRoot.querySelector('.lmv-markup-tool-select');\n  this.domStylesRoot = this.domRoot.querySelector('.lmv-markup-gui-style-options');\n\n  // General\n  this.hookEvent('click', '.lmv-markup-gui-collapse-btn', this.onToggleCollapse.bind(this));\n  this.hookEvent('click', '.lmv-markup-editmode-done', this.onEditModeDone.bind(this));\n  this.hookEvent('click', '.lmv-markup-gui-enterNavMode', this.enterNavigationMode.bind(this));\n  this.hookEvent('click', '.lmv-markup-gui-exitNavMode', this.exitNavigationMode.bind(this));\n  this.hookEvent('click', '.lmv-markup-gui-undo', this.onUndoClick.bind(this));\n  this.hookEvent('click', '.lmv-markup-gui-redo', this.onRedoClick.bind(this));\n  this.hookEvent('click', '.lmv-markup-gui-delete', this.onDeleteClick.bind(this));\n  this.hookEvent('click', '.lmv-markup-gui-cut', this.onCutClick.bind(this));\n  this.hookEvent('click', '.lmv-markup-gui-copy', this.onCopyClick.bind(this));\n  this.hookEvent('click', '.lmv-markup-gui-paste', this.onPasteClick.bind(this));\n  this.hookEvent('click', '.lmv-markup-gui-duplicate', this.onDuplicateClick.bind(this));\n  // Tools\n  this.hookEvent('change', '.lmv-markup-tool-select', this.onSelectEditMode.bind(this));\n  this.hookEvent('change', '.lmv-markup-gui-style-select', this.onStyleChange.bind(this));\n  // Text input fields for tools\n  this.hookEvent('input', '.lmv-markup-gui-style-textarea', this.onStyleChange.bind(this));\n  this.hookEvent('propertychange', '.lmv-markup-gui-style-textarea', this.onStyleChange.bind(this));\n\n  this.setStylesUi(this.core.editMode);\n};\n\nproto.destroyToolUi = function () {\n  if (this.domRoot) {\n    this.hideToolsUi();\n    this.domRoot = null;\n  }\n};\n\nproto.getEditMode = function (editModeType) {\n  var EditModeClass = theEditModeManager.getClass(editModeType);\n  if (!EditModeClass)\n  return null;\n\n  var editMode = new EditModeClass(this.core);\n  return editMode;\n};\n\nproto.onToggleCollapse = function () {\n  var curr = this.domContent.style.display;\n  if (curr === 'none')\n  this.domContent.style.display = 'block';else\n\n  this.domContent.style.display = 'none';\n};\n\nproto.onEditModeDone = function () {\n  this.deactivate();\n};\n\nproto.enterNavigationMode = function () {\n  this.core.allowNavigation(true);\n  this.setControlVisibility('.lmv-markup-gui-editMode', false);\n  this.setControlVisibility('.lmv-markup-gui-navMode', true);\n};\nproto.exitNavigationMode = function () {\n  this.core.allowNavigation(false);\n  this.setControlVisibility('.lmv-markup-gui-editMode', true);\n  this.setControlVisibility('.lmv-markup-gui-navMode', false);\n};\n\nproto.onUndoClick = function () {\n  this.core.undo();\n};\nproto.onRedoClick = function () {\n  this.core.redo();\n};\nproto.onDeleteClick = function () {\n  var markup = this.core.getSelection();\n  if (markup) {\n    this.core.deleteMarkup(markup);\n  }\n};\nproto.onCutClick = function () {\n  this.core.cut();\n};\nproto.onCopyClick = function () {\n  this.core.copy();\n};\nproto.onPasteClick = function () {\n  this.core.paste();\n};\nproto.onDuplicateClick = function () {\n  // only when there's a selection\n  var markup = this.core.getSelection();\n  if (markup) {\n    this.core.copy();\n    this.core.paste();\n  }\n};\n\nproto.onSelectEditMode = function (event) {\n  var editModeType = event.target.value;\n  var editMode = this.getEditMode(editModeType);\n  if (!editMode) {\n    avp.logger.error('Markup editMode not found for type: ' + editModeType);\n    return;\n  }\n\n  if (editMode.cancelEditModeChange) {\n    avp.logger.warn('There was a problem selecting current editMode');\n    return;\n  }\n\n  this.ignoreChangeEvent = true;\n  this.core.changeEditMode(editMode);\n  this.ignoreChangeEvent = false;\n  this.setStylesUi(editMode);\n  this.domToolSelect.blur(); // remove focus from UI\n};\n\nproto.onStyleChange = function (event) {\n  var select = event.target;\n  var styleKey = select.getAttribute('style-key');\n  var valueType = select.getAttribute('value-type');\n\n  var markup = this.core.getSelection();\n  var style = markup ? markup.getStyle() : this.core.getStyle();\n\n  // if it's a string input, just take the raw value\n  if (valueType === 'string') {\n    style[styleKey] = select.value;\n  } else {\n    var option = select.options[select.selectedIndex];\n    style[styleKey] = getTypedValue(option.value, valueType);\n    select.blur(); // remove focus from UI\n  }\n  this.core.setStyle(style);\n\n  function getTypedValue(val, type) {\n    if (type === 'number')\n    return Number(val);\n    if (type === 'boolean')\n    return val === 'true';\n    return val;\n  }\n};\n\nproto.setStylesUi = function (editMode, markup) {\n\n  var style = markup ? markup.style : editMode.style;\n  var defaults = getStyleDefaultValues(style, this.core);\n\n  this.domStylesRoot.innerHTML = ''; // flush UI\n  for (var key in defaults) {\n    // Quite inefiient because we are re-creating DOM constantly\n    // Consider optimize if it becomes a problem\n    var domElem = this.getUiForStyleKey(key, defaults[key], style[key]);\n    this.domStylesRoot.appendChild(domElem);\n  }\n};\n\nproto.getUiForStyleKey = function (key, defaults, current) {\n\n  var selectionIndex = defaults.default;\n  var options = [];\n  var values = defaults.values;\n  for (var i = 0, len = values.length; i < len; ++i) {\n    var optLine = [\n    '<option value=\"', values[i].value, '\">',\n    values[i].name,\n    '</option>'].\n    join('');\n    options.push(optLine);\n\n    if (this.valueEquals(values[i].value, current)) {\n      selectionIndex = i;\n    }\n  }\n\n  var valueType = _typeof(values[0].value);\n\n  // TODO: Build specialized controls for each style-attribute\n  var _document = this.getDocument();\n  var domElem = _document.createElement('div');\n  var html = [];\n  var isText = key.includes('text');\n\n  if (isText) {\n    html = [\n    '<span>', key, '</span>',\n    '<br>',\n    '<textarea class=\"lmv-markup-gui-style-textarea\" style-key=\"', key, '\" value-type=\"', valueType, '\">',\n    current || '',\n    '</textarea>'].\n    join('');\n  } else {\n    html = [\n    '<span>', key, '</span>',\n    '<select class=\"lmv-markup-gui-style-select\" style-key=\"', key, '\" value-type=\"', valueType, '\">',\n    options.join(''),\n    '</select>'].\n    join('');\n  }\n\n  domElem.innerHTML = html;\n\n  if (!isText) {\n    // select index\n    var domSelect = domElem.querySelector('select');\n    domSelect.selectedIndex = selectionIndex;\n  }\n\n  return domElem;\n};\nproto.valueEquals = function (value1, value2) {\n\n  return value1 === value2;\n};\n\nproto.setControlVisibility = function (selector, isVisible, visibleValue) {\n  var elem = this.domRoot.querySelector(selector);\n  if (!visibleValue)\n  visibleValue = 'block';\n  elem.style.display = isVisible ? visibleValue : 'none';\n};\n\nproto.hookEvent = function (eventStr, selector, callbackFn) {\n  var handler = function (event) {\n    if (this.matchesSelector(event.target, selector)) {\n      callbackFn(event);\n    }\n  }.bind(this);\n  this.domRoot.addEventListener(eventStr, handler);\n  this.domEvents.push({ str: eventStr, handler: handler });\n};\n\nproto.unhookAllEvents = function () {\n  var domRoot = this.domRoot;\n  this.domEvents.forEach(function (event) {\n    domRoot.removeEventListener(event.str, event.handler);\n  });\n  this.domEvents = [];\n};\n\nproto.matchesSelector = function (domElem, selector) {\n  if (domElem.matches) return domElem.matches(selector); //Un-prefixed\n  if (domElem.msMatchesSelector) return domElem.msMatchesSelector(selector); //IE\n  if (domElem.mozMatchesSelector) return domElem.mozMatchesSelector(selector); //Firefox (Gecko)\n  if (domElem.webkitMatchesSelector) return domElem.webkitMatchesSelector(selector); // Opera, Safari, Chrome\n  return false;\n};\n\nproto.getStyleOptions = function (editMode) {\n  var style = editMode.getStyle();\n  return getStyleDefaultValues(style, this.core);\n};\n\nproto.activate = function () {\n  if (!this.activeStatus) {\n    this.core.enterEditMode();\n    this.activeStatus = true;\n  }\n  return true;\n};\n\nproto.deactivate = function () {\n  if (this.activeStatus) {\n    this.core.hide();\n    this.activeStatus = false;\n  }\n  return true;\n};\n\n\nAutodesk.Viewing.theExtensionManager.registerExtension('Autodesk.Viewing.MarkupsGui', MarkupsGui);","exports = module.exports = require(\"../../../node_modules/css-loader/lib/css-base.js\")(false);\n// imports\n\n\n// module\nexports.push([module.id, \".adsk-viewing-viewer .autodesk-markups-extension-core-make-me-bigger:after {\\n  content: \\\"\\\";\\n  position: absolute;\\n  top: -15px;\\n  bottom: -15px;\\n  left: -15px;\\n  right: -15px; }\\n\\n.adsk-viewing-viewer .autodesk-markups-extension-core-make-me-bigger.rotation-bridge:after {\\n  top: 0;\\n  bottom: 0px; }\\n\\n.adsk-viewing-viewer .selector-box {\\n  position: absolute;\\n  border: 1px dashed #0696D7;\\n  background: rgba(6, 150, 215, 0.05);\\n  z-index: 1;\\n  cursor: move;\\n  box-sizing: border-box; }\\n\\n.adsk-viewing-viewer .selector-drag-point,\\n.adsk-viewing-viewer .selector-rotate-point {\\n  position: absolute;\\n  height: 8px;\\n  width: 8px;\\n  border-radius: 8px;\\n  /*HANDLE_SIZE*/\\n  background: #FFFFFF;\\n  /*HANDLE_BACKGROUND_COLOR*/\\n  border-color: rgba(107, 120, 127, 0.7);\\n  /* HANDLE_BORDER_COLOR; */\\n  border-width: 1px;\\n  /* BORDER_WIDTH */\\n  border-style: solid; }\\n\\n.adsk-viewing-viewer .selector-rotate-point {\\n  top: calc(100% + 22px);\\n  /* 30 - 8 = 22 */\\n  left: calc(50% + 1px);\\n  transform: translate3d(-50%, 0px, 0px); }\\n\\n.adsk-viewing-viewer .selector-drag-point.selected,\\n.adsk-viewing-viewer .selector-rotate-point.selected:not(.rotation-bridge) {\\n  background: #0696D7;\\n  border-color: #0696D7; }\\n\\n.adsk-viewing-viewer .rotation-bridge {\\n  position: absolute;\\n  background-color: rgba(0, 0, 0, 0);\\n  height: 30px;\\n  width: 0px;\\n  top: 100%;\\n  left: calc(50% + 1px);\\n  border: unset;\\n  border-left: 1px dashed #0696D7; }\\n\\n/*var placementOffset = -6;*/\\n.adsk-viewing-viewer .selector-drag-point.sdp-handle-n {\\n  top: -6px;\\n  left: calc(50% - 4px);\\n  position: relative; }\\n\\n.adsk-viewing-viewer .selector-drag-point.sdp-handle-s {\\n  top: calc(100% - 14px);\\n  left: calc(50% - 4px);\\n  position: relative; }\\n\\n.adsk-viewing-viewer .selector-drag-point.sdp-handle-w {\\n  left: -6px;\\n  top: 50%;\\n  transform: translate3d(0, -50%, 0); }\\n\\n.adsk-viewing-viewer .selector-drag-point.sdp-handle-e {\\n  right: -6px;\\n  top: 50%;\\n  transform: translate3d(0, -50%, 0); }\\n\\n.adsk-viewing-viewer .selector-drag-point.sdp-handle-nw {\\n  top: -6px;\\n  left: -6px; }\\n\\n.adsk-viewing-viewer .selector-drag-point.sdp-handle-ne {\\n  top: -6px;\\n  right: -6px; }\\n\\n.adsk-viewing-viewer .selector-drag-point.sdp-handle-sw {\\n  bottom: -6px;\\n  left: -6px; }\\n\\n.adsk-viewing-viewer .selector-drag-point.sdp-handle-se {\\n  bottom: -6px;\\n  right: -6px; }\\n\", \"\"]);\n\n// exports\n","exports = module.exports = require(\"../../../node_modules/css-loader/lib/css-base.js\")(false);\n// imports\n\n\n// module\nexports.push([module.id, \".adsk-icon-markup:before {\\n  content: \\\"a\\\"; }\\n\\n.lmv-markup-gui-toolbar {\\n  position: absolute;\\n  top: 0;\\n  margin: 5px 5px;\\n  color: #000000; }\\n\\n.lmv-markup-gui-toolbar-content > * {\\n  margin: 0 2px; }\\n\\n.lmv-markup-gui-style-options {\\n  display: inline-block; }\\n\", \"\"]);\n\n// exports\n","/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n// css base code, injected by the css-loader\nmodule.exports = function(useSourceMap) {\n\tvar list = [];\n\n\t// return the list of modules as css string\n\tlist.toString = function toString() {\n\t\treturn this.map(function (item) {\n\t\t\tvar content = cssWithMappingToString(item, useSourceMap);\n\t\t\tif(item[2]) {\n\t\t\t\treturn \"@media \" + item[2] + \"{\" + content + \"}\";\n\t\t\t} else {\n\t\t\t\treturn content;\n\t\t\t}\n\t\t}).join(\"\");\n\t};\n\n\t// import a list of modules into the list\n\tlist.i = function(modules, mediaQuery) {\n\t\tif(typeof modules === \"string\")\n\t\t\tmodules = [[null, modules, \"\"]];\n\t\tvar alreadyImportedModules = {};\n\t\tfor(var i = 0; i < this.length; i++) {\n\t\t\tvar id = this[i][0];\n\t\t\tif(typeof id === \"number\")\n\t\t\t\talreadyImportedModules[id] = true;\n\t\t}\n\t\tfor(i = 0; i < modules.length; i++) {\n\t\t\tvar item = modules[i];\n\t\t\t// skip already imported module\n\t\t\t// this implementation is not 100% perfect for weird media query combinations\n\t\t\t//  when a module is imported multiple times with different media queries.\n\t\t\t//  I hope this will never occur (Hey this way we have smaller bundles)\n\t\t\tif(typeof item[0] !== \"number\" || !alreadyImportedModules[item[0]]) {\n\t\t\t\tif(mediaQuery && !item[2]) {\n\t\t\t\t\titem[2] = mediaQuery;\n\t\t\t\t} else if(mediaQuery) {\n\t\t\t\t\titem[2] = \"(\" + item[2] + \") and (\" + mediaQuery + \")\";\n\t\t\t\t}\n\t\t\t\tlist.push(item);\n\t\t\t}\n\t\t}\n\t};\n\treturn list;\n};\n\nfunction cssWithMappingToString(item, useSourceMap) {\n\tvar content = item[1] || '';\n\tvar cssMapping = item[3];\n\tif (!cssMapping) {\n\t\treturn content;\n\t}\n\n\tif (useSourceMap && typeof btoa === 'function') {\n\t\tvar sourceMapping = toComment(cssMapping);\n\t\tvar sourceURLs = cssMapping.sources.map(function (source) {\n\t\t\treturn '/*# sourceURL=' + cssMapping.sourceRoot + source + ' */'\n\t\t});\n\n\t\treturn [content].concat(sourceURLs).concat([sourceMapping]).join('\\n');\n\t}\n\n\treturn [content].join('\\n');\n}\n\n// Adapted from convert-source-map (MIT)\nfunction toComment(sourceMap) {\n\t// eslint-disable-next-line no-undef\n\tvar base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));\n\tvar data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;\n\n\treturn '/*# ' + data + ' */';\n}\n","/**\r\n * A collection of shims that provide minimal functionality of the ES6 collections.\r\n *\r\n * These implementations are not meant to be used outside of the ResizeObserver\r\n * modules as they cover only a limited range of use cases.\r\n */\r\n/* eslint-disable require-jsdoc, valid-jsdoc */\r\nvar MapShim = (function () {\r\n    if (typeof Map !== 'undefined') {\r\n        return Map;\r\n    }\r\n    /**\r\n     * Returns index in provided array that matches the specified key.\r\n     *\r\n     * @param {Array<Array>} arr\r\n     * @param {*} key\r\n     * @returns {number}\r\n     */\r\n    function getIndex(arr, key) {\r\n        var result = -1;\r\n        arr.some(function (entry, index) {\r\n            if (entry[0] === key) {\r\n                result = index;\r\n                return true;\r\n            }\r\n            return false;\r\n        });\r\n        return result;\r\n    }\r\n    return /** @class */ (function () {\r\n        function class_1() {\r\n            this.__entries__ = [];\r\n        }\r\n        Object.defineProperty(class_1.prototype, \"size\", {\r\n            /**\r\n             * @returns {boolean}\r\n             */\r\n            get: function () {\r\n                return this.__entries__.length;\r\n            },\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n        /**\r\n         * @param {*} key\r\n         * @returns {*}\r\n         */\r\n        class_1.prototype.get = function (key) {\r\n            var index = getIndex(this.__entries__, key);\r\n            var entry = this.__entries__[index];\r\n            return entry && entry[1];\r\n        };\r\n        /**\r\n         * @param {*} key\r\n         * @param {*} value\r\n         * @returns {void}\r\n         */\r\n        class_1.prototype.set = function (key, value) {\r\n            var index = getIndex(this.__entries__, key);\r\n            if (~index) {\r\n                this.__entries__[index][1] = value;\r\n            }\r\n            else {\r\n                this.__entries__.push([key, value]);\r\n            }\r\n        };\r\n        /**\r\n         * @param {*} key\r\n         * @returns {void}\r\n         */\r\n        class_1.prototype.delete = function (key) {\r\n            var entries = this.__entries__;\r\n            var index = getIndex(entries, key);\r\n            if (~index) {\r\n                entries.splice(index, 1);\r\n            }\r\n        };\r\n        /**\r\n         * @param {*} key\r\n         * @returns {void}\r\n         */\r\n        class_1.prototype.has = function (key) {\r\n            return !!~getIndex(this.__entries__, key);\r\n        };\r\n        /**\r\n         * @returns {void}\r\n         */\r\n        class_1.prototype.clear = function () {\r\n            this.__entries__.splice(0);\r\n        };\r\n        /**\r\n         * @param {Function} callback\r\n         * @param {*} [ctx=null]\r\n         * @returns {void}\r\n         */\r\n        class_1.prototype.forEach = function (callback, ctx) {\r\n            if (ctx === void 0) { ctx = null; }\r\n            for (var _i = 0, _a = this.__entries__; _i < _a.length; _i++) {\r\n                var entry = _a[_i];\r\n                callback.call(ctx, entry[1], entry[0]);\r\n            }\r\n        };\r\n        return class_1;\r\n    }());\r\n})();\n\n/**\r\n * Detects whether window and document objects are available in current environment.\r\n */\r\nvar isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined' && window.document === document;\n\n// Returns global object of a current environment.\r\nvar global$1 = (function () {\r\n    if (typeof global !== 'undefined' && global.Math === Math) {\r\n        return global;\r\n    }\r\n    if (typeof self !== 'undefined' && self.Math === Math) {\r\n        return self;\r\n    }\r\n    if (typeof window !== 'undefined' && window.Math === Math) {\r\n        return window;\r\n    }\r\n    // eslint-disable-next-line no-new-func\r\n    return Function('return this')();\r\n})();\n\n/**\r\n * A shim for the requestAnimationFrame which falls back to the setTimeout if\r\n * first one is not supported.\r\n *\r\n * @returns {number} Requests' identifier.\r\n */\r\nvar requestAnimationFrame$1 = (function () {\r\n    if (typeof requestAnimationFrame === 'function') {\r\n        // It's required to use a bounded function because IE sometimes throws\r\n        // an \"Invalid calling object\" error if rAF is invoked without the global\r\n        // object on the left hand side.\r\n        return requestAnimationFrame.bind(global$1);\r\n    }\r\n    return function (callback) { return setTimeout(function () { return callback(Date.now()); }, 1000 / 60); };\r\n})();\n\n// Defines minimum timeout before adding a trailing call.\r\nvar trailingTimeout = 2;\r\n/**\r\n * Creates a wrapper function which ensures that provided callback will be\r\n * invoked only once during the specified delay period.\r\n *\r\n * @param {Function} callback - Function to be invoked after the delay period.\r\n * @param {number} delay - Delay after which to invoke callback.\r\n * @returns {Function}\r\n */\r\nfunction throttle (callback, delay) {\r\n    var leadingCall = false, trailingCall = false, lastCallTime = 0;\r\n    /**\r\n     * Invokes the original callback function and schedules new invocation if\r\n     * the \"proxy\" was called during current request.\r\n     *\r\n     * @returns {void}\r\n     */\r\n    function resolvePending() {\r\n        if (leadingCall) {\r\n            leadingCall = false;\r\n            callback();\r\n        }\r\n        if (trailingCall) {\r\n            proxy();\r\n        }\r\n    }\r\n    /**\r\n     * Callback invoked after the specified delay. It will further postpone\r\n     * invocation of the original function delegating it to the\r\n     * requestAnimationFrame.\r\n     *\r\n     * @returns {void}\r\n     */\r\n    function timeoutCallback() {\r\n        requestAnimationFrame$1(resolvePending);\r\n    }\r\n    /**\r\n     * Schedules invocation of the original function.\r\n     *\r\n     * @returns {void}\r\n     */\r\n    function proxy() {\r\n        var timeStamp = Date.now();\r\n        if (leadingCall) {\r\n            // Reject immediately following calls.\r\n            if (timeStamp - lastCallTime < trailingTimeout) {\r\n                return;\r\n            }\r\n            // Schedule new call to be in invoked when the pending one is resolved.\r\n            // This is important for \"transitions\" which never actually start\r\n            // immediately so there is a chance that we might miss one if change\r\n            // happens amids the pending invocation.\r\n            trailingCall = true;\r\n        }\r\n        else {\r\n            leadingCall = true;\r\n            trailingCall = false;\r\n            setTimeout(timeoutCallback, delay);\r\n        }\r\n        lastCallTime = timeStamp;\r\n    }\r\n    return proxy;\r\n}\n\n// Minimum delay before invoking the update of observers.\r\nvar REFRESH_DELAY = 20;\r\n// A list of substrings of CSS properties used to find transition events that\r\n// might affect dimensions of observed elements.\r\nvar transitionKeys = ['top', 'right', 'bottom', 'left', 'width', 'height', 'size', 'weight'];\r\n// Check if MutationObserver is available.\r\nvar mutationObserverSupported = typeof MutationObserver !== 'undefined';\r\n/**\r\n * Singleton controller class which handles updates of ResizeObserver instances.\r\n */\r\nvar ResizeObserverController = /** @class */ (function () {\r\n    /**\r\n     * Creates a new instance of ResizeObserverController.\r\n     *\r\n     * @private\r\n     */\r\n    function ResizeObserverController() {\r\n        /**\r\n         * Indicates whether DOM listeners have been added.\r\n         *\r\n         * @private {boolean}\r\n         */\r\n        this.connected_ = false;\r\n        /**\r\n         * Tells that controller has subscribed for Mutation Events.\r\n         *\r\n         * @private {boolean}\r\n         */\r\n        this.mutationEventsAdded_ = false;\r\n        /**\r\n         * Keeps reference to the instance of MutationObserver.\r\n         *\r\n         * @private {MutationObserver}\r\n         */\r\n        this.mutationsObserver_ = null;\r\n        /**\r\n         * A list of connected observers.\r\n         *\r\n         * @private {Array<ResizeObserverSPI>}\r\n         */\r\n        this.observers_ = [];\r\n        this.onTransitionEnd_ = this.onTransitionEnd_.bind(this);\r\n        this.refresh = throttle(this.refresh.bind(this), REFRESH_DELAY);\r\n    }\r\n    /**\r\n     * Adds observer to observers list.\r\n     *\r\n     * @param {ResizeObserverSPI} observer - Observer to be added.\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverController.prototype.addObserver = function (observer) {\r\n        if (!~this.observers_.indexOf(observer)) {\r\n            this.observers_.push(observer);\r\n        }\r\n        // Add listeners if they haven't been added yet.\r\n        if (!this.connected_) {\r\n            this.connect_();\r\n        }\r\n    };\r\n    /**\r\n     * Removes observer from observers list.\r\n     *\r\n     * @param {ResizeObserverSPI} observer - Observer to be removed.\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverController.prototype.removeObserver = function (observer) {\r\n        var observers = this.observers_;\r\n        var index = observers.indexOf(observer);\r\n        // Remove observer if it's present in registry.\r\n        if (~index) {\r\n            observers.splice(index, 1);\r\n        }\r\n        // Remove listeners if controller has no connected observers.\r\n        if (!observers.length && this.connected_) {\r\n            this.disconnect_();\r\n        }\r\n    };\r\n    /**\r\n     * Invokes the update of observers. It will continue running updates insofar\r\n     * it detects changes.\r\n     *\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverController.prototype.refresh = function () {\r\n        var changesDetected = this.updateObservers_();\r\n        // Continue running updates if changes have been detected as there might\r\n        // be future ones caused by CSS transitions.\r\n        if (changesDetected) {\r\n            this.refresh();\r\n        }\r\n    };\r\n    /**\r\n     * Updates every observer from observers list and notifies them of queued\r\n     * entries.\r\n     *\r\n     * @private\r\n     * @returns {boolean} Returns \"true\" if any observer has detected changes in\r\n     *      dimensions of it's elements.\r\n     */\r\n    ResizeObserverController.prototype.updateObservers_ = function () {\r\n        // Collect observers that have active observations.\r\n        var activeObservers = this.observers_.filter(function (observer) {\r\n            return observer.gatherActive(), observer.hasActive();\r\n        });\r\n        // Deliver notifications in a separate cycle in order to avoid any\r\n        // collisions between observers, e.g. when multiple instances of\r\n        // ResizeObserver are tracking the same element and the callback of one\r\n        // of them changes content dimensions of the observed target. Sometimes\r\n        // this may result in notifications being blocked for the rest of observers.\r\n        activeObservers.forEach(function (observer) { return observer.broadcastActive(); });\r\n        return activeObservers.length > 0;\r\n    };\r\n    /**\r\n     * Initializes DOM listeners.\r\n     *\r\n     * @private\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverController.prototype.connect_ = function () {\r\n        // Do nothing if running in a non-browser environment or if listeners\r\n        // have been already added.\r\n        if (!isBrowser || this.connected_) {\r\n            return;\r\n        }\r\n        // Subscription to the \"Transitionend\" event is used as a workaround for\r\n        // delayed transitions. This way it's possible to capture at least the\r\n        // final state of an element.\r\n        document.addEventListener('transitionend', this.onTransitionEnd_);\r\n        window.addEventListener('resize', this.refresh);\r\n        if (mutationObserverSupported) {\r\n            this.mutationsObserver_ = new MutationObserver(this.refresh);\r\n            this.mutationsObserver_.observe(document, {\r\n                attributes: true,\r\n                childList: true,\r\n                characterData: true,\r\n                subtree: true\r\n            });\r\n        }\r\n        else {\r\n            document.addEventListener('DOMSubtreeModified', this.refresh);\r\n            this.mutationEventsAdded_ = true;\r\n        }\r\n        this.connected_ = true;\r\n    };\r\n    /**\r\n     * Removes DOM listeners.\r\n     *\r\n     * @private\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverController.prototype.disconnect_ = function () {\r\n        // Do nothing if running in a non-browser environment or if listeners\r\n        // have been already removed.\r\n        if (!isBrowser || !this.connected_) {\r\n            return;\r\n        }\r\n        document.removeEventListener('transitionend', this.onTransitionEnd_);\r\n        window.removeEventListener('resize', this.refresh);\r\n        if (this.mutationsObserver_) {\r\n            this.mutationsObserver_.disconnect();\r\n        }\r\n        if (this.mutationEventsAdded_) {\r\n            document.removeEventListener('DOMSubtreeModified', this.refresh);\r\n        }\r\n        this.mutationsObserver_ = null;\r\n        this.mutationEventsAdded_ = false;\r\n        this.connected_ = false;\r\n    };\r\n    /**\r\n     * \"Transitionend\" event handler.\r\n     *\r\n     * @private\r\n     * @param {TransitionEvent} event\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverController.prototype.onTransitionEnd_ = function (_a) {\r\n        var _b = _a.propertyName, propertyName = _b === void 0 ? '' : _b;\r\n        // Detect whether transition may affect dimensions of an element.\r\n        var isReflowProperty = transitionKeys.some(function (key) {\r\n            return !!~propertyName.indexOf(key);\r\n        });\r\n        if (isReflowProperty) {\r\n            this.refresh();\r\n        }\r\n    };\r\n    /**\r\n     * Returns instance of the ResizeObserverController.\r\n     *\r\n     * @returns {ResizeObserverController}\r\n     */\r\n    ResizeObserverController.getInstance = function () {\r\n        if (!this.instance_) {\r\n            this.instance_ = new ResizeObserverController();\r\n        }\r\n        return this.instance_;\r\n    };\r\n    /**\r\n     * Holds reference to the controller's instance.\r\n     *\r\n     * @private {ResizeObserverController}\r\n     */\r\n    ResizeObserverController.instance_ = null;\r\n    return ResizeObserverController;\r\n}());\n\n/**\r\n * Defines non-writable/enumerable properties of the provided target object.\r\n *\r\n * @param {Object} target - Object for which to define properties.\r\n * @param {Object} props - Properties to be defined.\r\n * @returns {Object} Target object.\r\n */\r\nvar defineConfigurable = (function (target, props) {\r\n    for (var _i = 0, _a = Object.keys(props); _i < _a.length; _i++) {\r\n        var key = _a[_i];\r\n        Object.defineProperty(target, key, {\r\n            value: props[key],\r\n            enumerable: false,\r\n            writable: false,\r\n            configurable: true\r\n        });\r\n    }\r\n    return target;\r\n});\n\n/**\r\n * Returns the global object associated with provided element.\r\n *\r\n * @param {Object} target\r\n * @returns {Object}\r\n */\r\nvar getWindowOf = (function (target) {\r\n    // Assume that the element is an instance of Node, which means that it\r\n    // has the \"ownerDocument\" property from which we can retrieve a\r\n    // corresponding global object.\r\n    var ownerGlobal = target && target.ownerDocument && target.ownerDocument.defaultView;\r\n    // Return the local global object if it's not possible extract one from\r\n    // provided element.\r\n    return ownerGlobal || global$1;\r\n});\n\n// Placeholder of an empty content rectangle.\r\nvar emptyRect = createRectInit(0, 0, 0, 0);\r\n/**\r\n * Converts provided string to a number.\r\n *\r\n * @param {number|string} value\r\n * @returns {number}\r\n */\r\nfunction toFloat(value) {\r\n    return parseFloat(value) || 0;\r\n}\r\n/**\r\n * Extracts borders size from provided styles.\r\n *\r\n * @param {CSSStyleDeclaration} styles\r\n * @param {...string} positions - Borders positions (top, right, ...)\r\n * @returns {number}\r\n */\r\nfunction getBordersSize(styles) {\r\n    var positions = [];\r\n    for (var _i = 1; _i < arguments.length; _i++) {\r\n        positions[_i - 1] = arguments[_i];\r\n    }\r\n    return positions.reduce(function (size, position) {\r\n        var value = styles['border-' + position + '-width'];\r\n        return size + toFloat(value);\r\n    }, 0);\r\n}\r\n/**\r\n * Extracts paddings sizes from provided styles.\r\n *\r\n * @param {CSSStyleDeclaration} styles\r\n * @returns {Object} Paddings box.\r\n */\r\nfunction getPaddings(styles) {\r\n    var positions = ['top', 'right', 'bottom', 'left'];\r\n    var paddings = {};\r\n    for (var _i = 0, positions_1 = positions; _i < positions_1.length; _i++) {\r\n        var position = positions_1[_i];\r\n        var value = styles['padding-' + position];\r\n        paddings[position] = toFloat(value);\r\n    }\r\n    return paddings;\r\n}\r\n/**\r\n * Calculates content rectangle of provided SVG element.\r\n *\r\n * @param {SVGGraphicsElement} target - Element content rectangle of which needs\r\n *      to be calculated.\r\n * @returns {DOMRectInit}\r\n */\r\nfunction getSVGContentRect(target) {\r\n    var bbox = target.getBBox();\r\n    return createRectInit(0, 0, bbox.width, bbox.height);\r\n}\r\n/**\r\n * Calculates content rectangle of provided HTMLElement.\r\n *\r\n * @param {HTMLElement} target - Element for which to calculate the content rectangle.\r\n * @returns {DOMRectInit}\r\n */\r\nfunction getHTMLElementContentRect(target) {\r\n    // Client width & height properties can't be\r\n    // used exclusively as they provide rounded values.\r\n    var clientWidth = target.clientWidth, clientHeight = target.clientHeight;\r\n    // By this condition we can catch all non-replaced inline, hidden and\r\n    // detached elements. Though elements with width & height properties less\r\n    // than 0.5 will be discarded as well.\r\n    //\r\n    // Without it we would need to implement separate methods for each of\r\n    // those cases and it's not possible to perform a precise and performance\r\n    // effective test for hidden elements. E.g. even jQuery's ':visible' filter\r\n    // gives wrong results for elements with width & height less than 0.5.\r\n    if (!clientWidth && !clientHeight) {\r\n        return emptyRect;\r\n    }\r\n    var styles = getWindowOf(target).getComputedStyle(target);\r\n    var paddings = getPaddings(styles);\r\n    var horizPad = paddings.left + paddings.right;\r\n    var vertPad = paddings.top + paddings.bottom;\r\n    // Computed styles of width & height are being used because they are the\r\n    // only dimensions available to JS that contain non-rounded values. It could\r\n    // be possible to utilize the getBoundingClientRect if only it's data wasn't\r\n    // affected by CSS transformations let alone paddings, borders and scroll bars.\r\n    var width = toFloat(styles.width), height = toFloat(styles.height);\r\n    // Width & height include paddings and borders when the 'border-box' box\r\n    // model is applied (except for IE).\r\n    if (styles.boxSizing === 'border-box') {\r\n        // Following conditions are required to handle Internet Explorer which\r\n        // doesn't include paddings and borders to computed CSS dimensions.\r\n        //\r\n        // We can say that if CSS dimensions + paddings are equal to the \"client\"\r\n        // properties then it's either IE, and thus we don't need to subtract\r\n        // anything, or an element merely doesn't have paddings/borders styles.\r\n        if (Math.round(width + horizPad) !== clientWidth) {\r\n            width -= getBordersSize(styles, 'left', 'right') + horizPad;\r\n        }\r\n        if (Math.round(height + vertPad) !== clientHeight) {\r\n            height -= getBordersSize(styles, 'top', 'bottom') + vertPad;\r\n        }\r\n    }\r\n    // Following steps can't be applied to the document's root element as its\r\n    // client[Width/Height] properties represent viewport area of the window.\r\n    // Besides, it's as well not necessary as the <html> itself neither has\r\n    // rendered scroll bars nor it can be clipped.\r\n    if (!isDocumentElement(target)) {\r\n        // In some browsers (only in Firefox, actually) CSS width & height\r\n        // include scroll bars size which can be removed at this step as scroll\r\n        // bars are the only difference between rounded dimensions + paddings\r\n        // and \"client\" properties, though that is not always true in Chrome.\r\n        var vertScrollbar = Math.round(width + horizPad) - clientWidth;\r\n        var horizScrollbar = Math.round(height + vertPad) - clientHeight;\r\n        // Chrome has a rather weird rounding of \"client\" properties.\r\n        // E.g. for an element with content width of 314.2px it sometimes gives\r\n        // the client width of 315px and for the width of 314.7px it may give\r\n        // 314px. And it doesn't happen all the time. So just ignore this delta\r\n        // as a non-relevant.\r\n        if (Math.abs(vertScrollbar) !== 1) {\r\n            width -= vertScrollbar;\r\n        }\r\n        if (Math.abs(horizScrollbar) !== 1) {\r\n            height -= horizScrollbar;\r\n        }\r\n    }\r\n    return createRectInit(paddings.left, paddings.top, width, height);\r\n}\r\n/**\r\n * Checks whether provided element is an instance of the SVGGraphicsElement.\r\n *\r\n * @param {Element} target - Element to be checked.\r\n * @returns {boolean}\r\n */\r\nvar isSVGGraphicsElement = (function () {\r\n    // Some browsers, namely IE and Edge, don't have the SVGGraphicsElement\r\n    // interface.\r\n    if (typeof SVGGraphicsElement !== 'undefined') {\r\n        return function (target) { return target instanceof getWindowOf(target).SVGGraphicsElement; };\r\n    }\r\n    // If it's so, then check that element is at least an instance of the\r\n    // SVGElement and that it has the \"getBBox\" method.\r\n    // eslint-disable-next-line no-extra-parens\r\n    return function (target) { return (target instanceof getWindowOf(target).SVGElement &&\r\n        typeof target.getBBox === 'function'); };\r\n})();\r\n/**\r\n * Checks whether provided element is a document element (<html>).\r\n *\r\n * @param {Element} target - Element to be checked.\r\n * @returns {boolean}\r\n */\r\nfunction isDocumentElement(target) {\r\n    return target === getWindowOf(target).document.documentElement;\r\n}\r\n/**\r\n * Calculates an appropriate content rectangle for provided html or svg element.\r\n *\r\n * @param {Element} target - Element content rectangle of which needs to be calculated.\r\n * @returns {DOMRectInit}\r\n */\r\nfunction getContentRect(target) {\r\n    if (!isBrowser) {\r\n        return emptyRect;\r\n    }\r\n    if (isSVGGraphicsElement(target)) {\r\n        return getSVGContentRect(target);\r\n    }\r\n    return getHTMLElementContentRect(target);\r\n}\r\n/**\r\n * Creates rectangle with an interface of the DOMRectReadOnly.\r\n * Spec: https://drafts.fxtf.org/geometry/#domrectreadonly\r\n *\r\n * @param {DOMRectInit} rectInit - Object with rectangle's x/y coordinates and dimensions.\r\n * @returns {DOMRectReadOnly}\r\n */\r\nfunction createReadOnlyRect(_a) {\r\n    var x = _a.x, y = _a.y, width = _a.width, height = _a.height;\r\n    // If DOMRectReadOnly is available use it as a prototype for the rectangle.\r\n    var Constr = typeof DOMRectReadOnly !== 'undefined' ? DOMRectReadOnly : Object;\r\n    var rect = Object.create(Constr.prototype);\r\n    // Rectangle's properties are not writable and non-enumerable.\r\n    defineConfigurable(rect, {\r\n        x: x, y: y, width: width, height: height,\r\n        top: y,\r\n        right: x + width,\r\n        bottom: height + y,\r\n        left: x\r\n    });\r\n    return rect;\r\n}\r\n/**\r\n * Creates DOMRectInit object based on the provided dimensions and the x/y coordinates.\r\n * Spec: https://drafts.fxtf.org/geometry/#dictdef-domrectinit\r\n *\r\n * @param {number} x - X coordinate.\r\n * @param {number} y - Y coordinate.\r\n * @param {number} width - Rectangle's width.\r\n * @param {number} height - Rectangle's height.\r\n * @returns {DOMRectInit}\r\n */\r\nfunction createRectInit(x, y, width, height) {\r\n    return { x: x, y: y, width: width, height: height };\r\n}\n\n/**\r\n * Class that is responsible for computations of the content rectangle of\r\n * provided DOM element and for keeping track of it's changes.\r\n */\r\nvar ResizeObservation = /** @class */ (function () {\r\n    /**\r\n     * Creates an instance of ResizeObservation.\r\n     *\r\n     * @param {Element} target - Element to be observed.\r\n     */\r\n    function ResizeObservation(target) {\r\n        /**\r\n         * Broadcasted width of content rectangle.\r\n         *\r\n         * @type {number}\r\n         */\r\n        this.broadcastWidth = 0;\r\n        /**\r\n         * Broadcasted height of content rectangle.\r\n         *\r\n         * @type {number}\r\n         */\r\n        this.broadcastHeight = 0;\r\n        /**\r\n         * Reference to the last observed content rectangle.\r\n         *\r\n         * @private {DOMRectInit}\r\n         */\r\n        this.contentRect_ = createRectInit(0, 0, 0, 0);\r\n        this.target = target;\r\n    }\r\n    /**\r\n     * Updates content rectangle and tells whether it's width or height properties\r\n     * have changed since the last broadcast.\r\n     *\r\n     * @returns {boolean}\r\n     */\r\n    ResizeObservation.prototype.isActive = function () {\r\n        var rect = getContentRect(this.target);\r\n        this.contentRect_ = rect;\r\n        return (rect.width !== this.broadcastWidth ||\r\n            rect.height !== this.broadcastHeight);\r\n    };\r\n    /**\r\n     * Updates 'broadcastWidth' and 'broadcastHeight' properties with a data\r\n     * from the corresponding properties of the last observed content rectangle.\r\n     *\r\n     * @returns {DOMRectInit} Last observed content rectangle.\r\n     */\r\n    ResizeObservation.prototype.broadcastRect = function () {\r\n        var rect = this.contentRect_;\r\n        this.broadcastWidth = rect.width;\r\n        this.broadcastHeight = rect.height;\r\n        return rect;\r\n    };\r\n    return ResizeObservation;\r\n}());\n\nvar ResizeObserverEntry = /** @class */ (function () {\r\n    /**\r\n     * Creates an instance of ResizeObserverEntry.\r\n     *\r\n     * @param {Element} target - Element that is being observed.\r\n     * @param {DOMRectInit} rectInit - Data of the element's content rectangle.\r\n     */\r\n    function ResizeObserverEntry(target, rectInit) {\r\n        var contentRect = createReadOnlyRect(rectInit);\r\n        // According to the specification following properties are not writable\r\n        // and are also not enumerable in the native implementation.\r\n        //\r\n        // Property accessors are not being used as they'd require to define a\r\n        // private WeakMap storage which may cause memory leaks in browsers that\r\n        // don't support this type of collections.\r\n        defineConfigurable(this, { target: target, contentRect: contentRect });\r\n    }\r\n    return ResizeObserverEntry;\r\n}());\n\nvar ResizeObserverSPI = /** @class */ (function () {\r\n    /**\r\n     * Creates a new instance of ResizeObserver.\r\n     *\r\n     * @param {ResizeObserverCallback} callback - Callback function that is invoked\r\n     *      when one of the observed elements changes it's content dimensions.\r\n     * @param {ResizeObserverController} controller - Controller instance which\r\n     *      is responsible for the updates of observer.\r\n     * @param {ResizeObserver} callbackCtx - Reference to the public\r\n     *      ResizeObserver instance which will be passed to callback function.\r\n     */\r\n    function ResizeObserverSPI(callback, controller, callbackCtx) {\r\n        /**\r\n         * Collection of resize observations that have detected changes in dimensions\r\n         * of elements.\r\n         *\r\n         * @private {Array<ResizeObservation>}\r\n         */\r\n        this.activeObservations_ = [];\r\n        /**\r\n         * Registry of the ResizeObservation instances.\r\n         *\r\n         * @private {Map<Element, ResizeObservation>}\r\n         */\r\n        this.observations_ = new MapShim();\r\n        if (typeof callback !== 'function') {\r\n            throw new TypeError('The callback provided as parameter 1 is not a function.');\r\n        }\r\n        this.callback_ = callback;\r\n        this.controller_ = controller;\r\n        this.callbackCtx_ = callbackCtx;\r\n    }\r\n    /**\r\n     * Starts observing provided element.\r\n     *\r\n     * @param {Element} target - Element to be observed.\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverSPI.prototype.observe = function (target) {\r\n        if (!arguments.length) {\r\n            throw new TypeError('1 argument required, but only 0 present.');\r\n        }\r\n        // Do nothing if current environment doesn't have the Element interface.\r\n        if (typeof Element === 'undefined' || !(Element instanceof Object)) {\r\n            return;\r\n        }\r\n        if (!(target instanceof getWindowOf(target).Element)) {\r\n            throw new TypeError('parameter 1 is not of type \"Element\".');\r\n        }\r\n        var observations = this.observations_;\r\n        // Do nothing if element is already being observed.\r\n        if (observations.has(target)) {\r\n            return;\r\n        }\r\n        observations.set(target, new ResizeObservation(target));\r\n        this.controller_.addObserver(this);\r\n        // Force the update of observations.\r\n        this.controller_.refresh();\r\n    };\r\n    /**\r\n     * Stops observing provided element.\r\n     *\r\n     * @param {Element} target - Element to stop observing.\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverSPI.prototype.unobserve = function (target) {\r\n        if (!arguments.length) {\r\n            throw new TypeError('1 argument required, but only 0 present.');\r\n        }\r\n        // Do nothing if current environment doesn't have the Element interface.\r\n        if (typeof Element === 'undefined' || !(Element instanceof Object)) {\r\n            return;\r\n        }\r\n        if (!(target instanceof getWindowOf(target).Element)) {\r\n            throw new TypeError('parameter 1 is not of type \"Element\".');\r\n        }\r\n        var observations = this.observations_;\r\n        // Do nothing if element is not being observed.\r\n        if (!observations.has(target)) {\r\n            return;\r\n        }\r\n        observations.delete(target);\r\n        if (!observations.size) {\r\n            this.controller_.removeObserver(this);\r\n        }\r\n    };\r\n    /**\r\n     * Stops observing all elements.\r\n     *\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverSPI.prototype.disconnect = function () {\r\n        this.clearActive();\r\n        this.observations_.clear();\r\n        this.controller_.removeObserver(this);\r\n    };\r\n    /**\r\n     * Collects observation instances the associated element of which has changed\r\n     * it's content rectangle.\r\n     *\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverSPI.prototype.gatherActive = function () {\r\n        var _this = this;\r\n        this.clearActive();\r\n        this.observations_.forEach(function (observation) {\r\n            if (observation.isActive()) {\r\n                _this.activeObservations_.push(observation);\r\n            }\r\n        });\r\n    };\r\n    /**\r\n     * Invokes initial callback function with a list of ResizeObserverEntry\r\n     * instances collected from active resize observations.\r\n     *\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverSPI.prototype.broadcastActive = function () {\r\n        // Do nothing if observer doesn't have active observations.\r\n        if (!this.hasActive()) {\r\n            return;\r\n        }\r\n        var ctx = this.callbackCtx_;\r\n        // Create ResizeObserverEntry instance for every active observation.\r\n        var entries = this.activeObservations_.map(function (observation) {\r\n            return new ResizeObserverEntry(observation.target, observation.broadcastRect());\r\n        });\r\n        this.callback_.call(ctx, entries, ctx);\r\n        this.clearActive();\r\n    };\r\n    /**\r\n     * Clears the collection of active observations.\r\n     *\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverSPI.prototype.clearActive = function () {\r\n        this.activeObservations_.splice(0);\r\n    };\r\n    /**\r\n     * Tells whether observer has active observations.\r\n     *\r\n     * @returns {boolean}\r\n     */\r\n    ResizeObserverSPI.prototype.hasActive = function () {\r\n        return this.activeObservations_.length > 0;\r\n    };\r\n    return ResizeObserverSPI;\r\n}());\n\n// Registry of internal observers. If WeakMap is not available use current shim\r\n// for the Map collection as it has all required methods and because WeakMap\r\n// can't be fully polyfilled anyway.\r\nvar observers = typeof WeakMap !== 'undefined' ? new WeakMap() : new MapShim();\r\n/**\r\n * ResizeObserver API. Encapsulates the ResizeObserver SPI implementation\r\n * exposing only those methods and properties that are defined in the spec.\r\n */\r\nvar ResizeObserver = /** @class */ (function () {\r\n    /**\r\n     * Creates a new instance of ResizeObserver.\r\n     *\r\n     * @param {ResizeObserverCallback} callback - Callback that is invoked when\r\n     *      dimensions of the observed elements change.\r\n     */\r\n    function ResizeObserver(callback) {\r\n        if (!(this instanceof ResizeObserver)) {\r\n            throw new TypeError('Cannot call a class as a function.');\r\n        }\r\n        if (!arguments.length) {\r\n            throw new TypeError('1 argument required, but only 0 present.');\r\n        }\r\n        var controller = ResizeObserverController.getInstance();\r\n        var observer = new ResizeObserverSPI(callback, controller, this);\r\n        observers.set(this, observer);\r\n    }\r\n    return ResizeObserver;\r\n}());\r\n// Expose public methods of ResizeObserver.\r\n[\r\n    'observe',\r\n    'unobserve',\r\n    'disconnect'\r\n].forEach(function (method) {\r\n    ResizeObserver.prototype[method] = function () {\r\n        var _a;\r\n        return (_a = observers.get(this))[method].apply(_a, arguments);\r\n    };\r\n});\n\nvar index = (function () {\r\n    // Export existing implementation if available.\r\n    if (typeof global$1.ResizeObserver !== 'undefined') {\r\n        return global$1.ResizeObserver;\r\n    }\r\n    return ResizeObserver;\r\n})();\n\nexport default index;\n","/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\nvar stylesInDom = {};\n\nvar\tmemoize = function (fn) {\n\tvar memo;\n\n\treturn function () {\n\t\tif (typeof memo === \"undefined\") memo = fn.apply(this, arguments);\n\t\treturn memo;\n\t};\n};\n\nvar isOldIE = memoize(function () {\n\t// Test for IE <= 9 as proposed by Browserhacks\n\t// @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805\n\t// Tests for existence of standard globals is to allow style-loader\n\t// to operate correctly into non-standard environments\n\t// @see https://github.com/webpack-contrib/style-loader/issues/177\n\treturn window && document && document.all && !window.atob;\n});\n\nvar getTarget = function (target, parent) {\n  if (parent){\n    return parent.querySelector(target);\n  }\n  return document.querySelector(target);\n};\n\nvar getElement = (function (fn) {\n\tvar memo = {};\n\n\treturn function(target, parent) {\n                // If passing function in options, then use it for resolve \"head\" element.\n                // Useful for Shadow Root style i.e\n                // {\n                //   insertInto: function () { return document.querySelector(\"#foo\").shadowRoot }\n                // }\n                if (typeof target === 'function') {\n                        return target();\n                }\n                if (typeof memo[target] === \"undefined\") {\n\t\t\tvar styleTarget = getTarget.call(this, target, parent);\n\t\t\t// Special case to return head of iframe instead of iframe itself\n\t\t\tif (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {\n\t\t\t\ttry {\n\t\t\t\t\t// This will throw an exception if access to iframe is blocked\n\t\t\t\t\t// due to cross-origin restrictions\n\t\t\t\t\tstyleTarget = styleTarget.contentDocument.head;\n\t\t\t\t} catch(e) {\n\t\t\t\t\tstyleTarget = null;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmemo[target] = styleTarget;\n\t\t}\n\t\treturn memo[target]\n\t};\n})();\n\nvar singleton = null;\nvar\tsingletonCounter = 0;\nvar\tstylesInsertedAtTop = [];\n\nvar\tfixUrls = require(\"./urls\");\n\nmodule.exports = function(list, options) {\n\tif (typeof DEBUG !== \"undefined\" && DEBUG) {\n\t\tif (typeof document !== \"object\") throw new Error(\"The style-loader cannot be used in a non-browser environment\");\n\t}\n\n\toptions = options || {};\n\n\toptions.attrs = typeof options.attrs === \"object\" ? options.attrs : {};\n\n\t// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\n\t// tags it will allow on a page\n\tif (!options.singleton && typeof options.singleton !== \"boolean\") options.singleton = isOldIE();\n\n\t// By default, add <style> tags to the <head> element\n        if (!options.insertInto) options.insertInto = \"head\";\n\n\t// By default, add <style> tags to the bottom of the target\n\tif (!options.insertAt) options.insertAt = \"bottom\";\n\n\tvar styles = listToStyles(list, options);\n\n\taddStylesToDom(styles, options);\n\n\treturn function update (newList) {\n\t\tvar mayRemove = [];\n\n\t\tfor (var i = 0; i < styles.length; i++) {\n\t\t\tvar item = styles[i];\n\t\t\tvar domStyle = stylesInDom[item.id];\n\n\t\t\tdomStyle.refs--;\n\t\t\tmayRemove.push(domStyle);\n\t\t}\n\n\t\tif(newList) {\n\t\t\tvar newStyles = listToStyles(newList, options);\n\t\t\taddStylesToDom(newStyles, options);\n\t\t}\n\n\t\tfor (var i = 0; i < mayRemove.length; i++) {\n\t\t\tvar domStyle = mayRemove[i];\n\n\t\t\tif(domStyle.refs === 0) {\n\t\t\t\tfor (var j = 0; j < domStyle.parts.length; j++) domStyle.parts[j]();\n\n\t\t\t\tdelete stylesInDom[domStyle.id];\n\t\t\t}\n\t\t}\n\t};\n};\n\nfunction addStylesToDom (styles, options) {\n\tfor (var i = 0; i < styles.length; i++) {\n\t\tvar item = styles[i];\n\t\tvar domStyle = stylesInDom[item.id];\n\n\t\tif(domStyle) {\n\t\t\tdomStyle.refs++;\n\n\t\t\tfor(var j = 0; j < domStyle.parts.length; j++) {\n\t\t\t\tdomStyle.parts[j](item.parts[j]);\n\t\t\t}\n\n\t\t\tfor(; j < item.parts.length; j++) {\n\t\t\t\tdomStyle.parts.push(addStyle(item.parts[j], options));\n\t\t\t}\n\t\t} else {\n\t\t\tvar parts = [];\n\n\t\t\tfor(var j = 0; j < item.parts.length; j++) {\n\t\t\t\tparts.push(addStyle(item.parts[j], options));\n\t\t\t}\n\n\t\t\tstylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};\n\t\t}\n\t}\n}\n\nfunction listToStyles (list, options) {\n\tvar styles = [];\n\tvar newStyles = {};\n\n\tfor (var i = 0; i < list.length; i++) {\n\t\tvar item = list[i];\n\t\tvar id = options.base ? item[0] + options.base : item[0];\n\t\tvar css = item[1];\n\t\tvar media = item[2];\n\t\tvar sourceMap = item[3];\n\t\tvar part = {css: css, media: media, sourceMap: sourceMap};\n\n\t\tif(!newStyles[id]) styles.push(newStyles[id] = {id: id, parts: [part]});\n\t\telse newStyles[id].parts.push(part);\n\t}\n\n\treturn styles;\n}\n\nfunction insertStyleElement (options, style) {\n\tvar target = getElement(options.insertInto)\n\n\tif (!target) {\n\t\tthrow new Error(\"Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.\");\n\t}\n\n\tvar lastStyleElementInsertedAtTop = stylesInsertedAtTop[stylesInsertedAtTop.length - 1];\n\n\tif (options.insertAt === \"top\") {\n\t\tif (!lastStyleElementInsertedAtTop) {\n\t\t\ttarget.insertBefore(style, target.firstChild);\n\t\t} else if (lastStyleElementInsertedAtTop.nextSibling) {\n\t\t\ttarget.insertBefore(style, lastStyleElementInsertedAtTop.nextSibling);\n\t\t} else {\n\t\t\ttarget.appendChild(style);\n\t\t}\n\t\tstylesInsertedAtTop.push(style);\n\t} else if (options.insertAt === \"bottom\") {\n\t\ttarget.appendChild(style);\n\t} else if (typeof options.insertAt === \"object\" && options.insertAt.before) {\n\t\tvar nextSibling = getElement(options.insertAt.before, target);\n\t\ttarget.insertBefore(style, nextSibling);\n\t} else {\n\t\tthrow new Error(\"[Style Loader]\\n\\n Invalid value for parameter 'insertAt' ('options.insertAt') found.\\n Must be 'top', 'bottom', or Object.\\n (https://github.com/webpack-contrib/style-loader#insertat)\\n\");\n\t}\n}\n\nfunction removeStyleElement (style) {\n\tif (style.parentNode === null) return false;\n\tstyle.parentNode.removeChild(style);\n\n\tvar idx = stylesInsertedAtTop.indexOf(style);\n\tif(idx >= 0) {\n\t\tstylesInsertedAtTop.splice(idx, 1);\n\t}\n}\n\nfunction createStyleElement (options) {\n\tvar style = document.createElement(\"style\");\n\n\tif(options.attrs.type === undefined) {\n\t\toptions.attrs.type = \"text/css\";\n\t}\n\n\tif(options.attrs.nonce === undefined) {\n\t\tvar nonce = getNonce();\n\t\tif (nonce) {\n\t\t\toptions.attrs.nonce = nonce;\n\t\t}\n\t}\n\n\taddAttrs(style, options.attrs);\n\tinsertStyleElement(options, style);\n\n\treturn style;\n}\n\nfunction createLinkElement (options) {\n\tvar link = document.createElement(\"link\");\n\n\tif(options.attrs.type === undefined) {\n\t\toptions.attrs.type = \"text/css\";\n\t}\n\toptions.attrs.rel = \"stylesheet\";\n\n\taddAttrs(link, options.attrs);\n\tinsertStyleElement(options, link);\n\n\treturn link;\n}\n\nfunction addAttrs (el, attrs) {\n\tObject.keys(attrs).forEach(function (key) {\n\t\tel.setAttribute(key, attrs[key]);\n\t});\n}\n\nfunction getNonce() {\n\tif (typeof __webpack_nonce__ === 'undefined') {\n\t\treturn null;\n\t}\n\n\treturn __webpack_nonce__;\n}\n\nfunction addStyle (obj, options) {\n\tvar style, update, remove, result;\n\n\t// If a transform function was defined, run it on the css\n\tif (options.transform && obj.css) {\n\t    result = typeof options.transform === 'function'\n\t\t ? options.transform(obj.css) \n\t\t : options.transform.default(obj.css);\n\n\t    if (result) {\n\t    \t// If transform returns a value, use that instead of the original css.\n\t    \t// This allows running runtime transformations on the css.\n\t    \tobj.css = result;\n\t    } else {\n\t    \t// If the transform function returns a falsy value, don't add this css.\n\t    \t// This allows conditional loading of css\n\t    \treturn function() {\n\t    \t\t// noop\n\t    \t};\n\t    }\n\t}\n\n\tif (options.singleton) {\n\t\tvar styleIndex = singletonCounter++;\n\n\t\tstyle = singleton || (singleton = createStyleElement(options));\n\n\t\tupdate = applyToSingletonTag.bind(null, style, styleIndex, false);\n\t\tremove = applyToSingletonTag.bind(null, style, styleIndex, true);\n\n\t} else if (\n\t\tobj.sourceMap &&\n\t\ttypeof URL === \"function\" &&\n\t\ttypeof URL.createObjectURL === \"function\" &&\n\t\ttypeof URL.revokeObjectURL === \"function\" &&\n\t\ttypeof Blob === \"function\" &&\n\t\ttypeof btoa === \"function\"\n\t) {\n\t\tstyle = createLinkElement(options);\n\t\tupdate = updateLink.bind(null, style, options);\n\t\tremove = function () {\n\t\t\tremoveStyleElement(style);\n\n\t\t\tif(style.href) URL.revokeObjectURL(style.href);\n\t\t};\n\t} else {\n\t\tstyle = createStyleElement(options);\n\t\tupdate = applyToTag.bind(null, style);\n\t\tremove = function () {\n\t\t\tremoveStyleElement(style);\n\t\t};\n\t}\n\n\tupdate(obj);\n\n\treturn function updateStyle (newObj) {\n\t\tif (newObj) {\n\t\t\tif (\n\t\t\t\tnewObj.css === obj.css &&\n\t\t\t\tnewObj.media === obj.media &&\n\t\t\t\tnewObj.sourceMap === obj.sourceMap\n\t\t\t) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tupdate(obj = newObj);\n\t\t} else {\n\t\t\tremove();\n\t\t}\n\t};\n}\n\nvar replaceText = (function () {\n\tvar textStore = [];\n\n\treturn function (index, replacement) {\n\t\ttextStore[index] = replacement;\n\n\t\treturn textStore.filter(Boolean).join('\\n');\n\t};\n})();\n\nfunction applyToSingletonTag (style, index, remove, obj) {\n\tvar css = remove ? \"\" : obj.css;\n\n\tif (style.styleSheet) {\n\t\tstyle.styleSheet.cssText = replaceText(index, css);\n\t} else {\n\t\tvar cssNode = document.createTextNode(css);\n\t\tvar childNodes = style.childNodes;\n\n\t\tif (childNodes[index]) style.removeChild(childNodes[index]);\n\n\t\tif (childNodes.length) {\n\t\t\tstyle.insertBefore(cssNode, childNodes[index]);\n\t\t} else {\n\t\t\tstyle.appendChild(cssNode);\n\t\t}\n\t}\n}\n\nfunction applyToTag (style, obj) {\n\tvar css = obj.css;\n\tvar media = obj.media;\n\n\tif(media) {\n\t\tstyle.setAttribute(\"media\", media)\n\t}\n\n\tif(style.styleSheet) {\n\t\tstyle.styleSheet.cssText = css;\n\t} else {\n\t\twhile(style.firstChild) {\n\t\t\tstyle.removeChild(style.firstChild);\n\t\t}\n\n\t\tstyle.appendChild(document.createTextNode(css));\n\t}\n}\n\nfunction updateLink (link, options, obj) {\n\tvar css = obj.css;\n\tvar sourceMap = obj.sourceMap;\n\n\t/*\n\t\tIf convertToAbsoluteUrls isn't defined, but sourcemaps are enabled\n\t\tand there is no publicPath defined then lets turn convertToAbsoluteUrls\n\t\ton by default.  Otherwise default to the convertToAbsoluteUrls option\n\t\tdirectly\n\t*/\n\tvar autoFixUrls = options.convertToAbsoluteUrls === undefined && sourceMap;\n\n\tif (options.convertToAbsoluteUrls || autoFixUrls) {\n\t\tcss = fixUrls(css);\n\t}\n\n\tif (sourceMap) {\n\t\t// http://stackoverflow.com/a/26603875\n\t\tcss += \"\\n/*# sourceMappingURL=data:application/json;base64,\" + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + \" */\";\n\t}\n\n\tvar blob = new Blob([css], { type: \"text/css\" });\n\n\tvar oldSrc = link.href;\n\n\tlink.href = URL.createObjectURL(blob);\n\n\tif(oldSrc) URL.revokeObjectURL(oldSrc);\n}\n","\n/**\n * When source maps are enabled, `style-loader` uses a link element with a data-uri to\n * embed the css on the page. This breaks all relative urls because now they are relative to a\n * bundle instead of the current page.\n *\n * One solution is to only use full urls, but that may be impossible.\n *\n * Instead, this function \"fixes\" the relative urls to be absolute according to the current page location.\n *\n * A rudimentary test suite is located at `test/fixUrls.js` and can be run via the `npm test` command.\n *\n */\n\nmodule.exports = function (css) {\n  // get current location\n  var location = typeof window !== \"undefined\" && window.location;\n\n  if (!location) {\n    throw new Error(\"fixUrls requires window.location\");\n  }\n\n\t// blank or null?\n\tif (!css || typeof css !== \"string\") {\n\t  return css;\n  }\n\n  var baseUrl = location.protocol + \"//\" + location.host;\n  var currentDir = baseUrl + location.pathname.replace(/\\/[^\\/]*$/, \"/\");\n\n\t// convert each url(...)\n\t/*\n\tThis regular expression is just a way to recursively match brackets within\n\ta string.\n\n\t /url\\s*\\(  = Match on the word \"url\" with any whitespace after it and then a parens\n\t   (  = Start a capturing group\n\t     (?:  = Start a non-capturing group\n\t         [^)(]  = Match anything that isn't a parentheses\n\t         |  = OR\n\t         \\(  = Match a start parentheses\n\t             (?:  = Start another non-capturing groups\n\t                 [^)(]+  = Match anything that isn't a parentheses\n\t                 |  = OR\n\t                 \\(  = Match a start parentheses\n\t                     [^)(]*  = Match anything that isn't a parentheses\n\t                 \\)  = Match a end parentheses\n\t             )  = End Group\n              *\\) = Match anything and then a close parens\n          )  = Close non-capturing group\n          *  = Match anything\n       )  = Close capturing group\n\t \\)  = Match a close parens\n\n\t /gi  = Get all matches, not the first.  Be case insensitive.\n\t */\n\tvar fixedCss = css.replace(/url\\s*\\(((?:[^)(]|\\((?:[^)(]+|\\([^)(]*\\))*\\))*)\\)/gi, function(fullMatch, origUrl) {\n\t\t// strip quotes (if they exist)\n\t\tvar unquotedOrigUrl = origUrl\n\t\t\t.trim()\n\t\t\t.replace(/^\"(.*)\"$/, function(o, $1){ return $1; })\n\t\t\t.replace(/^'(.*)'$/, function(o, $1){ return $1; });\n\n\t\t// already a full url? no change\n\t\tif (/^(#|data:|http:\\/\\/|https:\\/\\/|file:\\/\\/\\/|\\s*$)/i.test(unquotedOrigUrl)) {\n\t\t  return fullMatch;\n\t\t}\n\n\t\t// convert the url to a full url\n\t\tvar newUrl;\n\n\t\tif (unquotedOrigUrl.indexOf(\"//\") === 0) {\n\t\t  \t//TODO: should we add protocol?\n\t\t\tnewUrl = unquotedOrigUrl;\n\t\t} else if (unquotedOrigUrl.indexOf(\"/\") === 0) {\n\t\t\t// path should be relative to the base url\n\t\t\tnewUrl = baseUrl + unquotedOrigUrl; // already starts with '/'\n\t\t} else {\n\t\t\t// path should be relative to current directory\n\t\t\tnewUrl = currentDir + unquotedOrigUrl.replace(/^\\.\\//, \"\"); // Strip leading './'\n\t\t}\n\n\t\t// send back the fixed url(...)\n\t\treturn \"url(\" + JSON.stringify(newUrl) + \")\";\n\t});\n\n\t// send back the fixed css\n\treturn fixedCss;\n};\n","var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n"],"mappings":";;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AClFA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACpNA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACtHA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC19BA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACrCA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AChpBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACtPA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACraA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AClGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC5QA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC1WA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC7GA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC3BA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC1BA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC/KA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AChKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC/XA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACjHA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACzIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC/WA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC/OA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACnBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC/9DA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACj+CA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC5PA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC9CA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC7CA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACvDA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC5DA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AChDA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC3CA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AClDA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AClDA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACpDA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACpDA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AChDA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC5CA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACpDA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACxCA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACzCA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AChDA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACpCA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACzCA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACpCA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACpCA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACtCA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACtCA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACpCA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC3BA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACxCA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC1EA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AClLA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACpMA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACpFA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC1CA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC5FA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AChFA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACjFA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AChEA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AChEA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACjEA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACjEA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACtDA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AChFA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC5DA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACnEA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC3DA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACnCA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACxCA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC5DA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC9VA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC7BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACpXA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC9LA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACjRA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACpHA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACvGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC3hBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC7CA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AClDA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC5QA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACtTA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACpTA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC9JA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC5EA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACpRA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC3RA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACljBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACnBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACrdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC3EA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC/5BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC/YA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACxFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;A","sourceRoot":""}