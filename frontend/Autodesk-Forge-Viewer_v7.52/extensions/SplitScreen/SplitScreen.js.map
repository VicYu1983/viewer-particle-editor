{"version":3,"file":"SplitScreen/SplitScreen.js","sources":["webpack://Autodesk.Extensions.[name]/webpack/bootstrap","webpack://Autodesk.Extensions.[name]/./extensions/SplitScreen/SplitScreen.js","webpack://Autodesk.Extensions.[name]/./extensions/SplitScreen/SplitScreenGroundShadow.js","webpack://Autodesk.Extensions.[name]/./extensions/SplitScreen/SplitScreenRenderContext.js"],"sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./extensions/SplitScreen/SplitScreen.js\");\n","import { SplitScreenGroundShadow } from './SplitScreenGroundShadow';\nimport { SplitScreenRenderContext } from './SplitScreenRenderContext';\n\n'use strict';\n\nvar namespace = AutodeskNamespace('Autodesk.Extensions.SplitScreen');\nvar myExtensionName = 'Autodesk.SplitScreen';\nvar navToolsExtension = 'Autodesk.DefaultTools.NavTools';\n\n/**\n                                                           * Filter function that returns true for models to be rendered on the specified subcanvas.\n                                                           * \n                                                           * @callback Autodesk.Viewing.Extensions.SplitScreenExtension~modelFilterFunction\n                                                           * @param {number} modelId - The id of the model.\n                                                           * @returns {boolean}\n                                                           */\n\n\n/**\n                                                               * This extension subdivides the LMV canvas into between 2 and 4 (inclusive) separate subcanvases.\n                                                               *\n                                                               * The extension id is: `Autodesk.SplitScreen`\n                                                               *\n                                                               * For each sub-canvas, you can specify a separate model filter function to control in which\n                                                               * canvases each model shall appear. The canvases are numbered as follows:\n                                                               * 0  1\n                                                               * 2  3\n                                                               *\n                                                               * By default (no modelFilter), all models are rendered to each subcanvas.\n                                                               * Overlays are rendered into both canvases (unless selection highlighting proxies - which are associated with models)\n                                                               *\n                                                               * Limitations: Most core features of LMV keep working (2D/3D render, mouse-over, selection, directional zoom etc.).\n                                                               * However, there are currently some known limitations/tradeoffs:\n                                                               * - All canvases must use the same camera. Overcoming this requires to introduce a separate scene graph evaluation too.\n                                                               * - Subcanvas configuration is currently limited to subcanvases with the same aspect ratio. Extending that will\n                                                               * (among others) require support for separate cameras.\n                                                               * - ZoomToolExtension, SectionTool, and Measure tool are disabled SplitScreen (we hide the UI)\n                                                               * - GroundShadow is supported, but doesn't apply model filter yet when refreshing the shadow\n                                                               * - GroundReflection in SplitScreen is not supported yet.\n                                                               * - We currently use only a single background for both. This is hardly noticeable for discreet backgrounds like the AEC default or fixed colors,\n                                                               * but may disturb when using more detailed environments.\n                                                               *\n                                                               * @example \n                                                               * var options = {\n                                                               * viewports: [\n                                                               * function(id) { return id === 1; },\n                                                               * function(id) { return id !== 1; }\n                                                               * ]\n                                                               * };\n                                                               * viewer.loadExtension('Autodesk.SplitScreen', options);\n                                                               * @param {Viewer3D} viewer - Viewer instance\n                                                               * @param {object} [options]\n                                                               * @param {Array.<Autodesk.Viewing.Extensions.SplitScreenExtension~modelFilterFunction?>} [options.viewports] - Filter\n                                                               * functions that returns true for models to be rendered for the viewport at that index. Falsy values render everything.\n                                                               * @memberof Autodesk.Viewing.Extensions\n                                                               * @alias Autodesk.Viewing.Extensions.SplitScreenExtension\n                                                               * @see {@link Autodesk.Viewing.Extension} for common inherited methods.\n                                                               * @class\n                                                               */\nexport function SplitScreenExtension(viewer, options) {\n  Autodesk.Viewing.Extension.call(this, viewer, options);\n  this.options = options || {};\n}\n\nSplitScreenExtension.prototype = Object.create(Autodesk.Viewing.Extension.prototype);\nSplitScreenExtension.prototype.constructor = SplitScreenExtension;\n\nvar proto = SplitScreenExtension.prototype;\n\n\nproto.load = function () {\n  var scope = this;\n  this.enabled = true;\n\n  // Note that we just wrap the RenderContext, but do not reinitialize it. This avoids a couple of issues like...\n  //  1. Wasting some resources by reallocating targets and effects\n  //  2. EdgeMaterial and DepthMaterial would be recreated, so that we would need to register them again at MaterialManager to keep cutplanes working.\n  //  3. We would lose some settings (e.g. edge rendering flag, sao settings etc.)\n  var renderer = this.viewer.impl.renderer();\n  this.context = new SplitScreenRenderContext(renderer, this.viewer);\n  this.viewer.impl.setUserRenderContext(this.context, true);\n\n  // Replace ground shadow by proxy object that manages an additional GroundShadows for right screen\n  this.groundShadow = new SplitScreenGroundShadow();\n  this.groundShadow.attach(this.viewer);\n\n  // Filter viewports\n  this.patchRayCast();\n\n  // Viewport coordinate conversions\n  this.patchCoordinateConversions();\n\n  // Fix world up (roll) tool\n  if (this.viewer.getExtension(navToolsExtension)) {\n    this.patchWorldUp();\n  } else {\n    var onExtensionLoaded = function onExtensionLoaded(event) {\n      if (event.extensionId === navToolsExtension) {\n        scope.patchWorldUp();\n        scope.viewer.removeEventListener(Autodesk.Viewing.EXTENSION_LOADED_EVENT, onExtensionLoaded);\n      }\n    };\n    this.viewer.addEventListener(Autodesk.Viewing.EXTENSION_LOADED_EVENT, onExtensionLoaded);\n  }\n\n  // Remember which tools we have hidden in order to bring them back later\n  // NOTE: This assumes that the tool display state or existence is not changed while SplitScreen is used. Ideally, we should\n  //       avoid this by making them work together.\n  this.collectControlsToHide();\n\n  // On resize or nav-mode changes, GuiViewer.updateButtonToolbar overwrites the display style for some tools, so that we have\n  // to hide them again.\n  this.onToolbarButtonsUpdated = function () {\n    scope.hideIncompatibleControls(true);\n  };\n  this.viewer.addEventListener(Autodesk.Viewing.NAVIGATION_MODE_CHANGED_EVENT, this.onToolbarButtonsUpdated);\n\n  // Adjust camera aspect ratio for half screen width (now and on resize)\n  this.handleResize = function () {\n    var w = scope.viewer.canvas.clientWidth;\n    var h = scope.viewer.canvas.clientHeight;\n\n    var camera = scope.viewer.impl.camera;\n    camera.clientWidth = w;\n    camera.clientHeight = h;\n    camera.aspect = w / h;\n\n    if (scope.enabled) {\n      camera.clientWidth /= 2.0;\n      if (scope.context.getNumberOfViewports() > 2) {\n        camera.clientHeight /= 2.0;\n      } else {\n        camera.aspect /= 2.0;\n      }\n    }\n\n    // Make sure that incompabible\n    scope.onToolbarButtonsUpdated();\n  };\n  this.viewer.addEventListener(Autodesk.Viewing.VIEWER_RESIZE_EVENT, this.handleResize);\n  this.handleResize();\n\n  if (this.options.viewports) {\n    this.context.setViewports(this.options.viewports);\n  } else if (this.options.modelFilterLeft || this.options.modelFilterRight) {\n    this.context.modelFilterLeft = this.options.modelFilterLeft;\n    this.context.modelFilterRight = this.options.modelFilterRight;\n  }\n\n  return true;\n};\n\n// Maps a value in the range [Left, Right] with midpoint M so that [L, M] => [L, R] and [M, R] => [L, R]\n/**\n * @param {number} a - Value to map\n * @param {number} left - Left of the range\n * @param {number} right - Right of the range\n * @private\n */\nfunction squish(a, left, right) {\n  if (Math.abs(a - left) > Math.abs(a - right)) {// closer to right than left\n    // Move to the left\n    a -= (right - left) / 2;\n  }\n\n  a = 2 * a - left;\n\n  return a;\n}\n\n/**\n   * Maps the given x/y coordinates onto a viewport. x is assumed to be in [left, right]. y is assumed to\n   * be in [top, bottom]. Viewports are numbered left to right, top to bottom starting at 0. E.g if there are\n   * 2 viewports, 0 is the left one, 1 is the right one. If there are 4, 0 is top left, 1 is top right, 2 is bottom\n   * left, 3 is bottom right.\n   *\n   * Example: top=-1, bottom=1, right=1, left=-1 with 4 viewports\n   *     -1\n   * -1 --|-- 1\n   *      1\n   * (-0.5, -0.5) => (0, 0) vpId=0\n   * (-0.25, 1) => (0.5, 1) vpId=2\n   * (1, 1) => (1, 1) vpId=3\n   *\n   *\n   * @param {number} x - The x coordinate to map. Should be in the range [left, right]\n   * @param {number} y - The y coordinate to map. Should be in the range [bottom, top]\n   * @param {number} left - The left boundary of the coordinate system\n   * @param {number} right - The right boundary of the coordinate system\n   * @param {number} top - The top boundary of the coordinate system\n   * @param {number} bottom - The bottom boundary of the coordinate system\n   *\n   * @returns {{x: number, y: number, viewportId: number}} - An object with the new x/y coordinates and the viewport number\n   */\nproto.mapCoords = function (x, y, left, right, top, bottom) {\n  var viewportId = 0;\n  var numberOfViewports = this.context.getNumberOfViewports();\n\n  // Need to map the x coordinate\n  if (numberOfViewports >= 2) {\n    viewportId = Math.abs(x - left) < Math.abs(x - right) ? 0 : 1;\n    x = squish(x, left, right);\n  }\n\n  // Need to map the y coordinate\n  if (numberOfViewports >= 3) {\n    viewportId += Math.abs(y - top) < Math.abs(y - bottom) ? 0 : 2;\n    y = squish(y, bottom, top);\n  }\n\n  return { x: x, y: y, viewportId: viewportId };\n};\n\n// Set 'display: none' for all incompatible tools or recover initial display value.\nproto.hideIncompatibleControls = function (hide) {\n  for (var i = 0; i < this.controlsToHide.length; i++) {\n    var obj = this.controlsToHide[i];\n    var val = hide ? 'none' : obj.originalValue;\n    obj.control.setDisplay(val);\n  }\n};\n\nproto.collectControl = function (control) {\n  if (control) {\n    this.controlsToHide.push({\n      control: control,\n      originalValue: control.container.style.display });\n\n  }\n};\n\n// Collect controls that we have to hide because they are not yet compatible with split screen\nproto.collectControlsToHide = function () {\n\n  this.controlsToHide = [];\n\n  // measure\n  var modelTools = this.viewer.modelTools;\n  this.collectControl(modelTools.measurementToolbarButton);\n\n  // section\n  this.collectControl(modelTools.getControl('toolbar-sectionTool'));\n\n  // zoom\n  this.collectControl(this.viewer.navTools.getControl('toolbar-zoomTools'));\n};\n\n// Wrap raycast, so that it distinguishes between viewports\nproto.patchRayCast = function () {\n  this.castRayViewport = this.viewer.impl.castRayViewport.bind(this.viewer.impl);\n\n  var hideAllFilter = function hideAllFilter() {return false;}; // Hide everything\n\n  var scope = this;\n  this.viewer.impl.castRayViewport = function (vpVecIn, ignoreTransparent, dbIds, modelIds, intersections) {\n    // get visible models\n    var mq = scope.viewer.impl.modelQueue();\n    var models = mq.getModels();\n\n    // Create list of modelIds to be ray-intersected\n    var modelIdsFiltered = models.map(function (model) {return model.id;});\n\n    // Filter based on viewport\n    // vpVecIn has been augmented with the viewport ID by this point so we can tell which viewport the mouse\n    // event originally came from.\n    // viewportFilter isn't guaranteed to be defined. If there are only 3 viewports, mouse events can still be\n    // mapped to where the 4th viewport would be if it existed. In this case we want to hit nothing\n    var viewports = scope.context.getViewports();\n    var viewportFilter = viewports[vpVecIn.viewportId || 0];\n    modelIdsFiltered = modelIdsFiltered.filter(viewportFilter || hideAllFilter);\n\n    return scope.castRayViewport(vpVecIn, ignoreTransparent, dbIds, modelIdsFiltered, intersections);\n  };\n};\n\n// Recover original raycast function\nproto.unpatchRayCast = function () {\n  this.viewer.impl.castRayViewport = this.castRayViewport;\n};\n\n// Fix coordinate conversions to respect the split viewports\nproto.patchCoordinateConversions = function () {\n  var scope = this;\n\n  this.clientToViewport = this.viewer.impl.clientToViewport.bind(this.viewer.impl);\n  this.screenToViewport = this.viewer.navigation.screenToViewport.bind(this.viewer.navigation);\n  this.viewportToScreen = this.viewer.navigation.viewportToScreen.bind(this.viewer.navigation);\n  this.rolloverObjectViewport = this.viewer.impl.rolloverObjectViewport.bind(this.viewer.impl);\n\n  // Returns vec with x and y in [-1, 1]\n  this.viewer.impl.clientToViewport = function (clientX, clientY) {\n    var vpVec = scope.clientToViewport(clientX, clientY);\n\n    var result = scope.mapCoords(vpVec.x, vpVec.y, -1, 1, 1, -1);\n\n    vpVec.x = result.x;\n    vpVec.y = result.y;\n\n    // Augment with an id for the viewport that was targeted so we can recover it later\n    vpVec.viewportId = result.viewportId;\n\n    return vpVec;\n  };\n\n  // Redirect to the correct viewport at tag the vector with the viewportId\n  this.viewer.navigation.screenToViewport = function (x, y) {\n    var result = scope.mapCoords(x, y, 0, 1, 0, 1);\n\n    var vpVec = scope.screenToViewport(result.x, result.y);\n    vpVec.viewportId = result.viewportId;\n\n    return vpVec;\n  };\n\n  // We can't recover the correct viewport so just assume it's from the left viewport\n  this.viewer.navigation.viewportToScreen = function (x, y) {\n    var vpVec = scope.viewportToScreen(x, y);\n\n    // Just convert to the top left viewport since we can't tell which one it's from\n    vpVec.x /= 2.0;\n\n    if (scope.context.getNumberOfViewports() > 2) {\n      vpVec.y /= 2.0;\n    }\n\n    return vpVec;\n  };\n\n  // Rolling over objects actually doesn't need a conversion so we have to undo the conversion that was applied\n  this.viewer.impl.rolloverObjectViewport = function (vpVecIn) {\n    var vpVecOut = new THREE.Vector3();\n\n    // Convert it back\n    vpVecOut.copy(vpVecIn);\n\n    vpVecOut.x += 1.0;\n    vpVecOut.x /= 2.0;\n    vpVecOut.x -= vpVecIn.viewportId % 2 === 0 ? 1.0 : 0.0;\n\n    if (scope.context.getNumberOfViewports() > 2) {\n      vpVecOut.y += 1.0;\n      vpVecOut.y /= 2.0;\n      vpVecOut.y -= vpVecIn.viewportId > 1 ? 1.0 : 0.0;\n    }\n\n    return scope.rolloverObjectViewport(vpVecOut);\n  };\n};\n\nproto.unpatchCoordinateConversions = function () {\n  this.viewer.impl.clientToViewport = this.clientToViewport;\n  this.viewer.navigation.screenToViewport = this.screenToViewport;\n  this.viewer.navigation.viewportToScreen = this.viewportToScreen;\n  this.viewer.impl.rolloverObjectViewport = this.rolloverObjectViewport;\n};\n\n// Fix world up by patching its input handlers\nproto.patchWorldUp = function () {\n  this.worldUpTool = this.viewer.toolController.getTool('worldup');\n  if (!this.worldUpTool) {\n    console.warn('Failed to patch the world up tool');\n    return;\n  }\n  this.worldUpHandleMouseMove = this.worldUpTool.handleMouseMove.bind(this.worldUpTool);\n  this.worldUpHandleButtonDown = this.worldUpTool.handleButtonDown.bind(this.worldUpTool);\n  this.worldUpHandleButtonUp = this.worldUpTool.handleButtonUp.bind(this.worldUpTool);\n\n  var scope = this;\n\n  // The viewport our interaction started in\n  var startingViewportId = null;\n\n  // Transforms the coordinates to the appropriate viewport. Records which viewport the mouse goes down in so we can\n  // reference it when tracking movement and release.\n  this.worldUpTool.handleButtonDown = function (event) {\n    var originalX = event.normalizedX;\n    var originalY = event.normalizedY;\n\n    var result = scope.mapCoords(originalX, originalY, -1, 1, 1, -1);\n\n    event.normalizedX = result.x;\n    event.normalizedY = result.y;\n    startingViewportId = result.viewportId;\n\n    result = scope.worldUpHandleButtonDown(event);\n\n    // Reverse the transformation so it doesn't affect other tools further down in the stack\n    event.normalizedX = originalX;\n    event.normalizedY = originalY;\n\n    return result;\n  };\n\n  // Returns a mouse handler function that transforms the input coordinates to the starting viewports coordinates.\n  // This prevents the weird snapping when dragging from one viewport to another when using the roll tool\n  /**\n   * @param f\n   * @private\n   */\n  function transform(f) {\n    return function (event) {\n      var originalX = event.normalizedX;\n      var originalY = event.normalizedY;\n\n      // Map the coordinates as usual\n      var result = scope.mapCoords(originalX, originalY, -1, 1, 1, -1);\n\n      // Shift result so it's in the starting viewport's coordinates\n      // X\n      // Only need to do something if we've dragged from left to right or right to left.\n      if (startingViewportId % 2 !== result.viewportId % 2) {\n        // Range becomes [-3, 1] or [-1, 3] depending on which viewport is our reference\n        result.x += 2 * (result.viewportId % 2 - startingViewportId % 2);\n      }\n\n      // Y\n      // Only need to do something if we've dragged from top to bottom or bottom to top.\n      if (startingViewportId > 1 !== result.viewportId > 1) {\n        // Range becomes [-3, 1] or [-1, 3] depending on which viewport is our reference\n        result.y += result.viewportId > 1 ? -2 : 2;\n      }\n\n      event.normalizedX = result.x;\n      event.normalizedY = result.y;\n\n      result = f(event);\n\n      // Reverse the transformation so it doesn't affect other tools further down in the stack\n      event.normalizedX = originalX;\n      event.normalizedY = originalY;\n\n      return result;\n    };\n  }\n  this.worldUpTool.handleMouseMove = transform(this.worldUpHandleMouseMove);\n  this.worldUpTool.handleButtonUp = transform(this.worldUpHandleButtonUp);\n};\n\nproto.unpatchWorldUp = function () {\n  // The patch wasn't necessarily applied so only unpatch if these are defined\n  if (this.worldUpHandleMouseMove) {\n    this.worldUpTool.handleMouseMove = this.worldUpHandleMouseMove;\n    this.worldUpHandleMouseMove = null;\n  }\n\n  if (this.worldUpHandleButtonDown) {\n    this.worldUpTool.handleButtonDown = this.worldUpHandleButtonDown;\n    this.worldUpHandleButtonDown = null;\n  }\n\n  if (this.worldUpHandleButtonUp) {\n    this.worldUpTool.handleButtonUp = this.worldUpHandleButtonUp;\n    this.worldUpHandleButtonUp = null;\n  }\n};\n\n\n// called on first activation of split screen mode\nproto.unload = function () {\n\n  // recover original RenderContext\n  this.viewer.impl.setUserRenderContext(this.context.context, true);\n\n  // recover original GroundShadow\n  this.groundShadow.detach(this.viewer);\n\n  // revert remapping of raycasts and getWorldpoint\n  this.unpatchRayCast();\n  this.unpatchCoordinateConversions();\n  this.unpatchWorldUp();\n\n  // reset camera to full horizontal fov\n  this.enabled = false;\n  this.handleResize();\n  this.viewer.removeEventListener(Autodesk.Viewing.VIEWER_RESIZE_EVENT, this.handleResize);\n\n  // recover visibility of incompatible controls\n  this.hideIncompatibleControls(false);\n  this.viewer.removeEventListener(Autodesk.Viewing.NAVIGATION_MODE_CHANGED_EVENT, this.onToolbarButtonsUpdated);\n};\n\n// Register the extension with the extension manager.\nAutodesk.Viewing.theExtensionManager.registerExtension(myExtensionName, SplitScreenExtension);\nnamespace.SplitScreenExtension = SplitScreenExtension;","'use strict';\n\nvar RightShadowMaterial = \"SplitScreen_RightGroundShadowMaterial\";\n\n// Proxy to manage 2 separate GroundShadows for split screen\nexport function SplitScreenGroundShadow() {\n\n  this.attach = function (viewer) {\n\n    this.renderer = viewer.impl.glrenderer();\n\n    // Reuse existing ground shadow for left screen and create a separate GroundShadow for the right one.\n    this.leftShadow = viewer.impl.setUserGroundShadow(this);\n    this.rightShadow = new Autodesk.Viewing.Private.GroundShadow(this.renderer);\n\n    // Make sure that override materials get current cutplanes from MaterialManager\n    var materials = viewer.impl.getMaterials();\n    materials.addMaterialNonHDR(RightShadowMaterial, this.rightShadow.getDepthMaterial());\n\n    // Sync right ground-shadow settings with the original one\n    this.rightShadow.enabled = this.leftShadow.enabled;\n    this.rightShadow.setColor(this.leftShadow.getColor());\n    this.rightShadow.setAlpha(this.leftShadow.getAlpha());\n\n    // force ground shadow update (including transform reset)\n    viewer.impl.sceneUpdated();\n  };\n\n  this.detach = function (viewer) {\n\n    // clean up secondary ground shadow material\n    var materials = viewer.impl.getMaterials();\n    materials.removeNonHDRMaterial(RightShadowMaterial);\n\n    // recover original ground shadow\n    viewer.impl.setUserGroundShadow(this.leftShadow);\n    viewer.impl.sceneUpdated();\n  };\n\n  // Create function that forwards a function call to left/right GroundShadow. Return values are taken\n  // from the right one. (We can use any, because we keep them in sync)\n  this.createForward = function (funcName) {\n    this[funcName] = function () {\n      this.leftShadow[funcName].apply(this.leftShadow, arguments);\n      return this.rightShadow[funcName].apply(this.rightShadow, arguments);\n    }.bind(this);\n  };\n\n  var forwards = [\n  \"setTransform\",\n  \"setDirty\",\n  \"prepareGroundShadow\",\n  \"getStatus\",\n  \"clear\",\n  \"setColor\",\n  \"setAlpha\"];\n\n  for (var i in forwards) {\n    this.createForward(forwards[i]);\n  }\n\n  Object.defineProperty(this, 'enabled', {\n    get: function get() {\n      return this.leftShadow.enabled;\n    },\n    set: function set(enabled) {\n      this.leftShadow.enabled = enabled;\n      this.rightShadow.enabled = enabled;\n    } });\n\n\n  Object.defineProperty(this, 'rendered', {\n    get: function get() {\n      return this.leftShadow.rendered;\n    },\n    set: function set(rendered) {\n      this.leftShadow.rendered = rendered;\n      this.rightShadow.rendered = rendered;\n    } });\n\n\n  this.renderShadow = function (camera, target) {\n\n    // Note that the camera is already set to half canvas width\n    var halfW = camera.clientWidth;\n    var height = camera.clientHeight;\n\n    this.renderer.setViewport(0, 0, halfW, height);\n    this.leftShadow.renderShadow(camera, target);\n\n    this.renderer.setViewport(halfW, 0, halfW, height);\n    this.rightShadow.renderShadow(camera, target);\n  };\n}","'use strict';\n\nexport function SplitScreenRenderContext(context, viewer) {\n\n  var permissiveFilter = function permissiveFilter() {return true;};\n  var _this = this;\n  var _black = new THREE.Color().setRGB(0, 0, 0);\n\n  this.context = context;\n  this.settings = this.context.settings;\n\n  // By default, 2 viewports, no filters (all models on both viewports)\n  this._viewports = [permissiveFilter, permissiveFilter];\n\n  // Backwards compatibility\n  Object.defineProperty(this, 'modelFilterLeft', {\n    enumerable: true,\n    get: function get() {\n      return this._viewports[0];\n    },\n    set: function set(val) {\n      this._viewports[0] = val || permissiveFilter; // null/undefined used to mean \"show all\"\n    } });\n\n  Object.defineProperty(this, 'modelFilterRight', {\n    enumerable: true,\n    get: function get() {\n      return this._viewports[1];\n    },\n    set: function set(val) {\n      this._viewports[1] = val || permissiveFilter; // null/undefined used to mean \"show all\"\n    } });\n\n\n  this.width = viewer.impl.canvas.clientWidth;\n  this.height = viewer.impl.canvas.clientHeight;\n\n  this.renderer = viewer.impl.glrenderer();\n\n  // All standard function calls that we don't override are forwarded to this.context\n  function applyForwards(targetContext) {\n\n    function createForwardFunction(funcName) {\n      return function () {\n        // Forward to target context.\n        return targetContext[funcName].apply(targetContext, arguments);\n      };\n    }\n\n    // For any function that we don't explicitly override in prototype, just forward the calls\n    // to both child contexts.\n    for (var key in targetContext) {\n\n      // Only care for functions\n      var func = targetContext[key];\n      if (typeof func !== 'function') {\n        continue;\n      }\n\n      _this[key] = createForwardFunction(key);\n    }\n  }\n  applyForwards(this.context);\n\n  this.renderScenePart = function (scene) {\n\n    this.renderer.enableViewportOnOffscreenTargets(true);\n\n    var vpWidth = this.width / 2;\n    var vpHeight = _this._viewports.length > 2 ? this.height / 2 : this.height;\n    var vpVertStart = _this._viewports.length > 2 ? vpHeight : 0;\n\n    var shouldRenderForViewport = _this._viewports.map(function (vpFilter) {\n      return vpFilter(scene.modelId);\n    });\n\n    // Left\n    if (shouldRenderForViewport[0]) {\n      this.renderer.setViewport(0, vpVertStart, vpWidth, vpHeight);\n      this.context.renderScenePart.apply(this.context, arguments);\n    }\n\n    // Right\n    if (shouldRenderForViewport[1]) {\n      this.renderer.setViewport(vpWidth, vpVertStart, vpWidth, vpHeight);\n      this.context.renderScenePart.apply(this.context, arguments);\n    }\n\n    // Bottom left\n    if (shouldRenderForViewport[2]) {\n      this.renderer.setViewport(0, 0, vpWidth, vpHeight);\n      this.context.renderScenePart.apply(this.context, arguments);\n    }\n\n    // Bottom right\n    if (shouldRenderForViewport[3]) {\n      this.renderer.setViewport(vpWidth, 0, vpWidth, vpHeight);\n      this.context.renderScenePart.apply(this.context, arguments);\n    }\n\n    this.renderer.setViewport(0, 0, this.width, this.height);\n    this.renderer.enableViewportOnOffscreenTargets(false);\n  };\n\n  // Set all meshes visible that are excluded by the given model filter.\n  // Returns an array of all meshes that were hidden - is used to recover previous visiblity later.\n  this.isolateSelectionMeshes = function (overlays, filter) {\n\n    var overlay = overlays[\"selection\"];\n    var scene = overlay && overlay.scene;\n    if (!scene) {\n      return [];\n    }\n\n    var meshesHidden = [];\n    for (var i = 0; i < scene.children.length; i++) {\n      var mesh = scene.children[i];\n      if (!(mesh instanceof THREE.Mesh) || !mesh.visible) {\n        continue;\n      }\n\n      // hide mesh if its model is excluded\n      if (filter && mesh.model && !filter(mesh.model.id)) {\n        mesh.visible = false;\n        meshesHidden.push(mesh);\n      }\n    }\n    return meshesHidden;\n  };\n\n  this.setMeshesVisible = function (meshes) {\n    for (var i = 0; i < meshes.length; i++) {\n      meshes[i].visible = true;\n    }\n  };\n\n  this.renderOverlays = function (overlays, lights) {\n    var vpWidth = this.width / 2;\n    var vpHeight = _this._viewports.length > 2 ? this.height / 2 : this.height;\n    var vpVertStart = _this._viewports.length > 2 ? vpHeight : 0;\n\n    var overlayTarget = this.context.getNamedTarget('overlay');\n    var needsClear = false;\n    for (var key in overlays) {\n      var p = overlays[key];\n      var s = p.scene;\n      if (s.children.length) {\n        needsClear = true;\n        break;\n      }\n    }\n    if (needsClear) {\n      this.renderer.setClearColor(_black, 0.0);\n      this.renderer.clearTarget(overlayTarget, true, false, false);\n    }\n\n    this.renderer.enableViewportOnOffscreenTargets(true);\n\n    var meshesExcluded;\n\n    // Left\n    meshesExcluded = this.isolateSelectionMeshes(overlays, _this._viewports[0]);\n    this.renderer.setViewport(0, vpVertStart, vpWidth, vpHeight);\n    this.context.renderOverlays(overlays, lights, true);\n    this.setMeshesVisible(meshesExcluded);\n\n    // Right\n    meshesExcluded = this.isolateSelectionMeshes(overlays, _this._viewports[1]);\n    this.renderer.setViewport(vpWidth, vpVertStart, vpWidth, vpHeight);\n    this.context.renderOverlays(overlays, lights, true);\n    this.setMeshesVisible(meshesExcluded);\n\n    // Bottom left\n    if (_this._viewports.length >= 3) {\n      meshesExcluded = this.isolateSelectionMeshes(overlays, _this._viewports[2]);\n      this.renderer.setViewport(0, 0, vpWidth, vpHeight);\n      this.context.renderOverlays(overlays, lights, true);\n      this.setMeshesVisible(meshesExcluded);\n    }\n\n    // Bottom right\n    if (_this._viewports.length >= 4) {\n      meshesExcluded = this.isolateSelectionMeshes(overlays, _this._viewports[3]);\n      this.renderer.setViewport(vpWidth, 0, vpWidth, vpHeight);\n      this.context.renderOverlays(overlays, lights, true);\n      this.setMeshesVisible(meshesExcluded);\n    }\n\n    this.renderer.setViewport(0, 0, this.width, this.height);\n    this.renderer.enableViewportOnOffscreenTargets(false);\n  };\n\n  this.setSize = function (w, h, force) {\n    this.width = w;\n    this.height = h;\n    this.context.setSize(w, h, force);\n  };\n\n  /**\n      * Sets the viewports and their filters. There can be at most 4 viewports/filters and at least 2.\n      *\n      * @param {Array.<Function?>} viewports - The array of viewport filters. Each entry in the array is a predicate\n      * function on a model ID indicating whether or not that model ID should be rendered in the viewport. Falsy values\n      * in the array are replaced with a function that always returns true.\n      */\n  this.setViewports = function (viewports) {\n    // Maximum 4 viewports, null means permissive filter\n    viewports = viewports.slice(0, 4) // create a shallow copy of at most 4 of the items\n    .map(function (filter) {\n      return filter || permissiveFilter; // Replace any null values with a permissive filter\n    });\n\n    // Minimum of 2 viewports\n    if (viewports.length < 2) {\n      var fillStart = viewports.length;\n      viewports.length = 2;\n      viewports.fill(permissiveFilter, fillStart);\n    }\n\n    this._viewports = viewports;\n\n    // Trigger a resize to recalculate aspect ratio and cause a redraw\n    viewer.resize();\n  };\n\n  /**\n      * Adds a viewport. If there are already 4 viewports then nothing happens.\n      *\n      * @param {Function?} [viewport] - A filter for the viewport. If no filter is provided then all models are displayed\n      */\n  this.addViewport = function (viewport) {\n    viewport = viewport || permissiveFilter;\n\n    if (this._viewports.length < 4) {\n      this._viewports.push(viewport);\n      // Trigger a resize to recalculate aspect ratio and cause a redraw\n      viewer.resize();\n    }\n  };\n\n  /**\n      * Removes a viewport at the specified index. If the index is out of bounds or there are 2 or fewer viewports\n      * then nothing happens.\n      *\n      * @param {Function?} [viewport] - A filter for the viewport. If no filter is provided then all models are displayed\n      */\n  this.removeViewport = function (index) {\n    if (this._viewports.length <= 2 || index >= this._viewports.length || index < 0) {\n      return;\n    }\n\n    this._viewports.splice(index, 1);\n    // Trigger a resize to recalculate aspect ratio and cause a redraw\n    viewer.resize();\n  };\n\n  /**\n      * Returns a shallow copy of the array of viewports\n      *\n      * @return {Array.<Function>} - The array of viewports\n      */\n  this.getViewports = function () {\n    // Shallow copy so we don't have to worry about other parts of the code modifying it and messing with our\n    // assumptions\n    return this._viewports.slice(0);\n  };\n\n  /**\n      * Returns the number of viewports.\n      *\n      * @return {number} - The number of viewports (between 2 and 4 inclusive)\n      */\n  this.getNumberOfViewports = function () {\n    return this._viewports.length;\n  };\n}"],"mappings":";;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AClFA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACneA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC7FA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;A","sourceRoot":""}