{"version":3,"sources":["webpack://Autodesk.Extensions.[name]/webpack/bootstrap","webpack://Autodesk.Extensions.[name]/./extensions/SplitScreen/SplitScreenGroundShadow.js","webpack://Autodesk.Extensions.[name]/./extensions/SplitScreen/SplitScreenRenderContext.js","webpack://Autodesk.Extensions.[name]/./extensions/SplitScreen/SplitScreen.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","SplitScreenGroundShadow","this","attach","viewer","renderer","impl","glrenderer","leftShadow","setUserGroundShadow","rightShadow","Autodesk","Viewing","Private","GroundShadow","getMaterials","addMaterialNonHDR","getDepthMaterial","enabled","setColor","getColor","setAlpha","getAlpha","sceneUpdated","detach","removeNonHDRMaterial","createForward","funcName","apply","arguments","forwards","set","rendered","renderShadow","camera","target","halfW","clientWidth","height","clientHeight","setViewport","SplitScreenRenderContext","context","permissiveFilter","_this","_black","THREE","Color","setRGB","settings","_viewports","val","width","canvas","targetContext","createForwardFunction","applyForwards","renderScenePart","scene","enableViewportOnOffscreenTargets","vpWidth","vpHeight","length","vpVertStart","shouldRenderForViewport","map","vpFilter","modelId","isolateSelectionMeshes","overlays","filter","overlay","meshesHidden","children","mesh","Mesh","visible","model","id","push","setMeshesVisible","meshes","renderOverlays","lights","meshesExcluded","overlayTarget","getNamedTarget","needsClear","setClearColor","clearTarget","setSize","w","h","force","setViewports","viewports","slice","fillStart","fill","resize","addViewport","viewport","removeViewport","index","splice","getViewports","getNumberOfViewports","namespace","AutodeskNamespace","SplitScreenExtension","options","Extension","constructor","proto","squish","a","left","right","Math","abs","load","scope","setUserRenderContext","groundShadow","patchRayCast","patchCoordinateConversions","getExtension","patchWorldUp","addEventListener","EXTENSION_LOADED_EVENT","onExtensionLoaded","event","extensionId","removeEventListener","collectControlsToHide","onToolbarButtonsUpdated","hideIncompatibleControls","NAVIGATION_MODE_CHANGED_EVENT","handleResize","aspect","VIEWER_RESIZE_EVENT","modelFilterLeft","modelFilterRight","mapCoords","x","y","top","bottom","viewportId","numberOfViewports","hide","controlsToHide","obj","originalValue","control","setDisplay","collectControl","container","style","display","modelTools","measurementToolbarButton","getControl","navTools","castRayViewport","hideAllFilter","vpVecIn","ignoreTransparent","dbIds","modelIds","intersections","modelIdsFiltered","modelQueue","getModels","viewportFilter","unpatchRayCast","clientToViewport","screenToViewport","navigation","viewportToScreen","rolloverObjectViewport","clientX","clientY","vpVec","result","vpVecOut","Vector3","copy","unpatchCoordinateConversions","worldUpTool","toolController","getTool","worldUpHandleMouseMove","handleMouseMove","worldUpHandleButtonDown","handleButtonDown","worldUpHandleButtonUp","handleButtonUp","startingViewportId","originalX","normalizedX","originalY","normalizedY","transform","console","warn","f","unpatchWorldUp","unload","theExtensionManager","registerExtension"],"mappings":"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","file":"SplitScreen/SplitScreen.min.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 863);\n","'use strict';\n\nvar RightShadowMaterial = \"SplitScreen_RightGroundShadowMaterial\";\n\n// Proxy to manage 2 separate GroundShadows for split screen\nexport function SplitScreenGroundShadow() {\n\n    this.attach = function(viewer) {\n\n        this.renderer = viewer.impl.glrenderer();\n\n        // Reuse existing ground shadow for left screen and create a separate GroundShadow for the right one.\n        this.leftShadow  = viewer.impl.setUserGroundShadow(this);\n        this.rightShadow = new Autodesk.Viewing.Private.GroundShadow(this.renderer);\n\n        // Make sure that override materials get current cutplanes from MaterialManager\n        var materials = viewer.impl.getMaterials();\n        materials.addMaterialNonHDR(RightShadowMaterial, this.rightShadow.getDepthMaterial());\n\n        // Sync right ground-shadow settings with the original one\n        this.rightShadow.enabled = this.leftShadow.enabled;    \n        this.rightShadow.setColor(this.leftShadow.getColor());\n        this.rightShadow.setAlpha(this.leftShadow.getAlpha());\n\n        // force ground shadow update (including transform reset)\n        viewer.impl.sceneUpdated();\n    };\n\n    this.detach = function(viewer) {\n\n        // clean up secondary ground shadow material\n        var materials = viewer.impl.getMaterials();\n        materials.removeNonHDRMaterial(RightShadowMaterial);\n\n        // recover original ground shadow\n        viewer.impl.setUserGroundShadow(this.leftShadow);\n        viewer.impl.sceneUpdated();\n    };\n\n    // Create function that forwards a function call to left/right GroundShadow. Return values are taken\n    // from the right one. (We can use any, because we keep them in sync)\n    this.createForward = function(funcName) {\n        this[funcName] = function() {\n            this.leftShadow[funcName].apply(this.leftShadow, arguments);\n            return this.rightShadow[funcName].apply(this.rightShadow, arguments);\n        }.bind(this);\n    };\n\n    var forwards = [        \n        \"setTransform\",\n        \"setDirty\",\n        \"prepareGroundShadow\",\n        \"getStatus\",\n        \"clear\",\n        \"setColor\",\n        \"setAlpha\"\n    ];\n    for (var i in forwards) {\n        this.createForward(forwards[i]);\n    }\n    \n    Object.defineProperty(this, 'enabled', {\n        get: function() { \n            return this.leftShadow.enabled;\n        },\n        set: function(enabled) { \n            this.leftShadow.enabled  = enabled; \n            this.rightShadow.enabled = enabled;\n        }\n    });\n\n    Object.defineProperty(this, 'rendered', {\n        get: function() { \n            return this.leftShadow.rendered;\n        },\n        set: function(rendered) { \n            this.leftShadow.rendered  = rendered; \n            this.rightShadow.rendered = rendered;\n        }\n    });\n\n    this.renderShadow = function(camera, target) {\n\n        // Note that the camera is already set to half canvas width\n        var halfW  = camera.clientWidth;\n        var height = camera.clientHeight;\n\n        this.renderer.setViewport(0, 0, halfW, height);\n        this.leftShadow.renderShadow(camera, target);\n\n        this.renderer.setViewport(halfW, 0, halfW, height);\n        this.rightShadow.renderShadow(camera, target);        \n    };\n}\n","'use strict';\n\nexport function SplitScreenRenderContext(context, viewer) {\n\n    var permissiveFilter = function() { return true; };\n    var _this = this;\n    var _black = new THREE.Color().setRGB(0, 0, 0);\n\n    this.context  = context;\n    this.settings = this.context.settings;\n\n    // By default, 2 viewports, no filters (all models on both viewports)\n    this._viewports = [permissiveFilter, permissiveFilter];\n\n    // Backwards compatibility\n    Object.defineProperty(this, 'modelFilterLeft', {\n        enumerable: true,\n        get: function() {\n            return this._viewports[0];\n        },\n        set: function(val) {\n            this._viewports[0] = val || permissiveFilter; // null/undefined used to mean \"show all\"\n        }\n    });\n    Object.defineProperty(this, 'modelFilterRight', {\n        enumerable: true,\n        get: function() {\n            return this._viewports[1];\n        },\n        set: function(val) {\n            this._viewports[1] = val || permissiveFilter; // null/undefined used to mean \"show all\"\n        }\n    });\n\n    this.width  = viewer.impl.canvas.clientWidth;\n    this.height = viewer.impl.canvas.clientHeight;\n\n    this.renderer = viewer.impl.glrenderer();\n\n    // All standard function calls that we don't override are forwarded to this.context\n    function applyForwards(targetContext) {\n\n        function createForwardFunction(funcName) {\n            return function() {\n                // Forward to target context.\n                return targetContext[funcName].apply(targetContext, arguments);\n            };\n        }\n\n        // For any function that we don't explicitly override in prototype, just forward the calls\n        // to both child contexts.\n        for (var key in targetContext) {\n            \n            // Only care for functions\n            var func = targetContext[key];\n            if (typeof func !== 'function') {\n                continue;\n            }\n\n            _this[key] = createForwardFunction(key);\n        }\n    }\n    applyForwards(this.context);\n\n    this.renderScenePart = function (scene) {\n\n        this.renderer.enableViewportOnOffscreenTargets(true);\n\n        var vpWidth = this.width / 2;\n        var vpHeight = _this._viewports.length > 2 ? this.height / 2 : this.height;\n        var vpVertStart = _this._viewports.length > 2 ? vpHeight : 0;\n\n        var shouldRenderForViewport = _this._viewports.map(function(vpFilter) {\n            return vpFilter(scene.modelId);\n        });\n\n        // Left\n        if (shouldRenderForViewport[0]) {\n            this.renderer.setViewport(0, vpVertStart, vpWidth, vpHeight);\n            this.context.renderScenePart.apply(this.context, arguments);\n        }\n\n        // Right\n        if (shouldRenderForViewport[1]) {\n            this.renderer.setViewport(vpWidth, vpVertStart, vpWidth, vpHeight);\n            this.context.renderScenePart.apply(this.context, arguments);\n        }\n\n        // Bottom left\n        if (shouldRenderForViewport[2]) {\n            this.renderer.setViewport(0, 0, vpWidth, vpHeight);\n            this.context.renderScenePart.apply(this.context, arguments);\n        }\n\n        // Bottom right\n        if (shouldRenderForViewport[3]) {\n            this.renderer.setViewport(vpWidth, 0, vpWidth, vpHeight);\n            this.context.renderScenePart.apply(this.context, arguments);\n        }\n\n        this.renderer.setViewport(0, 0, this.width, this.height);\n        this.renderer.enableViewportOnOffscreenTargets(false);\n    };\n\n    // Set all meshes visible that are excluded by the given model filter.\n    // Returns an array of all meshes that were hidden - is used to recover previous visiblity later.\n    this.isolateSelectionMeshes = function(overlays, filter) {\n\n        var overlay = overlays[\"selection\"];\n        var scene   = overlay && overlay.scene;\n        if (!scene) {\n            return [];\n        }\n\n        var meshesHidden = [];\n        for (var i=0; i<scene.children.length; i++) {\n            var mesh = scene.children[i];\n            if (!(mesh instanceof THREE.Mesh) || !mesh.visible) {\n                continue;\n            }\n            \n            // hide mesh if its model is excluded\n            if (filter && mesh.model && !filter(mesh.model.id)) {\n                mesh.visible = false;\n                meshesHidden.push(mesh);\n            }\n        }\n        return meshesHidden;\n    };\n\n    this.setMeshesVisible = function(meshes) {\n        for (var i=0; i<meshes.length; i++) {\n            meshes[i].visible = true;\n        }\n    };\n\n    this.renderOverlays = function(overlays, lights) {\n        var vpWidth = this.width / 2;\n        var vpHeight = _this._viewports.length > 2 ? this.height / 2 : this.height;\n        var vpVertStart = _this._viewports.length > 2 ? vpHeight : 0;\n\n        var overlayTarget = this.context.getNamedTarget('overlay');\n        var needsClear = false;\n        for (var key in overlays) {\n            var p = overlays[key];\n            var s = p.scene;\n            if (s.children.length) {\n                needsClear = true;\n                break;\n            }\n        }\n        if (needsClear) {\n            this.renderer.setClearColor(_black, 0.0);\n            this.renderer.clearTarget(overlayTarget, true, false, false);\n        }\n\n        this.renderer.enableViewportOnOffscreenTargets(true);\n\n        var meshesExcluded;\n\n        // Left\n        meshesExcluded = this.isolateSelectionMeshes(overlays, _this._viewports[0]);\n        this.renderer.setViewport(0, vpVertStart, vpWidth, vpHeight);\n        this.context.renderOverlays(overlays, lights, true);\n        this.setMeshesVisible(meshesExcluded);\n\n        // Right\n        meshesExcluded = this.isolateSelectionMeshes(overlays, _this._viewports[1]);\n        this.renderer.setViewport(vpWidth, vpVertStart, vpWidth, vpHeight);\n        this.context.renderOverlays(overlays, lights, true);\n        this.setMeshesVisible(meshesExcluded);\n\n        // Bottom left\n        if (_this._viewports.length >= 3) {\n            meshesExcluded = this.isolateSelectionMeshes(overlays, _this._viewports[2]);\n            this.renderer.setViewport(0, 0, vpWidth, vpHeight);\n            this.context.renderOverlays(overlays, lights, true);\n            this.setMeshesVisible(meshesExcluded);\n        }\n\n        // Bottom right\n        if (_this._viewports.length >= 4) {\n            meshesExcluded = this.isolateSelectionMeshes(overlays, _this._viewports[3]);\n            this.renderer.setViewport(vpWidth, 0, vpWidth, vpHeight);\n            this.context.renderOverlays(overlays, lights, true);\n            this.setMeshesVisible(meshesExcluded);\n        }\n\n        this.renderer.setViewport(0, 0, this.width, this.height);\n        this.renderer.enableViewportOnOffscreenTargets(false);\n    };\n\n    this.setSize = function(w, h, force) {\n        this.width  = w;\n        this.height = h;\n        this.context.setSize(w, h, force);\n    };\n\n    /**\n     * Sets the viewports and their filters. There can be at most 4 viewports/filters and at least 2.\n     *\n     * @param {Array.<Function?>} viewports - The array of viewport filters. Each entry in the array is a predicate\n     * function on a model ID indicating whether or not that model ID should be rendered in the viewport. Falsy values\n     * in the array are replaced with a function that always returns true.\n     */\n    this.setViewports = function(viewports) {\n        // Maximum 4 viewports, null means permissive filter\n        viewports = viewports.slice(0, 4) // create a shallow copy of at most 4 of the items\n          .map(function(filter) {\n              return filter || permissiveFilter; // Replace any null values with a permissive filter\n          });\n\n        // Minimum of 2 viewports\n        if (viewports.length < 2) {\n            var fillStart = viewports.length;\n            viewports.length = 2;\n            viewports.fill(permissiveFilter, fillStart);\n        }\n\n        this._viewports = viewports;\n\n        // Trigger a resize to recalculate aspect ratio and cause a redraw\n        viewer.resize();\n    };\n\n    /**\n     * Adds a viewport. If there are already 4 viewports then nothing happens.\n     *\n     * @param {Function?} [viewport] - A filter for the viewport. If no filter is provided then all models are displayed\n     */\n    this.addViewport = function(viewport) {\n        viewport = viewport || permissiveFilter;\n\n        if (this._viewports.length < 4) {\n            this._viewports.push(viewport);\n            // Trigger a resize to recalculate aspect ratio and cause a redraw\n            viewer.resize();\n        }\n    };\n\n    /**\n     * Removes a viewport at the specified index. If the index is out of bounds or there are 2 or fewer viewports\n     * then nothing happens.\n     *\n     * @param {Function?} [viewport] - A filter for the viewport. If no filter is provided then all models are displayed\n     */\n    this.removeViewport = function(index) {\n        if (this._viewports.length <= 2 || index >= this._viewports.length || index < 0) {\n            return;\n        }\n\n        this._viewports.splice(index, 1);\n        // Trigger a resize to recalculate aspect ratio and cause a redraw\n        viewer.resize();\n    };\n\n    /**\n     * Returns a shallow copy of the array of viewports\n     *\n     * @return {Array.<Function>} - The array of viewports\n     */\n    this.getViewports = function() {\n        // Shallow copy so we don't have to worry about other parts of the code modifying it and messing with our\n        // assumptions\n        return this._viewports.slice(0);\n    };\n\n    /**\n     * Returns the number of viewports.\n     *\n     * @return {number} - The number of viewports (between 2 and 4 inclusive)\n     */\n    this.getNumberOfViewports = function() {\n        return this._viewports.length;\n    };\n}\n","import { SplitScreenGroundShadow } from './SplitScreenGroundShadow';\nimport { SplitScreenRenderContext } from './SplitScreenRenderContext';\n\n'use strict';\n\nvar namespace = AutodeskNamespace('Autodesk.Extensions.SplitScreen');\nvar myExtensionName = 'Autodesk.SplitScreen';\nvar navToolsExtension = 'Autodesk.DefaultTools.NavTools';\n\n/**\n * Filter function that returns true for models to be rendered on the specified subcanvas.\n * \n * @callback Autodesk.Viewing.Extensions.SplitScreenExtension~modelFilterFunction\n * @param {number} modelId - The id of the model.\n * @returns {boolean}\n */\n\n\n/**\n * This extension subdivides the LMV canvas into between 2 and 4 (inclusive) separate subcanvases.\n *\n * The extension id is: `Autodesk.SplitScreen`\n *\n * For each sub-canvas, you can specify a separate model filter function to control in which\n * canvases each model shall appear. The canvases are numbered as follows:\n * 0  1\n * 2  3\n *\n * By default (no modelFilter), all models are rendered to each subcanvas.\n * Overlays are rendered into both canvases (unless selection highlighting proxies - which are associated with models)\n *\n * Limitations: Most core features of LMV keep working (2D/3D render, mouse-over, selection, directional zoom etc.).\n * However, there are currently some known limitations/tradeoffs:\n * - All canvases must use the same camera. Overcoming this requires to introduce a separate scene graph evaluation too.\n * - Subcanvas configuration is currently limited to subcanvases with the same aspect ratio. Extending that will\n * (among others) require support for separate cameras.\n * - ZoomToolExtension, SectionTool, and Measure tool are disabled SplitScreen (we hide the UI)\n * - GroundShadow is supported, but doesn't apply model filter yet when refreshing the shadow\n * - GroundReflection in SplitScreen is not supported yet.\n * - We currently use only a single background for both. This is hardly noticeable for discreet backgrounds like the AEC default or fixed colors,\n * but may disturb when using more detailed environments.\n *\n * @example \n * var options = {\n * viewports: [\n * function(id) { return id === 1; },\n * function(id) { return id !== 1; }\n * ]\n * };\n * viewer.loadExtension('Autodesk.SplitScreen', options);\n * @param {Viewer3D} viewer - Viewer instance\n * @param {object} [options]\n * @param {Array.<Autodesk.Viewing.Extensions.SplitScreenExtension~modelFilterFunction?>} [options.viewports] - Filter\n * functions that returns true for models to be rendered for the viewport at that index. Falsy values render everything.\n * @memberof Autodesk.Viewing.Extensions\n * @alias Autodesk.Viewing.Extensions.SplitScreenExtension\n * @see {@link Autodesk.Viewing.Extension} for common inherited methods.\n * @class\n */\nexport function SplitScreenExtension(viewer, options) {\n    Autodesk.Viewing.Extension.call(this, viewer, options);\n    this.options = options || {};\n}\n\nSplitScreenExtension.prototype = Object.create(Autodesk.Viewing.Extension.prototype);\nSplitScreenExtension.prototype.constructor = SplitScreenExtension;\n\nvar proto = SplitScreenExtension.prototype;\n\n\nproto.load = function() {\n    var scope = this;\n    this.enabled = true;\n\n    // Note that we just wrap the RenderContext, but do not reinitialize it. This avoids a couple of issues like...\n    //  1. Wasting some resources by reallocating targets and effects\n    //  2. EdgeMaterial and DepthMaterial would be recreated, so that we would need to register them again at MaterialManager to keep cutplanes working.\n    //  3. We would lose some settings (e.g. edge rendering flag, sao settings etc.)\n    var renderer = this.viewer.impl.renderer();\n    this.context = new SplitScreenRenderContext(renderer, this.viewer);\n    this.viewer.impl.setUserRenderContext(this.context, true);\n\n    // Replace ground shadow by proxy object that manages an additional GroundShadows for right screen\n    this.groundShadow = new SplitScreenGroundShadow();\n    this.groundShadow.attach(this.viewer);\n\n    // Filter viewports\n    this.patchRayCast();\n\n    // Viewport coordinate conversions\n    this.patchCoordinateConversions();\n\n    // Fix world up (roll) tool\n    if (this.viewer.getExtension(navToolsExtension)) {\n        this.patchWorldUp();\n    } else {\n        var onExtensionLoaded = function(event) {\n            if (event.extensionId === navToolsExtension) {\n                scope.patchWorldUp();\n                scope.viewer.removeEventListener(Autodesk.Viewing.EXTENSION_LOADED_EVENT, onExtensionLoaded);\n            }\n        };\n        this.viewer.addEventListener(Autodesk.Viewing.EXTENSION_LOADED_EVENT, onExtensionLoaded);\n    }\n\n    // Remember which tools we have hidden in order to bring them back later\n    // NOTE: This assumes that the tool display state or existence is not changed while SplitScreen is used. Ideally, we should\n    //       avoid this by making them work together.\n    this.collectControlsToHide();\n\n    // On resize or nav-mode changes, GuiViewer.updateButtonToolbar overwrites the display style for some tools, so that we have\n    // to hide them again.\n    this.onToolbarButtonsUpdated = function() {\n        scope.hideIncompatibleControls(true);\n    };\n    this.viewer.addEventListener(Autodesk.Viewing.NAVIGATION_MODE_CHANGED_EVENT, this.onToolbarButtonsUpdated);\n\n    // Adjust camera aspect ratio for half screen width (now and on resize)\n    this.handleResize = function() {\n        var w = scope.viewer.canvas.clientWidth;\n        var h = scope.viewer.canvas.clientHeight;\n        \n        var camera = scope.viewer.impl.camera;\n        camera.clientWidth = w;\n        camera.clientHeight = h;\n        camera.aspect = w / h;\n\n        if (scope.enabled) {\n            camera.clientWidth /= 2.0;\n            if (scope.context.getNumberOfViewports() > 2) {\n                camera.clientHeight /= 2.0;\n            } else {\n                camera.aspect /= 2.0;\n            }\n        }\n\n        // Make sure that incompabible\n        scope.onToolbarButtonsUpdated();\n    };\n    this.viewer.addEventListener(Autodesk.Viewing.VIEWER_RESIZE_EVENT, this.handleResize);\n    this.handleResize();\n\n    if (this.options.viewports) {\n        this.context.setViewports(this.options.viewports);\n    } else if (this.options.modelFilterLeft || this.options.modelFilterRight) {\n        this.context.modelFilterLeft  = this.options.modelFilterLeft;\n        this.context.modelFilterRight = this.options.modelFilterRight;\n    }\n\n    return true;\n};\n\n// Maps a value in the range [Left, Right] with midpoint M so that [L, M] => [L, R] and [M, R] => [L, R]\n/**\n * @param {number} a - Value to map\n * @param {number} left - Left of the range\n * @param {number} right - Right of the range\n * @private\n */\nfunction squish(a, left, right) {\n    if (Math.abs(a - left) > Math.abs(a - right)) { // closer to right than left\n        // Move to the left\n        a -= (right - left)/2;\n    }\n\n    a = 2 * a - left;\n\n    return a;\n}\n\n/**\n * Maps the given x/y coordinates onto a viewport. x is assumed to be in [left, right]. y is assumed to\n * be in [top, bottom]. Viewports are numbered left to right, top to bottom starting at 0. E.g if there are\n * 2 viewports, 0 is the left one, 1 is the right one. If there are 4, 0 is top left, 1 is top right, 2 is bottom\n * left, 3 is bottom right.\n *\n * Example: top=-1, bottom=1, right=1, left=-1 with 4 viewports\n *     -1\n * -1 --|-- 1\n *      1\n * (-0.5, -0.5) => (0, 0) vpId=0\n * (-0.25, 1) => (0.5, 1) vpId=2\n * (1, 1) => (1, 1) vpId=3\n *\n *\n * @param {number} x - The x coordinate to map. Should be in the range [left, right]\n * @param {number} y - The y coordinate to map. Should be in the range [bottom, top]\n * @param {number} left - The left boundary of the coordinate system\n * @param {number} right - The right boundary of the coordinate system\n * @param {number} top - The top boundary of the coordinate system\n * @param {number} bottom - The bottom boundary of the coordinate system\n *\n * @returns {{x: number, y: number, viewportId: number}} - An object with the new x/y coordinates and the viewport number\n */\nproto.mapCoords = function(x, y, left, right, top, bottom) {\n    var viewportId = 0;\n    var numberOfViewports = this.context.getNumberOfViewports();\n\n    // Need to map the x coordinate\n    if (numberOfViewports >= 2) {\n        viewportId = Math.abs(x - left) < Math.abs(x - right) ? 0 : 1;\n        x = squish(x, left, right);\n    }\n\n    // Need to map the y coordinate\n    if (numberOfViewports >= 3) {\n        viewportId += Math.abs(y - top) < Math.abs(y - bottom) ? 0 : 2;\n        y = squish(y, bottom, top);\n    }\n\n    return {x: x, y: y, viewportId: viewportId};\n};\n\n// Set 'display: none' for all incompatible tools or recover initial display value.\nproto.hideIncompatibleControls = function(hide) {\n    for (var i=0; i<this.controlsToHide.length; i++) {\n        var obj = this.controlsToHide[i];\n        var val = (hide ? 'none' : obj.originalValue);\n        obj.control.setDisplay(val);\n    }\n};\n\nproto.collectControl = function(control) {\n    if (control) {\n        this.controlsToHide.push({\n            control: control,\n            originalValue: control.container.style.display\n        });\n    }\n};\n\n// Collect controls that we have to hide because they are not yet compatible with split screen\nproto.collectControlsToHide = function() {\n\n    this.controlsToHide = [];\n\n    // measure\n    var modelTools = this.viewer.modelTools;\n    this.collectControl(modelTools.measurementToolbarButton);\n    \n    // section\n    this.collectControl(modelTools.getControl('toolbar-sectionTool'));\n\n    // zoom\n    this.collectControl(this.viewer.navTools.getControl('toolbar-zoomTools'));\n};\n\n// Wrap raycast, so that it distinguishes between viewports\nproto.patchRayCast = function() {\n    this.castRayViewport = this.viewer.impl.castRayViewport.bind(this.viewer.impl);\n\n    var hideAllFilter = function() { return false; }; // Hide everything\n\n    var scope = this;\n    this.viewer.impl.castRayViewport = function(vpVecIn, ignoreTransparent, dbIds, modelIds, intersections) {\n        // get visible models\n        var mq = scope.viewer.impl.modelQueue();\n        var models = mq.getModels();        \n\n        // Create list of modelIds to be ray-intersected\n        var modelIdsFiltered = models.map(function(model) { return model.id; });\n\n        // Filter based on viewport\n        // vpVecIn has been augmented with the viewport ID by this point so we can tell which viewport the mouse\n        // event originally came from.\n        // viewportFilter isn't guaranteed to be defined. If there are only 3 viewports, mouse events can still be\n        // mapped to where the 4th viewport would be if it existed. In this case we want to hit nothing\n        var viewports = scope.context.getViewports();\n        var viewportFilter = viewports[vpVecIn.viewportId || 0];\n        modelIdsFiltered = modelIdsFiltered.filter(viewportFilter || hideAllFilter);\n\n        return scope.castRayViewport(vpVecIn, ignoreTransparent, dbIds, modelIdsFiltered, intersections);\n    };\n};\n\n// Recover original raycast function\nproto.unpatchRayCast = function() {    \n    this.viewer.impl.castRayViewport = this.castRayViewport;\n};\n\n// Fix coordinate conversions to respect the split viewports\nproto.patchCoordinateConversions = function() {\n    var scope = this;\n\n    this.clientToViewport = this.viewer.impl.clientToViewport.bind(this.viewer.impl);\n    this.screenToViewport = this.viewer.navigation.screenToViewport.bind(this.viewer.navigation);\n    this.viewportToScreen = this.viewer.navigation.viewportToScreen.bind(this.viewer.navigation);\n    this.rolloverObjectViewport = this.viewer.impl.rolloverObjectViewport.bind(this.viewer.impl);\n\n    // Returns vec with x and y in [-1, 1]\n    this.viewer.impl.clientToViewport = function(clientX, clientY) {\n        var vpVec = scope.clientToViewport(clientX, clientY);\n\n        var result = scope.mapCoords(vpVec.x, vpVec.y, -1, 1, 1, -1);\n\n        vpVec.x = result.x;\n        vpVec.y = result.y;\n\n        // Augment with an id for the viewport that was targeted so we can recover it later\n        vpVec.viewportId = result.viewportId;\n\n        return vpVec;\n    };\n\n    // Redirect to the correct viewport at tag the vector with the viewportId\n    this.viewer.navigation.screenToViewport = function(x, y) {\n        var result = scope.mapCoords(x, y, 0, 1, 0, 1);\n\n        var vpVec = scope.screenToViewport(result.x, result.y);\n        vpVec.viewportId = result.viewportId;\n\n        return vpVec;\n    };\n\n    // We can't recover the correct viewport so just assume it's from the left viewport\n    this.viewer.navigation.viewportToScreen = function(x, y) {\n        var vpVec = scope.viewportToScreen(x, y);\n\n        // Just convert to the top left viewport since we can't tell which one it's from\n        vpVec.x /= 2.0;\n\n        if (scope.context.getNumberOfViewports() > 2) {\n            vpVec.y /= 2.0;\n        }\n\n        return vpVec;\n    };\n\n    // Rolling over objects actually doesn't need a conversion so we have to undo the conversion that was applied\n    this.viewer.impl.rolloverObjectViewport = function(vpVecIn) {\n        var vpVecOut = new THREE.Vector3();\n\n        // Convert it back\n        vpVecOut.copy(vpVecIn);\n\n        vpVecOut.x += 1.0;\n        vpVecOut.x /= 2.0;\n        vpVecOut.x -= vpVecIn.viewportId % 2 === 0 ? 1.0 : 0.0;\n\n        if (scope.context.getNumberOfViewports() > 2) {\n            vpVecOut.y += 1.0;\n            vpVecOut.y /= 2.0;\n            vpVecOut.y -= vpVecIn.viewportId > 1 ? 1.0 : 0.0;\n        }\n\n        return scope.rolloverObjectViewport(vpVecOut);\n    };\n};\n\nproto.unpatchCoordinateConversions = function() {\n    this.viewer.impl.clientToViewport = this.clientToViewport;\n    this.viewer.navigation.screenToViewport = this.screenToViewport;\n    this.viewer.navigation.viewportToScreen = this.viewportToScreen;\n    this.viewer.impl.rolloverObjectViewport = this.rolloverObjectViewport;\n};\n\n// Fix world up by patching its input handlers\nproto.patchWorldUp = function() {\n    this.worldUpTool = this.viewer.toolController.getTool('worldup');\n    if (!this.worldUpTool) {\n        console.warn('Failed to patch the world up tool');\n        return;\n    }\n    this.worldUpHandleMouseMove = this.worldUpTool.handleMouseMove.bind(this.worldUpTool);\n    this.worldUpHandleButtonDown = this.worldUpTool.handleButtonDown.bind(this.worldUpTool);\n    this.worldUpHandleButtonUp = this.worldUpTool.handleButtonUp.bind(this.worldUpTool);\n\n    var scope = this;\n\n    // The viewport our interaction started in\n    var startingViewportId = null;\n\n    // Transforms the coordinates to the appropriate viewport. Records which viewport the mouse goes down in so we can\n    // reference it when tracking movement and release.\n    this.worldUpTool.handleButtonDown = function(event) {\n        var originalX = event.normalizedX;\n        var originalY = event.normalizedY;\n\n        var result = scope.mapCoords(originalX, originalY, -1, 1, 1, -1);\n\n        event.normalizedX = result.x;\n        event.normalizedY = result.y;\n        startingViewportId = result.viewportId;\n\n        result = scope.worldUpHandleButtonDown(event);\n\n        // Reverse the transformation so it doesn't affect other tools further down in the stack\n        event.normalizedX = originalX;\n        event.normalizedY = originalY;\n\n        return result;\n    };\n\n    // Returns a mouse handler function that transforms the input coordinates to the starting viewports coordinates.\n    // This prevents the weird snapping when dragging from one viewport to another when using the roll tool\n    /**\n     * @param f\n     * @private\n     */\n    function transform(f) {\n        return function(event) {\n            var originalX = event.normalizedX;\n            var originalY = event.normalizedY;\n\n            // Map the coordinates as usual\n            var result = scope.mapCoords(originalX, originalY, -1, 1, 1, -1);\n\n            // Shift result so it's in the starting viewport's coordinates\n            // X\n            // Only need to do something if we've dragged from left to right or right to left.\n            if (startingViewportId % 2 !== result.viewportId % 2) {\n                // Range becomes [-3, 1] or [-1, 3] depending on which viewport is our reference\n                result.x += 2 * (result.viewportId % 2 - startingViewportId % 2);\n            }\n\n            // Y\n            // Only need to do something if we've dragged from top to bottom or bottom to top.\n            if (startingViewportId > 1 !== result.viewportId > 1) {\n                // Range becomes [-3, 1] or [-1, 3] depending on which viewport is our reference\n                result.y += result.viewportId > 1 ? -2 : 2;\n            }\n\n            event.normalizedX = result.x;\n            event.normalizedY = result.y;\n\n            result = f(event);\n\n            // Reverse the transformation so it doesn't affect other tools further down in the stack\n            event.normalizedX = originalX;\n            event.normalizedY = originalY;\n\n            return result;\n        };\n    }\n    this.worldUpTool.handleMouseMove = transform(this.worldUpHandleMouseMove);\n    this.worldUpTool.handleButtonUp = transform(this.worldUpHandleButtonUp);\n};\n\nproto.unpatchWorldUp = function() {\n    // The patch wasn't necessarily applied so only unpatch if these are defined\n    if (this.worldUpHandleMouseMove) {\n        this.worldUpTool.handleMouseMove = this.worldUpHandleMouseMove;\n        this.worldUpHandleMouseMove = null;\n    }\n\n    if (this.worldUpHandleButtonDown) {\n        this.worldUpTool.handleButtonDown = this.worldUpHandleButtonDown;\n        this.worldUpHandleButtonDown = null;\n    }\n\n    if (this.worldUpHandleButtonUp) {\n        this.worldUpTool.handleButtonUp = this.worldUpHandleButtonUp;\n        this.worldUpHandleButtonUp = null;\n    }\n};\n\n\n// called on first activation of split screen mode\nproto.unload = function() {\n\n    // recover original RenderContext\n    this.viewer.impl.setUserRenderContext(this.context.context, true);\n\n    // recover original GroundShadow\n    this.groundShadow.detach(this.viewer);\n\n    // revert remapping of raycasts and getWorldpoint\n    this.unpatchRayCast();\n    this.unpatchCoordinateConversions();\n    this.unpatchWorldUp();\n\n    // reset camera to full horizontal fov\n    this.enabled = false;\n    this.handleResize();\n    this.viewer.removeEventListener(Autodesk.Viewing.VIEWER_RESIZE_EVENT, this.handleResize);\n\n    // recover visibility of incompatible controls\n    this.hideIncompatibleControls(false);\n    this.viewer.removeEventListener(Autodesk.Viewing.NAVIGATION_MODE_CHANGED_EVENT, this.onToolbarButtonsUpdated);\n};\n\n// Register the extension with the extension manager.\nAutodesk.Viewing.theExtensionManager.registerExtension(myExtensionName, SplitScreenExtension);\nnamespace.SplitScreenExtension = SplitScreenExtension;"],"sourceRoot":""}